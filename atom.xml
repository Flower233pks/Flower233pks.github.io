<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orchidany.cf/"/>
  <updated>2019-12-15T07:08:03.000Z</updated>
  <id>http://www.orchidany.cf/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>http://www.orchidany.cf/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-12-15T07:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-MMfOHaUJ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-MMfOHaUJ"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center">咕</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】闲谈</title>
    <link href="http://www.orchidany.cf/2019/12/15/%E9%97%B2%E6%89%AF/"/>
    <id>http://www.orchidany.cf/2019/12/15/闲扯/</id>
    <published>2019-12-15T07:29:19.000Z</published>
    <updated>2019-12-15T10:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>别名：一句话日记</del></p><p>可能就是用来随时记录自己感悟的东西？</p><a id="more"></a><p>12.15</p><p>upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。</p><p>新建了这个文档，本想写很多，结果突然发现自己WC都去不了。</p><p>然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;别名：一句话日记&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;可能就是用来随时记录自己感悟的东西？&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://www.orchidany.cf/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Manacher简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/Manacher%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/Manacher泛做/</id>
    <published>2019-12-15T07:26:25.000Z</published>
    <updated>2019-12-15T07:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>在？为啥不用PAM？</del></p><p>emm那可能是空间开不下（自我安慰</p><a id="more"></a><h1 id="1-LG1659-国家集训队-拉拉队排练"><a href="#1-LG1659-国家集训队-拉拉队排练" class="headerlink" title="$1$ LG1659 [国家集训队]拉拉队排练"></a>$1$ LG1659 [国家集训队]拉拉队排练</h1><blockquote><p>求前$k$大的奇数长度回文串的长度之积。</p><p>$\rm |S|\leq 1e6,K\leq 1e12$</p></blockquote><p>……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq</p><p>二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。</p><p>以下是错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L = <span class="number">-1</span> ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> x = ed[p], i ; </span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; p ; ++ i)</span><br><span class="line">ret += <span class="number">1l</span>l * ((ed[i] - ed[p] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret + (buc[ed[p]]) &gt;= K) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) buc[base[i] - <span class="number">1</span>] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i += <span class="number">2</span>) <span class="keyword">if</span> (buc[i]) ed[++ tot] = i ; </span><br><span class="line">reverse(ed + <span class="number">1</span>, ed + tot + <span class="number">1</span>) ; <span class="keyword">int</span> L = <span class="number">1</span>, R = tot, Mid, ans, pos = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">/*if (rand() % 2)</span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/</span></span><br><span class="line"><span class="keyword">if</span> (check(Mid)) ans = Mid, R = Mid - <span class="number">1</span> ; <span class="keyword">else</span> L = Mid + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line">pos = ans, res = <span class="number">1l</span>l, _up = ed[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ed[pos] ; i &lt;= ed[<span class="number">1</span>] ; i += <span class="number">2</span>) fact *= <span class="number">1l</span>l * i ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (ed[i] &lt; _up) fact /= _up, _up -= <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">if</span> ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span> &gt; K)&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K)</span><br><span class="line">res = res * <span class="number">1l</span>l * ed[i], ed[i] -= <span class="number">2</span>, ++ j ; </span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line">&#125; </span><br><span class="line">res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ;</span><br><span class="line">K -= <span class="number">1l</span>l * ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">if</span> (K &lt;= <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= <span class="number">1</span>) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i], id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">ans += buc[i] ; </span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= K)</span><br><span class="line">(res *= expow(i, ans)) %= Mod, K -= ans ; </span><br><span class="line"><span class="keyword">else</span> &#123; (res *= expow(i, K)) %= Mod, K -= ans ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。</p><h1 id="2-LG4555-国家集训队-最长双回文串"><a href="#2-LG4555-国家集训队-最长双回文串" class="headerlink" title="$2$ LG4555 [国家集训队]最长双回文串"></a>$2$ LG4555 [国家集训队]最长双回文串</h1><p>这题比第一题友善了很多。。。</p><blockquote><p>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。</p></blockquote><p>嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">int</span> i, id = <span class="number">0</span>, rt = <span class="number">0</span> ; ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(rt - i + <span class="number">1</span>, base[<span class="number">2</span> * id - i]) ;  </span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"><span class="keyword">if</span> (i + base[i] &gt; rt) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> l = i / <span class="number">2</span> - (base[i] / <span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> r = i / <span class="number">2</span> + (base[i] / <span class="number">2</span>) - <span class="number">1</span> ; <span class="keyword">if</span> (ns[i] == <span class="number">35</span>) ++ r ;</span><br><span class="line">Ls[r] = max(Ls[r], base[i] - <span class="number">1</span>), Rs[l] = max(Rs[l], base[i] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + <span class="number">1</span>]) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;在？为啥不用PAM？&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;emm那可能是空间开不下（自我安慰&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
  </entry>
  
  <entry>
    <title>【题解】PAM简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAM%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAM泛做/</id>
    <published>2019-12-15T07:23:16.000Z</published>
    <updated>2019-12-15T07:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都是简单的PAM习题</p><a id="more"></a><h1 id="1-LG5496-【模板】回文自动机"><a href="#1-LG5496-【模板】回文自动机" class="headerlink" title="$1$ LG5496 【模板】回文自动机"></a>$1$ LG5496 【模板】回文自动机</h1><blockquote><p>对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。</p><p>$|s|\leq 1e6$</p></blockquote><p>然后就是PAM的板子题<del>咋感觉好像没有不是很板的PAM题呢</del></p><p>考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移<br>$$<br>cnt_{p}=cnt_{fail_p}+1<br>$$<br>然后就没有然后了。</p><h1 id="2-APIO2014-回文串"><a href="#2-APIO2014-回文串" class="headerlink" title="$2$ [APIO2014]回文串"></a>$2$ [APIO2014]回文串</h1><blockquote><p>给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。</p><p>对于给你的这个字符串$s$，求所有回文子串中的最大存在值。</p><p>$|s|\leq 1e6$</p></blockquote><p>感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然<strong>“串的最长回文后缀唯一”</strong>的逆命题<strong>“任何串会唯一作为其他串的最长回文后缀”</strong>也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用<br>$$<br>\rm f_u=ctn_u+\sum_{v\in S(u)}f_v<br>$$<br>其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。</p><p>emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; i --) </span><br><span class="line">    P.f[P.pre[i]] += P.f[i], ans = max(ans, <span class="number">1l</span>l * P.len[i] * P.f[i]) ;</span><br></pre></td></tr></table></figure><p><del>哪那么多P话，就是背啊</del></p><h1 id="3-LG5555-秩序魔咒"><a href="#3-LG5555-秩序魔咒" class="headerlink" title="$3$ LG5555 秩序魔咒"></a>$3$ LG5555 秩序魔咒</h1><blockquote><p>求两个串的最长公共回文子串以及该长度的出现次数。</p><p>$\rm |S|,|T|\leq 10^6$</p></blockquote><p><del>恭喜发现一个新套路</del></p><p>观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ans == P.len[x]) res ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; P.len[x]) res = <span class="number">1</span>, ans = P.len[x] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By the way，奇根/偶根都要$dp$一次。</p><h1 id="4-JSOI2013-快乐的-JYY"><a href="#4-JSOI2013-快乐的-JYY" class="headerlink" title="$4$ [JSOI2013]快乐的 JYY"></a>$4$ [JSOI2013]快乐的 JYY</h1><blockquote><p>求两个串的不同公共回文串的个数，其中不同意思是下标不同。</p><p>$|s|,|t|\leq 10^6$</p></blockquote><p>……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x + y &gt; <span class="number">2</span>) ans += <span class="number">1l</span>l * P.f[x] * Q.f[y] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.Init(), Q.Init() ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Insert(S[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, S) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) Q.Insert(T[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, T) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">1</span>) ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans&lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-闲扯"><a href="#5-闲扯" class="headerlink" title="$5$ 闲扯"></a>$5$ 闲扯</h1><p>写模板题真是让人感到空虚……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是简单的PAM习题&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】PAM &amp; Manacher</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAMandManacher/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAMandManacher/</id>
    <published>2019-12-15T06:05:19.000Z</published>
    <updated>2019-12-15T06:18:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PAM &amp; Manacher，两种用来处理回文串的玩意儿。</p><a id="more"></a> <h1 id="1-Manacher"><a href="#1-Manacher" class="headerlink" title="$1$ Manacher"></a>$1$ Manacher</h1><p><del>挺短，背是挺好背的</del></p><p>Manacher用于求回文串长度。思想大概就是：</p><p>1、加入字符集之外的识别字符（比如<code>#</code>）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。</p><p>2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定<strong>至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$}</strong> 。然后就不断扩展即可。</p><p>3、关于复杂度证明。我们记<strong>一次帅气的操作</strong>的意义是<strong>成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$</strong>，记以当前点为轴的最长回文子串为$\rm T$，$T$的右端点为$q$。可以知道</p><ul><li>（1）$\rm S$的右端点是单增的；</li><li>（2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然<code>while</code>1次，$maxlen$增大一次；</li><li>（3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出<code>while</code>；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。</li></ul><p>So,最终复杂度就是$\Theta(n)$的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id, fars, i ; </span><br><span class="line">id = <span class="number">0</span>, fars = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line"><span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> <span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), </span><br><span class="line">L = <span class="number">-1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; Manacher(In) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) ans = max(ans, base[i] - <span class="number">1</span>) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-PAM"><a href="#2-PAM" class="headerlink" title="$2$ PAM"></a>$2$ PAM</h1><p>学了PAM，不知道为啥感觉比SAM简单？</p><p>其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下：</p><p>0、一个串的回文子串至多有$O(n)$个。</p><p>1、首先每个节点需要保存这个节点中回文串的长度。</p><p>2、显然始状态需要有两个，即奇数长度的$s$和偶数长度的$s$，称作<strong>“奇根”</strong>和<strong>“偶根”</strong>。那么为了方便呢，奇根的长度设置为$-1$，偶根长度设置为$0$。</p><p>3、考虑要从$last$指针扩展当前状态，假设当前需要<code>insert</code>的字母是$c$，是这个串里面的第$p$个字符，那我们需要找到一个后缀$s[j…p-1]\quad s.t.\quad s[j…p-1]$本身回文且$s[j-1]=c$，那么就可以向下扩展。</p><p>4、考虑怎么找这个后缀，显然对于一个串$S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的<strong>最长回文后缀</strong>。</p><p>5、插入新节点时，考虑跳完$fail$后如果没有相应的转移边，就要新建一个状态然后连$fail$.</p><p>然后是代码和一点注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line"><span class="keyword">int</span> rt0, rt1, last, sz ;</span><br><span class="line"><span class="keyword">int</span> len[MAXN], fail[MAXN] ;</span><br><span class="line">&#125;P ;</span><br><span class="line"><span class="keyword">void</span> _init(PAM &amp;p)&#123;</span><br><span class="line">p.sz = <span class="number">-1</span>, </span><br><span class="line">p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ;</span><br><span class="line">p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ;</span><br><span class="line">p.last = p.rt0, p.len[p.rt0] = <span class="number">0</span>, p.len[p.rt1] = <span class="number">-1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line"><span class="keyword">int</span> u = p.last ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line"><span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line"><span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line"><span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, </span><br><span class="line">&#125;</span><br><span class="line">p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn,</span><br></pre></td></tr></table></figure><p>原因是当$fa=u$时就出现环了。</p><h1 id="3-闲扯"><a href="#3-闲扯" class="headerlink" title="$3$ 闲扯"></a>$3$ 闲扯</h1><p>学完才知道，$\rm PAM$又简单又好背功能又多……Manacher被打爆了啊喂qwq。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PAM &amp;amp; Manacher，两种用来处理回文串的玩意儿。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PAM,回文自动机" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces前11场泛做</title>
    <link href="http://www.orchidany.cf/2019/11/15/cf1-11/"/>
    <id>http://www.orchidany.cf/2019/11/15/cf1-11/</id>
    <published>2019-11-14T23:34:18.000Z</published>
    <updated>2019-12-15T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq</p><a id="more"></a><h1 id="rm-CF·1C"><a href="#rm-CF·1C" class="headerlink" title="$\rm {CF·1C}$"></a>$\rm {CF·1C}$</h1><blockquote><p>求包含给定三点的正多边形最小面积。</p></blockquote><hr><p>先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。</p><p>之后对于该多边形，我们考虑，由于其让求的正多边形需要<strong>面积最小</strong>。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是<strong>该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍</strong></p><p>那么我们就做一个<code>double</code>类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。</p><p>最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-4</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.00000</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> mark ; <span class="comment">// 0 = exist, 1 = inexist ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">&#125;A, B, C, O, m1, m2, m3 ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ;<span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line">    <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; <span class="comment">// y = kx + b, x = k, y = k ;</span></span><br><span class="line">&#125;L[<span class="number">12</span>] ; <span class="keyword">double</span> Len[<span class="number">4</span>], agl[<span class="number">4</span>], R, angle ; <span class="keyword">int</span> i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is x = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is y = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_Mid</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.x + B.x) / <span class="number">2</span>, (A.y + B.y) / <span class="number">2</span> &#125; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_verti</span><span class="params">(Node n, Line a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.mark) <span class="keyword">return</span> (Line) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (a.mark == <span class="number">1</span>) <span class="keyword">return</span> (Line) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = <span class="number">-1.0</span> / a.k, bb = n.y - n.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_Line</span><span class="params">(Node A, Node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A. y == B. y) <span class="keyword">return</span> (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A. x == B. x) <span class="keyword">return</span> (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, A.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span><span class="params">(Line A, Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, get_x(A, B), get_y(A, B)&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.y - B.b) / B.k, A.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (B.y - A.b) / A.k, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, B.x, B.x * A.k + A.b&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, A.x, A.x * B.k + B.b&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">gcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; Eps) <span class="keyword">return</span> a ; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; Eps) <span class="keyword">return</span> b ; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, <span class="built_in">fmod</span>(a, b)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; </span><br><span class="line">  A.mark = B.mark = C.mark = <span class="number">0</span> ;</span><br><span class="line">    L[<span class="number">1</span>] = get_Line(A, B), L[<span class="number">2</span>] = get_Line(B, C), L[<span class="number">3</span>] = get_Line(A, C) ; </span><br><span class="line">  m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ;</span><br><span class="line">    L[<span class="number">4</span>] = get_verti(m1, L[<span class="number">1</span>]), L[<span class="number">5</span>] = get_verti(m2, L[<span class="number">2</span>]) ;</span><br><span class="line">  O = get_inter(L[<span class="number">4</span>], L[<span class="number">5</span>]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / <span class="number">3.0</span> ;</span><br><span class="line">    Len[<span class="number">1</span>] = dis(A, B), Len[<span class="number">2</span>] = dis(B, C), Len[<span class="number">3</span>] = dis(A, C) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) agl[i] = <span class="built_in">acos</span>(<span class="number">1</span> - Len[i] * Len[i] / (<span class="number">2</span> * R * R) ); </span><br><span class="line">    agl[<span class="number">3</span>] = <span class="number">2</span> * Pi - agl[<span class="number">1</span>] - agl[<span class="number">2</span>], angle = gcd(agl[<span class="number">3</span>], gcd(agl[<span class="number">1</span>], agl[<span class="number">2</span>])) ; <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (Pi * R * R * <span class="built_in">sin</span>(angle)) / angle) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·2B"><a href="#rm-CF·2B" class="headerlink" title="$\rm CF·2B$"></a>$\rm CF·2B$</h1><blockquote><p>给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走</p><p>以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾.</p><p>$n\leq 1,000$</p></blockquote><p>考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> &amp;N, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!N) &#123; zerox = i, zeroy = j ; <span class="keyword">return</span> <span class="number">1</span> ; &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ; <span class="keyword">while</span> (!(N % fac)) ++ res, N /= fac ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark, <span class="keyword">int</span> kind)</span></span>&#123; <span class="comment">//mark 1 : D, 2 : R ;</span></span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (kind == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mark) <span class="keyword">return</span> ; <span class="keyword">if</span> (mark == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"D"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp2)), dp2[<span class="number">1</span>][<span class="number">0</span>] = dp2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(dp5, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp5)), dp5[<span class="number">1</span>][<span class="number">0</span>] = dp5[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp2[i][j] = min(dp2[i - <span class="number">1</span>][j], dp2[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">1</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">2</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp5[i][j] = min(dp5[i - <span class="number">1</span>][j], dp5[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">2</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">5</span>)) ;</span><br><span class="line">    Ans = min(dp5[N][N], dp2[N][N]) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans &gt; <span class="number">1</span> &amp;&amp; zerox &amp;&amp; zeroy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zerox ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zeroy ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zerox + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zeroy + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  dp5[N][N] &gt; dp2[N][N] ? Print(N, N, <span class="number">0</span>, <span class="number">1</span>) : Print(N, N, <span class="number">0</span>, <span class="number">2</span>) ;</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·2C"><a href="#rm-CF-·2C" class="headerlink" title="$\rm CF ·2C$"></a>$\rm CF ·2C$</h1><blockquote><p>给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。</p></blockquote><p><del>咋又是计算几何啊</del></p><p>设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。</p><p>那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有$$\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}$$</p><p>稍微移一下项，就会有$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)} $$</p><p>那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。</p><p>事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可：</p><p>设比例系数为$k(k \geq 1)$, 那么：</p><p>$$<br>\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\\<br>\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2<br>$$</p><p>稍微移一下项就会得到<br>$$<br>(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0<br>$$</p><p>看起来有点儿长……</p><p>令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$</p><p>那么就会变成<br>$$<br>Ax^2 + Ay^2+ Cx + Dy+E = 0<br>$$<br>由于$A,C,D,E$都是常数，所以这是一个<strong>圆的一般方程。</strong></p><p>我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说<strong>当且仅当两个圆半径相等时，点$T$的轨迹是一条直线</strong>。其余的情况则是<strong>一个圆</strong>。</p><p>我们不妨先记这种<strong>到两个圆的圆心的距离成定比例的</strong>轨迹为两个圆的<strong>生成曲线</strong>。</p><p>那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要：</p><ul><li>$(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。</li><li>$(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}$$的点，我们需要判断对于圆$C$是否也满足<br>$$<br>\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}<br>$$</li><li>$(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。</li></ul><p>然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233</p><p>代码很繁琐233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-3</span> ; <span class="keyword">int</span> i ;<span class="comment">//以下的mark都是记录状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> xa, ya, xb, yb ; &#125; I[<span class="number">5</span>] ; </span><br><span class="line"><span class="comment">// 0 = inexist, 1 = exist*1, 2 = exist*2 ;</span></span><br><span class="line"><span class="comment">//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; &#125;L[<span class="number">12</span>] ; </span><br><span class="line"><span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ; <span class="comment">// 1 : circle ; 0 : Line ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r ;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, D, E ;</span><br><span class="line">    Circle <span class="keyword">friend</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> Circle &amp;A, <span class="keyword">const</span> Circle &amp;B)&#123;</span><br><span class="line">        <span class="keyword">return</span> (Circle)&#123;<span class="number">0</span>, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;C[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">double</span> ansx, ansy ; <span class="keyword">bool</span> check ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> A.mark &lt; B.mark ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is (x = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is (y = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disa</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); </span><br><span class="line">&#125;<span class="comment">//第一个点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disb</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); </span><br><span class="line">&#125;<span class="comment">//第二个点之间的距离</span></span><br><span class="line"><span class="comment">//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">Line_inter</span><span class="params">(Line A, Line B)</span></span>&#123;<span class="comment">//斜截式直线求交点（之前写的直接copy过来的）</span></span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) ) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, get_x(A, B), get_y(A, B), <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.y - B.b) / B.k, A.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (B.y - A.b) / A.k, B.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, B.x, B.x * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, A.x, A.x * B.k + B.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span> <span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//“生成曲线”求交点</span></span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">0</span> &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == <span class="number">0</span>))&#123;<span class="comment">//一条是直线，一个是圆</span></span><br><span class="line">        <span class="keyword">if</span> (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; <span class="comment">// B is a line ;</span></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span> + (B.C / B.D) * (B.C / B.D), del ;</span><br><span class="line">        <span class="keyword">double</span> c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ;</span><br><span class="line">        <span class="keyword">double</span> b = (A.C - B.C * A.D / B.D + <span class="number">2</span> * B.C * B.E /((B.D) * (B.D)) ) ; </span><br><span class="line">        <span class="keyword">if</span> ((del = (b * b - <span class="number">4</span> * a * c)) &lt; -Eps) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ; </span><br><span class="line">        <span class="comment">// printf("%lf %lf %lf %lf\n", a, b, c, del) ;</span></span><br><span class="line">        <span class="keyword">double</span> xa =  (-b + <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a), xb = (-b - <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a) ;</span><br><span class="line">        <span class="keyword">double</span> ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">return</span> (Node)&#123;<span class="number">2</span>, xa, ya, xb, yb&#125; ;<span class="comment">//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.mark &amp;&amp; !B.mark)&#123;</span><br><span class="line">        Line La, Lb ; <span class="comment">//两条都是直线，那么就直接转化成斜截式求。</span></span><br><span class="line">        <span class="keyword">if</span> (!A.C) La = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - A.E / A.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!A.D) La = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -A.E / A.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> La = (Line)&#123;<span class="number">2</span>, -A.C / A.D, -A.E / A.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (!B.C) Lb = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - B.E / B.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!B.D) Lb = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -B.E / B.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> Lb = (Line)&#123;<span class="number">2</span>, -B.C / B.D, -B.E / B.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">        <span class="keyword">return</span> Line_inter(La, Lb) ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (A.mark &amp;&amp; B.mark)&#123;</span><br><span class="line">        Circle C = A - B ; <span class="keyword">return</span> get_inter(C, A) ;</span><br><span class="line">        <span class="comment">//此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">make_rat</span><span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//rat = ratio[n.]比例；比率，用来求生成曲线的函数</span></span><br><span class="line">    <span class="keyword">double</span> _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; <span class="keyword">double</span> t ; </span><br><span class="line">    Ans.A = Ans.B = (_k2 - <span class="number">1</span>), </span><br><span class="line">  Ans.C = <span class="number">-2</span> * (_k2 * B.x - A.x), </span><br><span class="line">  Ans.D = <span class="number">-2</span> * (_k2 * B.y - A.y), </span><br><span class="line">    Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), </span><br><span class="line">  Ans.x = Ans.y = Ans.r = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (Ans.A != <span class="number">0</span>) </span><br><span class="line">      Ans.mark = <span class="number">1</span>, t = Ans.A, Ans.A /= t, </span><br><span class="line">  Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; </span><br><span class="line">  <span class="keyword">else</span> Ans.mark = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_for_Ans</span><span class="params">()</span></span>&#123;<span class="comment">//最后的结果，判断选哪个交点</span></span><br><span class="line">    sort(I + <span class="number">1</span>, I + <span class="number">3</span>, Comp) ;<span class="comment">//我闲的，方便一点</span></span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>].mark &lt;= <span class="number">1</span>) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> A1, A11, B1, B11 ;</span><br><span class="line">        I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]) ;</span><br><span class="line">        A1 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        A11 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        B1 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        B11 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        <span class="keyword">if</span> (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) </span><br><span class="line">          check = <span class="number">1</span> ;<span class="comment">//如果在误差范围内都不相等就说明无解。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> Ja = <span class="built_in">sin</span>(<span class="number">1</span> / A1), Jb = <span class="built_in">sin</span>(<span class="number">1</span> / B1) ;<span class="comment">//比较角的大小，通过sin来搞</span></span><br><span class="line">            <span class="keyword">if</span> (Ja &gt; Jb) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">          <span class="keyword">else</span> ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ;</span><br><span class="line">    C[<span class="number">4</span>] = make_rat(C[<span class="number">1</span>], C[<span class="number">2</span>]), </span><br><span class="line">  C[<span class="number">5</span>] = make_rat(C[<span class="number">2</span>], C[<span class="number">3</span>]), </span><br><span class="line">  C[<span class="number">6</span>] = make_rat(C[<span class="number">3</span>], C[<span class="number">1</span>]), </span><br><span class="line">    I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]), </span><br><span class="line">  I[<span class="number">2</span>] = get_inter(C[<span class="number">5</span>], C[<span class="number">6</span>]), </span><br><span class="line">  I[<span class="number">3</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">6</span>]) ; </span><br><span class="line">    <span class="comment">/*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!I[<span class="number">1</span>].mark || !I[<span class="number">2</span>].mark || !I[<span class="number">3</span>].mark) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'\n'</span>), <span class="number">0</span> ; </span><br><span class="line">  make_for_Ans() ; (!check) ? <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf"</span>, ansx, ansy) : <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·3B"><a href="#rm-CF·3B" class="headerlink" title="$\rm CF·3B$"></a>$\rm CF·3B$</h1><blockquote><p>有一辆载重量为$v$的货车， 准备运送两种物品。 </p><p>物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。</p><p>$n\leq 100,000\quad v\leq 1e9$</p></blockquote><p>其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。</p><p>$\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学）</p><p>有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ,val ;</span><br><span class="line">&#125; base1[MAXN], base2[MAXN] ; <span class="keyword">int</span> N, M, p, v, v1, v2, c ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ; <span class="keyword">int</span> tot1, tot2, t1, t2, i ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Data a, Data b)</span></span>&#123; <span class="keyword">return</span> a.val &gt; b.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="built_in">memset</span>(base1, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base1)) ; </span><br><span class="line">    <span class="built_in">memset</span>(base2, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base2)) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v) ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">1</span>) base2[++ tot2].val = v, base2[tot2].num = i ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*qwq*/</span>base1[++ tot1].val = v, base1[tot1].num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base1 + <span class="number">1</span>, base1 + tot1 + <span class="number">1</span>, Comp), </span><br><span class="line">    sort(base2 + <span class="number">1</span>, base2 + tot2 + <span class="number">1</span>, Comp) ;</span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp; <span class="number">1</span>) ans.pb(base1[<span class="number">1</span>].num), Ans += base1[<span class="number">1</span>].val, ++ t1, M -- ;</span><br><span class="line">    <span class="keyword">while</span> (M &gt; <span class="number">1</span>)&#123;<span class="comment">//此处&gt;1是选v=2时防止越界</span></span><br><span class="line">        v2 = base2[t2 + <span class="number">1</span>].val ;</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) <span class="keyword">break</span> ;</span><br><span class="line">        v1 = base1[t1 + <span class="number">1</span>].val + base1[t1 + <span class="number">2</span>].val ; </span><br><span class="line">        <span class="keyword">if</span> (t1 + <span class="number">2</span> &gt; tot1) v1 = base1[t1 + <span class="number">1</span>].val, c = <span class="number">1</span> ; <span class="keyword">else</span> c = <span class="number">2</span> ; </span><br><span class="line">        <span class="keyword">if</span> (v1 &gt;= v2)&#123;</span><br><span class="line">            Ans += v1 ; M -= c ;</span><br><span class="line">            rep(i, <span class="number">1</span>, c) ans.pb(base1[++ t1].num) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Ans += v2, M -= <span class="number">2</span>, ans.pb(base2[++ t2].num) ; </span><br><span class="line">    &#125;<span class="comment">//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp;&amp; t1 &lt; tot1) </span><br><span class="line">      Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; </span><br><span class="line">  <span class="keyword">if</span> (Ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) <span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="string">" "</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·4D"><a href="#rm-CF·4D" class="headerlink" title="$\rm{CF·4D}$"></a>$\rm{CF·4D}$</h1><blockquote><p>给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$</p><p>求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度<br>$n \leq 5,000$</p></blockquote><p>一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), f[i] = <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">if</span> (A &lt;= W || B &lt;= H) <span class="keyword">continue</span> ;</span><br><span class="line">      E[++ tot].w = A, E[tot].h = B, E[tot].num = i ;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(E + <span class="number">1</span>, E + tot + <span class="number">1</span>, Comp) ;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h)</span><br><span class="line">              <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                  f[i] = f[j] + <span class="number">1</span>, r[i] = j ;</span><br><span class="line">              &#125; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; ans) ans = f[i], End = i ;</span><br><span class="line">  <span class="keyword">while</span>(End) s.push(End), End = r[End] ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">while</span> (!s.empty()) <span class="built_in">cout</span> &lt;&lt; E[s.top()].num &lt;&lt; <span class="string">" "</span>, s.pop() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5C"><a href="#rm-CF·5C" class="headerlink" title="$\rm CF·5C$"></a>$\rm CF·5C$</h1><blockquote><p>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。</p><p>$n\leq 1,000,000$</p></blockquote><p>好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s ; </span><br><span class="line"><span class="keyword">int</span> N, dp[MAXN], f[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) s.push(i)<span class="comment">/*, cout &lt;&lt; "qwq" &lt;&lt; endl */</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s.empty()) base[s.top()] = base[i] = <span class="number">1</span>, s.pop() ; </span><br><span class="line">    &#125; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (base[i]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span> ; <span class="keyword">else</span> dp[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      f[i] = max(f[i - <span class="number">1</span>], dp[i]) ; <span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">  <span class="keyword">int</span> maxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dp[i] == f[N]) ++ ans ; <span class="built_in">cout</span> &lt;&lt; (f[N] ? ans : <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5D"><a href="#rm-CF·5D" class="headerlink" title="$\rm CF·5D$"></a>$\rm CF·5D$</h1><blockquote><p>有一个长度为$l$的道路，你的加速是$a$。</p><p>从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。</p><p>$w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。</p></blockquote><p>高中物理模拟题？？</p><p>其实就是分类讨论一下就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> mark ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span> ; </span><br><span class="line"><span class="keyword">double</span> x_1, x_2, ans, x ;</span><br><span class="line"><span class="keyword">double</span> vnow, a, vmax, L, D, vmaxd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; a) swap(a, b) ;</span><br><span class="line"><span class="keyword">return</span> ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">0.5</span> * (<span class="number">2</span> * a * D + vmaxd * vmaxd)) ; </span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmax) vnow = vmax, mark = <span class="number">1</span> ;</span><br><span class="line">x_1 = vnow * vnow / <span class="number">2</span> / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;</span><br><span class="line"><span class="comment">//if (!mark)&#123;</span></span><br><span class="line">ans += vnow / a + (vnow - vmaxd) / a ; </span><br><span class="line"><span class="keyword">if</span> (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ;</span><br><span class="line"><span class="comment">/*&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment">ans += vnow / a + (vnow - vmaxd) / a ;</span></span><br><span class="line"><span class="comment">x = ans += x / vnow ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmax, x = vnow * vnow / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L || equal(x, L))&#123;</span><br><span class="line">ans = vnow / a, ans += (L - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * L) ;</span><br><span class="line">ans = vnow / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = (vmax * vmax - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L - D || equal(x, L - D))&#123;</span><br><span class="line">ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmaxd, x = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * (L - D) + vnow * vnow) ;</span><br><span class="line">ans += (x - vnow) / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5E"><a href="#rm-CF·5E" class="headerlink" title="$\rm CF·5E$"></a>$\rm CF·5E$</h1><blockquote><p>有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。</p><p>$n\leq 100,000$</p></blockquote><p>一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; ++ i) <span class="built_in">stack</span>[i] = Mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">init(M), ans = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i, tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line"><span class="keyword">while</span> (tp &amp;&amp; <span class="built_in">stack</span>[tp].first &lt; base[i]) </span><br><span class="line">      ans += <span class="built_in">stack</span>[tp].second, -- tp ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>[tp].first != base[i])  </span><br><span class="line">ans += (tp &gt; <span class="number">0</span>), <span class="built_in">stack</span>[++ tp] = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">else</span> ans += (tp &gt; <span class="number">1</span>) + <span class="built_in">stack</span>[tp].second, ++ <span class="built_in">stack</span>[tp].second ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i + N] = base[i] = qr() ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; St, Ed ;</span><br><span class="line">St = Mp(<span class="number">-1</span>, <span class="number">0</span>), Ed = Mp(<span class="number">-1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (St.first &lt; base[i]) </span><br><span class="line">      Ed = St, St = Mp(base[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (St.first == base[i]) ++ St.second ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Ed.first &lt; base[i]) Ed = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ed.first == base[i]) ++ Ed.second ;</span><br><span class="line">&#125;</span><br><span class="line">Ans = Solve(<span class="number">2</span> * N) - Solve(N),</span><br><span class="line">  Ans -= (St.second * St.second + ((St.second == <span class="number">1</span>) ? Ed.second : <span class="number">0</span>)), </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·6D"><a href="#rm-CF·6D" class="headerlink" title="$\rm CF·6D$"></a>$\rm CF·6D$</h1><blockquote><p>有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。</p><p>不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。</p><p>$n\leq 10$</p></blockquote><p>看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, a, b, blood[MAXN], i, j, k, l ; </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; From[MAXN][MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">Print(step - <span class="number">1</span>, From[step + <span class="number">1</span>][jj][kk].first, From[step + <span class="number">1</span>][jj][kk].second) ;</span><br><span class="line"><span class="keyword">int</span> tow = dp[step][From[step + <span class="number">1</span>][jj][kk].first][From[step + <span class="number">1</span>][jj][kk].second] ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">1</span> ; qwq &lt;= dp[step + <span class="number">1</span>][jj][kk] - tow ; ++ qwq) <span class="built_in">printf</span>(<span class="string">"%d "</span>, step) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; a &gt;&gt; b ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; blood[i], ++ blood[i] ;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">2</span>][blood[<span class="number">1</span>]][blood[<span class="number">2</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= blood[i - <span class="number">1</span>] ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= blood[i] ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> down_ = (j + b - <span class="number">1</span>) / b ;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j][k] &gt; INF) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">int</span>up_ = max(down_, max((blood [i + <span class="number">1</span>] + b - <span class="number">1</span>) / b, (k + a - <span class="number">1</span>) / a)) ;</span><br><span class="line"><span class="keyword">for</span> (l = down_ ; l &lt;= up_ ; ++ l)&#123;</span><br><span class="line"><span class="keyword">int</span> now_j = max(<span class="number">0</span>, k - a * l) ;</span><br><span class="line">          <span class="keyword">int</span> now_k = max(<span class="number">0</span>, blood[i + <span class="number">1</span>] - b * l) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i + <span class="number">1</span>][now_j][now_k] &gt; dp[i][j][k] + l)</span><br><span class="line">dp[i + <span class="number">1</span>][now_j][now_k] = dp[i][j][k] + l, </span><br><span class="line">          From[i + <span class="number">1</span>][now_j][now_k] = Mp(j ,k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; Print(N - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·6E"><a href="#rm-CF-·6E" class="headerlink" title="$\rm CF ·6E$"></a>$\rm CF ·6E$</h1><blockquote><p>给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。</p><p>$n\leq 100,000$</p></blockquote><p>憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233</p><p>值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。</p><p>然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, h1 = <span class="number">1</span>, t1 = <span class="number">0</span>, h2 = <span class="number">1</span>, t2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ;</span><br><span class="line">  <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ;</span><br><span class="line">  q[++ t1] = p[++ t2] = i ; </span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123;</span><br><span class="line">  l ++ ; <span class="keyword">while</span> (q[h1] &lt; l) ++ h1 ; <span class="keyword">while</span> (p[h2] &lt; l) ++ h2 ;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, s[i] - s[l - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是二分$st$表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_ST</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> H = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= H ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) &lt;= N + <span class="number">1</span> ; ++ i)</span><br><span class="line">dp1[i][j] = max(dp1[i][j - <span class="number">1</span>], dp1[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]), </span><br><span class="line">dp2[i][j] = min(dp2[i][j - <span class="number">1</span>], dp2[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> max(dp1[l][k - <span class="number">1</span>], dp1[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> min(dp2[l][k - <span class="number">1</span>], dp2[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">dp1[i][<span class="number">0</span>] = dp2[i][<span class="number">0</span>] = base[i] = qr() ;</span><br><span class="line">build_ST(), ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">L = i, R = N ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (query_max(i, Mid) - query_min(i, Mid) &lt;= K) </span><br><span class="line">t = Mid, L = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> R = Mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">L = t ;</span><br><span class="line"><span class="keyword">if</span> (L - i + <span class="number">1</span> &gt; ans) ans = L - i + <span class="number">1</span>, Ans[cnt = <span class="number">1</span>][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (L - i + <span class="number">1</span> == ans) Ans[++ cnt][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i][<span class="number">0</span>], Ans[i][<span class="number">1</span>]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·7C"><a href="#rm-CF·7C" class="headerlink" title="$\rm CF·7C$"></a>$\rm CF·7C$</h1><blockquote><p>给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。</p></blockquote><p>sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq</p><h1 id="rm-CF·7D"><a href="#rm-CF·7D" class="headerlink" title="$\rm CF·7D$"></a>$\rm CF·7D$</h1><blockquote><p>一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，<code>abaaba</code>是3阶字符串。</p><p>现在给定你一字符串，请你求出其所有前缀的的阶级之和。</p><p>$|\sf S|\leq 5,000,000$</p></blockquote><p>似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么<br>$$<br>f_i=[\quad H[1…\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1…i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)<br>$$</p><p>答案就是$\sum f_i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">131</span> ;<span class="keyword">bool</span> mark[MAXN] ;</span><br><span class="line"><span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> N, Ans, i, j, h, ans[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1[MAXN], base2[MAXN], times[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">times[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base1[i] = (base1[i - <span class="number">1</span>] * base + S[i]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base2[i] = (base2[i - <span class="number">1</span>] * base + S[N - i + <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) times[i] = times[i - <span class="number">1</span>] * base % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), init() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">h = i / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t1 = base1[h] % Mod ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ;</span><br><span class="line">ans[i] = (t1 == t2) * (ans[h] + <span class="number">1</span>),  Ans += ans[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·8C"><a href="#rm-CF·8C" class="headerlink" title="$\rm CF·8C$"></a>$\rm CF·8C$</h1><blockquote><p>平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。</p></blockquote><p>我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN], Pre[MAXN], Max ;</span><br><span class="line"><span class="keyword">int</span> N, D[<span class="number">50</span>][<span class="number">50</span>], i, j, k, bit[<span class="number">50</span>], tp ; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Obj[<span class="number">50</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Obj[<span class="number">0</span>].fr &gt;&gt; Obj[<span class="number">0</span>].sc &gt;&gt; N ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; ++ j)</span><br><span class="line">D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) </span><br><span class="line">      + (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ;</span><br><span class="line">Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i) dp[i] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit)), tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) bit[++ tp] = j + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= tp ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tp ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j != k)&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]], </span><br><span class="line">          Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>], </span><br><span class="line">        Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &lt; <span class="number">1061109567</span>) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[Max] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">while</span> (Max)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">int</span> qaq = Max ^ Pre[Max] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; qaq) <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">Max = Pre[Max] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·9D"><a href="#rm-CF·9D" class="headerlink" title="$\rm CF·9D$"></a>$\rm CF·9D$</h1><blockquote><p>用$n$个点组成二叉树，问高度大于等于$h$的有多少个。</p><p>$n\leq 35$</p></blockquote><p>没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; H ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; j ; ++ k)</span><br><span class="line">dp[j][i] += dp[k][i - <span class="number">1</span>] * dp[j - k - <span class="number">1</span>][i - <span class="number">1</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][N] - dp[N][D - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10C"><a href="#rm-CF·10C" class="headerlink" title="$\rm CF·10C$"></a>$\rm CF·10C$</h1><blockquote><p>定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$</p><p>现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。</p><p>$N\leq 1000000$</p></blockquote><p>考虑$d()$的本质：<br>$$<br>d(x)=\left{\begin{array}{ll}{x \bmod 9,} &amp; {x \bmod 9 \neq 0} \ {9,} &amp; {x \bmod 9=0}\end{array}\right.<br>$$<br>那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。</p><p>那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, base[<span class="number">20</span>], A, B, i, j ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i % <span class="number">9</span>] ++, B += N / i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">A += base[i] * base[j] * base[i * j % <span class="number">9</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A - B &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10D"><a href="#rm-CF·10D" class="headerlink" title="$\rm CF·10D$"></a>$\rm CF·10D$</h1><blockquote><p>求两个串的最长公共上升子序列。</p><ul><li><p>$n\leq 500$</p></li><li><p>$n\leq 5,000$</p></li></ul></blockquote><p>第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">if</span> (base1[i] != base2[j]) <span class="keyword">continue</span> ;</span><br><span class="line">dp[i][j] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt; j ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][k] + <span class="number">1</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, f[j] = k ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。</p><p>于是最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">dfs(pre[x]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, n = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (N = qr(), i = <span class="number">1</span> ; i &lt;= N ; ++ i) A[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (M = qr(), i = <span class="number">1</span> ; i &lt;= M ; ++ i) B[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, befo = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] != B[j]) f[i][j] = f[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">else</span> f[i][j] = res + <span class="number">1</span>, pre[j] = befo ;</span><br><span class="line"><span class="keyword">if</span> (B[j] &lt; A[i]) </span><br><span class="line"><span class="keyword">if</span> (res &lt; f[i - <span class="number">1</span>][j]) </span><br><span class="line">res = f[i - <span class="number">1</span>][j], befo = j ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (ans &lt; f[N][i]) ans = f[N][i], n = i ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; dfs(n) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11C"><a href="#rm-CF·11C" class="headerlink" title="$\rm CF·11C$"></a>$\rm CF·11C$</h1><blockquote><p>你有一个$01$矩阵。里面有多少个正方形？</p><p>其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣：</p><p>第一种：每条边与矩阵的边平行的正方形；</p><p>第二种：每条边与矩阵的对角线平行的正方形。</p><p>$t\leq 10,000\quad 2\leq n,m\leq 250$</p></blockquote><p>然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base[x][y] != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    base[x][y] = <span class="number">-1</span>, ++ step ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &gt;= <span class="number">1</span> &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= <span class="number">1</span> &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + step &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + i][y] != <span class="number">-1</span>) | (base[x][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + step][y + i] != <span class="number">-1</span>) | (base[x + i][y + step] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = step &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x + lx &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (base[x + lx][y] != <span class="number">-1</span> || y &lt; step) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + lx - i][y - i] != <span class="number">-1</span>) | (base[x + lx - i][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + i][y - i] != <span class="number">-1</span>) | (base[x + i][y + i] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][j] != <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                res = <span class="number">0</span>, dfs(i, j, res) ;</span><br><span class="line">                <span class="keyword">if</span> (res % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; res / <span class="number">4</span> &lt;= min(N, M))</span><br><span class="line">                    ans += chk1(res / <span class="number">4</span>, i, j) + chk2(res / <span class="number">4</span>, i, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11D"><a href="#rm-CF·11D" class="headerlink" title="$\rm CF·11D$"></a>$\rm CF·11D$</h1><blockquote><p>求简单无向图的环数。</p><p>$n\leq 19$</p></blockquote><p>一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。</p><p>观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从<code>lowbit</code>转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M, Mx = (1 &lt;&lt; N) - 1 ;</span><br><span class="line">for (i = 1, j = 0 ; j &lt; N ; ++ j, i &lt;&lt;= 1) f[i][j] = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] = A[v][u] = 1 ;</span><br><span class="line">for (s = 1 ; s &lt;= Mx ; ++ s)&#123;</span><br><span class="line">    for (i = 0 ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ;</span><br><span class="line">        for (j = 0 ; j &lt; N ; ++ j)&#123;</span><br><span class="line">            if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ;</span><br><span class="line">            if ((1 &lt;&lt; j) == low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans += f[s][i] ;</span><br><span class="line">            else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] += f[s][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codefoces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codefoces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数学/扩展欧几里得" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="计算几何/基础的点、直线与圆" scheme="http://www.orchidany.cf/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%9F%BA%E7%A1%80%E7%9A%84%E7%82%B9%E3%80%81%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%9C%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-840 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-840/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-840/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。</p><p>但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。</p><p>$n\leq 10^5$</p></blockquote><p>刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的……</p><p>然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）<br>$$<br>\begin{aligned}<br>F(n,k)&amp;=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\\&amp;=\frac{n+1}{k+1}<br>\end{aligned}<br>$$<br>然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。</p><p>你需要选出一些边（不一定联通），使得这些边构成的图符合要求。</p><p>$n\leq 3\cdot 10^5$</p></blockquote><p>首先考虑如果没有<code>-1</code>并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。</p><p>发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。</p><p>然后分类讨论：<code>0</code>的点和<code>1</code>的点</p><ul><li><code>0</code>的点。直接忽略，因为不产生影响；</li><li><code>1</code>的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。</li></ul><p>于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span> ; <span class="keyword">int</span> ret = base[u] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ST(to(k))) </span><br><span class="line">      res[++ tot] = (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ret ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (base[u] &lt; <span class="number">0</span>) ret = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), </span><br><span class="line">  (base[i] &lt; <span class="number">0</span>) ? mr1 = i : (mr2 ^= base[i]) ;</span><br><span class="line"><span class="keyword">if</span> (!mr1 &amp;&amp; mr2) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">ST(mr1 ? mr1 : <span class="number">1</span>) ;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  sort(res + <span class="number">1</span>, res + tot + <span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。</p></blockquote><p>考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$后，两个数相同时，其乘积才会为完全平方数。</p><p>那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。</p><p>那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$<br>$$<br>f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll d, ll z)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (z)&#123;</span><br><span class="line"><span class="keyword">if</span> (z &amp; <span class="number">1</span>) (res *= d) %= Mod ;</span><br><span class="line">( d *= d ) %= Mod, z &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i] ; <span class="keyword">bool</span> mk = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">ll p = trunc(<span class="built_in">sqrt</span>(base[i] * grp[j])) ;</span><br><span class="line"><span class="keyword">if</span> (p * p == base[i] * grp[j])&#123;++ tm[j], mk = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mk) grp[++ cnt] = base[i], tm[cnt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span> (Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (Frac[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; tot += tm[i], ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= tot ; ++ j) </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tm[i] ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --)</span><br><span class="line"><span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt; N) </span><br><span class="line">            (dp[i][t] += </span><br><span class="line">             Frac[tm[i]] * Cm[tm[i] - <span class="number">1</span>][k - <span class="number">1</span>] % Mod </span><br><span class="line">           * Cm[j][l] % Mod * Cm[tot - j + <span class="number">1</span>][k - l] % Mod </span><br><span class="line">           * dp[i - <span class="number">1</span>][j] % Mod) %= Mod ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[cnt][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>这个D曾经单独写过：<a href="http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/">Link</a></p><p>233反正就是乱搞就对了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-711 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-711/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-711/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个马来西亚老哥出的一场<code>Div2</code>，题目还算有点意思，于是就virtual了后三个题。</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。</p><p>$n,m\leq 100$</p></blockquote><p>一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= K ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= M ; ++ k)</span><br><span class="line">dp[i][j][k] = Inf ; </span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = i - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*/</span></span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">if (j &gt;= pos[i])&#123;</span></span><br><span class="line"><span class="comment">for (k = 1 ; k &lt;= M ; ++ k)</span></span><br><span class="line"><span class="comment">for (l = 1 ; l &lt;= M ; ++ l)</span></span><br><span class="line"><span class="comment">for (w = 1 ; w &lt;= K ; ++ w)</span></span><br><span class="line"><span class="comment">if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (base[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[<span class="number">1</span>][<span class="number">1</span>][i] = val[<span class="number">1</span>][i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (!base[i])&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)&#123;</span><br><span class="line">dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k] + val[i][k]);</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= M ; ++ l)</span><br><span class="line"><span class="keyword">if</span> (k != l) </span><br><span class="line">             dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][l] + val[i][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j][base[i]]) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k )</span><br><span class="line"><span class="keyword">if</span> (k != base[i]) </span><br><span class="line">           dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Ans = Inf, i = <span class="number">1</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (Ans == Inf ? - <span class="number">1</span> : Ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 </p><p>每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环</p></blockquote><p>一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。</p><p>好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>, base = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep, vis[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), deep + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)] &lt;= <span class="number">1</span>) rop[++ tot] = dep[u] - dep[to(k)] + <span class="number">1</span> ;</span><br><span class="line"> &#125;</span><br><span class="line">vis[u] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, Ans = <span class="number">1</span> ; <span class="keyword">int</span> qaq ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qaq), Add(i, qaq) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> ( !dep[i] ) dfs(i, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) </span><br><span class="line">    cnt += rop[i], (Ans *= (expow(rop[i]) - <span class="number">2</span> + Mod)) %= Mod ;</span><br><span class="line">Ans = Ans * expow(N - cnt) % Mod ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。</p><p>$n,k\leq 10^{18},\rm Mod=1e6+3$</p></blockquote><p>首先考虑答案就是<br>$$<br>\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}<br>$$<br>然后就变成了如果把这个东西求出来<del>传统艺能.jpg</del></p><p>1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。</p><p>2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来</p><p>3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$.</p><p>4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到<br>$$<br>\begin{aligned}<br>(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&amp;=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\ &amp;=(\prod\limits_{i=1}^{k}i,2^n)\ &amp;=(k!,2^n)<br>\end{aligned}<br>$$</p><p>再结合抽屉原理，只需要枚举$2$的幂就可以算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; ll Son, Mom ;</span><br><span class="line">ll N, M, Inv, _gcd, qwq, i, base = <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= Mod ;</span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">base &lt;&lt;= <span class="number">1</span> ; <span class="keyword">if</span> (base &gt;= M) &#123; ans = <span class="number">0</span> ; <span class="keyword">break</span> ;&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1 1"</span>), <span class="number">0</span> ;  Son = <span class="number">1</span> ;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M - <span class="number">1</span> ; i &lt;&lt;= <span class="number">1</span>) qwq += (M - <span class="number">1</span>) / i ;  </span><br><span class="line">_gcd = expow(<span class="number">2</span>, qwq), </span><br><span class="line">  Inv = expow(_gcd, Mod - <span class="number">2</span>) ; </span><br><span class="line">  Mom = expow(<span class="number">2</span>, N  % (Mod - <span class="number">1</span>) * (M - <span class="number">1</span>) % (Mod - <span class="number">1</span>)) ;</span><br><span class="line">  (Mom *= Inv) %= Mod ; </span><br><span class="line">  <span class="keyword">if</span> (M - <span class="number">1</span> &gt;= Mod) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, Mom, Mom), <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; M ; ++ i) </span><br><span class="line">    Son = Son * (expow(<span class="number">2</span>, N) - i + Mod) % Mod ; </span><br><span class="line">  (Son *= Inv) %= Mod, </span><br><span class="line">  Son = ((Mom - Son) % Mod + Mod) % Mod ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Son &lt;&lt; <span class="string">" "</span> &lt;&lt; Mom &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个马来西亚老哥出的一场&lt;code&gt;Div2&lt;/code&gt;，题目还算有点意思，于是就virtual了后三个题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E2</title>
    <link href="http://www.orchidany.cf/2019/11/14/xiaone-2/"/>
    <id>http://www.orchidany.cf/2019/11/14/xiaone-2/</id>
    <published>2019-11-14T01:59:40.000Z</published>
    <updated>2019-12-15T06:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛第二弹</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>$𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 </p></blockquote><p>性质题，找不出来人似乎就没了233</p><p>考虑最优情况下肯定会是<strong>单调地跳</strong>，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。</p><p>小$c$开始了漫长的<code>debug</code>的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。</p><p>等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出<code>NO</code></p></blockquote><p>题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。</p><p>我也是贪心做的，不过是正着做的。没有限制时，如果上一个是<code>(</code>，那我这一个就安排成<code>)</code>就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是<code>()(</code>这样，第三个括号被强制为右括号，就顺便把前一个右括号改成<code>(</code>，即变为<code>(()</code>，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; M, i = <span class="number">1</span> ; i &lt;= M ; ++ i) ok[qr()] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (ok[i] &amp;&amp; !stk[base[i]].size())&#123;</span><br><span class="line">ans[i] = <span class="number">1</span> ; </span><br><span class="line">stk[base[i]].pb(mat[buc[base[i]]]) ;</span><br><span class="line">ans[i] = <span class="number">1</span>, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = <span class="number">0</span> ;</span><br><span class="line">mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> mat[i] = stk[base[i]].back(), ans[i] = <span class="number">1</span>, </span><br><span class="line"> mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (!ans[i]) <span class="built_in">stack</span>[++ t] = i ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">stack</span>[t --] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%d "</span>, ans[i] ? <span class="string">'-'</span> : <span class="string">'+'</span>, base[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个${a}$的子集来凑出$x$。同时，求最小$|{a}|$下凑出所有$x$的方案总数。</p></blockquote><p>第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。</p><p>第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ .</p><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。</p><p>JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。</p></blockquote><p><del>质疑题面在恰饭</del></p><p>一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。</p><p>然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。</p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。</p><p>$n,q\leq 100,000$</p></blockquote><p>一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。</p><p>考虑推式子<br>$$<br>\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\\<br>x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\\<br>y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}<br>$$<br>然后如果我们令$val_i=y\cdot A_i-x \cdot  B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去<code>uoj</code>群里问了一圈发现这个被<code>lxl</code>规约到了$n \sqrt n$的问题上面……</p><p>然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了<code>100ms~6500ms</code>这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。</p><p>然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? </span><br><span class="line">        blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇数块正着排，偶数块倒着排，就会快好多。</p><p>然后最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写了一下午QAQ</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[MAXN] ; <span class="keyword">int</span> l, r, buc[MAXM], val[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> blg[MAXN], T[MAXM &lt;&lt; <span class="number">2</span>], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, X, Y, M, S, U, base[MAXN], cnt[<span class="number">2</span>][MAXM], pre[MAXN][<span class="number">2</span>], res, res2 ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> T[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R, p, v) ;</span><br><span class="line">    T[rt] = max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">0</span>][val[p]]) cnt[<span class="number">0</span>][val[p]] = Nxt[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">1</span>][val[p]]) cnt[<span class="number">1</span>][val[p]] = Pre[p] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;<span class="comment">// cout &lt;&lt; T[1] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">0</span>][val[p]] = min(cnt[<span class="number">0</span>][val[p]], p) ;</span><br><span class="line">    cnt[<span class="number">1</span>][val[p]] = max(cnt[<span class="number">1</span>][val[p]], p) ;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        base[i] = s[i] - <span class="string">'A'</span>,</span><br><span class="line">        pre[i][base[i]] = pre[i - <span class="number">1</span>][base[i]] + <span class="number">1</span>,</span><br><span class="line">        pre[i][base[i] ^ <span class="number">1</span>] = pre[i - <span class="number">1</span>][base[i] ^ <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][<span class="number">0</span>] - X * pre[i][<span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">-1</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i &gt;= <span class="number">0</span> ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + <span class="number">1</span>, buc[val[i]] = i ;</span><br><span class="line">    M = qr() ; S = <span class="built_in">pow</span>(M, <span class="number">0.5832</span>) ; U = <span class="built_in">ceil</span>((<span class="keyword">double</span>)M / S) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">0</span>], <span class="number">63</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">1</span>], <span class="number">-1</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = (i - <span class="number">1</span>) * S + <span class="number">1</span> ; j &lt;= i * S ; ++ j) blg[j] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) q[i].l = qr() - <span class="number">1</span>, q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + M + <span class="number">1</span>, comp) ; l = <span class="number">0</span>, r = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) upd(++ r) ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) upd(-- l) ;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">        ans[q[i].id] = res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233</p><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote><p>你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。</p><p>算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。</p><p>你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了）</p><p>然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。</p><p>现在，你需要求出完成上述一系列动作走过的最短路程。</p><p>$n \leq 20$</p></blockquote><p>一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。</p><p>然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个<code>floyd</code>，然后每次的代价就是</p><p>$$<br>\mathsf{\min _{x\in S,y\in T}(f_{S,x}+dis_{x,y}+g_{T,y})+\min _{x\in S,y\in T}(g_{S,x}+dis_{x,y}+f_{T,y}})<br>$$</p><p>然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[MAXS][MAXN], pre[MAXS][<span class="number">2</span>], sz[MAXS], ans ;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, ans = Inf ;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span> (f)) ; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) dis[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= E ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; k &gt;&gt; o,</span><br><span class="line">        A[j][k] = A[k][j] = o,</span><br><span class="line">        dis[j][k] = dis[k][j] = o ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span> * (dis[<span class="number">0</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>])), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][now] = min(f[i][now], f[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ; g[<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)][N - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)) + <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> g[i][now] = min(g[i][now], g[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; g[M][1] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] != N / <span class="number">2</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> stA = i, stB = (~i &amp; M), res = Inf, fg = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stA)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stB) </span><br><span class="line">res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//        if (!fg) res = 0 ;</span></span><br><span class="line">stB ^= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>), stB |= <span class="number">1</span> ;</span><br><span class="line">stA ^= <span class="number">1</span>, stA |= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stB)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;</span><br><span class="line"><span class="comment">//if (!fg) ans *= 2 ;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校内模拟赛第二弹&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="校内模拟赛" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数据结构/线段树" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 2</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-15T06:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要就是整理一下dsu on tree的进阶版习题。</p><a id="more"></a><h1 id="0x01-rm-Cf375D-Tree-and-Queries"><a href="#0x01-rm-Cf375D-Tree-and-Queries" class="headerlink" title="$0x01$ $\rm Cf375D$  Tree and Queries"></a>$0x01$ $\rm Cf375D$  Tree and Queries</h1><blockquote><p>给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 </p></blockquote><p>考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，<code>calc</code>到每个点的时候先<code>del</code>掉原来的再<code>upd</code>新的信息……然后就做完了233</p><p>然而一开始的时候我调了好久，因为我是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] -- ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _count(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)&#123;</span><br><span class="line"><span class="keyword">bool</span> fg = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!chk[base[u]]) </span><br><span class="line">chk[base[u]] = <span class="number">1</span>, </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, val), fg = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; </span><br><span class="line"><span class="keyword">if</span> (!fg) chk[base[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_do(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_del(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很对的亚子，但是错就错在<strong>必须每个点独立计算完贡献才能考虑下一个点</strong>，否则下一个点的信息就是错误的——也就是说不能整体<code>del</code>再整体<code>upd</code>，必须逐个逐个的<code>del</code>和<code>upd</code>。。然而事实上关键问题还是在$buc$的统计上出了问题233</p><p>于是最后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] ++ ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] -- ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(query(<span class="number">1</span>, <span class="number">1</span>, N, qs[u][k] + <span class="number">1</span>, N)) ;</span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths"><a href="#0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths" class="headerlink" title="$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"></a>$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</h1><blockquote><p> 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 </p></blockquote><p>似乎是<code>Cf570D</code>的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的：</p><blockquote><p>我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数</p></blockquote><p>然后就是考虑怎么维护这个东西。</p><ul><li><p>不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$.</p></li><li><p>经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。</p></li></ul><p>看上去应该这么实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">f[dis[u]] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> &amp; ans, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans = max(ans, f[dis[u]] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans = max(ans, f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>), ans[u] = max(ans[u], ans[to(k)]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span>, </span><br><span class="line">ans[u] = max(ans[u], ans[son[u]]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != fa) </span><br><span class="line">calc(to(k), u, ans[u], dep[u]), update(to(k), u) ;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u]] - dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] - dep[u]) ;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。</p><p>唔，感觉这个题还是比较有技巧性的233</p><h1 id="0x03-rm-NOIP2018-模拟-·-树"><a href="#0x03-rm-NOIP2018-模拟-·-树" class="headerlink" title="$0x03$ $\rm NOIP2018$模拟 · 树"></a>$0x03$ $\rm NOIP2018$模拟 · 树</h1><p>这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：<a href="https://www.luogu.org/problem/U92408" target="_blank" rel="noopener">$\rm Link$</a></p><p>题面：</p><blockquote><p>给定一棵树。</p><p>令$[L,R]$描述的是序号在$[L,R]$内的点的集合。</p><p>同时，令函数$\boldsymbol F({ \rm S})$表示令集合$\rm S$内的点联通的需要的最小边数。</p><p>问题则是求：</p><p>$$<br>\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])<br>$$</p><p>$n\leq 100,000$</p></blockquote><hr><p>一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。</p><p>子树内的比较容易维护，考虑假设现在有了${1,2,3},{5,6}$两个集合，将其视作两个连通块，当加进来${4}$时，会和左右都相连接，不妨假设先与${1,2,3}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用<strong>并查集+并查集的$size$</strong>来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。</p><p>之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的<code>ans_out</code>显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，<code>set</code>里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了<br>$$<br>calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)<br>$$<br>原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。</p><p>所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], op[MAXN] ;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span> ; &#125;</span><br><span class="line"><span class="keyword">void</span> _clear()&#123;</span><br><span class="line">s.clear() ;</span><br><span class="line">ansout = calc(N), ansin = <span class="number">0</span>, </span><br><span class="line">s.insert(<span class="number">0</span>), s.insert(N + <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> x == fr[x] ? x : fr[x] = _find(fr[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">s.insert(u) ; op[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; :: iterator l, r, mid ;</span><br><span class="line">l = r = mid = s.find(u), l --, r ++ ;</span><br><span class="line">ansout += calc(*r - *mid - <span class="number">1</span>) + calc(*mid - *l - <span class="number">1</span>) - calc(*r - *l - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (op[u - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u - <span class="number">1</span>), f2 = _find(u) ; </span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op[u + <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u + <span class="number">1</span>), f2 = _find(u) ;</span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">fuck(u) ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> _update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">op[u] = <span class="number">0</span>, fr[u] = u, bg[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> _delete(to(k), u) ; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">_update(u, fa), ans += calc(N) - ansout - ansin ; </span><br><span class="line"><span class="keyword">if</span> (!mk) _delete(u, fa), _clear() ; vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Warning"><a href="#rm-Warning" class="headerlink" title="$\rm Warning$"></a>$\rm Warning$</h1><ul><li><p>注意一个地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br></pre></td></tr></table></figure><p>把这两句写反了会调一下午，欢迎尝试quq</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是整理一下dsu on tree的进阶版习题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 1</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-15T10:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\boldsymbol{dsu~on~tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly~Direct~Counting~on~Tree}$，“优雅的树上暴力统计”。</p><a id="more"></a><h1 id="rm-0x01-前言-amp-技术分析"><a href="#rm-0x01-前言-amp-技术分析" class="headerlink" title="$\rm 0x01$ 前言$\&amp;$技术分析"></a>$\rm 0x01$ 前言$\&amp;$技术分析</h1><p>严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛：</p><blockquote><p>1、维护子树信息；</p><p>2、不能带修改操作。</p></blockquote><p>但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。</p><p>然后来看技术分析。</p><p>首先，假设我们有这样一个问题：</p><blockquote><p>给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。</p><p>$n,q\leq 5\cdot1e5$</p><p>一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。</p></blockquote><p>考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。</p><p>考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。</p><p>现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。</p><p>所以这样就解决了维护树上信息的问题，复杂度$n\log n$。</p><h1 id="0x02-入门题目选整"><a href="#0x02-入门题目选整" class="headerlink" title="$0x02$ 入门题目选整"></a>$0x02$ 入门题目选整</h1><p>感觉大部分<code>blog</code>找的题目都很不清真233</p><h2 id="rm-Task1-rm-Cf600E-Lomsat-gelral"><a href="#rm-Task1-rm-Cf600E-Lomsat-gelral" class="headerlink" title="$\rm Task1$ $\rm Cf600E$ Lomsat gelral"></a>$\rm Task1$ $\rm Cf600E$ Lomsat gelral</h2><p>一句话题意</p><blockquote><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 </p></blockquote><p>考虑套$\rm EDCT$的板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line"><span class="keyword">if</span> (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa, <span class="number">1</span>) ; ans[u] = res ; <span class="keyword">if</span> (son[u]) vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (!mk) calc(u, fa, <span class="number">-1</span>), res = <span class="number">0</span>, max_cnt = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最后的<code>calc</code>函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">buc[clr[u]] += mk ; </span><br><span class="line"><span class="keyword">if</span> (mk &gt; <span class="number">0</span> &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[clr[u]] &gt; max_cnt) </span><br><span class="line">    res = <span class="number">0</span>, max_cnt = <span class="number">1l</span>l * buc[clr[u]] ;</span><br><span class="line">res += <span class="number">1l</span>l * clr[u] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; </span><br><span class="line">calc(to(k), u, mk) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Task2-Cf570D-Tree-Requests"><a href="#rm-Task2-Cf570D-Tree-Requests" class="headerlink" title="$\rm Task2 ~Cf570D$ Tree Requests"></a>$\rm Task2 ~Cf570D$ Tree Requests</h2><p>一句话题意：</p><blockquote><p>给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. </p></blockquote><p>这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] ^= (<span class="number">1</span> &lt;&lt; base[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (x) ret += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret &lt;= <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(getl(buc[qs[u][k]])) ; </span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\boldsymbol{dsu~on~tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly~Direct~Counting~on~Tree}$，“优雅的树上暴力统计”。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-814 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/13/codeforces-814/"/>
    <id>http://www.orchidany.cf/2019/11/13/codeforces-814/</id>
    <published>2019-11-13T13:34:25.000Z</published>
    <updated>2019-12-15T10:28:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场<code>cn</code> round，然后每次<code>cn</code> round的最后一题都会很奇怪……</p><a id="more"></a><h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega $"></a>$\Omega $</h1><p>$\rm virtual$了一场……说实话这种<code>div2 only</code>的场次最后一题就经常比较毒……</p><p><del>老规矩，前面几题用来水字数</del></p><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>给出一个长度为$N$的非负整数序列$a_i$与长度为$K$的正整数序列$b_i$，满足$a_i$中刚好有$K$个$0$，且任一正整数在序列$a$和序列$b$中的出现次数的和不会超过$1$。</p><p>现在试判断是否存在一种方法，使得用$b_i$中的元素替换$a_i$中的$0$得到的序列不是递增序列。 </p></blockquote><p>sb一眼题，显然如果递减放进去还是递增就无解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline bool cmp(int a, int b)&#123; return a &gt; b ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; K ; int j = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ;</span><br><span class="line">for (i = 1 ; i &lt;= K ; ++ i) cin &gt;&gt; t[i] ; sort(t + 1, t + K + 1, cmp) ;</span><br><span class="line">for (i = 1 ; i &lt;= N ; ++ i) if (!base[i]) base[i] = t[j ++] ;</span><br><span class="line">for (i = 1 ; i &lt; N ; ++ i) if (base[i] &gt; base[i + 1]) return puts(&quot;Yes&quot;), 0 ;</span><br><span class="line">return puts(&quot;No&quot;), 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给定两个长度为$n$的不相同序列$a$和$b$，这两个序列至少有一个位置不同</p><p>现在需要构造一个长度为$n$的排列$p$，使得$p$与$a$只有一个地方不同，且$p$与$b$也只有一个地方不同</p></blockquote><p>一眼就可以看出最多有两个位置不同，否则一定不合法。考虑分类讨论，如果只有一个位置不同那就放上那个没出现过的数字；如果有两个位置不同，那就考虑是$A$中第一个位置放多了还是第二个位置放多了，放上$B$的就完了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), Ma[A[i]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), Mb[B[i]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i] != B[i]) pos[++ cnt] = i ; </span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!Ma.count(i) &amp;&amp; !Mb.count(i)) &#123; A[pos[<span class="number">1</span>]] = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Ma[A[pos[<span class="number">1</span>]]] &gt; <span class="number">1</span> &amp;&amp; !Ma[B[pos[<span class="number">1</span>]]])&#123; </span><br><span class="line">A[pos[<span class="number">1</span>]] = B[pos[<span class="number">1</span>]] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">A[pos[<span class="number">2</span>]] = B[pos[<span class="number">2</span>]] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来觉得是道构造题，后来发现是道细节模拟题。。。</p><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给你一个由小写字母构成的字符串.<br>有$q$个询问，每个询问给出数字$m$和小写字母$c$，你可以任意地修改字符串中的$m$个字符，求最多能够使字符串中含有多少个连续相同的字母$c$.<br>每个询问各自独立.<br>$|\rm S|\leq 1,500$</p></blockquote><p>其实感觉复杂度一点也不对……比如我觉得这题可以做到$5e4$以上……</p><p>考虑弱化版（原版）的解法，大概就是用$f_{i,j}$表示前$i$个字符用了$k$次机会最长的连续段有多长。然后就可以直接$O(26n^2)$给预处理出来，每次询问回答一下即可。</p><p>但是我们发现这玩意儿复杂度一点也不平衡，因为预处理贼慢但是回答贼快。于是考虑有哪些性质没用。我们考虑预处理出原串中对于一个字符$c$，最近的两个$c$之间的位置来，然后如果要修改就显然先修改跨度小的$c_i$和$c_{i+1}$中间的部分，因为这样肯定不会更劣。同时只有把中间的非$c$区域占满才能使之连通，故每次对于一个给定的$k$，二分查找一下可以占满的区间，剩下的随便铺，对于这些占满的区间提前预处理出贡献的前缀和就完了。复杂度大概是$q\log n+26n$</p><p>然而升级版只是口胡，什么时候闲下来再写吧qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] == <span class="string">'a'</span> + i) dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] - <span class="string">'a'</span> == i) dp[i][j][k] = dp[i][j - <span class="number">1</span>][k] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> dp[i][j][k] = max(dp[i][j][k], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">ans[i][k] = max(ans[i][k], dp[i][j][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;k, &amp;In) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[(<span class="keyword">int</span>)In - <span class="string">'a'</span>][k] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p> 有$n$个圆，将其分为两组。每组中，只有奇数个圆覆盖的区域的才会算入面积，求可能的最大面积。 </p></blockquote><p>首先考虑贪心。大概就是说原本的覆盖一定可以看做一团一团独立的子问题。将圆按照面积大小排序，之后考虑选每一堆最大的放到第一堆，然后把与之原本冲突的放到第二堆。这样可以发现最终减去的部分面积变成了之前产生贡献的部分面积……然而这不重要，重要的是这样保证了每次选的一定都是面积最大的圆的集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (check_in(base[i], base[j])) ++ mark[j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (!mark[i] || (mark[i] &amp; <span class="number">1</span>)) Ans += get_S(base[i]) ; <span class="keyword">else</span> Ans -= get_S(base[i]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans) ;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这个贪心似乎不好想，于是考虑一种精妙的$\rm dp$<del>其实更不好想</del>。考虑按照圆从大到小枚举顺次连边，最后连出来的会是一个森林状物。然后对于这个东西， 定义$dp[u][0/1][0/1]$表示以点$u$为根的子树里面，除$u$之外分成两堆之后，两堆分别的高度为偶数/奇数时的最优值。这东西就可以直接分类讨论求和+转移。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(C A, C B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_S</span><span class="params">(C A)</span></span>&#123; <span class="keyword">return</span> Pi * A.r * A.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_in</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r + B.r &gt; dist(A, B) ; &#125;</span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next, to ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> faa)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">2</span>][<span class="number">2</span>] ; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == faa) <span class="keyword">continue</span> ;</span><br><span class="line">do_dp(to(k), u) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">f[ii][jj] += dp[to(k)][ii][jj] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">dp[u][ii][jj] = max(</span><br><span class="line">                f[ii ^ <span class="number">1</span>][jj] + (<span class="number">1l</span>l * (ii ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r), </span><br><span class="line">f[ii][jj ^ <span class="number">1</span>] + (<span class="number">1l</span>l * (jj ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (check_in(base[i], base[j])) </span><br><span class="line"><span class="keyword">if</span> (!fa[j] || base[fa[j]].r &gt; base[i].r) fa[j] = i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (fa[i]) Add(i, fa[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)<span class="keyword">if</span> (!fa[i]) do_dp(i, <span class="number">0</span>), Ans += dp[i][<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans * Pi) ;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给出$n$个点和每个点的度让你构造出一张无向图满足以下两条性质：</p><ul><li><p>$1.$点1到点$i$仅有<strong>唯一</strong>一条最短路</p></li><li><p>$2.$点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度</p></li></ul><p>求能构成满足条件的无向图的个数   $n\leq 50, 2\leq degree_i\leq 3$</p></blockquote><p>这种计数题会是不可能会的，这辈子都不可能会了qaq</p><p>考虑一个$idea$，因为这张图无权，所以最短路一定会是$\it bfs$的分层。那么对于一个$i$来讲，他的要么和$i-1$在同一层，要么就在$i-1$的下一层。</p><p>那么考虑记$f_{i,j}$表示前$i$个点中有$j$个和$i$在同一层的方案数。那么考虑这东西的转移跟上一层中点的度数有关，也就是需要记$dp_{k,c_1,c_2}$表示当前层有$k$个点，上一层度数为$2$的点有$c_1$个，度数为$3$的点有$c_2$个这一子状态的方案数。那么有如下：<br>$$<br>dp_{i,j,k}=\begin{cases}{1} &amp; (i=j=k=0)\ \ {\sum\limits_{l=2}^{k-1} dp_{i,j,k-l-1} \cdot\left(\begin{array}{c}{k-1} \ {l}\end{array}\right) \cdot N_{l+1}} &amp;(i=j=0,k&gt;0) \ \ {(j-1) \cdot dp_{i,j-2,k}+k \cdot dp_{i,j,k-1}} &amp; (i=0,j&gt;0)\ \{j \cdot dp_{i-1,j-1,k}+k \cdot dp_{i-1,j+1,k-1}} &amp; (i&gt;0)\ \{0}\end{cases}<br>$$<br>其中$N_i$表示<strong>$\boldsymbol{i-}$项链数</strong>，也就是长度为$i$、元素各异、镜像对称的单环的数量，计算方式如下：<br>$$<br>N_i=\begin{cases} 1 &amp; (i=2)\ \frac{(i-1)!}{2} &amp;(i&gt;2)\ 0 &amp; \rm{otherwise}\ \end{cases}<br>$$<br>对于第二个转移，就是考虑向上一层插入一个点使其成为度数为$3$的点。考虑因为度数为$3$且题目要求“有位移最短路”，所以同一层中只有可能是简单的平边相连。所以就是考虑枚举原来的点里面可以与新加入的点组成项链的方案数。注意这里项链数必须$&gt;2$原因是题目中强调了不能有两个点之间连$&gt;1$条边。</p><p>对于第三个转移，考虑插入一个点使其度数为$2$，这一步转移即考虑$j-1$个点中选择一个可能变成$2$度的点和新加近来这个点相连有$j-1$种方案，相连之后两个点度数都变为$2$；同时考虑另一种可能性，就是这一个点和一个可能变成$3$度的点相连，那么原来的二度点变为三度点，新加进来的变成二度点。</p><p>对于第四个转移，考虑这一层最后一个加进来的节点，要么和上一层中一个可能变成$2$度的点相连要么和可能变成$3$度的点相连。</p><p>然后最后的答案就是枚举最后一层的点数<br>$$<br>ans =\sum_{j=1}^{n}f_{n,j}\cdot g_{0,c_1,c_2}<br>$$<br>其中$c_1$和$c_2$表示枚举到现在有多少个$d=2$和$d=3$的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> N, clr1, clr2, base[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, l ; ll dp[MAXN][MAXN] ;</span><br><span class="line">ll Ans, A[MAXN], f[MAXN][MAXN][MAXN], Cm[MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N  ; Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ; </span><br><span class="line"><span class="keyword">for</span> ( A[<span class="number">1</span>] = A[<span class="number">0</span>] = <span class="number">0</span>, A[<span class="number">2</span>] = A[<span class="number">3</span>] = <span class="number">1</span>, i = <span class="number">4</span> ; i &lt;= N ; ++ i) A[i] = A[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % Mod ;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; <span class="comment">//Calculate g</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - j ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!j &amp;&amp; k)</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt; k ; ++ l)</span><br><span class="line">(f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - l - <span class="number">1</span>] * Cm[k - <span class="number">1</span>][l] % Mod * A[l + <span class="number">1</span>] % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="number">2</span>) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j - <span class="number">2</span>][k] * (j - <span class="number">1</span>) % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">if</span> (k) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - <span class="number">1</span>] * k % Mod) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N - i ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - i - j ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j) (f[i][j][k] += f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * j % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">if</span> (k) (f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * k % Mod) %= Mod ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; f[i][j][k] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Calculate dp</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; dp[base[<span class="number">1</span>] + <span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = base[<span class="number">1</span>] + <span class="number">2</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i - base[<span class="number">1</span>] - <span class="number">1</span> ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, k = <span class="number">1</span> ; k &lt;= i - j ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[i - j - k + <span class="number">1</span>] &lt;= <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">(dp[i][j] += (dp[i - j][k] * f[j][clr1][clr2] % Mod)) %= Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[N - i + <span class="number">1</span>] == <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">(Ans += (dp[N][i] * f[<span class="number">0</span>][clr1][clr2]) % Mod) %= Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一场&lt;code&gt;cn&lt;/code&gt; round，然后每次&lt;code&gt;cn&lt;/code&gt; round的最后一题都会很奇怪……&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E1</title>
    <link href="http://www.orchidany.cf/2019/11/13/xiaonei-1/"/>
    <id>http://www.orchidany.cf/2019/11/13/xiaonei-1/</id>
    <published>2019-11-13T13:10:22.000Z</published>
    <updated>2019-12-15T10:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛选整</p><p>大概难度都是TG里面$2$~$3$左右的。</p><a id="more"></a><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><blockquote><p>给定直线上$n\leq 2000$个建筑的坐标，两种覆盖方式，$A:$覆盖长度为$L$，可以用$p$次；$B$：覆盖长度为$2L$，可以用$q$次。求最小的$L$.</p></blockquote><hr><p>首先就是可以知道$p,q$可以缩到$p+q\leq n$，否则答案就是$1$。</p><p>之后考虑二分一个$L$，$check$其正确性。$check$时感觉贪心并不是很好贪，可能会有比较妙的贪心，但这个地方选择一种更加稳妥的$dp$。考虑$f_{i,j}$表示两种覆盖分别用了$i,j$个最多能覆盖到哪个建筑，则<br>$$<br>f_{i,j}=\max(go_p[f_{i-1,j}+1], go_q[f_{i,j-1}+1])<br>$$<br>其中$go_x[P]$表示在位置$P$使用第$x$种覆盖能够覆盖多少建筑。于是最后复杂度$O(n^2\log n)$.</p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><blockquote><p>定义<code>string</code>类型的递推$f_0=’0’$，$f_1=’1’$，$f_i=f_{i-2}+f_{i-1}$，其中$+$表示<code>string</code>类型的连接。多组询问，询问$f_n$中区间$\rm [L,R]$内的串。$n\leq 1e9,~\rm L\leq R\leq 2e9,\sum (R-L)\leq 1e7$</p></blockquote><hr><p>拿到这题首先应该手写出前$6$项来找规律……</p><p>发现$f_i.size()$就是斐波那切数列的第$i$项，并且序号奇偶性相同的两项$f_i,f_j$，当$j&lt;i$时满足$f_j$是$f_i$的前缀，这东西可以数学归纳出来<del>并且肉眼看不出来</del>。</p><p>之后可以发现$\rm L,R\leq 2e9$，而斐波那切数列的第$50$项已经超过了这个范围。于是考虑对于一个询问$f_n[L,R]$，先把$n$缩到$50$以内，然后分奇偶性赋值为$48/49$，然后每次考虑把$f_n$分成$f_{n-2}+f_{n-1}$，分治下去。注意到其实是可以预处理一些状态来提速，于是选择预处理前$20$项左右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; f[n].substr(L, R - L + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line"><span class="keyword">if</span> (L &lt; fib[n - <span class="number">2</span>]) solve(n - <span class="number">2</span>, L, min(R, fib[n - <span class="number">2</span>])) ; </span><br><span class="line"><span class="keyword">if</span> (R &gt;= fib[n - <span class="number">2</span>]) solve(n - <span class="number">1</span>, max(<span class="number">0l</span>l, L - fib[n - <span class="number">2</span>]), R - fib[n - <span class="number">2</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><blockquote><p>我们有一张方格纸，他大概长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g7908v9b.png" alt></p><p>我们现在要从左上角$(0,0)$到右下角$(n,m)$画一条直线，然后询问它经过黑格子的长度与总长度的比值，并输出一个互质分数的形式。</p></blockquote><p>sb结论题，以下是结论，觉得证的挺好的（</p><blockquote><p>无论怎样，$rqy$太强了！！</p><p>以下是$rqy$给的严谨证明：</p><ul><li><p>对于每个二元组$(n,m)$，$(\frac{n}{\gcd(n,m)},\frac{m}{\gcd(n,m)})$ 的本质与$(n,m)$是一样的。</p></li><li><p>当$n$是偶数<strong>或者</strong>$m$是偶数的时候，答案显然是$\frac{1}{2}$，因为我们可以考虑把所有的颜色翻转，答案是一样的。</p></li><li><p>余下的情况，由于我们现在已经缩小了问题规模使得$n,m$互质，所以只有可能是$n、m$均为奇数，此时我们考虑如下（前方高能）：</p></li><li><p>由于横向有$m$段，纵向有$n$段，所以总共这条直线可以分成$n \times m$段，当然，有些段的颜色相同。我们这么做的目的是为了保证<strong>每一段不会跨过每个格子的边界，即同一段的每个部分都会是相同的颜色</strong></p></li><li><p>通过观察可以得到，对于从左上到右下的第$i$段，它应该在第$\lfloor \frac{i}{n} \rfloor$<strong>列</strong>，第$\lfloor \frac{i}{m} \rfloor$<strong>行</strong>。注意这个地方，虽然$n$表示的是行，但是$\lfloor \frac{i}{n} \rfloor$表示的是列。道理其实很简单：</p><ul><li>对于第$i$段，它占的部分是$\frac{i}{n \times m}$ ，所以所属的行应该是$\lfloor \frac{i}{n \times m} \cdot n \rfloor$，所属的列为$\lfloor \frac{i}{n \times m} \cdot m \rfloor$，约分一下答案显而易见。 </li></ul></li><li><p>基于前两条，我们会有一个比较平凡的结论：对于某一段$i$，当$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$为偶数的时候，这一段在黑色的格子上；是奇数的时候，这一段在白色格子上。</p></li><li><p>我们可以考虑对$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$搞一些事情：<br>$$<br>\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor\begin{align} \ \\&amp;\equiv\frac{i - i \mod n}{n}+\frac{i - i \mod m}{m} \pmod 2\ &amp;\equiv 2i - i \mod n - i \mod m \pmod 2\  &amp; \equiv i \mod n  + i  \mod m \pmod 2\end{align}<br>$$</p></li></ul><p>上式的目的其实就是通过对$2$取模建立同余式，由于$n,m$均为奇数，所以在$\mod 2$意义下都是$1$，可以直接除掉。那么接下来我们考虑，这样的$i$有多少个呢？很显然的，在$0 \to n - 1$中，共有$\frac {n-1}{2}$个奇数,$\frac{n+1}{2}$个偶数；在$0 \to m-1$中，共有$\frac {m-1}{2}$个奇数，$\frac {m+1}{2}$个偶数。因为只有奇偶性相同时，才属于黑色格子，所以由中国剩余定理得<br>$$<br>\begin{aligned}\sum check(i) &amp;= \frac{n-1}{2} \cdot \frac{m-1}{2} + \frac{n+1}{2} \cdot \frac{m+1}{2} \\&amp; = \frac{2nm + 2}{4}\end{aligned}<br>$$</p><p>那么最终答案就是<br>$$<br>\frac {\sum check(i)}{n \cdot m} = \frac{n \cdot m+1}{2n \cdot m}<br>$$</p></blockquote><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>给定一棵树，某些点是关键点。每条边有代价，每次可以删掉一条边并且获得这条边的代价。求最少的代价，使得所有关键点不连通。$n\leq 300,000$</p></blockquote><hr><p>直观的想法是$dp$，即记$f_x$表示处理完以$x$为根的子树内的关键点（不互相连通）的最少代价。但是发现这样似乎很难转移，因为转移时要考虑子树之间的关键点是否连通。于是考虑再记$g_x$表示处理完以$x$为根的子树内关键点互相不连通，且不与外界连通的最小代价。</p><p>那么考虑转移，记$x$为当前节点，$y$为$x$的子节点：</p><ul><li><p>当$x$为关键点时，有：<br>$$<br>\begin{align<em>}<br>f_x&amp;=\sum g_y \\<br>g_x&amp;=f_x+pre_x<br>\end{align</em>}<br>$$</p></li><li><p>当$x$不为关键点时，有<br>$$<br>f_x=\min(\sum f_y-f_{y’}+g_{y’})\\<br>g_x=\min(f_x+pre_x, \sum g_y)<br>$$</p></li></ul><p>唔，这个第二个转移的$f_x$还是需要编一编的，大概就是考虑现在只需要不让子树内部连通，那么就可以选出一棵子树来内部不连通，其他子树都不和外部连通，可知这样是最优的（因为天选之子不需要“不和外部连通”）。</p><p>学习了，学习了。</p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>现在有如下一个表达式： $0 ~a_1 b_1 a_2 b_2 … a_n b_n$。其中$a_i$为一个位运算符（$\bold{and/or/xor}$），$b_i$是一 个整数。每一对$a_i,b_i$有$c_i$的概率会消失，求表达式的结果的期望。  </p></blockquote><hr><p>需要建立某种神秘的条件反射，就是遇到位运算的题目就要想到“位与位之间是无关的”。那么就可以直接按位做，令$f_{i,0/1}$表示计算完前$i$对，现在这一位为$0/1$的概率是多少。转移时别忘了加上当前这一对被删除的概率，即$f_{i-1,0/1}$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校内模拟赛选整&lt;/p&gt;
&lt;p&gt;大概难度都是TG里面$2$~$3$左右的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="校内模拟赛" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="有趣的二分答案" scheme="http://www.orchidany.cf/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="动态规划-树形DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数学/概率,期望" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】分治在FFT上的应用</title>
    <link href="http://www.orchidany.cf/2019/08/27/fzfft-md/"/>
    <id>http://www.orchidany.cf/2019/08/27/fzfft-md/</id>
    <published>2019-08-27T09:40:53.000Z</published>
    <updated>2019-12-15T06:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是cdq分治+FFT。</p><p>分治FFT解决的问题的一般形式：</p><p>给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且<br>$$<br>f_i=\sum_{j=1}^{i} f_{i-j} g_j<br>$$<br>求$f_1,f_2\cdots f_{n-1}$</p><a id="more"></a><p>先展开观察性质<br>$$<br>\begin{aligned}f_1&amp;=g_1f_0,\\ f_2&amp;=g_1f_1+g_2f_0,<br>\\ f_3&amp;=g_1f_2+g_2f_1+g_3f_0\\ f_4&amp;=g_1f_3+g_2f_2+g_3f_1+g_4f_0=g_1^4\end{aligned}<br>$$<br>我们发现如果将整个序列分成两半，前一半对后一半的贡献是：<br>$$<br>o_p=\sum_{i=l}^{\rm{mid}}f_ig_{p-i}<br>$$<br>其中$p\in(\rm{mid},r]$，$o$是额外的贡献。</p><p>我们发现，其实这是个卷积的形式，毕竟对于普通的卷积定义是：<br>$$<br>c_i=\sum_{j\leq i} a_jb_{i-j}<br>$$<br>于是我们就可以通过分治，每次暴力NTT计算前一半对后一半的贡献，类似于cdq分治的操作，复杂度$n\log ^2n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">if</span> (!l) F[l] = <span class="number">1</span> ; <span class="keyword">return</span> ;&#125; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, L = r - l + <span class="number">1</span>, Len = <span class="number">1</span>, l1 = <span class="number">0</span> ;</span><br><span class="line">    cdqNTT(l, mid) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt;= L) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="built_in">memcpy</span> (P, G, <span class="keyword">sizeof</span>(LL) * (r - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memcpy</span> (Q, F + l, <span class="keyword">sizeof</span>(LL)*(mid - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memset</span> (P + r - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - r + l)) ;</span><br><span class="line">    <span class="built_in">memset</span> (Q + mid - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - mid + l)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>), NTT(Q, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = P[i] * Q[i] % Mod ;</span><br><span class="line">    NTT(P, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) (F[i] += P[i - l]) %= Mod ; cdqNTT(mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]) ;</span><br><span class="line">    cdqNTT(<span class="number">0</span>, N - <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, F[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，得出结论我的分治没学好qaq</p><p>但是如果换一个角度观察，设出两个形式幂级数，即令<br>$$<br>\begin{aligned}<br>\rm{F}&amp;=\sum f_ix^i\\\<br>\rm{G}&amp;=\sum g_ix^i<br>\end{aligned}<br>$$<br>然后我们把他俩卷起来，且因为F本身就是卷积的形式，即有：<br>$$<br>\begin{aligned}<br>\rm{F} *\rm{G} &amp; =\sum x^i\sum_{j\leq i} f_ig_j<br>\\\<br>&amp;= \sum x_i f_{i+1}\\\<br>&amp;= \rm{F}-f_0<br>\end{aligned}<br>$$<br>那么先移项，之后两边同时卷一个$\rm{G}-1$ 的逆就可以得到：<br>$$<br>\rm{F}= \frac{1}{1-G}<br>$$<br>于是直接求一个逆就完了，复杂度$n\log n$。</p><p>不得不说这也算是一个小技巧了qwq</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实就是cdq分治+FFT。&lt;/p&gt;
&lt;p&gt;分治FFT解决的问题的一般形式：&lt;/p&gt;
&lt;p&gt;给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且&lt;br&gt;$$&lt;br&gt;f_i=\sum_{j=1}^{i} f_{i-j} g_j&lt;br&gt;$$&lt;br&gt;求$f_1,f_2\cdots f_{n-1}$&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="分治" scheme="http://www.orchidany.cf/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="多项式的应用" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Berlekamp-Massey算法</title>
    <link href="http://www.orchidany.cf/2019/08/26/BM/"/>
    <id>http://www.orchidany.cf/2019/08/26/BM/</id>
    <published>2019-08-26T09:35:31.000Z</published>
    <updated>2019-08-30T14:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Berlekamp-Massey</strong>算法用于在$O(n^2)$的时间内求解数列的递推式。形式化地讲，给定$a_i(i=0,1,2,3…n-1)$，求一组$b_j(j=0,1,2,3…m)$，满足：<br>$$<br>\forall i\geq m, a_i=\sum _{j=0}^{m} a_{i-j}b_i<br>$$<br>其中或许会有条件限制$m$最小。</p><a id="more"></a><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>考虑现在我们已经有了一个递推式$[f]$且满足了前$k$项</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Berlekamp-Massey&lt;/strong&gt;算法用于在$O(n^2)$的时间内求解数列的递推式。形式化地讲，给定$a_i(i=0,1,2,3…n-1)$，求一组$b_j(j=0,1,2,3…m)$，满足：&lt;br&gt;$$&lt;br&gt;\forall i\geq m, a_i=\sum _{j=0}^{m} a_{i-j}b_i&lt;br&gt;$$&lt;br&gt;其中或许会有条件限制$m$最小。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Berlekamp-Massey算法" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Berlekamp-Massey%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Berlekamp-Massey" scheme="http://www.orchidany.cf/tags/Berlekamp-Massey/"/>
    
      <category term="数学/常系数齐次线性递推" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】快速沃尔什变换</title>
    <link href="http://www.orchidany.cf/2019/08/26/fwt/"/>
    <id>http://www.orchidany.cf/2019/08/26/fwt/</id>
    <published>2019-08-26T03:50:28.000Z</published>
    <updated>2019-12-15T06:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速沃尔什变换(FWT)</strong>是一种广义上的<strong>傅里叶变换</strong>，可以解决<strong>子集并卷积</strong>、<strong>子集交卷积</strong>以及<strong>子集对称差卷积</strong>。</p><p>而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决<strong>子集对称差卷积</strong>，即：<br>$$<br>c_i=\sum_{j\oplus k=i} a_jb_k<br>$$<br>其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。</p><a id="more"></a><hr><h1 id="再谈线性变换实质"><a href="#再谈线性变换实质" class="headerlink" title="再谈线性变换实质"></a>再谈线性变换实质</h1><p>首先是构造，我们考虑线性变换的本质，需要有:<br>$$<br>{\rm FWT(C)}_i={\rm FWT(B)}_i\cdot{\rm FWT(A)}_i<br>$$<br>那么一个思路就是先设一个辅助函数$\varphi(i,x)$出来：<br>$$<br>{\rm FWT(F)}_i=\sum_{j\geq 0}\varphi(j,i) \cdot f_j<br>$$<br>那么就会有：<br>$$<br>\sum_{j\geq 0}\varphi(j,i) \cdot c_j=\sum_{j\geq 0}\varphi(j,i) \cdot a_j\times \sum_{j\geq 0}\varphi(j,i) \cdot b_j<br>$$<br>然后把$c_i=\sum_{j\oplus k=i} a_jb_k$带进去并调整：<br>$$<br>\begin{aligned}<br>\sum_{j\geq 0}\varphi(j,i) \cdot \sum_{p\oplus q=j} a_pb_q &amp; =\sum_{j\geq 0}\varphi(j,i) \cdot a_j \times\sum_{j\geq 0}\varphi(j,i) \cdot b_j\\\<br>\sum_{p \geq 0} \sum_{q\geq 0}\varphi(p\oplus q,i)\cdot a_pb_q &amp; =\sum_{p\geq 0}\sum_{q\geq 0}\varphi(p,i) \cdot \varphi(q,i)\cdot a_pb_q\\\<br>\end{aligned}<br>$$<br>发现$\sum_{p\geq 0}\sum _{q\geq 0}a_pb_q$是可以消掉的，于是就有：<br>$$<br>\varphi(p\oplus q,i)=\varphi(p,i)\cdot \varphi(q,i)<br>$$</p><h1 id="构造-varphi"><a href="#构造-varphi" class="headerlink" title="构造$\varphi$"></a>构造$\varphi$</h1><p>对于异或操作来说，异或前后$1$的个数的奇偶性不会改变。即也就是说$i,j$中$1$的个数加起来和$i\oplus j$中1的个数的奇偶性是一样的。形式化地讲：</p><p>$$<br>\rm bitcount(i)+bitcount(j)\equiv bitcount(i~\oplus ~j)~(\bmod 2)<br>$$</p><p>证明：</p><p>考虑$i \oplus j$的每一位：</p><ul><li>若$i$和$j$的这一位相同，那么就会变成$0$，$1$的个数减二或不变；</li><li>如不同，那么就一定是$(xx1xx)\oplus(xx0xx)=(xx1xx)$，$1$的个数还是不变。</li></ul><p>而我们发现这个引理解决的是相加不变的问题，而我们需要的$\varphi$函数需要满足相乘不变，于是自然而然地想到要放到幂上去。</p><p>于是就定义了$\varphi$:<br>$$<br>\varphi(s,t)=(-1)^{|s\cap t|}<br>$$<br>换成数值的表示方法：<br>$$<br>\varphi(i,j)=(-1)^{\rm bitcount \mathcal{(i ~\rm{and}~ j)}}<br>$$<br>这么定义的原因是：<br>$$<br>(i \cap x) \oplus(j \cap x)=(i \oplus j) \cap x<br>$$<br>即<strong>异或对交有分配律</strong>，那么：</p><p>$$<br>{\rm{FWT(F)}}_i=\sum_{j \geq 0}(-1)^{|i\cap j|}f_j<br>$$</p><p><del>于是就喜提一个指数级算法</del></p><h1 id="真正的-rm-FWT"><a href="#真正的-rm-FWT" class="headerlink" title="真正的$\rm{FWT}$"></a>真正的$\rm{FWT}$</h1><p>我们发现似乎这东西没有办法dp，于是考虑：</p><blockquote><p>每一次考虑新加入第$i$个物品取不取的情况，将当前集合分为$i$取和$i$不取，$i$取的放右边，$i$不取的放左边。</p><p>$i$取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小$−1$。$i$不取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小同样的不变。 </p><p>这样考虑原有状态，左右两边对$i$不取的贡献都是$\text{++}$，因为集合大小不变。左边对$i$取的贡献是$+$，右边对$i$取的贡献是$\text{−−}$，因为都取$i$的话并集增加了$1$，贡献取反。</p></blockquote><p>然后其实就是个模拟的思路，由于$(1xxxxxx)_2$和$(0xxxxxx)_2$的数量是一致的，所以我们可以将小于$(1000000)_2$的分为一类，大于等于$(1000000)_2$的分为一类，从数值上看就是前一半和后一半。</p><p>总之就是个FFT🦋操作的思路啦。</p><p>然后对于逆变换，因为我们刚才的结论有：<br>$$<br>\begin{aligned}{F[j+k] =F[j+k]+F[i+j+k]} \\ {F[i+j+k]=F[j+k]-F[i+j+k]}\end{aligned}<br>$$<br>所以我们现在为了得到原来的$F[i+j+k]$和$F[j+k]$，直接<br>$$<br>\begin{array}{c}{F[j+k]=\frac{F[j+k]+F[j+i+k]}{2}} \ {F[j+i+k]=\frac{F[j+k]-F[j+i+k]}{2}}\end{array}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, m = <span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>), x, y ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                x = f[j + k], y = f[i + j + k] ;</span><br><span class="line">                f[j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + y) % Mod ;</span><br><span class="line">                f[i + j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + Mod - y) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是时间复杂度就是$n \log n$了。</p><h1 id="rm-FWT-做or-and卷积"><a href="#rm-FWT-做or-and卷积" class="headerlink" title="$\rm FWT$做or/and卷积"></a>$\rm FWT$做or/and卷积</h1><p>艹，真是被血坑了。</p><p>才发现原来FWT做or/and卷积就是跟FMT一个道理：<br>$$<br>\boldsymbol{or}: F[i+j+k]+=F[j+k]\\\<br>\boldsymbol{and}: F[j+k]+=F[i+j+k]<br>$$<br>然后逆变换就直接把加号改成减号就好了……原因就是“不取这个东西”一定是“取这个东西”的子集。</p><p>但是当时我认真学习FMT的时候，<code>Rockdu</code>博客里面FMT的代码是FWT的！！！然后再看别人的代码我就懵O了好久……</p><p>真是zz</p><p>但是终于理解了<code>JOHNKRAM</code>神仙的话：</p><p><img src="https://s2.ax1x.com/2019/08/30/mjCdF1.jpg" alt></p><p>不得不说是很形象了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>其实Lugou上的板子的复杂度是$2^n n$的，我一开始就觉得暴力枚举子集没啥问题，结果最后发现枚举子集不是枚举$(n)_2$的子集，而是枚举$(2^n)_2$的子集……白学了白学了</li><li>唉，本来就是功能相同的FWT和FMT，看错代码真是GG</li><li>其实只有对称差卷积难理解一些，交并卷积都是很形象的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;快速沃尔什变换(FWT)&lt;/strong&gt;是一种广义上的&lt;strong&gt;傅里叶变换&lt;/strong&gt;，可以解决&lt;strong&gt;子集并卷积&lt;/strong&gt;、&lt;strong&gt;子集交卷积&lt;/strong&gt;以及&lt;strong&gt;子集对称差卷积&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决&lt;strong&gt;子集对称差卷积&lt;/strong&gt;，即：&lt;br&gt;$$&lt;br&gt;c_i=\sum_{j\oplus k=i} a_jb_k&lt;br&gt;$$&lt;br&gt;其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="快速沃尔什变换(FWT)" scheme="http://www.orchidany.cf/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】快速莫比乌斯变换&amp;子集卷积</title>
    <link href="http://www.orchidany.cf/2019/08/26/fmt/"/>
    <id>http://www.orchidany.cf/2019/08/26/fmt/</id>
    <published>2019-08-26T03:50:09.000Z</published>
    <updated>2019-12-15T06:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速莫比乌斯变换(FMT)</strong>可以方便地解决<strong>子集交卷积</strong>和<strong>子集并卷积</strong>，形式化地讲就是求一个$\rm C$：<br>$$<br>c_i=\sum_{k\cup j=i} a_kb_j\\\<br>c_i=\sum_{k\cap j=i} a_kb_j<br>$$<br>而<strong>快速子集变换(FST)</strong>则是在FMT基础上的扩展，解决的也是子集交卷积，但是限制了<strong>状态不重复</strong>，即<br>$$<br>c_i=\sum_{\substack{~k\cup j=i\\ k \cap j= \emptyset }}a_kb_j<br>$$<br>换个写法：<br>$$<br>c_s=\sum_{t\subseteq s}a_sb_{s-t}<br>$$<br>同时，以上两种变换所涉及的交集、并集和差集的对象都是集合（也就是$c_i$的下角标$i$指代的是集合），其二进制表示能更好地展示这一点。</p><a id="more"></a><h1 id="rm-FMT"><a href="#rm-FMT" class="headerlink" title="$\rm{FMT}$"></a>$\rm{FMT}$</h1><p>首先我们考虑一步线性变换的实质。考虑FFT，其本质是通过DFT使得我们可以直接线性地逐项相乘，即<br>$$<br>\begin{aligned}<br>\rm {C} &amp; =\rm{A*B}\\\<br>\Longrightarrow \rm{DFT(C)_i} &amp; =\rm{DFT(A)_i\cdot DFT(B)_i}<br>\end{aligned}<br>$$<br>那么我们同时也希望构造出一种变换使得可以逐项相乘。</p><h2 id="1-子集并卷积"><a href="#1-子集并卷积" class="headerlink" title="$(1)$ 子集并卷积"></a>$(1)$ 子集并卷积</h2><p>不妨先扩大一下范围，即若$A\cup B=C$，则一定有$A\subseteq C$且$B \subseteq C$，但是反过来不一定。</p><p>那么先考虑$\rm MT$，即考虑一种变换而不思考其复杂度。我们令<br>$$<br>\rm MT(F)_i= \mathcal{\sum_{j\subseteq i} f_j}<br>$$<br>则有<br>$$<br>\rm{MT(F)_i\cdot MT(G)_i}=\mathcal{\sum _{j,k\subseteq i} f_j\cdot g_k}<br>$$<br>而实际上我们求的是<br>$$<br>\rm{P_i}=\mathcal{\sum_{j\cup k=i}f_jg_k}<br>$$<br>而我们发现<br>$$<br>\begin{aligned}<br>\sum _{j\subseteq i}{\rm}_j &amp;=\sum_{d \subseteq i} \sum_{j\cup k=d}f_jg_k\\ &amp;= \sum_{j,k\subseteq i} f_jg_k\\ &amp;= \rm{MT(P)_i}\end{aligned}<br>$$<br>也就是说有<br>$$<br>\rm MT(F)_i\cdot MT(G)_i =MT(P)_i<br>$$<br>于是就构造出了这样的线性变换，本质就是子集和。</p><p>但是普通的子集和是$O(2^nn)$的，但是我们的$n$是$100000$级别，所以考虑一个dp一样的东西。就是我们每次枚举每一位，那么这一位为0就是这一位为1的子集，所以类加进答案。于是这样的复杂度就变成了$n\log n$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//N = (1 &lt;&lt; M) - 1 ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j ^ (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-子集交卷积"><a href="#2-子集交卷积" class="headerlink" title="$(2)$ 子集交卷积"></a>$(2)$ 子集交卷积</h2><p>我们对称思考，即令$\rm{MOT}$表示交卷积的变换，那么应该有：<br>$$<br>\rm MOT(F)_i= \mathcal{\sum_{i\subseteq j} f_j}<br>$$<br>那么<br>$$<br>\rm{MOT(F)_i\cdot MOT(G)_i}=\mathcal{\sum _{i\subseteq j,i\subseteq k} f_j\cdot g_k}<br>$$<br>我们要求的是<br>$$<br>\rm{Q_i}=\mathcal{\sum_{j\cap k=i}f_jg_k}<br>$$<br>则：<br>$$<br>\begin{aligned}<br>\sum _{i\subseteq j}{\rm}_j &amp;=\sum_{i \subseteq d} \sum_{j\cap k=d}f_jg_k\\ &amp;= \sum_{i\subseteq j,i\subseteq k} f_jg_k\\ &amp;= {\rm{MOT(Q)}_i}\end{aligned}<br>$$<br>于是就直接反着求一遍即可。</p><p>然后这东西就也还是个dp，复杂度$n \log n$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = M ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j | (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-优化：增量分治"><a href="#3-优化：增量分治" class="headerlink" title="$(3)$ 优化：增量分治"></a>$(3)$ 优化：增量分治</h2><p>阅读提示：优你🐎的化，这就是个FWT。</p><p>以下是以前的翻车现场：</p><hr><p>实际上我觉得也没怎么优化……</p><p>拿并卷积举例，大体上就是我们考虑如果存在$i\subseteq j\subseteq k$，我们朴素的要算两次，但实际上我们对于前半部分的$k$只需要算一次。这样实际上就是我们考虑每次只转移前$n-i$个元素相同的集合。</p><p>(以下内容来自<code>Rockdu</code>的$blog$)</p><p>于是每当多了一个元素，即我们考虑由$i$层转移到$i+1$层，发现只是多了一个元素的状态——讨论一下这个元素取不取，发现这个元素不取，答案就和原来一样，因为它的子集和不变；如果这个元素要取，那么这个元素不取的情况是它的子集，会多出这个元素不取的子集和。最终我们发现，到第$i$层只需要把第$i$个元素不取的状态加到第$i$个元素取的状态就可以了。</p><p>于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(<span class="keyword">int</span> * A, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = i &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)</span><br><span class="line">                (A[i + j + k] += A[j + k]) %= Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去每次只用计算一半，但是<code>JOHNKRAM</code>神仙是这么说的：</p><p><img src="https://s2.ax1x.com/2019/08/29/mbfpBq.png" alt></p><p>你看他长得和FFT的蝴蝶操作一毛一样，所以还是$n\log n$的。</p><hr><p>= =假酒害人，假代码更害人</p><h1 id="rm-FST"><a href="#rm-FST" class="headerlink" title="$\rm FST$"></a>$\rm FST$</h1><p><del>这个名字不是很吉利</del></p><p>这东西其实也不是非要用$\rm FMT$来做，$\rm FWT$也可以。</p><p>然后就是考虑在卷积的时候多增加一维，即$f_{i,S}$表示集合$S$中有$i$个元素，于是发现只有当元素个数相加符合时才是对的。</p><p>于是一开始将$f_{bct(s),s}$赋值为$f_s$，其中$bct(s)=\rm bitcount(s)$。然后对每一个$f_i$分别做$\rm FMT$，之后按位乘的时候需要<br>$$<br>P_{i, S}=\sum_{i=0}^{i} f_{j, S} * g_{i-j, S}<br>$$<br>输出的时候只输出$P_{bct(s),s}$即可。</p><p>板子题是<a href="https://loj.ac/problem/152" target="_blank" rel="noopener"><code>LOJ #152</code></a>，略微卡常，被逼无奈写了神奇的取模优化233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 1056701</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> bc[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M ; LL A[MAXN][MAXM], B[MAXN][MAXM], C[MAXN][MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(LL &amp;x)</span> </span>&#123; x += x &gt;&gt; <span class="number">63</span> &amp; Mod ; &#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">Ifmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] -= f[j ^ <span class="number">1</span> &lt;&lt; i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">fmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] += f[j ^ <span class="number">1</span> &lt;&lt; i] - Mod) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; <span class="keyword">register</span> <span class="keyword">int</span> i, j, s ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) bc[i] = bc[i - (i &amp; -i)] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) A[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fmt(A[i]), fmt(B[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (s = <span class="number">0</span> ; s &lt;= M ; ++ s)</span><br><span class="line">                (C[i][s] += A[j][s] * B[i - j][s]) %= Mod ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ifmt(C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, C[bc[i]][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际上国际上根本不通用FMT和FST这两个简写（甚至可能国内也没几个人用FST指代”子集卷积“）,于是就只能233了</p><p>upd：有些说明参见FWT的讲解。</p><h2 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm Referance$"></a>$\rm Referance$</h2><ul><li>$[1]$ :<code>Dance of Faith</code>的$blog$ <a href="https://www.cnblogs.com/Dance-Of-Faith/p/8818211.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :<code>Rockdu</code>的$blog$ <a href="http://blog.leanote.com/post/rockdu/TX20" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;快速莫比乌斯变换(FMT)&lt;/strong&gt;可以方便地解决&lt;strong&gt;子集交卷积&lt;/strong&gt;和&lt;strong&gt;子集并卷积&lt;/strong&gt;，形式化地讲就是求一个$\rm C$：&lt;br&gt;$$&lt;br&gt;c_i=\sum_{k\cup j=i} a_kb_j\\\&lt;br&gt;c_i=\sum_{k\cap j=i} a_kb_j&lt;br&gt;$$&lt;br&gt;而&lt;strong&gt;快速子集变换(FST)&lt;/strong&gt;则是在FMT基础上的扩展，解决的也是子集交卷积，但是限制了&lt;strong&gt;状态不重复&lt;/strong&gt;，即&lt;br&gt;$$&lt;br&gt;c_i=\sum_{\substack{~k\cup j=i\\ k \cap j= \emptyset }}a_kb_j&lt;br&gt;$$&lt;br&gt;换个写法：&lt;br&gt;$$&lt;br&gt;c_s=\sum_{t\subseteq s}a_sb_{s-t}&lt;br&gt;$$&lt;br&gt;同时，以上两种变换所涉及的交集、并集和差集的对象都是集合（也就是$c_i$的下角标$i$指代的是集合），其二进制表示能更好地展示这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="奇怪的变换" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A5%87%E6%80%AA%E7%9A%84%E5%8F%98%E6%8D%A2/"/>
    
    
      <category term="快速莫比乌斯变换(FMT)" scheme="http://www.orchidany.cf/tags/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2-FMT/"/>
    
      <category term="快速沃尔什变换(FWT)" scheme="http://www.orchidany.cf/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
      <category term="快速子集变换(FST)" scheme="http://www.orchidany.cf/tags/%E5%BF%AB%E9%80%9F%E5%AD%90%E9%9B%86%E5%8F%98%E6%8D%A2-FST/"/>
    
  </entry>
  
  <entry>
    <title>随想十 · 繁星</title>
    <link href="http://www.orchidany.cf/2019/08/20/10/"/>
    <id>http://www.orchidany.cf/2019/08/20/10/</id>
    <published>2019-08-19T16:06:13.000Z</published>
    <updated>2019-08-26T10:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>换了新的博客，把之前博客园里的三篇搬了下来。</p><p>每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。</p><p>时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。</p><p>读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。</p><p>读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】CF Educational Round70 题解</title>
    <link href="http://www.orchidany.cf/2019/08/19/Er70/"/>
    <id>http://www.orchidany.cf/2019/08/19/Er70/</id>
    <published>2019-08-18T16:10:33.000Z</published>
    <updated>2019-12-15T06:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Educational Round</code>，顾名思义，<strong>教育做人专场</strong>。</p><p>这场比赛巧妙地教育了一个初出茅庐的萌新Oier（我）<strong>到底该如何做人</strong>（哭晕）。</p><p>比赛链接：<a href="https://codeforces.com/contest/1202" target="_blank" rel="noopener">戳</a></p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$~A$"></a>$~A$</h1><p>题意：给你两个二进制字符串$x$和$y$，将$y$左移$k$位，再与$x$相加，得到字符串$s_k$，最后将其反转得到$res_k$。求当$res_k$字典序最小时的$k$。</p><hr><p>诡异的贪心……</p><p>实不相瞒我想了整整半个多小时（中间伴有间歇性走神）……</p><p>其实就是转化的思想，求反串的字典序最小，就是要把正串里面的低位1们尽量消掉。又因为题目里面限制了$x&gt;y$，所以一定存在$x$的二进制表示中至少一个$1$比$y$的最低位$1$靠左。考虑贪心的思想，$x$被消掉的$1$越靠右，反串字典序就越小。所以说我们要找的就是$\boldsymbol{x}$<strong>中能被$\boldsymbol{y}$消掉的最靠右的那个$\boldsymbol{1}$的位置</strong>。</p><p>于是扫一遍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="keyword">int</span> i, posa = <span class="number">0</span> , posb = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, A + <span class="number">1</span>) ;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, B + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">int</span> La = <span class="built_in">strlen</span>(A + <span class="number">1</span>), Lb = <span class="built_in">strlen</span>(B + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Lb ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (B[i] == <span class="string">'1'</span>) posb = i ; posb = Lb - posb + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= La ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (A[i] == <span class="string">'1'</span>) <span class="keyword">if</span> (La - i + <span class="number">1</span> &gt;= posb) posa = La - i + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; posa &lt;&lt; " " &lt;&lt; posb &lt;&lt; endl ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, posa - posb) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="it-B"><a href="#it-B" class="headerlink" title="$\it{B}$"></a>$\it{B}$</h1><p>题意：给定一个计数器$(x-y)$，对于每次引进的常数$z$，可以选择$\text{((+=x)mod=10)}$ 或者$\text{((+=y)mod=10)}$（$\text{mod=}$就是<code>%=</code>）然后把结果再丢到运算里面继续运算。现在给定一个残缺的$z$序列（省略了中间的某些结果），求$0\text{~}9$两两组合的计数器分别至少需要多少步才能还原这个串的运算。</p><hr><p>草，我这最短路又是白学了。</p><p>首先我们考虑一个显然的$10^4\cdot \Omega(1)$的预处理，就是令$(i-j)$为计数器，从$k$到$o$的最短距离，这玩意儿显然可以BFS，由于是对$10$取模所以大概循环节也在下界为$\Theta(1)$左右酱紫。之后对于询问直接暴力枚举就好了，复杂度大概是$100\cdot O(|S|)\leq 100\times 2,000,000=2e8$……梦想算法……但其实显然那个$100$可以只做$50+$的样子，毕竟是对称的……不过还是梦想算法233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">10</span> ; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (o = <span class="number">0</span> ; o &lt; <span class="number">10</span> ; ++ o)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> mark[<span class="number">200</span>] ;</span><br><span class="line">                    dis[i][j][k][o] = <span class="number">-1</span> ;</span><br><span class="line">                    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark)) ;</span><br><span class="line">                    q.push((wk)&#123;k, <span class="number">0</span>&#125;) ;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">                        wk now = q.front() ; q.pop() ;</span><br><span class="line">                        <span class="keyword">if</span> (now.num == o &amp;&amp; now.cnt)&#123;</span><br><span class="line">                            dis[i][j][k][o] = now.cnt ; <span class="keyword">break</span> ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mark[now.num]) <span class="keyword">continue</span> ;mark[now.num] = <span class="number">1</span> ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + i) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + j) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) q.pop() ;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">/*for (i = 0 ; i &lt; 10 ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = 0 ; j &lt; 10 ; ++ j)</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt; 10 ; ++ k)</span></span><br><span class="line"><span class="comment">                for (o = 0 ; o &lt; 10 ; ++ o)</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; dis[i][j][k][o] &lt;&lt; " " ;*/</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ; <span class="keyword">int</span> ans = <span class="number">0</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = In[i] - <span class="string">'0'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)&#123; <span class="comment">/*qwqwq*/</span></span><br><span class="line">            <span class="keyword">for</span> (ans = <span class="number">0</span>, k = <span class="number">2</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j][base[k - <span class="number">1</span>]][base[k]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"-1 "</span>), ans = <span class="number">-1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dis[i][j][base[k - <span class="number">1</span>]][base[k]] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans - N + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（代码渲染会自动把<code>tab</code>映射成<code>force-tab</code>我也懒得管了= =）</p><h1 id="mathcal-C"><a href="#mathcal-C" class="headerlink" title="$\mathcal{C}$"></a>$\mathcal{C}$</h1><p>题意：给定一段某个机器人的操作序列<code>WSAD</code>，可以添加一个字符，求最终机器人的最小活动区域面积。</p><hr><p>首先显然是<strong>行列无关</strong>的，所以分开考虑；接着发现最优策略肯定是让某一步相当于没走，但是假设$x_{min}$和$x_{max}$均在这次改动操作的后面，那么缩小$x_{max}$的时候也会缩小$x_{min}$，相当于没缩——所以应找到一个界点，所有的最大值都在左/右边，对应的所有最小值都在右/左边。</p><p>由于每一步操作都是有后效性的，所以考虑直接前缀和上求出$min$和$max$就好。</p><p>但是考虑无论怎么移动，都不能越过预处理出来的$x_{min}$、$x_{max}$这个界（否则会出现越贪越大）。也就是说假设有一个$x_{max}$，接着过了一会儿有一个$x_{min}$，为了“拔高”$x_{min}$我们必须要添加一个$W$，所以我们必须要保证任何时刻不会出现$x_{max}$在放上一个$W$之后越界的情况，也就是说$x_{min}$和$x_{max}$出现的位置之间必须要一个$S$才能用来抵消掉我们$W$，需要特判。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL ans ; </span><br><span class="line"><span class="keyword">int</span> fhm, fhn, fwm, fwn, pos[<span class="number">2</span>][<span class="number">5</span>], i ; </span><br><span class="line"><span class="keyword">int</span> T, N, Sw[MAXN], Sh[MAXN] ; <span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        fhm = fwm = -Inf, fhn = fwn = Inf ;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            Sh[i] = Sh[i - <span class="number">1</span>], Sw[i] = Sw[i - <span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">'W'</span>) Sh[i] = Sh[i - <span class="number">1</span>] + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'S'</span>) Sh[i] = Sh[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'D'</span>) Sw[i] = Sw[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'A'</span>) Sw[i] = Sw[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">        &#125;<span class="comment">//前缀和 : w x h </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fwm = max(Sw[i], fwm), fwn = min(Sw[i], fwn) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fhm = max(Sh[i], fhm), fhn = min(Sh[i], fhn) ; </span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max w</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min h    </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min w</span></span><br><span class="line">        ans = <span class="number">1l</span>l * (fwn - fwm - <span class="number">1</span>) * (fhn - fhm - <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">3</span>] &lt; pos[<span class="number">0</span>][<span class="number">2</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">3</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">3</span>] &lt; pos[<span class="number">1</span>][<span class="number">2</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">3</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">4</span>] &lt; pos[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">4</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">4</span>] &lt; pos[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">4</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">1</span>] = pos[<span class="number">1</span>][<span class="number">1</span>] = pos[<span class="number">0</span>][<span class="number">2</span>] = pos[<span class="number">1</span>][<span class="number">2</span>] = Inf ;</span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">3</span>] = pos[<span class="number">1</span>][<span class="number">3</span>] = pos[<span class="number">0</span>][<span class="number">4</span>] = pos[<span class="number">1</span>][<span class="number">4</span>] = -Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm好像当时<code>debug</code>了好久的样子。</p><h1 id="rm-D"><a href="#rm-D" class="headerlink" title="$\rm{D}$"></a>$\rm{D}$</h1><p>题意：构造一个含有<code>1</code>/<code>3</code>/<code>7</code>的串，使得子序列<code>1337</code>的数量恰好为$x$。</p><hr><p>这特么就是一个智商题。就是考虑一个最简单的构造<code>133..3337</code>这种，但是不是每一个$x$都可以表示成$\frac{p(p-1)}{2}$这种形式的……所以考虑找出最大的$p~\rm{s.t.}$ $p(p-1)\leq 2x$，然后拼命地向第一组<code>33</code>后面添加<code>7</code>就好了。这样总长度是上限是$2\sqrt x$的，挺稳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> p = <span class="built_in">sqrt</span>(<span class="number">2</span>*N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &lt;= <span class="number">2</span>*N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * (i - <span class="number">1</span>) &gt; <span class="number">2</span> * N) <span class="keyword">break</span> ;</span><br><span class="line">            L1 = i * (i - <span class="number">1</span>) / <span class="number">2</span>, L2 = N - L1, L1 = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"133"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L2 ; ++ i) <span class="built_in">putchar</span>(<span class="string">'7'</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L1 - <span class="number">2</span> ; ++ i) <span class="built_in">putchar</span>(<span class="string">'3'</span>) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mathbb-E"><a href="#mathbb-E" class="headerlink" title="$\mathbb{E}$"></a>$\mathbb{E}$</h1><p>题意：给定$N~(\leq 1e5)$个模板串$s_i$和一个文本串$T$，求所有的$s_i+s_j~(i\not=j)$在$T$中出现的次数之和。</p><hr><p>嗯，顺带复习了一下$AC$自动机。</p><p>思路其实也很简单，就是建俩$AC$自动机，一个跑正串，一个跑反串，然后枚举每个合法的i作为中间的结合位点，乘法原理就好了……但其实这种结论能轻易得出还是建立在$AC$自动机掌握十分扎实的基础上啊。</p><p>哦对，似乎对于AC自动机的题目，树形dp才是正确的打开方式。每次重新跳fail根本吃不消。。（<code>CF</code>真的有数据去卡这东西，<code>aaa..aa</code>这种……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN], In[MAXN] ; <span class="keyword">int</span> N ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACm</span>&#123;</span></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ; <span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> tr[MAXN][<span class="number">27</span>], res[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> fail[MAXN], ans[MAXN], e[MAXN] ; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) tr[rt][x]</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> Id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), k, rt = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i)&#123;</span><br><span class="line">k = s[i] - <span class="string">'a'</span> ;</span><br><span class="line"><span class="keyword">if</span> (!v(k)) v(k) = ++ cnt ; </span><br><span class="line">rt = v(k) ;</span><br><span class="line">&#125;</span><br><span class="line">e[rt] ++ ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, rt = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) <span class="keyword">if</span> (v(i)) q.push(v(i)) ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">rt = q.front(), q.pop() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!v(i)) v(i) = tr[fail[rt]][i] ; </span><br><span class="line"><span class="keyword">else</span> fail[v(i)] = tr[fail[rt]][i], q.push(v(i)) ;</span><br><span class="line"><span class="comment">//if (e[fail[v(i)]]) last[v(i)] = fail[v(i)] ; else last[v(i)] = last[fail[v(i)]] ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">void work(char *s)&#123;</span></span><br><span class="line"><span class="comment">int i, j = strlen(s), p, rt = 0 ; </span></span><br><span class="line"><span class="comment">for (i = 0 ; i &lt; j ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">rt = v(s[i] - 'a'), p = rt ; </span></span><br><span class="line"><span class="comment">while(p) res[i] += e[p], p = fail[p] ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (res[rt] != <span class="number">-1</span>) <span class="keyword">return</span> res[rt] ;</span><br><span class="line"><span class="keyword">return</span> res[rt] = e[rt] + dfs(fail[rt]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line"><span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), p, rt = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) rt = v(s[i] - <span class="string">'a'</span>), ans[i] = dfs(rt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;P, Q ; LL ans ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; S &gt;&gt; N ; <span class="keyword">int</span> i, j ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, In), P.insert(In, i) ; </span><br><span class="line">j = <span class="built_in">strlen</span>(In), reverse(In, In + j), Q.insert(In, i) ;</span><br><span class="line">&#125;</span><br><span class="line">P.build(), Q.build() ; j = <span class="built_in">strlen</span>(S) ;</span><br><span class="line">P.work(S), j = <span class="built_in">strlen</span>(S) ; reverse(S, S + j) ; Q.work(S) ;</span><br><span class="line"><span class="comment">//for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; P.res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; Q.res[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) ans += <span class="number">1l</span>l * P.ans[i] * Q.ans[j - <span class="number">2</span> - i] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mathfrak-F"><a href="#mathfrak-F" class="headerlink" title="$\mathfrak{F}$"></a>$\mathfrak{F}$</h1><p>题意：给定大写字母$A$和$B$的数量，求可以组成多少种不同的最短周期。其中周期的定义式不完全的，即只需要满足$\forall i,s[i]=s[i~\bmod~k]$，$k$就是周期。</p><hr><p>这真是神仙题……</p><p>下文中用$a,b$表示输入的那俩值。</p><p>考虑对于一个合法的$k$而言，假设在这个$k$满足$k=\lfloor n/p\rfloor,p\in \mathbb{N}$，那么$p$就是循环节的数量。现在我们假设有$q_a+q_b=k$，即每一段循环节中$A$的数量和$B$的数量。那么一定需要满足的是$q_a\cdot p\leq a$并且$q_b\cdot p\leq b$。</p><p>同时考虑一定会有<br>$$<br>q_a \leq \lfloor\frac{a}{p}\rfloor, q_b \leq \lfloor\frac{b}{p}\rfloor<br>$$<br>但同时还有一个条件，就是虽然实际上多出去一堆下脚料，但$a_{rest},b_{rest}$必须小于等于$q_a$和$q_b$。也就是说需要有<br>$$<br>(p+1)\cdot q_a \geq a,(p+1)\cdot q_b\geq b<br>$$</p><p>美化一下就是</p><p>$$<br>\lceil \frac{a}{p+1} \rceil \leq q_a\leq \lfloor \frac{a}{p} \rfloor \\\<br>\lceil \frac{b}{p+1} \rceil \leq q_b\leq \lfloor \frac{b}{p} \rfloor<br>$$</p><p>就可以通过从$1$到$n$枚举$p$来求得$q_a$和$q_b$，那么根据定义，$q_a$和$q_b$是一段循环节中的$A$和$B$的数量，所以$q_a+q_b$对$k$产生贡献。</p><p>还有一个小问题，就是如何保证一定是<strong>最小的$k$</strong>。这个其实也很简单。假设对于每一段完整的循环节他同时也自循环，段和段之间$A$和$B$个数一定相同，所以可以考虑直接把每一段的$A$丢到前面，$B$丢到后面，就避免了自循环这种情况。</p><p>然后这东西显然是可以数论分块的，所以我们分一下块就做完了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, L ; LL Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, L = N + M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g, l = <span class="number">1</span>, r ; l &lt;= L ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        g = L / l, r = L / g ;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; g || M &lt; g) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> ln = (N + g) / (g + <span class="number">1</span>), hn = N / g ;</span><br><span class="line">        <span class="keyword">int</span> lm = (M + g) / (g + <span class="number">1</span>), hm = M / g ;</span><br><span class="line">        <span class="keyword">if</span> (hn &gt;= ln &amp;&amp; hm &gt;= lm)</span><br><span class="line">            Ans += max(<span class="number">0l</span>l, <span class="number">1l</span>l * (min(hn + hm, r) - max(l, lm + ln) + <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结撒🌹fa~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Educational Round&lt;/code&gt;，顾名思义，&lt;strong&gt;教育做人专场&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这场比赛巧妙地教育了一个初出茅庐的萌新Oier（我）&lt;strong&gt;到底该如何做人&lt;/strong&gt;（哭晕）。&lt;/p&gt;
&lt;p&gt;比赛链接：&lt;a href=&quot;https://codeforces.com/contest/1202&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="动态规划-树形DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="AC自动机" scheme="http://www.orchidany.cf/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】留言板</title>
    <link href="http://www.orchidany.cf/2019/08/09/%E7%95%99%E8%A8%80%E6%9D%BF/"/>
    <id>http://www.orchidany.cf/2019/08/09/留言板/</id>
    <published>2019-08-08T16:18:42.000Z</published>
    <updated>2019-12-15T07:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学rvalue造了个留言板，也顺便整理一些有趣的事情。</p><p>看起来似乎是用来留言的？或许吧233</p><p>Σ( ° △ °|||)︴这东西是给大家留言的辣，挂友链/踩爆我/吐槽blog的设计都阔以的啊QAQ</p><a id="more"></a><p>以下是被教育做人的经历：</p><blockquote><p>​        人生有许多道：曾经踏足的是道，即将踏往的也是道，那什么才是道呢？唯有脚下走的才是道。一切精神或者物质都归于虚无，然后从混沌中衍生出三万道。在悲喜间涉足一条无数前人经历过，且将有无数后人奔赴的道，无论是否已经或者将要到达彼岸，然后便不再回头或是左顾右盼，即使有些道繁盛至极，夜灯如昼，无数人一浪又一浪的涌去，造就了世人皆知的辉煌；即使有些道草木凋敝，荒草丛生，只等勇敢的开拓者斩开荆棘，创造一片天地；这些都无所关，无所在意，彼岸何如、来日何方甚至过往旧事都化作一缕云烟，飘渺碧霄，我自撷高山之月色，独随足落处往行。</p><p>​                                                                                                                                                    ——SD队长ckw</p></blockquote><blockquote><p>笔蘸波涛饰昆仑</p><p>​                            ——konoset学长</p></blockquote><p>居然有人想要我这种老年选手的企鹅号：<code>2836531293</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学rvalue造了个留言板，也顺便整理一些有趣的事情。&lt;/p&gt;
&lt;p&gt;看起来似乎是用来留言的？或许吧233&lt;/p&gt;
&lt;p&gt;Σ( ° △ °|||)︴这东西是给大家留言的辣，挂友链/踩爆我/吐槽blog的设计都阔以的啊QAQ&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://www.orchidany.cf/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
</feed>
