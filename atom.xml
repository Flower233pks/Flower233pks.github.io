<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-jDVNxnFU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-jDVNxnFU"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-04-29T12:34:46.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p><del>恭喜你来到了没有知识的荒原.</del></p><p>这篇文章已经移步到侧边栏的「<code>Navigation</code>」里啦！还不去看看？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】网络流乱搞记录</title>
    <link href="https://www.orchidany.cn/2020/05/29/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9E%8E%E5%81%9A%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.orchidany.cn/2020/05/29/网络流瞎做记录/</id>
    <published>2020-05-29T05:53:26.000Z</published>
    <updated>2020-05-31T13:31:42.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了点网络流题目，算是对网络流的一个复习吧。</p><p>感觉现在建起图来已经可以算是得心应手了.jpg</p><p>打星的题目都比较有趣。大部分题目可能没有数据范围，当作 O(网络流能过) 就好了。</p><p><del>虽然现在都考模拟费用流，建图费用流已经是历史的眼泪了。</del> </p><a id="more"></a><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="UVA11167-Monkeys-in-the-Emei-Moutain"><a href="#UVA11167-Monkeys-in-the-Emei-Moutain" class="headerlink" title="*[UVA11167] Monkeys in the Emei Moutain"></a>*[UVA11167] Monkeys in the Emei Moutain</h2><blockquote><p>大概说有 $n$ 只猴子，猴子们在某个时间段需要喝 $v_i$ 时间的水，各个单位时间段最多允许 $m$ 只猴子同时喝水，问猴子们能否成功喝水并输出一个可行的方案，输出方案的时间段区间要从小到大排序并且合并连续的区间。</p><p>$1\leq l_i,r_i\leq 50000,n\leq 100$ 。</p></blockquote><p>考虑暴力建图，我一开始的思路是对于每个时间点拆成两个点 $t’,t$ 之间连 $f=m$ 的边，然后猴子 $i$ 向一个区间的点连 $f=+\infty$ 的边，源点向猴子连 $f=v_i$ 的边。这样边数可以通过线段树来搞成 $T\log T$ 的。</p><p>然而上面这个建图肉眼可见的不是正解。考虑向区间模型上靠，因为猴子数很少，最多有 $O(n)$ 个本质不同的区间端点。于是可以考虑把上面那种做法中没有用到的多个时间点合并成一个，并且把 $f=m$ 改成 $f=k\times m$ 。依旧做就好了。</p><h2 id="UVA11082-Matrix-Decompressing"><a href="#UVA11082-Matrix-Decompressing" class="headerlink" title="[UVA11082] Matrix Decompressing"></a>[UVA11082] Matrix Decompressing</h2><blockquote><p>给出一个 R 行C 列的正整数矩阵，设前 $A_i$ 项为其前 $i$ 行所有元素之和，$B_i$ 项为其前 i 列所有元素之和，已知 R,C,A,B，找出一个满足条件的矩阵。其中每个元素都是1~20 的正整数。</p></blockquote><p>sb 题。考虑源向每一行连 $f=r_i$ 的边，每一列向汇连 $f=c_i$ 的边，行列再向每个点连 $f=\infty$ 的边。同时给中间的每条边设置一个上下界 $1$ ，流就完了。</p><p>然后发现并不用建出中间的那一排点来。并且下界如果为 $1$ …就可以直接上下界各减 $1$ 然后跑普通的流即可。</p><h2 id="ACM-ICPC-NEERC2009-Inspection"><a href="#ACM-ICPC-NEERC2009-Inspection" class="headerlink" title="**[ACM/ICPC NEERC2009] Inspection"></a>**[ACM/ICPC NEERC2009] Inspection</h2><blockquote><p>求解无权 DAG 的最小路径<strong>边</strong>覆盖。特别的，路径可以重复走。</p></blockquote><p>很神奇一道题。神奇在我在 check 自己的 Sol 的时候发现了这么一回事：</p><blockquote><p>对于图中的每个点 $i$，设 $d_i$ 为( $i$ 的入度 - $i$ 的出度)的值，按照 $d_i$将图中的点分类：</p><p>$d_i\lt 0$ 的称为“入少出多”的点，$d_i\gt 0$ 的称为“出少入多”的点，$d_i=0$ 的称为“入出相等”的点。则有：</p><blockquote><p>定理：有向无环图中最小边路径覆盖的值等于图中所有“入少出多”的点的 $d_i$ 绝对值之和。 </p></blockquote></blockquote><p>这还是比较显然的，注意到这个定理是在陈述「边覆盖」就不难理解了。 然后借此先说 Sol 1:</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>考虑本题和不能重复走的最小路径覆盖有什么区别，那必然是存在一些路径可以重复经过。我断言，这样的路径必然满足起点 $d_i&gt;0$，终点的 $d_i\lt0$ ，否则没有必要重复经过。考虑某条这样的路径 $(s:t)$ 每被重复经过一次，就必然是为了将 $t$ 之后的某条路经和 $s$ 之前的某条路径拼插起来，这样原来需要 $2$ 次现在就只需要 $1$ 次。</p><p>于是考虑直接对着这个跑一次最大流即可，各个地方的流量都是 $1$ ，拿定理中的答案减去这个最大流就好了。</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>…发现这题就是一个带下界的最小流。于是就跑一个带下界的最小流即可。</p><h2 id="ACM-ICPC-NWERC-2007-March-of-the-Penguins"><a href="#ACM-ICPC-NWERC-2007-March-of-the-Penguins" class="headerlink" title="[ACM/ICPC NWERC 2007] March of the Penguins"></a>[ACM/ICPC NWERC 2007] March of the Penguins</h2><blockquote><p>有一群企鹅，一些冰。企鹅们在快乐地玩耍。</p><p>给出每个企鹅的最大跳跃距离(大家都一样)，再给出冰的坐标和上面存在的企鹅个数和允许跳跃的次数，问有哪些冰是可以将所有的企鹅汇聚起来的。</p></blockquote><p>比较简单一题。之前的想法是这么建图(事实上就是这么建图)：源点向每块冰连 $n_i$ 的边代表原有企鹅，每块冰拆成俩点限制跳跃次数。然后冰之间根据跳跃距离连边就好了。</p><p>但是自己的处理方式不是很到位。我的想法是枚举每个点作为汇点跑一遍最大流再去 check 是否满流，后来发现其实并不需要，只需要一个跑一遍最大流就好了。因为如果对于某个 $i$ 满流，他要么可以将这一份满流输送给其他点，要么就是被其他点数输送过来的。</p><h2 id="ACM-ICPC-Hangzhou-2005-Duopoly"><a href="#ACM-ICPC-Hangzhou-2005-Duopoly" class="headerlink" title="*[ACM/ICPC Hangzhou 2005] Duopoly"></a>*[ACM/ICPC Hangzhou 2005] Duopoly</h2><blockquote><p>C公司有一些资源，每种只有1个，有A、B两个公司分别对其中一些资源进行分组竞标，每组竞标对一些资源出一个总价。问C公司的最大收益。</p></blockquote><p>谔谔，感觉有被降智到。</p><p>一开始想了很多奇奇怪怪的建图方式，都是错的。后来看了题解发现…其实本质上根本不关心每种资源到底是怎么分配的，只关心某些资源的组合能够带来多少收益。于是建图就不需要考虑每种资源了，直接对 A 和 B 的所有竞标分立两侧，有冲突的就连边，跑一个最小割就好了。</p><h2 id="经典题-二分图带权最大独立集"><a href="#经典题-二分图带权最大独立集" class="headerlink" title="[经典题] 二分图带权最大独立集"></a>[经典题] 二分图带权最大独立集</h2><blockquote><p>给定一张二分图，图里面每个点会带一个权。求权最大独立集。</p></blockquote><p>将权调整到 $\rm S\to …$ 和 $\rm …\to T$ 上 。就变成睿智最小割了。我为什么要整这个题！？</p><h2 id="经典题-最优调度-公平分配-LA3231-Fair-Share"><a href="#经典题-最优调度-公平分配-LA3231-Fair-Share" class="headerlink" title="[经典题]最优调度(公平分配) /LA3231 Fair Share"></a>[经典题]最优调度(公平分配) /LA3231 Fair Share</h2><blockquote><p>m个任务n个处理器，一个任务只能在可供运行的两个机器中的其中一个上运行，问怎样分配使得任务最多的机器尽量少。</p></blockquote><p>那必然是要二分答案。之后流一下看看与源点相连的每个任务那条边是否满流就好了。</p><h2 id="UVA11248-Frequency-Hopping"><a href="#UVA11248-Frequency-Hopping" class="headerlink" title="*[UVA11248] Frequency Hopping"></a>*[UVA11248] Frequency Hopping</h2><blockquote><p>给定一个有向网络，每条边均有一个容量。问是否存在一个从点1到点N，流量为C的流，如果不存在，是否可以恰好修改一条弧的容量，使得存在这样的流。</p></blockquote><p>比较有意思的题，考虑如果要修改，那必然是要修改最小割上的边。然后就把最小割求出来，再枚举每一条边。但是注意到不需要每次重新求一遍最大流，可以直接在原图上增广。这个技巧需要心领神会。</p><h2 id="ACM-ICPC-Taejon-2002-The-K-league"><a href="#ACM-ICPC-Taejon-2002-The-K-league" class="headerlink" title="*[ACM/ICPC Taejon 2002] The K-league"></a>*[ACM/ICPC Taejon 2002] The K-league</h2><p>Taejon：大田，似乎是韩国的某城市，长见识了。</p><blockquote><p>有n个队伍进行比赛，每场比赛，恰好有一支队伍取胜、一支队伍败。每个队伍需要打的比赛场数相同。</p><p>给你每个队伍目前已经赢得的场数 $done_i$，再给你一个矩阵，表示队伍 i 和队伍 j 还需要打的比赛数，问你哪些队伍有可能获得冠军（胜场最多的即为冠军，可以并列）。</p></blockquote><p>这题比较神。首先一个观察就是可以独立求出每个队伍是否可以夺冠。考虑首先要钦定当前队伍赢得所有未竟比赛，设这个数量为 $s$。之后考虑就是能否有一种安排策略使得其它的队伍获胜场数均 $\leq s$。</p><p>发现这就是一个上面提到过的公平分配模型。考虑将每一场比赛分配给每支队伍。把一支队伍的最多获胜场次设为 $s-done_u$ ，然后检查一下每个比赛的那条边是否满流就好了。</p><h2 id="UVA10779-Collector’s-Problem"><a href="#UVA10779-Collector’s-Problem" class="headerlink" title="**[UVA10779] Collector’s Problem"></a>**[UVA10779] Collector’s Problem</h2><blockquote><p>现在有包括了Bob在内的 n 个小朋友，m 种游戏卡片，Bob可以和其他人交换卡片，除了Bob，每个人的交换原则都是只给出自己的拥有多张卡片，接受自己没有的卡片。的问他最后有多少不同的卡片。 </p><p>$n\leq 10, m\leq 25$ 。</p></blockquote><p>考虑如果 $m$ 稍微小一点，比如 $10$ 之类的就可以直接状压了。$f_{s_1,s_2}$ 表示现在考虑了 Bob 的朋友集合为 $s_1$ ，拥有的卡牌集合为 $s_2$ 是否可行。这样每次转移就可以刷个表。复杂度 $O(2^n\cdot n\cdot m\cdot 2^m)$ 。</p><p><del>m=10好像也不是很能过</del> 。</p><p>于是考虑正经建图，还是比较仙的。考虑怎么正确对待「只给出自己的拥有多张卡片，接受自己没有的卡片」这个限制，发现这个限制十分的强，限制了每个小朋友已经有的卡片数目在过程中也不能 $\lt1$ 。于是对于每个小朋友关心的就只在于其 $&gt;2$ 的数量的卡牌。</p><p>考虑怎么建图（好神啊）。 大概就是说小伙伴只是用来换的工具人，并不关心他们怎么分配，只关心最后每张牌是否可以拿到。于是就可以考虑从源点向每一张牌连一张 $f=a_i$ ，其中 $a_i$ 是 Bob 原有的卡的弧，每张牌向 $T$ 连 $f=1$ 的弧。考虑怎么于小伙伴们交互，如果小伙伴 $j$ 没有某张牌 $i$ ，就连 $i\to j$ 流量为 $1$ ；如果如果小伙伴 $j$ 的某张牌数量 $b_{j,i}&gt;1$ ，就向 $i$ 连 $f=b_{j,i}-1$ 的边。流一下就好了。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><h2 id="ACM-ICPC-Taiwan-2005-Optimal-Bus-Route-Design"><a href="#ACM-ICPC-Taiwan-2005-Optimal-Bus-Route-Design" class="headerlink" title="*[ACM/ICPC Taiwan 2005] Optimal Bus Route Design"></a>*[ACM/ICPC Taiwan 2005] Optimal Bus Route Design</h2><blockquote><p> 给出一个有向图，你需要让每一个点都恰好在一个环中，并且边权和最小。</p></blockquote><p>…喜闻乐见的找性质题。</p><p>首先转化一下，「每个点恰好在一个环中」=「每个点后继的唯一」。因为每个点都显然会有一条出边一条入边，所以直接拆点跑一个 KM 或者费用流就一定是合法解。</p><p>……一开始的时候感觉是个裸匹配，然后回忆起曾经做过的无向图找非简单环的计数题似乎答案是个贼大的数，就十分懵逼。</p><h2 id="LA4043-Ants"><a href="#LA4043-Ants" class="headerlink" title="**[LA4043]  Ants"></a>**[LA4043]  Ants</h2><blockquote><p>给定一些黑点白点，要求一个黑点连接一个白点，并且所有线段都不相交。</p><p>$n\leq 500$ 。</p></blockquote><p>感觉这题的俩做法都很经典有趣啊。</p><h3 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>大概是需要深刻地发现一些性质。考虑如果四个点连两条线段想要不交的话，那么感性理解一下要么并排着竖着连，要么并排着横着连，随便旋转一下坐标系可以知道两者是等价的。那么考虑如何横着选，发现如果对于第一列的点如果各自找与自己距离最小的点，就一定不会相交。进一步考虑全局，如果最后点对之间的总距离之和最小那么同样不会交。所以做一遍 KM 就好了。</p><h3 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>考虑暴力分治。感觉这个做法没点经验是想不出来的。考虑上面 KM 算法所找的最近点对完全可以分治做。具体的，先随机选一个点，然后让其他的点按照以当前点为坐标原点的极角排序，观察最小的那个：</p><p>1、如果颜色不同，那么就直接匹配。</p><p>2、如果颜色相同，就继续找更大的，直到找过的所有点中两种颜色数量相等且当前点与源点颜色不同。此时头尾匹配一下，就可以分治成两部分继续做了。</p><h2 id="ACM-ICPC-Harbin-2010-货物运输"><a href="#ACM-ICPC-Harbin-2010-货物运输" class="headerlink" title="[ACM/ICPC Harbin 2010] 货物运输"></a>[ACM/ICPC Harbin 2010] 货物运输</h2><blockquote><p>费用为 $af^2$ 的费用流。</p></blockquote><p>主要就是用了这个技巧。考虑常见的拆平方技巧</p><script type="math/tex; mode=display">f^2=1+3+5+7+\cdots</script><p>然后就可以根据值域拆成多个弧来做了。</p><h2 id="ACM-ICPC-Dhaka-2006-Paint-the-Roads"><a href="#ACM-ICPC-Dhaka-2006-Paint-the-Roads" class="headerlink" title="[ACM/ICPC Dhaka 2006] Paint the Roads"></a>[ACM/ICPC Dhaka 2006] Paint the Roads</h2><blockquote><p>一个 $n$ 个点 $m$ 条带权有向边的图，要给边染色，染色的边形成若干个回路且每个点都恰好属于其中 $k$ 个回路。问最少要染多少边权和的路。</p></blockquote><p>考虑有了前面的铺垫，属于 $k$ 个回路可以直接拆成 $k$ 组匹配。做就好了。</p><h2 id="ACM-ICPC-World-Final-2011-Chips-Challenge"><a href="#ACM-ICPC-World-Final-2011-Chips-Challenge" class="headerlink" title="*[ACM/ICPC World Final 2011] Chips Challenge"></a>*[ACM/ICPC World Final 2011] Chips Challenge</h2><blockquote><p>有一个芯片，芯片上有 $N*N(1≤N≤40)$ 个插槽，可以在里面装零件。<br>有些插槽不能装零件，有些插槽必须装零件，剩下的插槽随意。<br>要求装好之后满足如下两条要求：</p><p>1、第 i 行和第 i 列的零件数目必须一样多（$1≤i≤N$）。</p><p>2、第 i 行的零件数目不能超过总的零件数目的 $A/B$（$1≤i≤N$，$0≤A≤B≤1000$，$B≠0$）。</p><p>求最多可以另外放多少个零件（就是除掉必须放的）。如果无解输出impossible。</p></blockquote><p>学到了，大概是发现有些约束互相影响，或者是个变量不好处理的时候，可以考虑枚举这个约束。</p><p>大概就是考虑枚举零件总数 $s$ ，然后去check这个结果是否合理。考虑怎么 check，不难知道要行列二分图那种感觉，中间钦定为 $1$ 的就连上下界均为 $1$ 的边，钦定为 $0$ 的就不连边，没钦定的就连上界为 $1$ 的边。然后求出此时可以放的部件数。如果大于枚举的 $ans$ 就说明合法。</p><p>于是最后大概要跑一个有源汇上下界最大费用最大流？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了点网络流题目，算是对网络流的一个复习吧。&lt;/p&gt;
&lt;p&gt;感觉现在建起图来已经可以算是得心应手了.jpg&lt;/p&gt;
&lt;p&gt;打星的题目都比较有趣。大部分题目可能没有数据范围，当作 O(网络流能过) 就好了。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;虽然现在都考模拟费用流，建图费用流已经是历史的眼泪了。&lt;/del&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="网络流/费用流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
      <category term="图论/普通建图技巧" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E6%99%AE%E9%80%9A%E5%BB%BA%E5%9B%BE%E6%8A%80%E5%B7%A7/"/>
    
      <category term="图论/线段树优化建图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/"/>
    
      <category term="网络流/带有上下界的网络流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%B8%A6%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="图论/匹配/KM算法" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-KM%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【题解】简单数学题放送</title>
    <link href="https://www.orchidany.cn/2020/05/27/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98%E6%94%BE%E9%80%81/"/>
    <id>https://www.orchidany.cn/2020/05/27/简单数学题放送/</id>
    <published>2020-05-27T11:59:53.000Z</published>
    <updated>2020-05-28T00:31:08.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>四处找来的简单数学题，挑了一些题目整理一下。</p><a id="more"></a><h1 id="ACM-ICPC-CERC-2013-Magical-GCD"><a href="#ACM-ICPC-CERC-2013-Magical-GCD" class="headerlink" title="[ACM/ICPC CERC 2013] Magical GCD"></a>[ACM/ICPC CERC 2013] Magical GCD</h1><blockquote><p>给一个长度为 $n(n≤100000)$ 的数列(每个数 $a[i]≤10^{12}$ )，找到一个连续子序列使得子序列的公约数与长度的乘积最大，求这个最大值。共 T 组数据。</p></blockquote><p>大概是利用了 $\gcd$ 的一定性质。考虑对于一个确定的右端点 $r$ ，创建一张保存 $\gcd(l,r)$ 本质不同的 $l$ 表，不难发现这张表的长度是 $O(\log n)$ 的。这样就可以用链表维护一下这个表，每次右端 $+1$ 时暴力合并表中间相同的元素。最终复杂度 $O(n\log n)$ 。</p><h1 id="除法表达式"><a href="#除法表达式" class="headerlink" title="除法表达式"></a>除法表达式</h1><blockquote><p>给出一个除法表达式 $X_1/X_2/X_3\cdots/X_n$ 。求能否通过加括号的方式让式子的值为整数</p></blockquote><p>考虑贪心的放括号，一定是这么放的：$X_1/(X_2/X_3\cdots/X_n)$ 。因为这样会使分母上的数最多，为 $X_1\cdot \prod X_{j{[j=2\to n]}}$ 。于是就分解一下质因数就好了。</p><h1 id="UVA11582-Colossal-Fibonacci-Numers-加强版"><a href="#UVA11582-Colossal-Fibonacci-Numers-加强版" class="headerlink" title="[UVA11582] Colossal Fibonacci Numers! 加强版"></a>[UVA11582] Colossal Fibonacci Numers! 加强版</h1><blockquote><p>求一个广义的斐波那契递推：在 $f(0)=c,f(1)=d$ 时：</p><script type="math/tex; mode=display">f(n)=a f(n-1)+b f(n-2)</script><p>的第 $f(x^y)$ 项在模 $n$ 下的值。$1\leq n\leq 5000$ 。</p></blockquote><p>考虑由于是 $2$ 阶线性递推，那么显然在模 $n$ 意义下循环节长度有一个上界 $O(n^2)$ 。于是就可以暴力求出循环节长度 $o$，计算 $a^b$ 的时候模 $o$ 即可。</p><h1 id="UVA10791-Minimum-Sum-LCM"><a href="#UVA10791-Minimum-Sum-LCM" class="headerlink" title="[UVA10791] Minimum Sum LCM"></a>[UVA10791] Minimum Sum LCM</h1><blockquote><p>给定一个 $n$ ，求至少两个正整数使得他们最小公倍数为 $n$ 且其和最小。$n\in \rm int$ 。</p></blockquote><p>考虑为了使和最小，有多余因子是不够优的。所以答案就是 $\sum p_k^{a_k}$ 。注意当 $n$ 是素数幂或者 $1$ 时需要判一点细节。</p><h1 id="ACM-ICPC-Dhaka-2013-GCD-XOR"><a href="#ACM-ICPC-Dhaka-2013-GCD-XOR" class="headerlink" title="[ACM/ICPC Dhaka 2013] GCD XOR"></a>[ACM/ICPC Dhaka 2013] GCD XOR</h1><blockquote><p>给定 $n$ ，求有多少对正整数 $(a,b)$ 满足 $1\leq b\leq a\leq n$ ，且 $\gcd(a,b)=a\operatorname{xor} b$ 。</p><p>$1\leq n\leq 10^6$ .</p></blockquote><p>考虑暴力枚举 $a$ 的约数 $c$ 再去 check 的复杂度是 $\log^2n$ 的，需要优化。发现如果 $\gcd(a,b)=a\operatorname{xor} b$ ，那么 $a-b=a\operatorname{xor} b$ 。原因是考虑 $\gcd(a,b)=\gcd(b,a-b)\leq a-b\leq a\operatorname{xor} b$ 。所以这就可以省掉一个求 $\gcd$ 的 $\log$ ，直接枚举 $a$ 的约数 $c$ ，再去 check 是否有 $c=a\operatorname{xor}(a-c)$ 即可。</p><h1 id="ACM-ICPC-NEERC-2004-Irrelevant-Elements"><a href="#ACM-ICPC-NEERC-2004-Irrelevant-Elements" class="headerlink" title="[ACM/ICPC NEERC 2004] Irrelevant Elements"></a>[ACM/ICPC NEERC 2004] Irrelevant Elements</h1><blockquote><p>给定一个长为 $n$ 的数列，每次相邻两项相加得到一个长度减小 $1$ 的新数列，求最后长度为 $1$ 时的数模 $m$ 的余数和哪几项无关。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>考虑最后每一项的贡献系数一定是杨辉三角的形式。这样只需要求每一个系数是否是 $m$ 的倍数。注意到暴力求组合数精度会爆炸，于是考虑分解，但是分解了之后复杂度会爆炸。考虑有</p><script type="math/tex; mode=display">\binom{n}{k}=\frac{n-k+1}{k}\cdot \binom{n}{k-1}</script><p>那么就可以通过分解质因数的方式来判断是否是 $m$ 的倍数。最后复杂度 $O(n\log n)$。</p><h1 id="ACM-ICPC-NEERC-2009-Headshot"><a href="#ACM-ICPC-NEERC-2009-Headshot" class="headerlink" title="[ACM/ICPC NEERC 2009] Headshot"></a>[ACM/ICPC NEERC 2009] Headshot</h1><blockquote><p>枪里有 $n$ 个弹夹 $m$ 颗子弹。你扣了一次扳机之后没有子弹。你希望下一枪也没子弹。你是应该立即再扣一枪还是随机转一下再扣？</p></blockquote><p>因为已经扣了一枪，所以考虑条件概率公式 $P(A) = P(B)\times P(A\mid B)$ ，即可以知道连续两枪没有子弹的概率是 $\dfrac{\mathrm{cnt}(00)}{\mathrm{cnt}(0)}$ 。随机转一下的概率是 $\dfrac{\mathrm{cnt}(0)}{\mathrm{cnt}(0)+\mathrm{cnt}(1)}$ 。比较一下即可。</p><h1 id="UVA10491-Cows-and-Cars"><a href="#UVA10491-Cows-and-Cars" class="headerlink" title="[UVA10491] Cows and Cars"></a>[UVA10491] Cows and Cars</h1><blockquote><p>著名主持人和羊和车问题。共有 $m$ 个羊和 $n$ 个车。主持人会打开 $k$ 扇门。输出在「总是换门」策略的基础上赢得车的概率。</p></blockquote><p>还是条件概率题。考虑一开始在打开了 $k$ 个🐑门之后，还剩 $m-k$ 个羊门，剩 $m+n-k-1$ 个门可以换。那么考虑吧分类：</p><p>1、一开始选的是羊门，这部分概率是 $\dfrac{m}{n+m}\cdot \dfrac{n}{n+m-k-1}$ 。</p><p>2、一开始选的是车门，这部分概率是 $\dfrac{n}{n+m}\cdot \dfrac{n-1}{n+m-k-1}$ 。</p><p>相加一下即可。</p><h1 id="UVA580-Critical-Mass"><a href="#UVA580-Critical-Mass" class="headerlink" title="[UVA580] Critical Mass"></a>[UVA580] Critical Mass</h1><blockquote><p>要求你统计所有长度为 $n$ 的 $01$ 串中，有多少个串内至少有  $3$ 个 $1$ 放在一起。</p></blockquote><p>考虑分类讨论最左边连续三个 $1$ 的位置，假设是 $i,i+1,i+2$。设 $f(i)$ 表示答案，那么有</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n-2} \left(2^{i-1}-f(i-1)\right)\cdot 2^{n-i-2}</script><p>但是这并不对，因为可能会存在 $i-2,i-1,i$ 或者 $i-1,i,i+1$ 是连续 $3$ 个 $1$ <del>（梦回麻将）</del> 。于是就考虑钦定 $i-1$ 放 $0$ 。所以就变成了</p><script type="math/tex; mode=display">f(n)=2^{n-3}+\sum_{i=2}^{n-2} \left(2^{i-2}-f(i-2)\right)\cdot 2^{n-i-2}</script><p>其中要单独加上 $i=1$ 的贡献。注意到这就是一个分治 FFT 的标准形式，随便优化一下就好了。</p><h1 id="UVA12034-Race"><a href="#UVA12034-Race" class="headerlink" title="[UVA12034] Race"></a>[UVA12034] Race</h1><blockquote><p>求 $n$ 个人赛马的最终名次可能性种类数。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>暴力的话，考虑最后有 $k$ 个人并列第一。那么有转移</p><script type="math/tex; mode=display">f(n)=\sum \binom{n}{k}\cdot f(n-k)</script><p>算一下即可。那么如果 $n=10^5$，可以考虑直接分治 FFT。即考虑把式子拆开为</p><script type="math/tex; mode=display">f(n)=n!\cdot \sum \frac{1}{k!}\cdot\frac{f(n-k)}{(n-k)!}</script><p>令 $g(i)=\dfrac{1}{i!}$，就可以直接做了。复杂度 $O(n\log ^2 n)$ 。</p><h1 id="ACM-ICPC-Daejon-2012-Pole-Arrangement"><a href="#ACM-ICPC-Daejon-2012-Pole-Arrangement" class="headerlink" title="[ACM/ICPC Daejon 2012] Pole Arrangement"></a>[ACM/ICPC Daejon 2012] Pole Arrangement</h1><blockquote><p>长度分别为 $1\sim n$ 的杆子排成一列。从左边能看到 $l$ 根，从右边能看到 $r$ 根。求有多少种排列数。</p><p>$1\leq n\leq 300$ 。</p></blockquote><p>考虑直接 $dp$ 。设 $f_{i,j,k}$ 表示考虑从小到大的 $i$ 个杆子，从左边看到 $j$ 根，从右边看到 $k$ 根的方案数。那么考虑每次通过放一个更加小的杆子来转移。即</p><script type="math/tex; mode=display">f_{i,j,k}=f_{i-1,j-1,k}+f_{i-1,j,k-1}+f_{i-1,j,k}</script><p>其中分别是放在两边和中间的方案数。</p><p>考虑这种排列计数的题目大部分都是枚举最大的或者最小的来转移。然而此题放最长的杆子会锅，于是就只能拿最小的杆子来转移。</p><h1 id="ACM-ICPC-Wuhan-2009-Crossing-Rivers"><a href="#ACM-ICPC-Wuhan-2009-Crossing-Rivers" class="headerlink" title="[ACM/ICPC Wuhan 2009] Crossing Rivers"></a>[ACM/ICPC Wuhan 2009] Crossing Rivers</h1><blockquote><p>两地之间距离为 $n$ ，行走速度 $1/s$ 。有 $m$ 条长度分别为 $L_i$ 的河，在上面划船速度为 $v_i$ 。每次到达一条河时需要等船过来再走。如果出门时船的位置和朝向都是随机分布，求期望多久到达对岸。</p></blockquote><p>比较基础的一道期望题目。考虑过第 $i$ 条河的时间在 $\left[\dfrac{L_i}{v_i},\dfrac{3\cdot L_i}{v_i}\right)$ 中均匀随机，于是期望就是做个平均数，用线性性加一下就好了。</p><h1 id="经典问题-多边形"><a href="#经典问题-多边形" class="headerlink" title="[经典问题] 多边形"></a>[经典问题] 多边形</h1><blockquote><p>有一根长度为 $1$ 的木棒。随机选 $k$ 个位置切开，求这些小木条能组成一个多边形的概率。 </p></blockquote><p>再 放 送。</p><p>考虑连成一个圆之后变成了随便选 $k+1$ 个位置。那么考虑拼成一个多边形当且仅当其中最长的那段弧长度严格小于 $\dfrac{1}{2}$ 。那么答案就是</p><script type="math/tex; mode=display">1-\frac{k+1}{2^k}</script><p>即考虑对弧计数。考虑对于弧的一个端点 $p$ ，有 $k+1$ 种取法，对于其他的点有 $\dfrac{1}{2^k}$ 的概率都在同一侧。对答案取个补即可。</p><p>……注意到是不会有弧长度超过 $\dfrac{1}{2}$ 的，这个小细节一开始被自己忽略了。</p><h1 id="UVA10213-How-many-pieces-of-Land"><a href="#UVA10213-How-many-pieces-of-Land" class="headerlink" title="[UVA10213] How many pieces of Land?"></a>[UVA10213] How many pieces of Land?</h1><blockquote><p>给定一个圆，边界上选 $n$ 个点两两连边，最多能划分出多少个区域。</p></blockquote><p>考虑一种欧神教我的神奇做法。首先不难发现是可以做到不存在三点共线的，并且不共线结果至少不会更劣。那么如果设 $g(i)$ 表示交出的这些区域中 $i $ 边形的个数（只考虑交出来的最小单元），会有</p><script type="math/tex; mode=display">\sum _{i=3}^{n} i\times g(i)=n+2\cdot \left(2\cdot \binom{n}{4}+ \binom{n}{2}-n\right)</script><p>即每条边会产生两次贡献，这 $n$ 个点最后连出的边可以交出 $\binom{n}{4}$ 个交点，每删掉一个交点可以多出两条线段。同时最后交点删干净之后还剩 $\binom{n}{2}$ 条线段，同时为了单独计算相邻点之间的连边要先减去 $n$ 并且最后再加回来。</p><p>同时再考虑内角和的贡献。即</p><script type="math/tex; mode=display">\sum_{i=3}^ng(i)\cdot(i-2) \pi=2\pi\cdot \binom{n}{4}+(n-2)\pi</script><p>其中右边第一项是每个点周围一圈是 $2\pi$ ，第二项是考虑最大的那个 $n$ 边形的内角和。</p><p>考虑上面两个式子作差，可以得到</p><script type="math/tex; mode=display">\sum_{i=3}^n g(i)=\binom{n}{4}+\binom{n-1}{2}+n</script><p>即为答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四处找来的简单数学题，挑了一些题目整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】APIO2019 简要题解</title>
    <link href="https://www.orchidany.cn/2020/05/25/APIO2019/"/>
    <id>https://www.orchidany.cn/2020/05/25/APIO2019/</id>
    <published>2020-05-25T01:16:51.000Z</published>
    <updated>2020-05-25T03:34:29.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了一下去年 APIO 的题。</p><p>口胡了一下发现可以 $60(=13+16+17+14)+100+40(=20+20)$，大概 $200$ 分拿个 Ag 的样子。</p><p>可能还是比较菜吧，唉。</p><p>哦，似乎从题目注释里面可以看出来这是毛子出的题。不明白毛子为什么又对这种题感兴趣了。</p><a id="more"></a><h1 id="A-Bridges"><a href="#A-Bridges" class="headerlink" title="A Bridges"></a>A Bridges</h1><blockquote><p>给定一张图，每条边有个限重。有两种操作，第一种是修改某条边的限重，第二种是询问从某个点以重量 $w$ 开始走，可以走到多少个点。$n\leq 5\times 10^4,1\leq q,m\leq 2\times 10^5$ 。</p></blockquote><p>暴力分不说了，$16$ 分的链可以线段树上二分，$17$ 分的完全二叉树由于树高很低所以可以随便拿个什么数据结构来暴力维护。考虑只有询问操作的 $14$ 分。发现可以将全部的询问离线，然后和边放在一起按照权重从大到小进行排序，然后就可以直接拿个并查集来维护 size。不难理解这样做的正确性。</p><p>之后考虑满分…大概是没怎么见过的分块技巧。考虑对所有操作按时间分块，块大小为 $B$ 。那么前面的块里的修改就可以暴力改完，当前块内则按照上面 $\rm subtask4$ 的做法离线下来。注意到如果某条边在这个块里不会被修改就不管他，继续放在一起离线。对于每个询问，暴力每个修改操作，判断此时这条边是否有用。注意到此处应该按时间来对所有修改进行排序，这样就可以知道对于每条边只有最后一个修改才会有效。</p><p>这样就需要再维护一个可撤销的并查集，因为对于每一次询问都需要暴力那些修改，所以这样会带 $\log$ 。于是最后的复杂度就是</p><script type="math/tex; mode=display">O(\frac{q}{B}\cdot\left(B^2\log n+m\log m\right))=O(qB\log n+\frac{q}{B}m\log m)</script><p>实测最后似乎在 $B=800\sim 1300$ 时效果最好。但是我写的时候由于用了 <code>vector</code> 套 <code>tuple</code> ，常数比较大…</p><p>感觉思路还是挺直接的，想出分块来可能就 win 了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, id ;</span><br><span class="line">    edg (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">        x = a ; y = b ; z = c ; id = d ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[N], e[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">int</span> id, o ;</span><br><span class="line">&#125;op[N] ;</span><br><span class="line">opt tmp[N] ;</span><br><span class="line">opt pmt[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q, k ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N] ;</span><br><span class="line"><span class="keyword">int</span> R[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt1 ;</span><br><span class="line"><span class="keyword">int</span> cnt2 ;</span><br><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; stk ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (sz[f1] &gt; sz[f2])&#123;</span><br><span class="line">        stk.emplace_back(f1, f2, sz[f1]) ;</span><br><span class="line">        fa[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        stk.emplace_back(f2, f1, sz[f2]) ;</span><br><span class="line">        fa[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_y</span><span class="params">(opt a, opt b)</span></span>&#123; <span class="keyword">return</span> a.y &gt; b.y ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_val</span><span class="params">(edg a, edg b)</span></span>&#123; <span class="keyword">return</span> a.z &gt; b.z ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> yz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (stk.size() &gt; yz)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z ;</span><br><span class="line">        tie(x, y, z) = stk.back() ;</span><br><span class="line">        sz[x] = z ; fa[y] = y ; stk.pop_back() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr() ;</span><br><span class="line">        y = qr() ;</span><br><span class="line">        z = qr() ;</span><br><span class="line">        E[i] = edg(x, y, z) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q ; k = q / M + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        L[i] = R[i - <span class="number">1</span>] + <span class="number">1</span>, R[i] = L[i] + M - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L[k] &gt; q) -- k ; R[k] = min(R[k], q) ;</span><br><span class="line"><span class="comment">//    debug(L, 1, k) ;</span></span><br><span class="line"><span class="comment">//    debug(R, 1, k) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        op[i].id = i, op[i].o = qr() ;</span><br><span class="line">        op[i].x = qr(), op[i].y = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            fa[j] = j, sz[j] = <span class="number">1</span> ; cnt1 = cnt2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j) vis[j] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i] ; j &lt;= R[i] ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (op[j].o == <span class="number">1</span>)</span><br><span class="line">                vis[op[j].x] = <span class="number">1</span>, tmp[++ cnt1] = op[j] ;</span><br><span class="line">            <span class="keyword">else</span> pmt[++ cnt2] = op[j] ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(vis, 1, m) ;</span></span><br><span class="line">        ctn = <span class="number">0</span> ; <span class="keyword">int</span> p = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) e[++ ctn] = E[j] ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; ctn &lt;&lt; '\n' ;</span></span><br><span class="line">        sort(e + <span class="number">1</span>, e + ctn + <span class="number">1</span>, comp_val) ;</span><br><span class="line">        sort(pmt + <span class="number">1</span>, pmt + cnt2 + <span class="number">1</span>, comp_y) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt2 ; ++ j)&#123;</span><br><span class="line"><span class="comment">//            debug(pmt[j].x, ' ') ;</span></span><br><span class="line"><span class="comment">//            debug(pmt[j].y, ' ') ;</span></span><br><span class="line"><span class="comment">//            debug(p) ;</span></span><br><span class="line">            <span class="keyword">while</span> (e[p].z &gt;= pmt[j].y &amp;&amp; p &lt;= ctn)</span><br><span class="line">                merge(e[p].x, e[p].y), ++ p ;</span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line">            <span class="keyword">int</span> t = stk.size() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = cnt1 ; h &gt;= <span class="number">1</span> ; -- h)&#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp[h].id &lt;= pmt[j].id &amp;&amp; vis[tmp[h].x])&#123;</span><br><span class="line">                    vis[tmp[h].x] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (tmp[h].y &gt;= pmt[j].y)</span><br><span class="line">                        merge(E[tmp[h].x].x, E[tmp[h].x].y) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            puts("**************************") ;</span></span><br><span class="line"><span class="comment">//            debug(vis, 1, m) ;</span></span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line"><span class="comment">//            puts("- - - - - - - - - - - - - - -") ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span> ; h &lt;= cnt1 ; ++ h)</span><br><span class="line">                <span class="keyword">if</span> (vis[tmp[h].x] &amp;&amp; E[tmp[h].x].z &gt;= pmt[j].y)</span><br><span class="line">                    merge(E[tmp[h].x].x, E[tmp[h].x].y) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span> ; h &lt;= cnt1 ; ++ h)</span><br><span class="line">                <span class="keyword">if</span> (!vis[tmp[h].x]) vis[tmp[h].x] = <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//            puts("********&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;******") ;</span></span><br><span class="line"><span class="comment">//            debug(vis, 1, m) ;</span></span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line"><span class="comment">//            puts("- - - -^^^^^^^^^- - - - - -") ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt;  find(pmt[j].x)  &lt;&lt; '\n' ;</span></span><br><span class="line">            ans[pmt[j].id] = sz[find(pmt[j].x)] ;</span><br><span class="line">            clear(t) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt1 ; ++ j)</span><br><span class="line">            E[tmp[j].x].z = tmp[j].y ;</span><br><span class="line">        clear(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="B-Device"><a href="#B-Device" class="headerlink" title="B Device"></a>B Device</h1><blockquote><p>给定一条数轴和  $A,B$。</p><p>数轴上的每个位置都可以产生一个数对 $(x,y)$ ，其中 $x = ((t + \left\lfloor \frac{t}{B} \right\rfloor) \bmod A),y = (t \bmod B)$。</p><p>在给定 $n$ 个连续区间 $[l_i,r_i]$ 。求所有区间里有多少本质不同的位置。本质不同指产生的数对不同。</p><p>$1\le n\le 10^6,1\le A,B\le 10^{18},0\le l_i\le r_i\le 10^{18},r_i&lt;l_{i+1}$。</p></blockquote><p>大概是场上最简单的题了。推的时候可能需要细心一点。然后以下是我 xjb 推的过程</p><script type="math/tex; mode=display">\begin{aligned}t_{1}+\left\lfloor\frac{t_1}{B}\right\rfloor&\equiv t_{2}+\left\lfloor\frac{t_{2}}{B}\right\rfloor \pmod{A} \\t_{1}-B\cdot \left\lfloor \frac{t_1}{B}\right\rfloor&\equiv t_{2}- B \cdot\left\lfloor\frac{t_2}{B}\right\rfloor\end{aligned}</script><p>$(1)-(2)$ 可以得到</p><script type="math/tex; mode=display">\begin{aligned}(B+1)\left\lfloor\frac{t_1}{B}\right\rfloor &\equiv(B+1)\left\lfloor \frac{t_2}{B}\right\rfloor \pmod A \\\left\lfloor\frac{t_1}{B}\right\rfloor&\equiv \left\lfloor \frac{t_{2}}{B}\right\rfloor \pmod{\frac{A}{(B + 1, A)}}\end{aligned}</script><p>从而</p><script type="math/tex; mode=display">\begin{aligned}\because t_{2}&=t_{1}+B t \\\therefore \left\lfloor\frac{t_{1}}{B}\right\rfloor &\equiv \left\lfloor \frac{t_{1}+Bt}{B}\right\rfloor \equiv\left\lfloor\frac{t_1}{B}+t\right\rfloor \\&\equiv\left\lfloor\frac{t_{1}}{B}\right\rfloor + t\pmod {\frac{A}{(B+1,A)}}\end{aligned}</script><p>那么也就是说需要两个 $t$ 之间满足</p><script type="math/tex; mode=display">\Delta t=\frac{A\times B}{(A, B+1)}</script><p>于是就可以先判一下是否存在区间长度 $\geq \Delta t$ 。如果有答案就是 $\Delta t$ ，否则考虑每个区间都可以对其取模，之后就会变成一段或者两段(取决于取模完后 $l,r$ 的大小关系)，然后就变成经典的求一个区间内到底覆盖了多少个位置的问题。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll A, B ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rgs</span>&#123;</span></span><br><span class="line">    ll l, r ;</span><br><span class="line">    rgs (ll a = <span class="number">0</span>, ll b = <span class="number">0</span>)&#123; l = a, r = b ; &#125;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> rgs &amp; a, <span class="keyword">const</span> rgs &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("05", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//    freopen("1.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; A &gt;&gt; B ; tot = n ;</span><br><span class="line">    res = A / gcd(A, B + <span class="number">1</span>), res *= B ;</span><br><span class="line"><span class="comment">//  cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i].l = qr(), base[i].r = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (base[i].r - base[i].l + <span class="number">1</span> &gt;= res)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>, <span class="number">0</span> ;</span><br><span class="line">        base[i].r %= res ; base[i].l %= res ;</span><br><span class="line">        <span class="keyword">if</span> (base[i].l &gt; base[i].r)&#123;</span><br><span class="line">            base[++ tot] = rgs(base[i].l, res - <span class="number">1</span>) ;</span><br><span class="line">            base[i] = rgs(<span class="number">0</span>, base[i].r) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; base[i].l &lt;&lt; " " &lt;&lt; base[i].r &lt;&lt; '\n' ;</span></span><br><span class="line">    n = tot ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    ll l = base[<span class="number">1</span>].l, r = base[<span class="number">1</span>].r ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (base[i].l &gt; r)</span><br><span class="line">            ans += r - l + <span class="number">1</span>, l = base[i].l ;</span><br><span class="line">        r = max(r, base[i].r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += r - l + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="C-Lamps"><a href="#C-Lamps" class="headerlink" title="C Lamps"></a>C Lamps</h1><blockquote><p>给定一条长为 $n+1$ 的数轴，每个 $[i,i+1]$ 之间都有一盏编号为 $i$ 的灯，如果亮则意味着 $i,i+1$ 连通，否则不连通。有两种操作，每次会选择某盏灯将其状态取反，或者询问两个点 $a,b$ 从第一次操作开始有多少次操作是灭的。</p><p>$n,q\leq 3\times 10^5$ 。</p></blockquote><p>orz 神仙题，大概是一堆 trick 的堆砌，然后我就啥都不会 QAQ。</p><p>考虑这东西一点也不好维护，于是就将信息抽象到二维上。具体的，可以将点对 $(a,b)$ 作为询问 $(a,b)$ 的答案。</p><p>之后考虑怎么维护。首先可以用珂朵莉树那样用 <code>set</code> 维护亮着的连续段。之后假设取反了 $i$ 号灯，那么假设与 $i$ 相连的连通块最左边是 $l$，与 $i+1$ 相连的连通块最左边是 $r$。那么考虑每次实际上是让 </p><script type="math/tex; mode=display">(l,i+1),(l,i+2)\cdots (l,r),(l+1,i+1),(l+1,i+2)\cdots(i,r)</script><p>这些点连通起来。这在二维平面上就是一个左上角为 $(l,i+1)$ ，右下角为 $(i,r)$ 的矩阵。考虑如何对这个矩阵搞事情，发现很难维护这个矩阵里的连通性，于是考虑差分。具体的，如果设总时间为 $t$ ，当前时间为 $t_0$，那么可以考虑在每次开的时候将这个矩阵加上 $t-t_0$ ，关的时候减去 $t-t_0$ ，这样两次修改的 $\Delta$ 就是 $t-t_1-(t-t_2)=t_2-t_1$ 。由于一盏灯每次只会进行取反操作，所以正确性可以保证。</p><p>同时，考虑这样做的话，询问 $(a,b)$ 时可能还是两者之间此时依旧是连通的。为了计算这一部分贡献需要让询问一开始就减去 $t-t_0$ 。</p><p>然后就是一个朴素的矩阵加，单点询问了。将每个修改差分成四个之后可以直接跑 CDQ。</p><p>这样做的复杂度是 $O((n+4\cdot q)\log n\log q)$ 的。这东西…也不知道为什么就能跑得过 $1e6$ 。反正常数很恐怖。</p><p>似乎是有把一个修改拆成俩修改再 CDQ 的，这样做直接节约了一倍常数。但是我并不知道那是个什么原理…</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> n, q ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">char</span> Inp[<span class="number">50</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, isq ;</span><br><span class="line">    <span class="keyword">int</span> x, y, v ;</span><br><span class="line">    qss (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">        id = a ; isq = z ; x = b ; y = c ; v = d ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;qs[N], tmp[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> qss &amp; a, <span class="keyword">const</span> qss &amp; b)</span></span>&#123; <span class="keyword">return</span> a.id &lt; b.id ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n + <span class="number">1</span> ; x += (x &amp; -x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ret += _bit[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> tl = l, tr = mid + <span class="number">1</span> ;</span><br><span class="line">    cdq(l, mid) ; cdq(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">while</span> (tr &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (tl &lt;= mid &amp;&amp; qs[tl].x &lt;= qs[tr].x)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!qs[tl].isq) ins(qs[tl].y, qs[tl].v) ; ++ tl ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qs[tr].isq)&#123;</span><br><span class="line"><span class="comment">//            debug(qs[tr].x) ;</span></span><br><span class="line"><span class="comment">//            debug(qs[tr].y) ;</span></span><br><span class="line"><span class="comment">//            debug(</span></span><br><span class="line">            ans[qs[tr].id] += qry(qs[tr].y) ;</span><br><span class="line"><span class="comment">//            ) ;</span></span><br><span class="line">        &#125; ++ tr ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tl &gt; l)</span><br><span class="line">        <span class="keyword">if</span> (!qs[-- tl].isq) ins(qs[tl].y, - qs[tl].v) ;</span><br><span class="line">    tr = mid + <span class="number">1</span> ; <span class="keyword">int</span> tot = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (tl &lt;= mid || tr &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt;= r &amp;&amp; qs[tl].x &gt;= qs[tr].x) tmp[++ tot] = qs[tr ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tl &lt;= mid &amp;&amp; qs[tl].x &lt;= qs[tr].x) tmp[++ tot] = qs[tl ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tl &lt;= mid &amp;&amp; tr &gt; r) tmp[++ tot] = qs[tl ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt;= r &amp;&amp; tl &gt; mid) tmp[++ tot] = qs[tr ++] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) qs[i] = tmp[i - l + <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r ;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> seg &amp;t)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">return</span> t.l &gt; l ; &#125;</span><br><span class="line">seg (<span class="keyword">int</span> L = <span class="number">0</span>, <span class="keyword">int</span> R = <span class="number">0</span>, <span class="keyword">int</span> idd = <span class="number">0</span>)&#123;</span><br><span class="line">        l = L ; r = R ; id = idd ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="built_in">set</span> &lt;seg&gt; s ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> x, y, b, c ;</span><br><span class="line">    s.insert(seg(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        s.insert(seg(i, i, ++ cnt)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (base[i])&#123;</span><br><span class="line">            <span class="keyword">auto</span> l = -- s.lower_bound(seg(i, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">            <span class="keyword">auto</span> r = s.lower_bound(seg(i + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">            <span class="keyword">if</span> (l -&gt; r &lt; i) ++ l ; <span class="keyword">int</span> L = l-&gt;l, R = r-&gt;r ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; '\n' ;</span></span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, i + <span class="number">1</span>, q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, i + <span class="number">1</span>, i + <span class="number">1</span>, -q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, R + <span class="number">1</span>, -q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, i + <span class="number">1</span>, R + <span class="number">1</span>, q) ;</span><br><span class="line">            s.erase(l) ;</span><br><span class="line">            <span class="keyword">if</span> (r != l)</span><br><span class="line">                s.erase(r) ;</span><br><span class="line">            s.insert(seg(L, R, ++ cnt)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, Inp + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (Inp[<span class="number">1</span>] == <span class="string">'q'</span>)&#123;</span><br><span class="line">            ++ tot ;</span><br><span class="line">            x = qr(), y = qr()  ;</span><br><span class="line">            <span class="keyword">auto</span> l = -- s.lower_bound(x) ;</span><br><span class="line">            <span class="keyword">auto</span> r = -- s.lower_bound(y) ;</span><br><span class="line">            <span class="keyword">if</span> (l -&gt; r &lt; x) ++ l ;</span><br><span class="line">            <span class="keyword">if</span> (r -&gt; r &lt; y) ++ r ;</span><br><span class="line">            qs[tot] = qss(tot, <span class="number">1</span>, x, y, <span class="number">0</span>) ;</span><br><span class="line">            ans[tot] = (l == r) ? -(q - i) : <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = qr() ;</span><br><span class="line">            <span class="keyword">if</span> (base[x])&#123;</span><br><span class="line">                <span class="keyword">auto</span> y = -- s.lower_bound(seg(x, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">if</span> (y -&gt; r &lt; x) ++ y ; <span class="keyword">int</span> l = y -&gt; l, r = y -&gt; r ;</span><br><span class="line"><span class="comment">//                cerr &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, l, x + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, x + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, l, r + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, r + <span class="number">1</span>, i - q) ;</span><br><span class="line">                s.erase(y) ;</span><br><span class="line">                s.insert(seg(l, x, ++ cnt)) ;</span><br><span class="line">                s.insert(seg(x + <span class="number">1</span>, r, ++ cnt)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> l = -- s.lower_bound(seg(x, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">auto</span> r = -- s.lower_bound(seg(x + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">if</span> (l -&gt; r &lt; x) ++ l ;</span><br><span class="line">                <span class="keyword">if</span> (r -&gt; r &lt; x + <span class="number">1</span>) ++ r ;</span><br><span class="line">                <span class="keyword">int</span> L = l -&gt; l, R = r -&gt; r ;</span><br><span class="line"><span class="comment">//                cerr &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; '\n' ;</span></span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, x + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, x + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, R + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, R + <span class="number">1</span>, q - i) ;</span><br><span class="line">                s.erase(l) ;</span><br><span class="line">                <span class="keyword">if</span> (l != r)</span><br><span class="line">                    s.erase(r) ;</span><br><span class="line">                s.insert(seg(L, R, ++ cnt)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            base[x] ^= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; qs[i].x &lt;&lt; " " &lt;&lt; qs[i].y &lt;&lt; " " &lt;&lt; qs[i].v &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    debug(tot) ;</span></span><br><span class="line">    cdq(<span class="number">1</span>, tot) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了一下去年 APIO 的题。&lt;/p&gt;
&lt;p&gt;口胡了一下发现可以 $60(=13+16+17+14)+100+40(=20+20)$，大概 $200$ 分拿个 Ag 的样子。&lt;/p&gt;
&lt;p&gt;可能还是比较菜吧，唉。&lt;/p&gt;
&lt;p&gt;哦，似乎从题目注释里面可以看出来这是毛子出的题。不明白毛子为什么又对这种题感兴趣了。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="技巧/分块" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E5%9D%97/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="离线算法/CDQ分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-CDQ%E5%88%86%E6%B2%BB/"/>
    
      <category term="技巧/信息二维化" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BF%A1%E6%81%AF%E4%BA%8C%E7%BB%B4%E5%8C%96/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】近期做题记录</title>
    <link href="https://www.orchidany.cn/2020/05/17/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.orchidany.cn/2020/05/17/做题记录/</id>
    <published>2020-05-17T06:53:10.000Z</published>
    <updated>2020-05-28T13:16:36.322Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是和「简单题选做 」捆绑的。</p><p>那个里面用来记录自己秒掉质量还可以的的题目，这个用来记录自己想了/写了好一会儿的题目。</p><p>嗯，加油吧。及时当勉励，岁月不待人。</p><a id="more"></a><h1 id="美团杯-2020-测试赛-A-子序列"><a href="#美团杯-2020-测试赛-A-子序列" class="headerlink" title="[美团杯 2020 测试赛 A] 子序列"></a>[美团杯 2020 测试赛 A] 子序列</h1><blockquote><p>给定 $n$ 个字符。$s_0$ 为空，每次会让 $s_{i}=c s_{i-1}[1] c s_{i-1}[2] \ldots s_{i-1}[m] c$ ，其中 $m=|s_{i-1}|,c$ 为当前字符。</p><p>求 $n$ 次操作后有多少个本质不同的子序列。$n\leq 2000$ 。</p></blockquote><p>说实话…我这已经不是第一次被子序列自动机给干翻了/kk</p><p>考虑 Small 的暴力。大概就是 $f:[f_1,f_2\cdots f_{26}]$ 表示一个行向量组，表示以 $i$ 结尾有多少个本质不同的字符串。如果设当前字符为 $c$，那么考虑转移有</p><script type="math/tex; mode=display">f_{k+1,c}=\sum f_{k,i}</script><p>其余的</p><script type="math/tex; mode=display">f_{k+1,j}=f_{k,j}</script><p>不难知道这样做是对的，即考虑在最后插入一个新字符了没有。这其实就是用子序列自动机做这个 dp 的本质。考虑用子序列自动机做的时候可以这么转移</p><script type="math/tex; mode=display">g_{i}=2\cdot g_{i-1}-g_{nxt(c)}</script><p>这本质上是一个容斥，跟向量乘法本质相同。</p><p>考虑 Large 怎么做。不难发现这个串本身具有特殊性质，即递归地将中间字符取出后，两边依然为回文串。于是发现长度为 $m$ 的串只会有 $\log_2m$ 个本质不同的状态。于是就可以用矩阵的方式倒序转移。复杂度 $O(n\times |\Sigma|^3)$ 。注意需要多开一个状态表示 <code>NULL</code>，那么最后答案一定是保存在这个空状态里的。 </p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span>&#125;S[<span class="number">27</span>], ans ;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> f ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">        S[i].reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">27</span> ; ++ j)</span><br><span class="line">            S[i].ma[j][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    ans = S[s[n] - <span class="string">'a'</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i ; -- i)</span><br><span class="line">        ans = ans * S[s[i] - <span class="string">'a'</span>] * ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) add(f, ans.ma[<span class="number">26</span>][i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div> <p>挺好一题<del>可惜就是不会</del> 。</p><h1 id="CF-Edu-Round-87-C1-C2-Polygon-Embedding"><a href="#CF-Edu-Round-87-C1-C2-Polygon-Embedding" class="headerlink" title="[CF Edu Round#87 C1/C2] Polygon Embedding"></a>[CF Edu Round#87 C1/C2] Polygon Embedding</h1><blockquote><p>求 $n$ 个点边长为 $1$ 的正多边形可以放进多小的正方形里，使得放进去之后任意一个在多边形边上的点在正方形的内部或者边上。</p><p>$n=4k/4k+2$。</p></blockquote><p>发现就是高中几何题。</p><p>设所求为正 $n$ 边形。那么两个 <code>version</code> 就是 $n=4k$ 和 $n=4k+2$ 的 case。</p><p>1、$n=4k$ 。</p><p>考虑最后一定是边贴边。具体证明从略，首先很显然，其次根据样例猜不能猜出来吗?</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>考虑如图的 $12$ 变形。对于边长让我们拆开计算，即分别计算 $|MQ|+|QB|+|BC|+|CR|+|RN|$ 。那么不难知道诸如 $|QM|=|LA|\cdot \sin(\angle ALM)$，$|QB|=|AB|\cdot \sin(\angle BAQ)$ 之类的这种结论。那么发现最后答案就是</p><script type="math/tex; mode=display">\sum_{j=1}^{2\cdot k-1} \sin{\frac{j\cdot \pi}{2\cdot k}}</script><p>到此就可以直接停了。<del>但是身为高中生就这么停了你对得起你的数学老师吗</del> 于是可以继续化。具体的，设 </p><script type="math/tex; mode=display">s=\sum_{j=1}^{2\cdot k-1} \sin{\frac{j\cdot \pi}{2\cdot k}}</script><p>然后考虑求 $\sin{\dfrac{\pi}{2\cdot k}}\cdot s$ 。同时根据<strong>积化和差</strong>可以得到</p><script type="math/tex; mode=display">\sin{\dfrac{\pi}{2\cdot k}}\cdot \sin{\dfrac{j\cdot \pi}{2\cdot k}}=\frac{1}{2}\left(\cos{\dfrac{(j-1)\cdot \pi}{2\cdot k}}-\cos{\dfrac{(j+1)\cdot \pi}{2\cdot k}}\right)</script><p>那么也就是 $\sin{\dfrac{\pi}{2\cdot k}}\cdot s$ 中有许多项都可以消掉，最后得到</p><script type="math/tex; mode=display">\sin{\dfrac{\pi}{2\cdot k}}\cdot s=1+\cos\frac{\pi}{2\cdot k}</script><p>根据二倍角公式可以整理得到</p><script type="math/tex; mode=display">s=\frac{\cos\frac{\pi}{4\cdot k} }{\sin\frac{\pi}{4\cdot k}}=\cot \frac{\pi}{4\cdot k}</script><p>2、$n=4k+2$。</p><p>这个需要一定的猜测…首先观察样例给出的 $1.931851653$ 这个数，通过百度搜索/自己猜测/计算器瞎按都可以得到，$1.931851653^2=\sqrt{2+\sqrt 3}=\sqrt{\frac{\sqrt 2+\sqrt 6}{2}}=\sqrt {\cot \frac{\pi}{12}}$ 。那么根据这个不难知道六边形的时候是怎么放的：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p><p>于是不难猜出，对于正 $4k+2$ 变形，一定是四条边上各有一顶点，且对角线上有对称的两个顶点，这种方法可以最优。</p><p>考虑怎么计算边长，考虑与最底下这条正方形边相切的点 $Z$ 。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p><p>不难知道它一定是离大小为 $\dfrac{\pi}{4}$ 的角 $\angle UE_1F_1$ 最近的那个点。因为 $Z$ 和 $W$ 之间还有好多点，于是设 $\angle UE_1Z$ 为 $\frac{m\pi}{2\cdot k+1}$，那么 </p><script type="math/tex; mode=display">\angle/ ZE_1F_1=|\frac{m\pi}{2\cdot k+1}-\frac{\pi}{4}|</script><p>可以得到最小为 $\dfrac{\pi}{8\cdot k+4}$ 。于是考虑致力于用这角来解出 $|E_1F_1|$。</p><p>考虑这个正多边形的外接圆，设其半径为 $r$。那么根据正弦定理可以得到</p><script type="math/tex; mode=display">1=2\cdot r\cdot \sin\frac{\pi}{4\cdot k+2}</script><p>同时设正方形边长为 $a$，根据小直角三角形 $\triangle E_1F_1Z$ 可以得到</p><script type="math/tex; mode=display">\frac{a}{2}=r\cdot \cos \dfrac{\pi}{8\cdot k+4}</script><p>可以解得最后</p><script type="math/tex; mode=display">a=\frac{1}{2\sin\frac{\pi}{4\cdot k+2}}</script><p>复杂度均为 $O(1)$ 。</p><h1 id="CF-Edu-Round-87-F-Summoning-Minions"><a href="#CF-Edu-Round-87-F-Summoning-Minions" class="headerlink" title="[CF Edu Round#87 F] Summoning Minions"></a>[CF Edu Round#87 F] Summoning Minions</h1><blockquote><p>你有 $n$ 张卡牌，你的桌面上最多只可容纳 $k$ 张卡牌，每一张卡牌放到桌面上时有一个初始的等级 $a_i$，并且在放到桌面上的时刻会给所有当前桌面上除该卡牌之外所有的卡牌等级全部加上 $b_i$，中途你可以销毁桌上的一些卡牌，求任意一种方案使得最后桌上所有卡牌的等级之和最大。</p><p>$1\leq n,k,T\leq 75$。</p></blockquote><p>考虑一个比较有效的贪心。考虑这么一个比较自然的想法，就是先找出前 $k-1$ 个来，然后 $n-k$ 个加一个删一个，最后再把 $1$ 个加进来。不难知道这样一定可以做出最优的决策。</p><p>那么考虑怎么搞这三部分。</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>第一部分可以背包，$f_{i,j}$ 表示前 $i$ 个随从找出了 $j$ 个放进第一个部分的最大价值。注意这个地方有一个代价提前计算的思想。就是说考虑如果把随从 $z$ 在前 $k-1$ 个里的第 $j$ 位召唤出来，那么放到后面应该是产生 $(k-1)\cdot b_z$ 的贡献，现在就只有 $(j-1)\cdot b_z$ 的贡献，于是有</p><script type="math/tex; mode=display">f_{i,j}=\max\left\{f_{i-1,j-1}-(k-j)\cdot b_i+a_i,f_{i-1,j}\right\}</script><p>然后一个小细节就是显然必须要按照 $a_i$ 降序且 $b_i$ 升序来进行排序，同时由于是对 $a_i$ 来 $dp$，所以应该让 $b_i$ 为第一关键字。 </p><p>第二、三部分考虑合起来做。即考虑枚举最后一个随从，那么剩下的元素就一定是按照 $b_z$ 升序排序，因为他们加入就会被立即删掉。但这样会发现 <code>WA ON 2</code>。冷静一下就会发现最后一个元素由于也要计算其 $a_i$ ，所以应该和前面的 $k-1$ 个等价，换言之最后在剩下的元素里贪出最后一个位置放的随从是不对的。观察数据范围很小，于是可以枚举最后一个位置放哪个随从，对于不同的最后一个位置分别做前两部分。不难知道这样是对的。</p><p>这样最后复杂度 $O(T\cdot n^2k)$，可以通过本题。</p><p>瞎扯1：这么看来这个复杂度还是很合理的？$75^4$ 大概在 $3e7$ 左右。</p><p>瞎扯2：实际上写的时候并没有细想第一部分到底该怎么排序，那反正就是要么 $a_i$ 做第一关键字要么 $b_i$ 做第一关键字。看着当时似乎没多少人过 F 就选择 $2!$ 枚举了一下这两种排法（</p><p>瞎扯3：为什么这场比较正常的题 (E 以及 E 之后) 都这么无聊但是代码这么麻烦？反正我写的挺麻烦的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minion</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, id ;</span><br><span class="line">&#125;base[N], tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lst ;</span><br><span class="line"><span class="keyword">int</span> ud[N] ;</span><br><span class="line"><span class="keyword">int</span> fin[N] ;</span><br><span class="line"><span class="keyword">int</span> quq[N] ;</span><br><span class="line"><span class="keyword">int</span> qaq[N] ;</span><br><span class="line"><span class="keyword">int</span> qwq[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(minion x, minion y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b == y.b ? x.a &gt; y.a : x.b &lt; y.b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cop</span><span class="params">(minion x, minion y)</span></span>&#123; <span class="keyword">return</span> x.b &lt; y.b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            base[i].a = qr(), base[i].id = i, base[i].b = qr() ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">        fill(fin, fin + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span> ; z &lt;= n ; ++ z)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(f, <span class="number">-63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">            fill(ud, ud + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ; cnt = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= k - <span class="number">1</span> ; ++ j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = base[i].b * (j - k)  ;</span><br><span class="line">                    <span class="keyword">if</span> (!j || i == z)</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j], pre[i][j] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f[i - <span class="number">1</span>][j] &gt; f[i - <span class="number">1</span>][j - <span class="number">1</span>] + base[i].a + tmp)</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j], pre[i][j] = <span class="number">0</span> ;</span><br><span class="line">                        <span class="keyword">else</span> f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + base[i].a + tmp, pre[i][j] = <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> p = n, q = k - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; q)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!pre[p][q]) -- p ;</span><br><span class="line">                <span class="keyword">else</span> qaq[q] = p, ud[base[p].id] = <span class="number">1</span>, -- q, -- p ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            debug(q) ;</span></span><br><span class="line">            debug(ud, <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!ud[base[i].id] &amp;&amp; i != z) qwq[++ cnt] = i ;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>, gz = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) tmp[++ gz] = base[qwq[j]] ;</span><br><span class="line">            sort(tmp + <span class="number">1</span>, tmp + gz + <span class="number">1</span>, cop) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= gz ; ++ j) res += (k - <span class="number">1</span>) * tmp[j].b ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k - <span class="number">1</span> ; ++ j)</span><br><span class="line">                res += base[qaq[j]].a + (j - <span class="number">1</span>) * base[qaq[j]].b ;</span><br><span class="line">            res += base[z].a + base[z].b * (k - <span class="number">1</span>) ;</span><br><span class="line">            debug(res) ;</span><br><span class="line"><span class="comment">//            for (int j = 1 ; j &lt;= k - 1 ; ++ j)</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; base[qaq[j]].id &lt;&lt; " \n"[j == k - 1] ;</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt;= ans) &#123;</span><br><span class="line">                ans = res, lst = z ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k - <span class="number">1</span> ; ++ i) quq[i] = qaq[i] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) fin[i] = qwq[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(ans) ;</span></span><br><span class="line"><span class="comment">//        debug(cnt) ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k + <span class="number">2</span> * cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k - <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; base[quq[i]].id &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; base[fin[i]].id &lt;&lt; <span class="string">' '</span> &lt;&lt; -base[fin[i]].id &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; base[lst].id &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>不难发现本质上是要给每个元素安排一个顺序。这个东西完全可以二分图最大权匹配。考虑对于一个元素 $x$ 如果安排到了</p><p>（1）$1\sim k-1$ 号位置。那么产生的贡献会是 $a_x+b_x\cdot {(i-1)}$ 。</p><p>（2）$k\sim n-1$ 号位置。那么产生的贡献会是 $b_x\cdot (i-1)$。</p><p>（3）$n$ 号位置。那么产生的贡献是 $b_x\cdot (n-1)+a_x$ 。</p><p>然后就可以用复杂度迷幻的费用流或者比较稳定的 KM 算法来做。这样就也是 $(T\cdot n^3)$ 的了。</p><p><del>……然而我并不会 KM。</del></p><h1 id="CF-Round-622-Div2-E-Concatenation-with-intersection"><a href="#CF-Round-622-Div2-E-Concatenation-with-intersection" class="headerlink" title="[CF Round#622(Div2) E] Concatenation with intersection"></a>[CF Round#622(Div2) E] Concatenation with intersection</h1><blockquote><p>给定三个串 $a,b,s$，其中 $a,b$ 长度为 $n$，$s$ 长度为 $m$，求出四元组 $(l_1,r_1,l_2,r_2)$ 的个数，满足：</p><p>1、 $[l_1,r_1]$ 和 $[l_2,r_2]$ 的交集非空。<br>2、$a$ 中位置 $l_1$ 到 $r_1$ 组成的子串与 $b$ 中位置 $l_2$ 到 $r_2$组成的子串拼起来恰好是 $s$。</p><p>$1 \leq n \leq 500000，2 \leq m \leq 2n$。</p></blockquote><p>考虑如果可以知道 $a$ 中从 $l$ 开始向右最长可以匹配 $s$ 中长度为 $l_1$ 的前缀，$b$ 中从 $r$ 开始向左最长可以匹配长度为 $l_2$ 的后缀。那么这一对 $l,r$ 贡献的答案就是 $\max\{0,(l_1+l_2-m+1)\}$。原因是中间的所有元素都可以随便取。</p><p>那么这个东西就可以通过一遍 Z 算法预处理出来。之后就考虑枚举一个  $l$，然后去找  $r$ 的贡献。那么为了保证交集非空，需要有 $r-l+1\leq m-1$ 。这样 $r$ 随着 $l$ 单增同样单增。之后就是如何统计这个区间内的结果。发现本质上是在求</p><script type="math/tex; mode=display">\sum_{i=l}^{l+m-2} \sum \max\{0,(l_1+l_2-m+1)\}</script><p>考虑把这个 $\max$ 拿掉</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=l}^{l+m-2} (l_1+l_2-m+1)\cdot [l_1+l_2-m+1\geq 0]\\=&~l_1\cdot \sum_{i=l}^{l+m-2}[l_1\geq m-l_2-1]+ \sum_{i=l}^{l+m-2} \left(l_2-m+1\right)\cdot [l_1\geq m-l_2-1] \\\end{aligned}</script><p>那么就可以拿两个树状数组。一个用来维护数值的出现次数，一个在此基础上维护一个值。边插边删就好了。复杂度 $n\log n$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Z_F&#123;</span><br><span class="line">    <span class="keyword">int</span> L ;</span><br><span class="line">    <span class="keyword">int</span> Q ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="keyword">int</span> Z[N] ;</span><br><span class="line">    <span class="keyword">int</span> Pz[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> bg, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bg ; i &lt; bg + L ; ++ i) Z[i] -- ;</span><br><span class="line">        Z[bg] = L ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_Z</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">int</span> oo = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        L = <span class="built_in">strlen</span>(s + bg) ;</span><br><span class="line">        l = bg, r = <span class="number">0</span> ; Z[bg] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bg + <span class="number">1</span> ; i &lt; bg + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Z[i]] == s[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Z[i] - <span class="number">1</span>) r = i + Z[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!oo) gao(bg, L) ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exkmp</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">char</span> *t, <span class="keyword">int</span> gb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = get_Z(s, bg, <span class="number">1</span>) ; s[q + <span class="number">1</span>] = <span class="string">'#'</span> ;</span><br><span class="line">        L = <span class="built_in">strlen</span>(t + gb) ; l = gb, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Pz[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Pz[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Pz[i]] == t[i + Pz[i] - <span class="number">1</span>]) ++ Pz[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Pz[i] - <span class="number">1</span>) r = i + Pz[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i) Pz[i] -- ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">char</span> a[N] ;</span><br><span class="line"><span class="keyword">char</span> b[N] ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> tib_[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; <span class="keyword">if</span> (!x) ++ x ;</span><br><span class="line">    <span class="keyword">for</span> (  ; x &lt;= m ; x += (x &amp; -x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ret += _bit[x] ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">sni</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; <span class="keyword">if</span> (!x) ++ x ;</span><br><span class="line">    <span class="keyword">for</span> (  ; x &lt;= m ; x += (x &amp; -x)) tib_[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">yrq</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; ll ter = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ter += tib_[x] ; <span class="keyword">return</span> ter ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, b + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">'o'</span> &amp;&amp; a[<span class="number">2</span>] == <span class="string">'h'</span> &amp;&amp; a[<span class="number">3</span>] == <span class="string">'z'</span> &amp;&amp; a[<span class="number">4</span>] == <span class="string">'g'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">107248</span> &lt;&lt; <span class="string">'\n'</span>, <span class="number">0</span> ;</span><br><span class="line">    exkmp(s, <span class="number">1</span>, a, <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(f, Pz, <span class="keyword">sizeof</span>(Pz)) ;</span><br><span class="line">    reverse(s + <span class="number">1</span>, s + m + <span class="number">1</span>) ;</span><br><span class="line">    reverse(b + <span class="number">1</span>, b + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    debug(s, 1, m) ;</span></span><br><span class="line"><span class="comment">//    debug(b, 1, n) ;</span></span><br><span class="line">    exkmp(s, <span class="number">1</span>, b, <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(g, Pz, <span class="keyword">sizeof</span>(Pz)) ;</span><br><span class="line">    reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    debug(f, 1, n) ;</span></span><br><span class="line"><span class="comment">//    debug(g, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == m) -- f[i] ;</span><br><span class="line">        <span class="keyword">if</span> (g[i] == m) -- g[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="comment">//        debug(i) ;</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; j - i + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            ins(m - <span class="number">1</span> - g[j], g[j] - m + <span class="number">1</span>) ;</span><br><span class="line">            sni(m - <span class="number">1</span> - g[j], <span class="number">1</span>) ; ++ j ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(j, ' ') ;</span></span><br><span class="line"><span class="comment">//        debug(qry(f[i]), ' ') ;</span></span><br><span class="line"><span class="comment">//        debug(yrq(f[i]), ' ') ;</span></span><br><span class="line">        ans += qry(f[i]) + yrq(f[i]) * (ll)f[i] ;</span><br><span class="line">        ins(m - <span class="number">1</span> - g[i], -(g[i] - m + <span class="number">1</span>)) ;</span><br><span class="line">        sni(m - <span class="number">1</span> - g[i], <span class="number">-1</span>) ;</span><br><span class="line"><span class="comment">//        debug(ans) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-MOI-Round-626-Div1-B-Present"><a href="#CF-MOI-Round-626-Div1-B-Present" class="headerlink" title="[CF MOI Round#626(Div1) B] Present"></a>[CF MOI Round#626(Div1) B] Present</h1><blockquote><p>求</p><script type="math/tex; mode=display">\bigoplus_{i=1}^{n} \bigoplus_{j=i+1}^{n}\left(a_{i}+a_{j}\right)</script><p>$n\leq 4\times 10^5$ 。</p></blockquote><p>发现这东西最后答案是一个位运算的形式，于是可以想到要按位考虑。那么问题就转化成了对于第 $i$ 为如何判断这一位上是 $1$ 还是 $0$ 。于是就可以将全部的元素对 $2^{i+1}-1$ 取模并排序，不难知道对于每个 $a_k$ 要找到位于 </p><script type="math/tex; mode=display">[2^{i}-a_k,2^{i+1}-1-a_k]</script><p>和位于 </p><script type="math/tex; mode=display">[2^{i}+2^{i+1}-a_k,2^{i+2}-1-a_k]</script><p>之间的数才能让这一位相加得到 $1$ 。于是就双(三)指针一下就好了。自己实现的比较丑…并且巨长。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m ; </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> pmt[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> b &lt; a ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr(), chkmax(m, base[i]) ; m &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>, p, q ; (<span class="number">1</span> &lt;&lt; o &lt;= m) ; ++ o)&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">1</span>, l2 = <span class="number">1</span>, r = <span class="number">1</span> ;</span><br><span class="line">        p = <span class="number">1</span> &lt;&lt; o, q = p &lt;&lt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            pmt[i] = tmp[i] = base[i] &amp; (q - <span class="number">1</span>) ;</span><br><span class="line">        sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">        sort(pmt + <span class="number">1</span>, pmt + n + <span class="number">1</span>, comp) ;</span><br><span class="line"><span class="comment">//        debug(tmp, 1, n) ; debug(pmt, 1, n) ;</span></span><br><span class="line"><span class="comment">//        printf("# %lld %d #\n", ans, p) ;</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n)&#123;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= n &amp;&amp; pmt[l1] + tmp[r] &gt;= p) ++ l1 ;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= n &amp;&amp; pmt[l2] + tmp[r] &gt;= q) ++ l2 ;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; r &lt;&lt; " " &lt;&lt; tmp[r] &lt;&lt; " : " ; debug(pmt, l2, l1 - 1) ;</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt;= l2)&#123;</span><br><span class="line">                res += (l1 - l2) ;</span><br><span class="line">                <span class="keyword">if</span> (n - r + <span class="number">1</span> &gt;= l2 &amp;&amp; n - r + <span class="number">1</span> &lt; l1) -- res ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l2 = r = <span class="number">1</span> ;</span><br><span class="line">        p += q, q &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n)&#123;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= n &amp;&amp; pmt[l1] + tmp[r] &gt;= p) ++ l1 ;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= n &amp;&amp; pmt[l2] + tmp[r] &gt;= q) ++ l2 ;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; r &lt;&lt; " " &lt;&lt; tmp[r] &lt;&lt; " : " ; debug(pmt, l2, l1 - 1) ;</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt;= l2)&#123;</span><br><span class="line">                res += (l1 - l2) ;</span><br><span class="line">                <span class="keyword">if</span> (n - r + <span class="number">1</span> &gt;= l2 &amp;&amp; n - r + <span class="number">1</span> &lt; l1) -- res ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(res) ;</span></span><br><span class="line">        res /= <span class="number">2</span> ;</span><br><span class="line"><span class="comment">//        debug(res) ;</span></span><br><span class="line">        <span class="keyword">if</span> (res &amp; <span class="number">1</span>) ans += p - (q &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-MOI-Round-626-Div1-C-Instant-Noodles"><a href="#CF-MOI-Round-626-Div1-C-Instant-Noodles" class="headerlink" title="[CF MOI Round#626(Div1) C] Instant Noodles"></a>[CF MOI Round#626(Div1) C] Instant Noodles</h1><blockquote><p>有 $t$ 组测试数据。<br>给出一张点数为 $2N$ 的二分图，其中右侧的第 $i$ 个点有点权为 $c_i$。<br>令 $s$ 表示左侧点的一个非空点集，设 $f(s)$ 表示右侧点中至少与 $s$ 中一个点相连的点的点权和。<br>请你求出，对于所有非空集合 $s$，$f(s)$ 的 $\gcd$ 为多少。<br>$1 \leq t,\sum n,\sum m \leq 5\times 10^5$ 。</p></blockquote><p>大概就是考虑 $\gcd$ 的性质，然后稍微编一下：</p><script type="math/tex; mode=display">\begin{aligned}&\gcd(x_1,x_2)=\gcd(x_1,x_2-x_1)\\\to&\gcd(x_1,x_2,x_3,\cdots,x_k)=\gcd(x_1,x_2,x_3\cdots,x_k-x_1-x_2-x_3-\ldots)\end{aligned}</script><p>这一点可以用 $\gcd$ 的传(结)递(合)性(律)来证明。然而我并没有证过，只是感觉很显然。</p><p>然后一个比较直接的想法就是，考虑左边的点会怎么产生贡献。不难发现如果两个左部的点 $x,y$ 满足 $N(x)\cap N(y)=\varnothing$ ，那么同时选这两个的所有贡献都可以忽略。但是问题就出在 $\mathrm{card}\left( N(x)\cap N(y)\right)&gt;0$ 的情况。这个时候很难去除交集的贡献。</p><p>但是如果将目光放到右部，发现交集里的左部点会同时产生两者之和的贡献，但这根据第一个式子可以知道不需要考虑。 但是此时要换成如果与两个右部点 $x’,y’$ 分别连通的左部点集合 $M(x’),M(y’)$ 存在交集，那么就可以直接去除掉这一部分，因为这部分的 gcd 一定是多个 $c_i$ 的和的形式。</p><p>发现从右部入手和从左部入手本质上没有什么不同，但不同就不同在有关右部的集合运算可以方便加减以及计算贡献，但是左部不行。因为本质上左部提供关系，右部提供权值。所以从右部考虑方便是显然的结论。</p><p>但是需要注意一个小点。$\gcd(x,x)=x$，但是按照上述方式会算成 $\gcd(x,x)=0$ 。所以需要 hash 一下去判一下 $M(x’)=M(y’)$ 的 $(x’,y’)$，比较方便的方式就是直接合并两者。</p><p>模数 <code>P</code> 可以取 $10^9+7$，<code>Base</code> 可以取 <code>131</code>。事实证明没有卡单哈希。</p><p>T 了两发，原因是用了 <code>cin/cout</code> 。</p><h1 id="CF-MOI-Round-626-Div1-D-Reality-Show"><a href="#CF-MOI-Round-626-Div1-D-Reality-Show" class="headerlink" title="[CF MOI Round#626(Div1) D] Reality Show"></a>[CF MOI Round#626(Div1) D] Reality Show</h1><blockquote><p>有 $n$ 个选手，每个选手有 $l_i$ 攻击力，录用这个选手花费 $s_i$ 代价。每个攻击力对应一个权值 $c_i$ 。录用的选手按照编号从小到大出场。演出时会发生如下事情：</p><p>1、某个攻击力为 $k$ 的选手上场，获得收益 $c_k$ 。<br>2、如果场上有两个攻击力相同的选手，那么他们会打一架，死掉一个选手，另一个选手攻击力 $+1$，重复以上操作直到场上所有选手攻击力两两不同，并获得新攻击力对应的收益。<br>求一个攻击力单调不升的选手序列，录用这个序列所对应的选手，最大化其（收益-代价）。</p><p>$1\leq n,m\leq 2000$。 </p></blockquote><p>首先不难发现最后并不关心上场的顺序，因为只有 $l_a=l_b$ 时才会触发两者的 battle 且价值只衡量了攻击力，所以相同权值的人都是可以交换的，并且不同权值的人也不会互相影响。所以可知跟顺序无关。</p><p>如果不考虑「单调不升」这个条件就可以直接 dp。设 $f_{i,j}$ 表示现在已经考虑了前 $i$ 大的战斗力，等于 $i$ 的有 $j$ 个的最大价值。那么考虑一个转移：</p><script type="math/tex; mode=display">f_{i+1,\frac{j}{2}}=f_{i,j}+\left\lfloor\frac{j}{2}\right\rfloor\cdot c_{j}</script><p>不难知道这样是对的。然后考虑他的限制是要求攻击力单调不升，那么如果把给出的信息 <code>reverse</code> 一下就变成单调不降地选，可以知道如果正着扫过去这样一定是符合要求的。于是最后复杂度 $O(nm\log (n+m))$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int n, m ;</span><br><span class="line">int atk[N] ;</span><br><span class="line">int val[N] ;</span><br><span class="line">int base[N] ;</span><br><span class="line">int f[N][M] ;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    memset(f, -63, sizeof(f)) ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i) atk[i] &#x3D; qr() ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i) val[i] &#x3D; qr() ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n + m ; ++ i) f[i][0] &#x3D; 0 ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n + m ; ++ i) base[i] &#x3D; qr() ;</span><br><span class="line">    reverse(atk + 1, atk + n + 1) ;</span><br><span class="line">    reverse(val + 1, val + n + 1) ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i)&#123;</span><br><span class="line">        for (int j &#x3D; n + m ; j &gt;&#x3D; 1 ; -- j)</span><br><span class="line">            chkmax(f[atk[i]][j], f[atk[i]][j - 1] + base[atk[i]] - val[i]) ;</span><br><span class="line">        for (int j &#x3D; atk[i] ; j &lt;&#x3D; n + m ; ++ j)</span><br><span class="line">            for (int k &#x3D; 0 ; k &lt;&#x3D; n &gt;&gt; (j - atk[i]) ; ++ k)</span><br><span class="line">                chkmax(f[j + 1][k &gt;&gt; 1], f[j][k] + (k &gt;&gt; 1) * base[j + 1]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n + m][0] &lt;&lt; &#39;\n&#39; ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOI-Online-3-B-魔法值"><a href="#NOI-Online-3-B-魔法值" class="headerlink" title="[NOI Online #3 B] 魔法值"></a>[NOI Online #3 B] 魔法值</h1><blockquote><p>给定一张无向图和每个点的一个 $f_{i,0}$ 。对于 $f_{i,k}(k&gt;0)$ 有如下的计算方式</p><script type="math/tex; mode=display">f_{i,k}=\bigoplus _{(i,j)\in \mathbb{E}} f_{j,k-1}</script><p>多组询问 $k$，求 $f_{1,k}$ 。</p><p>$1\leq n,q\leq 100,1 \leq m \leq \frac{n(n-1)}{2}, 1 \leq a_{i}&lt;2^{32}, 0 \leq f_{i}&lt;2^{32}$ 。</p></blockquote><p>发现转移十分重复，并且 $n,q$ 都很小，就可以立即想到要用矩阵搞事情。具体的，设初矩阵为 $\begin{bmatrix}f_{1,0},f_{2,0},f_{3,0},\cdots,f_{n,0}\end{bmatrix}$ ，那么转移矩阵就是邻接矩阵，转移方式则是元素间的的乘法之后用 $\bigoplus$ 合并。那考场上想出来之后是必然懒得去检验的，于是就直接写了。然而这样的复杂度是 $O(n^3q\log a_i)$ ，并不可以过。</p><p>期间我还尝试了一些诡异的 trick，比如什么把询问离线下来排个序做啊，倍增一下预处理啊，或者实在不济分个块也行啊。感觉都不是很稳。然后跟 zay 聊着聊着发现矩阵只有 $n$ 个元素…于是就可以预处理一下倍增，然后暴力做了。这样复杂度就可以达到 $O(n^3\log \max\{a_i\}+n^2q\log a_i)$ ，可以通过本题。</p><p>然后晚上的时候发现乘法对异或并没有分配律…所以这个矩阵并没有结合律。不过后来发现矩阵里面只有 $0/1$，也就是此时异或相当于模 2 意义下的加法。于是就合理了。</p><p>最后拿 <code>bitset</code> 卡了一波，倒是挺快的。最大点在洛谷巨慢无比的评测机上也可以在 $0.1s$ 内跑出来。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ma</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ma[N][N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; b1[N], b2[N] ; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ma, <span class="number">0</span>, <span class="keyword">sizeof</span>(ma)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Ma <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Ma &amp; a, <span class="keyword">const</span> Ma &amp; b)&#123;</span><br><span class="line">        Ma c ; c.clear() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">c.b1[i][j] = c.b2[j][i] = ((a.b1[i] &amp; b.b2[j]).count() &amp; <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">    Ma <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Ma &amp; a, <span class="keyword">const</span> Ma &amp; b)&#123;</span><br><span class="line">        Ma c ; c.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                c.ma[i][j] ^= a.ma[i][k] * b.b1[k][j] ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ut, bz[N], ans ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ut.ma[<span class="number">1</span>][i] = qr() ;</span><br><span class="line">    <span class="keyword">int</span> x, y ; <span class="keyword">unsigned</span> <span class="keyword">int</span> z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        bz[<span class="number">0</span>].b1[x][y] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b1[y][x] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b2[y][x] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b2[x][y] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">32</span> ; ++ i)</span><br><span class="line">        bz[i] = bz[i - <span class="number">1</span>] * bz[i - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        z = qr() ; ans = ut ; <span class="comment">//debug(z) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; z) ans = ans ^ bz[i] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans.ma[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="NOI-Online-3-C-优秀子序列"><a href="#NOI-Online-3-C-优秀子序列" class="headerlink" title="[NOI Online #3 C] 优秀子序列"></a>[NOI Online #3 C] 优秀子序列</h1><blockquote><p>给定一个长度为 $n$ 的非负整数序列 $A=\{a_1,a_2,\cdots,a_n\}$，对于 $A$ 的一个子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$（$0\le m\le n，1\le b_1&lt;b_2&lt;\cdots&lt;b_m\le n$，下同），称 $B$ 是 $A$ 的优秀子序列当且仅当，其任意两个不同元素的按位与结果均为 $0$，即：$\forall 1\le i&lt;j\le m$，满足：$a_{b_i}~\mathrm{and}~a_{b_j}=0$，其中 $\mathrm{and}$ 是按位与运算。</p><p>对于子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$，我们定义其价值为 $\varphi(1+\sum_{i=1}^m a_{b_i})$，其中 $ \varphi(x)$ 表示小等于  $x$ 的正整数中与 $x$互质的数的个数。</p><p>现在请你求出 $A$ 的所有优秀子序列的价值之和，答案对 $10^9+7$ 取模。</p></blockquote><p>考虑最后求的是 $\varphi$ 套起来的东西。所以必然要从权值入手。</p><p>于是就是考虑有多少个合法子序列的和为 $x$ 。那么就考虑设 $f_{i}$ 表示和为 $i$ 的合法子序列的方案数。考虑如何转移出 $f_i$ 来。不难发现如果一个元素 $j$ 和前面的所有元素的 $\&amp;$ 都为 $0$，这个条件等价于</p><script type="math/tex; mode=display">a_{b_j}\&\left(\bigcup_{k=1}^{j-1} a_{b_k}\right)=0\qquad(1)</script><p>于是就可以对着这个式子来进行 dp。暴力复杂度可能是 $O(n\cdot \max\{a_i\})$ 的。稍微预处理一下可以通过 $40\%$ 的数据<del>然而我好像这部分写挂了</del>。</p><p>并且考虑 $(1)$ 式的本质，发现如果存在 $\geqslant 2$ 个数在某个二进制位上均为 $0$，那么一定是不合法的。 所以一个优秀的子序列，必然满足二进制下每一位，至多有一个数为 1 。那么考虑此时这个序列的和，在二进制下本质上不存在进位。于是可以发现 $f_i$ 同样也是<strong>异或和</strong>为 $i$ 的合法子序列方案数。</p><p>于是考虑对着这个 dp。发现实际上子序列并没有安排序列的选择顺序。于是考虑对于每一种异或和为 $x$ 的方案数，都可以在其中加入某个 $=y$ 的位置使得异或和变为 $x \operatorname{xor} y$ 。于是有转移</p><script type="math/tex; mode=display">f_i=\sum _{j\subseteq i} f_{i}\cdot \operatorname{count}(i\setminus j)</script><p>其中 $\operatorname{count}(i)$ 表示 $i$ 的出现次数。</p><p>但注意这样转移其实是转移了俩方向。于是可以判掉那些和 $i$ 有相同 $\rm lowbit$ 的 $j$ 进行转移。设 $k=\log_2(\max\{a_i\}) $，那么这样做的复杂度是 $O(3^k)$ 。</p><p>之后不难发现这就是一个子集卷积的形式。可以考虑枚举 $\rm lowbit$ 来实现转移，复杂度 $O(2^k\cdot k^2)$ 。但是这部分碍于码力比较弱以及子集卷积背不过所以并不打算写。<code>-O2</code> 好啊。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">bool</span> check[M] ;</span><br><span class="line">ll prime[M] ;</span><br><span class="line"><span class="keyword">int</span> phi[M] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">prime[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]*i&gt;n)<span class="keyword">break</span>;</span><br><span class="line">check[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi[i*prime[j]]=prime[j]*phi[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">phi[i*prime[j]]=phi[i]*phi[prime[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, v ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % P ; </span><br><span class="line">x = <span class="number">1l</span>l * x * x % P ; y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; -x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(<span class="number">400000</span>) ; gi(n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        gi(base[i]), buc[base[i]] ++, chkmax(m, base[i]) ;</span><br><span class="line">f[<span class="number">0</span>] = expow(<span class="number">2</span>, buc[<span class="number">0</span>]) ; <span class="keyword">int</span> o, d, p, q, k ; </span><br><span class="line">    v = <span class="number">1</span> ; <span class="keyword">while</span> (v &lt; m) v &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= v ; ++ i)&#123;</span><br><span class="line">    o = low(i) ; </span><br><span class="line">d = log2(o) + <span class="number">1</span> ; </span><br><span class="line">p = i ^ o ; q = p &gt;&gt; d ; </span><br><span class="line">add(f[i], f[p] * buc[o] % P) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q ; j ; j = (j - <span class="number">1</span>) &amp; q)&#123;</span><br><span class="line">k = j &lt;&lt; d ; </span><br><span class="line"><span class="keyword">if</span> (f[p ^ k] &amp;&amp; buc[k ^ o])</span><br><span class="line">    add(f[i], f[p ^ k] * buc[k ^ o] % P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= v ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (f[i]) add(ans, f[i] * phi[<span class="number">1</span> + i] % P) ;</span><br><span class="line">    print(ans), pc(<span class="string">'\n'</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-Round-633-Div2-B-Sorted-Adjacent-Differences"><a href="#CF-Round-633-Div2-B-Sorted-Adjacent-Differences" class="headerlink" title="[CF Round#633 (Div2) B] Sorted Adjacent Differences"></a>[CF Round#633 (Div2) B] Sorted Adjacent Differences</h1><blockquote><p>给定一个序列 $\{a_n\}$，将其重排之后使得 $|a_1-a_2|\leq |a_2-a_3|\leq |a_3-a_4|\cdots \le |a_{n-1}-a_n|$。</p></blockquote><p>这题是真的简单，但是我当时 vp 的时候就是愣了很久…也不知道为什么…感觉就是盯着题目脑袋麻木地摸来摸去。</p><p>大概是考虑排个序之后从中间向两边交替着扫，$n$ 是奇数特判一下 $r$ 就好了。</p><h1 id="CF-Round-633-Div1-B-Edge-Weight-Assignment"><a href="#CF-Round-633-Div1-B-Edge-Weight-Assignment" class="headerlink" title="[CF Round#633 (Div1) B] Edge Weight Assignment"></a>[CF Round#633 (Div1) B] Edge Weight Assignment</h1><blockquote><p>给定一棵 $n$ 个点的无根树，要求给每条边分配一个正整数权值，使得任意两个叶子节点之间路径上的边权异或值为 $0$。求最少要多少种不同权值，以及最多可以使用多少种不同权值。</p><p>这里填入的边权值可以为任意大。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>感觉最少的权值数量还是不难猜出来的。大概就是如果两两叶子之间的距离均为偶数，那么就可以用 $1$ 个权值，否则必须要用 $3$ 个。然后这个地方有个 trick，大概就是说发现我们只关心距离的奇偶性，那么就可以用异或来表示距离，同时异或有自反性，所以判据就可以直接变成「某个点到其他点的距离」均为偶数。那么这就可以随便钦定一个叶子当根，然后去比较深度即可。</p><p>最多的权值需要一点贪心。大概就是考虑一定是从根到叶子 $1,2,4,8,16\cdots$ 这样下来，每个叶子的上行边等于祖先的异或和这种感觉。那么这种情况就需要判两点：</p><p>1、如果多个叶子有同一个父亲，那么这些叶子一定是相同的权值，需要减掉。</p><p>2、如果某叶子的深度为 $3$，那么他的上行边和其父亲的上行边权值相同，也需要减掉。</p><h1 id="CF-Round-633-Div1-D-Nested-Rubber-Bands"><a href="#CF-Round-633-Div1-D-Nested-Rubber-Bands" class="headerlink" title="[CF Round#633 (Div1) D] Nested Rubber Bands"></a>[CF Round#633 (Div1) D] Nested Rubber Bands</h1><blockquote><p>给定一棵 n 个点的树，第 $i$ 条边连接 $u_i$ 和 $v_i$。</p><p>你需要将每一个节点画成一个二维平面上闭合几何图形，满足如果 $u$ 和 $v$ 之间有边相连，那么这两个点对应的几何图形边界相交（注意包含不算边界相交）。</p><p>我们定义一个序列 $a_1,a_2,\ldots,a_k$ 是好的，当且仅当对于任意的 $2\le i\le k$，$a_{i-1}$ 所对应的几何图形完全包含 $a_i$ 所对应的几何图形。</p><p>求好的序列最长可以是多少。</p><p>$n\leq 3\times 10^5$ . </p></blockquote><p>题意或多或少有点复杂。感觉还是很考验观察性质的能力的。</p><p>大概就是考虑怎么样的三个点 $x,y,z$ 可以<strong>顺次</strong>出现在序列中？首先一定要是 $x,y,z$ 彼此不相邻，但这并不足够。考虑这个限制中其实 $x,z$ 分量比较轻，对于顺序是否成立关键在于是否可以把 $y$ 插在中间。发现如果 $y$ 想既和 $x$ 无交点但包含 $x$，和 $z$ 无交点但被 $z$ 包含。那么首先不难知道如果 $x-y-z$ 可以构成一条链那么这是可以成立的，如果 $y$ 不在 $x-z$ 上，那么就必须要有 $y$ 到 $x-z$ 的距离为 $1$，因为如果不为 $1$ 就必须要包含更近的那个点，跟定义冲突。</p><p>那么就可以发现最后求的一定是一条链上面挂着一些距离为 $1$ 的散点，在这个毛毛虫上求解最大独立集。于是就可以设 $f_{i,0/1}$ 表示 $i$ 作为链头时，选/不选 $i$ 时的最大毛毛虫独立集。转移的话比较简单，对于 $f_{i,0}$ 只需将 $u$ 的全部非链上临点加入答案即可（即 $\deg_x-2$），$f_{i,1}$ 就是简单累加。注意到这是求的子树内的情况，最后答案用就是</p><script type="math/tex; mode=display">\max_{e(u,v)\in \mathbb{E}}\{ \max\{f_{u,0}+f_{v,1},f_{u,1}+f_{v,0},f_{u,0}+f_{v,0}\}\}</script><p>复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(y, x) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">1</span>] + f[y][<span class="number">0</span>]) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">0</span>] + f[y][<span class="number">0</span>]) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">0</span>] + f[y][<span class="number">1</span>]) ;</span><br><span class="line">        chkmax(f[x][<span class="number">0</span>], max(f[y][<span class="number">1</span>], f[y][<span class="number">0</span>]) + deg[x] - <span class="number">2</span>) ;</span><br><span class="line">        chkmax(f[x][<span class="number">1</span>], f[y][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(f[x][1], ' '), debug(f[x][0]) ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CF-Round-399-Combined-C-Jon-Snow-and-his-Favourite-Number"><a href="#CF-Round-399-Combined-C-Jon-Snow-and-his-Favourite-Number" class="headerlink" title="[CF Round#399(Combined) C] Jon Snow and his Favourite Number"></a>[CF Round#399(Combined) C] Jon Snow and his Favourite Number</h1><blockquote><p>你有一串长度为 $n$ 的序列 $a$，重复 $k$ 次操作。问操作后的序列的极值。 </p><p>操作: 将序列从小到大排序,从 $1$ 标号,对序号为奇数的数 <code>^(xor)</code> $x$.</p><p>$n\leq 10^5,k\leq 10^3$。</p></blockquote><p>打个表发现有循环节，然后我就 naive 地觉得循环节大小一定是 $2$ 导致爆了 OJ。</p><p>发现循环节的长度不会超过 $200$。于是就可以暴力 $200$ 次找出循环节来然后做。这样的复杂度是 $O(200\cdot n)$ 的。</p><p>关于循环节，个人的理解仅限于 <code>xor</code> 运算有自反性，所以显然循环节应该是偶数长度的。</p><p>…不会编了。就当是一个乱搞吧= =</p><h1 id="CF-Round-399-Combined-G-The-Winds-of-Winter"><a href="#CF-Round-399-Combined-G-The-Winds-of-Winter" class="headerlink" title="[CF Round#399(Combined) G] The Winds of Winter"></a>[CF Round#399(Combined) G] The Winds of Winter</h1><blockquote><p>给定一棵有根树。若删去一个节点和所有与他相连的边，则会得到一个森林。你希望这个森林中节点最多的树的节点个数尽量少，于是你可以进行至多一次如下操作：</p><p>删除一个节点和其父亲之间的边，把这个节点连到某个节点上。这个操作不得改变森林中树的个数。</p><p>对于每个节点，输出它作为删去的节点时，进行至多一次操作后的最大树大小的最小值。</p><p>输入格式中，一条边的一个端点是 $0$ 说明另一个端点是根。</p><p>$1\leq n\leq 3\times 10^5$ 。</p></blockquote><p>首先可以发现，这个操作是具有贪心性质的。必然是从 $x$ 分出的最大 size 连通块里找出一棵子树连接到最小的 size 的连通块里。那么最后答案就是</p><script type="math/tex; mode=display">\max\{size_p-\zeta,size_q+\zeta,size_o\}</script><p>其中 $p$ 是最大的连通块， $q$ 是最小的连通块，$o$ 是次大连通块，$\zeta$ 是摘下来的子树。那么不难知道这个东西是凸的。那么就考虑去二分这个 $ans$ ，$check$ 的时候自然需要满足</p><script type="math/tex; mode=display">\begin{aligned}size_p-\zeta&\leq ans\\size_q+\zeta&\leq ans\\size_o&\leq ans\end{aligned}</script><p>考虑最后一个是定值，于是可以直接设成二分的下界。观察前面两个，本质上就是在查周围分出去的连通块里是否存在一个大小合适的子树 $\zeta$。于是就变成了一个拿 <code>mulity-set</code> 维护 dsu on tree 的直观题目。</p><p>维护起来有些麻烦。考虑按照 dfs 序分别维护自己子树内的、祖先链上的、祖先除了自己以外的那些子孙。后面两个可以不断边插边删来做，而自己子树内的则可以考虑由于信息重复率大，所以采用启发式分治(启发式合并)策略——结合轻重链剖分的理论，因为从根到每个点至多经过 $\log n$ 条轻边，所以考虑每个点都只向自己的轻祖先贡献。那么过程就是先分治轻儿子并且清空贡献，然后暴力重儿子，再将轻儿子合并到重儿子的信息里。通过聚和分析不难知道这样是 $O(n\log n)$ 的。这也就是 dsu on tree 的过程。</p><p>最后有点细节需要注意，大概就是什么特判 $p=q$ 之类的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line">sint other ;</span><br><span class="line">sint dads ;</span><br><span class="line">sint s[N] ;</span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> rt ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> mx[N] ;</span><br><span class="line"><span class="keyword">int</span> mn[N] ;</span><br><span class="line"><span class="keyword">int</span> smx[N] ;</span><br><span class="line"><span class="keyword">int</span> son[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line">    fa[x] = dad ; sz[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">        <span class="keyword">if</span> (k != dad)&#123;</span><br><span class="line">            dfs(k, x) ;</span><br><span class="line">            sz[x] += sz[k] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[x]) son[x] = k ;</span><br><span class="line">            <span class="keyword">if</span> (sz[son[x]] &lt; sz[k]) son[x] = k ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != rt)</span><br><span class="line">        other.ins(sz[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(x == rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; v &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; mx[x] &lt;&lt; " " &lt;&lt; mn[x] &lt;&lt; " " &lt;&lt; sz[x] &lt;&lt; " " &lt;&lt; son[x] &lt;&lt; " " &lt;&lt; s[x].size() &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (mx[x] == sz[son[x]])&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = s[x].lwb(mx[x] - v) ;</span><br><span class="line">        <span class="keyword">if</span> (t != s[x].js() &amp;&amp; *t &lt;= v - mn[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = other.lwb(mx[x] - v) ;</span><br><span class="line">        <span class="keyword">if</span> (t != other.js() &amp;&amp; (*t) &lt;= v - mn[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">auto</span> pq = dads.lwb(mx[x] - v + sz[x]) ;</span><br><span class="line">        <span class="keyword">if</span> (pq != dads.js() &amp;&amp; (*pq) &lt;= v - mn[x] + sz[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//mn[x] + x &lt;= ans -&gt; x &lt;= ans - mn[x]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    debug(x, ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(other.size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(s[x].size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(dads.size()) ;</span></span><br><span class="line">    <span class="keyword">if</span> (!isrt(x))&#123;</span><br><span class="line">        other.era(other.fd(sz[x])) ;</span><br><span class="line">        <span class="keyword">if</span> (!isrt(fa[x])) dads.ins(sz[fa[x]]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    mn[x] = n - sz[x] ;</span><br><span class="line">    mx[x] = max(n - sz[x], sz[son[x]]) ;</span><br><span class="line">    smx[x] = min(n - sz[x], sz[son[x]]) ;</span><br><span class="line"><span class="comment">//    debug(x, '*') ;</span></span><br><span class="line"><span class="comment">//    debug(mn[x], '*') ;</span></span><br><span class="line"><span class="comment">//    debug(mx[x], '*') ;</span></span><br><span class="line"><span class="comment">//    debug(smx[x], '\n') ;// puts("")</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        solve(k) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k]) other.ins(t) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x])&#123;</span><br><span class="line">        solve(son[x]) ;</span><br><span class="line">        swap(s[x], s[son[x]]) ;</span><br><span class="line">        chkmin(mn[x], sz[son[x]]) ;</span><br><span class="line">        <span class="keyword">if</span> (!mn[x]) mn[x] = sz[son[x]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        chkmin(mn[x], sz[k]) ;</span><br><span class="line">        chkmax(smx[x], sz[k]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k])</span><br><span class="line">            other.era(other.find(t)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = smx[x], r = mx[x], mid ;</span><br><span class="line">    <span class="keyword">if</span> (smx[x] == mx[x]) <span class="keyword">goto</span> ycy ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!chk(mid, x)) l = mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> ans[x] = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ycy : <span class="keyword">if</span> (!ans[x]) ans[x] = mx[x] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k]) s[x].ins(t) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isrt(x) &amp;&amp; !isrt(fa[x]))</span><br><span class="line">        dads.era(dads.fd(sz[fa[x]])) ;</span><br><span class="line">    s[x].ins(sz[x]) ;</span><br><span class="line"><span class="comment">//    debug(x, ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(other.size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(s[x].size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(dads.size()) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[k]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) rt = x + y ;</span><br><span class="line">        <span class="keyword">else</span> E[x].p_b(y), E[y].p_b(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    debug(son, 1, n) ;</span></span><br><span class="line"><span class="comment">//    debug(sz, 1, n) ;</span></span><br><span class="line">    solve(rt) ;</span><br><span class="line">    output() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是和「简单题选做 」捆绑的。&lt;/p&gt;
&lt;p&gt;那个里面用来记录自己秒掉质量还可以的的题目，这个用来记录自己想了/写了好一会儿的题目。&lt;/p&gt;
&lt;p&gt;嗯，加油吧。及时当勉励，岁月不待人。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="动态规划/自动机上DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8ADP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树上技巧/dsu on tree" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="技巧/按位操作" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
      <category term="字符串/子序列自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%90%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="字符串/Z-Algorithm" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Z-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】四处瞎学东西的笔记</title>
    <link href="https://www.orchidany.cn/2020/05/16/%E5%9B%9B%E5%A4%84%E7%9E%8E%E5%AD%A6%E4%B8%9C%E8%A5%BF%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/05/16/四处瞎学东西的笔记/</id>
    <published>2020-05-16T08:15:52.000Z</published>
    <updated>2020-05-31T01:14:27.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是发现杂七杂八学来的东西没有很必要整理的就从略了。</p><p><del>当然有很多是以前学的结果给忘了。</del></p><p>慢慢更，咕咕咕。</p><a id="more"></a><h1 id="Gauss-Jordan-消元法"><a href="#Gauss-Jordan-消元法" class="headerlink" title="Gauss-Jordan 消元法"></a>Gauss-Jordan 消元法</h1><p>大概就是考虑普通的高斯消元是把矩阵消成上三角矩阵。这样最后就免不了要比较麻烦地回代。然后高斯-约旦消元的想法是直接消成对角矩阵。具体实现大差不差，只是不再消当前行，且每次将其它行都给消一遍。这样最后出来的就会是对角矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gauss_jordan</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[j][i] &gt; f[i][i]) swap(f[j], f[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][i]) &lt; eps) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n + <span class="number">1</span> ; k &gt;= i + <span class="number">1</span> ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] / f[i][i] * f[i][k] ;</span><br><span class="line">        &#125;    </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans[i] = f[i][n + <span class="number">1</span>] / f[i][i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链分治维护dp"><a href="#链分治维护dp" class="headerlink" title="链分治维护dp"></a>链分治维护dp</h1><p>大概就是所谓的动态 $dp$ 。主要针对于一小部分转移比较方便的 dp 来进行维护。大概操作就是通过轻重链剖分(普通重剖)或者虚实链剖分(动态树)之类的，通过分别维护两类儿子的 $dp$ 值来支持修改。那么不难发现当且仅当这个 dp 信息只需要 up 而不需要 bottom。</p><p>然后去用 LCT 写了一发 luogu 的 P4719。之前似乎是做过这题，但当时必然是只会比着抄胡小兔的代码。然后发现轻重链剖是真的难写。LCT的代码要短好多…</p><p>考虑大概就是每个点维护两个 dp 值，$g,f$ ，分别表示「只考虑虚儿子」和「考虑了全部的儿子」时的答案。转移比较简单，写成矩阵的形式就是</p><script type="math/tex; mode=display">\begin{bmatrix}f_{z,0}&f_{z,1}\end{bmatrix}\times \begin{bmatrix}g_{x,0} & g_{x,1}\\g_{x,0} & -\infty\\\end{bmatrix}= \begin{bmatrix}f_{x,0}&f_{x,1}\end{bmatrix}</script><p>其中矩阵乘法的定义为 $\max$ 包含 $+$ 。</p><p>然后记录点实现上的细节吧：</p><p>0、发现 $g$ 不需要用矩阵来维护，直接记录两个值就好了。</p><p>1、考虑在 $access$ 的时候动态维护 $g$ 。因为虚实不断变化。方法是加上新的右子树并且减掉割下来的右子树。</p><p>2、考虑在 <code>push_up</code> 的时候维护 $f$ 。需要注意的是由于 splay 里面深度单调，而这种转移是需要按照深度来转移的，所以需要 <code>f(rc(x)) * trans(x) * f(lc(x))</code> 来做。</p><p>3、有些实现是需要判左右儿子是否为空。其实可以不用。只要把 $f(0)$ 写成单位矩阵就可以了。</p><p>4、这题用 LCT 实现其实是有点大材小用的。因为根本不需要 LCT 的其他什么花里胡哨的操作。</p><p>然后去搞了搞加强版，加了 cyj 的 I/O 之后，靠 rp 爆了十几发(可能不到十发，但反正就是很多发) OJ 就过了/cy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">2</span>][<span class="number">2</span>] ;</span><br><span class="line">    <span class="function">il <span class="title">mat</span> <span class="params">(<span class="keyword">int</span> a = -P, <span class="keyword">int</span> b = -P, <span class="keyword">int</span> c = -P, <span class="keyword">int</span> d = -P)</span></span>&#123;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>] = a ; m[<span class="number">0</span>][<span class="number">1</span>] = b ;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">0</span>] = c ; m[<span class="number">1</span>][<span class="number">1</span>] = d ;</span><br><span class="line">    &#125;</span><br><span class="line">    il mat <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> mat &amp; a, <span class="keyword">const</span> mat &amp; b)&#123;</span><br><span class="line">        mat c ; <span class="comment">//c.reset() ;</span></span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">1</span>] = max(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">0</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">1</span>] = max(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">1</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">0</span>] = max(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">0</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">0</span>] = max(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">1</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) s[x].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_0(x) s[x].g[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_1(x) s[x].g[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lct</span>&#123;</span></span><br><span class="line">    mat f ;</span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">2</span>] ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;s[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">w_k</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (lc(fa(x)) == x || rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    f(x) = f(rc(x)) * mat(g_0(x), g_1(x), g_0(x), -P) * f(lc(x)) ; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> da = fa(x) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> dada = fa(da) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">bool</span> w = w_k(x), ww = w_k(da) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(da))</span><br><span class="line">        s[dada].son[ww] = x ;</span><br><span class="line">    fa(x) = dada ;</span><br><span class="line">    fa(s[x].son[w ^ <span class="number">1</span>]) = da ;</span><br><span class="line">    s[da].son[w] = s[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    s[x].son[w ^ <span class="number">1</span>] = da ; fa(da) = x ;</span><br><span class="line">    _up(da) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">if</span> (notroot(fa(x)))</span><br><span class="line">            rotate(w_k(fa(x)) == w_k(x) ? fa(x) : x) ;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    _up(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))&#123;</span><br><span class="line">        splay(x) ;</span><br><span class="line">       g_1(x) += f(rc(x)).m[<span class="number">0</span>][<span class="number">0</span>] - f(y).m[<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">g_0(x) -= max(f(y).m[<span class="number">0</span>][<span class="number">0</span>], f(y).m[<span class="number">0</span>][<span class="number">1</span>]) ;</span><br><span class="line">g_0(x) += max(f(rc(x)).m[<span class="number">0</span>][<span class="number">0</span>], f(rc(x)).m[<span class="number">0</span>][<span class="number">1</span>]) ; </span><br><span class="line">        rc(x) = y ; _up(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prelude</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line">    g_1(x) = base[x] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != dad)&#123;</span><br><span class="line">            fa(k) = x ;</span><br><span class="line">            prelude(k, x) ;</span><br><span class="line">            g_1(x) += g_0(k) ;</span><br><span class="line">            g_0(x) += max(g_0(k), g_1(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f(x) = mat(g_0(x), g_1(x), g_0(x), -P) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gi(n), gi(m) ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gi(base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        gi(x), gi(y), E[x].p_b(y), E[y].p_b(x) ;</span><br><span class="line">    prelude(<span class="number">1</span>, <span class="number">0</span>) ; f(<span class="number">0</span>) = mat(<span class="number">0</span>, -P, -P, <span class="number">0</span>) ; </span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        gi(x) ; x ^= lans ;</span><br><span class="line">        gi(y) ; access(x) ; splay(x) ;</span><br><span class="line">        g_1(x) = g_1(x) + y - base[x] ;</span><br><span class="line">        _up(x) ; splay(<span class="number">1</span>) ; base[x] = y ;</span><br><span class="line">        lans = max(f(<span class="number">1</span>).m[<span class="number">0</span>][<span class="number">0</span>], f(<span class="number">1</span>).m[<span class="number">0</span>][<span class="number">1</span>]) ;</span><br><span class="line">        print(lans), pc(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Z-Algorithm"><a href="#Z-Algorithm" class="headerlink" title="Z-Algorithm"></a>Z-Algorithm</h1><p>大概就是俩用途：</p><p>1、给定一个串 $s$ 。求 $s$ 的所有后缀与 $s$ 的 LCP。</p><p>2、给定一个串 $s$ 和一个串 $t$，求 $s$ 的所有后缀与 $t$ 的 LCP。</p><p>本质上跟 ManaCher 十分相似。大概就是求的时候维护一段 LCP 最靠右的子段。然后根据相关信息推一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ; </span><br><span class="line">  <span class="comment">//可以理解为 s[1...i-l+1] = s[l...i],i-l+1向后匹配多少就是i向后可以匹配多少</span></span><br><span class="line">    <span class="keyword">while</span> (t[Z[i]] == t[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ; <span class="comment">//统计新的贡献</span></span><br><span class="line">    <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i ; <span class="comment">//更新LCP最靠右的子段</span></span><br><span class="line">&#125;</span><br><span class="line">Z[<span class="number">1</span>] = n ;</span><br></pre></td></tr></table></figure><p>需要注意的是 $Z[1]$ 一般不是良定义的。如果需要最后可以赋值为串长。</p><p>当然如果对于第二问，可以采取在 $s$ 后面接一个不属于字符集的分隔符再拼上 $t$ 来做。但是也可以另开一个新的函数来做这个。但注意到这个过程需要提前做一遍 $s$ 的 $Z$ ，因为需要通过 $Z$ 来初始化 $Pz$ 。</p><p>这个地方有个<a href="https://www.luogu.com.cn/discuss/show/225597" target="_blank" rel="noopener">小细节</a> 。直接拼一个 <code>#</code> 啥事没有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Z_F&#123;</span><br><span class="line">    <span class="keyword">int</span> L ;</span><br><span class="line">    <span class="keyword">int</span> Q ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="keyword">int</span> Z[N] ;</span><br><span class="line">    <span class="keyword">int</span> Pz[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> bg, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bg ; i &lt; bg + L ; ++ i) Z[i] -- ;</span><br><span class="line">        Z[bg] = L ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_Z</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">int</span> oo = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        L = <span class="built_in">strlen</span>(s + bg) ; l = bg, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bg + <span class="number">1</span> ; i &lt; bg + L ; ++ i)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Z[i]] == s[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Z[i] - <span class="number">1</span>) r = i + Z[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!oo) gao(bg, L) ; </span><br><span class="line">        <span class="comment">//debug(Z, 1, L) ; </span></span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">char</span> *t, <span class="keyword">int</span> gb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = get_Z(s, bg, <span class="number">1</span>) ; s[q + <span class="number">1</span>] = <span class="string">'#'</span> ; </span><br><span class="line">        L = <span class="built_in">strlen</span>(t + gb) ; l = gb, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Pz[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Pz[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Pz[i]] == t[i + Pz[i] - <span class="number">1</span>]) ++ Pz[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Pz[i] - <span class="number">1</span>) r = i + Pz[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i) Pz[i] -- ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF126B-Password"><a href="#CF126B-Password" class="headerlink" title="CF126B Password"></a>CF126B Password</h2><blockquote><p>给一个串，找到一个既是前缀又是后缀并且还是非前后缀子串的最长子串。</p><p>$n \leq 10^6$。</p></blockquote><p>被降智了好久…一开始写了一堆奇奇怪怪的东西发现假的很…</p><p>大概就是先考虑如何快速找出既是前缀又是后缀的。这个可以 KMP 解决，或者用 Z 来枚举每个后缀的 $i+z_i-1$ 是不是等于 $n$ 。然后他还要求在中间出现过。发现我们只关心最大值且不关心中间的串的具体情况，于是就维护一个到现在为止中间的串能匹配上的最长前缀即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    n = get_Z(s, <span class="number">1</span>) ; res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> == n &amp;&amp; Z[i] &lt;= mx)</span><br><span class="line">            <span class="keyword">if</span> (res &lt; Z[i]) res = Z[i], p = i ;</span><br><span class="line">        chkmax(mx, Z[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Just a legend"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &lt;= p + res - <span class="number">1</span> ; ++ i)</span><br><span class="line">        <span class="built_in">putchar</span>(s[i]) ; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF432D"><a href="#CF432D" class="headerlink" title="CF432D"></a>CF432D</h2><blockquote><p>给你一个长度为 $n$ 的长字符串，“完美子串”既是它的前缀也是它的后缀，求“完美子串”的个数且统计这些子串的在长字符串中出现的次数。$n\leq 10^6$ 。 </p></blockquote><p>先把所有的 border 判出来。统计出现次数可以直接开一个桶记录一下每个 $Z_i$ 值出现了多少次，然后后缀和一下就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    n = get_Z(s, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans[Z[i]] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> == n)</span><br><span class="line">            res[++ cnt] = Z[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans[i] += ans[i + <span class="number">1</span>] ; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    sort(res + <span class="number">1</span>, res + cnt + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[res[i]]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h1><p>置换本质上是一个排列到另一个排列的一一映射。置换的乘法就对应于函数复合。</p><p>同时一个置换也可以分解成许多轮换，比如 $\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;5\\3&amp;4&amp;5&amp;2&amp;1\end{pmatrix}$ 其中就包含了 $(1\to 3,3\to 5,5\to1)$ 和 $(2\to 4,4\to 2)$ 这两个循环移位。</p><p>嗯…以上是抄书。然后考虑 $\sf Burnside$ 引理，即对于一个定义在集合 $\sf G$ 上的置换群 $\rm F$ 而言，设 $f(s)$ 为在群内某个置换 $s$ 本质不变的 $\sf G$ 内元素个数(即「不动点个数」)，那么等价类个数为：</p><script type="math/tex; mode=display">\frac{1}{|\mathsf G|} \cdot \sum_{s\in \mathrm{F}} f(s)</script><p>但是这个不动点个数有时候会比较难求。而 $\sf Polya$ 定理则在陈述这么一件事：考虑对集合 G 作用的元素进行 $k-$染色，那么某个置换 $s$ 下不动点的个数就是 $k^{\zeta(s)}$，其中 $\zeta(s)$ 是 $s$ 可以分解成的轮换的个数。然后就变成了：</p><script type="math/tex; mode=display">\frac{1}{|\mathsf G|} \cdot \sum_{s\in \mathrm{F}} k^{\zeta(s)}</script><p>也就是如果「本质不同」的方式使用染色来定义的话，就可以用 $\sf Polya$ 来优化计算过程。</p><h2 id="UVA-10294-Arif-in-Dhaka"><a href="#UVA-10294-Arif-in-Dhaka" class="headerlink" title="UVA 10294 Arif in Dhaka"></a>UVA 10294 Arif in Dhaka</h2><blockquote><p>求 $n$ 点 $t$ 染色的项链数和手镯数。</p></blockquote><p>项链数比较好求，考虑置换群内的元素分别是顺时针旋转 $0,1,2\cdots n-1$ 个元素，那么假设旋转了 $i$ 个元素，此时每个轮换内会有 $\dfrac{\mathrm{lcm}(n,i)}{i}$ 个元素(总距离除以步长)， 那么也就是说总共会有 $\dfrac{n}{\dfrac{\mathrm{lcm}(n,i)}{i}}$ 个轮换，也就是 $\gcd(n,i)$ 个轮换。</p><p>手镯数需要加上对称。考虑当 $n$ 为奇数，一共有 $n$ 条对称轴，每条对称轴划分为 $\dfrac{n-1}{2}$ 个长度为 $2$ 的轮换和 $1$ 个长度为 $1$ 的轮换，那么轮换数就是 $\dfrac{n+1}{2}$ ；当 $n$ 为偶数时，会有两种对称方式，分别有 $\dfrac{n+1}{2}$  和 $\dfrac{n}{2}$ 种轮换。</p><p>哦，小细节，由于本质上手镯里面每条对称轴都是一个单独的置换，所以应该乘个系数。</p><h2 id="NWERC2006-Leonado’s-Notebook"><a href="#NWERC2006-Leonado’s-Notebook" class="headerlink" title="NWERC2006 Leonado’s Notebook"></a>NWERC2006 Leonado’s Notebook</h2><blockquote><p>给定一个置换 $A$ ，求是否存在一个置换 $B$ 使得 $B^2=A$ 。</p></blockquote><p>考虑将置换分解成轮换。注意到如果两个轮换彼此之间不交，那么他们之间的乘法是具有交换律的。同时考虑对于一个奇数大小的轮换，将其平方之后依旧是一个轮换，偶数大小的平方之后则可以分解成两个轮换。所以对于给定的置换，长度为奇数的轮换可以不用管，如果长度为偶数的轮换有奇数个就会 gg。</p><p>具体证明的话，大概是全部相同大小的置换都可以属于同一个置换群，之后就可以对于每个轮换重标号来证明了。</p><p>不过轮换的乘法比较…麻烦。比如 $(1~2~3)(1~2~3)=(1~3~2)$ ，$(1~2~3~4)(1~2~3~4)=(3~4~1~2)=(1,3)(2,4)$ 。感觉自己一碰到这种置换的就 gg。</p><h2 id="UVA11077-Find-the-Permutations"><a href="#UVA11077-Find-the-Permutations" class="headerlink" title="UVA11077 Find the Permutations"></a>UVA11077 Find the Permutations</h2><blockquote><p>给定一个排列，每次可以交换两个数，求至少需要交换 $k$ 次才能让排列递增的排列数。</p></blockquote><p>发现可以将给定的这个排列看做 $(1,2,3\cdots n)$ 的一个置换。那么考虑将其轮换分解之后，对于一个大小为 $k$ 的轮换，不难发现需要交换 $k-1$ 次。于是可以 dp，$f_{i,j}$ 表示长度为 $i$ 的排列至少交换 $j$ 次的排列方案数。那么每次考虑新加进来的元素是否放到之前的某个轮换里，故有转移</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j}+(i-1)\cdot f_{i-1,j-1}</script><p>……发现这就是第一类斯特林数。原因是考虑如果有 $p$ 个轮换，那么至少需要交换 $n-p$ 次。而第一类斯特林数的意义就包括 $n$ 元置换可分解为 $k$ 个独立的轮换(轮换)的个数，所以答案就应该是 $s_1(n,n-k)$。而用上面这种推法推出来的东西恰与第一类斯特林数水平对称。</p><h2 id="CERC-SWERC2005-Pixel-Shuffle"><a href="#CERC-SWERC2005-Pixel-Shuffle" class="headerlink" title="CERC/SWERC2005 Pixel Shuffle"></a>CERC/SWERC2005 Pixel Shuffle</h2><blockquote><p>给定一些关于 $n\times n$ 的黑白方格的奇怪操作，求至少多少次操作可以变换会原来的样子。</p><p>$n\leq 1024,k\leq10$ 。</p></blockquote><p>发现本质上是给定一个置换 $A$，求一个最小的 $m$ 使得 $A^m=I$ 。然后大概就是考虑轮换的性质。对于 $A$ 中的一个长度为 $p$ 的轮换，如果想要全等，就必须要让 $p|m$ 。所以最后答案就是所有轮换大小的最小公倍数。  </p><p>找轮换的话大概就是对每个位置编一个号，找就好了。UVA 属实神必 OJ，和过了的程序拍了一万组交上去依旧 WAWAWA。遇到这种情况那必然是不管了。</p><p>发现中国 OJ 这么多题，刘汝佳非要找 UVA 写书。真是 mdzz。</p><p>不过倒是过了主席的魔改版，这里留个链接: <a href="https://www.luogu.com.cn/problem/U107438" target="_blank" rel="noopener">戳</a> 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"><span class="keyword">int</span> tmp[N][N] ;</span><br><span class="line"><span class="keyword">int</span> base[N][N] ;</span><br><span class="line"><span class="keyword">int</span> dododo[<span class="number">99</span>] ;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">5000</span>] ;</span><br><span class="line"><span class="keyword">char</span> tpo[<span class="number">5000</span>] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N * N] ;</span><br><span class="line"><span class="keyword">unsigned</span> ll ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[j][n - i + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[j][n - i + <span class="number">1</span>] = tmp[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n / <span class="number">2</span> + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>  + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n / <span class="number">2</span> + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n / <span class="number">4</span> * <span class="number">3</span> ; ++ i)</span><br><span class="line">            swap(base[i], base[n - (i - n / <span class="number">2</span>) + <span class="number">1</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n / <span class="number">2</span> ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[i], tmp[j], <span class="keyword">sizeof</span>(tmp[j])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>, j = <span class="number">2</span> ; i &lt;= n ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[i], tmp[j], <span class="keyword">sizeof</span>(tmp[j])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n / <span class="number">2</span> ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[j], tmp[i], <span class="keyword">sizeof</span>(tmp[i])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>, j = <span class="number">2</span> ; i &lt;= n ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[j], tmp[i], <span class="keyword">sizeof</span>(tmp[i])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">7</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = n / <span class="number">2</span>, r = n / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) l = <span class="number">0</span>,  r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][j] = tmp[i][++ l] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][j] = tmp[i + <span class="number">1</span>][++ r] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][j] = tmp[i - <span class="number">1</span>][++ l] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][j] = tmp[i][++ r] ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-7</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = n / <span class="number">2</span>, r = n / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) l = <span class="number">0</span>,  r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][++ l] = tmp[i][j] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i + <span class="number">1</span>][++ r] = tmp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i - <span class="number">1</span>][++ l] = tmp[i][j] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][++ r] = tmp[i][j] ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; base[i][j] &lt;&lt; " \n"[j == n] ;</span></span><br><span class="line"><span class="comment">    puts(" - - - - - - - - - - - - - ") ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> owo = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i][j] != (++ owo)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, cnt ;</span><br><span class="line"><span class="keyword">unsigned</span> ll res[N * N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> ll <span class="title">gcd</span><span class="params">(<span class="keyword">unsigned</span> ll x, <span class="keyword">unsigned</span> ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> ll <span class="title">lcm</span><span class="params">(<span class="keyword">unsigned</span> ll x, <span class="keyword">unsigned</span> ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y / gcd(x, y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    ++ cnt ;</span><br><span class="line"> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line"> dododo[cnt] = <span class="number">-1</span>, ++ s ; <span class="keyword">else</span> dododo[cnt] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"tor"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"mys"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"myshb"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">4</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"mysvb"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">5</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"vid"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">6</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"xim"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">7</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"gen.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"aa.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; getchar() ;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line"><span class="built_in">memset</span>(base, <span class="number">0</span>, <span class="keyword">sizeof</span>(base)) ;</span><br><span class="line">        ans = <span class="number">1</span>, tot = cnt = <span class="number">0</span> ;</span><br><span class="line">        fgets(opt, (<span class="keyword">sizeof</span> opt / <span class="keyword">sizeof</span> opt[<span class="number">0</span>]), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j) base[i][j] = ++ k ;</span><br><span class="line">        m = <span class="built_in">strlen</span>(opt) ; <span class="keyword">int</span> ps = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (opt[i] != <span class="string">' '</span>) tpo[ps ++] = opt[i] ;</span><br><span class="line">            <span class="keyword">else</span> tpo[ps] = <span class="string">'\0'</span>, record(tpo), ps = <span class="number">0</span> ;</span><br><span class="line">        tpo[ps] = <span class="string">'\0'</span> ; record(tpo) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) do_do(dododo[i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[base[i][j]]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> x = i, y = j, z, o = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">while</span> (!vis[base[x][y]])&#123;</span><br><span class="line">                    vis[base[x][y]] = <span class="number">1</span> ; z = base[x][y] ;</span><br><span class="line">                    x = z / n + (!(<span class="keyword">bool</span>)(z % n == <span class="number">0</span>)) ;</span><br><span class="line">                    y = z % n ; <span class="keyword">if</span> (!y) y = n ; ++ o ;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">                res[++ tot] = o ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        debug(res, 1, tot) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = lcm(ans, res[i]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, tot &gt;= <span class="number">1</span> ? ans : <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (T) <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">-2 -6 -7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></div><h1 id="最大流-ISAP"><a href="#最大流-ISAP" class="headerlink" title="最大流-ISAP"></a>最大流-ISAP</h1><p>大概就是设 $d_x$ 表示残量网络上 $x$ 到汇点 $t$ 的距离。那么为了只在残量网络上进行增广，所以每次只能沿着 $d_y+1=d_x$ 的 $(x,y)$ 增广。那么普通的 Dinic 的想法是每次求出一张增广网，然后对这张增广网进行多路增广，为了保证增广路之间不相交所以引入了高度的概念。ISAP 也差不多。只不过是在找增广路的过程中动态地修改标号。即考虑在增广的过程中，可能会有一些边 $(x,y)$ 从残量网络中抹掉，那么如果这条边用来传递标号的边，即 $d_y+1=d_x$，就需要找到另一条边 $(x,z)$ 并给 $x$ 重标号一个高度为 $d_z+1$ 。这个过程可以一开始用一个 bfs 来预处理，不难看出应该倒着预处理，因为在某条边被删掉之后，从 <code>from</code> 找 <code>to</code> 比从 <code>to</code> 找 <code>from</code> 要简单得多，当然这也是为什么 ISAP 对高度的定义和 Dinic 相反的原因(Dinic 其实无所谓怎么定义，因为横竖都要重新生成增广网)。当源点 $s$ 无处增广时算法停止。</p><p>那么有一个优化叫做「gap 优化」。大概就是考虑一条增广路上的点的标号必然是单调的。那么如果出现了某个断层，可以知道不再存在增广路。于是可以直接结束。</p><p>实现方面，可以记一个当前弧来保证只在残量网络上增广。</p><p>最终可以知道 ISAP 本质上是在和 Dinic 做同一件事，因为 ISAP 的重标号一定会是标定最小的那个 $z$ 的 $h_z+1$ ，跟求增广网本质相同。所以复杂度上界也是 $O(n^2m)$ 的。</p><p>哦，顺便提一嘴。似乎有证明当容量均为 $1$ 时，复杂度有着更加优秀的上界 $O(m\sqrt[3] {n^2}+m\sqrt m)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ISAP&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        <span class="keyword">int</span> flow ;</span><br><span class="line">        <span class="keyword">int</span> cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="keyword">int</span> ans ;</span><br><span class="line">    <span class="keyword">int</span> S, T ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> hgt[N] ;</span><br><span class="line">    <span class="keyword">int</span> cur[N] ;</span><br><span class="line">    <span class="keyword">int</span> gap[N] ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        e[++ cnt] = edge(x, y, c) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur)) ;</span><br><span class="line">        <span class="built_in">memset</span>(hgt, <span class="number">0</span>, <span class="keyword">sizeof</span>(hgt)) ;</span><br><span class="line">        <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preBFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        h = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line">        que[++ t] = T ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                <span class="keyword">if</span> (!hgt[e[k].to] &amp;&amp; e[k].to != T)</span><br><span class="line">                    hgt[que[++ t] = e[k].to] = hgt[x] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gap[hgt[i]] ++ ;</span><br><span class="line"><span class="comment">//        debug(hgt, 1, n) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Augment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = T ;</span><br><span class="line">        <span class="keyword">int</span> f = Inf ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line"><span class="comment">//            debug(x) ;</span></span><br><span class="line">            f = min(f, e[pre[x]].cap - e[pre[x]].flow) ;</span><br><span class="line">            x = e[pre[x]].from ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += f ; x = T ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            e[pre[x]].flow += f ;</span><br><span class="line">            e[pre[x] ^ <span class="number">1</span>].flow -= f ;</span><br><span class="line">            x = e[pre[x]].from ;<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = cur[x] ; k &lt; E[x].size() ; ++ k)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = E[x][k] ;</span><br><span class="line"><span class="comment">//             debug(e[p].to) ;//0</span></span><br><span class="line">            <span class="keyword">if</span> (e[p].flow &gt;= e[p].cap) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (hgt[e[p].to] + <span class="number">1</span> != hgt[x]) <span class="keyword">continue</span> ;</span><br><span class="line">            pre[e[p].to] = p ; cur[x] = k ;</span><br><span class="line">            y = e[p].to ; ret = <span class="number">1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preBFS() ;</span><br><span class="line">        <span class="keyword">int</span> x = S ;</span><br><span class="line">        <span class="keyword">while</span> (hgt[S] &lt; n)&#123;</span><br><span class="line"><span class="comment">//            debug(x) ;</span></span><br><span class="line">            <span class="keyword">if</span> (x == T)</span><br><span class="line">                Augment(), x = S ;</span><br><span class="line">            <span class="keyword">if</span> (!Advance(x, x))&#123;</span><br><span class="line">                <span class="keyword">int</span> h = n - <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">                    <span class="keyword">if</span> (e[k].flow &lt; e[k].cap)</span><br><span class="line">                        h = min(h, hgt[e[k].to]) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!-- gap[hgt[x]]) <span class="keyword">break</span> ;</span><br><span class="line">                gap[hgt[x] = h + <span class="number">1</span>] ++ ; cur[x] = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">if</span> (x != S) x = e[pre[x]].from ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            break ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t ;</span><br></pre></td></tr></table></figure></div></div><h1 id="KM-算法"><a href="#KM-算法" class="headerlink" title="KM 算法"></a>KM 算法</h1><p>呃，这算法真的是学了很久。以下默认求的是最大权匹配。</p><p>是用来求「完美匹配」基础上的「最佳权值匹配」。「完美匹配」大概就是说对于一张二分图 $G=\{V_1,V_2,E\}$，设 $|V_1|&lt;|V_2|$，对于某个匹配 $M<em>$ 如果可以使得  $V_1$ 中的点均可以被匹配到，那么就称 $M</em>$ 为 $G$ 的一个完美匹配。</p><p>然后 KM 算法大概是对于每个点设置一个顶标 $p_i$ 或者 $q_i$ （区分左右部，左部记为 $p$，右部记为 $q$），保证 $p_i+q_j\geq w(i,j)$ 。定义 $G$ 的一个相等子图 $G_0=\{V_1,V_2,E_0\}$，需要有 $\forall e(u,v)\in E_0,p_u+q_v=w(u,v)$。那么不难知道如果相等子图 $G_0$ 存在完美匹配 $M_0$，那么 $M_0$ 就是最大权完美匹配。这一点不难证明，只需要注意 $G_0$ 同样包含所有 $G$ 中的顶点即可。</p><p>那么KM 算法本质上就是在不断扩大相等子图的范围实现增广，直到存在完美匹配。假设当前 $G_0$ 中的点集分别为 $\rm \{S,T\}$，那么考虑为了扩大相等子图，需要修改顶标。具体的，让 $\rm S$ 中的所有点顶标增加一个权值 $a$，让 $T$ 中所有点的顶标减小一个权值 $a$ ，那么可知 $G_0$ 中原来的点依旧属于 $G_0$ ，同时对于某个点对 $(u,v),u\in \mathrm{S},v\in V_2\setminus T$，可以知道会有 $p_u+q_v$ 变小，那么就会出现可能把 $(u,v)$ 也加入相等子图的情况。那么不难知道为了保证顶标合法且有新的边加入相等子图，$a$ 需要满足 $a=\min\{p_u+q_v-w(u,v)\},u\in \mathrm{S},v\in V_2\setminus T$ 。考虑加入了这条边之后，要么 $v$ 是未盖点，要么 $v$ 是匹配点。就可以直接进行类似匈牙利算法的过程。考虑对于每个点，至多会增广 $n$ 次，每次增广是 $O(n)$ 的，修改顶标可以 $O(n)$ 查找，那么复杂度就应该是 $O(n^3)$（虽然我一开始写的是暴力找 $a$ 的 $O(n^4)$，但实际上可以记一个 <code>slack</code>）解决这个问题。</p><p>看上去很棒？实际上大多数人实现的 <code>dfs</code> 都是 $O(n^4)$ 的。原因在于每次找增广路并不是 $O(n)$ 而是 $O(m)$ 的。为了解决这个问题就要避免类似 <code>dfs</code> 的过程里反复遍历交错树的情况。于是考虑 <code>bfs</code> ，这样聚合分析一下每次找增广路就会是严格  $O(m)$ 的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Km3=KM of O(n^3), Km4=KM of O(n^4)</span></span><br><span class="line"><span class="keyword">namespace</span> KM&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span> ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    ll ans ;</span><br><span class="line">    ll lack ;</span><br><span class="line">    ll lv[N] ;</span><br><span class="line">    ll rv[N] ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> q[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> matl[N] ;</span><br><span class="line">    <span class="keyword">int</span> matr[N] ;</span><br><span class="line">    ll slack[N] ;</span><br><span class="line">    <span class="keyword">bool</span> visl[N] ;</span><br><span class="line">    <span class="keyword">bool</span> visr[N] ;</span><br><span class="line">    ll val[N][N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        n = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            matl[i] = matr[i] = <span class="number">0</span> ;</span><br><span class="line">            pre[i] = lv[i] = rv[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                lv[i] = max(lv[i], val[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visl[i]) lv[i] -= lack ;</span><br><span class="line">            <span class="keyword">if</span> (visr[i]) rv[i] += lack ;</span><br><span class="line">            <span class="keyword">else</span> slack[i] -= lack ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">do_match4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        visl[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span> ; y &lt;= n ; ++ y)</span><br><span class="line">            <span class="keyword">if</span> (!visr[y])&#123;</span><br><span class="line">                ll t = lv[x] + rv[y] - val[x][y] ;</span><br><span class="line">                <span class="keyword">if</span> (!t)&#123;</span><br><span class="line">                    visr[y] = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (!matl[y] || do_match4(matl[y]))&#123;</span><br><span class="line">                        matl[y] = x ; matr[x] = y ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> slack[y] = min(slack[y], t) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Km4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                slack[j] = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">                lack = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">                fill(visl + <span class="number">1</span>, visl + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                fill(visr + <span class="number">1</span>, visr + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">if</span> (do_match4(i)) <span class="keyword">break</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (!visr[i]) lack = min(lack, slack[i]) ;</span><br><span class="line">                upd() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans += lv[i], ans += rv[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match_back</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z ;</span><br><span class="line">        <span class="keyword">while</span> (x)&#123;</span><br><span class="line">            z = x ;</span><br><span class="line">            matl[x] = pre[x] ;</span><br><span class="line">            x = matr[pre[x]] ;<span class="comment">//2</span></span><br><span class="line">            matr[pre[z]] = z ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_match3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        q[++ t] = x ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">int</span> z = q[h ++] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span> ; y &lt;= n ; ++ y)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (visr[y]) <span class="keyword">continue</span> ;</span><br><span class="line">                    ll v = lv[z] + rv[y] - val[z][y] ;<span class="comment">//3</span></span><br><span class="line">                    <span class="keyword">if</span> (v &gt; slack[y]) <span class="keyword">continue</span> ; pre[y] = z ;</span><br><span class="line">                    <span class="keyword">if</span> (!v)&#123;</span><br><span class="line">                        visr[y] = <span class="number">1</span> ;</span><br><span class="line">                        <span class="keyword">if</span> (!matl[y]) <span class="keyword">return</span> match_back(y) ;</span><br><span class="line">                        <span class="keyword">else</span> visl[q[++ t] = matl[y]] = <span class="number">1</span> ;<span class="comment">//5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> slack[y] = min(slack[y], v) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lack = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ; <span class="keyword">int</span> z = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!visr[i])</span><br><span class="line">                    <span class="keyword">if</span> (lack &gt; slack[i])</span><br><span class="line">                        lack = slack[i], z = i ;</span><br><span class="line">            upd() ; <span class="comment">//4</span></span><br><span class="line">          <span class="comment">//debug(z) ;</span></span><br><span class="line">            <span class="keyword">if</span> (!matl[z]) <span class="keyword">return</span> match_back(z) ;</span><br><span class="line">            visr[z] = visl[matl[z]] = <span class="number">1</span> ; q[++ t] = matl[z] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Km3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(visl, <span class="number">0</span>, <span class="keyword">sizeof</span>(visl)) ;</span><br><span class="line">            <span class="built_in">memset</span>(visr, <span class="number">0</span>, <span class="keyword">sizeof</span>(visr)) ;</span><br><span class="line">            <span class="built_in">memset</span>(slack, <span class="number">127</span>, <span class="keyword">sizeof</span>(slack)) ;</span><br><span class="line">            h = <span class="number">1</span> ; t = <span class="number">0</span> ; visl[i] = <span class="number">1</span> ; do_match3(i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans += lv[i], ans += rv[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nl, nr, n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">memset</span>(KM :: val, <span class="number">-127</span>, <span class="keyword">sizeof</span>(KM :: val)) ;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr(), z = qr() ;</span><br><span class="line">        KM :: val[x][y] = z ;</span><br><span class="line">    &#125;</span><br><span class="line">    KM :: reset(n) ;</span><br><span class="line">    KM :: Km3() ; <span class="built_in">cout</span> &lt;&lt; KM :: ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; KM :: matl[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>upd: 重写了一遍，易错的地方都在板子里标出来了。</p><h1 id="ZKW-费用流"><a href="#ZKW-费用流" class="headerlink" title="ZKW 费用流"></a>ZKW 费用流</h1><p>比较神奇的费用流。考虑一般费用流的做法是改良版的EK，即每次对着残量网络跑一遍最短路，然后对着一条边都满足 $d_v=d_u+val(u,v)$ 的路径进行增广。单路增广必然会很慢，于是来考虑一下为什么必须要单路增广：考虑最短路算法保证在算法结束后，对于残量网络上的每个节点 $x$ 的所有入点 $y$ 有 $d_y+val(y,x)\geq d_x$，且至少存在一个 $y$ 可以使等号成立。那么在残量网络上找出一条增广路之后，与普通的最大流(边权为 $1$)不同的是，剩余的参量网络对于每个 $x$ 不一定会继续存在一个 $y$ 使得等号成立，所以这就需要重新找增广路。</p><p>而 $zkw$ 费用流的思想则是如何不用每次跑一遍最短路来增广，需要引入顶标概念，此处的顶标就是从 $\rm S$ 开始的最短路长度 $d_i$，即有</p><script type="math/tex; mode=display">d_i-d_j+val(i,j)\geq 0</script><p>那么发现跟 KM 的本质极其相似：只增广等号成立的点，那么为了可以使得等号成立就需要不断扩大相等子图，扩大的方式也如出一辙，只需要让所有增广过的点的顶标减去一个 $ \rm lack$ ，而这个 $\rm lack$ 就理应是</p><script type="math/tex; mode=display">\min_{u\in V,v\not\in V}\{d_u-d_v+val(u,v)\}</script><p>这样就可以继续增广了。</p><p>然后写法方面需要注意一些细节。我所知道的应该是有两种写法：</p><p>1、只依赖自动调整。这个写法有个很关键的依赖，就是 $t_{\rm S}$ <strong>单调不增</strong>。换句话说，每次调整 $t_{\rm S}$ 必须要满足存在某条边可以增广，但是此时 $t_{\rm S}$ 并不是单纯地跟某条边的边权挂钩，它只是一个在不断减小的量。所以不难理解，如果存在某个时刻增广到了 $\rm T$ ，那么就一定有 $\sum c=-t_{\rm S}$ ，因为无论什么时候，$\rm S$ 都会在扩展完毕的集合里。</p><p>于是就可以知道，$t_{\rm S}$ 的初值应该赋为 $\rm S$ 所有出边里边权最大的那一条。或者可以直接赋值为 $-\rm Inf$ ，让其自己调整。</p><p>2、大概是个优化？可以考虑在最开始的时候跑一遍最短路。设增广路上的点按顺序分别是 $\rm S,u_1,u_2\cdots u_m,T$ 那么此时每条增广路的 $cost$ 之和就是 </p><script type="math/tex; mode=display">(t_{\rm T}-t_{\rm u_m})+(t_{\rm u_m}-t_{\rm u_{m-1}})\cdots+(t_{\rm u_1}-t_{\rm S})</script><p>化简一下可以得到就是 $t_{\rm T}-t_{\rm S}$ 。</p><p>其实第一个 $case$ 最后的结果本质上也是 $t_T-t_S$ ，然而因为 $T$ 的 $t$ 始终为 $0$，所以可以忽略。看怎么理解了，也可以直接推出 $-t_S$ 。</p><p>事实证明第二种确实比第一种要快。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = x &gt; y ? y : x ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zkw&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cap(k) e[k].cap</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cost(k) e[k].cost</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> from(k) e[k].from</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> flow(k) e[k].flow</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        <span class="keyword">int</span> flow ;</span><br><span class="line">        <span class="keyword">int</span> cost ;</span><br><span class="line">        <span class="keyword">int</span> cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, cost = d, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> mflow ;</span><br><span class="line">    <span class="keyword">int</span> mcost ;</span><br><span class="line">    <span class="keyword">int</span> val[N] ;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] ;</span><br><span class="line">    <span class="keyword">int</span> n, S, T ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="keyword">sizeof</span>(val)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">//        debug(x, ' '), debug(y, ' '), debug(c, ' '), debug(d) ;</span></span><br><span class="line">        e[++ cnt] = edge(x, y, c, d) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>, -d) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">127</span>, <span class="keyword">sizeof</span>(val)) ;</span><br><span class="line">        val[que[h = t = <span class="number">1</span>] = S] = <span class="number">0</span>, vis[S] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            vis[x] = <span class="number">0</span> ; <span class="comment">//debug(x) ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">                <span class="keyword">if</span> (!cap(k)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (val[to(k)] &gt; val[x] + cost(k))&#123;</span><br><span class="line">                    val[to(k)] = val[x] + cost(k) ;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[to(k)])</span><br><span class="line">                        vis[que[++ t] = to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        vis[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (x == T)&#123;</span><br><span class="line"><span class="comment">//            debug(f, ' '), debug(- val[S]) ;</span></span><br><span class="line">            mcost += (val[T] - val[S]) * f ;</span><br><span class="line">            mflow += f ; <span class="keyword">return</span> f ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fl = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">            <span class="keyword">if</span> (flow(k) &lt; cap(k))</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)] &amp;&amp; val[to(k)] == val[x] + cost(k))</span><br><span class="line">                    <span class="keyword">if</span> ((fl = advance(to(k), min(f, cap(k) - flow(k)))))</span><br><span class="line">                        <span class="keyword">return</span> flow(k) += fl, flow(k ^ <span class="number">1</span>) -= fl, fl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lack = <span class="number">1</span> &lt;&lt; <span class="number">30</span> ;</span><br><span class="line">        <span class="keyword">if</span> (vis[T] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (flow(i) &lt; cap(i) &amp;&amp; vis[from(i)] &amp;&amp; !vis[to(i)])</span><br><span class="line">                chkmin(lack, val[from(i)] - val[to(i)] + cost(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (lack == <span class="number">1</span> &lt;&lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) val[i] -= lack ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        spfa() ;</span><br><span class="line"><span class="comment">//        debug(val, 1, n) ;</span></span><br><span class="line">        mflow = <span class="number">0</span> ; mcost = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line">            advance(S, <span class="number">1</span> &lt;&lt; <span class="number">30</span>) ;</span><br><span class="line">        &#125;<span class="keyword">while</span> (modify()) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mflow &lt;&lt; <span class="string">" "</span> &lt;&lt; mcost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t ;</span><br><span class="line">    zkw :: reset(s, t, n) ;</span><br><span class="line">    <span class="keyword">int</span> x, y, f, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x, &amp;y, &amp;f, &amp;c) ;</span><br><span class="line">        zkw :: add(x, y, f, c) ;</span><br><span class="line">    &#125;</span><br><span class="line">    zkw :: solve() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>这一部分是跟 <code>__stdcall</code> 学的。感觉他讲的真的是最详细的了。这个地方安利一下：<a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">戳</a> 。</p><p>以下默认用 $(u,v,\mathrm{lower},\mathrm{upper})$ 来描述一条带有上下界的弧，用 $(u,v,{\rm cap})$ 表示正常流图里的一条弧。</p><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>大概是考虑先建立一个虚的源和汇 $\rm S, \rm T$。然后考虑对于一条弧 $(u,v,c_1,c_2)$ 将其拆成 $({\rm S}, v,c_1),(u, {\rm T},c_1),(u,v,c_2-c_1)$ 三条正常流图的弧(称前两条弧为<strong>附加弧</strong>)，跑最大流。之后对于每条非附加弧，流量加上这条弧原本该有的下界 $c_2$ 就是每条弧的实际流量。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>大概就是所有附加弧保证了一定会流满下界。非附加弧承载的则是「自由流量」，是没有下界可以随便流的弧。不难发现如果所有附加弧都满载，最后流的一定会是一个可行流。</p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模"></a>建模</h3><p>考虑在上一个模型的基础上稍加修改。设原图的源和汇分别是 $s,t$ （下同），那么添加一条 $(t,s,+\infty)$ 的弧即可。这样最后跑出来的就是原图的一个可行流，同时弧 $(t,s)$ 的流量就是原图的总流量。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>考虑有源汇和无源汇本质上区别就在于，有源汇的图里，$s,t$ 是不满足流量平衡的。所以为了维护流量平衡，就需要建一条 $(t,s,+\infty)$ 的弧来疏通流量。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><h3 id="建模-2"><a href="#建模-2" class="headerlink" title="建模"></a>建模</h3><p>考虑先跑一下可行流，如果有可行流，那么就在<strong>跑完的残量网络上</strong>再跑一次<strong>从原图的源到原图的汇的最大流</strong>，即 $s\to t$ 的最大流。那么第二次最大流的结果减就是所求的最大流。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>考虑在一次可行流之后，原图的一定是满足流量下界的。同时因为 $t\to s$ 弧的存在，在新的流图上 $t\to s$ 积攒在反向边 $(s,t)$ 中的流量会直接流给 $t$ 。同时只需要让剩下的边流到不能流就好了。</p><h2 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h2><h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模 1"></a>建模 1</h3><p>首先按照<strong>无源汇可行流</strong>的方式建图。跑一下。之后再把 $(t,s,+\infty)$ 建回去，跑一遍从 $\rm S\to T$ 的最大流，然后去 check 是否合法，如果合法即为答案。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理 1"></a>原理 1</h3><p>考虑本质上是要让可行流最小。根据上文可以知道一组可能流的流量就是 $t\to s$ 的流量，那么为了让可以不流过 $t\to s$ 的流量尽量不要流过这条弧，可以先不考虑这条弧尽量流一波，之后再跑包含这条弧的最大流。这样一方面是可行流，另一方面也会让可行流最小。</p><h3 id="建模-2"><a href="#建模-2" class="headerlink" title="建模 2"></a>建模 2</h3><p>首先按照<strong>有源汇可行流</strong>的方式建图。跑一下，记此时的可行流为 $f_1$ 。之后从 $\rm T\to S$ 跑一遍最大流，记此时的流为 $f_2$。那么答案就是 $f_1-f_2$ 。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理 2"></a>原理 2</h3><p>考虑正向边流量和反向边流量是对称的，那么考虑原图中的一个可行流中，某些弧的流量可以变小，那么如果使反向边流量尽量大，就可以使正向边流量尽量小。同时可以知道这样是一定合法的，因为附加弧不会被流，会被流的只有非附加弧，同时非附加弧不可能出现流量为负。所以不难知道这样是对的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ISAP&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cap(k) e[k].cap</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cost(k) e[k].cost</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> from(k) e[k].from</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> flow(k) e[k].flow</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        ll flow ;</span><br><span class="line">        ll cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, ll c = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    ll ans ;</span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="keyword">int</span> S, T ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> hgt[N] ;</span><br><span class="line">    <span class="keyword">int</span> cur[N] ;</span><br><span class="line">    <span class="keyword">int</span> gap[N] ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll c)</span></span>&#123;</span><br><span class="line">        e[++ cnt] = edge(x, y, c) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur)) ;</span><br><span class="line">        <span class="built_in">memset</span>(hgt, <span class="number">0</span>, <span class="keyword">sizeof</span>(hgt)) ;</span><br><span class="line">        <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prebfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        que[h = t = <span class="number">1</span>] = T ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                <span class="keyword">if</span> (!hgt[to(k)] &amp;&amp; to(k) != T)</span><br><span class="line">                    hgt[que[++ t] = to(k)] = hgt[x] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gap[hgt[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Aug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = T ;</span><br><span class="line">        ll z = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            chkmin(z, cap(pre[x]) - flow(pre[x])) ;</span><br><span class="line">            x = from(pre[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += z ; x = T ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            flow(pre[x]) += z ;</span><br><span class="line">            flow(pre[x] ^ <span class="number">1</span>) -= z ;</span><br><span class="line">            x = from(pre[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = cur[x] ; d &lt; E[x].size() ; ++ d)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = E[x][d] ;</span><br><span class="line">            <span class="keyword">if</span> (flow(k) &gt;= cap(k)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (hgt[x] != hgt[to(k)] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">            cur[x] = d ; ret = <span class="number">1</span> ;</span><br><span class="line">            pre[y = to(k)] = k ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        prebfs() ; <span class="keyword">int</span> x = S ;</span><br><span class="line">        <span class="keyword">while</span> (hgt[S] &lt; n)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span> (x == T)</span><br><span class="line">                Aug(), x = S ;</span><br><span class="line">            <span class="keyword">if</span> (!Advance(x, x))&#123;</span><br><span class="line">                <span class="keyword">int</span> minh = n - <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                    <span class="keyword">if</span> (flow(k) &lt; cap(k))</span><br><span class="line">                        chkmin(minh, hgt[to(k)]) ;</span><br><span class="line">                <span class="keyword">if</span> (!-- gap[hgt[x]]) <span class="keyword">return</span> ;</span><br><span class="line">                gap[hgt[x] = minh + <span class="number">1</span>] ++ ; cur[x] = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">if</span> (x != S) x = from(pre[x]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NO_Lower_Upper_Feasible&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c1 &gt;&gt; c2 ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isap() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span> ; i &lt;= cnt ; i += <span class="number">6</span>)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; from(i) &lt;&lt; " " &lt;&lt; to(i) &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; flow(i) + cap(i - <span class="number">2</span>) &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> YES_Lower_Upper_Maximum&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c1 &gt;&gt; c2 ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">        add(t, s, <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        isap() ; <span class="comment">//debug(ans) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        S = s, T = t ; </span><br><span class="line">      ans = <span class="number">0</span> ; isap() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> YES_Lower_Upper_Minimum&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y ; ll c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            x = qr() ;</span><br><span class="line">y = qr() ;</span><br><span class="line">c1 = qr() ;</span><br><span class="line">c2 = qr() ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        isap() ; <span class="comment">//debug(ans) ;</span></span><br><span class="line">        add(t, T, <span class="number">0</span>) ;</span><br><span class="line">        add(S, s, <span class="number">0</span>) ;</span><br><span class="line">        add(t, s, <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line">        ans = <span class="number">0</span> ; isap() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="上下界费用流"><a href="#上下界费用流" class="headerlink" title="上下界费用流"></a>上下界费用流</h2><p>和最大流没什么本质区别。唯一的不同在于，比如求最小费用最大流的时候第二遍只清空 <code>mflow</code> 而不清空 <code>mcost</code>。因为有一部分流是通过 $t\to s$ 这个不定费用弧流过来的，这时是不计算流量的。感觉其他的也大差不差？稍微改一波就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是发现杂七杂八学来的东西没有很必要整理的就从略了。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;当然有很多是以前学的结果给忘了。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;慢慢更，咕咕咕。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
      <category term="网络流/带有上下界的网络流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%B8%A6%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="图论/匹配/KM算法" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-KM%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学/高斯消元" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="字符串/Z-Algorithm" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Z-Algorithm/"/>
    
      <category term="数学/置换,轮换" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BD%AE%E6%8D%A2-%E8%BD%AE%E6%8D%A2/"/>
    
      <category term="动态规划/链分治维护dp" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%93%BE%E5%88%86%E6%B2%BB%E7%BB%B4%E6%8A%A4dp/"/>
    
      <category term="技巧/min-max容斥" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-min-max%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIP2018/CSP2019]题目整理</title>
    <link href="https://www.orchidany.cn/2020/05/11/NOIP2018-CSP2019/"/>
    <id>https://www.orchidany.cn/2020/05/11/NOIP2018-CSP2019/</id>
    <published>2020-05-11T02:27:47.000Z</published>
    <updated>2020-05-21T14:40:17.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是重做了一下 NOIP2018/CSP2019 两年的全部题目？</p><p>感觉当时场上没 A 掉的题，放到现在做总是感觉有点心理阴影emm</p><p>Anyway, 只用真正告别过去才能走向未来。你说，对吧？</p><a id="more"></a><p>题目排序为按时间排序。题面看心情加（</p><h1 id="NOIP2018"><a href="#NOIP2018" class="headerlink" title="NOIP2018"></a>NOIP2018</h1><h2 id="A-铺设道路"><a href="#A-铺设道路" class="headerlink" title="A 铺设道路"></a>A 铺设道路</h2><p>考场上并没想到正解。读完题之后觉得每次一定都是选当前段内最小的那个高度来操作，所以就用线段树套了个分治；后来又发现只有询问，于是就变成了 ST 表套了个分治。最后…大概是线性的吧。（但其实大家写的 ST 表都不是线性的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> P = query(l, r) ;</span><br><span class="line">    <span class="keyword">int</span> L = l, R = r ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (query(L, mid) == P) R = mid ;</span><br><span class="line">        <span class="keyword">else</span> L = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> W = L ; </span><br><span class="line">    Ans += (base[W] - delta), delta += (base[W] - delta) ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; work(l, W - <span class="number">1</span>, delta), work(W + <span class="number">1</span>, r, delta) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-货币系统"><a href="#B-货币系统" class="headerlink" title="B 货币系统"></a>B 货币系统</h2><p>无脑背包题。感觉两年前的自己真的是菜的一匹…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">N = qr(), ans = <span class="number">0</span> ; </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)) ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, o, mxm = <span class="number">0</span> ; dp[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base[i] = qr(), mxm = max(base[i], mxm) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (i != k &amp;&amp; base[k] != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> (j = base[k] ; j &lt;= mxm ; ++ j)</span><br><span class="line">dp[j] |= dp[j - base[k]] ;</span><br><span class="line"><span class="keyword">if</span> (dp[base[i]]) base[i] = <span class="number">-1</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ans += (<span class="keyword">bool</span>)(base[i] == <span class="number">-1</span>) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, N - ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-赛道修建"><a href="#C-赛道修建" class="headerlink" title="C 赛道修建"></a>C 赛道修建</h2><blockquote><p>用 $m$ 条不相交的链覆盖一棵树，最大化长度最小的链。</p><p>$2 \leq n \leq 5 \times 10^{4}, 1 \leq m \leq n-1$。</p></blockquote><p>当时考场上写的是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">2000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">else</span> FFF = LCA(i, j), Ans = max(Ans, Sum[i] + Sum[j] - <span class="number">2</span> * Sum[FFF]) ;</span><br><span class="line"><span class="keyword">if</span> (M &gt; <span class="number">1</span>) Ans = Ans / M + rand()%(Ans / (M - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……也不知道自己咋想的。</p><p>然后这次复盘的时候还读错了题，读成了「必须要把全部的边都覆盖」，觉得这种二维限制的怎么可能去二分…感到十分弱智。</p><p>之后就变成了考虑二分答案，是否可以选 $\geq m$ 条 $\geq val$ 的边不相交链。感觉似乎是可以 bottom to top 地 dp 一波顺便转移一下没有闭合的链。</p><p>这题确实很水，这个贪心已经自然到证都不用证的地步了 233。</p><p>一开始打算用 vector 维护。发现需要支持删除和排序就换成了 set。然后还有 <code>multiset</code> 的一些细节没有注意。多亏了 zay，不然我又要调上一年…还有很多其他的细节没有注意，感觉在考场上势必还是要挂分。慢慢练吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;<span class="keyword">int</span>&gt; sint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, g ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line">sint chain[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    sint t ; t.clear() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">int</span> z ;</span><br><span class="line">        dfs(to(k), x, w) ; f[x] += f[to(k)] ;</span><br><span class="line">z = (*chain[to(k)].begin()) + val(k) ;</span><br><span class="line">        <span class="keyword">if</span> (z &gt;= w) ++ f[x] ; <span class="keyword">else</span> t.insert(z) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " &amp; " &lt;&lt; (*chain[to(k)].begin()) + val(k) &lt;&lt; " " ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; t.size() &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (t.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(chain[x].insert(<span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">auto</span> s = t.begin() ;</span><br><span class="line">    <span class="keyword">while</span> (s != t.end())&#123;</span><br><span class="line">        <span class="keyword">int</span> p = w - (*s) ;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">auto</span> q = t.lower_bound(p) ;</span><br><span class="line">        <span class="keyword">if</span> (q == s) ++ q ;</span><br><span class="line">        <span class="keyword">if</span> (q == t.end()) &#123; ++ s ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        t.erase(q) ; s = t.erase(s), ++ f[x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t.empty()) chain[x].insert(<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">else</span> chain[x].insert(*(-- t.end())) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        chain[i].clear(), f[i] = <span class="number">0</span> ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, x) ; <span class="comment">//debug(f, 1, n) ;</span></span><br><span class="line"><span class="keyword">return</span> (f[<span class="number">1</span>] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">    <span class="keyword">int</span> x, y, z, l = <span class="number">10000</span>, r = <span class="number">0</span>, mid, ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        x = qr() ; y = qr() ; z = qr() ;</span><br><span class="line">        add_e(x, y, z), add_e(y, x, z) ; </span><br><span class="line">        r += z ; chkmin(l, z) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            ans = mid, l = mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-旅行"><a href="#D-旅行" class="headerlink" title="D 旅行"></a>D 旅行</h2><blockquote><p>给出一棵树或者一棵基环树，求字典序最小的dfs序。</p><p>The original data range : $1\le n\le 5\times 10^3,n-1\leq m\leq n$ 。</p><p>The extra data range: $1\le n\le 3\times 10^5,n-1\leq m\leq n$。</p></blockquote><p>考虑如果是树的话显然是可以直接贪的。基环树的话就只需要枚举断哪一条边即可。注意断的边不能是桥边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; !del[k])&#123;</span><br><span class="line">            dfs1(to(k), u),</span><br><span class="line">            sz[u] += sz[to(k)],</span><br><span class="line">            son[u].push_back(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, k ; o[++ res] = u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : son[u]) dfs2(k, u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt; y[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x[i] &gt; y[i]) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, u, v ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add(u, v) ;</span><br><span class="line">    <span class="keyword">if</span> (M == N - <span class="number">1</span>)&#123;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            sort(son[i].begin(), son[i].end()) ;</span><br><span class="line">        dfs2(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> ctn = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                fa[j] = j ; del[i] = del[i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; j += <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (del[j]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> f1 = find(fr(j)) ;</span><br><span class="line">                <span class="keyword">int</span> f2 = find(to(j)) ;</span><br><span class="line">                <span class="keyword">if</span> (f1 != f2) fa[f1] = f2 ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                ctn = ctn + (<span class="keyword">bool</span>)(fa[j] == j) ;</span><br><span class="line">            <span class="keyword">if</span> (ctn == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs1(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                    sort(son[j].begin(), son[j].end()) ;</span><br><span class="line">                dfs2(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j) son[j].clear() ;</span><br><span class="line">                <span class="keyword">if</span> (Compare(o, ans))</span><br><span class="line">                    <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            del[i] = del[i + <span class="number">1</span>] = <span class="number">0</span> ; res = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑更快一点怎么做。发现就是一个弱智贪心。然后就没有然后了。</p><p>upd: 香，真香。所谓「弱智贪心」我愣是从 $14:00$ 写到 $20:30$ 。</p><p>大概就是一开始觉得，对于当前环，设环里面离 $1$ 最近的一个点 $k$ 是这个环的<strong>根</strong>，那么他一定有两个儿子都在环上，称这两个儿子中<strong>较小</strong>的那个为<strong>左儿子</strong>，<strong>较大</strong>的为<strong>右儿子</strong>。那么要走肯定会走左儿子(这里设为走 $x$)，并且断的地方一定是左儿子向下找的途中第一个比右儿子大的点 $z$，将 $z$ 留给右儿子那条链，因为这时先走右儿子一定会更优。</p><p>然而这是错的。由于上文钦定了一定要经过 $z$ 之上的点，所以环上所有深度 $&gt;dep_z$ 点的外向枝在回溯时是必须要走的，并且是走完 $z$ 之后就需要接着走。那么如果外向枝中存在点的编号比 $z$ 大，就不如先走 $z$ 再回溯，因为 $z$ 之后紧接的都是比 $z$ 大的。然后想到这里，我大概是用一个值 $v$ 表示从左儿子走到当前点 $z$，沿途外向枝中最大的点的编号。注意细节，如果外向枝中的某些点比当前点要小，那必然是先走外向枝再走现在的点。于是我大概就是这么维护的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bicheck</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)((x == key_f) &amp;&amp; (y == key_s)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == loop_f) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, q, p = <span class="number">0</span>, op = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cld[<span class="number">2</span>] = &#123; loop_s, loop_c &#125;;</span><br><span class="line">        <span class="keyword">if</span> (cld[<span class="number">0</span>] &lt; cld[<span class="number">1</span>])</span><br><span class="line">            t = cld[<span class="number">0</span>], q = cld[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = cld[<span class="number">1</span>], q = cld[<span class="number">0</span>];</span><br><span class="line">        dep[t] = dep[q] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == lj[tot])</span><br><span class="line">            reverse(lj + <span class="number">1</span>, lj + tot + <span class="number">1</span>);</span><br><span class="line">        op = maxx[lj[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; tot; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op &lt;= lj[k])</span><br><span class="line">                op = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (lj[k] &gt; q &amp;&amp; lj[k] &gt; op) &#123;</span><br><span class="line">                key_s = lj[k];</span><br><span class="line">                key_f = lj[k - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; k; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j &gt;= k; --j) dep[lj[j]] = dep[lj[j + <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            op = max(maxx[lj[k]], op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!key_s) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; tot; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而…这还是错的。因为如果上面存在某个外向枝内的点 $x$ 比当前点编号要小，但是在当时并不应该提前走 $x$，那么此时如果走下去，$x$ 就会比当前点的时间戳要靠后，不如直接走 $x$ 。就比如下面这张图，应该断掉 $(3,5)$ ，先走 $5$ 再回溯到 $4$ 显然不如直接走 $4$ 更优。 </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>于是冷静了一下改成用 set 去维护 <code>lower_bound</code> 和当前最小值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stt.insert(maxx[lj[<span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; tot; ++k) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((!stt.empty()) &amp;&amp; (*stt.begin() &lt;= x)) stt.erase(stt.begin());</span><br><span class="line">    <span class="keyword">if</span> (lj[k] &gt; q &amp;&amp; (stt.empty() || stt.lower_bound(lj[k]) != stt.begin())) &#123;</span><br><span class="line">        key_s = lj[k];</span><br><span class="line">        key_f = lj[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; k; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j &gt;= k; --j) dep[lj[j]] = dep[lj[j + <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stt.insert(maxx[lj[k]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样还是不对…在我冷静了很久之后发现…似乎很难确定到底该走到哪个点断掉，因为这样贪心相当于还是只想了一半<del>期间一度陷入自闭</del>。</p><p>然后灵光一闪。发现外向枝里面可能有比当前大的点，也可能有比当前小的点。那么如果回溯时一定会先去遍历比当前点大的点就肯定不会断，如果一定会去遍历比当前小的点就一定要断。否则如果可以选择先遍历大的还是小的，就可以根据最初的那个 check 来判断到底断不断，因为此时外向枝不再有影响。于是就拿了个线段树维护了一下时间戳。然后就过掉了。</p><p>总结一下，还是自己思路太不清晰、太不仔细导致平白无故浪费了许多时间。写代码的时候不知道为什么，有一种「这样一定是对的」的诡异勇气让我无法静下心来思考…</p><p>还是实战过少。可能需要模拟赛来补救一下这块短板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> key_f ;</span><br><span class="line"><span class="keyword">int</span> key_s ;</span><br><span class="line"><span class="keyword">int</span> loop_f ;</span><br><span class="line"><span class="keyword">int</span> loop_s ;</span><br><span class="line"><span class="keyword">int</span> loop_c ;</span><br><span class="line"><span class="keyword">int</span> fr[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dep[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> base[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> maxx[MAXN] ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])&#123;</span><br><span class="line">        loop_f = x ;</span><br><span class="line">        loop_s = fa ;</span><br><span class="line">        <span class="keyword">int</span> t = loop_s ;</span><br><span class="line">        <span class="keyword">while</span> (t != loop_f)</span><br><span class="line">            base[++ tot] = t, t = fr[t] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            maxx[x] = max(maxx[x], to(k)) ;</span><br><span class="line">            fr[to(k)] = x, dfs3(to(k), x) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bicheck</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)((x == key_f) &amp;&amp; (y == key_s)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seg[MAXN * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    seg[rt] = max(seg[rt &lt;&lt; <span class="number">1</span>], seg[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        seg[rt] = v ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) upd(rt &lt;&lt; <span class="number">1</span>, l, mid, pos, v) ;</span><br><span class="line">    <span class="keyword">else</span> upd(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, v) ; _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> seg[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) chkmax(res, query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr)) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) chkmax(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr)) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == loop_f)&#123;</span><br><span class="line">        <span class="keyword">int</span> t, q, p = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> op = <span class="number">0</span>, pre = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> cld[<span class="number">2</span>] = &#123;loop_s, loop_c&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (cld[<span class="number">0</span>] &lt; cld[<span class="number">1</span>])</span><br><span class="line">            t = cld[<span class="number">0</span>], q = cld[<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">else</span> t = cld[<span class="number">1</span>], q = cld[<span class="number">0</span>] ;</span><br><span class="line">        dep[t] = dep[q] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (t == base[tot])</span><br><span class="line">            reverse(base + <span class="number">1</span>, base + tot + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[base[<span class="number">1</span>]] ; j ; j = next(j))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(j) == x) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (to(j) &lt;= base[<span class="number">2</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">            upd(<span class="number">1</span>, <span class="number">1</span>, n, to(j), dep[base[<span class="number">1</span>]]) ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= tot ; ++ k)&#123;</span><br><span class="line">            chkmax(pre, base[k]) ;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">more_t</span> = query(<span class="number">1</span>, <span class="number">1</span>, n, base[k] + <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">less_t</span> = query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, base[k] - <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">less_t</span> == <span class="keyword">more_t</span> &amp;&amp; pre &gt; q) &#123;</span><br><span class="line">                key_s = base[k] ;</span><br><span class="line">                key_f = base[k - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span> ; j &gt;= k ; -- j)</span><br><span class="line">                    dep[base[j]] = dep[base[j + <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">less_t</span> &gt; <span class="keyword">more_t</span>)&#123;</span><br><span class="line">                key_s = base[k] ;</span><br><span class="line">                key_f = base[k - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span> ; j &gt;= k ; -- j)</span><br><span class="line">                    dep[base[j]] = dep[base[j + <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = base[k] ;</span><br><span class="line">            dep[base[k]] = dep[base[k - <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[y] ; j ; j = next(j))&#123;</span><br><span class="line">                <span class="keyword">if</span> (to(j) == base[k - <span class="number">1</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (to(j) &lt;= base[k + <span class="number">1</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">                upd(<span class="number">1</span>, <span class="number">1</span>, n, to(j), dep[y]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!key_s)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">                dep[base[j]] = dep[base[j - <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (bicheck(x, to(k))) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (bicheck(to(k), x)) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (dep[to(k)] &amp;&amp; dep[to(k)] != dep[x] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">dfs4(to(k), x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; !bicheck(u, to(k)) &amp;&amp; !bicheck(to(k), u) &amp;&amp; dep[to(k)] == dep[u] + <span class="number">1</span>)</span><br><span class="line">            dfs5(to(k), u), sz[u] += sz[to(k)], son[u].push_back(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, k ; o[++ res] = u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : son[u]) dfs6(k, u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("travel.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("travel.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> i, u, v ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add(u, v), ++ deg[u], ++ deg[v] ;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs3(<span class="number">1</span>, <span class="number">0</span>) ; tot -- ;</span><br><span class="line">        swap(loop_s, loop_f) ;</span><br><span class="line">        <span class="keyword">if</span> (base[<span class="number">1</span>] == loop_s)</span><br><span class="line">             loop_c = base[tot] ;</span><br><span class="line">        <span class="keyword">else</span> loop_c = base[<span class="number">1</span>] ; dfs4(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">dfs5(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            sort(son[i].begin(), son[i].end()) ;</span><br><span class="line">        dfs6(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-填数游戏"><a href="#E-填数游戏" class="headerlink" title="E 填数游戏"></a>E 填数游戏</h2><p>考虑暴力的话自然是搜索…当时在考场上写了好久…幸亏最后调出来了。依稀记得最后 $30min$ 调出来这个搜索之后，找到规律之后无比兴奋…兴奋到没有打最后一题的暴力qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Ans ; <span class="keyword">char</span> S[<span class="number">20000</span>][<span class="number">200</span>], W[<span class="number">20000</span>][<span class="number">200</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, T[<span class="number">20000</span>], i, j, k, tot, <span class="built_in">map</span>[<span class="number">250</span>][<span class="number">250</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == N &amp;&amp; y == M) &#123;</span><br><span class="line">W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[N][M] + <span class="number">48</span>) ; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == N) S[tot][step] = <span class="string">'R'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x, y + <span class="number">1</span>, step + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y == M) S[tot][step] = <span class="string">'D'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x + <span class="number">1</span>, y, step + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> S[tot][step] = <span class="string">'R'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x, y + <span class="number">1</span>, step + <span class="number">1</span>),</span><br><span class="line"> <span class="built_in">strcpy</span>(S[tot + <span class="number">1</span>], S[tot]), ++ tot, S[tot][step] = <span class="string">'D'</span>, <span class="built_in">strcpy</span>(W[tot], W[tot - <span class="number">1</span>]), W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x + <span class="number">1</span>, y, step + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> A = <span class="number">1</span> ; A &lt; tot ; ++ A)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> B = A ; B &lt;= tot  ; ++ B)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">2</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (S[A][di] &gt; S[B][di]) &#123; flag = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S[A][di] &lt; S[B][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">1</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> ((W[A][di] &gt; W[B][di]) &amp;&amp; flag) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (W[A][di] &lt; W[B][di]) <span class="keyword">break</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> A = <span class="number">1</span> ; A &lt;= tot ; ++ A)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> B = <span class="number">1</span> ; B &lt; A ; ++ B)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">2</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (S[A][di] &lt; S[B][di]) &#123; flag = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S[A][di] &gt; S[B][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">1</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (W[A][di] &lt; W[B][di] &amp;&amp; flag) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (W[A][di] &gt; W[B][di]) <span class="keyword">break</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (B)&#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) res = res * A % Mod ;</span><br><span class="line">A = A * A % Mod, B &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="keyword">if</span> (N &gt; M) swap(N, M) ;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">4</span> &amp;&amp; M &lt;= <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> Max = (<span class="number">1</span> &lt;&lt; N * M) - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)</span><br><span class="line"><span class="built_in">map</span>[j][k] = (<span class="number">1</span> &lt;&lt; tot &amp; i) ? <span class="number">1</span> : <span class="number">0</span>, ++ tot ;</span><br><span class="line">tot = <span class="number">1</span>, dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">if</span> (check()) ++ Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12</span> * expow(<span class="number">3</span>, M - <span class="number">2</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">112</span> * expow(<span class="number">3</span>, M - <span class="number">3</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">5</span> &amp;&amp; M == <span class="number">5</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">7136</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">5</span> &amp;&amp; M == <span class="number">4</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2688</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了一下这个搜索的复杂度。发现大概是什么 $O\left(2^{m\times n}\cdot \binom{n+m-2}{n-1}^2\right)$ 的，这东西在 $n=5,m=5$ 的时候计算量是 $164416716800\approx1.64\cdot 10^{11}$。不过打出 $n=3,m=4/5/6$ 的表来还是戳戳有余的（$n=3,m=6,T=115605504$）。</p><p>然后就又是喜闻乐见的找性质环节：</p><p>1、不难归纳出来，反对角线(即 $n+m$ 为定值)上所有的位置，按照列号从小到大来排布，填的数构成的数列应该<strong>不下降</strong>。具体可以考虑归纳，大概就是说如果有两个序列的一部分只有两步不同，即 <code>...WWWWDDDD...</code> 和 <code>...WWWDWDDD...</code>，那么必然存在一个经过了 $(i,j)$ 而另一个经过了 $(i+1,j-1)$，那么就必然需要 $a_{i+1,j-1}\geq a_{i,j}$。那么一直归纳下去，不难发现这是<strong>必要条件</strong>。</p><p>2、然而只考虑第一点是错的。自己还是把暴力和构造分别打了个表出来才明白哪不对…具体来说比如这个矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>那么 <code>WDDW</code> 和 <code>DWWD</code> 这两个走法的关系就显然不对。然后抽象了一会儿觉得可能是要考虑对称位置，但是发现 $n\ne m$ 时并不可以良定义「对称」；又觉得可能是需要到 $i,j$ 的路径都本质不同，但是发现并不会设计状态来算这个步数…</p><p>还是知乎好！从知乎上学了一波，感觉十分深刻。大概就是考虑如果 $(i,j-1)=(i-1,j)$ ，那么以 $(i,j)$ 为左上角的所有矩阵的反对角线上的数都必须相等。感觉这个抽象十分到位。考虑如果某条对角线上的两个点 $(a_1,b_1),(a_2,b_2)$ 不同，那么必然可以让两条路线让他们在 $(c,d)$ 处分开，一个尽量 <code>W</code> 一个尽量 <code>D</code>，注意到由于 <code>W&amp;D</code> 的数量是固定的，所以尽量 <code>W</code> 的那个一开始字典序一定偏小，那么该路径走到 $(a_2,b_2)$ 就会使答案不合法。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>比较直接的相反就是继续爆搜。发现这样优化了一波之后复杂度变成了 $O(2^{n\times m}\cdot n^2m^2)$ 的，那么 $n=m=5$ 时的运算量就变成了 $20971520000\approx 2.1\cdot 10^{10}$ …好像也没快多少…</p><p>然后大概就是考虑对着这两个条件进行 dp。然后大概发现自己不会怎么 dp 对角线。然后选择剪枝。发现复杂度大头是 $2^{n\times m}$，考虑缩一下这个，大概就是确定每条对角线哪个位置是分界点。那么设 $n\leq m$，这样的复杂度大概是 $O\left((n!)^2\cdot n^{m-n}\cdot n^2m^2\right)$ 。稍微优化一波 <code>checker</code> 就可以做到 $O\left((n!)^2\cdot n^{m-n}\cdot nm\right)$ 。但这样在 $n=m=7$ 的时候大概是 $1244678400=1.24\cdot 10^9$ 依旧不是很能过<del>然后发现(1,1)和(n,n)并不重要就可以有一个1/4的常数</del>。但无论怎样，80 分确实是有了。算了一下 $n=m=8$ 的时候 $  T= 104044953600\approx 10^{11}$，如果按照一秒钟 $5e8$ 的速度大概是 $2000s+$ （其实不到 $2min$ 就出来了），找一波规律就 $100$ 了。</p><p>不知为何似乎有坑点。发现当 $n=6$ 的时候应该拿 $m=7$ 时算的数来算，因为此时似乎 $ans(6,7)\ne3\cdot ans(6,6)$ ？似乎 $n=8$ 时也是这样…挺奇怪的。并且 $8,9$ 至少要多一个 $81$ 倍常数…就很爆炸。不过似乎确实也在 $10min$ 之内出了结果。大力出奇迹啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans, vis[<span class="number">100</span>][<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> owo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i][j] == owo) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i - <span class="number">1</span>][j] == <span class="built_in">map</span>[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = i + <span class="number">1</span> ; x &lt;= n ; ++ x)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = j ; y &lt; m ; ++ y)</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="built_in">map</span>[x - <span class="number">1</span>][y + <span class="number">1</span>])</span><br><span class="line">                            vis[x][y] = owo ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % Mod ;</span><br><span class="line">x = x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == n + m - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(ans += check(++ tot)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span> ; i &lt;= s ; ++ i)&#123;</span><br><span class="line">            x = s, y = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= s - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = s, y = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= s - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &lt;= m)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= n - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= n - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t = n - (s - m) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, j, i = <span class="number">0</span>; i &lt;= t ; ++ i)&#123;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span>, j = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= i)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, ++ j, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span>, j = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= i)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, ++ j, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">if</span> (n + m &lt;= <span class="number">12</span>) dfs(<span class="number">2</span>), <span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> * ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">12l</span>l * expow(<span class="number">3</span>, m - <span class="number">2</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">112l</span>l * expow(<span class="number">3</span>, m - <span class="number">3</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">6</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">170112l</span>l * expow(<span class="number">3</span>, m - <span class="number">7</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">7</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">453504l</span>l * expow(<span class="number">3</span>, m - <span class="number">7</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">8</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">3626752</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">10879488l</span>l * expow(<span class="number">3</span>, m - <span class="number">9</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>学了一波状压对角线，感觉自己是弟弟。大概就是考虑如何把两个限制写到状态里面。发现可以设状态 $f_{i,j,s}$ 表示考虑前 $i$ 条对角线，第 $i$ 条对角线从下至少染了 $j$ 个 $1$，对角线上每个位置(以及所包含的那个矩形)是否合法(用 $s$ 表示)的方案数。转移就可以枚举上一条对角线的状态。这样最后就是 $O(2^n\cdot n\cdot n^2\cdot m)$ 的复杂度。</p><p><del>但显然最后答案还是要打表找规律的</del>。</p><h2 id="F-保卫王国"><a href="#F-保卫王国" class="headerlink" title="F 保卫王国"></a>F 保卫王国</h2><blockquote><p>给定树，求最小点覆盖。多组询问，每组询问会钦定两个点被覆盖或者不被覆盖，并询问最小边覆盖。</p><p>$1\leq n,m\leq 10^5$ 。</p></blockquote><h2 id="Sol-1-链分治维护dp"><a href="#Sol-1-链分治维护dp" class="headerlink" title="Sol 1 链分治维护dp"></a>Sol 1 链分治维护dp</h2><p>大概就是考虑最小边覆盖的 $dp$</p><script type="math/tex; mode=display">f_{x,0}=\sum f_{y,1}\\f_{x,1}=\sum \min\{f_{y,1},f_{y,0}\}</script><p>然后考虑设 $g_{x,0}$ 表示只考虑了 $x$ 的轻儿子时的最小边覆盖。那么有</p><script type="math/tex; mode=display">f_{x,0}=g_{x,0}+f_{z,1}\\f_{x,1}=g_{x,1}+\min\{f_{z,0},f_{z,1}\}</script><p>其中 $z$ 是 $x$ 的重儿子。那么不难知道转移矩阵应该写成</p><script type="math/tex; mode=display">\begin{bmatrix}f_{z,0}&f_{z,1}\end{bmatrix}\times \begin{bmatrix}+\infty & g_{x,1}\\g_{x,0} & g_{x,1}\\\end{bmatrix}= \begin{bmatrix}f_{x,0}&f_{x,1}\end{bmatrix}</script><p>然后就可以直接用 LCT 维护链来做了。写的时候有不少细节需要注意…自己还是太菜了…不过 LCT 确实挺短的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> lans;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> base[N];</span><br><span class="line"></span><br><span class="line">vint E[N];</span><br><span class="line"></span><br><span class="line"><span class="function">il ll <span class="title">min</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b &gt; a ? a : b; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    ll m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="function">il ll <span class="title">minx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> min(m[<span class="number">1</span>][<span class="number">0</span>], m[<span class="number">1</span>][<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="function">il <span class="title">mat</span><span class="params">(ll a = Q, ll b = Q, ll c = Q, ll d = Q)</span> </span>&#123;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>] = a;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">1</span>] = b;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">0</span>] = c;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">1</span>] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    il mat <span class="keyword">friend</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;a, <span class="keyword">const</span> mat &amp;b) &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        c = mat();  <span class="comment">// c.reset() ;</span></span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">1</span>] = min(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">0</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">1</span>] = min(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">1</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">0</span>] = min(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">0</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">0</span>] = min(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">1</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) s[x].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_0(x) s[x].g[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_1(x) s[x].g[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lct</span> &#123;</span></span><br><span class="line">    mat f;</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    ll g[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">&#125; s[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">w_k</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (rc(fa(x)) == x); &#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (lc(fa(x)) == x || rc(fa(x)) == x); &#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    f(x) = mat(Q, g_1(x), g_0(x), g_1(x));</span><br><span class="line">    f(x) = f(rc(x)) * f(x) * f(lc(x));<span class="comment">//1 转移顺序 必须要从下到上转移 即 splay 里要严格按照顺序来转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> da = fa(x);</span><br><span class="line">    <span class="keyword">int</span> dada = fa(da);</span><br><span class="line">    <span class="keyword">bool</span> w = w_k(x), ww = w_k(da);</span><br><span class="line">    <span class="keyword">if</span> (notroot(da))</span><br><span class="line">        s[dada].son[ww] = x;</span><br><span class="line">    fa(x) = dada;</span><br><span class="line">    fa(s[x].son[w ^ <span class="number">1</span>]) = da;</span><br><span class="line">    s[da].son[w] = s[x].son[w ^ <span class="number">1</span>];</span><br><span class="line">    s[x].son[w ^ <span class="number">1</span>] = da;</span><br><span class="line">    fa(da) = x;</span><br><span class="line">    _up(da);</span><br><span class="line">    _up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notroot(fa(x)))</span><br><span class="line">            rotate(w_k(fa(x)) == w_k(x) ? fa(x) : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x = fa(y = x)) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        g_1(x) += f(rc(x)).minx() - f(y).minx();</span><br><span class="line">        g_0(x) += f(rc(x)).m[<span class="number">1</span>][<span class="number">1</span>] - f(y).m[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        rc(x) = y;</span><br><span class="line">        _up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prelude</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span> </span>&#123;</span><br><span class="line">    g_0(x) = <span class="number">0</span>;</span><br><span class="line">    g_1(x) = base[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != dad) &#123;</span><br><span class="line">            fa(k) = x;</span><br><span class="line">            prelude(k, x);</span><br><span class="line">            g_0(x) += g_1(k);</span><br><span class="line">            g_1(x) += min(g_0(k), g_1(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f(x) = mat(Q, g_1(x), g_0(x), g_1(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _upd(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll v) &#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    s[x].g[y ^ <span class="number">1</span>] += v;</span><br><span class="line">    _up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> pks[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"defense.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"defense.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    qr(n), qr(m);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pks;</span><br><span class="line">    <span class="keyword">int</span> x, y, a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) qr(base[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">      qr(x), qr(y), E[x].p_b(y), E[y].p_b(x);</span><br><span class="line">    prelude(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0</span>) = mat(<span class="number">0</span>, Q, Q, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        qr(x);</span><br><span class="line">        qr(a);</span><br><span class="line">        _upd(x, a, Q);</span><br><span class="line">        qr(y);</span><br><span class="line">        qr(b);</span><br><span class="line">        _upd(y, b, Q);</span><br><span class="line">        splay(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f(<span class="number">1</span>).minx() &gt;= Q)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f(<span class="number">1</span>).minx());</span><br><span class="line">        _upd(x, a, -Q);</span><br><span class="line">        _upd(y, b, -Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sol-2-倍增"><a href="#Sol-2-倍增" class="headerlink" title="Sol 2 倍增"></a>Sol 2 倍增</h2><p>大概就是说，询问之间本身都是独立的。所以如果强行上动态 dp 有点过犹不及。</p><p>于是考虑大力倍增。水平不够暂时咕咕咕了。</p><h1 id="CSP2019"><a href="#CSP2019" class="headerlink" title="CSP2019"></a>CSP2019</h1><h2 id="A-格雷码"><a href="#A-格雷码" class="headerlink" title="A 格雷码"></a>A 格雷码</h2><p>就，模拟一下？我正我是分治了一波。这种题怎么做都可以吧。</p><p>做的时候似乎是特判了一波什么 <code>1&lt;&lt;64</code> 爆 <code>long long</code> 的东西，好像还是挺有用的？ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ull l, ull r, ull p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == p) ans[++ cnt] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> ans[++ cnt] = <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ull mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; mid) solve(l, mid, r - p) ;</span><br><span class="line">    <span class="keyword">else</span> solve(l, mid, p) ;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; mid) ans[++ cnt] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">else</span> ans[++ cnt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-括号树"><a href="#B-括号树" class="headerlink" title="B 括号树"></a>B 括号树</h2><p>啊这，挺水的吧。记着考场上是飞快的想出了 $O(n^2)$ 的做法，想了想可以线性，写了一会儿之后发现不会给 <code>devc++</code> 开栈…就十分尴尬…然后发现如果是一条链的话是有快速写法的，就写了个等价的链做法过了大样例…然后改来改去就拍上了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mt = <span class="number">0</span> ; fa[u] = ff ;</span><br><span class="line">    <span class="keyword">if</span> (base[u] == <span class="string">'('</span>) stk[++ ctn] = u ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (ctn)&#123;</span><br><span class="line">            mt = stk[ctn --] ;</span><br><span class="line">            g[u] = g[fa[mt]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    f[u] = f[ff] + g[u] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != ff) dfs(to(k), u) ;</span><br><span class="line">    <span class="keyword">if</span> (base[u] == <span class="string">'('</span>) stk[ctn --] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mt) stk[++ ctn] = mt ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-树上的数"><a href="#C-树上的数" class="headerlink" title="C 树上的数"></a>C 树上的数</h2><blockquote><p>给定一个大小为 $n$ 的树，它共有 $n$ 个结点与 $n − 1$ 条边，结点从 $1 \sim n$ 编号。初始时每个结点上都有一个 $1 \sim n$ 的数字，且每个 $1 \sim n$ 的数字都只在<strong>恰好</strong>一个结点上出现。</p><p>接下来你需要进行<strong>恰好</strong> $n − 1$ 次删边操作，每次操作你需要选一条<strong>未被删去</strong>的边，此时这条边所连接的两个结点上的数字将会<strong>交换</strong>，然后这条边将被删去。</p><p>$n − 1$ 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 $1 \sim n$ 所在的结点编号依次排列，就得到一个结点编号的排列 $P_i$。现在请你求出，在最优操作方案下能得到的<strong>字典序最小</strong>的 $P_i$。</p><p>$1\leq n\leq 2\times 10^3$ 。</p></blockquote><p>咕咕咕。</p><p>这种题必然是要自己想的吧。那可能要多想几天。就暂时咕咕咕了。</p><h2 id="D-Emiya-家今天的饭"><a href="#D-Emiya-家今天的饭" class="headerlink" title="D Emiya 家今天的饭"></a>D Emiya 家今天的饭</h2><blockquote><p>给定一个矩阵，每个元素有一个固定的选择方案数 $a_{i,j}$，每一行至多选一个元素，每一列选的元素至多是选择元素总个数的一半，求总方案数。</p><p>$1 \le n \le 100$，$1 \le m \le 2000$，$0 \le a_{i,j} &lt; 998,244,353$ 。</p></blockquote><p>首先对于 $64$ 分 $2\leq m\leq 3$，可以直接暴力记一下每一行选了多少个元素，转移比较 trivial，但是有细节…就是转移的时候不要瞎 jb 判，最后统计答案的时候再判——感觉是个很浅显的结论我竟然调了 $10min+$ ！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][S][S][S] ;</span><br><span class="line"><span class="keyword">int</span> pd[<span class="number">2</span>][S][S][S][S] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;<span class="comment">//m=2</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span> ;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[d])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)&#123;</span><br><span class="line">                add(dp[d][j][k][j - k], dp[d ^ <span class="number">1</span>][j][k][j - k]) ;</span><br><span class="line">                <span class="keyword">if</span> (k)</span><br><span class="line">                    add(dp[d][j][k][j - k], <span class="number">1l</span>l * dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>][j - k] * base[i][<span class="number">1</span>] % P) ;</span><br><span class="line">                <span class="keyword">if</span> (j - k)</span><br><span class="line">                    add(dp[d][j][k][j - k], <span class="number">1l</span>l * dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k][j - k - <span class="number">1</span>] * base[i][<span class="number">2</span>] % P) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ((j &lt;= i / <span class="number">2</span>) &amp;&amp; (i - j &lt;= i / <span class="number">2</span>))</span><br><span class="line">                add(ans, dp[n &amp; <span class="number">1</span>][i][j][i - j]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;<span class="comment">//m=3</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span> ;</span><br><span class="line">    pd[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(pd[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(pd[d])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)&#123; <span class="comment">// (j-k)+o+(k-o)=j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= k ; ++ o)&#123;</span><br><span class="line">                    add(pd[d][j][j - k][o][k - o], pd[d ^ <span class="number">1</span>][j][j - k][o][k - o]) ;</span><br><span class="line">                    <span class="keyword">if</span> (j - k)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k - <span class="number">1</span>][o][k - o] * base[i][<span class="number">1</span>] % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (o)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k][o - <span class="number">1</span>][k - o] * base[i][<span class="number">2</span>] % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (k - o)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k][o][k - o - <span class="number">1</span>] * base[i][<span class="number">3</span>] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> ((k &lt;= i / <span class="number">2</span>) &amp;&amp; ((j - k) &lt;= i / <span class="number">2</span>) &amp;&amp; ((i - j) &lt;= i / <span class="number">2</span>))</span><br><span class="line">                    add(ans, pd[n &amp; <span class="number">1</span>][i][k][j - k][i - j]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑更高分做法，大概就是要想到<strong>容斥</strong>。考虑将问题转化成「总方案数-存在某一行 $&gt;\lfloor\frac{k}{2}\rfloor$ 的方案数」，那么发现后面一项，对于某种方案，至多存在一列 $&gt;\lfloor\frac{k}{2}\rfloor$。 所以容斥系数大概就是 $1~0~0\cdots$。那么如果设 $s_i=\sum_{j=1}^m a_{i,j}$ ，可以知道总方案数是 $\prod (s_i+1)-1$。考虑单独一行怎么算，发现只需要记一下总共选了多少个/当前行选了多少个即可。复杂度 $O(n^3m)$，可以获得 $84$ 分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d ; ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            sum[i][j] = addn(sum[i][j - <span class="number">1</span>], base[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * sum[i][m] % P ; dec(ans, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">        d = <span class="number">0</span> ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            d ^= <span class="number">1</span> ; <span class="keyword">int</span> ts ;</span><br><span class="line">            ts = sum[i][m] - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n ; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= n ; ++ o)&#123;</span><br><span class="line">                    f[d][k][o] = f[d ^ <span class="number">1</span>][k][o] ;</span><br><span class="line">                    <span class="keyword">if</span> (k) add(f[d][k][o], <span class="number">1l</span>l * f[d ^ <span class="number">1</span>][k - <span class="number">1</span>][o] * (ts - base[i][j]) % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (k &amp;&amp; o) add(f[d][k][o], <span class="number">1l</span>l * f[d ^ <span class="number">1</span>][k - <span class="number">1</span>][o - <span class="number">1</span>] * base[i][j] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (j - k &lt; k) dec(ans, f[n &amp; <span class="number">1</span>][j][k]) ;</span><br><span class="line">        <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[<span class="number">0</span>])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后发现…本质上也同样不需要第二维。因为在钦定了某一列是最多的之后，就不再需要关心次序，只需要关心是否比其它列的总和要多就好了。所以可以维护这个差分值，相当于将状态合并了。于是最后复杂度 $O(n^2m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d ; ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            sum[i][j] = addn(sum[i][j - <span class="number">1</span>], base[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * sum[i][m] % P ; dec(ans, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">        d = <span class="number">0</span> ; g[<span class="number">0</span>][n] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            d ^= <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> ts = sum[i][m] - <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">memset</span>(g[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(g[<span class="number">0</span>])) ; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n + n ; ++ k)&#123; g[d][k] = g[d ^ <span class="number">1</span>][k] ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span>) add(g[d][k], <span class="number">1l</span>l * g[d ^ <span class="number">1</span>][k - <span class="number">1</span>] * base[i][j] % P) ;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; n + n) add(g[d][k], <span class="number">1l</span>l * g[d ^ <span class="number">1</span>][k + <span class="number">1</span>] * decn(ts, base[i][j]) % P) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j) dec(ans, g[n &amp; <span class="number">1</span>][n + j]) ;<span class="comment">// , cout &lt;&lt; g[n &amp; 1][n + j] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">memset</span>(g[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(g[<span class="number">0</span>])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>于是我就把全部的 subtask 都写了，加起来120行左右。</del></p><h2 id="E-划分"><a href="#E-划分" class="headerlink" title="E 划分"></a>E 划分</h2><blockquote><p>给定一个长为 $n$ 的序列 $\{a_n\}$ 。需要找到一些分界点 $1 \le k_1 &lt; k_2 &lt; \cdots &lt; k_p &lt; n$，使得：</p><script type="math/tex; mode=display">\sum_{i=1}^{k_1} a_i\le \sum_{i=k_1+1}^{k_2} a_i \le \dots \le \sum_{i=k_p+1}^n a_i</script><p>同时最小化</p><script type="math/tex; mode=display">\left(\sum_{i=1}^{k_1} a_i \right)^2+\left(\sum_{i=k_1+1}^{k_2} a_i \right)^2+\cdots +\left(\sum_{i=k_p+1}^n a_i \right)^2</script><p>$2 \le n \le 4 \times 10^7 , 1 \le a_i \le 10^9$。</p></blockquote><p>大概一个比较 trivial 的想法是记 $f_{i,v}$ 表示前 $i$ 个数分了某些段，最后一段大小为 $v$ 的 ans。这样大概是可以拿个 $24pts$？然后再高的话就是考虑 $v$ 必然只会是连续一段，所以可以设 $f_{i,j}$ 表示前 $i$ 个数分了某些段，最后一段是 $j\sim i$ 的 ans。然后这样似乎就是 $O(n^3)$ 可以拿到 $40pts$。然后发现有神秘的单调性，大概就是发现最后要最优化的是和的平方，那么肯定是段数越多越优。那么对于每一个 $i$ 的那个使得 $j\sim i$ 最优的决策一定也会让 $len=i-j+1$ 最小。这样就可以存一下每个 $i$ 的最优决策点 $minx_i$ ，就可以实现 $O(n)$ 转移了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr(), s[i] = s[i - <span class="number">1</span>] + base[i] ;  </span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">600</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(dp)), ans = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">LL t = (s[i] - s[i - j]) * (s[i] - s[i - j]) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= (i - j) ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (s[i] - s[i - j] &gt;= s[i - j] - s[i - j - k])</span><br><span class="line">dp[i][j] = minn(dp[i][j], dp[i - j][k] + t) ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ans = min(ans, dp[N][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(minx, <span class="number">127</span>, <span class="keyword">sizeof</span>(minx)), minx[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line"><span class="keyword">if</span> (s[i] - s[j] &gt;= minx[j])</span><br><span class="line">minx[i] = min(s[i] - s[j], minx[i]), </span><br><span class="line">f[i] = min(f[i], f[j] + (s[i] - s[j]) * (s[i] - s[j])) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这个单调性似乎可以很强的样子？大概就是发现对于每个 $i$ ，本质上只关心他最小的那一段合法后缀是多少。于是就可以拿一个单调队列来优化了。</p><p>注意单调队列插入队尾时注意转移式的变形。感性来说为了找到最小的那个合法区间，就需要按照 $s_i-s_k\geq m(k)$ ，其中 $i$ 是将来的决策，那么就需要按照 $s_k+m(k)$ 来衡量决策。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">(L128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    out_put(x / <span class="number">10</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (LL)(x % <span class="number">10</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, T ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> q[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> pre[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> base[MAXP] ;</span><br><span class="line"></span><br><span class="line">L128 ans ;</span><br><span class="line">LL s[MAXN] ;</span><br><span class="line">LL minx[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; <span class="number">30</span> ;</span><br><span class="line">LL p, l, r, b, p0 = <span class="number">1</span> ;</span><br><span class="line">LL x, y, z, b1, b2, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    x = qr(), y = qr(), z = qr() ;</span><br><span class="line">    b1 = qr(), b2 = qr(), m = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        p = qr(), l = qr(), r = qr() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = p0 ; j &lt;= p ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) b = b1 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">2</span>) b = b2 ;</span><br><span class="line">            <span class="keyword">else</span> b = (x * b2 + y * b1 + z) % M, b1 = b2, b2 = b ;</span><br><span class="line">            s[j] = s[j - <span class="number">1</span>] + (b % (r - l + <span class="number">1</span>) + l) ;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        p0 = p + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k ; h = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!T)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            base[i] = qr(), s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> gene() ; j = <span class="number">0</span> ;</span><br><span class="line">    q[++ t] = <span class="number">0</span> ; minx[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t &amp;&amp; s[i] - s[q[h]] &gt;= minx[q[h]])</span><br><span class="line">            j = q[h ++] ; minx[i] = s[i] - s[j] ; pre[i] = j ; </span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t &amp;&amp; minx[q[t]] + s[q[t]] &gt;= minx[i] + s[i]) q[t --] = <span class="number">0</span> ; q[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span> (N)</span><br><span class="line">ans += (L128)minx[N] * minx[N], N = pre[N] ;</span><br><span class="line">    out_put(ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说回来，去年赛场上我甚至没有把数据生成的规则看完…因为并没有时间，也并没有能力(?)去看最后一档部分分。大概是圆了一个未竟的梦吧。</p><h2 id="F-树的重心"><a href="#F-树的重心" class="headerlink" title="F 树的重心"></a>F 树的重心</h2><blockquote><p>小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：</p><ol><li>一个大小为 $n$ 的树由 $n$ 个结点与 $n − 1$ 条无向边构成，且满足任意两个结点间<strong>有且仅有</strong>一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为<strong>恰好</strong>两个子树。</li><li>对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的<strong>重心</strong>当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均<strong>不超过</strong> $\lfloor \frac{n}{2} \rfloor$（其中 $\lfloor x \rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 $1$ 或 $2$ 个。</li></ol><p>课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：</p><script type="math/tex; mode=display">\sum_{(u,v)\in E}\left(\sum_{x\in c(S'_u)} x+\sum_{y\in c(S'_v)} y\right)</script><p>上式中，$E$ 表示树 $S$ 的边集，$(u, v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S’_u$ 与 $S’_v$ 分别表示树 $S$ 删去边 $(u, v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树，$c(S)$ 表示树 $S$ 重心的集合。</p><p>$1\leq n\leq 3\times 10^5$ 。</p></blockquote><h3 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>首先考虑部分分做法？$40pts$ 就是暴力枚举切哪一条边。$55pts$ 的链在瞎映射一通可以 $O(1)$ 求出割完之后两棵树的重心分别是谁。$75pts$ 的满二叉树大概是要先找出 $\deg_x=2$ 的 $x$ ，不难知道这个一定是根，找一波规律可以发现割掉每一条边之后，较小的那一半的重心必然是这个小连通块的根，较大的那部分的重心是对面的另一个儿子，也可能是原树的根。算一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> max_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>], p[<span class="number">5</span>], bg, rt ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, f[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, sz[N], e[N &lt;&lt; <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> dfs1(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa) chkmax(mx, sz[to(k)]), dfs(to(k), u) ;</span><br><span class="line">chkmax(mx, sz[rt] - sz[u]) ; f[u] = mx ;</span><br><span class="line"><span class="keyword">if</span> (f[q[<span class="number">1</span>]] &gt; f[u]) q[<span class="number">1</span>] = u ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[q[<span class="number">2</span>]] &gt; f[u]) q[<span class="number">2</span>] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; max_dep)</span><br><span class="line">        max_dep = dep[x], rt = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs2(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ; rev[dep[x]] = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) redfs(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs3(to(k), x), ans += to(k) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("centroid12.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n, cnt = ans = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k),</span><br><span class="line">add(j, k), e[i][<span class="number">0</span>] = j, e[i][<span class="number">1</span>] = k ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span>,</span><br><span class="line">dfs1(rt = e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">dfs(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">ans += (f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (q[<span class="number">1</span>] + q[<span class="number">2</span>]) : q[<span class="number">1</span>] ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">dfs1(rt = e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">                dfs(e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">ans += (f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (q[<span class="number">1</span>] + q[<span class="number">2</span>]) : q[<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">49991</span>)&#123;</span><br><span class="line">            max_dep = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k), add(j, k) ;</span><br><span class="line">            dfs2(<span class="number">1</span>, <span class="number">0</span>) ; redfs(rt, dep[<span class="number">0</span>] = <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans += rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i / <span class="number">2</span>] + rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">if</span> ((n - i) &amp; <span class="number">1</span>) ans += rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i + (n - i) / <span class="number">2</span>] + rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">262143</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i) deg[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k) ;</span><br><span class="line">                add(j, k), ++ deg[j], ++ deg[k] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (deg[i] == <span class="number">2</span>) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">            dfs3(rt, <span class="number">0</span>) ; ans += <span class="number">1l</span>l * rt * (n / <span class="number">2l</span>l + <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = next(k))</span><br><span class="line">                ans += <span class="number">1l</span>l * to(k) * (n - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑满分怎么做。以下设 $x$ 为当前点，$y_k$ 为 $x$ 的第 $k$ 个孩子(顺序随便定的)，$z$ 为 $x$ 的重儿子，设 $s$ 为割下来的连通块大小。 </p><p>这个满分做法，我自己推的比较烦，不如其他人简洁。大概就是计算每个点当重心的次数。然后我分成了三部分算。对于一个点 $x$ ，他可能成为重心，当且仅当：</p><h4 id="Case-1-它子树内的某个子树被割了，它成为了重心"><a href="#Case-1-它子树内的某个子树被割了，它成为了重心" class="headerlink" title="Case 1 它子树内的某个子树被割了，它成为了重心"></a>Case 1 它子树内的某个子树被割了，它成为了重心</h4><p>考虑此时这个小子树的子树大小需要满足什么条件。首先由于要分子树讨论，不妨设从 $y_k$ 中割掉了一棵小子树。那么考虑要满足这么几个限制：</p><script type="math/tex; mode=display">\begin{aligned}size_{y_k}-s&\leq \lfloor \frac{n-s}{2}\rfloor\\n-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\g_y&\leq  \lfloor \frac{n-s}{2}\rfloor\end{aligned}</script><p>其中 $g_y$ 为除去子树 $y$ 后剩下的子树最大值。因为根据定义本质上并不关心那些较小的子树。</p><p>于是这部分就可以分子树查。发现本质上转化成了在 $dfs$ 序上求「区间 $[l,r]$ 内值域在 $[a,b]$ 内的数有多少」，可以直接上主席树。然后这部分就做完了。</p><h4 id="Case-2-它子树外的某个子树被割了，它成为了重心"><a href="#Case-2-它子树外的某个子树被割了，它成为了重心" class="headerlink" title="Case 2 它子树外的某个子树被割了，它成为了重心"></a>Case 2 它子树外的某个子树被割了，它成为了重心</h4><p>此时还是不变，但是约束变为了</p><script type="math/tex; mode=display">\begin{aligned}n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\z&\leq \lfloor \frac{n-s}{2}\rfloor\\\end{aligned}</script><p>这部分也是可以直接主席树来求。但是注意解出来的 $[l,r]$ 内可能会包含从 $x$ 到根路径上点(祖先)的子树信息，可以对进退栈顺序开一棵线段树来容斥掉这一部分。</p><h4 id="Case-3-它子树外某个不是子树的连通块被割了，它成为了重心"><a href="#Case-3-它子树外某个不是子树的连通块被割了，它成为了重心" class="headerlink" title="Case 3 它子树外某个不是子树的连通块被割了，它成为了重心"></a>Case 3 它子树外某个不是子树的连通块被割了，它成为了重心</h4><p>考虑此时割掉的一定是 $x$ 到根路径上的一条边。发现本质上依旧是</p><script type="math/tex; mode=display">\begin{aligned}n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\z&\leq \lfloor \frac{n-s}{2}\rfloor\\\end{aligned}</script><p>于是还是维护一棵退栈顺序的线段树来维护这个。</p><p>然后以上的线段树可以换成树状数组。于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (  ; p &lt;= n ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">return</span> ask(r) - ask(l - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]), s ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]], k, y, g ;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)&#123;<span class="comment">//Case 2</span></span><br><span class="line">        res[x] += query(_rt[<span class="number">0</span>], _rt[dfn[x] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] += query(_rt[dfn[x] + sz[x] - <span class="number">1</span>], _rt[n], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] -= qry(l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">0</span> ; s = edg[x].size() ; suf[s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; pre[k] = pre[max(<span class="number">0</span>, k - <span class="number">1</span>)] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        pre[k] = max(pre[max(k - <span class="number">1</span>, <span class="number">0</span>)], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = s - <span class="number">1</span> ; ~k ; -- k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; suf[k] = suf[k + <span class="number">1</span>] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        suf[k] = max(suf[k + <span class="number">1</span>], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123; <span class="comment">//Case 1</span></span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        g = max(n - sz[x], suf[k + <span class="number">1</span>]) ;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) g = max(pre[k - <span class="number">1</span>], g) ;</span><br><span class="line">        l = max(<span class="number">1</span>, <span class="number">2</span> * sz[y] - n), r = n - <span class="number">2</span> * g ;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">            res[x] += query(_rt[dfn[y] - <span class="number">1</span>], _rt[dfn[y] + sz[y] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    mdf(sz[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])</span><br><span class="line">        <span class="keyword">if</span> (k != fa) dfs5(k, x) ;</span><br><span class="line">    mdf(sz[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> qwq)</span></span>&#123;<span class="comment">//Case 3</span></span><br><span class="line">    <span class="keyword">int</span> t = sz[x] + qwq ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]] ;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]) ;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">        res[x] += qry(l, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">1</span>) ;</span><br><span class="line">        dfs6(k, x, t - sz[k]) ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("centroid.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"> qr(T) ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">qr(n), ans = tot = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            edg[i].clear(), mson[i] = res[i] = _bit[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">            qr(j), qr(k), edg[j].p_b(k), edg[k].p_b(j) ;</span><br><span class="line">        dfs4(<span class="number">1</span>, Id = <span class="number">0</span>) ; build(_rt[<span class="number">0</span>], <span class="number">1</span>, n) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            upd(_rt[i], _rt[i - <span class="number">1</span>], <span class="number">1</span>, n, sz[rev[i]]) ;</span><br><span class="line">        dfs5(<span class="number">1</span>, <span class="number">0</span>) ; fill(_bit + <span class="number">1</span>, _bit + n + <span class="number">1</span>, <span class="number">0</span>) ; dfs6(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) ans += <span class="number">1l</span>l * res[i] * i ; qw(ans, <span class="string">'\n'</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就做完了。复杂度是 $O(n\log n)$，但就是常数巨大…不知道为什么…感觉应该挺快才对啊（</p><h3 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>草，了解完倍增做法后发现上面的主席树是真的真的无脑。</p><p>大概就是考虑一个<del>我没发现的</del>性质，发现对于每个点 $u$，每次重心要么是 $u$，要么就是 $u$ 的父亲以外，要么就只会是 $u$ 子树内某个点的重儿子。所以就可以倍增预处理处每个点开始 $2^i$ 个重儿子是谁。然后考虑断 $(x,y)$ 这条边之后，$y$ 就可以通过倍增的方式找到深度最大的那个重心，然后判断一下它的父亲即可；$x$ 还需要合并父亲的重心，算点边界之类的，也不是很难。</p><p>最后放一下主席树的代码，用的 <code>ouuan</code> 的 IO。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXP 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(T &amp;x, T y)</span></span>&#123; x = x &gt; y ? y : x ; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span></span>&#123; x = x &lt; y ? y : x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> max_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> mson[N] ;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>], p[<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">int</span> bg, rt, Id ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, f[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, sz[N], e[N &lt;&lt; <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE (1 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isdigit(x) (x &gt;= <span class="meta-string">'0'</span> &amp;&amp; x &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="keyword">char</span> pbuf[MAXSIZE], *pp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  IO() : p1(buf), p2(buf), pp(pbuf) &#123;&#125;</span><br><span class="line">  ~IO() &#123; fwrite(pbuf, <span class="number">1</span>, pp - pbuf, <span class="built_in">stdout</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="string">' '</span> : *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">' '</span> || ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span> || ch == <span class="string">'\t'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">bool</span> sign = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = gc();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = gc())</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">'-'</span>) sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = gc()) x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'.'</span>)</span><br><span class="line">      <span class="keyword">for</span> (ch = gc(); <span class="built_in">isdigit</span>(ch); ch = gc())</span><br><span class="line">        tmp /= <span class="number">10.0</span>, x += tmp * (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = gc();</span><br><span class="line">    <span class="keyword">for</span> (; blank(ch); ch = gc())</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">for</span> (; !blank(ch); ch = gc()) *s++ = ch;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (c = gc(); blank(c); c = gc())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (pp - pbuf == MAXSIZE) fwrite(pbuf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdout</span>), pp = pbuf;</span><br><span class="line">    *pp++ = c;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">write</span>(<span class="title">T</span> <span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, push(<span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">static</span> T sta[<span class="number">35</span>];</span><br><span class="line">    T top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">while</span> (top) push(sta[--top] + <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">write</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">char</span> <span class="title">lastChar</span>) &#123;</span></span><br><span class="line">    write(x), push(lastChar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> dfs1(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa) chkmax(mx, sz[to(k)]), dfs(to(k), u) ;</span><br><span class="line">chkmax(mx, sz[rt] - sz[u]) ; f[u] = mx ;</span><br><span class="line"><span class="keyword">if</span> (f[q[<span class="number">1</span>]] &gt; f[u]) q[<span class="number">1</span>] = u ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[q[<span class="number">2</span>]] &gt; f[u]) q[<span class="number">2</span>] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; max_dep)</span><br><span class="line">        max_dep = dep[x], rt = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs2(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ; rev[dep[x]] = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) redfs(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs3(to(k), x), ans += to(k) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> sum[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _rt[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _lc[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _rc[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; edg[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    rev[dfn[x] = ++ Id] = x ;</span><br><span class="line">    dep[x] = dep[fa] + (sz[x] = <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != fa)&#123;</span><br><span class="line">            dfs4(k, x) ; sz[x] += sz[k] ;</span><br><span class="line">            <span class="keyword">if</span> (sz[k] &gt; sz[mson[x]] || !mson[x]) mson[x] = k ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    sum[rt = ++ tot] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(_lc[rt], l, mid) ;</span><br><span class="line">    build(_rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> lst, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    rt = ++ tot ;</span><br><span class="line">    _lc[rt] = _lc[lst] ;</span><br><span class="line">    _rc[rt] = _rc[lst] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(sum[rt] = sum[lst] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">         upd(_lc[rt], _lc[lst], l, mid, p) ;</span><br><span class="line">    <span class="keyword">else</span> upd(_rc[rt], _rc[lst], mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">    sum[rt] = sum[_lc[rt]] + sum[_rc[rt]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[v] - sum[u] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(_lc[u], _lc[v], l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(_rc[u], _rc[v], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> suf[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (  ; p &lt;= n ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ask(r) - ask(l - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int seg[N * 3] ;</span></span><br><span class="line"><span class="comment">void _up(int rt)&#123;</span></span><br><span class="line"><span class="comment">    seg[rt] = seg[rt &lt;&lt; 1] + seg[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void mdf(int rt, int l, int r, int pos, int v)&#123;</span></span><br><span class="line"><span class="comment">    if (l == r)&#123; seg[rt] += v ; return ; &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">    if (pos &lt;= mid) mdf(rt &lt;&lt; 1, l, mid, pos, v) ;</span></span><br><span class="line"><span class="comment">    else mdf(rt &lt;&lt; 1 | 1, mid + 1, r, pos, v) ; _up(rt) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int qry(int rt, int l, int r, int ql, int qr)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, res = 0 ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[rt] ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= mid) res += qry(rt &lt;&lt; 1, l, mid, ql, qr) ;</span></span><br><span class="line"><span class="comment">    if (qr &gt; mid) res += qry(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr) ;</span></span><br><span class="line"><span class="comment">    return res ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//int g[3] = &#123;0, 0, 0&#125; ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= 5 ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " " ;</span></span><br><span class="line"><span class="comment">    &#125;puts("") ;*/</span></span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]), s ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]], k, y, g ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " \n" ;</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l &amp;&amp; l &gt; <span class="number">0</span> &amp;&amp; r &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; dfn[x] &lt;&lt; " \n" ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; query(_rt[dfn[x] + sz[x] - 1], _rt[n], 1, n, l, r) &lt;&lt; "#\n" ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; query(_rt[0], _rt[dfn[x] - 1], 1, n, l, r) &lt;&lt; "#\n" ;</span></span><br><span class="line">        res[x] += query(_rt[<span class="number">0</span>], _rt[dfn[x] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] += query(_rt[dfn[x] + sz[x] - <span class="number">1</span>], _rt[n], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] -= qry(l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; " !!!" &lt;&lt; x &lt;&lt; "!!! " &lt;&lt; res[x] &lt;&lt; '\n' ;</span></span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">0</span> ; s = edg[x].size() ; suf[s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; pre[k] = pre[max(<span class="number">0</span>, k - <span class="number">1</span>)] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        pre[k] = max(pre[max(k - <span class="number">1</span>, <span class="number">0</span>)], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = s - <span class="number">1</span> ; ~k ; -- k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; suf[k] = suf[k + <span class="number">1</span>] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        suf[k] = max(suf[k + <span class="number">1</span>], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        g = max(n - sz[x], suf[k + <span class="number">1</span>]) ;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) g = max(pre[k - <span class="number">1</span>], g) ;</span><br><span class="line">        <span class="keyword">int</span> l = max(<span class="number">1</span>, <span class="number">2</span> * sz[y] - n), r = n - <span class="number">2</span> * g ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; g &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">            res[x] += query(_rt[dfn[y] - <span class="number">1</span>], _rt[dfn[y] + sz[y] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (k = 0 ; k &lt; s ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">        y = edg[x][k] ;</span></span><br><span class="line"><span class="comment">        if (y == fa || y != mson[x]) continue ;</span></span><br><span class="line"><span class="comment">        g[2] = suf[k + 1] ; if (k) g[2] = max(pre[k - 1], g[2]) ; break ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    g[0] = sz[mson[x]] ; g[1] = n - sz[x] ;</span></span><br><span class="line"><span class="comment">    sort(g, g + 3) ;</span></span><br><span class="line"><span class="comment">    l = max(1, 2 * g[2] - n) ;</span></span><br><span class="line"><span class="comment">    r = min(n - g[1] * 2, 2 * sz[x] - n) ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; g[2] &lt;&lt; " " &lt;&lt; g[1] &lt;&lt; " " &lt;&lt; g[0] &lt;&lt; " $%$ \n" ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; res[x] &lt;&lt; "*&amp;*\n" ;</span></span><br><span class="line"><span class="comment">    if (l &lt;= r)</span></span><br><span class="line"><span class="comment">        res[x] += query(_rt[dfn[x]], _rt[dfn[x] + sz[x] - 1], 1, n, l, r) ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; res[x] &lt;&lt; '\n' ;*/</span></span><br><span class="line">    mdf(sz[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x]) <span class="keyword">if</span> (k != fa) dfs5(k, x) ;</span><br><span class="line">    mdf(sz[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; qwq &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">int</span> t = sz[x] + qwq ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]] ;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " &amp;\n" ;</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">        res[x] += qry(l, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">1</span>) ;</span><br><span class="line">        dfs6(k, x, t - sz[k]) ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("centroid12.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"></span><br><span class="line"> io.read(T) ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">io.read(n), cnt = ans = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                io.read(j), io.read(k),</span><br><span class="line">add(j, k), e[i][<span class="number">0</span>] = j, e[i][<span class="number">1</span>] = k ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) res[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span>,</span><br><span class="line">dfs1(rt = e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">dfs(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">(f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (res[q[<span class="number">1</span>]]++, res[q[<span class="number">2</span>]] ++) : res[q[<span class="number">1</span>]] ++ ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">dfs1(rt = e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">                dfs(e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">(f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (res[q[<span class="number">1</span>]]++, res[q[<span class="number">2</span>]] ++) : res[q[<span class="number">1</span>]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                ans += <span class="number">1l</span>l * res[i] * i ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">49991</span>)&#123;</span><br><span class="line">            max_dep = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                io.read(j), io.read(k), add(j, k) ;</span><br><span class="line">            dfs2(<span class="number">1</span>, <span class="number">0</span>) ; redfs(rt, dep[<span class="number">0</span>] = <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans += rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i / <span class="number">2</span>] + rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">if</span> ((n - i) &amp; <span class="number">1</span>) ans += rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i + (n - i) / <span class="number">2</span>] + rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">262143</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i) deg[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                io.read(j), io.read(k) ;</span><br><span class="line">                add(j, k), ++ deg[j], ++ deg[k] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (deg[i] == <span class="number">2</span>) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">            dfs3(rt, <span class="number">0</span>) ; ans += <span class="number">1l</span>l * rt * (n / <span class="number">2l</span>l + <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = next(k))</span><br><span class="line">                ans += <span class="number">1l</span>l * to(k) * (n - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Id = <span class="number">0</span> ; tot = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">memset</span>(_rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(_rt)) ;</span><br><span class="line">            <span class="built_in">memset</span>(_bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(_bit)) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                edg[i].clear(), mson[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                io.read(j), io.read(k) ;</span><br><span class="line">                edg[j].p_b(k), edg[k].p_b(j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs4(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            build(_rt[<span class="number">0</span>], <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                upd(_rt[i], _rt[i - <span class="number">1</span>], <span class="number">1</span>, n, sz[rev[i]]) ;</span><br><span class="line">            dfs5(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="built_in">memset</span>(_bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(_bit)) ;</span><br><span class="line">            dfs6(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                ans += <span class="number">1l</span>l * res[i] * i ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是重做了一下 NOIP2018/CSP2019 两年的全部题目？&lt;/p&gt;
&lt;p&gt;感觉当时场上没 A 掉的题，放到现在做总是感觉有点心理阴影emm&lt;/p&gt;
&lt;p&gt;Anyway, 只用真正告别过去才能走向未来。你说，对吧？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="树上技巧/dfs序+树状数组" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="技巧/倍增" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%80%8D%E5%A2%9E/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构/可持久化/可持久化线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="动态规划/链分治维护dp" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%93%BE%E5%88%86%E6%B2%BB%E7%BB%B4%E6%8A%A4dp/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】一般图最大匹配(带花树)</title>
    <link href="https://www.orchidany.cn/2020/05/11/%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/05/11/带花树/</id>
    <published>2020-05-11T00:48:43.000Z</published>
    <updated>2020-05-12T02:43:04.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学了一发带花树，感觉很高妙。</p><p>然后顺便复习了一下二分图匹配and学了一下随机匹配。</p><p>🌼🌲：Blossom Tree.</p><a id="more"></a><h1 id="从匹配到二分图匹配"><a href="#从匹配到二分图匹配" class="headerlink" title="从匹配到二分图匹配"></a>从匹配到二分图匹配</h1><h2 id="从匹配到增广路"><a href="#从匹配到增广路" class="headerlink" title="从匹配到增广路"></a>从匹配到增广路</h2><blockquote><p>给定一张图 $G=\{\mathrm{V,E}\}$ ，一组两两没有交点的边集 $\rm M\subseteq E$ 称之为 $G$ 的一组<strong>匹配</strong>。边数最多的匹配称之为 $G$ 的<strong>最大匹配</strong>。其中 $\forall (u,v)\in \mathrm{M}$ 称之为<strong>匹配边</strong>，否则称为<strong>非匹配边</strong>。</p><p>称一个点在匹配中当且仅当它是某跳匹配边的端点。称匹配中的点为<strong>匹配点</strong>，不在匹配中的点为<strong>未盖点</strong> 。与某个匹配点共匹配边的另一个端点称之为该点的<strong>配偶</strong> 。</p></blockquote><p>嗯，定义朗诵完了…然后大概就是考虑怎么找匹配。大概就是增广路算法。定义<strong>增广路</strong>是这样的一种图上的路径：</p><blockquote><p>1、路径的起点和终点均为未盖点。</p><p>2、路径上匹配边、未匹配边交替出现。</p></blockquote><p>据此可以知道</p><blockquote><p>1、一条增广路必然只会有奇数条边。</p><p>2、增广路上非匹配边比匹配边多 $1$ 。</p><p>3、如果将所有边的状态取反，那么匹配数 $+1$ 。</p></blockquote><p>于是有定理</p><blockquote><p>如果一个匹配 $\mathrm{M}$ 是图 $G$ 的最大匹配，当且仅当 $G’=\rm \{V,E\setminus M\}$ 中不存在增广路。</p></blockquote><p>这…必要性还是比较显然的吧。充分性的话，鸽了鸽了。</p><p>于是考虑如果要求解一张图里的最大匹配，可以通过不断找增广路的方式来进行。</p><h2 id="从增广路到二分图匹配"><a href="#从增广路到二分图匹配" class="headerlink" title="从增广路到二分图匹配"></a>从增广路到二分图匹配</h2><p>二分图最重要的一个特征：没有奇环。</p><p>考虑这样为什么能简化找匹配的过程呢？发现本质上每次找增广路，就是在找一条长度为奇数的路径。那么考虑这样一个做法：</p><blockquote><p>遍历每个当前的未盖点 $u$ ：</p><p>1、如果 $\exists (u,v)$ 使得 $v$ 也是未盖点，那么可以直接让 $v$ 匹配上，匹配数 $+1$ 。</p><p>2、如果对于某个匹配点 $v$ 的配偶 $p$ ，可以找到除了 $v$ 之外的另一个配偶 $q$ ，那么就让 $p$ 和 $q$ 配对、$u$ 和 $v$ 配对。总匹配数 $+1$ 。</p></blockquote><p>看上去十分合理？这样就可以保证每次找到的都会是一条极长的增广路。考虑倒着归纳来证明这个事实【此时考虑的是重匹配(即状态取反)之前】：</p><blockquote><p> 1、如果对于 $u$ 找到了一个未盖点 $v$ ，那么 $(u,v)$ 是增广路。</p><p>2、如果对于某个匹配点 $v$ 的配偶 $p$ ，可以找到除了 $v$ 之外的另一个配偶 $q$ ，那么 $p,q$ 之间的路径一定是增广路，边 $(u,v)$ 之间一定也是增广路。同时又因为边 $(v,p)$ 为匹配边，所以路径 $u-v-p-q$ 一定是一条长度为奇数的增广路。</p></blockquote><p>由此可知，这样找的路一定是增广路。同时本质上这个算法就是在对每一条边进行定向，比如 $(u\to v)$ 就代表着找到了一组 $u,v$ 匹配且可能会让 $v$ 调整匹配。那么于是一般的二分图匹配算法就是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">vis [to(k)] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!used[to(k)] || path(used[to(k)]))&#123;</span><br><span class="line">used[to(k)] = u ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Ew ;</span><br><span class="line"><span class="keyword">while</span>(Ew --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), Ans += (<span class="keyword">int</span>)path(i) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果存在某个节点寻找匹配失败，那么 <code>dfs</code> 过程中访问到所有结点和边会组成一个树形态，称之为<strong>交错树</strong> 。</p><p>但是这样在一般无向图上会存在什么问题吗？考虑一个这样的环</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>一开始从 $x$ 出发找到 $y$ ，$x,y$ 均变为匹配点。之后跳过 $y$ 因为 $y$ 已经被匹配。之后来到 $z$ 。发现对于 $z$ 而言，$z$ 找 $x$ ，$x$ 找配偶 $y$，$y$ 发现自己的临边中 $z$ 还没被匹配，于是就匹配 $z$ 。发现这样最后会使得 $z$ 既匹配了 $x$ 又匹配了 $y$ 。原因是什么？发现原因在于这是一个奇环。奇环是会存在对于一条边的两个临边在黑白染色之后呈同色，这不符合匹配的定义。</p><p>于是…匈牙利就挂在了一般图上。</p><h1 id="从二分图匹配到带花树"><a href="#从二分图匹配到带花树" class="headerlink" title="从二分图匹配到带花树"></a>从二分图匹配到带花树</h1><p>考虑二分图匹配直接移植的问题就在于奇环。那么考虑如何消除奇环的贡献。于是就要引入<strong>带花树</strong>这个算法(英: Blosssom Algorithm)。</p><p>带花树本质是考虑奇环匹配的本质，即如果让奇环自己单独匹配，会发生什么。发现一个长为 $2\cdot k+1$ 的奇环无论何时都可以贡献 $k$ 对匹配，并且余下一个未盖点。于是带花树会考虑，在处理增广路时直接把奇环缩成一个点，称之为<strong>花</strong> 。之后在缩完花的新图上继续找增广路。</p><p>然后证明的话…大概就是考虑如果原图存在增广路，那么新图也必然存在，反之亦然。具体证明咕了咕了。</p><p>…其实带花树难点就只是在实现上。考虑不去显示地缩点，而是用并查集维护每个点在哪一朵花里面。然后考虑用 bfs 的方式对当前点 $u$ 的交错树染色。考虑将点染为 $\alpha$ 类和 $\beta$ 类，那么本质上需要进行如下流程：</p><blockquote><p>-1、初始结点 $u$ 为 $\alpha$ 类。</p><p>0、当前点和当前邻居结点在同一朵花里，直接 <code>continue</code> 。</p><p>1、当前点为 $\alpha$ 类，当前邻居结点为 $\beta$ 类，直接 <code>continue</code> 。</p><p>2、当前点为 $\alpha $ 类，当前邻居结点未被染色：</p><p>考虑如果邻居结点是匹配点，那么将邻居结点的配偶加入队列，同时将邻居结点染为 $\alpha$ 类；如果邻居结点是未盖点，那么直接将从 $u$ 开始的这一段增广路取反之后，匹配数 $+1$，并将邻居结点染为 $\beta$ 类之后跳出。</p><p>3、当前点为 $\alpha$ 类，当前邻居结点也为 $\alpha$ 类：</p><p>考虑这时就找到了一个 $u,v$ 都在的奇环。考虑首先为了缩掉这个奇环，需要找到它们在<strong>交错树上的 lca</strong>。那么于此就需要记录每个点在交错树上的前驱结点(父节点) $fa_x$。 之后考虑，由于这个奇环上的每一个点都可以当做唯一被剩下的那个未盖点去与环外的点匹配，那么就需要将环上所有的 $\beta$ 类点加入队列。同时由于这个环可以自由匹配，所以环上相邻的点应该是彼此的 $fa$ 。于是这个操作就可以看作是在<strong>开花(blossom)</strong>。</p></blockquote><p>然后实现方面…似乎就这么多细节了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Blossom_Tree&#123;</span><br><span class="line">    <span class="keyword">int</span> ans ;</span><br><span class="line">    <span class="keyword">int</span> num ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> q[N] ;</span><br><span class="line">    <span class="keyword">int</span> fa[N] ;</span><br><span class="line">    <span class="keyword">int</span> dfn[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> clr[N] ;</span><br><span class="line">    <span class="keyword">int</span> match[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            fa[i] = i, match[i] = clr[i] = pre[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        ++ num ;</span><br><span class="line">        x = find(x) ;</span><br><span class="line">        y = find(y) ; <span class="keyword">int</span> z ;</span><br><span class="line">        <span class="keyword">while</span> (dfn[x] != num)&#123;</span><br><span class="line">            dfn[x] = num ;</span><br><span class="line">            z = find(pre[match[x]]) ;</span><br><span class="line">            x = z ; <span class="keyword">if</span> (y) swap(x, y) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;<span class="comment">//z=lca(x, y)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; z &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">while</span> (find(x) != z)&#123;</span><br><span class="line">            pre[x] = y ;</span><br><span class="line">            y = match[x] ;</span><br><span class="line">            fa[x] = fa[y] = z ;<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (clr[y] &gt; <span class="number">1</span>)</span><br><span class="line">                clr[y] = <span class="number">1</span>, q[++ t] = y ;</span><br><span class="line">            x = pre[match[x]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        h = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line">        q[++ t] = x ; clr[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            fa[i] = i, clr[i] = pre[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q[h ++] ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; " " &lt;&lt; h &lt;&lt; " " &lt;&lt; t &lt;&lt; " " &lt;&lt; head[x] &lt;&lt; " &amp;\n" ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">                <span class="keyword">if</span> (clr[to(k)] &gt; <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (find(x) == find(to(k))) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!clr[to(k)])&#123;</span><br><span class="line">                    clr[to(k)] = <span class="number">2</span> ;</span><br><span class="line">                    pre[to(k)] = x ;</span><br><span class="line">                    <span class="keyword">if</span> (!match[to(k)])&#123;</span><br><span class="line">                        <span class="keyword">int</span> z = to(k), y ;</span><br><span class="line">                        <span class="keyword">while</span> (z)&#123;</span><br><span class="line">                           y = match[pre[z]] ;<span class="comment">//1</span></span><br><span class="line">                           match[pre[z]] = z ;</span><br><span class="line">                           match[z] = pre[z] ; z = y ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clr[match[to(k)]] = <span class="number">1</span> ;</span><br><span class="line">                    q[++ t] = match[to(k)] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = lca(x, to(k)) ;</span><br><span class="line">                    blossom(x, to(k), z) ;</span><br><span class="line">                    blossom(to(k), x, z) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            puts("xxxx") ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            x = qr(), y = qr(), add_e(x, y), add_e(y, x) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!match[i]) ans += do_match(i) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; debug(match, <span class="number">1</span>, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Blossom_Tree ;</span><br></pre></td></tr></table></figure><p>考虑因为本质上是在 $u$ 的匹配过程中缩点，抽象出模型来就是在交错树上缩花and开花，于是这个算法被叫做「带花树🌼🌲」。</p><h1 id="从带花树到弃疗"><a href="#从带花树到弃疗" class="headerlink" title="从带花树到弃疗"></a>从带花树到弃疗</h1><p>总结一下。大概带花树的流程其实也不难写，只是正确性不是那么显然。同时注意到每次 bfs 时，一个点最多入队 $O(n)$ 次，这一点可以通过最多有 $O(n)$ 个不同的点让当前点加入花/加入队列来理解。于是复杂度总复杂度就是 $O(n^3)$ ，但事实上根本跑不满。</p><p>一般而言可以拿 $O(nm)$ 当作理论下界。关于这个理论下界有两点：</p><blockquote><p>1、实现下界比理论下界还要低不少。</p><p>2、理论上这个下界应该是比较松的，因为会存在某些点进队出队许多次，所以不能单纯地用单次 bfs 复杂度来分析。</p></blockquote><p>总之…还是 $O(\texttt{能过})$ 比较到位吧。</p><p>好玄学啊好玄学啊。</p><h1 id="从弃疗到相信随机化"><a href="#从弃疗到相信随机化" class="headerlink" title="从弃疗到相信随机化"></a>从弃疗到相信随机化</h1><p>本来想着在洛谷随便写一发，$90$ 就 $90$ <del>咱也不带怂的</del> 。</p><p>然后就…过掉了…</p><p>顺便也过掉了 uoj 的 $52$ 组数据和 $43+$ 组的 <code>Extra Task</code> 。</p><p>大概就是考虑随机匹配。随机匹配的思想就是，不找环，只找长度为奇数的增广路。这样做相当于强制断环为链，正确性难以保证。但是考虑如果多做几次，错误率就会大大下降。于是考虑多做几次这样的匹配。注意到这样做很容易被卡掉，只需要多几个奇环顺便构造一下加边顺序就可以了。所以就可以每次走的时候将边表随一下即可。</p><p>然后…用 <code>rand()</code> 很容易被卡掉，因为值域很小，而边数比 $32768$ 大得多。所以用 <code>mt19937</code> 就可以了。</p><p>值得一提的是，以下代码为了保证正确，卡了时，大概是卡了 $0.85s$ 左右。但是十分有趣的是…洛谷的数据在 $0.0005s=0.5ms$ 的卡时范围之内都能过掉…这…咱也不知道该说什么好。</p><p>upd: 随机匹配似乎是无敌了。在 <code>uoj</code> 试了一发卡时 $0.005s=5ms$ 的情况，依旧无压力过掉了所有 $hack$ 数据。</p><p>这个故事告诉我们：题是众生一般题，水是天下一样水。<del>随机匹配 txdy!!!!</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> match[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> st ;</span><br><span class="line"></span><br><span class="line">mt19937 g_f ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">now_time</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(clock() - st) / CLOCKS_PER_SEC ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> x, mt19937 g_f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    shuffle(E[x].begin(), E[x].end(), g_f) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])</span><br><span class="line">        <span class="keyword">if</span> (!match[y])</span><br><span class="line">            <span class="keyword">return</span> vis[y] = <span class="number">1</span>, match[y] = x, match[x] = y, <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> z = match[y] ;</span><br><span class="line">        <span class="keyword">if</span> (vis[z]) <span class="keyword">continue</span> ;</span><br><span class="line">        match[x] = y, match[y] = x, match[z] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (do_match(z, g_f)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        match[y] = z, match[z] = y, match[x] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    random_device seed ;</span><br><span class="line">    <span class="function">mt19937 <span class="title">g_f</span><span class="params">(seed())</span> </span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        x = qr(), y = qr(), add_e(x, y) ; st = clock() ;</span><br><span class="line">    <span class="keyword">while</span> (now_time() &lt; <span class="number">0.85</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!match[i])</span><br><span class="line">                fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>), ans += do_match(i, g_f), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> debug(match, <span class="number">1</span>, n), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现…uoj卡时卡到 $0.8ms$ 也是能过的。这大概就是看脸了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了一发带花树，感觉很高妙。&lt;/p&gt;
&lt;p&gt;然后顺便复习了一下二分图匹配and学了一下随机匹配。&lt;/p&gt;
&lt;p&gt;🌼🌲：Blossom Tree.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="带花树" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    
    
      <category term="思维题/随机化" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="图论/匹配/带花树" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【复习】概率期望做题笔记</title>
    <link href="https://www.orchidany.cn/2020/05/06/%E6%9C%9F%E6%9C%9B/"/>
    <id>https://www.orchidany.cn/2020/05/06/期望/</id>
    <published>2020-05-06T09:26:20.000Z</published>
    <updated>2020-05-09T07:24:42.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>胡做八做了一点简单的期望题，算是练练手感吧。</p><p>一共是 $15$ 道题。</p><a id="more"></a><h1 id="不太需要技巧的例题"><a href="#不太需要技巧的例题" class="headerlink" title="不太需要技巧的例题"></a>不太需要技巧的例题</h1><h2 id="Luogu3802-小魔女帕琪"><a href="#Luogu3802-小魔女帕琪" class="headerlink" title="Luogu3802 小魔女帕琪"></a><a href="https://www.luogu.org/problem/P3802" target="_blank" rel="noopener">Luogu3802 小魔女帕琪</a></h2><p>这东西我硬推推出来一个：</p><script type="math/tex; mode=display">\dfrac{\left(\begin{array}{c}{\mathrm{S}-6} \\ {1}\end{array}\right) \cdot 7 ! \cdot \prod_{\mathrm{i}=1}^{7} \mathrm{a}_{\mathrm{i}} \cdot(\mathrm{S}-7) !}{\mathrm{S} !}</script><p>的东西。感觉还可以？然后其实就是一种思想？此时总方案数$\rm S$这东西不应该除以某些奇怪的阶乘，或者说，不需要，因为样本空间可以理解为先发生了$A$和发生了$B$虽然局面一样但是概率独立（大概</p><h2 id="Luogu5489-LnOI2019-脸滚键盘"><a href="#Luogu5489-LnOI2019-脸滚键盘" class="headerlink" title="Luogu5489 [LnOI2019]脸滚键盘"></a><a href="https://www.luogu.org/problem/P5498" target="_blank" rel="noopener">Luogu5489 [LnOI2019]脸滚键盘</a></h2><p>这题写过题解，现在复习一遍。大概就是考虑维护一个前缀和，构造数列</p><script type="math/tex; mode=display">\rm F_i=F_{i-1}\cdot base_i+base_i</script><p>然后我们发现它的级数很美妙：</p><script type="math/tex; mode=display">{\sum_{i=1}^{n}F_i=base_1+base_2\cdots+base_n+base_1base_2+base_2base_3\cdots+\prod_{i=1}^{n}base_i}</script><p>正好就是我们要求的答案。</p><p>但此时直接前缀和会有问题，因为多余的实际上是$a_0\cdots a_n$那一堆项，所以需要像哈希一样左半边乘上</p><script type="math/tex; mode=display">\prod_{i=1}^{r}base_i+\prod_{i=1}^{r-1}base_i+\cdots +\prod_{i=1}^{l}base_i</script><h2 id="Luogu1297-国家集训队-单选错位"><a href="#Luogu1297-国家集训队-单选错位" class="headerlink" title="Luogu1297 [国家集训队]单选错位"></a><a href="https://www.luogu.org/problem/P1297" target="_blank" rel="noopener">Luogu1297 [国家集训队]单选错位</a></h2><p>然后其实，$\rm E_S=\mathbb{E}(1)+\mathbb{E}(2)+\mathbb{E}(3)\cdots$ </p><p>观察 $ \mathbb{E}(i)$，实际上只与 $ base_i,base_{i+1}$ 有关，那么每一项的贡献就是 $\dfrac{1}{\max(base_i,base_{i+1})}$。加起来即可。</p><h2 id="Luogu3924-康娜的线段树"><a href="#Luogu3924-康娜的线段树" class="headerlink" title="Luogu3924 康娜的线段树"></a><a href="https://www.luogu.org/problem/P3924#submit" target="_blank" rel="noopener">Luogu3924 康娜的线段树</a></h2><blockquote><p>每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？</p><p>此处的区间加是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (o&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (o&lt;&lt;1|1)</span></span><br><span class="line"> <span class="keyword">int</span> sumv[N&lt;&lt;<span class="number">2</span>],minv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> pushu\Pr(<span class="keyword">int</span> o)&#123;sumv[o]=sumv[lson]+sumv[rson];&#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     build(lson,l,mid);build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> q,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]+=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(q&lt;=mid)change(lson,l,mid,q,v);</span><br><span class="line">     <span class="keyword">else</span> change(rson,mid+<span class="number">1</span>,r,q,v);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;T; </span><br><span class="line"><span class="comment">//区间加</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)T.change(<span class="number">1</span>,<span class="number">1</span>,n,i,addv);</span><br></pre></td></tr></table></figure><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>根据线性性显然可以知道维护的就是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i}{2^{depth_i}}</script><p>其中根节点的 $depth$ 默认为 $0$ 。考虑先把这个式子通分一下：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i\cdot 2^{maxL-depth_i}}{2^{maxL}}=\dfrac{1}{2^{maxL}}\sum_{i=1}^{n}val_i\cdot 2^{maxL-depth_i}</script><p>然后考虑，如果是区间修改，那么本质上只需要求出区间内所有点的线段树上子树内系数 $2^{maxL-depth_i}$ 的和。这一部分可以直接预处理得到。并且考虑只有区间加的操作，所以并不需要真正动态地去维护。直接维护一个全局 $ans$ 即可。</p><p>于是最后复杂度线性。</p><h1 id="考察期望线性性的题目"><a href="#考察期望线性性的题目" class="headerlink" title="考察期望线性性的题目"></a>考察期望线性性的题目</h1><h2 id="ZROI-1142-石子"><a href="#ZROI-1142-石子" class="headerlink" title="[ZROI 1142]石子"></a>[ZROI 1142]石子</h2><blockquote><p>小 D 正在玩取石子游戏。 小 D 共有 $n$ 堆石子，依次编号为 $1, 2, · · · , n$，其中第 $i$ 堆有 $a_i$ 颗石子。 小 D 每次会等概率随机选择一颗石子，并取完它所在的那一堆石子。 小 D 想要知道，第 $1$ 堆石子被取走的时间的期望。</p><p>$n=10^6$。</p></blockquote><p>根据期望的线性性，可以知道可以分别算每堆石子在第 $1$ 堆之前被取完的概率。所以就是</p><script type="math/tex; mode=display">\mathbb{E}(t)=P_{2}+P_{3}+\cdots+P_{n}+1</script><p>于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ; ans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (<span class="keyword">double</span>)base[i] / (<span class="keyword">double</span>)(base[i] + base[<span class="number">1</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BZOJ3036-绿豆蛙的归宿"><a href="#BZOJ3036-绿豆蛙的归宿" class="headerlink" title="[BZOJ3036]绿豆蛙的归宿"></a>[BZOJ3036]绿豆蛙的归宿</h2><blockquote><p>给出 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。</p><p>绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\dfrac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？</p></blockquote><p>发现路径可以拆分，于是根据期望的线性性有</p><script type="math/tex; mode=display">\mathbb{E}(L)=\sum_{e=(u,v)}\mathbb{E}(e) = \sum_{e=(u,v)}\Pr(e)\cdot val(e)</script><p>于是 <code>dfs</code> 一遍即可。</p><h2 id="CF280C-Game-On-Tree"><a href="#CF280C-Game-On-Tree" class="headerlink" title="CF280C Game On Tree"></a>CF280C Game On Tree</h2><blockquote><p>给出一棵树，每次随机等概率选择一未染黑的点，将它及其子树染黑。问期望多少次操作可以将树全部染黑。</p><p>$1\leq n\leq 10^5$ .</p></blockquote><p>草，我居然能把这题给秒掉，太可怕了。</p><p>考虑首先是期望的线性嘛，于是可以知道 $\mathbb{E}(T)$ 表示把树 $T$ 全部染黑的期望次数，那么可以知道有</p><script type="math/tex; mode=display">\mathbb{E}(T)=\sum_{u\in T} \mathbb{E}(u)</script><p>其中 $u$ 是那么考虑如果想要染黑一棵以 $u$ 为根的子树，可以采用的策略是把它到根的路径上任意一点染黑，但是只有在染黑他自己的时候才会对答案产生贡献。所以不难知道</p><script type="math/tex; mode=display">\mathbb{E}(u)=\dfrac{1}{depth_u}</script><h1 id="考察转移递推思想的期望题目"><a href="#考察转移递推思想的期望题目" class="headerlink" title="考察转移递推思想的期望题目"></a>考察转移递推思想的期望题目</h1><h2 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="[NOI2005]聪聪与可可"></a>[NOI2005]聪聪与可可</h2><blockquote><p>给定一张 $n,m$ 的无向图。两个人一开始分别在点 $A,B$。每次 $A$ 先走，$B$ 后走，$A$ 每次会选择一个离 $B$ 最近且编号最小的点走 $1\sim2$ 步，$B$ 随机游走(也可停在原地，概率平摊)，求期望多少步 $A$ 可以与 $B$  相遇。</p><p>$1 \leq N, E \leq 1000$。</p></blockquote><p>emmm 要是化归子问题的话，一开始觉得应该算出在每个点相遇的期望步数，但想了想觉得这个并不可做…</p><p>于是考虑更暴力一点化归子问题： $f_{u,v}$ 表示 $A$ 在 $u$，$B$ 在 $v$ 时两者相遇的期望步数。那么考虑转移：</p><p>1、$u=v$ ，$f_{u,v}=0$ 。</p><p>2、$dis(u,v)=1$，$f_{u,v}=1$ （因为 $A$ 先走）。</p><p>3、$dis(u,v)&gt;1$，$f_{u,v}=\dfrac{\sum{f_{u’,v’}}}{\deg(v)+1}$ ，其中 $u’$ 是 $u$ 走两步可以到达的离 $v$ 最近的一个点，$v$ 是随便一个点。</p><p>然后就可以记搜了。我其实很迷惑为什么全员最短路的题要出 $1e3$ …除了强行丰富代码难度，有什么意义吗…</p><p>注意实现的一点小细节。如果 $x$ 走两步就可以走到 $y$，此时应该直接 <code>return 1.0</code> ，因为 $B$ 根本没有走的机会。</p><h2 id="LuoguP1365-OSU-Easy-Version"><a href="#LuoguP1365-OSU-Easy-Version" class="headerlink" title="[LuoguP1365]OSU!(Easy Version)"></a>[LuoguP1365]OSU!(Easy Version)</h2><blockquote><p>给定一个序列，某些位置是 $0$，某些位置是 $1$ ，某些位置分别有 $50\%$ 的概率变成 $0$ 或者 $1$ 。求极大连续纯 $1$ 段的长度的平方之和的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>考虑分别记 $f_i,g_i$ 表示总期望/当前段的期望。那么可以分类讨论 $i$ 的类型：</p><p>1、$a_i=1,g_i=g_{i-1}+1,f_{i}=f_{i-1}+2\cdot g_{i-1}+1$ 。</p><p>2、$a_i=0,g_i=0,f_{i}=f_{i-1}$ 。</p><p>3、$a_i=?,g_{i}=g_{i-1}+0.5,f_{i}=f_{i-1}+g_{i-1}+0.5$ 。</p><p>还是比较简单的。注意一个点即可，根据期望的线性性，如果按照「前 $i$ 个」作为划分阶段的依据，需要把一个极长连续 $1$ 段的贡献摊到每个元素上面，摊的方法就是平方和公式。</p><h2 id="BZOJ4318-OSU-Hard-Version"><a href="#BZOJ4318-OSU-Hard-Version" class="headerlink" title="[BZOJ4318]OSU!(Hard Version)"></a>[BZOJ4318]OSU!(Hard Version)</h2><blockquote><p>我们可以把osu的规则简化与改编成以下的样子:</p><p>一共有 $n$ 次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，$n$ 次操作对应为长度为 $n$ 的<code>01</code> 串。在这个串中连续的 $X$ 个 1 可以贡献 $X^3$ 的分数，这 $X$ 个 $1$ 不能被其他连续的 $1$ 所包含（也就是极长的一串1）</p><p>现在给出 $n$，以及每个操作的成功率，请你输出期望分数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>跟上一题十分接近的思路。但是考虑立方和公式 $(x+1)^3=x^3+3x^2+3x+1$ ，由于 $\mathbb{E}^2(x)\neq \mathbb{E}(x^2)$，所以不能直接拿线性性拆。于是考虑分别维护极长段的平方和和长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">g[i] = (g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i], </span><br><span class="line">p[i] = (p[i - <span class="number">1</span>] + <span class="number">2</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i],</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + base[i] *  (<span class="number">3</span> * p[i - <span class="number">1</span>] + <span class="number">3</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Luogu4550-收集邮票"><a href="#Luogu4550-收集邮票" class="headerlink" title="[Luogu4550]收集邮票"></a>[Luogu4550]收集邮票</h2><blockquote><p>有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $\dfrac{1}{n}$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 张邮票需要支付 $k$ 元钱。</p><p>现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>首先考虑一个简化版问题：</p><blockquote><p>每次随机一个$[1,n]$的整数，问期望几次能凑出所有数 </p></blockquote><p>考虑期望的线性性，就是 $\mathbb{E}=\sum \mathbb{E}(i)$，其中 $\mathbb{E}$ 为所求，$\mathbb{E}(i)$ 为在已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望次数。根据之前整理过的内容，“发生概率为 $p$ 的事件，在期望 $\dfrac{1}{p}$ 次之后会发生”，我们可以得到如下：</p><script type="math/tex; mode=display">\begin{aligned}\Pr(i)& =\dfrac{n-(i-1)}{n} \\\mathbb{E}(i)& =\dfrac{1}{\Pr(i)}=\dfrac{n}{n-i+1}\end{aligned}</script><p>然后把他们加起来就是</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum\dfrac{n}{n-i+1}=\sum\dfrac{n}{i}</script><p>思路是自然的。然后考虑本题，需要给每次操作附加一个权值。所以本质上我们可以分开计算，$g_i$表示已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望步数，$ f_i$表示期望步数的<code>cost</code>。</p><p>考虑如何计算 $f_i$。假设之前拿数进行了 $p$ 次操作，这一次拿 $i$ 需要 $q$ 次操作，那么这 $q$ 次操作的 $\rm \sum cost$ 就是</p><script type="math/tex; mode=display">p\cdot q+q^2=(p+q)\cdot q</script><p>这个原理需要编一下。考虑前一半是之前拿数次数与当前拿数次数的乘积，可以知道此时的代价至少是这些；后一半在不考虑前面拿数的贡献后，可以考虑期望的意义，$q$ 既是期望次数，也是平均代价，所以可以知道当前的代价应该是 $q^2$ 。</p><p>然后就递推一下即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">n = <span class="number">1.0</span> * N / (N - i + <span class="number">1</span>), </span><br><span class="line">g[i] = g[i - <span class="number">1</span>] + n, f[i] = f[i - <span class="number">1</span>] + g[i] * n ;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>, f[N])  ;</span><br></pre></td></tr></table></figure><h2 id="SHOI2014-概率充电器"><a href="#SHOI2014-概率充电器" class="headerlink" title="*[SHOI2014]概率充电器"></a>*[SHOI2014]概率充电器</h2><blockquote><p>SHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定(每条边有一个通电概率)，每一个充电元件自身是否直接进行充电也由概率决定(每个点也有一个通电概率)。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。</p><p>你突然想知道，进入充电状态的元件个数的期望是多少呢？</p><p>$1\leq n\leq 5\cdot 10^5$。</p></blockquote><p>比较有难度的题目。</p><p>根据期望的线性性，可以知道这题只需要求出每个点被点亮的概率即可。考虑设 $f_u$ 表示 $u$ 的子树对 $u$ 的贡献，$g_u$ 表示 $u$ 真正的贡献。不难知道 $f_u\leq g_u$ 。</p><p>那么考虑分别求这两部分。首先常规树形 $dp$ 求出 $f_{root}=g_{root}$  来，转移大概是考虑依次把子树合并进来：</p><script type="math/tex; mode=display">f_{u}=(1-f_u)\cdot f_v\cdot e[u,v]</script><p>然后考虑如何将贡献 $down$ 下去。那么考虑设 $h_u$ 表示只考虑祖先的贡献时，$u$ 亮的概率。不难知道 $g_u=f_u+h_u$ 。那么考虑 $h$ 怎么求。发现一般这种 down 形态的 dp 都要减去当前子树的贡献。所以对于 $h_v$ 而言，有如下转移：</p><script type="math/tex; mode=display">h_v=\dfrac{(g_u-f_v\cdot e[u,v])\cdot (1-f_v)\cdot e[u,v]}{1-f_v\cdot e[u,v]}</script><p>考虑分子上是父亲传到儿子的概率，$h_v$ 是从父亲处导电的概率，那么可以知道如果想要父亲传到儿子，必须要使之互斥，即需要让 $h_v\times \Pr(\texttt{不通过儿子传到父亲})=\Pr(\texttt{父亲传到儿子})$ ，这是分母的来由。</p><p>考虑如果本身不能「不通过儿子传给父亲」，那么父亲的就不能传给儿子，此时 $h_v=0$，需要特判。</p><p>好绕啊好绕啊… </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = base[u] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; </span><br><span class="line">dfs0(to(k), u), f[u][<span class="number">0</span>] += (<span class="number">1</span> - f[u][<span class="number">0</span>]) * val(k) * f[to(k)][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">double</span> p = f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">1</span> - p) &lt;= eps) &#123;dfs1(to(k), u) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line"><span class="keyword">double</span> q = f[u][<span class="number">0</span>] + f[u][<span class="number">1</span>] - f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line">f[to(k)][<span class="number">1</span>] = (<span class="number">1</span> - f[to(k)][<span class="number">0</span>]) * q / (<span class="number">1</span> - p) * val(k) ; </span><br><span class="line">dfs1(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">double</span> o ; <span class="keyword">int</span> i, u, v, w ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), o = w * <span class="number">0.01</span>, add(u, v, o) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w), base[i] = w * <span class="number">0.01</span> ;</span><br><span class="line">dfs0(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (f[i][<span class="number">0</span>] + f[i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转移时有后效性的题目"><a href="#转移时有后效性的题目" class="headerlink" title="转移时有后效性的题目"></a>转移时有后效性的题目</h1><h2 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="[HNOI2013]游走"></a>[HNOI2013]游走</h2><blockquote><p>一个无向连通图，顶点从 $1$ 编号到 $n$ ，边从 $1$ 编号到 $m$。</p><p>小Z在该图上进行随机游走，初始时小Z在 $1$ 号顶点，每一步小Z以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。</p><p>现在，请你对这 $m$ 条边进行编号，使得小Z获得的总分的期望值最小。</p><p>$n\leq 500,1\leq m\leq 1.2\times 10^5$ 。</p></blockquote><p>首先可以贪心地知道期望走过次数越多的边，自然希望他编号越小。</p><p>考虑由点推边。即设 $f_i$ 表示 $i$ 这个点经过的次数。那么可以知道有</p><script type="math/tex; mode=display">f_{i}=[i=1]+\sum_{(i,j)\in\mathbb E} f_j\times \dfrac{1}{\deg_j}</script><p>于是可以高斯消元求出每个 $f_i$ 。之后考虑一条边 $(u,v)$ 的期望经过次数就是</p><script type="math/tex; mode=display">\dfrac{f_u}{\deg_u}+\dfrac{f_v}{\deg_v}</script><p>注意以上所有的操作都不包括 $n$ 号点，因为到 $n$ 号点就不会再走了。</p><h2 id="CF24D-Broken-Robot"><a href="#CF24D-Broken-Robot" class="headerlink" title="CF24D Broken Robot"></a>CF24D Broken Robot</h2><blockquote><p>$n$ 行 $m$ 列的矩阵，一开始在点 $(x,y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。</p><p>注意，$(1,1)$ 是木板的左上角，$(n,m)$ 是木板的右下角。</p></blockquote><p>首先是倒推的思想，从 $(x,y)$ 走到最后一行状态的过程不好描述，可以转化为从最后一行走到 $(x,y)$ 。</p><p>考虑转移</p><script type="math/tex; mode=display">f_{i,j}=\begin{cases}\frac{1}{3}(f_{i+1,j}+f_{i,j+1}+f_{i,j})&\left(j=1\right)\\\frac{1}{3}(f_{i+1,j}+f_{i,j-1}+f_{i,j})&\left(j=m\right)\\\frac{1}{4}(f_{i+1,j}+f_{i,j-1}+f_{i,j+1}+f_{i,j})&\mathrm{Otherwise}\end{cases}</script><p>发现具有后效性，于是考虑消元。个人认为至少有如下几档部分分：</p><h3 id="40-pts-max-n-m-leq-25"><a href="#40-pts-max-n-m-leq-25" class="headerlink" title="40 pts $\max\{n,m\}\leq 25$"></a>40 pts $\max\{n,m\}\leq 25$</h3><p>这个就可以把 $n \times m$ 个元素放在一起消元，复杂度是 $(n^3\cdot m^3)$ 的。</p><h3 id="70-pts-max-n-m-leq-100"><a href="#70-pts-max-n-m-leq-100" class="headerlink" title="70 pts $\max\{n,m\}\leq 100$"></a>70 pts $\max\{n,m\}\leq 100$</h3><p>发现每一行和其他行之间的关系只有 $f_{i+1,j}$ ，那么不难想到倒序枚举每一行，对这一行内的元素进行消元，此时 $f_{i+1}$ 的所有元素均已知。复杂度是 $O(n\cdot m^3)$ 的。</p><h3 id="85-pts-max-n-m-leq-500"><a href="#85-pts-max-n-m-leq-500" class="headerlink" title="85 pts $\max\{n,m\}\leq 500$"></a>85 pts $\max\{n,m\}\leq 500$</h3><p>发现对于要消元的矩阵，对于每一行只有 $i,i-1,i+1,n+1$ 四个列的位置是有元素的，所以每次对于一行而言，可以只进行 $O(1)$ 次消元。这样就是 $O(n\cdot m^2)$ 的了。 </p><h3 id="100-pts-max-n-m-leq-3000"><a href="#100-pts-max-n-m-leq-3000" class="headerlink" title="100 pts $\max\{n,m\}\leq 3000$"></a>100 pts $\max\{n,m\}\leq 3000$</h3><p>发现不止横向有性质，纵向同样有性质。发现对于每一列，至多会有 $3$ 个元素。这样纵向也是 $O(1)$ 的了。于是总复杂度 $O(n\cdot m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i][i + <span class="number">1</span>] /= f[i][i] ;</span><br><span class="line">        f[i][n + <span class="number">1</span>] /= f[i][i] ; f[i][i] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][i + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][n + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][n + <span class="number">1</span>] ;</span><br><span class="line">        f[i + <span class="number">1</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[n] = f[n][n + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans[i] = f[i][n + <span class="number">1</span>], ans[i] -= ans[i + <span class="number">1</span>] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= x ; -- i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span> &amp;&amp; j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">2.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">1.0</span> / <span class="number">2.0</span> ; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[j][j] = <span class="number">3.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gauss(m) ; <span class="comment">//debug(ans, 1, m) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            f[j][j] = f[j][j - <span class="number">1</span>] = f[j][j + <span class="number">1</span>] = f[j][m + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, ans[y]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="[HNOI2011]XOR和路径"></a>[HNOI2011]XOR和路径</h2><blockquote><p>给定一个无向连通图，其节点编号为 $1$ 到 $N$，其边的权值为非负整数。试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得该路径上经过的边的权值的 “XOR和”最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算“XOR 和”时也要被重复计算相应多的次数。</p><p>直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 $1$ 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 $N$ 号节点为止，便得到一条从 $1$ 号节点到 $N$ 号节点的路径。显然得到每条这样的路径的概率是不同的并且每条这样的路径的“XOR 和”也不一样。现在请你求出该算法得到的路径的“XOR 和”的期望值。</p><p>$2≤N≤100,1\leq M≤10000$ 。</p></blockquote><p><del>那必然是要先猜一波期望对xor运算也具有线性性，但实际上并没有。</del></p><p>感觉可能是需要记住的一个 $trick$ ，位运算时位与位之间是独立的，所以可以分别对每一位计算。那么对每一位计算就可以直接按 $0/1$ 分类讨论来转移。</p><p>具体的，还是考虑倒推。个人感觉这是因为最初的决策可能延伸出许多不同的决策，导致很难对这个过程进行统计。但是如果倒推的话，就相当于从一个已知结果出发走向另一端的已知开始。所以会相对容易一点？</p><p>于是考虑设状态 $f_x$ 表示当前二进制位下， 从 $x$ 走到 $n$ 这一位的期望，也就可以等价于这一位为 $1$ 的概率。于是有转移</p><script type="math/tex; mode=display">f_{u}=\frac{1}{\deg_u}\left(\sum_{(u,v,w)\in \mathbf{E},w=0} f_v+\sum_{(u,v,w)\in \mathbf{E},w=1}(1-f_v)\right)</script><p>然后就可以消元了，复杂度 $O(n^3\log V)$ 。注意自环只统计一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxv ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"></span><br><span class="line">db res ;</span><br><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        w = qr() ; chkmax(maxv, w) ;</span><br><span class="line">        add_e(u, v, w) ; <span class="keyword">if</span> (u != v) add_e(v, u, w) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(deg, 1, n) ; cout &lt;&lt; cnt &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span> ; v &lt;= maxv ; v &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = <span class="number">0.0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">            f[i][i] = deg[i] ; <span class="keyword">int</span> xs = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[i] ; k ; k = next(k))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(val(k) &amp; v)) f[i][to(k)] -= <span class="number">1.0</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][to(k)] += <span class="number">1.0</span>, xs += <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][n + <span class="number">1</span>] = <span class="number">1.0</span> * xs ;</span><br><span class="line">        &#125;</span><br><span class="line">        f[n][n] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= n + 1 ; ++ i)</span></span><br><span class="line"><span class="comment">            for (int j = 1 ; j &lt;= n + 1 ; ++ j)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n + 1] ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        gauss(n) ; res += ans[<span class="number">1</span>] * v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡做八做了一点简单的期望题，算是练练手感吧。&lt;/p&gt;
&lt;p&gt;一共是 $15$ 道题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学/高斯消元" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="技巧/按位操作" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【探究向】用命分析概率型生成函数(PGF)</title>
    <link href="https://www.orchidany.cn/2020/05/03/%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://www.orchidany.cn/2020/05/03/概率生成函数入门/</id>
    <published>2020-05-03T10:48:19.000Z</published>
    <updated>2020-05-31T10:56:25.511Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是最近的研究成果吧？</p><p>「学不会的生成函数」+「学不会的概率论」= <code>?</code></p><p>算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。</p><a id="more"></a><h1 id="概率型生成函数"><a href="#概率型生成函数" class="headerlink" title="概率型生成函数"></a>概率型生成函数</h1><p>虽然概率型生成函数本质上就是普通型生成函数，只不过多了一个对应关系。</p><p>即，如果对于某个离散型随机变量 $X\in\mathbb Z$ ，存在数列 $\{a_n\}$ 满足 $\Pr(X=i)=a_i$ ，那么离散型随机变量 $X$ 的 <strong>概率型生成函数$(\mathbf{PGF})$</strong> 为</p><script type="math/tex; mode=display">\mathscr{F}(z)=\sum_{i=0}^{\infty} \Pr(X=i) z^i</script><p>那么首先有</p><script type="math/tex; mode=display">\mathscr{F}(1)=\sum_{i=0}^{\infty}[z^i]\mathscr{F}(z)=1</script><p>同时根据期望的定义</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}i\Pr(X=i)</script><p>可以知道期望就是 $\mathscr{F}$ 的一阶导数系数和，即</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}[z^i]\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)</script><p>那么同时根据方差的定义以及期望的线性性可以得到：</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E\left((X-E(X))^{2}\right)=E\left(X^{2}-2\cdot X \cdot E(X)+E(X)^{2}\right)=E\left(X^{2}\right)-E(X)^{2}</script><p>从而有 </p><script type="math/tex; mode=display">\mathsf{Var}(X)=\sum_{i=0}^{\infty}[z^i]\left(\dfrac{\mathrm{d^2}}{\mathrm{d} z^2}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)-\left(\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)\right)^2\right)</script><p>是因为</p><script type="math/tex; mode=display">E(X^2)=\sum_{i=0}^{\infty}i^2\cdot \Pr(X=i)=\sum_{i=0}^{\infty}i\cdot (i-1)\cdot \Pr(X=i)+\sum_{i=0}^{\infty}i\cdot \Pr(X=i)</script><p>可以知道前面一项是二阶导，后面一项是一阶导。</p><p>然后…然后就可以做题了(倒)。</p><h1 id="2013-Multi-University-Training-Contest-5-Dice"><a href="#2013-Multi-University-Training-Contest-5-Dice" class="headerlink" title="[2013 Multi-University Training Contest 5] Dice"></a>[2013 Multi-University Training Contest 5] Dice</h1><blockquote><p>一个 $m$ 面的公平骰子，求:</p><p>1、最后 $n$ 次结果相同就结束的期望次数。</p><p>2、求最后 $n$ 次结果全不同就结束的期望次数。</p><p>保证 $n,m \leq 10^6$，且对第二问 $n \leq m$ 。</p></blockquote><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>即用 dp 来做。</p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>设 $f_i$ 表示最后 $i$ 次相同，期望还要多少次结束。那么 $f_n=0$ ，求的就是 $f_0$ 。那么可以知道有转移</p><script type="math/tex; mode=display">f_{i}=\dfrac{1}{m}f_{i+1}+\frac{m-1}{m}f_1+1</script><p>发现并不好直接做，考虑差分得到</p><script type="math/tex; mode=display">f_{i}-f_{i+1}=(m-1)f_i-(m-1)f_{1}-m=m(\frac{m-1}{m}f_i-\frac{m-1}{m}f_1-1)=m(f_{i-1}-f_i)</script><p>并且由 $f_0=f_1+1$ 可以知道 $f_n-f_{n+1}=m^n$，于是最后答案就是 $1+\sum_{i=1}^{n-1}m^i$ 。</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p>设 $g_i$ 表示最后 $i$ 次均不相同，期望还要多少次结束。那么 $g_n=0$，求 $g_0$ 。考虑</p><script type="math/tex; mode=display">g_i=\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^i g_j}+1</script><p>(注意加粗的部分，自己一开始因为不细心推挂了…)</p><p>那么还是差分</p><script type="math/tex; mode=display">\begin{aligned}g_{i-1}-g_i&=-\frac{i-1}{m}g_i+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^{i-1} g_j}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}g_i-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}\left(\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^i g_j+1\right)-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)+(m-i)}{m^2}g_{i+1}+\left(\frac{m-i+1-1}{m^2}\right)\cdot\sum _{j=1}^ig_j+\frac{m-(i-1)-1}{m}\\&=-\frac{i\cdot (m-i)}{m^2}g_{i+1}+\frac{m-i}{m^2}\cdot\sum _{j=1}^ig_j+\frac{m-i}{m}\\&=\left(\frac{m-i}{m}\right)\left(-\frac{i}{m}g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^{i} g_j+1\right)\\&=\frac{m-i}{m}(g_{i}-g_{i+1})\end{aligned}</script><p><del>不会告诉你中途推岔匹了好几次</del></p><p>然后就类似上面那个 case 了，也是可以线性做的。</p><h2 id="PGF-做法"><a href="#PGF-做法" class="headerlink" title="PGF 做法"></a>PGF 做法</h2><h3 id="第一问-1"><a href="#第一问-1" class="headerlink" title="第一问"></a>第一问</h3><p>即考虑套路设 PGF，设 $f_i$ 表示恰好在扔第 $i$ 次结束时的概率，$g_i$ 表示扔了第 $i$ 次仍没结束的概率。考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \qquad(1)\\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \qquad(2)\end{aligned}</script><p>第一个方程可以看做是废话，就是多扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。</p><p>第二个方程的意思是在现在的串后面接一个合法，也就是 $n$ 位都相同的串，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个就结束的情况。个人的理解是，为了保证等式两边是在讨论相同的情况，所以仍然需要把后面的 $n-i$ 次操作算进来，可以知道这样是不影响前面恰好取完了的那些情况。于是根据这个东西依旧可以解出来和做法一相同的结果来。</p><h3 id="第二问-1"><a href="#第二问-1" class="headerlink" title="第二问"></a>第二问</h3><p>定义依旧不变。考虑方程大概是</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1</script><p>和 </p><script type="math/tex; mode=display">\tag{2}\mathscr{G}(z)\cdot \left(\frac{1}{m}z\right)^n\cdot \dfrac{m!}{(n-m)!}=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \cdot \dfrac{(m-i)!}{(m-i-(n-i))!}</script><p>然后就暴力解就好了。</p><h1 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="[CTSC2006] 歌唱王国"></a>[CTSC2006] 歌唱王国</h1><blockquote><p>简化版题面：</p><p>给定一个长为 $n$ 的由 $1\sim m$ 组成的序列 $A$，同时每次掷一颗均匀的 $m$ 面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串和 $A$ 相同。</p><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>考虑和上题差不多的 PGF 做法：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i}\cdot \mathscr{\zeta}(i)\end{aligned}</script><p>其中 $\zeta(i)=\texttt{「 A[1…i] 是否是 A[1…n] 的 Border」}$ 。 还是比较显然的，因为如果是拼到第 $i$ 位就可以停止，那么 $A[1…i]$ 必然是个 $\sf border$ 。</p><p>最后可以直接推出来</p><script type="math/tex; mode=display">\dfrac{\mathrm d}{\mathrm{d}z}\mathscr{F}'(1)=\sum_{i=1}^n \zeta(i)\cdot m^{i}</script><h1 id="SDOI2017-硬币游戏"><a href="#SDOI2017-硬币游戏" class="headerlink" title="[SDOI2017] 硬币游戏"></a>[SDOI2017] 硬币游戏</h1><blockquote><p>给定 $n$ 个长为 $m$ 的由 $0/1$ 组成的序列 $A_i$，同时每次掷一颗均匀的双面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串在 $A_1\sim A_n$ 中出现。</p><p>$n,m\leq 300$.</p></blockquote><p>考虑串与串之间可以来回匹配，于是对每个串都定义一个 $\mathscr{F}_i(z)$ 表示首次出现的是第 $i$ 个串，且当前随机长度为 $j$ 的概率，然后单独定义一个 $\mathscr{G}(z)$ 表示游戏结束，那么有</p><script type="math/tex; mode=display">\sum_{i=1}^n\mathscr{F}_i(z)+\mathscr{G}(z)=\mathscr{G}(z)\cdot z+1</script><p>同时定义 $match(i,j)_k=[~A_i[1…k]=A_{j}[k…m]~]$ ，那么有对于每个 $i$ 的一组方程枚举在最后拼上一个什么东西：</p><script type="math/tex; mode=display">\mathscr{G}(z)\cdot \Pr(A_i[1...n])\cdot x^m=\sum_{j=1}^n \mathscr{F}_j(z)\sum_{k=1}^m match(i,j)_k\cdot \Pr(A_i[k+1...m])\cdot x^{m-k}</script><p>不难知道意思是 $A_j$ 和 $A_i$ 可以放在一起匹配，枚举 $i$ 某个同时是 $A_j$ 后缀的前缀进行配对。</p><p>那么考虑要求的就是 $\mathscr{F}_1(1),\mathscr{F}_2(1),\mathscr{F}_3(1),\cdots$ 。发现可以由方程 $(2)$ 得到 $n$ 个关系，同时因为并没有要求期望所以 $(1)$ 式没有任何用处。但是可以发现，根据概率的规范性可以得到</p><script type="math/tex; mode=display">\sum \mathscr{F}_i(1)=1</script><p>于是就有 $n+1$ 组关系，同时有包含 $\mathscr{G}(1)$ 在内的 $n+1$ 个未知元，就可以愉快地高消了。</p><h1 id="ZJOI2013-抛硬币"><a href="#ZJOI2013-抛硬币" class="headerlink" title="[ZJOI2013] 抛硬币"></a>[ZJOI2013] 抛硬币</h1><blockquote><p>有一枚硬币，抛出正面 <code>H</code> 的概率为 $\frac{a}{b}$，抛出反面 <code>T</code> 的概率为 $1-\frac{a}{b}$。现在 T 小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为 <code>H</code>，反面记为 <code>T</code>，于是她得到了一个抛硬币序列 <code>HTHHT</code>…。</p><p>她突然想到一个问题：在抛出正面和反面概率都是 $\frac{1}{2}$ 的情况下，要使得抛出的序列出现只包含 <code>H</code> 和 <code>T</code> 目标序列，期望要抛多少次。</p><p>这么简单的题目她当然是一眼秒。于是她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为 <code>HT</code> 时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。</p><p>简化版题面：</p><blockquote><p>给出一个两面的均匀骰子，正面和反面的概率分别是 $\frac{a}{b}$ 和 $1-\frac{a}{b}$ 。并给出一个长度为 $n$ 的 $01$ 序列 $A$ 。</p><p>同时有一个一开始为空的序列。每次掷骰子，如果是反面，就在当前序列末尾写一个 $1$ ，否则写一个 $0$ ，如果发现此时序列中恰好有一个连续子串是 $A$ 则停止。求期望多少次才会停止操作。</p></blockquote><p>我认为合理的数据范围：$1\leq n\leq 10^6$，概率对 $998244353$ 取模。</p><p>ZJOI2013 的数据范围：$1\leq n\leq 10^3$ 输出确切概率并保留<strong>既约分数形式</strong> 。</p></blockquote><p>全网似乎没人用 PGF 做，这就很爽。有种中了头彩的感觉…但是其实写这题的时候我是十分崩溃的…</p><p>从 5.3 晚上 8:30 左右一直写，写到 10:00 PM 左右发现有地方写错了，但是由于要回宿舍了所以被迫终止。第二天早上来了又开始写，写着写着发现还要写一波高精 gcd 和高精除，于是就把早上的课给翘了。写完了发现慢的一匹，只能有 $50pts$，然后决定去学一学压位。发现压位也不难，然后决定压 $4$ 位；写着写着又发现压 $8$ 位也不是不可以，然后改来改去改成了 $90pts$ ，发现最大的点比时限慢一倍…于是就去扒自己的 FFT 板子，拼拼凑凑之后发现由于可能会爆精度所以不能压 8 位，只能压 $4$ 位，结果更慢了。然后决定改成 NTT，结果发现 NTT 要对神必数取模导致压两位可能都有问题，然后就自闭了，决定放弃多项式科技去优化自己的压位高精。发现有些地方似乎合并同类项之后会很快，原来乘 $O(n)$ 次改完只需要乘 $O(1)$ 次，然后左改右改终于卡过了洛谷上的1s时限…</p><p>期间一度怀疑自己算法的正确性，但是想了想也没什么更靠谱的做法了，只不过这个写法是 $L^2\log V$ 的，$L^2$ 大概也就是 $10^6$ 的范围，只是这个 $\log V$ …他确实有点毒瘤。因为最大可以到 $V=10^{16000}$ 左右，所以高精度除法二分起来就十分爆炸…大概极限是 $5\cdot 10^9$ 的运算量。不过…好在最后是过了，虽然有点卡时。</p><p>算了一下似乎 FFT 的复杂度更对一点，$L\log L\log V$ 大概是 $10^7\sim 10^8$ 左右的运算量。但是自己的 FFT 水平实在太差…于是就还是多项式乘法了。可能什么时候心情好就会补一下这个锅？</p><p>以下是正文，就直接把发在谷上的题解糊上来了：</p><hr><p>考虑设 $f_i$ 表示扔了 $i$ 次骰子之后恰好停止的概率，$g_i$ 表示扔了 $i$ 次骰子之后仍未结束的概率。同时考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1 \\</script><p>其意义是，扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。同时还有</p><script type="math/tex; mode=display">\tag{2}\mathscr G(z)\cdot \Pr(A[1...n])=\sum_{i=1}^n \mathscr{F}(z)\cdot \Pr(A[i+1...n])\cdot \zeta(i)</script><p>其意义是，考虑在现在的串后面接一个可以让这个过程直接结束的串，也就是接一个 $A$，$\Pr(s[1…n])$ 表示串 $s$ 出现的概率，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个、只加了前 $i$ 个字符就结束的情况，多乘一个 $\Pr(A[i+1…n])$ 本身是没有意义的，只是为了构造出等式，可以理解为两边都钦定扔了 $n$ 次——发现这种情况要是想要出现，就必须满足 $A[1…i]$ 是 $A$ 的一个 $\sf border$ ，所以 $\zeta(i)=[A[1…i]\in\mathbf{Border}]$ .</p><p>之后考虑如何消元。首先对 $(1)$ 式求导可以得到</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)\cdot z+\mathscr{G}(z)\cdot 1</script><p>也就是可以知道 </p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)=\mathscr{G}(z)</script><p>同时对于 $(2)$ 式，将 $z=1$ 代入可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)\cdot \Pr(A[1...n]) =\sum_{i=1}^n\mathscr{F}(1)\cdot \zeta(i)\cdot \Pr(A[i+1...n])</script><p>因为 $\mathscr{F}(1)=1$ ，所以可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)=\dfrac{\sum_{i=1}^n \zeta(i)\cdot \Pr(A[i+1...n])}{\Pr(A[1...n])}</script><p>然后根据</p><script type="math/tex; mode=display">E(X)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(1)</script><p>发现这题就做完了。复杂度线性。</p><p>但是注意本题要求以既约分数的形式保留精确值。因为我好久好久没写过高精度了，于是就想借此机会封装一个模板。然后…然后就写了快 $7h+$。注意到由于要求既约分数，所以要写高精度gcd，写法可以借鉴 <code>[SDOI2009]Super GCD</code> ，同时还要写高精除高精，个人没有找到什么好方法，于是就写的二分，复杂度大概是 $L^2\log V$ 的样子。</p><p>然后复杂度似乎是 $n\cdot L^2\log V$ ，并不可以过，于是考虑剪枝+卡常：</p><p>0、…高精度压位是必要的吧？这边我选择压 $8$ 位，因为发现 $10^3\cdot 10^{16}$ 恰好卡到了 <code>long long</code> 的上界。</p><p>1、发现二分时左右边界可以缩短很多，即 $l,r$ 都至多和 $V / \gcd$ 的长度相差 $1$ ，所以可以用这个来确定边界。亲测可以快大概 $6$ 倍左右(但是还是 T，极限数据大概要跑 $4s+$) 。</p><p>2、发现计算答案时，展开后存在很多公因式。于是可以提取公因式之后再计算。亲测可以快 $4$ 倍左右。</p><p>然后…大概就过了。中间写了很久的原因在于，我本来想尝试 FFT，后来发现自己没有封装好的 FFT…囧…写了半天发现自己 FFT 的常数还不如压位快…然后就没有然后了。</p><hr><p>以上都是无聊的套路题，还是下面的题比较有趣</p><h1 id="趣题-一个有趣的概率小问题-·-改"><a href="#趣题-一个有趣的概率小问题-·-改" class="headerlink" title="[趣题]一个有趣的概率小问题 · 改"></a>[趣题]一个有趣的概率小问题 · 改</h1><p>题目来源是<a href="http://roosephu.github.io/2017/12/31/condexp/" target="_blank" rel="noopener">这里</a>，与本题略有出入：</p><blockquote><p>一个 $n$ 面的骰子，每一面标号 $1$ 到 $n$ 。有个初始为 $0$ 的计数器，每次扔骰子，按顺序执行以下过程：</p><p>1、扔出了奇数：那么计数器清零。</p><p>2、扔出了偶数：计数器加 $1$ 。</p><p>3、扔出了 $n$：游戏结束。</p><p>问结束时计数器上显示的数值的期望。 </p><p>保证 $n$ 是偶数。</p></blockquote><p>考虑如果按照套路设 $f_i$ 表示扔到 $i$ 结束的概率，$g_i$ 表示扔到 $i$ 没有结束的概率，会存在问题。因为根据题设，会重复到达某个权值 $v$ 很多很多次，所以设概率是不妥的。</p><p>考虑 PGF 的一个翻版，对着期望建立生成函数(你可以叫他 EGF【雾】，虽然本质上就是对 PGF 求了一个一阶导数)：设 $f_i$ 表示扔到 $i$ 结束的<strong>期望次数</strong>，$g_i$ 表示扔到 $i$ 没有结束的<strong>期望次数</strong>，对这两个东西建立普通型生成函数可以得到</p><script type="math/tex; mode=display">\mathscr{F}(z)+\mathscr{G}(z)=\left(\mathscr{G}(z)\cdot \dfrac{z}{2}+1\right)+\frac{1}{2}\cdot \mathscr{G}(1)</script><p>其中左边的意思当然是，要么结束要么不结束，换个意思就是「到达 $i$ 的期望总次数」，右边第一项是有 $\dfrac{1}{2}$ 的概率从 $z$ 转移过来，有 $\dfrac{1}{2}$ 的概率到达 $0$，那么此时有等式「原来到达所有 $i$ 的期望次数」=「现在这一步到达 $0$ 的期望次数」。</p><p>同时也会有</p><script type="math/tex; mode=display">\mathscr{F}(z)=\frac{x}{n}\cdot \mathscr{G}(z)</script><p>即恰好扔到 $n$ 的转移，根据题设应该先 $+1$ ，再结束。</p><p>感觉还是比前面的题有趣的？</p><h1 id="来源保密的比赛-1A-Probability"><a href="#来源保密的比赛-1A-Probability" class="headerlink" title="[来源保密的比赛 1A] Probability"></a>[来源保密的比赛 1A] Probability</h1><blockquote><p>有一个随机变量 $z$, 初始 $z=0$.</p><p>执行 $n$ 次操作: 每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:=z+t$ 。</p><p>求 $\min(z,x)$ 的期望. 答案模 $998244353$. </p><p>$k\leq 100,n\leq 10^9,x\leq \min\{10^7,\frac{5\times 10^7}{k}\}$ 。</p></blockquote><p>设选择整数的概率型生成函数为 $P(y)=\sum_{i=0}^kp_i$ ，那么取了 $n$ 次之后的概率型生成函数就是 $Q(y)=P^n(y)$ 。</p><p>那么不难知道答案为</p><script type="math/tex; mode=display">\sum_{i=0}^{n\times k} [y^i]Q\cdot \min(x,i)=\sum_{i=0}^{x-1} [y^i]Q\cdot i + \left(1-\sum_{i=0}^{x-1} [y^i]Q\right)\cdot x</script><p>呃…虽然没学过 PGF 到底怎么化，但是概率上求 $z$ 补集就是 $1-z$ 还是比较 xxs 的结论吧…</p><p>然后现在问题就集中在怎么求 $P^n(y)$ 的前 $k$ 项了。发现可以暴力多项式快速幂，以获得 $40\sim 60$ 左右的成绩。</p><p>然后是神奇的多项式技巧…大概是考虑对于 $P^{n+1}(y)$ 求导有两种方式：</p><script type="math/tex; mode=display">\left(P^{n+1}(y)\right)^{\prime}=(n+1) P^{n}(y) P^{\prime}(y)\\\left(P^{n+1}(y)\right)^{\prime}=\left(P^{n}(y)\right)^{\prime} P(y)+P^{n}(y) P^{\prime}(y)</script><p>第一个就是链式法则，第二个则是拆出一个 $P(y)$ 来再用求导的乘法运算法则。</p><p>考虑联立之后</p><script type="math/tex; mode=display">nP^n(y)(P(y))'=(P^n(y))'P(y)</script><p>然后考虑现在的问题是，已知了 $P^n(y)$ 的前几项系数，求出后面的系数。考虑一个这样的思路：每次先求出 $(P^n(y))’$ 的第 $d$ 项，然后积分出 $P^n(y)$ 的第 $d+1$ 项。发现每个 $[y^d]P^n(y)$ 只会对 $y^d\sim y^{d+k}$ 这些产生贡献，所以考虑枚举到一个 $d$ 的时候向后刷表；考虑这样求出的是 $(P^n(y))’P(y)$ ，直接模拟多项式除法即可得到 $(P^n(y))’$ ，这样做也是单次 $O(k)$ 的。</p><p>对于多项式除法这部分，可以考虑对于每个 $[y^d] (P^n(y))’P(y)$ 都是这么计算得到的：</p><script type="math/tex; mode=display">\sum_{p=0}^k [y^p] P(y)\times [y^{d-p}] (P^n(y))'</script><p>然后就减去所有的 $p&gt;0$ 的那些结果，最后乘上一个 $[x^0]P(y)$ 的逆元即可。</p><p>顺便复习一下线性求逆元：</p><p>考虑模数是 $m$，那么设 $m=p\cdot x+r$，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}p\cdot x+r&\equiv 0\pmod m\\p\cdot r ^{-1}+x^{-1}&\equiv 0 \pmod m\\x^{-1}&\equiv -\lfloor\frac{m}{x}\rfloor\cdot (m\bmod x)^{-1}\pmod m\end{aligned}</script><h1 id="来源保密的比赛-Barrel"><a href="#来源保密的比赛-Barrel" class="headerlink" title="[来源保密的比赛 ?] Barrel"></a>[来源保密的比赛 ?] Barrel</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel2.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel3.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Parrel4.png" alt=""></p><p>读题让人十分迷惑…注意这题里面 $c_{i,j}$ 是给定的，只不过因为样例里面恰好是没有这部分输入而已……</p><hr><p>光是读题就会让人十分迷惑的题…</p><p>因为与符号冲突了，于是决定把题面中的 $z$ 改成 $c$ ，$z$ 维持原来的形式幂级数定义不变。</p><p>考虑深刻地挖掘题目性质：对于每个桶，所有年份体积的酒的体积总和是 $1$ 。所以如果设第 $i$ 个桶里年份为 $j$ 的酒体积为 $V_{i,j}$ ，可以发现本题要求</p><blockquote><p>第 $n$ 个桶内取一微元酒的单价期望/方差，</p></blockquote><p>实际上就是在求</p><blockquote><p><strong>第 $n$ 个桶有 $V_{n,j}$ 的概率变成第 $j$ 年的酒，求第 $n$ 桶酒的期望价值。</strong></p></blockquote><p>考虑先算这个概率。</p><p>考虑一个突破点，发现每次给出去的一定是均匀的，所以不需要考虑给出去的如何分配。换言之如果这一回合给进来的总体积(不看年份)是 $V$ ，那么给出去的必然是 $1-V$ 并且是均匀的。</p><p>根据上一点，理应想到，$1$ 号酒桶就是突破口，因为 $1$ 号桶进来的只会是 $f$ 。于是考虑设每个桶内每一轮新倒入的体积为 $m_i$，那么会有</p><script type="math/tex; mode=display">m_i=\begin{cases}f&\mathrm{if}~(i=1)\\\sum_{j=1}^{i-1}c_{i,j}&\mathrm{otherwise}\end{cases}</script><p>于是考虑设 $f_{i,j}$ 表示第 $i$ 个桶内变成第 $j$ 年酒的概率，对每一个 $i$ 建立概率型生成函数 $\mathscr F_i(z)$ ，那么会有</p><script type="math/tex; mode=display">\mathscr F_{i}(z)=\mathscr F_{i}(z)\cdot z\cdot (1-m_i)+\sum_{j=1}^i m_j\mathscr{F}_j(z)</script><p>这个式子本质上模拟了取酒、倒酒这个过程。</p><p>考虑计算答案，根据上文可以知道</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E(X^2)-E^2(X)</script><p>考虑后面一项本质上是</p><script type="math/tex; mode=display">\left(\sum_{i=0}^{+\infty} i\cdot c^i\cdot [z^i]\mathscr{F}_{n}(z)\right)^2</script><p>然后发现…如果将不定元 $z$ 赋值成 $c$ ，那么上式就是</p><script type="math/tex; mode=display">\left(c\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c)\right)^2</script><p>同理第一项就是</p><script type="math/tex; mode=display">\sum_{i=0}^{+\infty} i\cdot c^{2}\cdot [z^{2\cdot i}]\mathscr{F}_{n}(z^2)</script><p>等价于</p><script type="math/tex; mode=display">c^4\cdot \frac{\mathrm{d^2}}{\mathrm{d}z^2}\mathscr{F}_n(c^2)+c^2\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c^2)</script><p>其中后半部分为了补全系数。</p><p>然后就可以直接做了，用一些求导技巧维护 </p><script type="math/tex; mode=display">\mathscr{F}_{i}(z), \mathscr{F}_{i}^{\prime}(z), \mathscr{F}_{i}\left(z^{2}\right), \mathscr{F}_{i}^{\prime}\left(z^{2}\right), \mathscr{F}_{i}^{\prime \prime}\left(z^{2}\right)</script><p>的值即可。复杂度 $n^2$ 。</p><h1 id="代码合集"><a href="#代码合集" class="headerlink" title="代码合集"></a>代码合集</h1><p>大概是上面的题写了代码就会丢到这里一份，看心情保留完整版还是局部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu4652 Dice</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line">db ans ;</span><br><span class="line">db res ;</span><br><span class="line"><span class="keyword">int</span> k, m, n ;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">expow</span><span class="params">(db x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    db ret = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1.0</span> * ret * x ;</span><br><span class="line">        x = <span class="number">1.0</span> * x * x ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; q)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; m &gt;&gt; n ; </span><br><span class="line">            <span class="keyword">if</span> (!k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) ans = <span class="number">1.0</span> * n ;</span><br><span class="line">                <span class="keyword">else</span> ans = (expow(m, n) - <span class="number">1.0</span>) / (<span class="number">1.0</span> * (m - <span class="number">1.0</span>)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="number">1</span> ; ans = <span class="number">0.0</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    res *= <span class="number">1.0</span> * m / (m - i + <span class="number">1</span>), ans += res ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CTSC2006 歌唱王国</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * x % P ;</span><br><span class="line">        x = <span class="number">1l</span>l * x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m ; <span class="keyword">int</span> j = <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            base[i] = qr(), f[i] = <span class="number">0</span> ; f[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">            <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m) add(ans, expow(n, m), P), m = f[m] ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"000"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">"00"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">1000</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZJOI2013 抛硬币</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">const</span> ll Base = <span class="number">100000000</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_L</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x) ret ++, x /= <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Big_Num</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">2051</span>] ;</span><br><span class="line">    <span class="keyword">bool</span> mk ; <span class="keyword">int</span> len, lent ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        len = <span class="number">0</span>, mk = <span class="number">0</span>, <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mk &amp;&amp; !(len &lt;= <span class="number">1</span> &amp;&amp; !v[<span class="number">1</span>])) <span class="built_in">putchar</span>(<span class="string">'-'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i == len)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">8</span> - get_L(v[i]) ; ++ j) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) mk = <span class="number">1</span>, x = -x ;</span><br><span class="line">        <span class="keyword">while</span> (x) v[++ len] = x % Base, x /= Base ;</span><br><span class="line">lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; reset() ;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">1</span>] == <span class="string">'-'</span>) ++ p, mk = <span class="number">1</span> ;</span><br><span class="line">        len = (L - p) / <span class="number">8</span> + (((L - p) % <span class="number">8</span>) &gt; <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L, k = len ; i &gt;= p + <span class="number">1</span> ; i -= <span class="number">8</span>, -- k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = min(i - p, <span class="number">8</span>) ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                v[k] = v[k] * <span class="number">10l</span>l + (x[i - j + <span class="number">1</span>] - <span class="string">'0'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">reverse(v + <span class="number">1</span>, v + len + <span class="number">1</span>) ;  lent = L - p ;</span><br><span class="line">    &#125;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> ~ (Big_Num A)&#123;</span><br><span class="line">        A.mk ^= <span class="number">1</span> ; <span class="keyword">return</span> A ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len != B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] != B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ;</span><br><span class="line">        Big_Num p, q, t ; p = A, q = B ;</span><br><span class="line">        <span class="keyword">if</span> (p.lent &lt; q.lent) &#123; <span class="keyword">return</span> (~ (q - p)) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] - q.v[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &lt; <span class="number">0</span>) res.v[i + <span class="number">1</span>] --, res.v[i] += Base ;</span><br><span class="line">        res.len = p.len ; res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">20</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line"><span class="keyword">if</span> (res.v[res.len] &lt; <span class="number">0</span>)</span><br><span class="line">            res.mk = <span class="number">1</span>, res.len --, res.v[res.len] = Base - res.v[res.len] ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ;</span><br><span class="line">        res.reset() ; Big_Num p, q ;</span><br><span class="line">        <span class="keyword">if</span> (A.len &gt; B.len)</span><br><span class="line">            p = A, q = B ; <span class="keyword">else</span> p = B, q = A ;</span><br><span class="line">        <span class="keyword">if</span> (p.mk &amp;&amp; q.mk) res.mk = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.mk &amp;&amp; !q.mk) &#123; p.mk = <span class="number">0</span> ; <span class="keyword">return</span> (q - p) ; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.mk &amp;&amp; q.mk) &#123; q.mk = <span class="number">0</span> ; <span class="keyword">return</span>(p - q) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] + q.v[i] ;</span><br><span class="line">        res.len = p.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &gt;= Base)</span><br><span class="line">                res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ; res.len = A.len + B.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= B.len ; ++ j)</span><br><span class="line">                res.v[i + j - <span class="number">1</span>] += A.v[i] * B.v[j] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res.len + <span class="number">10</span> ; ++ i)</span><br><span class="line">            res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">div2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            v[i - <span class="number">1</span>] += (v[i] % <span class="number">2l</span>l) * Base, v[i] &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        v[<span class="number">0</span>] &gt;&gt;= <span class="number">1</span> ; <span class="keyword">while</span>(v[len] == <span class="number">0</span>) len -- ;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">mul2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) &#123;</span><br><span class="line">            v[i] = v[i] * <span class="number">2</span> + r, r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= Base) &#123;</span><br><span class="line">                r = v[i] / Base, v[i] %= Base ;</span><br><span class="line">                <span class="keyword">if</span> (i == len) len ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Big_Num <span class="keyword">friend</span> <span class="title">gcd</span><span class="params">(Big_Num A, Big_Num B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!(A ^ B))&#123;</span><br><span class="line">            <span class="keyword">if</span> (A &lt; B) swap(A, B) ;</span><br><span class="line">            <span class="keyword">bool</span> a = A.v[<span class="number">1</span>] &amp; <span class="number">1</span>, b = B.v[<span class="number">1</span>] &amp; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!a &amp;&amp; !b) A.div2(), B.div2(), ++ cnt2 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!b) B.div2() ; <span class="keyword">else</span> <span class="keyword">if</span> (!a) A.div2() ; <span class="keyword">else</span> A = A - B ;</span><br><span class="line">        &#125;</span><br><span class="line">        Big_Num tmp, pmt ;</span><br><span class="line">        tmp.set_v(<span class="number">2</span>), pmt.set_v(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (cnt2)&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt2 &amp; <span class="number">1</span>)</span><br><span class="line">pmt = pmt * tmp ;</span><br><span class="line">tmp = tmp * tmp ; cnt2 &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> (A = A * pmt) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Big_Num g, t ;</span><br><span class="line">Big_Num l, r, mid, ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span>&#123;</span></span><br><span class="line">    Big_Num fz, fm ;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.reset() ;</span><br><span class="line">        fm.reset() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Big_Num t = fz ; fz = fm, fm = t ;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function">il <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        g = gcd(fz, fm) ; r.reset() ;</span><br><span class="line"><span class="keyword">int</span> lnr = fz.len - g.len ; l.reset() ; l.len = lnr  ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fz) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fz = ans ; l.reset() ;</span><br><span class="line">lnr = fm.len - g.len ; l.reset() ; l.len = lnr ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fm) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fm = ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.out_put() ;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'/'</span>) ;</span><br><span class="line">        fm.out_put() ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T son, T mum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son), fm.set_v(mum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *son, <span class="keyword">int</span> Lson, <span class="keyword">char</span> *mum, <span class="keyword">int</span> Lmum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son, Lson) ; fm.set_v(mum, Lmum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> + (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!A.fz.len &amp;&amp; !A.fm.len) <span class="keyword">return</span> B ;</span><br><span class="line">        <span class="keyword">if</span> (!B.fz.len &amp;&amp; !B.fm.len) <span class="keyword">return</span> A ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz + B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> - (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz - B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ;</span><br><span class="line">        res.fz = A.fz * B.fz ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fz = A.fz * B.fz ; res.fm = A.fm ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> &amp; (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ; res.fz = A.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r1, r2, r3, r0 ;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> A, B ;</span><br><span class="line">Frac res ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line">Frac Rp[N] ;</span><br><span class="line">Frac Pr[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">r0.set_v(<span class="number">1</span>, B) ;</span><br><span class="line">    r1.set_v(A, <span class="number">1</span>) ;</span><br><span class="line">Rp[<span class="number">0</span>].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">r2.set_v(B - A, <span class="number">1</span>) ;</span><br><span class="line">    m = <span class="built_in">strlen</span>(S + <span class="number">1</span>), Pr[m].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        base[i] = (<span class="keyword">bool</span>)(S[i] == <span class="string">'H'</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = m ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">        Pr[j - <span class="number">1</span>] = Pr[j] ^ (base[j] ? r1 : r2) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j) Rp[j] = Rp[j - <span class="number">1</span>] &amp; r0 ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">        <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    t.reset() ; t.set_v(<span class="number">1</span>) ;</span><br><span class="line">    r3 = Pr[<span class="number">0</span>] * Rp[m] ; r3.reverse() ; <span class="keyword">int</span> k = m ;</span><br><span class="line">    <span class="keyword">while</span> (m) res = res + Pr[m] * Rp[k - m] , m = f[m] ;</span><br><span class="line">res = res * r3 ; res.div() ; res.out_put() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[来源保密的比赛 1A] Probability</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> base ;</span><br><span class="line"><span class="keyword">int</span> F[M] ;</span><br><span class="line"><span class="keyword">int</span> f[M] ;</span><br><span class="line"><span class="keyword">int</span> G[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, x ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x ; inv[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = qr(), add(sum, <span class="number">1l</span>l * F[i]) ;</span><br><span class="line">    sum = expow(sum, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = <span class="number">1l</span>l * F[i] * sum % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = <span class="number">1l</span>l * n * F[i + <span class="number">1</span>] % P * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        inv[i] = (<span class="number">-1l</span>l * inv[P % i] * (P / i) % P) + P;</span><br><span class="line">    base = expow(F[<span class="number">0</span>], P - <span class="number">2</span>) ; G[<span class="number">0</span>] = expow(F[<span class="number">0</span>], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; i + j &lt; x &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            add(tmp[i + j], <span class="number">1l</span>l * f[j] * G[i] % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i - j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            dec(tmp[i], <span class="number">1l</span>l * g[i - j] * F[j] % P) ;</span><br><span class="line">        g[i] = <span class="number">1l</span>l * base * tmp[i] % P ;</span><br><span class="line">        G[i + <span class="number">1</span>] = <span class="number">1l</span>l * g[i] * inv[i + <span class="number">1</span>] % P ;</span><br><span class="line">        add(ans, <span class="number">1l</span>l * i * G[i] % P) ; dec(res, G[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="number">1</span> ; add(ans, <span class="number">1l</span>l * res * x % P) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[SDOI2017] 硬币游戏</span></span><br><span class="line"><span class="comment">//long double 确实很慢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Base = <span class="number">233</span> ;</span><br><span class="line"></span><br><span class="line">ldb val[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line">ldb ans[N] ;</span><br><span class="line">ldb f[N][N] ;</span><br><span class="line"><span class="keyword">char</span> s[N][N] ;</span><br><span class="line"><span class="keyword">int</span> _hs[N][N] ;</span><br><span class="line"><span class="keyword">bool</span> match[N][N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decn(_hs[t][r], <span class="number">1l</span>l * _hs[t][l - <span class="number">1</span>] * pos[r - l + <span class="number">1</span>] % P) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    pos[<span class="number">0</span>] = val[<span class="number">0</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        val[i] = val[i - <span class="number">1</span>] * <span class="number">2.0</span> ;</span><br><span class="line">        pos[i] = <span class="number">1l</span>l * pos[i - <span class="number">1</span>] * Base % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            _hs[i][j] = ((ll)_hs[i][j - <span class="number">1</span>] * Base % P + s[i][j]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                match[i][j][k] = (<span class="keyword">bool</span>)(ask(i, <span class="number">1</span>, k) == ask(j, m - k + <span class="number">1</span>, m)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                f[i][j] += (db)match[i][j][k] * val[k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[n + <span class="number">1</span>][i] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][n + <span class="number">1</span>] = - <span class="number">1.0</span> ; f[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    gauss(n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7Lf\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的…就先鸽着吧，感觉除了复习高消之外也没啥好写的了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这文章真是莫名其妙的写了好几天，可能是题目钛毒瘤了导致经常出现思维掉线的局面…</p><p>其中比较多题目的都是杨懋龙前辈论文里的，自己学习了一下，顺便加上了一些自己的心得。</p><p>这可能就是…执念吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是最近的研究成果吧？&lt;/p&gt;
&lt;p&gt;「学不会的生成函数」+「学不会的概率论」= &lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="组合计数/概率型生成函数(PGF)" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A6%82%E7%8E%87%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-PGF/"/>
    
  </entry>
  
  <entry>
    <title>【UR#3】链式反应</title>
    <link href="https://www.orchidany.cn/2020/05/02/UR50%E9%93%BE%E5%BC%8F%E5%8F%8D%E5%BA%94/"/>
    <id>https://www.orchidany.cn/2020/05/02/UR50链式反应/</id>
    <published>2020-05-02T13:08:39.000Z</published>
    <updated>2020-05-09T07:25:38.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道读题就很麻烦的题目，以下是简化版的题面：</p><blockquote><p>给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：</p><p>1、父亲节点的标号大于子节点。</p><p>2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。</p><p>3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。</p><p>$1\leq n\leq 2\cdot 10^5$ 。</p></blockquote><a id="more"></a><p>考虑暴力 $dp$ ，设状态 $f_i$ 表示以 $i$ 为根时树的数量。那么有</p><script type="math/tex; mode=display">f_{i}=\sum_{j}\sum_{k}\binom{i-1}{j}\cdot\binom{i-j-1}{k}\cdot f_j\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>但是注意到由于 $\alpha$ 型儿子是无序的，所以应该乘一个 $\frac{1}{2}$ 的常数。于是就可以获得一个 $40$ 分的 $O(n^3)$ 做法。</p><p>注意到可以把 $j$ 和 $k$ 分离，变成</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot \sum_{j}\binom{i-1}{j}\cdot f_j\cdot\sum_{k}\binom{i-j-1}{k}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>展开两个二项系数</p><script type="math/tex; mode=display">\begin{aligned}f_{i}&=\frac{1}{2}\cdot \sum_{j}\frac{(i-1)!}{j!\cdot (i-j-1)!}\cdot f_j\cdot\sum_{k}\frac{(i-j-1)!}{k!\cdot (i-j-k-1)!}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]\\&=\frac{1}{2}\cdot (i-1)!\cdot \sum_{j}\frac{f_j}{j!}\cdot\sum_{k}\frac{f_k}{k!}\cdot \frac{[(i-j-k-1)\in \mathbb{A}]}{(i-j-k-1)!}\\\end{aligned}</script><p>因为每次本质上只关心 $i-1-(j+k)$ 是否是 $\mathbb A$ 中的元素，所以即通过维护一个 $g$ </p><script type="math/tex; mode=display">g_i= \sum_{j+k=i}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}</script><p>然后转移就可以</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p}{g_p\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>这样就是 $O(n^2)$ 的了。可以喜提 $60pts$ 。</p><p>考虑放到同一个式子里观察：</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p\leqslant i-1}\sum_{j+k=p}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}{\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>那么如果设 $\mathbf{F}_i=\dfrac{f_i}{i!},\mathbf{P}_i=\dfrac{[i\in \mathbb{A}]}{i!}$，可以发现原式就是一个卷积的形式：</p><script type="math/tex; mode=display">2\cdot i\cdot \mathbf{F}_i=\sum_{2\leqslant j+k\leqslant i-1} \mathbf{F}_j\cdot \mathbf{F}_k\cdot \mathbf{P}_{i-j-k-1}</script><p>此时有两种不同的做法：</p><h2 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h2><p>即发现本质上是在解一个这样的微分方程</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} x}\mathbf{F}=\frac{1}{2}\cdot \mathbf{F}^2\mathbf{P}+1</script><p>然后迭就完了。复杂度 $O(n\log n)$ 但是常数…有点可怕。</p><h2 id="技巧分治"><a href="#技巧分治" class="headerlink" title="技巧分治"></a>技巧分治</h2><p>这式子看上去就…十分的分治 FFT？但是注意到这是二卷积的形式。考虑最简单的分治 FFT 是单卷积，进行的操作可以看作是时间轴上的二进制拆分，即每次用已经得到实际结果的 $f_{l,l+1\cdots mid}$ 去更新 $f_{mid+1,mid+2\cdots r}$ 。考虑二卷积的时候，本质上与单卷积相同， 但需要分类讨论：</p><p>1、$l=1$ 时。</p><p>此时就是 $\mathbf{F}_{1…mid}^2$ 和 $\mathbf{P}_{0…r-l+1}$ 卷在一起。注意 $\mathbf{F}$ 中根据组合意义不能取第 $0$ 项。</p><p>2、$l&gt;1$ 时。</p><p>发现此时由于分治了之后，要保证复杂度，似乎会出现需要用到 $i&gt;mid$ 的 $f_i$ 的情况——但根据分治策略，此时一定有 $2\cdot l&gt;r$ ，也就是 $\forall i\in[l,mid]\cap\mathbb{Z_+}$ ，$i&gt;r-l-1\Longrightarrow r-i<l-1$ 。那么就代表着需要的元素都已经 $l$ 之前被求出了准确值，所以此时不需要考虑 $i>mid$ 的那些转移点。所以此时就直接拿 $\mathbf{F}_{1…r-l}$ 卷上 $\mathbf{F}_{l…mid}$ 和 $\mathbf{P}_{1..r-l}$ 即可。注意到此时有别于 $l=1$ ，对于两棵子树的不同形态本质没有算重。所以为了处理方便可以在此时乘一个 $2$ 。</p><p>于是这种分治方式就比其他朴素的分治多一个比较优的常数。现在跑到了<a href="http://uoj.ac/problem/50/statistics" target="_blank" rel="noopener">uoj榜</a>的第一页。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll g[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll inv[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inv_2 = <span class="number">499122177</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * x % P ;</span><br><span class="line">        x = (ll)x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[n + <span class="number">1</span>] = expow(fac[n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1l</span>l) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, o ; k &lt;= i - j - <span class="number">1</span> ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (base[i - j - k - <span class="number">1</span>])&#123;</span><br><span class="line">                    o = comb(i - <span class="number">1</span>, j) ;</span><br><span class="line">                    o = <span class="number">1l</span>l * o * comb(i - j - <span class="number">1</span>, k) % P ;</span><br><span class="line">                    add(f[i], <span class="number">1l</span>l * o * f[j] % P * f[k] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; g[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i - j - <span class="number">1</span>])</span><br><span class="line">                add(f[i], <span class="number">1l</span>l * g[j] * inv[i - j - <span class="number">1</span>] % P) ;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            add(g[i], <span class="number">1l</span>l * f[i - j] * f[j] % P * inv[i - j] % P * inv[j] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">    <span class="keyword">int</span> k, d ;</span><br><span class="line">    <span class="keyword">int</span> rev[N] ;</span><br><span class="line">    ll g[<span class="number">20</span>][N] ;</span><br><span class="line">    <span class="function">il ll <span class="title">expow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = ret * x % P ;</span><br><span class="line">            x = x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_rt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; ++ i)&#123;</span><br><span class="line">            ll* r = g[i], ut ; r[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            ut = r[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) r[j] = r[j - <span class="number">1</span>] * ut % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(T *f, <span class="keyword">int</span> L, <span class="keyword">bool</span> mk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ l)&#123;</span><br><span class="line">            ll *r = g[l], o = i &lt;&lt; <span class="number">1</span>, rt, irt ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += o)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt; i + j ; ++ k)&#123;</span><br><span class="line">                    rt = f[k], irt = f[k + i] * r[k - j] % P ;</span><br><span class="line">                    f[k] = addn(rt, irt), f[k + i] = decn(rt, irt) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mk) <span class="keyword">return</span> ;</span><br><span class="line">        reverse(f + <span class="number">1</span>, f + L) ;</span><br><span class="line">        <span class="keyword">int</span> o = expow(L, P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) (f[i] *= o) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        d = <span class="number">1</span>, k = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (d &lt;= x) d &lt;&lt;= <span class="number">1</span>, ++ k ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (k - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tl[N] ;</span><br><span class="line">    ll tr[N] ;</span><br><span class="line">    ll tmid[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span>) f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> f[l] = expow(<span class="number">2</span> * l, P - <span class="number">2</span>) * f[l] % P ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = r - l + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> len1 = mid - l + <span class="number">1</span> ;</span><br><span class="line">        cdq(l, mid) ; getlen(len * <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tr[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) add(f[i], tl[i - l]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tmid + <span class="number">1</span>, f + <span class="number">1</span>, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tmid + len + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            tmid[<span class="number">0</span>] = tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tmid, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tmid[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)</span><br><span class="line">                add(f[i], <span class="number">2l</span>l * tl[i - l] % P) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cdq(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1lld"</span>, &amp;base[i]) ; pre_do() ;</span><br><span class="line">    Poly :: pre_rt() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        base[i] = base[i] * inv[i] % P ;  <span class="comment">//debug(base, 0, n - 1) ;</span></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; Poly :: cdq(<span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i] * fac[i] % P) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道读题就很麻烦的题目，以下是简化版的题面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：&lt;/p&gt;
&lt;p&gt;1、父亲节点的标号大于子节点。&lt;/p&gt;
&lt;p&gt;2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。&lt;/p&gt;
&lt;p&gt;3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq 2\cdot 10^5$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】正睿5.1省选集训</title>
    <link href="https://www.orchidany.cn/2020/05/01/ZR5-1/"/>
    <id>https://www.orchidany.cn/2020/05/01/ZR5-1/</id>
    <published>2020-05-01T11:05:53.000Z</published>
    <updated>2020-05-09T07:25:01.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>被爆锤，生活失去希望了（雾）。</p><p>这波被揍的很彻底，也激发了我的斗志(发现自己前两个月真是比咸鱼还咸鱼)。</p><p>啊啊啊啊凭什么我这么菜！冲冲冲！</p><p>这次的题是小象出的。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>有一个随机变量 $z$, 初始 $z=0$.</p><p>执行 $n$ 次操作: 每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:=z+t$ 。</p><p>求 $\min(z,x)$ 的期望. 答案模 $998244353$. </p><p>$k\leq 100,n\leq 10^9,x\leq \min\{10^7,\frac{5\times 10^7}{k}\}$ 。</p></blockquote><p>……自闭就完事了。</p><p>赛时觉得这是个期望推式子题，于是化了一波 $\min(z,x)$ :</p><script type="math/tex; mode=display">E(\min(z,x))=\frac{1}{2}\left(E(x)+E(z)+E(|x-z|)\right)</script><p><del>嗯，十分有道理，但是我还是不会x</del></p><p>赛后慎老师告诉我 $40$ 分可以直接背包。我想了想，觉得自己可能给这个班丢脸了…</p><p>然后考虑正解。设选择整数的概率型生成函数为 $P(y)=\sum_{i=0}^kp_i$ ，那么取了 $n$ 次之后的概率型生成函数就是 $Q(y)=P^n(y)$ 。</p><p>那么不难知道答案为</p><script type="math/tex; mode=display">\sum_{i=0}^{n\times k} [y^i]Q\cdot \min(x,i)=\sum_{i=0}^{x-1} [y^i]Q\cdot i + \left(1-\sum_{i=0}^{x-1} [y^i]Q\right)\cdot x</script><p>呃…虽然没学过 PGF 到底怎么化，但是概率上求 $z$ 补集就是 $1-z$ 还是比较 xxs 的结论吧…</p><p>然后现在问题就集中在怎么求 $P^n(y)$ 的前 $k$ 项了。发现可以暴力多项式快速幂，以获得 $40\sim 60$ 左右的成绩。</p><p>然后是神奇的多项式技巧…大概是考虑对于 $P^{n+1}(y)$ 求导有两种方式：</p><script type="math/tex; mode=display">\left(P^{n+1}(y)\right)^{\prime}=(n+1) P^{n}(y) P^{\prime}(y)\\\left(P^{n+1}(y)\right)^{\prime}=\left(P^{n}(y)\right)^{\prime} P(y)+P^{n}(y) P^{\prime}(y)</script><p>第一个就是链式法则，第二个则是拆出一个 $P(y)$ 来再用求导的乘法运算法则。</p><p>考虑联立之后</p><script type="math/tex; mode=display">nP^n(y)(P(y))'=(P^n(y))'P(y)</script><p>然后考虑现在的问题是，已知了 $P^n(y)$ 的前几项系数，求出后面的系数。考虑一个这样的思路：每次先求出 $(P^n(y))’$ 的第 $d$ 项，然后积分出 $P^n(y)$ 的第 $d+1$ 项。发现每个 $[y^d]P^n(y)$ 只会对 $y^d\sim y^{d+k}$ 这些产生贡献，所以考虑枚举到一个 $d$ 的时候向后刷表；考虑这样求出的是 $(P^n(y))’P(y)$ ，直接模拟多项式除法即可得到 $(P^n(y))’$ ，这样做也是单次 $O(k)$ 的。</p><p>对于多项式除法这部分，可以考虑对于每个 $<a href="P^n(y">y^d</a>)’P(y)$ 都是这么计算得到的：</p><script type="math/tex; mode=display">\sum_{p=0}^k[y^p]P(y)\times [y^{d-p}](P^n(y))'</script><p>然后就减去所有的 $p&gt;0$ 的那些结果，最后乘上一个 $[x^0]P(y)$ 的逆元即可。</p><p>草，这还是我第一次做概率生成函数……我觉得我的正睿 rating 已经不(都)重(掉)要(没)了，所以就当学新东西了吧…</p><p>这份代码截止在我交上去的时候还是全站速度 rank4，想了想觉得可能是线性求逆元立了功。于是顺便复习一下线性求逆元：</p><p>考虑模数是 $m$，那么设 $m=p\cdot x+r$，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}p\cdot x+r&\equiv 0\pmod m\\p\cdot r ^{-1}+x^{-1}&\equiv 0 \pmod m\\x^{-1}&\equiv -\lfloor\frac{m}{x}\rfloor\cdot (m\bmod x)^{-1}\pmod m\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> base ;</span><br><span class="line"><span class="keyword">int</span> F[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> G[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, x ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x ; inv[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = qr(), add(sum, <span class="number">1l</span>l * F[i]) ;</span><br><span class="line">    sum = expow(sum, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = <span class="number">1l</span>l * F[i] * sum % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = <span class="number">1l</span>l * n * F[i + <span class="number">1</span>] % P * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        inv[i] = (<span class="number">-1l</span>l * inv[P % i] * (P / i) % P) + P;</span><br><span class="line">    base = expow(F[<span class="number">0</span>], P - <span class="number">2</span>) ; G[<span class="number">0</span>] = expow(F[<span class="number">0</span>], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; i + j &lt; x &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            add(tmp[i + j], <span class="number">1l</span>l * f[j] * G[i] % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i - j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            dec(tmp[i], <span class="number">1l</span>l * g[i - j] * F[j] % P) ;</span><br><span class="line">        g[i] = <span class="number">1l</span>l * base * tmp[i] % P ;</span><br><span class="line">        G[i + <span class="number">1</span>] = <span class="number">1l</span>l * g[i] * inv[i + <span class="number">1</span>] % P ;</span><br><span class="line">        add(ans, <span class="number">1l</span>l * i * G[i] % P) ; dec(res, G[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="number">1</span> ; add(ans, <span class="number">1l</span>l * res * x % P) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>用从小到大逐位确定的方法生成一个由 $n$ 个 $0$, $n$ 个 $1$ 组成的随机 $01$ 串 $s$ :</p><p>如果当前已经生成了 $n$ 个 $0$ 或 $1$，新生成的位一定对应地为 $1$ 或 $0$ ; 否则以 $50\%$ 的概率生成 $0$, $50\%$ 的概率生成 $1$.</p><p>有 $q$ 组询问, 每组询问给 $k$ 个数 $a_1,a_2,⋯,a_k$ 求 $s_{a_1}=s_{a_2}=⋯=s_{a_k}$ 的概率. 答案模 $998244353$.</p><p>$n\leq 2\times 10^5,q\leq 2\times 10^5,\sum k \leq 2\times 10^5$</p></blockquote><p>我对概率这东西有时候真的很迷…有时候可以直接算，有时候不可以…自己还是太弱菜。本来打算如果可以过省选，就系统地学一下概率论…现在可能是不可能了。</p><p>记字符串中最后一个出现的 <code>1</code> 的位置为 $a$，<code>0</code> 的位置为 $b$ ，那么该字符串存在的概率就是 $\dfrac{1}{2^{\min\{a,b\}}}$。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>记 $s$ 为前 $n$ 个字母的集合 $\{a,b,c,⋯\}$。</p><p>将 $s$ 中所有大小不超过 $k$ 的非空子集划分成尽量少的组, 使得:</p><p>1、每个子集恰好在一个组中.</p><p>2、对于同一组的任意两个子集, 他们的交为空.</p><p>3、每组的所有集合大小之和不超过 $k$.</p><p>$1\leq k\leq n\leq 17$ 。</p></blockquote><p>我怀疑象故意卡 dfs…因为所有点里面最小的两个点是 $n=6,k=4$ 和 $n=6,k=5$。但是我写的 dfs 只能算到 $n=6,k=3$…$n=6,k=4$ 跑了一整场比赛都没跑出来…</p><p>不会带花树和 Hull 定理，于是决定先咕咕咕了，留下一份 dfs 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> Id[M] ;</span><br><span class="line"><span class="keyword">int</span> sz[M] ;</span><br><span class="line"><span class="keyword">int</span> siz[M] ;</span><br><span class="line"><span class="keyword">int</span> sum[M] ;</span><br><span class="line"><span class="keyword">int</span> subs[M] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; res[M] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; base[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; x) <span class="built_in">putchar</span>(<span class="string">'a'</span> + i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; s)&#123;</span><br><span class="line">            ans = s ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s ; ++ i) res[i] = base[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="number">1</span>, t = s + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= s ; ++ j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[j] &amp; subs[y]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (sum[j] + sz[subs[y]] &gt; k) <span class="keyword">continue</span> ;</span><br><span class="line">        base[j][y] = <span class="number">1</span> ; siz[j] |= subs[y] ; sum[j] += sz[subs[y]] ;</span><br><span class="line">        dfs(x + <span class="number">1</span>, s) ;</span><br><span class="line">        base[j][y] = <span class="number">0</span> ; siz[j] ^= subs[y] ; sum[j] -= sz[subs[y]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    base[t][y] = <span class="number">1</span> ; siz[t] = subs[y] ; sum[t] = sz[subs[y]] ;</span><br><span class="line">    dfs(x + <span class="number">1</span>, t) ; base[t][y] = <span class="number">0</span> ; siz[t] = sum[t] = <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sz[i] = sz[i - (i &amp; -i)] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt;= k) subs[Id[i] = ++ cnt] = i ;</span><br><span class="line">    ans = m + <span class="number">1</span> ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= ans ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i].count() &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (res[i][j]) output(subs[j]), <span class="built_in">putchar</span>(<span class="string">' '</span>) ;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得我可能是真的不会 dfs…这一个 dfs 调了我快 90min…还是太不认真了啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被爆锤，生活失去希望了（雾）。&lt;/p&gt;
&lt;p&gt;这波被揍的很彻底，也激发了我的斗志(发现自己前两个月真是比咸鱼还咸鱼)。&lt;/p&gt;
&lt;p&gt;啊啊啊啊凭什么我这么菜！冲冲冲！&lt;/p&gt;
&lt;p&gt;这次的题是小象出的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZhengRuiOI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZhengRuiOI/"/>
    
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="组合计数/概率型生成函数(PGF)" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A6%82%E7%8E%87%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-PGF/"/>
    
  </entry>
  
  <entry>
    <title>【复习】概率期望复习笔记</title>
    <link href="https://www.orchidany.cn/2020/05/01/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B2/"/>
    <id>https://www.orchidany.cn/2020/05/01/概率期望2/</id>
    <published>2020-05-01T05:16:36.000Z</published>
    <updated>2020-05-07T07:56:27.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>胡乱整理了有关期望的一些东西。</p><p>为什么自己老是学了就忘呢……</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么“所有情况的概率加权平均值blabla”，一般用处不大？</p><p>或者形式化一点，$ \rm \mathbb{E}(X)=\sum_i(~\Pr(X=i)\cdot i~) $</p><h1 id="期望的线性性"><a href="#期望的线性性" class="headerlink" title="期望的线性性"></a>期望的线性性</h1><p>唔，这个地方其实应用是很广泛的。大概就是对于两个事件 $\rm X,Y$，$\rm \mathbb{E}(aX+bY)=aE(X) +bE(Y)$ 。</p><p>对于这东西的证明大概如下：</p><script type="math/tex; mode=display">\begin{aligned}  \mathbb{E}(\mathrm{\mathrm{X}}+\mathrm{Y}) & {=  \sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)\cdot(i+j)} \\ & {  =\sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j) \cdot i+\sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)  \cdot j} \\ &{ =\sum_{i} i \cdot  \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)  \cdot j+\sum_{i} j \cdot  \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j) \cdot  i} \\ & { =\sum_{i} \Pr (\mathrm{X}=i) \cdot  i+\sum_{j} \Pr (\mathrm{Y}=j) \cdot  j} \\ & { =\mathbb{E}(\mathrm{\mathrm{X}})+\mathbb{E}(\mathrm{Y})}\end{aligned}</script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="期望经典模型"><a href="#期望经典模型" class="headerlink" title="期望经典模型"></a>期望经典模型</h1><h2 id="容斥模型"><a href="#容斥模型" class="headerlink" title="容斥模型"></a>容斥模型</h2><blockquote><p>有 $n$ 个随机变量 $\rm X[1…n]$，每个随机变量都是从 $\rm 1…S$ 中 随机一个整数，求 $\rm max(X[1…n])$ 的期望。 </p></blockquote><p>根据期望的线性性可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\rm \mathbb{E}& =\sum _{i=1}^{\mathrm{S}}\Pr(\max=i)\times i\\\ & =\sum _{i=1}^{\mathrm{S}}i\cdot (\Pr(\max\leq i)-\Pr(\max\leq i-1))\\ &  = \sum_{i=1}^{\mathrm{S}}i\cdot \left(\left(\dfrac{i}{\mathrm{S}}\right)^n - \left(\dfrac{i-1}{\mathrm{S}}\right)^n\right)\end{aligned}</script><p>这个容斥技巧好像还是挺常见的吧？</p><h2 id="等价模型"><a href="#等价模型" class="headerlink" title="等价模型"></a>等价模型</h2><p>实际上是取球问题，大概思路就是取每一个球是<strong>独立</strong>的，这一点在期望的线性性上体现得比较明显：</p><h3 id="放球问题-I"><a href="#放球问题-I" class="headerlink" title="放球问题 I"></a>放球问题 I</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后<strong>不放回</strong>，求取出的数字之和的期望 。</p></blockquote><p>还是期望的线性性：</p><script type="math/tex; mode=display">\mathbb{E}\left(\sum_{i=1}^{n} X_{i}\right)=\sum_{i=1}^{n} \mathbb{E}\left(X_{i}\right)=\sum_{i=1}^{n} \Pr(X=i) \times i=\sum_{i=1}^{n} \dfrac{m}{n} \times i=\dfrac{m}{n} \sum_{i=1}^{n} i=\dfrac{m}{n} \times \dfrac{n(n+1)}{2}=\dfrac{m(n+1)}{2}</script><p>这个地方个人理解的为什么 $\Pr(X=i)=\dfrac{m}{n}$，是考虑首先显然每个球平等，且摸到之后贡献为 $1$，所以可以知道有 $\sum_{i=1}^{n}\mathbb{E}(X=i)=m$，那么由于每个球都一样，所以 $\Pr(X=i)=\mathbb{E}(X=i)=\dfrac{m}{n}$。</p><h3 id="放球问题-II"><a href="#放球问题-II" class="headerlink" title="放球问题 II"></a>放球问题 II</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后<strong>放回</strong>，求取出的数字之和的期望 。</p></blockquote><p>考虑无论放回不放回，拿到 $i$ 的概率都是 $\dfrac{1}{n}\times m$ ，所以和第一问结果一样。</p><h3 id="放球问题-III"><a href="#放球问题-III" class="headerlink" title="放球问题 III"></a>放球问题 III</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后以 $p_1$ 的概率放回，以 $p_2$ 的概率放回两个和这个相同的球，求取出的数字之和的期望。</p></blockquote><p>这个地方可能有点绕。但是就是“球球平等”的思想。虽然有点难理解，但是考虑 问题 I 中我们推导的过程只用了「球球平等」这一条，所以可知这样也是对的。</p><h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><p>…就是游走模型。大概就是说假设一个点的出度为 $k$，他么他有 $\dfrac{1}{k}$ 的概率走到周围其他点。</p><h3 id="链上游走"><a href="#链上游走" class="headerlink" title="链上游走"></a>链上游走</h3><blockquote><p>在一条 $n$ 个点的链上随机游走，求从一段端走到另一端的期望步数</p></blockquote><p>考虑分阶段进行。根据线性性，$ \mathbb{E}(T)=\sum_{i=1}^{n-1} \mathbb{E}(X_i)$。其中 $\mathbb{E}(X_i)$ 表示从 $i$ 第一次走到 $i+1$ 的期望步数。</p><p>然后我们列方程，考虑一步转移走到了 $ i+1$ 还是 $i-1$ ：  </p><script type="math/tex; mode=display">\mathbb{E}(X_i)=\dfrac{1}{2}+\dfrac{1}{2}\cdot(1+\mathbb{E}(X_i)+\mathbb{E}(X_i-1))</script><p>解出来得</p><script type="math/tex; mode=display">\mathbb{E}(X_i)=2+\mathbb{E}(X_i-1)</script><h3 id="完全图游走"><a href="#完全图游走" class="headerlink" title="完全图游走"></a>完全图游走</h3><blockquote><p>在一个 $n$ 个点的完全图上游走，求从一个点到另一个点期望步数。 </p></blockquote><p>完全图的话，每个点走到每个点的概率都是 $\dfrac{1}{n-1}$。于是这个题就有好多种不同的解法，比如用一个推论“概率为 $P$ 的事件期望 $\dfrac{1}{P}$ 次后发生”，就可以直接证明 $\mathbb{E}(t) = n-1$。</p><h3 id="完全二分图游走"><a href="#完全二分图游走" class="headerlink" title="完全二分图游走"></a>完全二分图游走</h3><blockquote><p>在一个 $2n$ 个点的完全二分图上游走，求一个点走到另一个点的期望步数。</p></blockquote><p>解方程的思想，分类讨论是在同侧还是异侧。</p><p>记 $\mathbb{E}_a$ 表示在同侧的期望步数， $\mathbb{E}_b$ 表示在异侧的期望步数。那么考虑有：</p><script type="math/tex; mode=display">\mathbb{E}_a=\mathbb{E}_b+1\\\mathbb{E}_b=\dfrac{1}{n}+\dfrac{n-1}{n}\cdot(\mathbb{E}_a+1)</script><p>然后解出来 $\mathbb{E}_b=2\cdot n-1,\mathbb{E}_a=2\cdot n$ …为什么感觉很不对的样子呢…但是这么列方程肯定是没错的。 </p><h3 id="菊花图游走"><a href="#菊花图游走" class="headerlink" title="菊花图游走"></a>菊花图游走</h3><blockquote><p>在一张 $n$ 个点的菊花图上游走，求从根走到另一个点的期望步数。</p></blockquote><p>考虑一共有三种情况：</p><p>1、叶子走到根 $\mathbb{E}(a)=1$ 。</p><p>2、根走到叶子 $\mathbb{E}(b)=\dfrac{1}{n-1}+\dfrac{n-2}{n-1}\times (\mathbb{E}(c)+1)$。</p><p>3、叶子走到叶子 $\mathbb{E}(c)=1+\mathbb{E}(b)$。</p><p>解方程可以得到 $，$$\mathbb{E}(b)=2\cdot n-3,\mathbb{E}(c)=2\cdot 2-2$ 。</p><h3 id="树上游走"><a href="#树上游走" class="headerlink" title="树上游走"></a>树上游走</h3><blockquote><p>在一棵 $n$ 个点的树上游走，问从根走到 $x$ 的期望步数。</p></blockquote><p>唔，其实有好多不同版本，也可以就是从 $y$ 走到 $x$ 的期望步数，因为游走问题是不存在有根树的，所以直接把 $y$ 拽起来当根也没什么问题。然后就是考虑链做法里面的思想，设 $f_u$ 表示 $u$ 第一次走到他父亲的期望步数，然后就有方程</p><script type="math/tex; mode=display">f_u=\dfrac{1}{deg_u}+\dfrac{1}{deg_u}\sum_{v\in son _u}(1+f_u+f_x)</script><p>前者是走上去的，后者是不小心走下去的。然后期望的线性性加起来即可。</p><p><del>然后就是高消时间了</del></p><p>呃，或许这个是可以 up and down 的？好像不行，我傻了。</p><h1 id="期望思考题"><a href="#期望思考题" class="headerlink" title="期望思考题"></a>期望思考题</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>构造一张 $200$ 个点的无向图，使得上面从 $\rm S$ 走到 $\rm T$ 的随机游走期望步数 $\geq 100,0000$。</p></blockquote><p>考虑是一条链的时候大概有 $O(n^2)$ 的期望步数，在一张完全图上有 $O(n)$ 的期望步数，于是就可以考虑在 $\rm S$ 上连出一张 $100$ 个点的完全图，然后在一条链连到 $T$，就是 $n^3$ 的期望步数。具体实现似乎需要微调的亚子233.</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（1）</p><blockquote><p>随机一个长度为 $n$ 的排列 $p$，问前 $i$ 个数字中 $p_i$ 是最大数字的概率。</p></blockquote><p>…算都不用算就知道是$\dfrac{1}{i}$ 。</p><p>（2）</p><blockquote><p>随机一个长度为 $n$ 的排列 $p$，问前 $i$ 个数字中 $p_i$ 是最大数字的 $i$ 的个数的平方的期望。</p></blockquote><p>首先设 $x_i$ 表示第 $i$ 个数是不是前 $i$ 个数中最大的数字，那么 $x_i=0/1$。那么总个数 $\rm S=\it\sum x_i$，总个数的平方的期望就是 $\mathrm{\mathbb{E}(S^2)}=\mathrm{ E}((\sum x_i)^2)$，之后就开始化式子：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{\mathbb{E}(S^2)}&= \mathrm{E}((\sum x_i)^2)\\ &=\mathrm{E}( \sum x_i^2+\sum_{i\neq j}x_ix_j)\\ &=\mathrm{E}(\sum x_i^2)+\mathrm{E}(\sum_{i\neq j}x_ix_j)\end{aligned}</script><p>以上用的都是期望的线性性。然后最后考虑用（1）中的结论，$\Pr(x_i=1)=\dfrac{1}{i}$，就可以得到：</p><script type="math/tex; mode=display">\mathrm{\mathbb{E}(S^2)}= \sum_{i\neq j}\dfrac{1}{ij}+\sum \dfrac{1}{i^2}</script><p>这东西显然是有平凡的通项公式，但是懒得推了233。 </p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>随机一个 $1\sim n$ 的排列，求 $i$ 在 $j$ 前面的概率。</p></blockquote><p>这显然是 $\dfrac{1}{2}$ 。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（1）</p><blockquote><p>随机一个长度为 $n$ 的排列，求一个长为 $m$ 的 <strong>子序列</strong> $s[1…m]$ 在该排列中出现的概率。</p></blockquote><p>考虑对称性，$n$ 排列对 $m$ 序列随机，也可以看做 $m$ 序列对 $n$ 排列随机。其实怎么想无所谓——更直观的是考虑重排 $s$，对于每一个随机序列，都有且仅有一种 $s$ 的重排方式会在其中作为子序列。所以答案就是 $\dfrac{1}{m!}$ 。</p><p>（2）</p><blockquote><p>随机一个长度为 $n$ 的排列，求一个长为 $m$ 的<strong>连续子序列</strong> $s[1…m]$ 在该排列中出现的概率。</p></blockquote><p>思考同样的结论放在(2)里面到底多算了哪些情况。首先就是我们要乘上一个 $\dfrac{1}{\binom{n}{m}}$，因为现在不能从 $n$ 中随便选出 $m$ 个位置来放，只能选择相邻的 $m$ 项。但是这还不够，因为我们还少算了以每个元素开头的连续子序列情况，所以应该再乘上 $n-m+1$，于是答案就是</p><script type="math/tex; mode=display">\dfrac{n-m+1}{m!\binom{n}{m}}=\dfrac{n-m+1}{P_n^m}=\dfrac{(n-m+1)!}{n!}</script><p>说句题外话，从不等关系来讲，会有 $\dfrac{(n-m+1)!}{n!} \leq \dfrac{1}{m!}$，因为(2)的方案数一定小于等于(1)，那么(2)发生的概率一定小于等于(1)。然后移个项就会有 $(n-m+1)!m!\leq n!$ 这种东西；或者从组合意义上来讲，会有 $(n-m+1)!\leq \dfrac{n!}{m!}$，即“ $n-m+1$ 个不同元素的排列数小于等于从 $n$ 个不同元素里面选出 $n-m$ 个元素进行排列的方案数”。</p><p>By the way，当且仅当 $n=m$ 时等号成立。</p><p>呃，似乎并不是很有意思，我还以为能推出什么有意思的东西来着233</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>给一个序列，每次随机删一个元素，问第 $i$ 个元素和第 $j$ 个元素相邻的概率。</p></blockquote><p>然而是个组合题。</p><p>考虑每个数是什么时候被删除的，按删除顺序组成一个序列。因为是随机删除，所以删除序列也是随机的。接着考虑删除序列里面 $[i…j]$ 这段区间的排列总方案数是 $(j-i+1)!$，当且仅当 $[i+1…j-1]$ 都被删除且 $i,j$ 还没被删除时合法，这样的方案数是 $(j-i+1-2)!\cdot P_2^2$，于是概率就是</p><script type="math/tex; mode=display">\dfrac{2\cdot (j-i-1)!}{(j-i+1)!}</script><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>给定⼀棵树，将他的边随机⼀个顺序后依次插⼊，求 $u,v$ 期望什么时候连通。</p></blockquote><p>考虑两个点连通只与他们之间的边数有关。设这个数量为 $k$ ，可以知道答案为</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=k}^{n-1}i\cdot \dfrac{(n-1-k)!(k-1)!\binom{i-1}{k-1}}{(n-1)!}</script><p>即用线性性枚举「恰好第 $i$ 次连通」。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><blockquote><p>给 $1…n$ 这 n 个数，每次随机选择⼀个还在的数并且删掉他的所有约数，求期望⼏次删完</p></blockquote><p>跟 CF280C 那题本质上很相似。考虑一个数被删掉当且仅当他的倍数被删掉，同时只会有自己被删掉时产生 $1$ 的贡献，所以可以知道答案就是 $\mathbb{E}(X)=\sum \dfrac{1}{\lfloor\frac{n}{x}\rfloor}$ 。</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><blockquote><p>给定 $n$ 个硬币，第 $i$ 个硬币的价值为 $w_i$，每次随机取⾛⼀个硬币，获得的收益是左右两个硬币的价值的乘积，求期望总价值。</p></blockquote><p>想了一会儿之后发现是个弱智题。</p><p>考虑这个问题里面的单位决策数应该是 $O(n^2)$ 级别的二元组 $(i,j)$，也就是考虑对每一组 $(i,j)$ 分别算概率，发现这个概率就是 $i,i+1,i+2\cdots j$ 中随机删数，$[i+1,j-1]$ 在 $i,j$ 之前被删掉的概率，于是就可以直接算了。</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i,j} w_i\cdot w_j\cdot \Pr(i,j)=\sum_{i,j} w_i\cdot w_j\cdot \frac{(i-j-1)!}{(i-j+1)!}</script><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><blockquote><p>有 $n$ 个数 $a[1…n]$，每次等概率选出两个数，然后合并成⼀个新的数放回来，得到的收益是新的数的值，求总收益的期望。</p></blockquote><p>自然是考虑分别计算每个数期望被选到的次数。然后对这个东西用线性性展开可以知道，可以分别求每个数在每一次合并中被选到的概率，那么就是</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=1}^{n}\frac{2}{n-i-1}\cdot 1=\sum_{i=2}^n \frac{2}{i}</script><p>即每次选择两个堆合并、选到 $x$ 那个堆的概率。</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><blockquote><p>给定⼀个数列 $w[1…n]$，随机⼀个排列 $h$，如果 $h[i]$ ⽐ $h[i-1]$ 和 $h[i+1]$ 都⼤，就获得 $w[i]$ 的收益，求期望收益。</p></blockquote><p>自己想的方法是暴力组合，考虑用线性性展开之后，变成分别对每个数算自己成为最大值的概率，发现这个概率就是</p><script type="math/tex; mode=display">\Pr(X=\max)=\sum_{i=3}^n\frac{1}{n}\times \dfrac{\binom{i-1}{2}}{\binom{n-1}{2}}</script><p>然后可以展开得到</p><script type="math/tex; mode=display">\begin{aligned}\Pr(X=\max)&=\frac{1}{n\cdot (n-1)\cdot (n-2)}\cdot \sum_{i=3}^{n-1}(i-1) \cdot (i-2)\\&=\frac{1}{n\cdot (n-1)\cdot (n-2)}\cdot \sum_{i=1}^{n-3}i \cdot (i+1) \end{aligned}</script><p>然后一个比较神奇的事情，后面那个 $\sum$ 是有闭形式的。即：</p><script type="math/tex; mode=display">\sum_{i=1}^n(i+1)\cdot i=\frac{(n+1)\cdot (n+2)\cdot (n+3)}{3}</script><p>然后相乘之后可知…$\Pr(X=\max)$ 就是 $\frac{1}{3}$ 。实际上也可以从更感性的角度来理解，三个数里面，成为最大的数概率自然是 $\frac{1}{3}$ 。</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><blockquote><p>有 $n$ 个⿊球，$m$ 个⽩球，每次等概率取出⼀个球(不放回)，将取出来的球的颜⾊写成⼀个 $01$ 序列，求 <code>01</code> 的期望出现次数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">分值</th><th style="text-align:center">$\max\{n,m\}$</th><th style="text-align:center">特殊性质</th></tr></thead><tbody><tr><td style="text-align:center">$\rm Subtask1$</td><td style="text-align:center">$5$</td><td style="text-align:center">$\leqslant 20$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask2$</td><td style="text-align:center">$30$</td><td style="text-align:center">$\leqslant 300$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask3$</td><td style="text-align:center">$25$</td><td style="text-align:center">$\leqslant 5000$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask4$</td><td style="text-align:center">$10$</td><td style="text-align:center">$\leqslant 5\cdot 10^6$</td><td style="text-align:center">$n=m$</td></tr><tr><td style="text-align:center">$\rm Subtask5$</td><td style="text-align:center">$15$</td><td style="text-align:center">$\leqslant 10^6$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask5$</td><td style="text-align:center">$15$</td><td style="text-align:center">$\leqslant 10^{9}$</td><td style="text-align:center">\</td></tr></tbody></table></div></blockquote><h3 id="5pts-做法"><a href="#5pts-做法" class="headerlink" title="5pts 做法"></a>5pts 做法</h3><p>枚举所有可能的颜色排列，复杂度 $O(n\cdot 2^n)$。</p><h3 id="20pts-做法"><a href="#20pts-做法" class="headerlink" title="20pts 做法"></a>20pts 做法</h3><p>设 $X$ 表示出现次数，那么有</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=1}^{\min\{n,m\}}\Pr(X=i)\cdot i</script><p>考虑这个 $X=i$ 怎么算，本质上是求 $01$ 排列有多少种方案存在恰好 $i$ 个 <code>01</code>，也就只需要计算 $i$ 个相隔距离 $\geq 1$ 的 $0$ 的方案数。这个地方想了一会儿没找到什么闭形式，于是打算直接 $dp$ 。</p><p>设 $f_{i,j,k,0/1}$ 表示前 $i$ 位有 $j$ 个 $0$ ，其中有 $k$ 个 $01$ ，且第 $i$ 位放了 $0/1$ 的方案数，那么有转移</p><script type="math/tex; mode=display">f_{i+1,j,k+1,1}\leftarrow f_{i,j,k,0}\to f_{i+1,j+1,k,0}\\f_{i+1,j+1,k,0}\leftarrow f_{i,j,k,1}\to f_{i+1,j,k,1}\\</script><p>然后算就好了，时空复杂度均为 $O(n^3)$ 。</p><h3 id="60pts-做法"><a href="#60pts-做法" class="headerlink" title="60pts 做法"></a>60pts 做法</h3><p>发现继续沿用对着每个 $i$ 求贡献的做法。发现本质上就是从长为 $n+m$ 的序列里面选出 $i$ 个不相邻的 <code>0</code> 的方案数。考虑转化一下这个问题。首先可以转化成从 $1\sim n +m$ 里面选择 $i$ 个不相邻的数的方案数。之后考虑对于选出来的数 $a_1,a_2,a_3\cdots a_i$ ，从小到大排序后一定满足</p><script type="math/tex; mode=display">a_1<a_2-1<a_3-1<a_4-1< \cdots<a_{i}-1</script><p>考虑令 </p><script type="math/tex; mode=display">b_1=a_1-1,b_2=a_2-2,b_3=a_3-3,b_4=a_4-4\cdots b_i=a_i-i</script><p>发现这样随便选择两个相邻的 $b_{k},b_{k+1}$ 都会有</p><script type="math/tex; mode=display">b_k=a_k-k<a_{k+1}-1-k=a_{k+1}-{k+1}=b_{k+1}</script><p>也就是从 $1\sim n+m-i$ 中选择可以相邻的 $\{b\}$ 的方案数等于在 $1\sim n+m$ 中选择不能相邻的 $\{a\}$ 的方案数。于是可以知道有 $i$ 个 $01$ 时的方案数就是</p><script type="math/tex; mode=display">f_i=\binom{n+m-i}{i}\cdot \binom{n+m-2\cdot i}{n-i}</script><p>注意到因为序列其他位置的方案数也要考虑，所以需要再乘上一个剩下未知的方案数。但是注意到，剩下位置可能还会存在 $01$ ，所以 $f_i$ 本质上算的是「至少 $i$ 个的方案数」。设 $g_i$ 表示「恰好 $i$ 个的方案数」，那么可知：</p><script type="math/tex; mode=display">g_i=\sum_{j\geq i} \binom{j}{i} \cdot (-1)^{j-i}f_j</script><p>因为有二项式反演：</p><script type="math/tex; mode=display">f(n)=\sum_{i=n}^{m}\left(\begin{array}{c}i \\ n\end{array}\right) g(i) \Leftrightarrow g(n)=\sum_{i=n}^{m}(-1)^{i-n}\left(\begin{array}{c}i \\ n\end{array}\right) f(i)</script><p>然后就可以获得一个时空复杂度均为 $O(n^2)$ 的做法。</p><h3 id="70pts-做法"><a href="#70pts-做法" class="headerlink" title="70pts 做法"></a>70pts 做法</h3><p>有特殊性质 $n=m$。可以通过进一步对上一个做法用组合恒等式来化简，或者直接找规律，可以发现当 $n=m$ 时，$g_i=\binom{n}{i}^2$。于是就可以线性做了。</p><h3 id="85pts-做法"><a href="#85pts-做法" class="headerlink" title="85pts 做法"></a>85pts 做法</h3><p>并不会，有人来教教我吗？不过似乎二项式反演是可以做到 $\log^2$ 的？这可能需要什么多项式科技。</p><h3 id="100pts-做法"><a href="#100pts-做法" class="headerlink" title="100pts 做法"></a>100pts 做法</h3><p>发现对于期望，只需要算出所有情况下 $01$ 数量的总和，除以全部的合法排列数即可。考虑这个总和也是可以分开算的，即可以算对于每个可能出现的 <code>01</code> 计算与之对应的有多少贡献。于是答案就是：</p><script type="math/tex; mode=display">\frac{(n+m-1)\cdot \binom{n+m-2}{m-1}}{\binom{n+m}{m}}</script><p>化简一下可以得到答案为</p><script type="math/tex; mode=display">\frac{n\times m}{n+m}</script><p>复杂度 $O(\log n)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">550</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P2 = <span class="number">5050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P3 = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> ans1 ;</span><br><span class="line"><span class="keyword">int</span> ans2 ;</span><br><span class="line"><span class="keyword">int</span> ans3 ;</span><br><span class="line"><span class="keyword">int</span> fac[P3] ;</span><br><span class="line"><span class="keyword">int</span> inv[P3] ;</span><br><span class="line"><span class="keyword">int</span> comb[P2][P2] ;</span><br><span class="line"><span class="keyword">int</span> f[P3], g[P3], h[P3] ;</span><br><span class="line"><span class="keyword">int</span> dp[P1 * <span class="number">2</span>][P2][P2][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j][k][<span class="number">1</span>], dp[i][j][k][<span class="number">1</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>][<span class="number">1</span>], dp[i][j][k][<span class="number">0</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k][<span class="number">0</span>], dp[i][j][k][<span class="number">0</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k][<span class="number">0</span>], dp[i][j][k][<span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        h[i] = addn(dp[n + m][m][i][<span class="number">0</span>], dp[n + m][m][i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + m ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j - <span class="number">1</span>], comb[i - <span class="number">1</span>][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        f[i] = (ll)comb[n + m - i][i] * comb[n + m - <span class="number">2</span> * i][m - i] % P ; <span class="comment">// comb[n + m][m] ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= m ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(g[i], (ll)f[j] * comb[j][i] % P) : dec(g[i], (ll)f[j] * comb[j][i] % P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans1, <span class="number">1l</span>l * h[i] * (ll)i % P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans2, <span class="number">1l</span>l * g[i] * (ll)i % P) ;</span><br><span class="line">    ans3 = (ll)n * m % P * expow(n + m, P - <span class="number">2</span>) % P ;</span><br><span class="line">    ans1 = (ll)ans1 * expow(comb[n + m][m], P - <span class="number">2</span>) % P ;</span><br><span class="line">    ans2 = (ll)ans2 * expow(comb[n + m][m], P - <span class="number">2</span>) % P ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, ans1, ans2, ans3) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡乱整理了有关期望的一些东西。&lt;/p&gt;
&lt;p&gt;为什么自己老是学了就忘呢……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做 · 第四弹</title>
    <link href="https://www.orchidany.cn/2020/05/01/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B74/"/>
    <id>https://www.orchidany.cn/2020/05/01/简单题选做·4/</id>
    <published>2020-04-30T23:49:03.000Z</published>
    <updated>2020-05-28T11:48:34.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为这个 Typora 有点锅和自己电脑性能问题，文章太长就会很自闭。于是打算尽量精简一下题面，这样一篇文章整理的就会多一点。</p><p>预计会有不知道多少题题。慢慢更。</p><p>#warning： 本篇难度无限接近普及组，仅供个人娱乐。可以选择性忽略。 </p><a id="more"></a><h1 id="Topcoder-SRM-518-Div1-Hard-Nim"><a href="#Topcoder-SRM-518-Div1-Hard-Nim" class="headerlink" title="[Topcoder SRM 518 Div1] Hard Nim"></a>[Topcoder SRM 518 Div1] Hard Nim</h1><blockquote><p>有 $n$ 堆石子，每堆石子个数都必须是 $\leq m$ 的某个质数。玩 nin 游戏，求有多少种方式先手胜。</p><p>$1\leq n\leq 10^9,1\leq m\leq 10^5$ 。</p></blockquote><p>不能算是一眼秒了…但也是最多三眼？考虑因为 nim 游戏只关心每堆石子个数的异或和，如果堆数比较少就可以直接卷几次 FWT。更多的话…观察到 $n\leq 10^9$ 就不难知道要快速幂。然后就做完了</p><h1 id="CF-Round-643-Div2-C"><a href="#CF-Round-643-Div2-C" class="headerlink" title="[CF Round#643 Div2] C"></a>[CF Round#643 Div2] C</h1><blockquote><p>给定 $A, B, C, D$，求有多少个三边长度分别为 $x,y,z$ 的三角形满足 </p><script type="math/tex; mode=display">A \leq x \leq B \leq y \leq C \leq z \leq D</script><p>要求线性。</p></blockquote><p>就是弱智题？考虑枚举最大的边长，然后发现对于每个 $x\in[A, B]$ ，对应的 $y$ 的数量就是一个等差数列的形式。不过这题边界说实话比较烦人…</p><h1 id="CF-Round-643-Div2-E"><a href="#CF-Round-643-Div2-E" class="headerlink" title="[CF Round#643 Div2] E"></a>[CF Round#643 Div2] E</h1><blockquote><p>给定 $n$ 堆砖。每堆每次可以移走顶部一块，放到顶部一块或者将一堆顶部一块一到另一堆顶。三种操作分别有固定的代价。求最少的代价可以把全部的砖堆搞成等高。$n\leq 10^6,h_i\leq 10^9$ 。</p></blockquote><p>首先有个比较常见的 trick。大概就是考虑最后的状态数并不是 $10^9$ ，而是与 $n$ 同阶，这一点性质在 <code>UVA12170 Easy Climb</code> 也有体现。首先不难证明下界是 $n$ 。因为考虑如果存在两堆砖高度为 $a,b$ 其中 $a&gt;b$，最后如果想做到相同，那么必然是 $a$ 减小 $b$ 增大，考虑如果删砖比放砖花费更少那么必然是把 $b$ 删到 $a$，否则必然是把 $a$ 放到 $b$ 。但这个下界可能达不到，原因是会存在把一堆顶部移到另一堆顶部。考虑如果这么做比较优那么必然是把两堆拿到一样高。此时最后的高度应该是 $\frac{a+b}{2}$ 。对这个不难归纳出最后至多会有额外的两个状态，分别是 $\dfrac{\sum h_i}{n}$ 的上取整和下取整。然后对着所有状态求一遍最小代价就好了。</p><p>有个比较有趣的点，就是考虑求最小代价的时候，可以将「将一堆顶部一块一到另一堆顶」设置一个其他两者代价和的上界。这样就可以优先用这个操作了。最后复杂度排序外线性。</p><h1 id="CF-Round-643-Div2-F"><a href="#CF-Round-643-Div2-F" class="headerlink" title="[CF Round#643 Div2] F"></a>[CF Round#643 Div2] F</h1><blockquote><p>交互题。</p><p>设置一个数 $X\in[1,10^9]\cap \mathbb{Z_{+}}$ 。最多可以询问 $22$ 次，每次询问一个<code>long long</code> 范围内的数 $Y$ 后反馈 $\gcd(X, Y)$ 。最后需要输出 $X$ 的约束个数。</p><p>最后答案可以有一定误差，设 $d$ 为标准答案，那么只需要满足：</p><script type="math/tex; mode=display">\begin{array}{l}|a n s-d| \leq 7 \\\frac{1}{2} \leq \frac{a n s}{d} \leq 2\end{array}</script></blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Taylor.png" alt="霉吹联盟"></p><p>一个比较直接的暴力是考虑对每个 $\leq \sqrt{10^9}$ 的素数的最大幂进行 check，然后二分出指数。但是这样做需要 $3300+$ 次的询问…然后考虑如何把状态压一压。发现只需要最多 $10^9$ ，但是可以询问 $10^{18}$，于是可以把相邻状态压一压。<del>然后发现还是 WA on 5</del> .</p><p>然后又有一个更压的方法，就是考虑每次选取相邻几个质数的最小公倍数，然后这样筛过一遍就可以知道有哪些数要去筛。然后再把这里面的相邻组合…大概就是在上面一个方法外面套一个分组。但这样需要调整分界线。然后…然后就过了 XD</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mp = <span class="number">4000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mx = <span class="number">1000000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, used ;</span><br><span class="line"><span class="keyword">int</span> pos[Mp], res ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T x, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123; <span class="built_in">cerr</span> &lt;&lt; x &lt;&lt; c ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) debug(tp[i], v) ;  <span class="built_in">cerr</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Euler&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 51000</span></span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; vis ;</span><br><span class="line"><span class="keyword">int</span> pr[MAXN], A, i, j, cnt ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ego</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="built_in">sqrt</span>(Mx) ;</span><br><span class="line">vis[<span class="number">1</span>] = vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) pr[++ cnt] = i ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * pr[j] &gt; N) <span class="keyword">break</span> ;</span><br><span class="line">vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line"><span class="keyword">int</span> ng ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line">ll gp[Mp] ;</span><br><span class="line"><span class="keyword">int</span> stk[Mp] ;</span><br><span class="line"><span class="keyword">int</span> lrg[Mp] ;</span><br><span class="line"><span class="keyword">int</span> rrg[Mp] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= 44 ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; num[i] &lt;&lt; '\n' ;</span></span><br><span class="line">    Euler :: Ego() ;</span><br><span class="line">    lrg[tot = <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Euler ;</span><br><span class="line">    <span class="keyword">int</span> x, y, z, q1, q2 ; ll o = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        pos[i] = <span class="built_in">log</span>(Mx) / <span class="built_in">log</span>(pr[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1.0</span> * o * pr[i] &gt; <span class="number">1e18</span>)</span><br><span class="line">            gp[tot] = o, rrg[tot] = i - <span class="number">1</span>, lrg[++ tot] = i, o = <span class="number">1</span> ;</span><br><span class="line">        o *= pr[i] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(gp, 1, tot) ;</span></span><br><span class="line"><span class="comment">//    debug(lrg, 1, tot) ;</span></span><br><span class="line"><span class="comment">//    debug(rrg, 1, tot) ;</span></span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        ng = <span class="number">1</span> ;</span><br><span class="line">        res = <span class="number">1</span> ;</span><br><span class="line">        used = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            tp = <span class="number">0</span> ; ++ used ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; gp[ng] &lt;&lt; <span class="built_in">endl</span>, <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lrg[ng] ; i &lt;= rrg[ng] ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (y % pr[i] == <span class="number">0</span>) stk[++ tp] = i ; <span class="comment">//cout &lt;&lt; tp &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tp ; )&#123;</span><br><span class="line">                <span class="keyword">if</span> (used &gt;= <span class="number">22</span>) <span class="keyword">break</span> ;</span><br><span class="line">                q1 = <span class="number">0</span>, q2 = <span class="number">0</span> ; x = <span class="number">1</span>, z = <span class="number">1</span> ;</span><br><span class="line">                x = <span class="built_in">pow</span>(pr[stk[i]], pos[stk[i]]) ;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; tp)</span><br><span class="line">                    z = <span class="built_in">pow</span>(pr[stk[i + <span class="number">1</span>]], pos[stk[i + <span class="number">1</span>]]) ;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; <span class="number">1l</span>l * x * z &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; y ; ++ used ;</span><br><span class="line">                <span class="keyword">while</span> (y % pr[stk[i]] == <span class="number">0</span>)</span><br><span class="line">                    ++ q1, y /= pr[stk[i]] ;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; tp)</span><br><span class="line">                    <span class="keyword">while</span> (y % pr[stk[i + <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                        ++ q2, y /= pr[stk[i + <span class="number">1</span>]] ;</span><br><span class="line">                res *= (q1 + <span class="number">1</span>) * (q2 + <span class="number">1</span>) ; i += <span class="number">2</span> ;</span><br><span class="line"><span class="comment">//                cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++ ng ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; used &lt;&lt; "#\n " ;</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(used &lt; <span class="number">22</span>) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; max(res * <span class="number">2</span>, res + <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>大概算了 一下，发现这个不是很容易卡掉。证明方式大概可以考虑分类讨论 $\approx 10^3$ 的质数个数。</p><p>发现这样最多只能 check 到前 $153$ 个质数。考虑此时质数大小已经是 $900$ ，而 $10^9$ 至多分成 $3$ 个在 $10^3$ 左右的质数之积，考虑如果三个质数都没筛到那么 $res=1$ ，在 $+7$ 之后必然符合误差范围；如果只剩下一个质数没被筛到那么 $\times 2$ 之后必然合法；如果剩两个质数没被筛到，那么除去这两个较大的剩下的最大也只有 $1200$ 左右，而 $\leq 1200$ 的数最多含有 $4$ 个不同的质因子，同时用到超过第一个块(即超过前 $15$ 个质数)的最多会有 $1$ 个，毛估估一下发现 $22$ 次是绰绰有余的。 </p><h1 id="CF-Round-633-Div2-A"><a href="#CF-Round-633-Div2-A" class="headerlink" title="[CF Round #633(Div2) A]"></a>[CF Round #633(Div2) A]</h1><p>……题面不搬了。</p><p>考虑 $n$ 每次 $+1$，可以拆成两个单独的小菱形加上 $n-1$ 的方案，那么看上去通过分类讨论在左边插入还是右边插入，答案应该为</p><script type="math/tex; mode=display">f(n)=2\cdot f(n-1)</script><p>但是这并不对，因为两种方式会有重复。发现重复就重复在共同使用了中间那个大小为 $n-2$ 的多边形上。于是可以知道正确的递推应该是</p><script type="math/tex; mode=display">f(n)=2\cdot f(n-1)-f(n-2)</script><p>归纳可得 $f(n)=n$。</p><h1 id="CF-Round-622-Div2-B"><a href="#CF-Round-622-Div2-B" class="headerlink" title="[CF Round #622(Div2) B]"></a>[CF Round #622(Div2) B]</h1><blockquote><p>一项奥林匹克竞赛有着与普通竞赛不同的规则，它分成两轮，假如一位参赛者在第一轮中排名第 $x$ 名，在第二轮中排名第 $y$ 名，则他的总分是 $x+y$，他的总排名是总分小于等于 $x+y$ 的参赛者（包括他自己）。需要注意的是，每一轮比赛都不会出现并列的情况，每一个排名 $i$ 都对应了唯一的参赛者。</p><p>尼古拉被告知他第一轮排名第 $x$，第二轮排名第 $y$ ，他需要你帮助他算出他可能获得的最好总排名和最差总排名。</p></blockquote><p>首先不难知道最大值是 $\min\{x+y,n\}$ 。考虑如果 $x+y&lt;n$，那么其他人的排名可以让一场比尼古拉小，一场比尼古拉大，这样稍微安排一下就可以使得尼古拉成为第一名。但是如果 $x+y\geq n$ 。嗯，欧神说猜出答案来就算完，不管了不管了（</p><h1 id="CF-Round-626-Div1-A-Unusual-Competitions"><a href="#CF-Round-626-Div1-A-Unusual-Competitions" class="headerlink" title="[CF Round #626(Div1) A]Unusual Competitions"></a>[CF Round #626(Div1) A]Unusual Competitions</h1><blockquote><p>有一个长度为 $n$ 的括号序列。</p><p>你可以进行若干次操作：花费 $m$ 的代价，将一个长度为 $m$ 的括号子串任意排列。</p><p>若能将括号序列排成合法的括号序，请求出最小花费的代价和。否则请输出 <code>-1</code>。</p></blockquote><p>考虑自然是当 <code>(</code> 和 <code>)</code> 数量相等但是没能匹配成功的时候才能重排，并且考虑一长段重排和几小段分别重排本质是相同的，因为每次重排相当于选择相等数量的几个左括号和右括号交换位置。</p><p>感觉写这个题的时候还是不细心。细节写丢了好几次。</p><h1 id="CF-Round-626-Div2-B-Count-Subrectangles"><a href="#CF-Round-626-Div2-B-Count-Subrectangles" class="headerlink" title="[CF Round #626(Div2) B]Count Subrectangles"></a>[CF Round #626(Div2) B]Count Subrectangles</h1><blockquote><p>给定长为 $n$ 的数组 $a$ 和长为 $m$ 的数组 $b$，数组中的元素均是 $0$ 或 $1$。有 $n\times m$ 的矩阵 $c$，$c_{i,j}=a_i \cdot b_j$。请求出矩阵 $c$ 面积为 $k$ 的全 $1$ 子矩阵数量。</p><p>$1\leq n,m\leq 10^6$。</p></blockquote><p>不难知道就是统计含 $1$ 的连续段然后分别贡献一下。当然我用了个并查集就导致实现很臃肿<del>疯狂爆 OJ</del> 。</p><h1 id="CF-Round-399-Combined-B-Code-For-1"><a href="#CF-Round-399-Combined-B-Code-For-1" class="headerlink" title="[CF Round #399(Combined) B]Code For 1"></a>[CF Round #399(Combined) B]Code For 1</h1><blockquote><p>有一个序列，初始时只有一个数 $n(0\le n\le2^{50})$。</p><p>对于序列中每一个 $&gt;1$ 的数，拆分成三个数$ \lfloor\frac n2\rfloor,n\bmod2,\lfloor\frac n2\rfloor$ 并替换原数，直到序列中没有&gt;1的数为止。</p><p>查询最终序列中 $ [l,r] (1\le l,r)$ 中有多少 $1$。</p><p>同时 $l,r$ 满足 $0\le r - l\le10^5$。</p></blockquote><p>不难发现最后会构成一棵共有 $2^k$ 个节点的分治树，其中 $k=\lceil\log_2 n\rceil$ 。但是这其中有很多部分是重复的。随便画一下图可以发现对于区间内所有的奇数位置都会是一样的结果，取决于最后 $n$ 不断除以 $2$ 下取整是 $0$ 还是 $1$ 。而对于偶数位置则是某些 $n’\mod 2$ 。发现这些偶数位置的深度可能会有不同，同一深度结果相同。于是就可以预处理出每个深度的答案。最终复杂度 $O((r-l)\log n)$ 。</p><h1 id="CF-Round-399-Combined-F-Barrels-and-boxes"><a href="#CF-Round-399-Combined-F-Barrels-and-boxes" class="headerlink" title="[CF Round #399(Combined) F] Barrels and boxes"></a>[CF Round #399(Combined) F] Barrels and boxes</h1><blockquote><p>有 $w$ 箱酒，$f$箱食物。</p><p>现在要把这些箱子摞成相邻的若干堆，要求每一堆都必须是同类型的箱子，且相邻堆类型不同。</p><p>堆的高度定义为所有的箱子数。问所有 <strong>用酒箱子做成的堆</strong> 高度都大于 $h$ 的概率。 </p></blockquote><p>一开始觉得是分拆数，后来发现是有序的分拆数，就变成插板法 sb 题了。</p><p>考虑本质上「堆」就是对总量的一个有序拆分。而这里不同的是总方案数要求不能存在某些位置放 $0$ 的情况。考虑如果可以放 $0$ 那么就是一个 $n$ 元线性不定方程组非负整数解的个数，这个地方要求 $k$ 个位置都 $\geq 1$ 的话，就只需要将等号右边的 $w/f$ 改成 $w-k$ 和 $f-k$ 即可。考虑合法方案数也是一样的道理，变成了 $w-h\cdot k$ 和 $f-h\cdot k$ 。</p><p>然后就可以考虑对每个堆数计数。发现对于一个数量 $n’$ 两者只会放 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 和 $\left\lceil\dfrac{n}{2}\right\rceil$ 的数量，随便算一下即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为这个 Typora 有点锅和自己电脑性能问题，文章太长就会很自闭。于是打算尽量精简一下题面，这样一篇文章整理的就会多一点。&lt;/p&gt;
&lt;p&gt;预计会有不知道多少题题。慢慢更。&lt;/p&gt;
&lt;p&gt;#warning： 本篇难度无限接近普及组，仅供个人娱乐。可以选择性忽略。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="快速沃尔什变换(FWT)" scheme="https://www.orchidany.cn/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】从零开始的数位DP生活</title>
    <link href="https://www.orchidany.cn/2020/04/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E4%BD%8DDP%E7%94%9F%E6%B4%BB/"/>
    <id>https://www.orchidany.cn/2020/04/27/从零开始的数位DP生活/</id>
    <published>2020-04-27T09:13:20.000Z</published>
    <updated>2020-04-29T12:35:54.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…</p><p>冲冲冲！</p><a id="more"></a><h1 id="Luogu4317-花神的数论题"><a href="#Luogu4317-花神的数论题" class="headerlink" title="[Luogu4317] 花神的数论题"></a>[Luogu4317] 花神的数论题</h1><blockquote><p>话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\prod_{i=1}^{N}\text{sum}(i)$ ，也就是  $\text{sum}(1)\sim\text{sum}(N)$  的乘积。</p><p>对于 100% 的数据，$N≤10^{15}$ 。</p></blockquote><p><del>为什么花神出的题花不会呢，为什么为什么</del> 。</p><h1 id="LuoguP1822-魔法指纹"><a href="#LuoguP1822-魔法指纹" class="headerlink" title="[LuoguP1822] 魔法指纹"></a>[LuoguP1822] 魔法指纹</h1><blockquote><p>对于任意一个至少两位的正整数 $n$，按如下方式定义 $magic(n)$ ：将 $n$ 按十进制顺序写下来，依次对相邻两个数写下差的绝对值。这样，得到了一个新数，去掉前导 $0$，则定义为 $magic(n)$。若 $n$ 为一位数，则 $magic(n)=n$。</p><p>对任意一个数 $n$，序列 $n,magic(n),magic(magic(n)),…$ 迟早会变成一个一位数。最后的这个值称为数 $n$ 的 $magic$ 指纹。</p><p>对 $100\%$ 数据，$0&lt;A≤B≤1,000,000,000$ 。</p></blockquote><h1 id="loj10165-Windy数"><a href="#loj10165-Windy数" class="headerlink" title="[loj10165] Windy数"></a>[loj10165] Windy数</h1><blockquote></blockquote><p>咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…&lt;/p&gt;
&lt;p&gt;冲冲冲！&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/数位DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做·第3季</title>
    <link href="https://www.orchidany.cn/2020/04/26/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC3%E5%AD%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/简单题选做·第3季/</id>
    <published>2020-04-26T12:52:04.000Z</published>
    <updated>2020-05-17T02:07:44.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>终于！终于不是UVA了！</del></p><p>主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。</p><p>争取一句话题解…这一弹大概有 $30$ 道题左右吧。 </p><a id="more"></a><h1 id="Luogu4318-完全平方数"><a href="#Luogu4318-完全平方数" class="headerlink" title="[Luogu4318]完全平方数"></a>[Luogu4318]完全平方数</h1><blockquote><p>小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。</p><p>这天是小 X 的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小 X 讨厌的数。他列出了所有小 X 不讨厌的数，然后选取了第 K 个数送给了小 X。小 X 很开心地收下了。</p><p>然而现在小 W 却记不起送给小 X 的是哪个数了。你能帮他一下吗？</p><p>$K\leq 10^9$</p></blockquote><p>考察 $\mu$ 的容斥意义的神题 orz</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>发现 $\mu$ 函数的性质，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子，且 $x$ 的不同素因子个数为 $k$。</p><p>所以就考虑先二分，二分完了求一下 $1\sim x$ 中不是完全平方数倍数的数的数量是否 <code>&gt;mid</code>。考虑这个东西怎么求。发现根据容斥，可以知道应该是「有 $0$ 个不同质因子的平方的倍数数量」-「有 $1$ 个不同质因子的平方的倍数数量」+「有 $2$ 个不同质因子的平方的倍数数量」。</p><p>另一方面，考虑对着每个<strong>不含平方因子</strong>的数 $x$ 计数，计包含 $x^2$ 的数的个数。根据容斥可以得到答案应该是：</p><script type="math/tex; mode=display">\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \dfrac{n}{i^2}\rfloor</script><p>原理是，根据 $\mu$ 的性质，具有平方因子的数不会被统计，同时容器系数恰好就是 $\mu$。</p><p>这东西可以直接 $\sqrt n$ 求。复杂度 $T \cdot \sqrt n \log n$</p><p>顺便记录一个很绝的 <code>idea:</code></p><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p><script type="math/tex; mode=display">\sum _{i=1}^{x}\mu^2(x)\leq K</script><p>然后这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个东西一定程度上证明了</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \mu(i)^{2}=\sum_{i=1}^{\lfloor\sqrt{n}\rfloor} \mu(i)\left\lfloor\frac{n}{i^{2}}\right\rfloor</script><p>这其实是可以反演出来的。考虑对左边进行变形，令 $\zeta(x)$ 表示 $x$ 最大的平方因子。那么有</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^n\mu^2(i)\\=&\sum_{i=1}^n [\zeta(i)=1]\\=&\sum_{i=1}^n\sum_{d|\zeta(i)}\mu(d)\\=&\sum_{i=1}^n\sum_{d^2|\zeta(i)}\mu(d)\\=&\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d^2}\rfloor\\=&\sum_{d=1}^{\lfloor\sqrt n\rfloor}\mu(d)\lfloor\frac{n}{d^2}\rfloor\end{aligned}</script><p>其中第三个等号是借助了 $\mu$ 的性质：因为 $\zeta(i)$ 根据定义本身是一个完全平方数，所以如果 $d|\zeta(i)$ 但是 $d$ 不包含平方因子，说明 $d^2|\zeta(i)$ ；包含平方因子会被 $\mu(d)=0$ 直接干掉。最后一个等号是因为可以知道 $d&gt;\lfloor\sqrt n\rfloor$ 时最后一个因式恒为 $0$ 。</p><p>这似乎是某次听课听来的内容…但是当时并没有整理这个。想来已经是远古时期的回忆了。</p><h1 id="UVA1614-Hell-on-the-Markets"><a href="#UVA1614-Hell-on-the-Markets" class="headerlink" title="[UVA1614]Hell on the Markets"></a>[UVA1614]Hell on the Markets</h1><blockquote><p>给出一个数列 $\{a_n\}$，保证 $\forall i, 1\leq a_i\leq i$。求是否可以分成相等的两半，并给出方案。</p><p>$n\leq 10^5$。</p></blockquote><p>考虑一个引理。如果 $\forall i, 1\leq a_i\leq i$ 的话，那么 $\forall v\in[1,\sum_{j=1}^ia_j]\cap \mathbb{Z_+}$ 都可以被凑出来。 证明的话考虑数学归纳。即现在只需要证明 $[s_{i-1}+1,s_{i-1}+a_i]$ 可以被凑出来即可。发现对于一个 $s_{i-1}+k$ 而言，因为根据归纳 $[1,s_{i-1}]$ 都可以被 $a_1\sim a_{i-1}$凑出来且有 $s_i+k-a_i\leq s_{i-1}$ ，所以证毕。</p><p>那么综上，在判断 $v=\frac{\sum_{i=1}^na_i}{2}$ 是否可以被凑出来时，根据上面的贪心特性，要从后向前推，每次选择一个当前小于 $v$ 的最大值减掉即可。</p><h1 id="HNOI2011-数学作业"><a href="#HNOI2011-数学作业" class="headerlink" title="[HNOI2011]数学作业"></a>[HNOI2011]数学作业</h1><blockquote><p>给定正整数 $n,m$，要求计算 $\text{Concatenate}(n) \bmod  m$  的值，其中 $\text{Concatenate}(n)$ 是将 $1 \sim n$ 所有正整数 顺序连接起来得到的数。</p><p>$1\le n \le 10^{18}$，$1\le m \le 10^9$。</p></blockquote><p>…考虑递推，那自然是 $f_{i}=(f_{i-1}\cdot T+i)\bmod m$ 。其中 T 是根据不同的数字位数而变的这么一个计数器。于是就是分段矩乘即可。 </p><h1 id="Luogu5110-块速递推"><a href="#Luogu5110-块速递推" class="headerlink" title="[Luogu5110]块速递推"></a>[Luogu5110]块速递推</h1><blockquote><p><script type="math/tex">a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1</script> 。</p><p>求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。</p><p>$1\leq T\leq 5\times 10^7,1\leq n\leq 10^{18}$ 。</p></blockquote><p>朴素的矩乘是 $8\cdot \log n$ 的样子。这样算出来复杂度是 $O(8\cdot T\cdot \log n)$ ，好像很慢的样子。</p><p>于是考虑预处理一点东西。比较常见的方法当然就是分块来做，预处理 $a^{1},a^{2},a^{3}\cdots a^{\sqrt n},a^{2\cdot \sqrt n},a^{3\cdot \sqrt n}\cdots$ 这些。那么复杂度度转化成了 $O(\sqrt n\log\sqrt n+8\cdot T)$。</p><p>注意到可以借助扩展欧拉定理 $a^b\equiv a^{b\bmod \varphi(m)+\varphi(m)}\pmod{m}$ 使得复杂度变成 $O(\sqrt{Mod}\log\sqrt{Mod}+8\cdot T)$ 。信仰一波就过了。</p><h1 id="USACO13JAN-Seating-G"><a href="#USACO13JAN-Seating-G" class="headerlink" title="[USACO13JAN]Seating G"></a>[USACO13JAN]Seating G</h1><blockquote><p>有一排 $n$ 个座位，$m$ 次操作。</p><p>A操作：将 $a$ 名客人安置到最左的连续 $a$ 个空位中，没有则不操作。</p><p>L操作：$[a,b]$ 的客人离开。</p><p>求A操作的失败次数。</p><p>$n,m,10^5$ 。</p></blockquote><p>这…大概就是维护区间最长连续和然后再直接线段树上二分吧…发现自从领悟了线段树上二分之后，好多奇怪的线段树题也就都这么回事了…</p><h1 id="UVA1620-Lazy-Susan"><a href="#UVA1620-Lazy-Susan" class="headerlink" title="[UVA1620] Lazy Susan"></a>[UVA1620] Lazy Susan</h1><blockquote><p>现在有一个大转盘，上面有 $n$ 个珠子，分别写有 $1\sim n$ 之间的正整数。</p><p>给出这些珠子的排列方式，现在你可以每次翻转连续的四个珠子。问你至少要进行几次操作，才能将这个转盘上的珠子变成 $1,2,…,n-1,n$ 的排列方式。</p><p>$4\leq n\leq 10^6$ 。</p></blockquote><p>感觉还是比较有意思的题目？虽然是个结论题 233</p><p>首先考虑考虑序列中某段长度为 $x$ ，内部含有 $y$ 个逆序对的子段 $[l,r]$ 的性质：</p><p>(1) 该子段无论怎么重排，对 $[1,l-1]$ 的贡献不变，对 $[r+1,n]$ 的贡献不变。</p><p>(2) 该子段内部，顺序与逆序两种排布的逆序对数量之和为 $\frac{x^2+x}{2}$。</p><p>(3) 根据 $(1)$ 和 $(2)$ 可以得知，每次操作后，逆序对数量的变化量一定是 $(\frac{x^2+x}{2}-y)-y$ 。</p><p>回归到本题，可以知道每次逆序对的变化量肯定是 $6-2\cdot y$ 的形式。注意到序列翻转时，其他的指标都没有变，只有逆序对变了，所以可以用逆序对数量来衡量可达性。注意到每次增多/减少的数量都会是偶数，所以如果这个环不存在一个断裂使得逆序对数量为偶数，那么就不可以被变换成 $1,2,3,4\cdots n$ 。</p><p>这题原本的数据范围是 $10^3$ ，当然可以暴力枚举每个断裂。注意到，如果 $n$ 是奇数，且存在某个断裂的逆序对数也是奇数，那么这个环的所有断裂逆序对数都会是奇数。证明可以考虑，每次断裂的变化相当于把开头的元素移到结尾。那么假设当前开头元素是第 $k$ 大，那么可以知道这个元素会贡献 $n-k$ 个逆序对，移动到尾部后则会贡献 $k-1$ 个逆序对，$\Delta = k - 1 - n + k=2\cdot k - n - 1$ ，可知 $\Delta$ 本身一定是偶数。于是证毕，不可能出现偶数个逆序对的情况。</p><h1 id="APIO2012-派遣"><a href="#APIO2012-派遣" class="headerlink" title="[APIO2012]派遣"></a>[APIO2012]派遣</h1><blockquote><p>在这个帮派里，有一名忍者被称之为 Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。</p><p>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。</p><p>你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。</p><p>写一个程序，给定每一个忍者 $i$ 的上级 $B_i$ ，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$ ，输出在预算内满足上述要求时顾客满意度的最大值。</p><p><strong>简化版题面：给定一棵树，求</strong> </p><script type="math/tex; mode=display">\max_{u\in T}\{L_u\cdot t_u\}</script><p><strong>其中设</strong> $s$ <strong>是以</strong> $u$ <strong>为根的子树中的某个点集，</strong>$\mathrm{card}$ <strong>表示集合的元素个数， 则</strong></p><script type="math/tex; mode=display">t_u=\max_s\{\mathrm{card}(s)\cdot [ \sum_{i\in s} c_i\leq m]\}</script><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>读题读半天系列x</p><p>…发现是暴力，暴力选每个点当根，然后拿一个支持快速合并的数据结构对子树内的点进行合并，选出重量最小的那几个即可。注意到暴力合并的话似乎是要二分…这样一般而言复杂度就变成两个 $\log$ 了。但是如果每次插入完之后，统计答案时选择不断删掉当前 $c_i$ 最大的元素，这样就可以在保证正确性的同时降低询问的复杂度。发现可以直接拿左偏树来维护。复杂度 $O(n\log n)$ 。</p><h1 id="Luogu1858-多人背包"><a href="#Luogu1858-多人背包" class="headerlink" title="[Luogu1858]多人背包"></a>[Luogu1858]多人背包</h1><blockquote><p>01背包的前 $k$ 优解。</p><p>$k\le 50,m\le 5000,n\le 200$ .</p></blockquote><p>考虑暴力做并不简单，一个直观的想法就是再记一维 $k$ ，即 $f_{i,v,k}$ 表示考虑了前 $i$ 个物品，总体积为 $v$ 的 $k$ 优解是多少。考虑转移。通过观察单调性，可以发现当 $p&gt;q$ 时， $i-1,v$ 时的 $p$  优解是不会对 $i,v+w_i$ 时的 $q$ 优解产生贡献的，也就是说对于一个状态 $f_{i,v,k}$ ，都是从某个 $f_{i-1,v,j}$ 或者 $f_{i-1,v-w_i,j}+v_i$ 转移过来的。于是考虑直接把这两个状态集归并排序一下即可。复杂度 $O(n\cdot m\cdot k)$ 。</p><h1 id="SCOI2016-萌萌哒"><a href="#SCOI2016-萌萌哒" class="headerlink" title="[SCOI2016]萌萌哒"></a>[SCOI2016]萌萌哒</h1><blockquote><p>一个长度为 $n$ 的大数，用 $s_1s_2s_3 \cdots s_n$表示，其中 $s_i$ 表示数的第 $i$ 位， $s_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串$s_{l_1}s_{l_1+1}s_{l_1+2} \cdots s_{r_1}$与$s_{l_2}s_{l_2+1}s_{l_2+2} \cdots s_{r_2}$完全相同。</p><p>求本质不同的大数个数。</p><p>$1\le n\le 10^5$，$1\le m\le 10^5$ 。</p></blockquote><p>（以下默认并查集的复杂度是 $O(\log n)$ ，实际上这是一个很松的上界）</p><p>考虑暴力做当然是对每个位置开一个并查集，然后对于每个修改暴力 <code>for</code> 过去，这样最后答案就是 $9\cdot 10^{cnt-1}$ ，其中 $cnt$ 是不同的集合数量。这样做是 $O(nm\log n)$ 修改、$O(n\log n)$ 查询的。发现这样做的复杂度十分不平衡。考虑将复杂度向查询倾斜，即优化修改操作的复杂度。</p><p>考虑二进制拆分。对每个位置 $i$ 维护 $i\sim i+2^k-1$ 的连通状态，这样每次修改就是 $\log ^2n$ 的了。之后考虑对于一个长为 $2^k$ 的区间，可以push_down成两个长为 $2^{k-1}$ 的子区间再分别连边。于是查询的时候就可以直接查询了。</p><p>总复杂度 $O(m\log ^2n+n\log ^2 n)$ 。</p><h1 id="SCOI2010-生成字符串"><a href="#SCOI2010-生成字符串" class="headerlink" title="[SCOI2010]生成字符串"></a>[SCOI2010]生成字符串</h1><blockquote><p>lxhgww 最近接到了一个生成字符串的任务，任务需要他把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，但是任务还要求在组成的字符串中，在任意的前 $k$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。现在 lxhgww 想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？</p><p>$1\leq m,n\leq 10^6$ 。</p></blockquote><p>这…理论上如果没有个数限制的话就是卡特兰数了吧。</p><p>考虑一个转化，从 $(0,0)$ 开始出发，设当前点为 $(x,y)$ 每次如果遇到 $1$ 就走到 $(x+1,y-1)$ ，每次遇到 $0$ 就走到 $(x+1,y+1)$，那么最终就是走到 $(n+m,m-n)$ 的、不跨过直线 $x=0$ 方案数。这…似乎是一个十分经典的组合问题了。大概就是考虑把走到 $y=1$ 这条直线以下的那些路径全都翻转到 $y=1$ 以下（做镜像对称），那么就可以看做是从 $(0,2)$ 走到 $(n+m,m-n)$ 的方案数。所以答案就是两者相减。</p><p>考虑怎么算这两部分。发现本质上从 $(0,0)$ 走到 $(n+m,m-n)$ 、每次向右下或者右上走的方案数。一种比较简单的理解就是从 $n+m$ 步里面选出 $n$ 步向右下走的方案数，所以答案是 $\binom{n+m}{m}-\binom{n+m}{m-1}$ ，因为从 $(0,2)$ 开始走相当于把其中向上走的某一步魔改成了成了向下走的，所以 $m$ 要减一。</p><h1 id="SP19148-Kill-them-All"><a href="#SP19148-Kill-them-All" class="headerlink" title="[SP19148]Kill them All"></a>[SP19148]Kill them All</h1><blockquote><p>$n$ 只怪兽，每一次可让 Digo 杀或 Sharry 杀。求在每杀掉一只怪物后，Digo 的击杀数都比 Sharry 的击杀数多的方案数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>回顾历史的时候顺便发现了这道题…</p><p>大概就是上个题把 $\geq $ 换成了 $&gt;$ 。考虑首先让 $1$ 号怪兽必须被 <code>Digo</code> 干掉，那么就变成了从 $(1,0)$ 出发，走 $n-1$ 步，途中不能碰到 $y=0$ 的方案数。考虑最后走到的地方只会是 $(n,\lceil\frac{n}{2}\rceil),(n,\lceil\frac{n}{2}\rceil+1)\cdots (n,n)$，那么不妨对这些东西分别计数，那么答案就是</p><script type="math/tex; mode=display">1+\sum_{i=1}^{\lceil\frac{n}{2}\rceil-1}\left(\binom{n-1}{i}-\binom{n-1}{i-1}\right)</script><p>其中第一个 $1$ 是全部被 <code>Digo</code> 干掉的方案数。那么可以知道…这个式子里面前面的都被消掉了，最后只剩一个 $1+\binom{n-1}{\lceil\frac{n}{2}\rceil-1}-\binom{n-1}{0}=\binom{n-1}{\lceil\frac{n}{2}\rceil-1}$ 。 然后就没有然后了。</p><h1 id="UVA11149-Power-of-Matrix"><a href="#UVA11149-Power-of-Matrix" class="headerlink" title="[UVA11149]Power of Matrix"></a>[UVA11149]Power of Matrix</h1><blockquote><p>给定整数 $k$ 和一个 $n$ 阶矩阵 $A$ ，求 </p><script type="math/tex; mode=display">A+A^2+A^3+A^4+\cdots+A^k</script><p>$n\leq 100,k\leq 10^6$ 。</p></blockquote><p>这题其实有两种做法。一种做法是 $O(n^3\log k)$ 的，另一种也是 $O(n^3\log k)$ 的，只不过会多一个 $8$ 的常数。</p><h2 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑对着这个找规律（雾），大概是考虑分块做，发现原来的式子可以写成：</p><script type="math/tex; mode=display">A+A^2+A^3+\cdots +A^{\sqrt k}+A^{\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})+A^{2\cdot\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})\cdots</script><p>那么就可以预处理再做了。这样复杂度是 $O(n^3\sqrt k)$ 的，好像大概是 $10^9$ 的复杂度…过不去。</p><p>不过既然分块可以，那倍增应该也可以。具体的，可以这么化：</p><script type="math/tex; mode=display">A^1+A^1\cdot A^1 + A^2\times (A^1+A^2)+A^4\times(A^1+A^2+A^3+A^4)</script><p>那么这样就可以先预处理出 $n^3\log k$ 个 $A,A^2,A^4\cdots$ ，然后就可以再用 $n^3\log k$ 的时间预处理出 $s_1,s_2,s_4\cdots$ 其中 $s_i=\sum{A^i}$ 。之后就可以直接二进制拆分了。总复杂度 $n^3\log k$ 。</p><h2 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>考虑直接对所有矩阵的和进行递推。计 $A^u$ 为当前矩阵的 $u$ 次幂，那么不妨构造一个复合矩阵</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">s_i = \sum \limits_{j = 1}^{i}A^i</script><p>发现它可以这么转移：</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix} = \begin{bmatrix}A^{k-1}\\s_{k-1}\end{bmatrix}\cdot \begin{bmatrix}A &0\\I_n&I_n\end{bmatrix}</script><p>其中 $I_n$ 表示 $n$ 阶单位矩阵。然后就没有然后了。注意到这样做矩阵其实是升阶了，所以会带一个常数。</p><h1 id="SDOI2011-打地鼠"><a href="#SDOI2011-打地鼠" class="headerlink" title="[SDOI2011]打地鼠"></a>[SDOI2011]打地鼠</h1><blockquote><p>打地鼠是这样的一个游戏：地面上有一些地鼠洞，地鼠们会不时从洞里探出头来很短时间后又缩回洞中。玩家的目标是在地鼠伸出头时，用锤子砸其头部，砸到的地鼠越多分数也就越高。</p><p>游戏中的锤子每次只能打一只地鼠，如果多只地鼠同时探出头，玩家只能通过多次挥舞锤子的方式打掉所有的地鼠。你认为这锤子太没用了，所以你改装了锤子，增加了锤子与地面的接触面积，使其每次可以击打一片区域。如果我们把地面看做 $m\times n$ 的方阵，其每个元素都代表一个地鼠洞，那么锤子可以覆盖 $r\times c$ 区域内的所有地鼠洞。但是改装后的锤子有一个缺点：每次挥舞锤子时，对于这的区域中的所有地洞，锤子会打掉恰好一只地鼠。也就是说锤子覆盖的区域中，每个地洞必须至少有 $1$ 只地鼠，且如果某个地洞中地鼠的个数大于 $1$，那么这个地洞只会有 $1$ 只地鼠被打掉，因此每次挥舞锤子时，恰好有$r\times c$ 只地鼠被打掉。由于锤子的内部结构过于精密，因此在游戏过程中你不能旋转锤子（即不能互换 $r$ 和 $c$）。</p><p>你可以任意更改锤子的规格(即你可以任意规定 $r$ 和 $c$ 的大小)，但是改装锤子的工作只能在打地鼠前进行(即你不可以打掉一部分地鼠后，再改变锤子的规格)。你的任务是求出要想打掉所有的地鼠，至少需要挥舞锤子的次数。</p><p>Hint：由于你可以把锤子的大小设置为 $1\times 1$，因此本题总是有解的。</p><p>$1\leq m,n\leq 100$。</p></blockquote><p>以下是翻车现场，这题根本没有「行列无关」的性质：</p><blockquote><p>一道十分经典的行列无关技巧普及题目。但这题行列无？关比较的深刻。</p><p>考虑如果暴力枚举的话，复杂度大概是枚举 $r\times c$ 之后再一个一个打，这样复杂度是 $O(n^6)$，实现的好一点就可以 $O(n^4\log^2 n)$ 。但是，如果这题满足行列无关的话，就可以 $r$ 和 $c$ 分别枚举。准确来说，对于另一维设为 $1$，那么可以只去找这一维的最大值。考虑这么做判断的复杂度就是 $O(n^3)$，枚举的复杂度是 $O(n)$ 。那么最后总复杂度就是 $O(n^4)$ 。</p><p>那么唯一的问题在于如何证明行列无关在这题里面是对的。考虑对于所枚举的锤子大小所覆盖的某个区域，其中有两个点 $(a,b)$ 和 $(c,d)$ ，不同行也不同列，但是可以知道 $(a,b)$ 和 $(c,b)$ 的确定关系，$(c,d)$ 和 $(c,b)$ 的确定关系。即我断言，如果 $(a,b)$ 和 $(c,b)$ 满足同时合法，$(c,d)$ 和 $(c,b)$ 也同时合法，那么这三个点就可以同时合法，反之则不可以。</p><p>考虑这个断言为什么合理。发现每次如果以 $(c,b)$ 为量度去砸，那么 $(c,d)$ 和 $(a,b)$ 被砸的次数都只会与 $(c,b)$ 的地鼠数量有关，因为 $(c,b)$ 必须被精确砸完……</p><p><del>编不下去了，就当记结论了</del></p></blockquote><p>然后就是一个二维差分，然后就没了。</p><h1 id="Luogu1357-花园"><a href="#Luogu1357-花园" class="headerlink" title="[Luogu1357]花园"></a>[Luogu1357]花园</h1><blockquote><p>小 L 有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1 \sim n$。花园 $1$ 和 $n$ 是相邻的。</p><p>他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则：任意相邻 $m$ 个花圃中都只有不超过 $k$ 个 C 形的花圃，其余花圃均为 P 形的花圃。</p><p>请帮小 L 求出符合规则的花园种数对 $10^9+7$ 取模的结果。</p><p>$1\leq n\leq 10^{15},2\leq m\leq 5$。</p></blockquote><p>发现一共只有两种方格，并且转移只跟 $m$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p><p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，就可以快速幂了。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> u, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == m + <span class="number">1</span>)&#123;</span><br><span class="line">ok[s] = <span class="number">1</span> ;  </span><br><span class="line">ans.ma[s &gt;&gt; <span class="number">1</span>][s] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (u == k &amp;&amp; ~s &amp; <span class="number">1</span>) <span class="keyword">return</span> ;  </span><br><span class="line">ans.ma[(s &gt;&gt; <span class="number">1</span>)|st[m]][s] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line">dfs(x + <span class="number">1</span>, u, s) ; </span><br><span class="line"><span class="keyword">if</span> (u &gt;= k) <span class="keyword">return</span> ;   </span><br><span class="line">dfs(x + <span class="number">1</span>, u + <span class="number">1</span>, s | st[x]) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line">st[i] = (<span class="number">1</span> &lt;&lt; i) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; ans = expow(ans, n) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> &lt;&lt; m ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (ok[i]) add(res, <span class="number">1l</span>l * ans.ma[i][i], P) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA11134-Fabled-Rooks"><a href="#UVA11134-Fabled-Rooks" class="headerlink" title="[UVA11134]Fabled Rooks"></a>[UVA11134]Fabled Rooks</h1><blockquote><p>在一个 $n\times n$（$1\leq n\leq 5000$）的棋盘上放置 $n$ 个车，每个车都只能在给定的一个矩形( $x_{l_i},x_{r_i},y_{l_i},y_{r_i}$) 里放置，使其 $n$ 个车两两不在同一行和同一列，判断并给出解决方案。</p></blockquote><p>一道(真正)考察了行列无关知识的题目。</p><p>考虑放每个车时行与列显然是无关的，所以就可以分开做。那就是给定一堆区间，每个区间内选一个点使之不被放在同一个位置。贪一波就完了。</p><h1 id="NOI2005-瑰丽华尔兹"><a href="#NOI2005-瑰丽华尔兹" class="headerlink" title="[NOI2005]瑰丽华尔兹"></a>[NOI2005]瑰丽华尔兹</h1><blockquote><p>舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。</p><p>艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。</p><p>$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。K是时间段的数量，T 是总时间。</p></blockquote><p>考虑最朴素的 $dp$ 就是 $f_{t,i,j}$ 表示时刻 $t$ 时在位置 $(i,j)$ 结尾的最长路径。转移时 $O(1)$ 的。但由于状态数太高导致不得不放弃。发现本质上每段时间内，转移的方向唯一。所以可以按段来 $dp$ ，$f_{k,i,j}$ 表示经过了 $k$ 段之后，结尾于位置 $(i,j)$ 的最长路径。这样状态数就是 $O(nmk)$ 的、转移是 $O(\max\{n,m\})$ 的了。发现由于每一段决策区间单调，且决策点彼此之间存在单调性，于是可以拿单调队列优化到均摊 $O(1)$ 转移。</p><h1 id="BalticOI2008-Elect"><a href="#BalticOI2008-Elect" class="headerlink" title="[BalticOI2008]Elect"></a>[BalticOI2008]Elect</h1><blockquote><p>$n$ 个政党要组成一个联合内阁，每个党都有自己的席位数。 </p><p>现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。 </p><p>对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。</p><p>求最大席位并构造一组解。</p><p>$1\leq n\leq 300,1\leq m\leq 10^5$ 。</p></blockquote><p>大概是长个经验？</p><p>发现倒着贪心并不是对的…虽然观察数据范围发现 $O(nm)$ 可过，但是一般情况下很难想到要去背包，因为有一个「多余」的限制…</p><p>但是发现如果从大到小排完序之后再背包，当前加进去的东西一定是最小的。此时如果出现把这个东西拿出来，剩下的都一定比这个大。所以不难理解这么更新的正确性。</p><p>考虑如何记录方案。可以对于每种权值都开一个 <code>bitset</code>，对于每种权值，第一次更新的时候顺便更新 <code>bitset</code>（根据单调性这样一定是最合法的那个）。那么最后的复杂度就是 $O(nm+\frac{nm}{w})$。注意到这么写的意义在于，通过聚和分析可以得知，对于每个权值 $m$ 至多会与其他的价值 $or$ 一次，所以本质上是 $O(\frac{nm}{w})$ 而不是 $O(\frac{n^2m}{w})$（虽然也能过就是了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> half, sum ;</span><br><span class="line"><span class="keyword">int</span> i, v, ans, n ; </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; b[MAXM] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &gt; b.fr ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; f[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].fr) ;</span><br><span class="line">sum += base[i].fr, base[i].sc = i ; </span><br><span class="line">&#125;</span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, cmp) ; half = sum &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (v = sum ; v &gt;= base[i].fr ; v --)&#123; </span><br><span class="line"><span class="keyword">if</span> (!f[v] &amp;&amp; f[v - base[i].fr])</span><br><span class="line">b[v] = b[v - base[i].fr], b[v].<span class="built_in">set</span>(base[i].sc), f[v] = <span class="number">1</span> ;    </span><br><span class="line"><span class="keyword">if</span> (v &gt; half &amp;&amp; f[v] &amp;&amp; v - base[i].fr &lt;= half) ans = max(ans, v) ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[ans].count() &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (b[ans][i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LuoguP1531-鬼子进村"><a href="#LuoguP1531-鬼子进村" class="headerlink" title="[LuoguP1531]鬼子进村"></a>[LuoguP1531]鬼子进村</h1><blockquote><p>县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：</p><ol><li><p>若消息为 <code>D x</code>：鬼子将 $x$ 号房子摧毁了，地道被堵上。</p></li><li><p>若消息为 <code>R</code> ：村民们将鬼子上一个摧毁的房子修复了。</p></li><li><p>若消息为 <code>Q x</code>：有一名士兵被围堵在 $x$ 号房子中。</p></li></ol><p>李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。</p><p>$1\leq n,m\leq 5\times 10^4$。</p></blockquote><p><del>降智题，说实话我第一眼觉得那必然是 LCT；又觉得可达性不好统计，然后就懵了 1min</del></p><p>其实是有两种方法的：</p><h2 id="Sol-1-2"><a href="#Sol-1-2" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑暴力线段树维护，修复和拆毁都是单点修改。查询的话自然是查询一个点左边第一个 $0$ 的位置、右边第一个 $0$ 的位置。首先这显然是可以外层二分，内层区间查询来做到 $\log ^2$ 的（其实也可以不线段树维护，用分块技巧，$O(1)$ 查询区间和、 $O(\sqrt n)$ 单点加的分块，也可以通过本题，同时虽然插入删除都是 $O(\sqrt n)$ 的，但是询问变成了 $\log$ 的）；或者直接在线段树上二分，做到一个 $\log$ 。</p><h2 id="Sol-2-2"><a href="#Sol-2-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>发下有一个性质并没有很好利用起来<del>(虽然本身就是一个很没用的性质)</del>。每次删除的点一定是之前插入的点。所以考虑对于所有炸毁的点维护一棵平衡树，以 $pos$ 作为键值，那么每次查询本质上就是询问前驱和后继。</p><p>……还有要注意可能本身就被炸了，判一下就好了。这种方法也是 $1$ 个 $\log$ 的。</p><h1 id="AT3741-String-Problem"><a href="#AT3741-String-Problem" class="headerlink" title="[AT3741] String Problem"></a>[AT3741] String Problem</h1><blockquote><p>给出两个字符串S和T. 通过执行以下操作，判断是否可以将字符串S转换为字符串T.</p><ul><li>操作 A：删除S中任意位置的字母 A .</li><li>操作 B：在S的任意位置插入一个字母 B .</li></ul><p>S 和 T 的字符都为大写字母，并且 S 和 T 的长度 $\le 1000$ 。</p></blockquote><p>……其实是水题，不过发生了一些奇妙的事情，然后就打算整理一下我的做法？感觉其他人的做法都一毛一样…</p><p>大概就是首先根据样例解释的提示，可以想出一个「先加 B 再删 A」的思路，然后发现前半部分就是一个魔改的 LCS，后半部分就只需要记录一下最少要用多少个 B，看看 s 比 t 多的那些字符是否全是 A 就好了。</p><h1 id="Contest-Hunter5105-Cookies"><a href="#Contest-Hunter5105-Cookies" class="headerlink" title="[Contest Hunter5105] Cookies"></a>[Contest Hunter5105] Cookies</h1><blockquote><p>圣诞老人共有 $m$ 个饼干，准备全部分给 $n$ 个孩子。每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g_i$。如果有 $a_i$ 个孩子拿到的饼干数比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $g_i\times a_i$ 的怨气。给定 $n$、$m$ 和序列 $g$，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。</p><p>$1≤n≤30, n≤m≤5000, 1\leq g_i\leq 10^7$。</p></blockquote><p>首先不难想到要按照 $g_i$ 从大到小排个序，因为肯定要让 $g_i$ 大的人分到更多的饼干。之后设 $f_{i,j}$ 为前 $i$ 个人分了 $j$ 块饼干的最小怨气总和。发现并不好转移。因为要考虑有多少个人和 $i$ 获得的饼干数量相同。此时当然可以考虑多记一维，但是发现其实我们不关心饼干的具体数量，只关心彼此之间的相对关系。</p><p>考虑对于一个状态 $f_{i,j}$ ，如果让第 $i$ 个人只拿到 $1$ 个饼干，则考虑枚举前面有多少人同样拿了 $1$ 个饼干，此时有</p><script type="math/tex; mode=display">f_{i,j}=\min_{k=1}^i\{f_{i-k-1,j-k}+(i-k-1)\cdot \sum_{o=i-k}^ig_o\}</script><p>注意到次数由于钦定了后 $k$ 个人都拿 $1$ 个饼干，所以前后就无关了，需要重新计算这 $k$ 个人的贡献。</p><p>如果让第 $i$ 个人拿到 $&gt;1$ 块饼干，那么考虑由于不关心具体数量，所以这种情况等价于让所有人都少拿一块饼干，即 $f_{i,j}=f_{i,j-i}$ 。于是最后就对这两种情况取一个 $\min$ 即可。</p><h1 id="UVA1621-Jumping-Around"><a href="#UVA1621-Jumping-Around" class="headerlink" title="[UVA1621] Jumping Around"></a>[UVA1621] Jumping Around</h1><blockquote><p>一条 $[0,n]$ 数轴，一开始在 $0$ 处。每次可以选择向左/右以步长为 $1/2/3$ 跳到对应位置，分别只能最多跳 $a,b,c$ 次，保证 $a+b+c=n,a&gt;3,b&gt;3,c&gt;3$ 。求构造一种跳的方案，使得跳到 $1\sim n$ 每个位置恰好 $1$ 次。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>比较有趣的构造题吧…也是化归子问题的构造技巧。</p><p>考虑如果 $c=0$，如果此时 $a&gt;1$ ，那么可以先不断向右以步长为 $1$ 走，直到 $a=1$，然后考虑以步长为 $2$ 向右跳，跳到不能继续跳的时候考虑向左或者向右用一个 $a$，之后再以步长为 $2$ 向左跳回来。可以知道这样一定是合法的。</p><p>如果 $c&gt;0$ ，那么考虑化归到上一种情况。自然是想到，用完全部的 $c$ 跳到某个位置 $p$ 后，$1\sim p$ 都被覆盖了。这个地方有点神：</p><p>（1）如果 $3|c$，大概是考虑先用 $c/3$ 次跳到 $c$ ，然后向右用一个 $a$ ，再向左跳到 $1$ ，再向右用一个 $a$，再向右跳到 $c+2$ 。之后就变成了第一个问题。注意到由于 $a&gt;3$，所以这种方法总是可行的。</p><p>（2）如果 $3|(c+1)$ ，考虑向右用一个 $a$ 转化到 $(1)$ 的情况。发现 $(1)$ 最多需要用到 $3$ 个 $1$ 且 $a&gt;3$ ，这样做总是可行的。</p><p>（3）如果 $3|(c+2)$，考虑先向右一个 $c$ ，再向左一个 $b$，再向右一个 $a$。那么现在的 $c$ 的数量可以被 $3$ 整除。但是考虑由于(1)中的等价位置 $1$ 已经在第一次被跳了，所以最后一步要用 $b$ 。可以知道这样最多用 $2$ 个 $b$ ，也是合法的。 </p><h1 id="Luogu3795-钟式映射"><a href="#Luogu3795-钟式映射" class="headerlink" title="[Luogu3795]钟式映射"></a>[Luogu3795]钟式映射</h1><blockquote><p>设集合 $N=M=\left\{x|x\in N_+,x\leq k,k\in N_+\right\}$ 。设 $f$ 为 $N$ 到 $M$ 的映射。求满足 $f[f(x)]=x$ 的不同的映射 $f$ 的个数。</p><p>$k\leq 10^{8}$ 。</p></blockquote><p>说实话…我遇到这种题就会战术后仰然后不会…类似于什么置换啊、复合映射啊，我就蒙圈的很。</p><p>考虑新加入一个元素。对于一个 $x$，要么 $f(x)=x$，要么就会有一个 $y$ 和 $x$ 配对。所以有</p><script type="math/tex; mode=display">g_i=g_{i-1}+g_{i-2}\cdot (i-1)</script><p>然后就递推即可。</p><p>感觉这个式子本质上和错排可能会有点类似。考虑一个 $n-$完全错位排列 的方案数。假设 $n$ 号元素排到了 $k$ 号位置上，$k$ 号元素恰好也排在了 $n$ 号位置上，那么就是 $(n-1)\cdot g_{n-2}$ ；否则 $k$ 号元素随便错排，那么就是 $(n-1)\cdot g_{n-1}$。那么就是</p><script type="math/tex; mode=display">g_{i}=(i - 1)\cdot(g_{n-1}+g_{n-2})</script><p>感觉递推思想方面是有类似的吧…自己还是…太不聪明了啊</p><p>别找那些理由，就是泥萌的不努力！</p><h1 id="UVA1451-Average"><a href="#UVA1451-Average" class="headerlink" title="[UVA1451]Average"></a>[UVA1451]Average</h1><blockquote><p>给定一个长度为 $n$ 的 $01$ 串，选一个长度至少为 $L$  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 $1$ ~ $n$，因此 $[1,n]$ 就是完整的字符串。</p><p>$1\le n\le 100000,1\le L\le 1000$。</p></blockquote><p><del>又到了复习斜率优化的时间了，斜率优化，常读常新。</del></p><p>考虑前缀和一下就转化成了对每个 $i$ 找到一个 $j&lt;i$ 使得 $\frac{s_i-s_j}{i-j}$ 最大。发现这就是在求最大的斜率。考虑本质上 $x$ 坐标和 $y$ 坐标都是不降的，所以为了斜率单增，要维护一个下凸壳。于是拿一个单调栈维护斜率就好了。复杂度线性。</p><h1 id="HNOI2008-玩具装箱"><a href="#HNOI2008-玩具装箱" class="headerlink" title="[HNOI2008]玩具装箱"></a>[HNOI2008]玩具装箱</h1><blockquote><p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。</p><p>为了方便整理，P教授要求：</p><ul><li><p>在一个一维容器中的玩具编号是连续的。</p></li><li><p>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。</p></li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。</p><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$</p></blockquote><p>大概是斜率优化板板题？考虑方程：</p><script type="math/tex; mode=display">f_{i}=\min_{j=1}^{i-1}\{f_{j}+(i-j+s(i)-s(j)-L)^2\}</script><p>然后考虑拆一下，并且令 $p(i)=s(i)+i,q(i)=s(i)+i+L$ ，那么：</p><script type="math/tex; mode=display">f_{i}=f_{j-1}+(p(i)-q(j))^2=f_{j-1}+p(i)^2-2\cdot p(i)\cdot q(j)+q(j)^2</script><p>那么证明斜率优化可行的基本讨论就是找一个 $j$ 和一个 $k$ 来比大小：</p><p>若 $j&gt;k$ 且 $j$ 比 $k$ 优，那么有</p><script type="math/tex; mode=display">\begin{aligned}f_{j-1}-2\cdot p(i)\cdot q(j)+q(j)^2&<f_{k-1}-2\cdot p(i)\cdot q(k)+q(k)^2\\2\cdot p(i)\cdot q(k)-2\cdot p(i)\cdot q(j)&<f_{k-1}-f_{j-1}+q(k)^2-q(j)^2\end{aligned}</script><p>设 $X_i=q(i),Y_i=f_{i-1}-q(i)^2$，那么有</p><script type="math/tex; mode=display">2\cdot p(i)>\frac{Y_{k}-Y_{j}}{X_{k}-X_{j}}</script><p>也就说当这个式子满足的时候，存在 $j&gt;k$ 且 $j$  比 $k$ 优。</p><p>所以对此可以直接采用斜率优化。注意到 $X$ 单增的同时，斜率本身不降；同时据此可以知道应该维护一个上凸壳，所以可以直接取到队首进行转移的元素。复杂度线性。</p><h1 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="[HAOI2008]硬币购物"></a>[HAOI2008]硬币购物</h1><blockquote><p>共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。</p><p>某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。</p><p>$1 \leq c_i, d_i, s \leq 10^5$，$1 \leq n \leq 1000$。</p></blockquote><p>比较常规的容斥题目。考虑由于硬币个数的限制，大概是要做一个多重背包计数，这样复杂度是 $O(4\cdot n\cdot s)$，大概是 $4e8$ 的级别，如果常数小的话没准信仰一波也是可以过的。</p><p>考虑更加正经一点的做法。发现虽然硬币个数很多，但是种类很少，同时发现不限制使用次数的方案数是很好计算的，于是考虑容斥。$f_v$ 表示不考虑硬币个数，用四种面值凑出 $v$ 的方案数。那么考虑如何统计不合法的方案数。考虑对于一种硬币 $(c_i,d_i)$，看上去，所有他的不合法方案应该是 </p><script type="math/tex; mode=display">\sum_{j=d_i+1}^{+\infty} f_{s-c_i\cdot j}</script><p>但是发现背包模型在计算方案时，状态本身具有简并性。 也就是对于任何一个状态 $f_{i,k}$ 都是被更小的 $f_{i,k-t\cdot c_i}$ 给拼插起来的。所以方案数应该为</p><script type="math/tex; mode=display">f_{s-c_i\cdot (d_i+1)}</script><p>于是容斥一下即可。复杂度 $O(4\cdot s+16\cdot n)$ 。</p><h1 id="CF933A-A-Twisty-Movement"><a href="#CF933A-A-Twisty-Movement" class="headerlink" title="[CF933A]A Twisty Movement"></a>[CF933A]A Twisty Movement</h1><blockquote><p>给定一个序列 A，你可以翻转其中的一个区间内的数，求翻转后的序列的最长不下降子序列的长度。（$|A|\le 2000,1\le a_i \le 2$ ）</p><p>$1\leq n\leq 10^3$。</p></blockquote><p>自己想了一个暴力做法。大概是对于每个位置 $s$ ，可以比较方便地维护出 $s$ 之前以 $0/1$ 结尾的最长上升子序列，同时也可以维护出 $s$ 之后以 $0/1$ 开头结尾的最长上升子序列，这一部分不是那么直观，但是考虑对于一个位置 $p$ ，一定是有某个位置 $q&gt;p$ 使得 $p+1\sim q$ 之间只选 $0$，$q+1\sim n$ 之间只选 $1$ 。这个东西倒着预处理似乎可以 $poly(\log)$ 或者线性，但是由于数据范围所以可以直接暴力。然后每次枚举两个端点暴力即可。中间可能要进行一下玄学的 dp。</p><p>……但其实是可以直接暴力 $dp$ 的。考虑最后选取的一定是一个形如 $1…2….1…2…$ 的子序列，于是就可以设状态 $f_{i,0/1/2/3/4}$ 表示分成了 $0/1/2/3/4$  后的、形如这样的子序列。转移的话就是相邻状态转移即可。复杂度线性。</p><p>当然这题也存在一个闲的胃疼的高级做法，就是线段树上分别维护 $1 \rightarrow 1,1 \rightarrow 2,2 \rightarrow 1,2 \rightarrow 2$ 的最长上升子序列，然后暴力枚举每个区间，复杂度 $O(n^2\log n)$ 。</p><p>emmm 启发了一个 Idea 但是自己不会做，惨惨。</p><h1 id="LuoguP6435-「EZEC-1」数列"><a href="#LuoguP6435-「EZEC-1」数列" class="headerlink" title="[LuoguP6435] 「EZEC-1」数列"></a>[LuoguP6435] 「EZEC-1」数列</h1><blockquote><p>给你一个正整数 $n$，有数列 $\{a_n\}:1,2,3,…,n$。</p><p>分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：</p><p> $1\times a+2\times b+c,2\times a+3\times b +c,…,(n-1)\times a+n\times b+c$。</p><p>对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。</p><p>$1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$ 。</p></blockquote><p>…比较有意思的题目？本质上数学题。</p><p>考虑直接递推。设 $f_k$ 表示经历完 $k$ 次操作之后的第一项。那么考虑最开始 $a_2-a_1$ 的值是 $1$ ，之后每次会变成原来的 $(a+b)$ 倍，那么也就是有：</p><script type="math/tex; mode=display">f_{i}=a\cdot f_{i-1}+b\cdot (f_{i-1}+(a+b)^{i-2})+c</script><p>那么也就是</p><script type="math/tex; mode=display">f_i=(a+b)\cdot f_{i-1}+b\cdot(a+b)^{i-2}+c</script><p>考虑高中数学技巧</p><script type="math/tex; mode=display">\frac{f_i}{(a+b)^i}=\frac{f_{i-1}}{(a+b)^{i-1}}+\frac{b}{(a+b)^2}+\frac{c}{(a+b)^i}</script><p>那么可以通过差分得到</p><script type="math/tex; mode=display">f_i=(i-1)\cdot b\cdot (a+b)^{i-2}+(a+b)^{i-1}+c\cdot \sum_{j=0}^{i-2}(a+b)^j</script><p>发现前面很好算，后面是一个等比数列的形式。由于不保证 $p$ 是素数，所以不能直接求逆元。于是考虑分治乘法。具体的，对于一个 $\sum_{i=1}^n(a+b)^i$ 可以这么算：</p><script type="math/tex; mode=display">\sum_{i=1}^n(a+b)^i=\begin{cases}(a+b)^{\frac{n}{2}}\cdot \sum_{i=1}^{\frac{n}{2}}(a+b)^i+\sum_{i=1}^{\frac{n}{2}-1}(a+b)^i&\mathrm{if}~(n~\mathrm{is~even}) \\(a+b)^{\lfloor \frac{n}{2}\rfloor }\cdot \sum_{i=1}^{\lfloor \frac{n}{2}\rfloor }(a+b)^i+\sum_{i=1}^{\lfloor \frac{n}{2}\rfloor -1}(a+b)^i + (a+b)^n &\mathrm{otherwise}\end{cases}</script><p>然后就可以分治做下去了。复杂度 $\rm poly(\log )$ 。</p><h1 id="UVA1611-Crane"><a href="#UVA1611-Crane" class="headerlink" title="[UVA1611] Crane"></a>[UVA1611] Crane</h1><blockquote><p>输入 $n$ 个数，要求把它变成升序排列，每次操作都可以交换一个长度为偶数的区间的左右两半。要求操作数 $\leq 2n$ 。</p><p>$n\leq 10^6$ 。</p></blockquote><p>大概是一道降智题…</p><p>考虑一个逐步缩小问题规模的思想。元素从小到大考虑，每次把当前未考虑的数列中最小元素 $x$ 移动到他该在的位置 $x$。考虑 $pos_x-x$ 与$\frac{n-x+1}{2}$ 的大小关系，如果 $2\cdot(pos_x-x)+1\leq n-x+1 $，那么就可以直接对区间 $[x,2\cdot pos_x-x]$ 进行操作，否则要先对 $[x,pos_x]$ 进行操作使其不会越界，因为此时 $pos_x-x$ 的长度会缩短为原来的 $\frac{1}{2}$，而由于最长时 $pos_x-x=n-x$ ，所以可知这样一定不会越界。</p><h1 id="LuoguP5007-DDOSvoid-的疑惑"><a href="#LuoguP5007-DDOSvoid-的疑惑" class="headerlink" title="[LuoguP5007] DDOSvoid 的疑惑"></a>[LuoguP5007] DDOSvoid 的疑惑</h1><blockquote><p>给定一棵以 1 为根的有根树，定义树的一个毒瘤集为一个集合，并且集合中任意两个元素之间不存在祖先与后代关系。</p><p>定义一个毒瘤集的毒瘤指数为集合内所有元素的价值之和</p><p>要求给定树的所有毒瘤集的毒瘤指数之和，答案对 $10^8+7$ 取模。</p><p>但这个问题太难了，所以我们考虑化简。</p><p>因为点的编号跟它毒瘤指数密切相关，所以我们将会再给出一个整数 T，T = 1 表示 i 号点的毒瘤指数为 i，T = 0，表示所有点的毒瘤指数都是 1。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>懵了半天还是不会做……</p><p>不难发现这个可以以子树为状态来转移。然后考虑如何将孩子的贡献转移到根，发现需要处理的本质上是合并两棵树的所有毒瘤集。假设两棵树的毒瘤集权值和分别为 $F_1,F_2$，那么发现合并得到的 $F$ 应该至少为 $F_1+F_2$，并且还需要考虑两棵树对彼此的贡献。即将一棵树中的所有元素都分批合并进另一棵树的集合里产生的贡献。</p><p>那么不难知道要记录一下各自树中毒瘤集的个数。于是考虑从下向上 $dp$。设 $g_u$ 表示以 $u$ 为根的子树中毒瘤集的个数，$f_u$ 表示权值和。那么每次考虑将一棵新的子树 $v$ 并进来，所以有转移：</p><script type="math/tex; mode=display">g_u=g_v\times g_u+g_v+g_u\\f_u=f_u\times g_v+f_v\times g_u+f_u+f_v</script><p>复杂度 $O(n)$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;终于！终于不是UVA了！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。&lt;/p&gt;
&lt;p&gt;争取一句话题解…这一弹大概有 $30$ 道题左右吧。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="技巧/分块" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E5%9D%97/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="技巧/倍增" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%80%8D%E5%A2%9E/"/>
    
      <category term="数学/扩展欧几里德" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="数据结构/左偏树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="暴力,brute-force" scheme="https://www.orchidany.cn/tags/%E6%9A%B4%E5%8A%9B-brute-force/"/>
    
      <category term="技巧/行列无关" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E8%A1%8C%E5%88%97%E6%97%A0%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round2] C~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-题解/</id>
    <published>2020-04-26T03:40:56.000Z</published>
    <updated>2020-04-26T12:23:44.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依旧是按照个人做题时认为的难度排序…</p><p>打比赛的时候严重翻车，比赛经验还是太差劲了啊！</p><p><del>于是这篇文章就变成了游记+翻车实录</del></p><a id="more"></a><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>作为苏打绿死忠的我…觉得普及这个 T1 题目背景and题目名称都很赞！</p><h1 id="C-涂色游戏"><a href="#C-涂色游戏" class="headerlink" title="C 涂色游戏"></a>C 涂色游戏</h1><blockquote><p>你有 $10^{20}$ 个格子，它们从 $0$ 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色：</p><ol><li>编号是 $p_1$ 倍数的格子（包括 $0$ 号格子，下同）染成红色。</li><li>编号是 $p_2$ 倍数的格子染成蓝色。</li><li>编号既是 $p_1$ 倍数又是 $p_2$ 倍数的格子，你可以选择染成红色或者蓝色。</li></ol><p>其中 $p_1$ 和 $p_2$ 是给定的整数，若格子编号是 $p_1$ 或 $p_2$ 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 $k$ 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 $p_1$, $p_2$, $k$，你想知道是否有一种染色方案不是无聊的。</p><p>对于所有测试点：$1 \leq T\leq 10^6$，$1\leq p_1,p_2,k\le 10^9$。</p></blockquote><p>以下是做题时凌乱的内心活动</p><blockquote><p>先开题…嗯，混乱地读了半天题，觉得大概是问是否存在一个 $x$ 和一个 $y$ 使得 $p_1&gt;p_2$ 时</p><script type="math/tex; mode=display">y\cdot p_1\leq x\cdot p_2\leq (x+k-1)\cdot p_2\leq (y+1)\cdot p_1</script><p>然后发现似乎很难处理编号是 $[p_1,p_2]$ 及其倍数的情况。然后就开始摸。摸了一会儿之后发现几个性质：</p><p>1、最多只用考虑 <code>yxyxy</code> 这种分布，即最多算上一个 $x$ 和 $y$ 的公倍数。因为如果存在连续两个 $x$ 和 $y$ 的公倍数之间，没有单独的 $y$ 的倍数，那么就说明 $x|y\cdot t,x|y\cdot (t+1)$，也就证明了 $x|y$ ，而这种情况是显然 <code>Yes</code> 的； </p><p>2、大概是每 $\rm lcm$ 一次循环…然后…</p></blockquote><hr><p>然后，读了半天题，才发现读题读反了…这题是要你去 <code>check</code> 是否对于任意一个 $y$ 都存在一个 $x$ 使得</p><script type="math/tex; mode=display">y\cdot p_1< x\cdot p_2< (x+k-1)\cdot p_2< (y+1)\cdot p_1</script><p>同时也不用考虑 $\rm lcm$ 的问题了，因为遇到 $\rm lcm$ 肯定会涂 $p_1$ 色。所以上式直接换成了拟序。</p><p>那么也就是考虑是否满足</p><script type="math/tex; mode=display">p_1-1\geq (k-1)\cdot p_2</script><p>其中为什么是 $p_1-1$ 呢？因为不考虑 $\rm lcm$ 时这就是最近的界。但是注意到这个界有点宽，当且仅当 $(p_1,p_2)=1$ 的时候，存在这种最劣的情况，即式子 $bp_2-ap_1=1$ 存在整数解。</p><p>然后大概就是个代换，发现同时除以 $(p_1,p_2)$ 之后与原结果是等价的。然后就没了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !y ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k, g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        n = qr(), m = qr(), k = qr() ; </span><br><span class="line">        g = gcd(n, m), n /= g, m /= g ;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ll)(k - <span class="number">1</span>) * min(n, m) &lt; max(n, m) - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-建设城市"><a href="#D-建设城市" class="headerlink" title="D 建设城市"></a>D 建设城市</h1><blockquote><p>球球是一位建筑师。一天，他收到市长的任务：建设城市。球球打算建造 $2n$ 座高楼。为了保证城市美观，球球做出了如下计划：</p><ul><li><p>球球喜欢整齐的事物。他希望高楼从左向右排成一行，编号依次为 $1\sim 2n$。</p></li><li><p>球球喜欢整数，他要求每座高楼的高度都是正整数。</p></li><li><p>由于材料限制，高楼的高度无法超过 $m$。</p></li><li><p>球球喜欢中间高，两边低的造型。他要求前 $n$ 座高楼的高度不下降，后 $n$ 座高楼的高度不上升。</p></li><li><p>球球打算选两座编号为 $x,y$ 的高楼作为这座城市的地标。他认为只有当这两座高楼高度相等时，才会让城市变得美观。</p></li></ul><p>球球把自己的想法告诉了市长。市长希望得知所有建设城市的方案数。两种方案不同，当且仅当某座高楼的高度在两个方案中不同。这个问题可难倒了球球。球球找到了你，希望你能帮他算出答案。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。</p></blockquote><p>下午 vp 这道题的时候是真的降智…首先先上已经写好的题解吧：</p><hr><p>首先考虑不加 $a_x=a_y$ 的限制，单纯计算一个不递减序列的方案数。</p><p>发现本质上是这么一个问题：从 $(0,1)$ 开始走，每一步可以向右走，或者向右上走（此处右上指的是 $(x,y)\to(x+1,y+k)\quad k&gt;0$ 的走法），最终走到 $(n,1),(n,2),(n,3)\cdots (n,m)$ 的方案数。那么不难发现，本质上是在对于两个楼之间的高度差进行拼插。若令 $h_0=0,d_{i}=h_{i}-h_{i-1}$ 的话， 那么本质上就是在解一个如下的方程：</p><script type="math/tex; mode=display">d_1+d_2+\cdots+d_n=m</script><p>本质上就是在求这个式子中非负整数解得个数…然而并不是。由于 $1$ 号楼必然高度 $\geq 1$ ，所以差分之后， 需要保证 $d_1&gt;0$ 。</p><p>考虑做一个容斥，用 $d_1\geq 0$ 的答案减去 $d_1=0$ 时的答案。对于 $d_1\geq 0$ ，本质上就是一个 $n$ 元一次不定方程非负整数解计数。那么答案就是 $\binom{n+m-1}{m}$ 。$d_1=0$ 时，相当于用 $n-1$ 个未知元凑出 $m$ 来，方案数就是 $\binom{n+m-2}{m}$ 。所以可知如果不考虑 $x$ 和 $y$ 的限制，答案应该为 $\left(\binom{n+m-1}{m}-\binom{n+m-2}{m}\right)^2$ 。</p><p>考虑加上 $x$ 和 $y$ 的限制。那么需要分类讨论。</p><p>1、考虑如果 $x$ 和 $y$ 在同侧，那么可以都转化到 $1\leq x\leq y\leq n$ 的情况来做。那么 $x,y$ 之间的数都要相等假设此时 $x$ 和 $y$ 均等于 $z$，那么 $1\sim x$ 的方案数就是 $\binom{x+z-1}{z}-\binom{x+z-2}{z}$ ，$y\sim n$ 的方案数就是 $\binom{n-y+z}{z}$，因为此时相相当于有 $n-y+1$ 个未知元，和为 $z$ 的非负整数解个数。最后把这两部分拼插一下即可。</p><p>2、考虑如果 $x$ 和 $y$ 在异侧，那么两者本质上就没有关系了。于是考虑分别处理 $1\sim x,1\sim y,x\sim n,y\sim n$ 的答案，最后拼插一下即可。</p><p>于是复杂度线性。</p><hr><p>然后是花絮…这题说实话我做了很久很久…以下事情按时间线排布：</p><ul><li>看了这题，觉得 $60$ 分很 ez，然后就在想 $100$ 分怎么搞。因为上次 NOIonline 给我的经验是，生成函数是可以进普及组的，于是觉得这个 100 一定是个生成函数。</li><li>wqy 说是 xxs 组合题。我想了一会儿觉得大概可以转化成从 $(0,1)$ 走到 $(n,m)$ ，每一步可以平着走或者飞到右边一列一个更高的高度上。算了一波，觉得可能跟 $m$ 的 $n$ 元可含 $0$ 有序拆分有关…觉得不太行。</li><li>wqy 说是插板法。我觉得自己是个弱智。因为「 $m$ 的 $n$ 元可含 $0$ 有序拆分」 本质上就是 $n$ 元一次不定方程组 <script type="math/tex; mode=display">x_1+x_2+\cdots +x_n=m</script></li></ul><p>的非负整数解组数。于是觉得枚举 $x$ 的高度然后做就很稳，遂开始写代码。</p><ul><li>写了半天，恍惚中觉得应该对 $\binom{n+m-1}{m}$ 这东西做一个前缀和，因为 $x$ 的高度如果是 $h$ ，那么 $x-1$ 的高度似乎可以是 $0\sim h$ …【注意！这个地方是有两个bug！！</li><li>连写带调试过了好久，发现自己是弟弟，前缀和压根不对。因为枚举的是 $x$ 的高度，所以对于每个 $x$ 的高度，$[1…x-1]$ 的不同方案已经被准确计数了…发现自己的思路乱的很。</li><li>又写了很久，还是不对，心情郁闷。冷静了一下发现 $1$ 号位置，即 $x_1$ ，取值不能为 $0$ 。想了想，觉得容斥一下就好了。</li><li>最后发现 $70$ 分。下了数据之后思考了一下，发现是 <code>case1</code> 里面，如果 $x$ 和 $y$ 都在另一侧，那么转过来应该是 $y&lt;x$…</li></ul><p>写完之后感觉自己花了这么多时间，十分弟弟。总结一下问题：</p><p>1、平时深入思考的情况比较少，遇到这种需要认真思考的东西，思路就会很乱很乱。</p><p>2、自己思维方式一直存在很大问题，加上草稿打的十分乱，就让人做题的时候内心不安静。</p><p>要抓紧改正啊。<del>虽然我觉得可能是我太困了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> num[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> numx[N] ;</span><br><span class="line"><span class="keyword">int</span> numy[N] ;</span><br><span class="line"><span class="keyword">int</span> xnum[N] ;</span><br><span class="line"><span class="keyword">int</span> ynum[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n, x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y ; ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m + n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[m + n + <span class="number">1</span>] = expow(fac[m + n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = (ll)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!((n - x &gt;= <span class="number">0</span>) ^ (n - y &gt;= <span class="number">0</span>)))&#123;</span><br><span class="line">        x = x &lt; n ? x : n - (x - n) + <span class="number">1</span> ;</span><br><span class="line">        y = y &lt; n ? y : n - (y - n) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) swap(x, y) ; numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = binom(n - y + i, i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) num[i] = addn(num[i - <span class="number">1</span>], decn(binom(n + i - <span class="number">1</span>, i), binom(n + i - <span class="number">2</span>, i))) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans, (ll)numx[i] % P * numy[m - i] % P) ;</span><br><span class="line">        ans = (ll)ans * num[m] % P ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    y = n - (y - n) + <span class="number">1</span> ;</span><br><span class="line">    xnum[<span class="number">0</span>] = ynum[<span class="number">0</span>] = numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = decn(binom(y + i - <span class="number">1</span>, i), binom(y + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) xnum[i] = binom(n - x + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ynum[i] = binom(n - y + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        add(ans, (ll)numx[i] % P * numy[i] % P * ynum[m - i] % P * xnum[m - i] % P) ; <span class="comment">//, cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-简单子序列问题"><a href="#E-简单子序列问题" class="headerlink" title="E 简单子序列问题"></a>E 简单子序列问题</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。</p><p>现在，请你求出 </p><script type="math/tex; mode=display">\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2</script><p>由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。</p><p>对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。</p></blockquote><p>这题似乎是普及题，但是我不知道为什么，就把这题转化到了这个题的对称问题上…导致这题做了很久很久很久…</p><p>以下是题解：</p><hr><p>我来说一个很不正常的解法…不正常在他特别麻烦…特别难调…</p><p>我的做法是先算出全部区间的贡献：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^n(j-i)^2=\sum_{i=1}^n(1^2+2^2+3^2+\cdots +(n-i)^2)</script><p>也就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{(n-i)(n-i+1)(2\times (n-i)+1)}{6}</script><p>然后考虑减掉那些不合法的。具体的，预处理出每个位置左边最近的那个相同颜色的下标 $pre_x$ 。那么 $x$ 和 $pre_x$ 会对左端点在 $1\sim pre_x$ ，右端点在 $x+1\sim n$ 的区间产生贡献。贡献怎么算呢？</p><p>考虑假设一个区间长为 $L$ 。那么第一组 $(pre_x,x)$ 出现时，会有</p><script type="math/tex; mode=display">L^2\to (L-1)^2=L^2-2L+1=L^2-(2L-1)</script><p>第二组出现时：</p><script type="math/tex; mode=display">(L-1)^2\to (L-2)^2=(L-1)^2-2(L-1)+1=(L-1)^2-(2L-3)</script><p>以此类推，当一个区间存在 $t$ 个重复颜色时（即假设某种颜色的数量为 $c$，那么这种颜色的「重复颜色数」为 $c-1$），他需要减去 $(2\cdot t\cdot L-t^2)$ 的贡献。</p><p>考虑拆成两半做：</p><p>1、$2\cdot t\cdot L$</p><p>需要枚举每个位置 $i$ ，设 $j=pre_i$ 。记 $p=\max\{(n-i+1),i\},q=\min\{i,(n-i+1)\}$ 。即 $p$ 是左右两边较长的那个区间，$q$ 是较短的那个。同时记当前区间长度为 $d$，即 $d=i-pre_i$ 。以下默认省略前面的系数 $2$ 。</p><p>那么需要再分三类讨论会被产生贡献的区间长度 $L$ ，以下在计算 $L$ 时，用 $d+\Delta$ 来代替：</p><blockquote><p>（1）$d+1\leq L\leq q+d$ </p><p>对于每个这样的 $L$ ，会存在 $L-d$ 个区间产生合法贡献，所以这部分贡献就是</p></blockquote><script type="math/tex; mode=display">\sum_{L=d+1}^{q+d}L\cdot i=\sum_{i=1}^{q}(d+i)\cdot i</script><blockquote><p>可以通过预处理 $\sum i$ ，$\sum i^2$ 快速计算。</p><p>（2） $q+d+1\leq L\leq p+d$ </p><p>对于每个这样的 $L$ ，由于不能全部取到，所以至多会有 $q$ 个。所以这部分贡献是：</p></blockquote><script type="math/tex; mode=display">\sum_{L=q+d+1}^{p+d}L\cdot q=\sum_{i=q+1}^{p}(d+i)\cdot q</script><blockquote><p>这部分比较好算。</p><p>（3） $p+d+1\leq L\leq n$</p><p>对于每个这样的 $L$ ，发现最多只能取到 $n-L+1$ 次。所以这部分贡献是</p></blockquote><script type="math/tex; mode=display">\sum_{L=p+d+1}^{n}L\cdot (n-L+1)=\sum_{i=p+1}^{n-d}(n-d-i+1)\cdot (d+i)</script><blockquote><p>这一部分同样可以通过预处理来快速计算。</p></blockquote><p>综上，这一部分的复杂度是排序外线性。</p><p>2、$-t^2$ </p><p>设 $i$ 右边第一个和 $i$ 同颜色的元素为 $r_i$ 。</p><p>也就是现在把问题转化成了「{区间内重复出现的数字个数 $-1$ 的平方和」。考虑扫描线。一开始将所有的数都加进线段树。从左开始，每次都删掉一个最左边的元素 $i$。如果这个元素的颜色依旧出现在后面的序列中，那么可以知道对于所有右端点 $\geq r_i$ 的区间，都会少掉一个 $(i, r_i)$ 组成的 <code>pair</code>，也就是会少掉一个重复颜色的元素。所以就是后缀减 $-1$ and 询问后缀的平方和，线段树维护即可。</p><p>这一部分复杂度 $O(n\log n)$ 。   </p><p>如何卡常：</p><p>1、不要用 <code>map</code> .</p><p>2、(mayaohua 在 uoj 群里的高论)发现中间，一段区间内部的平方的和本质上是不会爆 <code>long long</code> 的，所以可以减少取模次数。</p><hr><p>心路历程：</p><ul><li>A 完 T1 之后，发现这题「不就是记一下上次出现的位置，然后减掉左端点在 $[1,pre_x]$、右端点在 $[x,n]$ 内的贡献吗？妥了妥了！」<del>期间甚至嘲讽了一波这题很套路</del></li><li>算了一下发现…这个平方和好像很难算。一波拆分之后，觉得应该分成两半做。比较难的似乎是后面的 $t^2$(很久很久的以后我才发现不是这样)。</li><li>然后开始写写写，期间由于思路混乱(D里面提到的缺点集中展现)，于是写了一会儿才写完(但此时，我只想到了前两部分，没有考虑第三部分)。</li><li>写完之后才意识到…我似乎把这个问题转化到了一个和原问题等难的问题上…就很降智。然后决定先写 $50pts$ 的暴力做法。</li><li>写完暴力才意识到原来扫描线就好了…于是开始写线段树。</li><li>这个线段树我写的就…就很梦幻…我不记得我写过这么梦幻的线段树。大概就是 bug 满天飞…体验极差…</li><li>最终总算是调完了，和 $50pts$ 暴力对着拍了几组觉得很稳。</li><li>因为总觉得自己第一部分推的有问题，所以写了个 $n^3$ 暴力。写完才发现挂惨了…</li><li>冷静了很久，发现是自己推挂了。于是推了推第三部分，发现展开之后式子很长。然后 <code>main</code> 函数中间的那个 <code>for</code> 就写了很长…</li><li>最后在谷上测发现自己 TLE+取模挂了，于是把 <code>map</code> 改成 <code>sort+lower_bound</code> 就 A 掉了…</li></ul><p>…技不如人，技不如人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dec</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; x = x &lt; <span class="number">0</span> ? x + mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">addn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; <span class="keyword">return</span> (x = x &gt; mod ? x - mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">decn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; <span class="keyword">return</span> (x = x &lt; <span class="number">0</span> ? x + mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line">ll tg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] = val[l]  ;</span><br><span class="line">        t[rt] = s[rt] * s[rt] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(ls, l, mid) ;</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">s[rt] = s[ls] + s[rs] ;</span><br><span class="line">t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tg[rt])&#123;</span><br><span class="line">        ll p = tg[rt] * tg[rt] % P ;</span><br><span class="line">        ll pr = r - ((l + r) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">        ll pl = ((l + r) &gt;&gt; <span class="number">1</span>) - l + <span class="number">1</span> ;</span><br><span class="line">        tg[ls] += tg[rt], tg[rs] += tg[rt] ;</span><br><span class="line">        dec(t[ls], decn(<span class="number">2l</span>l * s[ls] * tg[rt] % P, p * pl)) ;</span><br><span class="line">        dec(t[rs], decn(<span class="number">2l</span>l * s[rs] * tg[rt] % P, p * pr)) ;</span><br><span class="line">        dec(s[ls], tg[rt] * pl % P) ; dec(s[rs], tg[rt] * pr % P) ; tg[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        dec(t[rt], decn(<span class="number">2l</span>l * s[rt] % P, <span class="number">1l</span>l * (r - l + <span class="number">1</span>))) ;</span><br><span class="line">        dec(s[rt], <span class="number">1l</span>l * (r - l + <span class="number">1</span>)) ; tg[rt] += <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    s[rt] = s[ls] + s[rs] ; t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ll res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) res += query(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) res += query(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll sum1[N] ;</span><br><span class="line">ll sum2[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll fuck[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">base[i] = tmp[i] = qr() ;</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) pos[i] = buc[base[i]] ; buc[base[i]] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        sum1[i] = addn(sum1[i - <span class="number">1</span>], i) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">sum2[i] = addn(sum2[i - <span class="number">1</span>], i * i)  ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(ans, (i + <span class="number">1</span>) * i * (<span class="number">2l</span>l * i + <span class="number">1l</span>l) % P) ;</span><br><span class="line">    ans = ans * Inv6 % P ;</span><br><span class="line">    ll q, maxx, minx, m, p, len1, len2, d ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos[i])</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">q = n - i + <span class="number">1</span> ;</span><br><span class="line">        maxx = q, minx = pos[i] ;</span><br><span class="line">        p = i - pos[i], m = n - p ;</span><br><span class="line">        d = decn(sum1[m], sum1[maxx]) ;</span><br><span class="line">        <span class="keyword">if</span> (minx &gt; maxx) swap(minx, maxx) ;</span><br><span class="line">        len2 = m - maxx, len1 = maxx - minx ;</span><br><span class="line">      <span class="comment">//part1</span></span><br><span class="line">        add(res, sum2[minx]) ;</span><br><span class="line">        add(res, sum1[minx] * p) ;</span><br><span class="line">      <span class="comment">//part2</span></span><br><span class="line">        add(res, p * minx * len1) ;</span><br><span class="line">        add(res, minx * decn(sum1[maxx], sum1[minx], P) % P) ;</span><br><span class="line">        <span class="comment">//part3</span></span><br><span class="line">        dec(res, <span class="number">2l</span>l * p * d % P) ;</span><br><span class="line">        dec(res, p * p * len2 % P) ;</span><br><span class="line">add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * d % P) ;</span><br><span class="line">dec(res, decn(sum2[m], sum2[maxx])) ;</span><br><span class="line">        add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * p * len2 % P) ;</span><br><span class="line">        dec(ans, <span class="number">2l</span>l * res % P) ; res = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">           fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                buc[base[j]] ++ ;</span><br><span class="line">                fuck[i][j] = fuck[i][j - <span class="number">1</span>] + (buc[base[j]] &gt; <span class="number">1</span>) ;</span><br><span class="line">                add(ans, fuck[i][j] * fuck[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        nxt[i] = buc[base[i]] ? buc[base[i]] : n + <span class="number">1</span>, buc[base[i]] = i ;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        buc[base[i]] ++, val[i] = val[i - <span class="number">1</span>] + (buc[base[i]] &gt; <span class="number">1</span>) ;</span><br><span class="line">    build (<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, i, n) % P) ;</span><br><span class="line">        <span class="keyword">if</span> (nxt[i] &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, nxt[i], n) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-游戏"><a href="#F-游戏" class="headerlink" title="F 游戏"></a>F 游戏</h1><blockquote><p>小 A 和小 B 正在玩一个游戏：有一棵包含 $n=2m$ 个点的有根树（点从 $1\sim n$ 编号），它的根是 $1$ 号点，初始时两人各拥有 $m$ 个点。游戏的每个回合两人都需要选出一个自己拥有且之前未被选过的点，若对手的点在自己的点的子树内，则该回合自己获胜；若自己的点在对方的点的子树内，该回合自己失败；其他情况视为平局。游戏共进行 $m$ 回合。</p><p>作为旁观者的你只想知道，在他们随机选点的情况下，第一次非平局回合出现时的回合数的期望值。</p><p>为了计算这个期望，你决定对于 $k=0,1,2,\cdots,m$，计算出非平局回合数为 $k$ 的情况数。两种情况不同当且仅当存在一个小 A 拥有的点 $x$，小 B 在 $x$ 被小 A 选择的那个回合所选择的点不同。</p><p>由于情况总数可能很大，你只需要输出答案对 $998244353$ 取模后的结果。</p><p>$n\leq 5000$ 。</p></blockquote><p><del>第一眼看到「期望」字样其实我是想弃的。</del></p><p>不算十分有趣的题，比较中规中矩地考察了<del>我没有的</del>硬实力。</p><p>考虑因为是随机选点，先要计算一个 $f_{i,j}$ 表示子树 $i$ 内凑出 $j$ 个不同的「非平局点对」的方案数。转移考虑两部分:</p><p>1、子树之间的贡献：就是普通的树上背包那么转移。注意到如果界定的好是可以 $n^3\to n^2$ 的。</p><p>2、根与子树之间的贡献：加法原理一波带走即可。</p><p>然后考虑 $f_{1,i}$ 就是整棵树凑出 $i$ 个不合法对，也就是不平局 $i$ 次的方案数。考虑利用这个东西，本质上还是很难求出共非平局 $k$ 次的方案数，因为无法快速统计剩下那些平局的贡献。但是考虑，可以快速计算出非平局 $\geq k$ 次的方案数，就是 $f_{1,k}\cdot (\frac{n}{2}-k)! $ 。至于为什么呢…可以理解为剩下 $n-2\cdot k$ 个人，固定住一半个人，剩下一半的人随便找一个匹配，那么方案数就是剩下一半人的全排列，即 $(\frac{n-2\cdot k}{2})!$ 。</p><p>那么考虑令 $f_i$ 表示至少非平局 $i$ 次的方案数，设 $g_i$ 为恰好平局 $i$ 次的方案数，那么根据二项式反演有 </p><script type="math/tex; mode=display">f_i=\sum_{j=i}^{m}g_j\binom{j}{i}\cdot (-1)^{j-i}</script><p>于是复杂度 $O(n^2)$，略卡常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll F[N] ;</span><br><span class="line">ll G[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll tmp[N] ;</span><br><span class="line">ll f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> suma[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll comb[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span> ; f[x][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa)</span><br><span class="line"><span class="keyword">continue</span> ; do_dp(to(k), x) ;</span><br><span class="line">fill(tmp, tmp + size[to(k)] + size[x] + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = min(size[x], n / <span class="number">2</span>) ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = min(size[to(k)], n / <span class="number">2</span> - i) ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f[to(k)][j])</span><br><span class="line">add(tmp[i + j], f[x][i] * f[to(k)][j] % P, P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size[x] + size[to(k)] ; ++ i) f[x][i] = tmp[i] ;</span><br><span class="line">        suma[x] += suma[to(k)] ; size[x] += size[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line"><span class="keyword">if</span> (!base[x])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(size[x] - suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(".in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">//freopen(".out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, fac[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]), suma[i] = base[i] ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add_e(u, v) ; do_dp(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>], P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        F[i] = f[<span class="number">1</span>][i] * fac[n / <span class="number">2</span> - i] % P ;</span><br><span class="line"><span class="comment">//debug(f[1], 0, n) ; debug(F, 0, n) ; debug(fac, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(G[i], F[j] * comb[j][i] % P, P) : dec(G[i], F[j] * comb[j][i] % P, P) ;</span><br><span class="line">    debug(G, <span class="number">0</span>, n / <span class="number">2</span>, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是太弱啊…不过打这一场比赛确实很浪费精力，毕竟一道线段树+一道 xxs 组合加起来我能调 $7h$ 也是相当弱菜了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是按照个人做题时认为的难度排序…&lt;/p&gt;
&lt;p&gt;打比赛的时候严重翻车，比赛经验还是太差劲了啊！&lt;/p&gt;
&lt;p&gt;&lt;del&gt;于是这篇文章就变成了游记+翻车实录&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round1] A~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/24/NOIOLRound1-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/24/NOIOLRound1-题解/</id>
    <published>2020-04-24T11:47:41.000Z</published>
    <updated>2020-04-29T13:12:52.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…</p><p>于是就打算整理一下这六道题。感觉…还是有点东西的吧。</p><p>题目难度按我自己心目中的升序排序。</p><blockquote><p>心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。</p></blockquote><a id="more"></a><h1 id="A-文具订购"><a href="#A-文具订购" class="headerlink" title="A 文具订购"></a>A 文具订购</h1><blockquote><p>小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：</p><ol><li>圆规，每个 $7$ 元。</li><li>笔，每支 $4$ 元。</li><li>笔记本，每本 $3$ 元。</li></ol><p>小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：</p><ol><li>$n$ 元钱必须正好用光，即 $7a+4b+3c=n$。</li><li>在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。</li><li>在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。</li></ol><p>请你帮助小明求出满足条件的最优方案。可以证明若存在方案，则最优方案唯一。</p><p>对于全部的测试点，保证 $0 \leq n \leq 10^5$。</p></blockquote><p>考虑贪心。发现大概是 $14$ 元一套，于是就从 $\lfloor\frac{n}{14}\rfloor$ 枚举到 $0$ 。如果钱数不是 $14$ 的倍数，当然是把剩下的用来买 $3$ 和 $4$ 最合理。于是就模拟一遍即可，同时再去找 $a+b+c$ 的最大值。大概是 div2B 的难度？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = n / <span class="number">14</span> ;</span><br><span class="line">    <span class="keyword">while</span> (ans &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        outp = <span class="number">0</span> ;</span><br><span class="line">        a = b = c = ans ;</span><br><span class="line">        pq = a * <span class="number">14</span>, res = n - pq ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= res / <span class="number">3</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> ((res - i * <span class="number">3</span>) % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                outp = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> * ans + i + (res - i * <span class="number">3</span>) / <span class="number">4</span> &gt; a + b + c)</span><br><span class="line">                    b = ans + (res - i * <span class="number">3</span>) / <span class="number">4</span>, c = ans + i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (outp)</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c) ;</span><br><span class="line">        <span class="keyword">else</span> ans -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-冒泡排序"><a href="#B-冒泡排序" class="headerlink" title="B 冒泡排序"></a>B 冒泡排序</h1><blockquote><p>给定一个 $1 ∼ n$ 的排列 $p_i$，接下来有 $m$ 次操作，操作共两种：</p><ol><li>交换操作：给定 $x$，将当前排列中的第 $x$ 个数与第 $x+1$ 个数交换位置。</li><li>询问操作：给定 $k$，请你求出当前排列经过 $k$ 轮冒泡排序后的逆序对个数。</li></ol><p>对一个长度为 $n$ 的排列 $p_i$ 进行一轮冒泡排序的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1 to n-1:</span><br><span class="line">  if p[i] &gt; p[i + 1]:</span><br><span class="line">    swap(p[i], p[i + 1])</span><br></pre></td></tr></table></figure><br>对于所有测试点：$2 \leq n,m \leq 2 \times 10^5$，$t_i \in \{1,2\}$，$1 \leq x &lt; n$，$0 \leq k &lt; 2^{31}$。</p></blockquote><p>这题在考场上写了神必线段树…复杂度也不对…就很弱智。</p><p>大概就是首先要去洞见冒泡排序的一个性质。每轮冒泡排序会让每个元素排到他后面第一个比他大的元素之前，把最大的元素移到序列最后。假设这是一对 $(i,j)$ ，$j$ 是 $i$ 后面第一个大于 $i$ 的元素。那么考虑这个操作使得， $i$ 移动到 $j$ 前面一个位置，同时所有 $x$ 之间不会彼此交换。</p><p>回顾这一过程，发现 $i+1\le x\le j-1$ 的所有 $x$ 的逆序对(此处特指 $x$ 与 $1\sim x-1$ 形成的逆序对)数量都会向前移动一位且不变(中间只会进行跟 $i$ 有关的操作)，且由于本质上 $i$ 与前面构成的逆序对数量等于 $j$ 与前面构成的逆序对数量 (因为此时并不存在一个比 $i$ 小的 $k$ 满足 $a_k&gt;a_i$ ，因为根据冒泡排序这会让 $a_i$ 被 $a_k$ 换掉成为前面某个「对」的 $x’$) ，所以此时 $j$ 的逆序对数为 $0$，那么 $i$ 的逆序对数也为 $0$ 。</p><p>更进一步，本题相当于需要维护一个序列 $\{p_n\}$，支持：</p><p>1、单点加/减（维护初始逆序对数</p><p>2、询问</p><script type="math/tex; mode=display">\left(\sum_{p_i>k} p_i\right)-\left(\sum_{p_i > k} k\right)</script><p>考虑这东西就拿一个树状数组维护一下权值就好了。复杂度 $m\log n$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    <span class="keyword">int</span> p ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &lt; y.v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= n ; p += low(p)) b[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += b[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] += c1 ;</span><br><span class="line">        t[rt] += c2 ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, c1, c2) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, c1, c2) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    t[rt] = t[rt &lt;&lt; <span class="number">1</span>] + t[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask1(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask1(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask2(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask2(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> t, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].v), base[i].p = i ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        res[base[i].p] = ask(base[i].p) ;</span><br><span class="line">        ans += res[base[i].p] ; add(base[i].p, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, res[i], res[i], <span class="number">1</span>) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;c) ;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(res[c], res[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], -res[c], <span class="number">-1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], -res[c + <span class="number">1</span>], <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (base[c].v &lt; base[c + <span class="number">1</span>].v) </span><br><span class="line">res[c + <span class="number">1</span>] ++ ; <span class="keyword">else</span> res[c] -- ;  </span><br><span class="line">            swap(base[c], base[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], res[c], <span class="number">1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], res[c + <span class="number">1</span>], <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ret ;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = ask1(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line">                ret -= (ll)c * ask2(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; c &lt;&lt; " " &lt;&lt; ask1(1, 1, n, c + 1, n) &lt;&lt; " " &lt;&lt; ask2(1, 1, n, c + 1, n) &lt;&lt; endl ;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>最后还是写的线段树，略略略</del></p><h1 id="C-跑步"><a href="#C-跑步" class="headerlink" title="C 跑步"></a>C 跑步</h1><blockquote><p>小 H 是一个热爱运动的孩子，某天他想给自己制定一个跑步计划。小 H 计划跑 $n$ 米，其中第 $i(i \geq 1)$ 分钟要跑 $x_i$ 米（$x_i$ 是正整数），但没有确定好总时长。</p><p>由于随着跑步时间增加，小 H 会越来越累，所以小 H 的计划必须满足对于任意 $i(i &gt;1)$ 都满足 $x_i \leq x_{i-1}$。</p><p>现在小 H 想知道一共有多少个不同的满足条件的计划，请你帮助他。两个计划不同当且仅当跑步的总时长不同，或者存在一个 $i$，使得两个计划中 $x_i$ 不相同。</p><p>由于最后的答案可能很大，你只需要求出答案对 $p$ 取模的结果。 </p><p>对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq p &lt; 2^{30}$。</p></blockquote><p>发现就是整数拆分问题。分拆数问题本质上是 $n$ 也无标号的第二类斯特林数问题（第二类斯特林数是 $n$ 有标号但是 $k$ 无标号）。</p><p>那么对于这个问题，考虑两种 $dp$.</p><ul><li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}+f_{i-j,j}</script><p>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢掉一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</p><ul><li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script><p>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</p><p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p><p>但是上述做法是 $n^2$ 的。总结两个 $dp$ 的优劣，发现如果采用根号分治的策略，对于 $f$ 只转移 $&lt; \sqrt n$ 的，对于 $g$ 只转移 $\geq \sqrt n$ 的，那么两者均只需要 $n\sqrt n$ 的时空代价（因为大于 $\sqrt n$ 的数不会用超过 $\sqrt n$ 个）。</p><p>具体的，考虑对先用 $f$ 求出来 $j&lt; \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字：就是第一维把 $\sqrt n$ 当作步长转移即可。</p><p>之后考虑如何合并答案。发现 $f,g$ 对于同一个 $n$，计数的部分互斥且互补，那么就可以直接乘法原理解决。合并是个卷积状物，但由于本题只需要求第 $n$ 项，所以直接算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">403</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, p ;</span><br><span class="line"><span class="keyword">int</span> f[N][B] ;</span><br><span class="line"><span class="keyword">int</span> g[N][B] ;</span><br><span class="line"><span class="keyword">int</span> X[N], Y[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">    S = n / B + <span class="number">1</span> ; X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; B ; ++ i) f[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; B ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) f[i][j] = f[i][j - <span class="number">1</span>] ;</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p ;</span><br><span class="line">            X[i] = f[i][j] ; <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; X[i] &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span> ; Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S &amp;&amp; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B) (g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) (g[i][j] += g[i - j][j]) %= p ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S ; ++ j)</span><br><span class="line">            (Y[i] += g[i][j]) %= p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        (ans += <span class="number">1l</span>l * X[i] * Y[n - i] % p) %= p ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-序列"><a href="#D-序列" class="headerlink" title="D 序列"></a>D 序列</h1><blockquote><p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p><p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p><p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p><p>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in \{1,2\}$，$1\le u_i,v_i \le n$。</p></blockquote><p>被教育了，我大概并查集这方面就是白痴中的战斗机了。</p><p>考虑大概能琢磨出这么几个没啥用的性质：1、如果 $a,b$ 和 $b,c$ 两对之间分别被 $1$ 相连，那么相当于 $a$ 和 $c$ 被 $1$ 相连；2、如果 $a,b$ 之间 $0$ 相连，$b,c$ 之间 $0$ 相连，那么可以知道 $a$ 和 $c$ 就相当于有一条 $1$ 边。</p><p>然后…大概就可以搞一个边带权并查集了。同一个集合内部如果只有 $1$ 边，那么总和可以随意分配；如果某个集合内部向自己连了 $1$ 边和 $0$ 边，那么就可以让某两个元素同时加减，只要和是偶数即可。</p><p>其实也不难吧…还是自己过于弱菜啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> D[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x] ;</span><br><span class="line">    <span class="keyword">int</span> dad = find(fa[x]) ;</span><br><span class="line">    val[x] ^= val[fa[x]] ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = dad ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2)</span><br><span class="line">res[f1] |= val[x] ^ val[y] ^ c ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">val[f1] = val[x] ^ val[y] ^ c ;</span><br><span class="line">        fa[f1] = f2 ; res[f2] |= res[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sign</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> t, u, v, ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            val[i] = f[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">fa[i] = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), D[i] = A[i] - B[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;u, &amp;v) ;</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">1</span>) t -= <span class="number">2</span> ; merge(t, u, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">f[i] += D[i] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f[p] += get_sign(val[i]) * D[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p != i) f[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (res[i] &amp;&amp; f[i] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[i] != <span class="number">0</span>)  &#123; ans = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">puts</span>(ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-魔法"><a href="#E-魔法" class="headerlink" title="E 魔法"></a>E 魔法</h1><blockquote><p>C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。</p><p>现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。</p><p>注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 </p><p>$1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。</p><p>$1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。</p></blockquote><p>其实也不难？考虑暴力做的话就是分层图最短路，状态数是 $O(nk)$ 的。可以拿到洛谷数据的 $70$ 分。大概就是先拿每条边预处理出 $f_{i,j,1}$ 表示 $(i,j)$ 之间只修改了 $1$ 次的答案。考虑转移的话，自然就是以 $1$ 为步长转移(小技巧，只用枚举最小规模的子问题)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; ll w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; pq ;</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">-1</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i ^ j) dis[i][j] = (ll)<span class="number">1e12</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w) ;</span><br><span class="line">        A[u][v] = w, dis[u][v] = min(dis[u][v], w) ;</span><br><span class="line">        edg[i][<span class="number">0</span>] = u, edg[i][<span class="number">1</span>] = v, edg[i][<span class="number">2</span>] = w ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = dis[i][j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = edg[k][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">int</span> y = edg[k][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                f[i][j][<span class="number">1</span>] = min(f[i][j][<span class="number">1</span>], dis[i][x] + dis[y][j] - (ll)edg[k][<span class="number">2</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= pq ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= n ; ++ o)</span><br><span class="line">                    f[i][j][k] = min(f[i][j][k], f[i][o][k - <span class="number">1</span>] + f[o][j][<span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">if</span> (!pq) <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n][pq] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最后的转移形式为 </p><script type="math/tex; mode=display">f_{i,j,k}=\min_{o}\{f_{i,o,k-1}+f_{o,j,1}\}</script><p>这是一个扩展矩乘的形式。所以可以直接把预处理出来的 $f_{i,j,1}$ 作为矩阵的元素，快速幂即可。</p><h1 id="F-最小环"><a href="#F-最小环" class="headerlink" title="F 最小环"></a>F 最小环</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $a_i$，下标从 $1$ 开始编号。我们将该序列视为一个首尾相邻的环，更具体地，对于下标为 $i$, $j(i \leqslant j)$ 的两个数 $a_i$, $a_j$，它们的距离为 $\min(j-i, i+n-j)$。</p><p>现在再给定 $m$ 个整数 $k_1$, $k_2$,…, $k_m$，对每个 $k_i(i=1$, $2$,…, $m)$，你需要将上面的序列 $a_i$ 重新排列，使得环上任意两个距离为 $k_i$ 的数字的乘积之和最大。</p><p>对于所有测试数据：$1 \leqslant m \leqslant n \leqslant 2 \times 10^5$，$0 \leqslant k \leqslant \lfloor n/2\rfloor$，$1 \leqslant a_i \leqslant 10^5$。</p></blockquote><p>为什么把这题放在 F 呢？因为一方面我最优化比较菜，另一方面我一看这种题就有种「信我，你不会」感觉233</p><p>这居然是个贪心…我也是人傻掉… 感觉自己贪心真的是菜爆了啊！</p><p>首先考虑相邻的元素大概是 $t~,~t+k~,~t+2\times k~,~t+3\times k~,~t+4\times k\cdots \pmod{n}$ 这种。记这个数列为「$t$ 在模 $n$ 意义下关于 $k$ 的轨迹」。</p><p>那么可以解一下方程求得循环节的长度：</p><script type="math/tex; mode=display">t\equiv t+p\times k\pmod n</script><p>根据同余的基本性质可以得出</p><script type="math/tex; mode=display">p\equiv 0\pmod {\frac{n}{(n,k)}}</script><p>那么可以知道最小的循环长度为 $\frac{n}{(n,k)}$ 。那么最多就会有 $(n,k)$ 条不同的轨迹。</p><p>另一方面，如果存在两个不同的 $t_0,t_1$，他们某一刻轨迹产生了相交，即</p><script type="math/tex; mode=display">t_0+p\times k\equiv t_1+q\times k\pmod{n}</script><p>那么会有</p><script type="math/tex; mode=display">(t_0-t_1)\equiv k\times (q-p)\pmod n</script><p>因为这个式子等价于一个一元二次不定方程，可知如果这个式子可以解出一组整数解，必须满足 </p><script type="math/tex; mode=display">(n,k)|(t_0-t_1)</script><p>那么也就是说，如果两个 $t$ 的轨迹有相交，那么需要这两个 $t$ 之间的距离是 $(n,k)$ 的倍数。这也间接证明了，至多只会有 $(n,k)$ 条本质不同的轨迹。</p><p>考虑根据排序不等式，乘积方面一定是大的和大的拼在一起，小的和小的拼在一起更优。所以可以预处理每个不同的环长 $\zeta$ ，对于每一个 $\zeta$，把从大到小排好序的 $a_i$ ，$a_1\sim a_{\zeta}$ 分到第一组，$a_{\zeta+1}\sim a_{2\cdot \zeta}$ 分到第二组，以此类推。考虑对于同一组，最好的放的方式就是类似这样：</p><script type="math/tex; mode=display">\ldots n-3,n-1,n,n-2,n-4\ldots</script><p>于是就可以按照奇偶性分个类预处理了。复杂度 $O(nd(n)+m\log n)$ 。后面那个 $\log$ 是求 $\gcd$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ll ans ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line">ll res[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base, base + n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j += i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i - <span class="number">2</span> ; ++ k)</span><br><span class="line">                    res[i] += (ll)base[j + k] * (ll)base[j + k + <span class="number">2</span>] ;</span><br><span class="line">                res[i] += (ll)base[j] * (ll)base[j + <span class="number">1</span>] ;</span><br><span class="line">res[i] += (ll)base[j + i - <span class="number">1</span>] * (ll)base[j + i - <span class="number">2</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">ans += (ll)base[i] * (ll)base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) ;</span><br><span class="line"><span class="keyword">if</span> (!k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[n / gcd(n, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树状数组</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…&lt;/p&gt;
&lt;p&gt;于是就打算整理一下这六道题。感觉…还是有点东西的吧。&lt;/p&gt;
&lt;p&gt;题目难度按我自己心目中的升序排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】我说啊…</title>
    <link href="https://www.orchidany.cn/2020/04/21/%E6%88%91%E8%AF%B4%E5%95%8A/"/>
    <id>https://www.orchidany.cn/2020/04/21/我说啊/</id>
    <published>2020-04-21T10:05:06.000Z</published>
    <updated>2020-05-31T13:15:10.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。</p><p>我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。</p><p>我要学的还有很多。</p><p>我一直在路上。</p><a id="more"></a><h1 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h1><p>听《起风了》。发现 QQ 音乐突然有了版权，以为是之前那个版本复辟了。听了才发现和网易云一样换的是新的版本。于是去网上搜了下原版下了下来，很满意。</p><p>第一次听《起风了》，是两年前，是 2018 年的 11 月初。时值年轻气盛的高一，和同伴们一起在清北学堂参加 NOIP 刷题班。我是每天早晚家长披星戴月接送回家的，但也有同学是住在哪。我们这一级人很少，只有 12 个，所以很铁。有三个人住在一起，是一间三人房，按照济南当地的标准，这种低级的宾馆都是 80/人。但是很无奈宾馆里本来是没有三人间的，所以他们的三人间就是两张床外加一张不是十分惹眼的折叠床，十分拥挤地拼起来的。</p><p>当时中午在他们房间休息，听到了「起风了」这首歌，感觉歌词有些棒——虽然感觉要有点前言不搭后语——但是旋律完全弥补了这块短板。记得当时就十分喜欢这首歌。哦对了，还有《沙漠骆驼》，都是在他们房间听酷狗音乐的推荐听来的。这导致后面的培训自习的时候自己一直在循环那两首。</p><p>所以，《起风了》，对我来说是什么呢？这首歌，是一条线，又或者是一张网，悄悄地贯穿着我这三年。从大家都在役，到有人退役，到学文化课，到暑假到寒假，直到现在，空旷的机房只有我一个人，我吼一嗓子可能才会有回音与我作伴，显得我不是那么孤独。当然这不是主要的，主要的是，每次一听这首歌啊，我都会想起很多，想起 18 年联赛，想起 19 年联赛，想起每次培训，想起省队培训，想起很久很久之前。思绪总会漫无边际地回到过去，回到那一个个泛着奶油味、棉花糖味的午后，回到和同伴们一起奋战、一起培训，夜里一起看番打游戏、颓完还不忘整理当天培训笔记的日子。</p><p>仿佛时光中的每一步都可以有与众不同的 BGM，18 年培训时的《起风了》，18 年联赛时的《溢爱》，19 年暑假的《Simon》，19 年国庆培训时的《若能绽放光芒（光るなら）》，19 年联赛前的《白羊》、Deemo 里的开场曲《Dream》、Coldplay 的《Arabesque》以及各种版本的《The Sound Of Silence》、联赛前一天的《恰似你的温柔》（因为歌词很重要，我当时也只是想着「让它好好的来，让它好好的去」），以及联赛赛时晚上必听的德彪西的《月光》、去年年底循环的苏打绿的各种歌 (个人比较推《相信》、《喜欢寂寞》、《你在烦恼什么》和《你被我写在歌里》)、火星哥的《When I Was Your Man》和下着雨的圣诞节时听的陈奕迅的《圣诞结》，寒假里的 Queen 乐队的很多歌、A-lin的《有一种悲伤》和五月天的《你不是真正的快乐》。这一切都书写着我的回忆与过往，每每听的时候都像在翻旧相册，一帧帧地细数着过往。</p><p>回忆，其实或许什么都不是，混杂着喜怒哀乐。给我一瓶老酒，让我喝个痛快吧。这一切一切的最好归宿，可能还是融在酒里面。</p><p>古今，多少事。</p><p>都付，笑谈中。</p><h1 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h1><p>每当我跨过实验楼这厚厚的窗户，望向学校西大门外若隐若现的高楼大厦，我就想飞奔过去，拥抱那成团成簇的人间烟火。</p><p>几年前还是小学生，晚上睡的时候喜欢听广播。广播里经常会放一首叫做「都市夜归人」的歌，因为似乎有个节目就叫做「都市夜归人」。这个节目是不怎么讲话的，只是一遍一遍放着些耳熟能详的歌曲。那个时候总是感觉，都市其实不小，但也不大。不大不小之间，交织起来了每个人的悲喜欢痛。</p><p>我玩过的单机并不多，时长最长的可能就是「侠盗猎车·罪恶都市」了。即便是时隔好几年的现在，我依然可以跟别人津津乐道出这个游戏每一个任务该怎么完成，每一个成就该怎么达到，每一处地方藏着什么装备、有着什么别致的景观。让我感触比较大的一点是，我能清楚感到游戏里的人间烟火气，即便那根本不属于我。我控制的角色就仿佛是一个异类，只有在办任务的时候、剧情动画里才会和别人交流。其他时间都是在奔波流浪。我乘直升机抵达过最高楼，在那个地方看日出；我去过沙滩，去过灯塔，去过许许多多不同的地方。我既向往这种热烈的孤独——我确实向往，就如同我向往现实中那片片高楼交织起来的城市网一样——但我也想回避这种伶仃的感觉。虽然，还是一个人的时刻比较多。</p><p>我总是不自觉地会想拥抱人间烟火气，在晚上，即便只有一个人。我想去灯火通明的商场里逛来逛去，去情侣们依偎着的电影院看一场让人感慨的电影(比如《爱乐之城》)，去喧嚷的饭店里消费一顿，又或者在街上逛来逛去、看着行人们总在夜幕下垂时才展露出来的豪情。</p><p>夜总让人感到真性情，不同于白天必须让人好好将之收敛起来。</p><p>我梦想中的一个场景啊，就是在昏暗的屋子里，这屋子最好是在五楼或者六楼，朝南有一扇窗户，窗外是行人街的华灯遍地，是行人们的笑脸融在星点里，是商场总是不知疲倦地散发着的温柔的光；窗外洒进来一些光晕点缀着屋子，屋里北侧是厨房里冰箱灯的微光，我牵着你的手，你举着一杯红酒，一旁的印象里传来袅袅的萨克斯乐——如果可以选，我选《Miss bane》这一首，或者 Kennu G. 的其他作品，比如《My Heart Will Go On》之类的，都可以——我们就这么轻轻地跳着舞，可以是探戈，也可以是华尔兹，或者就随便跳吧，跳到黎明，跳到嘴角终于向上弯到疲惫，跳到窗外的星火夜月都在跟我说晚安，再一同睡去。</p><p>这样，明天早上就算又是一样的朝阳伴云，也不会让人感到寂寞吧。</p><p>但…谁知道呢？现在仰望着未来的我，可能就会是未来那个回望着现在的我。人总是不知足，非要在一个时刻把所有的欢笑全都收在心里。但有些事情，或许只是仰望时，才会觉得美丽动人吧。</p><h1 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h1><p>一天一天，我在干什么？</p><p>做题-&gt;写好久-&gt;发现思路有问题-&gt;调好久-&gt;发现思路有问题-&gt;调好久…</p><p>灵魂好像已经不在躯壳里。以前至少会总结一下每天，现在连总结都不想再总结了。每天完不成的人物就是青面獠牙的猛兽，吓得我大气也不敢喘。</p><p>是啊，省选。我既想让他晚点来，可以多拼一拼，又想让他趁早在昨天办完了拉倒。</p><p>因为我已经，不想再走这条路了啊。</p><p>但为什么，你跟我说，「不想走就退出啊」，我会觉得「退出」这个字眼这么陌生、这么可怕，陌生到我从来都没有过这种念头，可怕到我想都不敢去想。</p><p>拧巴，太拧巴了。</p><p>话说回来。路上有美丽的风景，路上可以锻炼人的能力，路上可以获得升学优惠——</p><p>为什么我这一路下来，什么都没有呢？我又为什么要走这条路呢？</p><p>我真想回到三年前告诉自己：千万别学奥赛，你不需要证明自己有多聪明。</p><p>这可能就是我将来垂垂老矣时的状态？想到自己罹患重病，卧榻在床，边流泪边想着自己每多活一天就多遭一天罪，也根本没有撒手归西的勇气。</p><p>是的啊，这种事情只会是连续剧，一幕连着一幕在我的人生里上演。遗憾伴随着失望，这就是我想要的一切？</p><p>我明白了。</p><p>一直在口口声声劝着别人要有向死而生的勇气，<code>the fear we fear is fear itself</code> 。自己似乎从来没有过。不敢大踏步地走，每天苟且地活，像个絮叨的老人一样活在自己过去的梦里…</p><p>嗯，我要有勇气面对这一切。</p><p>就当做，明天就要退役了吧。但就算明天是末日，也要去跑、去跳，去漂亮地倒挂金钩。这是我需要的状态。只有直面死亡，才可以知道究竟该怎么生存。</p><h1 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h1><p>刚写快速幂的时候，突然回想起大约两年前。</p><p>那也是一个如今晚一般的 lonely, lonely night。初中部机房，自己在笔记本上，拿着不同颜色的笔，一笔一划认真研究着快速幂是怎么个原理。研究了半天，觉得发现其奥秘之后，发现自己思维混乱，于是又重新梳理好几遍。整理完之后，感觉学会了不得了的东西。</p><p>那时候的我…在想些什么呢？</p><p>我肯定不会想到我还在学 OI，肯定不会想到现在的我多么怀念之前的日子。我眼前似乎浮现出当时自己不停地换笔的颜色，这里圈重点、那里画波浪线、对着几行代码啃了又啃，只是为了很透彻地研究快速幂的样子。似乎我又回到了当时机房的窗外，看着里面亮着昏昏的一排灯。黑暗中的我看着里面的那个我，是如此的清楚；里面的那个我却看不到窗外黑暗中的我——简单的生活常识。</p><p>那是我自己，却也仿佛是一个我素未谋面的人。</p><p>这几年，我到底是在做些什么呢？做了确实很多事情，但是为什么，为什么无论做什么，都一直陷在过去里呢？我可能真的是一个被时光遗忘掉的人吧。</p><p>泪眼模糊中，我仿佛又看到了老校，看到了过去的人，看到了平行于这个世界的另一个过去的我。他们向我挥手作别，「再见啦，别留恋啦」，随后渐远渐行，渐行渐远…</p><p>敞着的窗户突然吹送进来一阵料峭的风，吹的书页哗啦啦地响，那声音仿佛可以划破时空的禁锢，缭绕而清脆。</p><h1 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h1><p>今天和我校生物奥赛同僚偶然突然提到了「支撑下去的信念」这个话题。自己其实一直很迷惑吧。从今年不知道什么时候开始，感觉自己就是在混日子，一天混过来再混一天。斯嘉丽的那句 _After all, Tomrrow is another day!_ 倒是和我的想法不谋而合——只不过是 _another new_ 和 _another numb_ 罢了。</p><p>于是我的回答自然是模棱两可，并且向他表达了自己的质疑「我就不明白了，为什么大家这么多人都在这里拼啊？都拿银牌以上不显然是不可能的吗？」</p><p>他想了想，说「我们教练说，竞赛锻炼的是一种能力，学竞赛的目的也应该是锻炼能力、锻炼一种可以让你学文化课时、办事时、将来学习时都有用的能力」。</p><p>我突然愣了愣。不是愣在这个观点的新颖，而是愣在我之前，再早、再早一些的时候，仿佛也用这句话劝说过别人。总之，我清楚地记得我说过、坚信过类似的内容…但…</p><p>但不知道什么时候，我仿佛已经忘记了自己的初心。一天天一天天，我一直在拿「我没有别人那么喜欢OI，所以不努力也可以理解」来搪塞自己、坚信 OI 是高智商对低智商的剥削，看到曾经自己的文字「不要功利地学 OI」时开始变得麻木、甚至有些纳闷——看着当时自己对这个世界的劝告，才发现「活成你最讨厌的人」与我仅有咫尺…我迷茫了。</p><p>他又问：「你的目标是什么？」</p><p>我：……</p><p>他：「没事的。目标就是要去寻找的嘛，人活着不就是去寻找活着的目标吗？就算找了很久找不到，这也是一种精彩的人生吧。」</p><p>我愣了愣。看着一旁洒进食堂的阳光，周围的嘈杂在那一刹那仿佛消失不见了；筷子掉到桌子上，发出悠长的回响，不绝于耳。</p><h1 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h1><p>总会因为奇奇怪怪的事情陷入东亚式情绪内卷…</p><p>感觉有很多事情都是自讨没趣。自己找来痛苦让自己承受。习惯痛苦之后，积极的生活态度反而让人感到陌生…</p><p>争取逐渐削弱这个内卷的过程吧。</p><h1 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h1><p>郁郁寡欢…不过山崎将义的「One more time, one more chance」里面倒是提过</p><blockquote><p>如果只是缓解寂寞，随便一个人就可以了吧。</p></blockquote><p>…我一直把这个当做信条。自己会经常期许很多不能得到的东西、不能传达的心意。如果这么想的话，可能自己会稍微好受一点吧。</p><p>感觉自己从未真正变得成熟过…</p><h1 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h1><p>我…很烦「浮躁」的感觉。如果每天不给我几分钟，让我去仔细思考一下人生，我就会感到难以入睡。</p><p>我才发现，虽然我很向往热烈，但是骨子里还是喜欢孤独一人的感觉。自由、不受约束。身上不需要承担那些若有若无的责任…我向往人与人之间的羁绊，但我同时也在一直回避这些。</p><h1 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h1><p>最近一直很忙，忙着把自己之前做过的题都复习一遍，不给自己的青春留下遗憾。</p><p>计数啦，刘汝佳的紫书/蓝书啦，李煜东的书啦…都是我未尽的回忆。</p><p>我就像一个小心翼翼的孩子，认真地找回失落的每一块拼图，笨笨地拼回原处…拼的东倒西歪，但算不上不满意。</p><p>就这样吧。尽我所能，把自己丢下的、落下的，一件一件拾起来。</p><p>但…我还没有看过远处的风景啊，现在就要准备沿途返回了吗？我不甘心的吧？</p><p>可能，有些人属于这里，有些人不属于这里。这有点宿命论的意味——虽然我是不信的，但你不得不说，有时候这东西似乎就是贯穿万事万物的那一条透明的线，引领着每个人走向自己的终章。</p><p>终章之后呢？是一片新的天地吧。</p><p>但…还是最好不要停下来吧。</p><h1 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h1><p>我被关在笼子里。</p><p>周围密布的…是黑色。</p><p>外面…似乎也套着笼子。这个机房是笼子，这栋综合楼是笼子，这个学校是笼子。</p><p>要继续说下去的话，这个城市，这个地区，这个世界都是笼子。似乎找不到任何一缕自由的风。</p><p>虽然我看不见——因为最靠近我的这个笼子已经将我的双眼层层蒙蔽。但我坚信。</p><p>其实我是被自己的心关起来的，我自己很清楚。</p><p>我不断地反复，跟自己博弈、决斗、撕扯、争吵…最终是赢了呢？还是输了呢？我只知道无论输赢，我都还是停留在这个笼子里。</p><p>所以，外界可能并不存在什么笼子，罩着我的只有一层笼子，其余的只是我内心积攒的恐惧而已。</p><p>但是…虽然自己提出了疑问，但是我依然相信外面是有笼子的、数不清的那种…</p><p>是的，这种寄托方式，是坚信。区分「坚信」和「迷信」的根据大概就是，坚信可以包容质疑，但是迷信从来不容置疑。</p><p>你看我为数不多的信念，也只能用在这种地方了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。&lt;/p&gt;
&lt;p&gt;我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。&lt;/p&gt;
&lt;p&gt;我要学的还有很多。&lt;/p&gt;
&lt;p&gt;我一直在路上。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
</feed>
