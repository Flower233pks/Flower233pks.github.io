<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orchidany.cf/"/>
  <updated>2019-12-15T11:49:54.949Z</updated>
  <id>http://www.orchidany.cf/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>http://www.orchidany.cf/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-12-15T11:49:54.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-tKlgqKti" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-tKlgqKti"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center">咕</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】构造题选做 · 2</title>
    <link href="http://www.orchidany.cf/2019/12/24/%E6%9E%84%E9%80%A02/"/>
    <id>http://www.orchidany.cf/2019/12/24/构造2/</id>
    <published>2019-12-24T02:01:07.000Z</published>
    <updated>2019-12-24T08:05:03.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没啥特别原因，就是底下那篇文章题太多了就分流出一部分。</p><a id="more"></a><h3 id="1-UVa1697"><a href="#1-UVa1697" class="headerlink" title="$1$ UVa1697"></a>$1$ UVa1697</h3><blockquote><p>给定一排长度为 $4n$ 的格子，编号从 $-2n+1$ 到 $2n$ 每个编号为正的格子中有一个物品，其中每个编号为奇数的格子中有一个 $B$ 类物品，编号为偶数的格子中有一个 $A$ 类物品。</p><p>你只能进行一种操作：选择某两个相邻的都有物品的格子，移动到另外两个相邻的空格子中，同时不能改变两个格子的相对位置。</p><p>要求进行最少的操作使得所有物品以 <code>AAA…ABBB…B</code> ($n$ 个 $A$ 和 $n$ 个 $B$) 的形式排列在一起 输出一种可行方案 </p><p>$3\leq n \leq 100$</p></blockquote><p>人类智慧学不来了orz</p><p>考虑 $n=3,4,5,6,7$ 的时候都可以人类智慧。那么对于 $n &gt; 7$ 时考虑增量构造，即从 $n$ 构造到 $n+4$。</p><p>那么 $n=4$ 时可以这么构造：</p><blockquote><p><code>__babababa</code></p><p><code>abbabab__a</code></p><p><code>abba__bbaa</code></p><p><code>a__abbbbaa</code></p><p><code>aaaabbbb__</code></p></blockquote><p>然后考虑对于 $n+4$，记 $|BA|$  表示有一堆 <code>bababa</code> 这种东西。</p><p>那么考虑 $n+4$ 可以这么玩：</p><blockquote><p><code>__|BA|</code></p><p><code>ab|BA|b__a</code></p><p><code>abba__|BA|bbaa</code></p></blockquote><p>发现中间那一段和起始状态是一样的，就可以大力递归，回代的时候回代一下即可。</p><p>$n=3\sim 7$ 我选择直接从网上抄来别人的人类智慧，毕竟我莫得智慧.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" to "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = R - L + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">3</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(<span class="number">2</span>, <span class="number">-1</span>), oo(<span class="number">5</span>, <span class="number">2</span>), oo(<span class="number">3</span>, <span class="number">-3</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">4</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">5</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">5</span>), oo(L - <span class="number">1</span>, L + <span class="number">2</span>), oo(L + <span class="number">6</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">7</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">8</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">6</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">9</span>, L - <span class="number">2</span>), oo(L + <span class="number">6</span>, L + <span class="number">9</span>), oo(L + <span class="number">1</span>, L + <span class="number">6</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">1</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">10</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">7</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">4</span>, L + <span class="number">7</span>), oo(L + <span class="number">11</span>, L + <span class="number">4</span>),</span><br><span class="line">               oo(L + <span class="number">2</span>, L + <span class="number">11</span>), oo(L + <span class="number">8</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">8</span>), oo(L + <span class="number">12</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    oo(R - <span class="number">2</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, R - <span class="number">2</span>), work(L + <span class="number">4</span>, R - <span class="number">4</span>), oo(L - <span class="number">1</span>, R - <span class="number">5</span>), oo(R - <span class="number">1</span>, L - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) work(<span class="number">1</span>, N * <span class="number">2</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-BZOJ4148-Pillars"><a href="#2-BZOJ4148-Pillars" class="headerlink" title="$2$ BZOJ4148 Pillars"></a>$2$ BZOJ4148 Pillars</h3><blockquote><p>给定一个 $n\times m$ 的矩形，其中有 $f$ 个 $2\times 2$ 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 $6$，且每个障碍物的中心到边缘的距离至少为 $3$。</p><p>请找到一条从左下角 $(1,1)$ 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。</p><p>保证 $n,m$ 均为偶数，且 $1\leq n,m\leq 1000$ .</p></blockquote><p>发现是乱搞题 <del>Claris居然搬过这样的题</del></p><p>就是考虑如果没有障碍的走法，由于 $n,m$ 都是偶数，所以可以从 $(1,1)$ 上到 $(1,n)$，然后从 $(1,n)$ 到 $(n,n)$ 再到 $(n,n-1)$ 再到 $(2,n-1)$ 这么蛇形走。</p><p>考虑有了障碍，因为每个障碍可以看做是独立的的，所以大概可以这么走：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qvupb852.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt></p><p>其中紫色是障碍，黄色是原来的路线，红色是新的。由于 $6$ 的限制，所以可以这么绕。</p><p>所以是道细节题233</p><p>代码先鸽着，什么时候有心情再写。</p><h3 id="3-【UR-6】-智商锁"><a href="#3-【UR-6】-智商锁" class="headerlink" title="$3$ 【UR #6】 智商锁"></a>$3$ 【UR #6】 智商锁</h3><blockquote><p>构造一个节点数不超过 $100$ 的无向图，使其生成树个数对 $998244353$ 取模的结果为 $k$ 。</p><p>$k\leq 10^9$</p></blockquote><p>看题，仔细一想，莫非是什么神秘的 $\boldsymbol{EGF}$ 大力乱搞（警觉）。</p><p>结果人傻了……以下是官方做法：</p><p>考虑如果两个图只有一个公共点，那么生成树个数为两个图相乘。那么随机 $1000$ 个随机无向图，两两拼凑出 $10^6$ 个无向图，然后对每一个在 <code>map</code> 里找 $k$ 的逆元即可。<del>如果没有就再随机一遍。</del></p><p>发现这样实际上几乎不可能没有解。。。</p><p><img src="http://img.uoj.ac/utility/bear-thinking.gif" alt="思考熊"></p><p>降智打击.jpg</p><h3 id="4-【UNR-1】Jakarta-Skyscrapers"><a href="#4-【UNR-1】Jakarta-Skyscrapers" class="headerlink" title="$4$  【UNR #1】Jakarta Skyscrapers"></a>$4$  【UNR #1】Jakarta Skyscrapers</h3><blockquote><p>有一个数集，最初其中只有 $a$ 和 $b$。</p><p>你可以进行最多 $400$ 次操作，每次选择集合中满足 $i&gt;j$ 的 $i$ 和 $j$，把 $i-j$ 加入集合中，使得最后 $c$ 在这个集合中。</p><p>$a,b,c\leq 10^{18}$</p></blockquote><p>考虑构造中间状态。发现可以用 $a-(a-b-c)$ 构造 $b+c$， 可以用 $a-(a-b-b)$ 构造倍增，于是考虑先辗转相除得到 $1$，然后倍增，然后就没了。注意，如果一开始 $(a,b) \not|~c$ 的话是无解的。那么考虑同除 $(a,b)$ 就可以快乐地更相减损得到 $1$ 了。</p><p>代码先鸽着…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没啥特别原因，就是底下那篇文章题太多了就分流出一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="构造" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】构造题选做 · 1</title>
    <link href="http://www.orchidany.cf/2019/12/24/%E6%9E%84%E9%80%A01/"/>
    <id>http://www.orchidany.cf/2019/12/24/构造1/</id>
    <published>2019-12-24T02:01:07.000Z</published>
    <updated>2019-12-24T08:03:51.086Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从网课和 <code>uoj</code> 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。</p><a id="more"></a><h3 id="1-神秘的题目"><a href="#1-神秘的题目" class="headerlink" title="1 神秘的题目"></a>1 神秘的题目</h3><p>设 $f_A$ 表示 $A$ 的本质不同子串个数<br>给出 $x, y$，要求构造出两个字符串 $A, B$<br>满足：<br>$f_A = x , f_B = y , f_{A+B} = x + y$</p><p>$x, y ≤ 5000$</p><hr><p>考虑 $x$ 个 $a$，$y$ 个 $b$ ，然后拼起来就好……</p><h3 id="2-CF743C"><a href="#2-CF743C" class="headerlink" title="2 CF743C"></a>2 CF743C</h3><p>给出 n，构造出 x, y, z，满足：</p><p>$$<br>\frac{2}{n} = \frac{1}{x}+\frac{1}{y}+\frac{1}{z}\\\<br>x\not= y, x\not= z, y\not= z<br>$$<br>无解输出 −1<br>$n ≤ 10^4$</p><hr><p>考虑通分（分时裂项），即<br>$$<br>\frac{1}{n}-\frac{1}{n+1}=\frac{1}{n(n+1)}\\\<br>\frac{1}{n}=\frac{1}{n+1}+ \frac{1}{n(n+1)}\\\<br>\frac{2}{n}=\frac{1}{n} + \frac{1}{n+1}+ \frac{1}{n(n+1)}<br>$$<br>然后就做完了。</p><p>注意1要特判。</p><h3 id="3-CF359B"><a href="#3-CF359B" class="headerlink" title="3 CF359B"></a>3 CF359B</h3><p>给出 n, k , 2k ≤ n，构造出 2n 的一个排列，满足：</p><p>$$<br>∑^n_{i=1} |a_{2i−1} − a_{2i}| − |∑^n_{i=1}(a_{2i−1} − a_{2i})| = 2k<br>$$</p><p>n ≤ 50000</p><hr><p>寄几想了一种构造，就是$a_{i+1} = a_i+k,~i=2p,~p \in \mathbb{N+}$，然后随便两次交换两项就好了。然而并不对，因为这样构造出的结果并不合法；于是遂决定改成$a_{i+1} = a_i+2k,~i=2p,~p \in \mathbb{N+}$，但也不对，单次交换的步长太长了，是$4k$。于是我又想能否有什么诡异的交换方法可以补救回来$2k$……失败了qaq</p><p>然而其实很简单，我们只要把步长控制为$1$就一定能凑出来。所以一开始先令$a_i=a_{i+1}+1$这种感觉，然后交换$2k$次即可。</p><h3 id="color-violet-4-rm-CF-it-512E"><a href="#color-violet-4-rm-CF-it-512E" class="headerlink" title="$\color{violet}{4~ \rm{CF}\it{512E}}$"></a>$\color{violet}{4~ \rm{CF}\it{512E}}$</h3><p>对于一个正 n 边形，可以用 n − 3 条边分成 n − 2 个三角形<br>给出两种划分，你需要进行若干次操作把第一种划分变成第二种划分<br>每次操作选择一个四边形删去它的对角线，连另外一条对角线<br>n ≤ 1000，操作次数不超过 20000</p><hr><p> 开始掉线……</p><p>其实主要思想就是<del>酱油瓶</del>状态替换，把起始状态 $s$ 变成对角线都从 $1$ 出发的状态 $p$，再从 $p$ 出发变成终态 $t$。</p><p>具体操作好像是</p><p>别想了，掉线了怎么可能还会有？</p><h3 id="5-神秘的题目"><a href="#5-神秘的题目" class="headerlink" title="$5$ 神秘的题目"></a>$5$ 神秘的题目</h3><blockquote><p>给出一棵树，定义一个点的邻居集合为到它距离 $\leq 2$ 的所有点。</p><p>给出所有点的邻居集合，还原原树。</p><p>$n\leq 1,000$</p></blockquote><p>考虑一个结论，如果两个点的邻居集合交集大小为 $2$， 那么交集中的点一定有连边。（$\rm bitset$ 做到 $\frac{n^3}{w}$）</p><p>于是就可以先把 <strong>非叶子节点</strong> 两两之间的连边求出来</p><p>然后考虑如何求出叶子。发现叶子有个性质，就是叶子到某些非叶节点的距离一定 $=$ 与之相邻的非叶节点到某些非叶节点的距离 $+1$。所以就可以再把离每个非叶节点距离为 $1$ 的非叶节点求出来，称这个点集为<strong>旁边集合</strong>。那么如果叶子 $u$ 的邻居集合与非叶节点 $v$ 的旁边集合相同，那么 $u$ 就一定挂在 $v$ 上。</p><h3 id="6-AT3877"><a href="#6-AT3877" class="headerlink" title="$6$ AT3877"></a>$6$ AT3877</h3><blockquote><p>给定 $\rm X,Y$， 给出 $[d_{i,j}]$ 表示当 $\mathrm X=i,\mathrm Y=j$ 时，$\rm S$ 到 $\rm T$ 的最短路。</p><p>构造这张图，使之点数 $&lt;300$，无自环和重边，每条边的权值 $\leq 100$， 权值可以是数也可以是 $\rm X,Y$，并给出 $\rm S,T$ 。</p></blockquote><p>设 $g_{i,j}$ 表示从 $\rm S$ 到 $\rm T$ ，经过了包含 $i$ 条 $\rm X$ 边， $j$ 条 $\rm Y$ 边的路径，其它边的边权最小和。</p><p>那么发现这东西可以这么转移出 $[d_{i,j}]$来<br>$$<br>d_{i,j}= \min_{p,q}{(p\cdot i+q\cdot j + g_{p,q})}<br>$$<br>然后可以得到松弛条件<br>$$<br>\forall p,q, \quad \exists~ d_{i,j}\leq p\cdot i+q\cdot j+g_{p,q}<br>$$<br>移项可以得到<br>$$<br>g_{p,q}=\max_{i,j}{(d_{i,j}-p\cdot i - q\cdot j)}<br>$$<br>于是考虑求出 $g $ ，之后反推出 $[d_{i,j}]’$ 观察是否吻合。吻合则考虑根据经过的 $\rm X,Y$ 连边即可。</p><h3 id="7-ARC-095F"><a href="#7-ARC-095F" class="headerlink" title="$7$ ARC 095F"></a>$7$ ARC 095F</h3><blockquote><p>给定一棵树 $\rm T$, 要求构造一个排列 $p$ .</p><p>对于每一个 $p_i$ ，找到最大的 $j$ 使得 $p_j&lt;p_i$，然后在 $i,j$ 间连边。</p><p>问是否可以构造出与 $\rm T$ 同构的树。</p><p>如果可以，则给出字典序最小的排列。</p><p>$n\leq 100,000$</p></blockquote><p>反向考虑，观察对于一个排列生成的树。按照排列的权值升序操作，维护最靠右的位置 $mxp$ 即可。</p><p>然后发现由于一个排列不可能同时有两个最大值，这样生成的树一定会是一根长链周围分散着单点。</p><p>于是考虑把直径抽出来，对上面的点扫一遍。遇到有挂在上面的肯定考虑从小到大放在前面，然后就没有然后了。</p><p>可能实现还不太会，要再想想。</p><h3 id="8-小题整理"><a href="#8-小题整理" class="headerlink" title="$8$ 小题整理"></a>$8$ 小题整理</h3><p>8.1 覆盖</p><blockquote><p>平面上给定 $n$ 个点，每个点可以覆盖 $\frac{1}{4}$ 的平面，求最少需要多少个点才能覆盖所有点</p></blockquote><hr><p>orz我和ouuuyuuu一开始觉得题很傻，最多四个，结果发现原来最多两个就可以，然后发现我们很傻。。</p><p>找某一维坐标最大/最小的两个点，再判一下是不是只需要一个点就可以满足，就做完了。</p><p>8.2 CF477B</p><blockquote><p>有 $n$ 个集合，彼此交集为空。</p><p>每个集合有 $4$ 个元素，两两之间均有 $\gcd = k$</p><p>求 $4n$ 个数中最大值的最小值</p><p>$1\leq n\leq 10000$</p></blockquote><p>发现可以同除以 $k$ ，于是就变成两两互质了，于是 $4$ 个数中至多 $1$ 个偶数。</p><p>同时发现一个<del>鬼能发现的</del>性质，就是相邻两个奇数一定互质，那么就构造<br>$$<br>\mathrm{S}:{6i-1,6i-3,6i-5,6i-4 }<br>$$<br>可知它们互质。然后就没了。</p><h3 id="9-CF-527D"><a href="#9-CF-527D" class="headerlink" title="$9$ CF 527D"></a>$9$ CF 527D</h3><blockquote><p>每个元素有一个 $a_i$ 一个 $b_i$ .</p><p>求一个最大的点集使得 $\forall p,q\in \mathrm{S},\quad |a_p-a_q|\geq b_p+b_q$</p><p>$n\leq 200,000$</p></blockquote><p>我丢，其实就是把每个元素看做 $(a_i-b_i,a_i+b_i)$ 这么一段区间，然后求的就是最长不相交的区间个数。</p><p>然后就没了……就没了……</p><h3 id="10-ARC-084D"><a href="#10-ARC-084D" class="headerlink" title="$10$ ARC 084D"></a>$10$ ARC 084D</h3><blockquote><p>求出 $K$ 的倍数中，各位数字的和最小的那个数字的数字和。</p><p>$K \leq 100,000$</p></blockquote><p>考虑从 $i$ 到 $i+1$ 连一条长度为 $1$ 的边，$i$ 到 $10\cdot i$ 连长度为 $0$ 的边。然后按照$\bmod k$ 的余数建边，最后就是  $1\to 0$ 的最短路。</p><h3 id="11-神秘的题目"><a href="#11-神秘的题目" class="headerlink" title="$11$ 神秘的题目"></a>$11$ 神秘的题目</h3><blockquote><p>给出一张 $n \cdot m$ 的网格图，曼哈顿距离为 $2$ 或 $3$ 的点之间连一条边，构造出一条哈密尔顿回路。</p><p>可能无解。哈密尔顿回路：经过每个点恰一次。</p></blockquote><p>发现可以走法可以是<strong>棋盘染色</strong>，即黑白相间染色，先走完黑色再走完白色。</p><p>发现只有 $n=2,m=2$ 时无解。当 $\min(n,m)=1$ 时，考虑 $(1,2),(1,3),(2,4),(2,5)$ 都必须连（保证有回路），剩下的瞎构造即可。</p><h3 id="12-CF-468A"><a href="#12-CF-468A" class="headerlink" title="$12$ CF 468A"></a>$12$ CF 468A</h3><blockquote><p>用 $1\sim n$ 的所有数凑出 $24$，输出方案。</p><p>每个数都要用，只能用 <code>+</code>、<code>-</code>、<code>×</code> 三种运算。 $n\leq 100,000$</p></blockquote><p>发现 $n\leq 3$ 显然不行。</p><p>然后 $n=4$ 的时候阶乘即可，$n=5$ 的时候发现可以 $5\times 3+4\times 2+1$ 这么算。</p><p>然后考虑 $n&gt;5$，那么 $n$ 一定可以由 $n-2$ 推过来，因为只要乘上 $n-(n-1)$ 即可。发现这样总是可以构造出来合法解。</p><h3 id="13-Loj-525"><a href="#13-Loj-525" class="headerlink" title="$13$ Loj #525"></a>$13$ Loj #525</h3><blockquote><p>给定一个正整数 $k$，你需要寻找一个系数均为 $0$ 到 $k−1$ 之间的非零多项式 $f(x)$，满足对于任意整数 $x$ 均有 $f(x)≡0~(\bmod k)$</p><p>要求 $\deg(f)\leq 60000$</p><p>$k\leq 30000$</p></blockquote><p>首先发现只要对 $0\sim k-1$ 成立那么就满足条件。</p><p><del>然后就变成傻题了，分治FFT！分治FFT！</del></p><p>然而分治FFT会T。不妨令 $q\geq \varphi(k)$，则由于扩展欧拉定理有：<br>$$<br>x^q\equiv x^{q\bmod \varphi(k)+\varphi(k)}(\mod k)<br>$$<br>那么如果令 $v=q+\varphi(k)$，就会有</p><p>$$<br>\begin{aligned}<br>x^v &amp; \equiv x^{v\bmod \varphi(k)+\varphi(k)} (\bmod k) \\ &amp;\equiv x^{(q\bmod \varphi(k)+\varphi(k) \bmod \varphi(k))\bmod \varphi(k) +\varphi(k)} (\bmod k)\\ &amp; \equiv x^{q\bmod \varphi(k)+\varphi(k)}(\bmod k)\\ &amp; \equiv x^q(\bmod k)<br>\end{aligned}<br>$$<br>然后就构造第 $\varphi(k)$ 项系数为 $k-1$，第 $2\cdot \varphi(k)$ 项系数为 $1$ 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从网课和 &lt;code&gt;uoj&lt;/code&gt; 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="构造" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【练习记录】之前的杂题整理（To Be Continued....）</title>
    <link href="http://www.orchidany.cf/2019/12/22/%E6%9D%82%E9%A2%98%E6%B3%9B%E5%81%9A%C2%B7%E4%B9%8B%E5%89%8D/"/>
    <id>http://www.orchidany.cf/2019/12/22/杂题泛做·之前/</id>
    <published>2019-12-22T13:14:22.000Z</published>
    <updated>2019-12-23T23:30:52.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是 <code>CSP-S 2019</code> 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……</p><a id="more"></a><hr><p>1、<a href="https://www.luogu.com.cn/problem/P1357" target="_blank" rel="noopener">LG5317 花园</a></p><p>发现一共只有两种方格，并且转移只跟 $\rm M$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p><p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，然后就快速幂。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波。</p><p>2、<a href="https://www.luogu.com.cn/problem/P4318#submit" target="_blank" rel="noopener">LG4218 完全平方数</a></p><p>一道傻题，大概就是考察 $\mu$ 的性质。</p><ul><li><p>$\rm Algorithm~1$</p><ul><li>发现可以容斥，且 $\mu$ 函数的性质在于，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子且 $x$ 的不同素因子个数为 $k$。所以就考虑先二分，二分完了求一下 </li><li>$$<br>\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \frac{n}{i^2}\rfloor<br>$$<ul><li>就变成傻题了。复杂度 $T \cdot \sqrt n \log n$</li></ul></li></ul></li></ul><p>顺便记录一个很绝的 <code>idea</code></p><ul><li><p>$\rm Algorithm~2$</p><ul><li><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p><ul><li><p>$$<br>\sum _{i=1}^{x}\mu^2(x)\leq K<br>$$</p><p>然后我们发现这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p></li></ul></li></ul></li></ul><p><del>但显然杜教筛被暴力给爆锤了好吗</del></p><p>3、[]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是 &lt;code&gt;CSP-S 2019&lt;/code&gt; 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="技巧/状态压缩" scheme="http://www.orchidany.cf/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="容斥/暴力容斥" scheme="http://www.orchidany.cf/tags/%E5%AE%B9%E6%96%A5-%E6%9A%B4%E5%8A%9B%E5%AE%B9%E6%96%A5/"/>
    
      <category term="数学/线性代数/矩阵" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S2019游记</title>
    <link href="http://www.orchidany.cf/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/"/>
    <id>http://www.orchidany.cf/2019/12/20/CSP-S2019游记/</id>
    <published>2019-12-19T19:38:34.000Z</published>
    <updated>2019-12-24T10:40:15.671Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想不到吧，还有这个时候写游记的。</p><p>在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233</p><p>这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。</p><a id="more"></a><h1 id="rm-Day-quad"><a href="#rm-Day-quad" class="headerlink" title="$\rm Day\quad -???$"></a>$\rm Day\quad -???$</h1><p>LCEZ机房终于只剩8个人了。</p><p>分别是经常会灵光一现的wxl，稳得一批的yjk，经常被膜被AKIOI的wx，玩梗宅男ljp，爱占便宜的lwy，智商不低的qcr，首席颓蛋/电视导购lzr和我。</p><p>其实初三刚来实验班一开始是12个人，但是后来1个人去了友校，1个人选择在 <code>NOIP2018</code> 之前去学文化课，我们把她在团队里的名字改成了“等你回来”，但是最后也没等到；剩下两个人选择考完NOIP2018就退出，现在其中一个因为选了一科地理去了平行班，另一个选择留在文化课班专攻文化课。当然，那就是另一个故事了。</p><p>NOIP2018，我们之中有人考得很好，有人铩羽而归，而我属于后者。所以大家都在积极准备着，选择在国庆之后就停课。</p><p>国庆的时候，我和lzr，wx和qcr去了青岛参加正睿，自认为是停课效果排名比较靠前的一次外出培训了。我只记得前几天每天闲的时候会选择去打 _This is the police 2_，并且在走的前一天成功丢了身份证awa，lzr 则在狂颓上古卷轴Online，wx和qcr在另一个屋，所以我并不清楚。无论怎样，青岛的培训也是很值得回忆的吧。我到现在也可以回想起夜里无人的大街、昏黄的房间只有一件台灯、抑郁的我、经常去买的大桶雪碧和辣条<del>和我丢了的身份证</del>。</p><p>无论怎样，青岛的外卖没有济南的好吃，嘿嘿。</p><h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad -??$"></a>$\rm Day\quad -??$</h1><p>我选择把每天上午安排给ZR的模拟赛，一般名次都不会很高，唉菜死了。</p><p>剩下人可能在做题，可能在颓。印象最深刻的就是我每五次去找yjk玩，有三次他都在刷知乎。。。</p><p>发现自己无论什么大型比赛之前都会发现自己原来有整理不完的博客，平时习惯太差带来的后果真可怕e</p><p>不过似乎是有我引起的一阵风，机房里大家都开始晚上喝_香飘飘_，甚至连铁公鸡yjk也拔毛了买过几次奶茶，于是走廊上就一股浓郁的奶茶味233</p><p>之前嘛，就做了做<code>dp</code>，学了学<code>odt</code>，第一次写莫队结果被逼着调了半天最后套了个线段树。剩下的或许就没有什么印象深刻的事情了。</p><p>哦，胜利一中的神仙们一直很在状态。我就很奇怪为什么会有人每天坚持打比赛还能坚持整完所有题目的……期间我整天听歌，还抽了一个晚上看了集《奇葩说》，感觉李诞认真起来实力也不弱蛤。</p><p>要来了吗？要来了吧。</p><h1 id="rm-Day-quad-3"><a href="#rm-Day-quad-3" class="headerlink" title="$\rm Day\quad-3$"></a>$\rm Day\quad-3$</h1><p>给最喜欢的语文老师写了封信，跟她说我觉得我可能在考完之后不会继续走下去了，这让我很难过，因为我割舍不下那些回忆，觉得她可能会理解我。她回信了。我很高兴她没有硬塞什么心灵鸡汤。于是每天晚上我都会拿出信来读一遍。</p><p>哦对，她以前是我的语文老师，文化课/奥赛分班之后她就只教隔壁了。</p><p>其实你说现在我有什么感受呢？我也不知道，就是蔡琴唱过的 _让它好好的来，让它好好的去_ 这种感觉吧。</p><h1 id="rm-Day-quad-0"><a href="#rm-Day-quad-0" class="headerlink" title="$\rm Day\quad 0$"></a>$\rm Day\quad 0$</h1><p>报到日，群体乘大巴。大巴上我教yjk打音游和拳皇，打deemo他菜的一批233</p><p>到了考点，日照什么职业技术大学。校园一般，宿舍还行，起码有插头和桌子。</p><p>去试了试饭菜，感觉还可以，挺丰富的。发现是兑换餐币，于是就换了三种面值的留下作纪念了。</p><p>晚上去试机，豪华六边形方桌，和机房里一样，感到很开心。键盘也很轻。听别人说键盘难用、座位之间间距太小，才知道原来不是每个考场都是豪华六边形方桌。有抽中大奖的喜悦233</p><p>试机回来就是瞎写了写板子，写了写博客。睡前听的是德彪西的《月光》。</p><p>考前和yjk估摸了一下，Day1要拿260左右才能稳，不知道明天会怎样。</p><p>哦，对，当时听的那一版《月光》，是我听完好多版之后最喜欢的一个版本。但之后我尝试找过，但无论怎么找都找不到了…</p><h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad 1$"></a>$\rm Day\quad 1$</h1><p>考啦考啦。</p><p>开题发现有一些奇怪的说明，没管。</p><p>开 $\rm T1$，发现是个sb题，写了$\rm [5,10]min$ 左右切了，开考 $15\min$ 的时候拍上了。</p><p>开 $\rm T2$，发现 $50$ 在送，于是先写了 $50$ 。之后寻思着去做做 $\rm T3$，发现不太会。本着求稳，写了 $10pts$ 就回去写 $\rm T2$了。于是就开始演，演了半小时写出了一堆不知道啥东西，然后又演了半小时发现大样例爆栈了……</p><p>我不会告诉你我接下来浪费了快半小时去回忆<code>Dev</code>怎么开栈…… </p><p>最后还是失败了，但是发现其实大样例不需要 <code>dfs</code> ，于是写了个序列版本给演过去了。之后 $\rm T2$ 就拍上了。此时大概是 $10:15$ 。</p><p>觉得去刚 $\rm T3$ 应该不至于一分没有，结果就真的一分没有，伤心。</p><p>之后就自闭了。出了考场，我戴紧冲锋衣帽子冲到了一个僻静的小路里面，周围都是密密麻麻的树，开始思考人生。在家庭群里用微信发了句 “考挂了，没救了”，跟妹子说了声“要退役了”就找了个角落开始思考人生。思考完之后开始在校园里闲逛，不想回宿舍。我觉得一定会有 sb 学弟或者 sb 同级生在对 tnd 答案，结果最后手机没电了不得不回去。</p><p>回去之后要了份脆皮鸡饭叫上 yjk 出去逛，发现原来大家都是 210 左右，心态得到了放松。结果不知道为啥，后半程跟 yjk 越走越自闭。我们俩大概是这么聊天的：</p><blockquote><p>我：你最后考到多少名还学？</p><p>yjk：20~30吧。</p><p>我：嗯我也是。那 70 以后呢（因为他去年这个名次）？</p><p>yjk：不学了吧。。</p><p>我：嗯我也是。</p><p>yjk：今天的题感觉没有区分度啊</p><p>我：是啊，没有区分度啊。回去还要补文化课。大家今天都 210，全天下都 210，明天还会更难，肯定会加大区分度，那我可能就被区分下去了…（开始碎碎念）</p><p>yjk：是啊……</p></blockquote><p>于是我俩就在四季桥那里自闭了，和俩二傻子一样蹲在桥边，如果忽略肤色，宛如两尊佛。</p><p>不过后来走着走着心态又回来了。回到宿舍后被辅导员骂了一顿，因为手机落在宿舍并且没签到，233.</p><p>之后选择去吃晚饭，碰到了胜利一中的神仙，但是显然他们不可能认识我，所以我就像一个狗仔一样单方面盯着他们看……233</p><p>晚饭挺不错！这是真的！之后去买了红牛，希望明天能用上。</p><p>晚上其实一直在颓火影和拳皇……睡之前写了写博客，<code>hexo -d</code> 之后就睡了。</p><p>还是听的《月光》。</p><h1 id="rm-Day-quad-2"><a href="#rm-Day-quad-2" class="headerlink" title="$\rm Day\quad 2$"></a>$\rm Day\quad 2$</h1><p>……自闭了。</p><p>开场看T1，发现是计数，不会。去搞 T2，觉得很可做，发现40在送；写完去看T3，发现40在送。于是决定写 T2。然后 T2 猜了一波单调性发现可以 64，于是数据分治了一下，拍上了；之后去写了个T3的40。T2推了推，觉得似乎可以斜率优化，但是发现有二次项似乎很难办，就没管。剩下的时间就在做T1……</p><p>最大的失误是啥呢？可能就是我T1<strong>把 n 和 m 看反了，并且过了前两个样例</strong>，于是觉得这题64在送。但是死活过不去第三个样例。好久之后才发现看反了，赶紧写了个玄学dfs。赛后一测re了。真开心。T3当时看的时候觉得75都是送，但是最后也没来得及写……于是第二天就这么凉了。</p><p>一出来，就自闭了。闲逛了好久，用QQ跟妹子说“真退役了”，用微信跟家长说“已经准备迎接新生活了”，后来就没有后来了。回去一问发现大家也都挂了……yjk哭了，我头一次见他哭。</p><p>不用想的，Day2就是考区分度。之前zr做题的时候就明白了，我是那种被区分下去的人。容斥、dp、贪心之类的这些基本功，我都很烂很不扎实，被区分下去是我活该。你说我会为自己以前拼命学多项式感到不值吗？可能确实不值，但是说啥都没用了。</p><p>回去的路上还是比较愉快的。车上的电视终于不放上21世纪初的悲情无脑乡村恋爱歌曲，改放《欢乐喜剧人》，于是最终和yjk看了一路233</p><p>rqy哭了，可能是因为觉得我们都退役了吧。但是我感觉我和他已经不是一个世界的人了。我一直感觉，如果让我从实力和陪伴里面选一个，我肯定毫不迟疑地选择前者。但，结束了。</p><p>晚上回家了，就是在一直颓而已，没啥别的，期间励志要开启新生活，觉得很有斗志。</p><h1 id="rm-Day-7"><a href="#rm-Day-7" class="headerlink" title="$\rm Day ~7$"></a>$\rm Day ~7$</h1><p>在校的周六，选择去机房收拾东西，顺便看了眼民间数据成绩单。发现自己和yjk都是省里50多名，还一个分…这就很难了，我们之前没讨论过这个区间该干啥呀？</p><h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>之后？之后就是我又滚回来追梦，yjk去文化课了，剩下的人都退役了。</p><p>LCEZ55 级的机房故事，也就这么结束了吧？我一直觉得，我们机房没有其它机房可爱，我是罪魁祸首。我身为队长，要张罗日常事务，但是从来没真正关心过谁，加上脾气很差容易着急（虽然现在好很多了？）。并且一开始我很菜，要一直不遗余力的提升自己实力，不顾什么”同学友谊“啊啥的，功利且浮躁。大家平时也不怎么敢跟我交流，于是机房就很冷清。</p><p>但机房里也时常会有笑声，比如联赛前，机房里一直其乐融融的。现在看来那似乎是遥远的回忆了。</p><p>现在机房里只有我一个人了，我开心吗？终于等到了我喜欢的悠远的寂静，我更快乐吗？</p><p>向前走吧。</p><p>我还很菜，啥都不会，迷茫且不知所措。</p><p>但是人生也就应该是这样的吧。</p><p>明天你好。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家一起加油吧！为了梦想和明天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想不到吧，还有这个时候写游记的。&lt;/p&gt;
&lt;p&gt;在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233&lt;/p&gt;
&lt;p&gt;这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】闲谈</title>
    <link href="http://www.orchidany.cf/2019/12/15/%E9%97%B2%E6%89%AF/"/>
    <id>http://www.orchidany.cf/2019/12/15/闲扯/</id>
    <published>2019-12-15T07:29:19.000Z</published>
    <updated>2019-12-24T11:01:09.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>别名：一句话日记</del></p><p>可能就是用来随时记录自己感悟的东西？</p><a id="more"></a><h3 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h3><p>平安夜，很自闭233</p><p>看了一上午+大半个下午的构造，感觉一般。听 <code>ouuuyuuu</code> 说构造题只能长经验，是学不会的，感觉有点小失落。</p><p><del>人总要有梦想，万一我就学会了呢</del></p><p>晚上复盘了一下自己的 $\rm CSP-S~2019$ ，感觉虽然和大家都很有差距，但是如果从进步的意义上来讲，比起去年来自己进步还是蛮多的。毕竟去年也就那点水平。</p><p>嗯，所以呢，谁知道将来我会不会进步到我想象不到的水平呢？加油吧，我可是想要创造奇迹的笨蛋啊！</p><h3 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h3><p>越来越困了，发现啥都学不会，然后自闭了。</p><p>发现去了 <code>pkuwc</code> 的小伙伴们似乎都有约拿了，感觉更自闭了。</p><p>……我觉得我现在应该是全校最盼着放寒假的人了。当初觉得似乎机房生活会很轻松，结果发现比文化课生活自闭了不止一个量级。可海星……</p><p>发现啥都学不会了，发现比别人拉下的不止一点半点……有点难受，但是一想到马上要放假了（虽然还有一个多月）就会开心一点phh</p><h3 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h3><p>……之前换了几天的 <code>jacman</code> 主题，说实话感觉不是很漂亮。换主题的原因是我关了一次 <code>icloud</code>，然后他就给我吞了……迷惑。于是只能重新建一个主题。不过好在我<del>找回了失去的脑子</del>找到了对应的文件夹，于是九成功复原了。于是现在就又换回了 <code>next</code> 主题。</p><p>怎么说呢，虽然 <code>next</code> 主题确实用的比较多，有烂大街的嫌疑，但是你要真让我去挑其他的喜欢的并且配置出来，确实很麻烦。</p><p>嗯，这个故事告诉我们要学会备份。 </p><h3 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h3><p>upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。</p><p>新建了这个文档，本想写很多，结果突然发现自己WC都去不了。</p><p>然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;别名：一句话日记&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;可能就是用来随时记录自己感悟的东西？&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://www.orchidany.cf/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Manacher简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/Manacher%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/Manacher泛做/</id>
    <published>2019-12-15T07:26:25.000Z</published>
    <updated>2019-12-15T07:28:45.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>在？为啥不用PAM？</del></p><p>emm那可能是空间开不下（自我安慰</p><a id="more"></a><h1 id="1-LG1659-国家集训队-拉拉队排练"><a href="#1-LG1659-国家集训队-拉拉队排练" class="headerlink" title="$1$ LG1659 [国家集训队]拉拉队排练"></a>$1$ LG1659 [国家集训队]拉拉队排练</h1><blockquote><p>求前$k$大的奇数长度回文串的长度之积。</p><p>$\rm |S|\leq 1e6,K\leq 1e12$</p></blockquote><p>……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq</p><p>二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。</p><p>以下是错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L = <span class="number">-1</span> ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> x = ed[p], i ; </span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; p ; ++ i)</span><br><span class="line">ret += <span class="number">1l</span>l * ((ed[i] - ed[p] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret + (buc[ed[p]]) &gt;= K) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) buc[base[i] - <span class="number">1</span>] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i += <span class="number">2</span>) <span class="keyword">if</span> (buc[i]) ed[++ tot] = i ; </span><br><span class="line">reverse(ed + <span class="number">1</span>, ed + tot + <span class="number">1</span>) ; <span class="keyword">int</span> L = <span class="number">1</span>, R = tot, Mid, ans, pos = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">/*if (rand() % 2)</span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/</span></span><br><span class="line"><span class="keyword">if</span> (check(Mid)) ans = Mid, R = Mid - <span class="number">1</span> ; <span class="keyword">else</span> L = Mid + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line">pos = ans, res = <span class="number">1l</span>l, _up = ed[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ed[pos] ; i &lt;= ed[<span class="number">1</span>] ; i += <span class="number">2</span>) fact *= <span class="number">1l</span>l * i ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (ed[i] &lt; _up) fact /= _up, _up -= <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">if</span> ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span> &gt; K)&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K)</span><br><span class="line">res = res * <span class="number">1l</span>l * ed[i], ed[i] -= <span class="number">2</span>, ++ j ; </span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line">&#125; </span><br><span class="line">res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ;</span><br><span class="line">K -= <span class="number">1l</span>l * ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">if</span> (K &lt;= <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= <span class="number">1</span>) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i], id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">ans += buc[i] ; </span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= K)</span><br><span class="line">(res *= expow(i, ans)) %= Mod, K -= ans ; </span><br><span class="line"><span class="keyword">else</span> &#123; (res *= expow(i, K)) %= Mod, K -= ans ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。</p><h1 id="2-LG4555-国家集训队-最长双回文串"><a href="#2-LG4555-国家集训队-最长双回文串" class="headerlink" title="$2$ LG4555 [国家集训队]最长双回文串"></a>$2$ LG4555 [国家集训队]最长双回文串</h1><p>这题比第一题友善了很多。。。</p><blockquote><p>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。</p></blockquote><p>嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">int</span> i, id = <span class="number">0</span>, rt = <span class="number">0</span> ; ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(rt - i + <span class="number">1</span>, base[<span class="number">2</span> * id - i]) ;  </span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"><span class="keyword">if</span> (i + base[i] &gt; rt) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> l = i / <span class="number">2</span> - (base[i] / <span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> r = i / <span class="number">2</span> + (base[i] / <span class="number">2</span>) - <span class="number">1</span> ; <span class="keyword">if</span> (ns[i] == <span class="number">35</span>) ++ r ;</span><br><span class="line">Ls[r] = max(Ls[r], base[i] - <span class="number">1</span>), Rs[l] = max(Rs[l], base[i] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + <span class="number">1</span>]) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;在？为啥不用PAM？&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;emm那可能是空间开不下（自我安慰&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
  </entry>
  
  <entry>
    <title>【题解】PAM简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAM%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAM泛做/</id>
    <published>2019-12-15T07:23:16.000Z</published>
    <updated>2019-12-15T07:26:12.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都是简单的PAM习题</p><a id="more"></a><h1 id="1-LG5496-【模板】回文自动机"><a href="#1-LG5496-【模板】回文自动机" class="headerlink" title="$1$ LG5496 【模板】回文自动机"></a>$1$ LG5496 【模板】回文自动机</h1><blockquote><p>对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。</p><p>$|s|\leq 1e6$</p></blockquote><p>然后就是PAM的板子题<del>咋感觉好像没有不是很板的PAM题呢</del></p><p>考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移<br>$$<br>cnt_{p}=cnt_{fail_p}+1<br>$$<br>然后就没有然后了。</p><h1 id="2-APIO2014-回文串"><a href="#2-APIO2014-回文串" class="headerlink" title="$2$ [APIO2014]回文串"></a>$2$ [APIO2014]回文串</h1><blockquote><p>给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。</p><p>对于给你的这个字符串$s$，求所有回文子串中的最大存在值。</p><p>$|s|\leq 1e6$</p></blockquote><p>感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然<strong>“串的最长回文后缀唯一”</strong>的逆命题<strong>“任何串会唯一作为其他串的最长回文后缀”</strong>也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用<br>$$<br>\rm f_u=ctn_u+\sum_{v\in S(u)}f_v<br>$$<br>其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。</p><p>emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; i --) </span><br><span class="line">    P.f[P.pre[i]] += P.f[i], ans = max(ans, <span class="number">1l</span>l * P.len[i] * P.f[i]) ;</span><br></pre></td></tr></table></figure><p><del>哪那么多P话，就是背啊</del></p><h1 id="3-LG5555-秩序魔咒"><a href="#3-LG5555-秩序魔咒" class="headerlink" title="$3$ LG5555 秩序魔咒"></a>$3$ LG5555 秩序魔咒</h1><blockquote><p>求两个串的最长公共回文子串以及该长度的出现次数。</p><p>$\rm |S|,|T|\leq 10^6$</p></blockquote><p><del>恭喜发现一个新套路</del></p><p>观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ans == P.len[x]) res ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; P.len[x]) res = <span class="number">1</span>, ans = P.len[x] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By the way，奇根/偶根都要$dp$一次。</p><h1 id="4-JSOI2013-快乐的-JYY"><a href="#4-JSOI2013-快乐的-JYY" class="headerlink" title="$4$ [JSOI2013]快乐的 JYY"></a>$4$ [JSOI2013]快乐的 JYY</h1><blockquote><p>求两个串的不同公共回文串的个数，其中不同意思是下标不同。</p><p>$|s|,|t|\leq 10^6$</p></blockquote><p>……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x + y &gt; <span class="number">2</span>) ans += <span class="number">1l</span>l * P.f[x] * Q.f[y] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.Init(), Q.Init() ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Insert(S[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, S) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) Q.Insert(T[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, T) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">1</span>) ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans&lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-闲扯"><a href="#5-闲扯" class="headerlink" title="$5$ 闲扯"></a>$5$ 闲扯</h1><p>写模板题真是让人感到空虚……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是简单的PAM习题&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】PAM &amp; Manacher</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAMandManacher/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAMandManacher/</id>
    <published>2019-12-15T06:05:19.000Z</published>
    <updated>2019-12-15T06:18:31.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PAM &amp; Manacher，两种用来处理回文串的玩意儿。</p><a id="more"></a> <h1 id="1-Manacher"><a href="#1-Manacher" class="headerlink" title="$1$ Manacher"></a>$1$ Manacher</h1><p><del>挺短，背是挺好背的</del></p><p>Manacher用于求回文串长度。思想大概就是：</p><p>1、加入字符集之外的识别字符（比如<code>#</code>）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。</p><p>2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定<strong>至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$}</strong> 。然后就不断扩展即可。</p><p>3、关于复杂度证明。我们记<strong>一次帅气的操作</strong>的意义是<strong>成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$</strong>，记以当前点为轴的最长回文子串为$\rm T$，$T$的右端点为$q$。可以知道</p><ul><li>（1）$\rm S$的右端点是单增的；</li><li>（2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然<code>while</code>1次，$maxlen$增大一次；</li><li>（3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出<code>while</code>；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。</li></ul><p>So,最终复杂度就是$\Theta(n)$的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id, fars, i ; </span><br><span class="line">id = <span class="number">0</span>, fars = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line"><span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> <span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), </span><br><span class="line">L = <span class="number">-1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; Manacher(In) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) ans = max(ans, base[i] - <span class="number">1</span>) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-PAM"><a href="#2-PAM" class="headerlink" title="$2$ PAM"></a>$2$ PAM</h1><p>学了PAM，不知道为啥感觉比SAM简单？</p><p>其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下：</p><p>0、一个串的回文子串至多有$O(n)$个。</p><p>1、首先每个节点需要保存这个节点中回文串的长度。</p><p>2、显然始状态需要有两个，即奇数长度的$s$和偶数长度的$s$，称作<strong>“奇根”</strong>和<strong>“偶根”</strong>。那么为了方便呢，奇根的长度设置为$-1$，偶根长度设置为$0$。</p><p>3、考虑要从$last$指针扩展当前状态，假设当前需要<code>insert</code>的字母是$c$，是这个串里面的第$p$个字符，那我们需要找到一个后缀$s[j…p-1]\quad s.t.\quad s[j…p-1]$本身回文且$s[j-1]=c$，那么就可以向下扩展。</p><p>4、考虑怎么找这个后缀，显然对于一个串$S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的<strong>最长回文后缀</strong>。</p><p>5、插入新节点时，考虑跳完$fail$后如果没有相应的转移边，就要新建一个状态然后连$fail$.</p><p>然后是代码和一点注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line"><span class="keyword">int</span> rt0, rt1, last, sz ;</span><br><span class="line"><span class="keyword">int</span> len[MAXN], fail[MAXN] ;</span><br><span class="line">&#125;P ;</span><br><span class="line"><span class="keyword">void</span> _init(PAM &amp;p)&#123;</span><br><span class="line">p.sz = <span class="number">-1</span>, </span><br><span class="line">p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ;</span><br><span class="line">p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ;</span><br><span class="line">p.last = p.rt0, p.len[p.rt0] = <span class="number">0</span>, p.len[p.rt1] = <span class="number">-1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line"><span class="keyword">int</span> u = p.last ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line"><span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line"><span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line"><span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, </span><br><span class="line">&#125;</span><br><span class="line">p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn,</span><br></pre></td></tr></table></figure><p>原因是当$fa=u$时就出现环了。</p><h1 id="3-闲扯"><a href="#3-闲扯" class="headerlink" title="$3$ 闲扯"></a>$3$ 闲扯</h1><p>学完才知道，$\rm PAM$又简单又好背功能又多……Manacher被打爆了啊喂qwq。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PAM &amp;amp; Manacher，两种用来处理回文串的玩意儿。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PAM,回文自动机" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces前11场泛做</title>
    <link href="http://www.orchidany.cf/2019/11/15/cf1-11/"/>
    <id>http://www.orchidany.cf/2019/11/15/cf1-11/</id>
    <published>2019-11-14T23:34:18.000Z</published>
    <updated>2019-12-16T01:46:05.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq</p><a id="more"></a><h1 id="rm-CF·1C"><a href="#rm-CF·1C" class="headerlink" title="$\rm {CF·1C}$"></a>$\rm {CF·1C}$</h1><blockquote><p>求包含给定三点的正多边形最小面积。</p></blockquote><hr><p>先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。</p><p>之后对于该多边形，我们考虑，由于其让求的正多边形需要<strong>面积最小</strong>。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是<strong>该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍</strong></p><p>那么我们就做一个<code>double</code>类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。</p><p>最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-4</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.00000</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> mark ; <span class="comment">// 0 = exist, 1 = inexist ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">&#125;A, B, C, O, m1, m2, m3 ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ;<span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line">    <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; <span class="comment">// y = kx + b, x = k, y = k ;</span></span><br><span class="line">&#125;L[<span class="number">12</span>] ; <span class="keyword">double</span> Len[<span class="number">4</span>], agl[<span class="number">4</span>], R, angle ; <span class="keyword">int</span> i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is x = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is y = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_Mid</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.x + B.x) / <span class="number">2</span>, (A.y + B.y) / <span class="number">2</span> &#125; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_verti</span><span class="params">(Node n, Line a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.mark) <span class="keyword">return</span> (Line) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (a.mark == <span class="number">1</span>) <span class="keyword">return</span> (Line) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = <span class="number">-1.0</span> / a.k, bb = n.y - n.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_Line</span><span class="params">(Node A, Node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A. y == B. y) <span class="keyword">return</span> (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A. x == B. x) <span class="keyword">return</span> (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, A.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span><span class="params">(Line A, Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, get_x(A, B), get_y(A, B)&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.y - B.b) / B.k, A.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (B.y - A.b) / A.k, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, B.x, B.x * A.k + A.b&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, A.x, A.x * B.k + B.b&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">gcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; Eps) <span class="keyword">return</span> a ; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; Eps) <span class="keyword">return</span> b ; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, <span class="built_in">fmod</span>(a, b)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; </span><br><span class="line">  A.mark = B.mark = C.mark = <span class="number">0</span> ;</span><br><span class="line">    L[<span class="number">1</span>] = get_Line(A, B), L[<span class="number">2</span>] = get_Line(B, C), L[<span class="number">3</span>] = get_Line(A, C) ; </span><br><span class="line">  m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ;</span><br><span class="line">    L[<span class="number">4</span>] = get_verti(m1, L[<span class="number">1</span>]), L[<span class="number">5</span>] = get_verti(m2, L[<span class="number">2</span>]) ;</span><br><span class="line">  O = get_inter(L[<span class="number">4</span>], L[<span class="number">5</span>]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / <span class="number">3.0</span> ;</span><br><span class="line">    Len[<span class="number">1</span>] = dis(A, B), Len[<span class="number">2</span>] = dis(B, C), Len[<span class="number">3</span>] = dis(A, C) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) agl[i] = <span class="built_in">acos</span>(<span class="number">1</span> - Len[i] * Len[i] / (<span class="number">2</span> * R * R) ); </span><br><span class="line">    agl[<span class="number">3</span>] = <span class="number">2</span> * Pi - agl[<span class="number">1</span>] - agl[<span class="number">2</span>], angle = gcd(agl[<span class="number">3</span>], gcd(agl[<span class="number">1</span>], agl[<span class="number">2</span>])) ; <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (Pi * R * R * <span class="built_in">sin</span>(angle)) / angle) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·2B"><a href="#rm-CF·2B" class="headerlink" title="$\rm CF·2B$"></a>$\rm CF·2B$</h1><blockquote><p>给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走</p><p>以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾.</p><p>$n\leq 1,000$</p></blockquote><p>考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> &amp;N, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!N) &#123; zerox = i, zeroy = j ; <span class="keyword">return</span> <span class="number">1</span> ; &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ; <span class="keyword">while</span> (!(N % fac)) ++ res, N /= fac ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark, <span class="keyword">int</span> kind)</span></span>&#123; <span class="comment">//mark 1 : D, 2 : R ;</span></span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (kind == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mark) <span class="keyword">return</span> ; <span class="keyword">if</span> (mark == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"D"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp2)), dp2[<span class="number">1</span>][<span class="number">0</span>] = dp2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(dp5, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp5)), dp5[<span class="number">1</span>][<span class="number">0</span>] = dp5[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp2[i][j] = min(dp2[i - <span class="number">1</span>][j], dp2[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">1</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">2</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp5[i][j] = min(dp5[i - <span class="number">1</span>][j], dp5[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">2</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">5</span>)) ;</span><br><span class="line">    Ans = min(dp5[N][N], dp2[N][N]) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans &gt; <span class="number">1</span> &amp;&amp; zerox &amp;&amp; zeroy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zerox ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zeroy ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zerox + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zeroy + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  dp5[N][N] &gt; dp2[N][N] ? Print(N, N, <span class="number">0</span>, <span class="number">1</span>) : Print(N, N, <span class="number">0</span>, <span class="number">2</span>) ;</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·2C"><a href="#rm-CF-·2C" class="headerlink" title="$\rm CF ·2C$"></a>$\rm CF ·2C$</h1><blockquote><p>给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。</p></blockquote><p><del>咋又是计算几何啊</del></p><p>设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。</p><p>那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有$$\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}$$</p><p>稍微移一下项，就会有$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)} $$</p><p>那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。</p><p>事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可：</p><p>设比例系数为$k(k \geq 1)$, 那么：</p><p>$$<br>\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\\<br>\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2<br>$$</p><p>稍微移一下项就会得到<br>$$<br>(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0<br>$$</p><p>看起来有点儿长……</p><p>令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$</p><p>那么就会变成<br>$$<br>Ax^2 + Ay^2+ Cx + Dy+E = 0<br>$$<br>由于$A,C,D,E$都是常数，所以这是一个<strong>圆的一般方程。</strong></p><p>我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说<strong>当且仅当两个圆半径相等时，点$T$的轨迹是一条直线</strong>。其余的情况则是<strong>一个圆</strong>。</p><p>我们不妨先记这种<strong>到两个圆的圆心的距离成定比例的</strong>轨迹为两个圆的<strong>生成曲线</strong>。</p><p>那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要：</p><ul><li>$(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。</li><li>$(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}$$的点，我们需要判断对于圆$C$是否也满足<br>$$<br>\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}<br>$$</li><li>$(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。</li></ul><p>然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233</p><p>代码很繁琐233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-3</span> ; <span class="keyword">int</span> i ;<span class="comment">//以下的mark都是记录状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> xa, ya, xb, yb ; &#125; I[<span class="number">5</span>] ; </span><br><span class="line"><span class="comment">// 0 = inexist, 1 = exist*1, 2 = exist*2 ;</span></span><br><span class="line"><span class="comment">//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; &#125;L[<span class="number">12</span>] ; </span><br><span class="line"><span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ; <span class="comment">// 1 : circle ; 0 : Line ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r ;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, D, E ;</span><br><span class="line">    Circle <span class="keyword">friend</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> Circle &amp;A, <span class="keyword">const</span> Circle &amp;B)&#123;</span><br><span class="line">        <span class="keyword">return</span> (Circle)&#123;<span class="number">0</span>, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;C[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">double</span> ansx, ansy ; <span class="keyword">bool</span> check ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> A.mark &lt; B.mark ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is (x = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is (y = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disa</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); </span><br><span class="line">&#125;<span class="comment">//第一个点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disb</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); </span><br><span class="line">&#125;<span class="comment">//第二个点之间的距离</span></span><br><span class="line"><span class="comment">//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">Line_inter</span><span class="params">(Line A, Line B)</span></span>&#123;<span class="comment">//斜截式直线求交点（之前写的直接copy过来的）</span></span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) ) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, get_x(A, B), get_y(A, B), <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.y - B.b) / B.k, A.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (B.y - A.b) / A.k, B.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, B.x, B.x * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, A.x, A.x * B.k + B.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span> <span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//“生成曲线”求交点</span></span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">0</span> &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == <span class="number">0</span>))&#123;<span class="comment">//一条是直线，一个是圆</span></span><br><span class="line">        <span class="keyword">if</span> (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; <span class="comment">// B is a line ;</span></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span> + (B.C / B.D) * (B.C / B.D), del ;</span><br><span class="line">        <span class="keyword">double</span> c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ;</span><br><span class="line">        <span class="keyword">double</span> b = (A.C - B.C * A.D / B.D + <span class="number">2</span> * B.C * B.E /((B.D) * (B.D)) ) ; </span><br><span class="line">        <span class="keyword">if</span> ((del = (b * b - <span class="number">4</span> * a * c)) &lt; -Eps) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ; </span><br><span class="line">        <span class="comment">// printf("%lf %lf %lf %lf\n", a, b, c, del) ;</span></span><br><span class="line">        <span class="keyword">double</span> xa =  (-b + <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a), xb = (-b - <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a) ;</span><br><span class="line">        <span class="keyword">double</span> ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">return</span> (Node)&#123;<span class="number">2</span>, xa, ya, xb, yb&#125; ;<span class="comment">//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.mark &amp;&amp; !B.mark)&#123;</span><br><span class="line">        Line La, Lb ; <span class="comment">//两条都是直线，那么就直接转化成斜截式求。</span></span><br><span class="line">        <span class="keyword">if</span> (!A.C) La = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - A.E / A.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!A.D) La = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -A.E / A.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> La = (Line)&#123;<span class="number">2</span>, -A.C / A.D, -A.E / A.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (!B.C) Lb = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - B.E / B.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!B.D) Lb = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -B.E / B.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> Lb = (Line)&#123;<span class="number">2</span>, -B.C / B.D, -B.E / B.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">        <span class="keyword">return</span> Line_inter(La, Lb) ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (A.mark &amp;&amp; B.mark)&#123;</span><br><span class="line">        Circle C = A - B ; <span class="keyword">return</span> get_inter(C, A) ;</span><br><span class="line">        <span class="comment">//此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">make_rat</span><span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//rat = ratio[n.]比例；比率，用来求生成曲线的函数</span></span><br><span class="line">    <span class="keyword">double</span> _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; <span class="keyword">double</span> t ; </span><br><span class="line">    Ans.A = Ans.B = (_k2 - <span class="number">1</span>), </span><br><span class="line">  Ans.C = <span class="number">-2</span> * (_k2 * B.x - A.x), </span><br><span class="line">  Ans.D = <span class="number">-2</span> * (_k2 * B.y - A.y), </span><br><span class="line">    Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), </span><br><span class="line">  Ans.x = Ans.y = Ans.r = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (Ans.A != <span class="number">0</span>) </span><br><span class="line">      Ans.mark = <span class="number">1</span>, t = Ans.A, Ans.A /= t, </span><br><span class="line">  Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; </span><br><span class="line">  <span class="keyword">else</span> Ans.mark = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_for_Ans</span><span class="params">()</span></span>&#123;<span class="comment">//最后的结果，判断选哪个交点</span></span><br><span class="line">    sort(I + <span class="number">1</span>, I + <span class="number">3</span>, Comp) ;<span class="comment">//我闲的，方便一点</span></span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>].mark &lt;= <span class="number">1</span>) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> A1, A11, B1, B11 ;</span><br><span class="line">        I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]) ;</span><br><span class="line">        A1 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        A11 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        B1 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        B11 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        <span class="keyword">if</span> (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) </span><br><span class="line">          check = <span class="number">1</span> ;<span class="comment">//如果在误差范围内都不相等就说明无解。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> Ja = <span class="built_in">sin</span>(<span class="number">1</span> / A1), Jb = <span class="built_in">sin</span>(<span class="number">1</span> / B1) ;<span class="comment">//比较角的大小，通过sin来搞</span></span><br><span class="line">            <span class="keyword">if</span> (Ja &gt; Jb) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">          <span class="keyword">else</span> ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ;</span><br><span class="line">    C[<span class="number">4</span>] = make_rat(C[<span class="number">1</span>], C[<span class="number">2</span>]), </span><br><span class="line">  C[<span class="number">5</span>] = make_rat(C[<span class="number">2</span>], C[<span class="number">3</span>]), </span><br><span class="line">  C[<span class="number">6</span>] = make_rat(C[<span class="number">3</span>], C[<span class="number">1</span>]), </span><br><span class="line">    I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]), </span><br><span class="line">  I[<span class="number">2</span>] = get_inter(C[<span class="number">5</span>], C[<span class="number">6</span>]), </span><br><span class="line">  I[<span class="number">3</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">6</span>]) ; </span><br><span class="line">    <span class="comment">/*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!I[<span class="number">1</span>].mark || !I[<span class="number">2</span>].mark || !I[<span class="number">3</span>].mark) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'\n'</span>), <span class="number">0</span> ; </span><br><span class="line">  make_for_Ans() ; (!check) ? <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf"</span>, ansx, ansy) : <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·3B"><a href="#rm-CF·3B" class="headerlink" title="$\rm CF·3B$"></a>$\rm CF·3B$</h1><blockquote><p>有一辆载重量为$v$的货车， 准备运送两种物品。 </p><p>物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。</p><p>$n\leq 100,000\quad v\leq 1e9$</p></blockquote><p>其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。</p><p>$\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学）</p><p>有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ,val ;</span><br><span class="line">&#125; base1[MAXN], base2[MAXN] ; <span class="keyword">int</span> N, M, p, v, v1, v2, c ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ; <span class="keyword">int</span> tot1, tot2, t1, t2, i ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Data a, Data b)</span></span>&#123; <span class="keyword">return</span> a.val &gt; b.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="built_in">memset</span>(base1, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base1)) ; </span><br><span class="line">    <span class="built_in">memset</span>(base2, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base2)) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v) ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">1</span>) base2[++ tot2].val = v, base2[tot2].num = i ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*qwq*/</span>base1[++ tot1].val = v, base1[tot1].num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base1 + <span class="number">1</span>, base1 + tot1 + <span class="number">1</span>, Comp), </span><br><span class="line">    sort(base2 + <span class="number">1</span>, base2 + tot2 + <span class="number">1</span>, Comp) ;</span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp; <span class="number">1</span>) ans.pb(base1[<span class="number">1</span>].num), Ans += base1[<span class="number">1</span>].val, ++ t1, M -- ;</span><br><span class="line">    <span class="keyword">while</span> (M &gt; <span class="number">1</span>)&#123;<span class="comment">//此处&gt;1是选v=2时防止越界</span></span><br><span class="line">        v2 = base2[t2 + <span class="number">1</span>].val ;</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) <span class="keyword">break</span> ;</span><br><span class="line">        v1 = base1[t1 + <span class="number">1</span>].val + base1[t1 + <span class="number">2</span>].val ; </span><br><span class="line">        <span class="keyword">if</span> (t1 + <span class="number">2</span> &gt; tot1) v1 = base1[t1 + <span class="number">1</span>].val, c = <span class="number">1</span> ; <span class="keyword">else</span> c = <span class="number">2</span> ; </span><br><span class="line">        <span class="keyword">if</span> (v1 &gt;= v2)&#123;</span><br><span class="line">            Ans += v1 ; M -= c ;</span><br><span class="line">            rep(i, <span class="number">1</span>, c) ans.pb(base1[++ t1].num) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Ans += v2, M -= <span class="number">2</span>, ans.pb(base2[++ t2].num) ; </span><br><span class="line">    &#125;<span class="comment">//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp;&amp; t1 &lt; tot1) </span><br><span class="line">      Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; </span><br><span class="line">  <span class="keyword">if</span> (Ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) <span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="string">" "</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·4D"><a href="#rm-CF·4D" class="headerlink" title="$\rm{CF·4D}$"></a>$\rm{CF·4D}$</h1><blockquote><p>给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$</p><p>求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度<br>$n \leq 5,000$</p></blockquote><p>一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), f[i] = <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">if</span> (A &lt;= W || B &lt;= H) <span class="keyword">continue</span> ;</span><br><span class="line">      E[++ tot].w = A, E[tot].h = B, E[tot].num = i ;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(E + <span class="number">1</span>, E + tot + <span class="number">1</span>, Comp) ;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h)</span><br><span class="line">              <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                  f[i] = f[j] + <span class="number">1</span>, r[i] = j ;</span><br><span class="line">              &#125; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; ans) ans = f[i], End = i ;</span><br><span class="line">  <span class="keyword">while</span>(End) s.push(End), End = r[End] ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">while</span> (!s.empty()) <span class="built_in">cout</span> &lt;&lt; E[s.top()].num &lt;&lt; <span class="string">" "</span>, s.pop() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5C"><a href="#rm-CF·5C" class="headerlink" title="$\rm CF·5C$"></a>$\rm CF·5C$</h1><blockquote><p>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。</p><p>$n\leq 1,000,000$</p></blockquote><p>好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s ; </span><br><span class="line"><span class="keyword">int</span> N, dp[MAXN], f[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) s.push(i)<span class="comment">/*, cout &lt;&lt; "qwq" &lt;&lt; endl */</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s.empty()) base[s.top()] = base[i] = <span class="number">1</span>, s.pop() ; </span><br><span class="line">    &#125; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (base[i]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span> ; <span class="keyword">else</span> dp[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      f[i] = max(f[i - <span class="number">1</span>], dp[i]) ; <span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">  <span class="keyword">int</span> maxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dp[i] == f[N]) ++ ans ; <span class="built_in">cout</span> &lt;&lt; (f[N] ? ans : <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5D"><a href="#rm-CF·5D" class="headerlink" title="$\rm CF·5D$"></a>$\rm CF·5D$</h1><blockquote><p>有一个长度为$l$的道路，你的加速是$a$。</p><p>从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。</p><p>$w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。</p></blockquote><p>高中物理模拟题？？</p><p>其实就是分类讨论一下就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> mark ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span> ; </span><br><span class="line"><span class="keyword">double</span> x_1, x_2, ans, x ;</span><br><span class="line"><span class="keyword">double</span> vnow, a, vmax, L, D, vmaxd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; a) swap(a, b) ;</span><br><span class="line"><span class="keyword">return</span> ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">0.5</span> * (<span class="number">2</span> * a * D + vmaxd * vmaxd)) ; </span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmax) vnow = vmax, mark = <span class="number">1</span> ;</span><br><span class="line">x_1 = vnow * vnow / <span class="number">2</span> / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;</span><br><span class="line"><span class="comment">//if (!mark)&#123;</span></span><br><span class="line">ans += vnow / a + (vnow - vmaxd) / a ; </span><br><span class="line"><span class="keyword">if</span> (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ;</span><br><span class="line"><span class="comment">/*&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment">ans += vnow / a + (vnow - vmaxd) / a ;</span></span><br><span class="line"><span class="comment">x = ans += x / vnow ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmax, x = vnow * vnow / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L || equal(x, L))&#123;</span><br><span class="line">ans = vnow / a, ans += (L - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * L) ;</span><br><span class="line">ans = vnow / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = (vmax * vmax - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L - D || equal(x, L - D))&#123;</span><br><span class="line">ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmaxd, x = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * (L - D) + vnow * vnow) ;</span><br><span class="line">ans += (x - vnow) / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5E"><a href="#rm-CF·5E" class="headerlink" title="$\rm CF·5E$"></a>$\rm CF·5E$</h1><blockquote><p>有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。</p><p>$n\leq 100,000$</p></blockquote><p>一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; ++ i) <span class="built_in">stack</span>[i] = Mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">init(M), ans = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i, tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line"><span class="keyword">while</span> (tp &amp;&amp; <span class="built_in">stack</span>[tp].first &lt; base[i]) </span><br><span class="line">      ans += <span class="built_in">stack</span>[tp].second, -- tp ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>[tp].first != base[i])  </span><br><span class="line">ans += (tp &gt; <span class="number">0</span>), <span class="built_in">stack</span>[++ tp] = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">else</span> ans += (tp &gt; <span class="number">1</span>) + <span class="built_in">stack</span>[tp].second, ++ <span class="built_in">stack</span>[tp].second ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i + N] = base[i] = qr() ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; St, Ed ;</span><br><span class="line">St = Mp(<span class="number">-1</span>, <span class="number">0</span>), Ed = Mp(<span class="number">-1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (St.first &lt; base[i]) </span><br><span class="line">      Ed = St, St = Mp(base[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (St.first == base[i]) ++ St.second ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Ed.first &lt; base[i]) Ed = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ed.first == base[i]) ++ Ed.second ;</span><br><span class="line">&#125;</span><br><span class="line">Ans = Solve(<span class="number">2</span> * N) - Solve(N),</span><br><span class="line">  Ans -= (St.second * St.second + ((St.second == <span class="number">1</span>) ? Ed.second : <span class="number">0</span>)), </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·6D"><a href="#rm-CF·6D" class="headerlink" title="$\rm CF·6D$"></a>$\rm CF·6D$</h1><blockquote><p>有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。</p><p>不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。</p><p>$n\leq 10$</p></blockquote><p>看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, a, b, blood[MAXN], i, j, k, l ; </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; From[MAXN][MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">Print(step - <span class="number">1</span>, From[step + <span class="number">1</span>][jj][kk].first, From[step + <span class="number">1</span>][jj][kk].second) ;</span><br><span class="line"><span class="keyword">int</span> tow = dp[step][From[step + <span class="number">1</span>][jj][kk].first][From[step + <span class="number">1</span>][jj][kk].second] ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">1</span> ; qwq &lt;= dp[step + <span class="number">1</span>][jj][kk] - tow ; ++ qwq) <span class="built_in">printf</span>(<span class="string">"%d "</span>, step) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; a &gt;&gt; b ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; blood[i], ++ blood[i] ;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">2</span>][blood[<span class="number">1</span>]][blood[<span class="number">2</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= blood[i - <span class="number">1</span>] ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= blood[i] ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> down_ = (j + b - <span class="number">1</span>) / b ;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j][k] &gt; INF) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">int</span>up_ = max(down_, max((blood [i + <span class="number">1</span>] + b - <span class="number">1</span>) / b, (k + a - <span class="number">1</span>) / a)) ;</span><br><span class="line"><span class="keyword">for</span> (l = down_ ; l &lt;= up_ ; ++ l)&#123;</span><br><span class="line"><span class="keyword">int</span> now_j = max(<span class="number">0</span>, k - a * l) ;</span><br><span class="line">          <span class="keyword">int</span> now_k = max(<span class="number">0</span>, blood[i + <span class="number">1</span>] - b * l) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i + <span class="number">1</span>][now_j][now_k] &gt; dp[i][j][k] + l)</span><br><span class="line">dp[i + <span class="number">1</span>][now_j][now_k] = dp[i][j][k] + l, </span><br><span class="line">          From[i + <span class="number">1</span>][now_j][now_k] = Mp(j ,k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; Print(N - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·6E"><a href="#rm-CF-·6E" class="headerlink" title="$\rm CF ·6E$"></a>$\rm CF ·6E$</h1><blockquote><p>给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。</p><p>$n\leq 100,000$</p></blockquote><p>憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233</p><p>值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。</p><p>然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, h1 = <span class="number">1</span>, t1 = <span class="number">0</span>, h2 = <span class="number">1</span>, t2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ;</span><br><span class="line">  <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ;</span><br><span class="line">  q[++ t1] = p[++ t2] = i ; </span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123;</span><br><span class="line">  l ++ ; <span class="keyword">while</span> (q[h1] &lt; l) ++ h1 ; <span class="keyword">while</span> (p[h2] &lt; l) ++ h2 ;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, s[i] - s[l - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是二分$st$表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_ST</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> H = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= H ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) &lt;= N + <span class="number">1</span> ; ++ i)</span><br><span class="line">dp1[i][j] = max(dp1[i][j - <span class="number">1</span>], dp1[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]), </span><br><span class="line">dp2[i][j] = min(dp2[i][j - <span class="number">1</span>], dp2[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> max(dp1[l][k - <span class="number">1</span>], dp1[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> min(dp2[l][k - <span class="number">1</span>], dp2[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">dp1[i][<span class="number">0</span>] = dp2[i][<span class="number">0</span>] = base[i] = qr() ;</span><br><span class="line">build_ST(), ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">L = i, R = N ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (query_max(i, Mid) - query_min(i, Mid) &lt;= K) </span><br><span class="line">t = Mid, L = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> R = Mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">L = t ;</span><br><span class="line"><span class="keyword">if</span> (L - i + <span class="number">1</span> &gt; ans) ans = L - i + <span class="number">1</span>, Ans[cnt = <span class="number">1</span>][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (L - i + <span class="number">1</span> == ans) Ans[++ cnt][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i][<span class="number">0</span>], Ans[i][<span class="number">1</span>]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·7C"><a href="#rm-CF·7C" class="headerlink" title="$\rm CF·7C$"></a>$\rm CF·7C$</h1><blockquote><p>给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。</p></blockquote><p>sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq</p><h1 id="rm-CF·7D"><a href="#rm-CF·7D" class="headerlink" title="$\rm CF·7D$"></a>$\rm CF·7D$</h1><blockquote><p>一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，<code>abaaba</code>是3阶字符串。</p><p>现在给定你一字符串，请你求出其所有前缀的的阶级之和。</p><p>$|\sf S|\leq 5,000,000$</p></blockquote><p>似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么<br>$$<br>f_i=[\quad H[1…\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1…i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)<br>$$</p><p>答案就是$\sum f_i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">131</span> ;<span class="keyword">bool</span> mark[MAXN] ;</span><br><span class="line"><span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> N, Ans, i, j, h, ans[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1[MAXN], base2[MAXN], times[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">times[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base1[i] = (base1[i - <span class="number">1</span>] * base + S[i]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base2[i] = (base2[i - <span class="number">1</span>] * base + S[N - i + <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) times[i] = times[i - <span class="number">1</span>] * base % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), init() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">h = i / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t1 = base1[h] % Mod ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ;</span><br><span class="line">ans[i] = (t1 == t2) * (ans[h] + <span class="number">1</span>),  Ans += ans[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·8C"><a href="#rm-CF·8C" class="headerlink" title="$\rm CF·8C$"></a>$\rm CF·8C$</h1><blockquote><p>平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。</p></blockquote><p>我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN], Pre[MAXN], Max ;</span><br><span class="line"><span class="keyword">int</span> N, D[<span class="number">50</span>][<span class="number">50</span>], i, j, k, bit[<span class="number">50</span>], tp ; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Obj[<span class="number">50</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Obj[<span class="number">0</span>].fr &gt;&gt; Obj[<span class="number">0</span>].sc &gt;&gt; N ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; ++ j)</span><br><span class="line">D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) </span><br><span class="line">      + (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ;</span><br><span class="line">Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i) dp[i] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit)), tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) bit[++ tp] = j + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= tp ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tp ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j != k)&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]], </span><br><span class="line">          Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>], </span><br><span class="line">        Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &lt; <span class="number">1061109567</span>) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[Max] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">while</span> (Max)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">int</span> qaq = Max ^ Pre[Max] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; qaq) <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">Max = Pre[Max] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·9D"><a href="#rm-CF·9D" class="headerlink" title="$\rm CF·9D$"></a>$\rm CF·9D$</h1><blockquote><p>用$n$个点组成二叉树，问高度大于等于$h$的有多少个。</p><p>$n\leq 35$</p></blockquote><p>没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; H ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; j ; ++ k)</span><br><span class="line">dp[j][i] += dp[k][i - <span class="number">1</span>] * dp[j - k - <span class="number">1</span>][i - <span class="number">1</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][N] - dp[N][D - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10C"><a href="#rm-CF·10C" class="headerlink" title="$\rm CF·10C$"></a>$\rm CF·10C$</h1><blockquote><p>定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$</p><p>现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。</p><p>$N\leq 1000000$</p></blockquote><p>考虑$d()$的本质：<br>$$<br>d(x)=\left{\begin{array}{ll}{x \bmod 9,} &amp; {x \bmod 9 \neq 0} \ {9,} &amp; {x \bmod 9=0}\end{array}\right.<br>$$<br>那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。</p><p>那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, base[<span class="number">20</span>], A, B, i, j ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i % <span class="number">9</span>] ++, B += N / i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">A += base[i] * base[j] * base[i * j % <span class="number">9</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A - B &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10D"><a href="#rm-CF·10D" class="headerlink" title="$\rm CF·10D$"></a>$\rm CF·10D$</h1><blockquote><p>求两个串的最长公共上升子序列。</p><ul><li><p>$n\leq 500$</p></li><li><p>$n\leq 5,000$</p></li></ul></blockquote><p>第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">if</span> (base1[i] != base2[j]) <span class="keyword">continue</span> ;</span><br><span class="line">dp[i][j] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt; j ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][k] + <span class="number">1</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, f[j] = k ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。</p><p>于是最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">dfs(pre[x]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, n = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (N = qr(), i = <span class="number">1</span> ; i &lt;= N ; ++ i) A[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (M = qr(), i = <span class="number">1</span> ; i &lt;= M ; ++ i) B[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, befo = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] != B[j]) f[i][j] = f[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">else</span> f[i][j] = res + <span class="number">1</span>, pre[j] = befo ;</span><br><span class="line"><span class="keyword">if</span> (B[j] &lt; A[i]) </span><br><span class="line"><span class="keyword">if</span> (res &lt; f[i - <span class="number">1</span>][j]) </span><br><span class="line">res = f[i - <span class="number">1</span>][j], befo = j ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (ans &lt; f[N][i]) ans = f[N][i], n = i ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; dfs(n) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11C"><a href="#rm-CF·11C" class="headerlink" title="$\rm CF·11C$"></a>$\rm CF·11C$</h1><blockquote><p>你有一个$01$矩阵。里面有多少个正方形？</p><p>其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣：</p><p>第一种：每条边与矩阵的边平行的正方形；</p><p>第二种：每条边与矩阵的对角线平行的正方形。</p><p>$t\leq 10,000\quad 2\leq n,m\leq 250$</p></blockquote><p>然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base[x][y] != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    base[x][y] = <span class="number">-1</span>, ++ step ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &gt;= <span class="number">1</span> &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= <span class="number">1</span> &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + step &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + i][y] != <span class="number">-1</span>) | (base[x][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + step][y + i] != <span class="number">-1</span>) | (base[x + i][y + step] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = step &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x + lx &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (base[x + lx][y] != <span class="number">-1</span> || y &lt; step) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + lx - i][y - i] != <span class="number">-1</span>) | (base[x + lx - i][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + i][y - i] != <span class="number">-1</span>) | (base[x + i][y + i] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][j] != <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                res = <span class="number">0</span>, dfs(i, j, res) ;</span><br><span class="line">                <span class="keyword">if</span> (res % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; res / <span class="number">4</span> &lt;= min(N, M))</span><br><span class="line">                    ans += chk1(res / <span class="number">4</span>, i, j) + chk2(res / <span class="number">4</span>, i, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11D"><a href="#rm-CF·11D" class="headerlink" title="$\rm CF·11D$"></a>$\rm CF·11D$</h1><blockquote><p>求简单无向图的环数。</p><p>$n\leq 19$</p></blockquote><p>一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。</p><p>观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从<code>lowbit</code>转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M, Mx = (1 &lt;&lt; N) - 1 ;</span><br><span class="line">for (i = 1, j = 0 ; j &lt; N ; ++ j, i &lt;&lt;= 1) f[i][j] = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] = A[v][u] = 1 ;</span><br><span class="line">for (s = 1 ; s &lt;= Mx ; ++ s)&#123;</span><br><span class="line">    for (i = 0 ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ;</span><br><span class="line">        for (j = 0 ; j &lt; N ; ++ j)&#123;</span><br><span class="line">            if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ;</span><br><span class="line">            if ((1 &lt;&lt; j) == low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans += f[s][i] ;</span><br><span class="line">            else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] += f[s][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codefoces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codefoces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数学/扩展欧几里得" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="计算几何/基础的点、直线与圆" scheme="http://www.orchidany.cf/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%9F%BA%E7%A1%80%E7%9A%84%E7%82%B9%E3%80%81%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%9C%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-711 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-711/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-711/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:14.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个马来西亚老哥出的一场<code>Div2</code>，题目还算有点意思，于是就virtual了后三个题。</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。</p><p>$n,m\leq 100$</p></blockquote><p>一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= K ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= M ; ++ k)</span><br><span class="line">dp[i][j][k] = Inf ; </span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = i - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*/</span></span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">if (j &gt;= pos[i])&#123;</span></span><br><span class="line"><span class="comment">for (k = 1 ; k &lt;= M ; ++ k)</span></span><br><span class="line"><span class="comment">for (l = 1 ; l &lt;= M ; ++ l)</span></span><br><span class="line"><span class="comment">for (w = 1 ; w &lt;= K ; ++ w)</span></span><br><span class="line"><span class="comment">if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (base[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[<span class="number">1</span>][<span class="number">1</span>][i] = val[<span class="number">1</span>][i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (!base[i])&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)&#123;</span><br><span class="line">dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k] + val[i][k]);</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= M ; ++ l)</span><br><span class="line"><span class="keyword">if</span> (k != l) </span><br><span class="line">             dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][l] + val[i][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j][base[i]]) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k )</span><br><span class="line"><span class="keyword">if</span> (k != base[i]) </span><br><span class="line">           dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Ans = Inf, i = <span class="number">1</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (Ans == Inf ? - <span class="number">1</span> : Ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 </p><p>每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环</p></blockquote><p>一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。</p><p>好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>, base = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep, vis[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), deep + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)] &lt;= <span class="number">1</span>) rop[++ tot] = dep[u] - dep[to(k)] + <span class="number">1</span> ;</span><br><span class="line"> &#125;</span><br><span class="line">vis[u] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, Ans = <span class="number">1</span> ; <span class="keyword">int</span> qaq ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qaq), Add(i, qaq) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> ( !dep[i] ) dfs(i, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) </span><br><span class="line">    cnt += rop[i], (Ans *= (expow(rop[i]) - <span class="number">2</span> + Mod)) %= Mod ;</span><br><span class="line">Ans = Ans * expow(N - cnt) % Mod ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。</p><p>$n,k\leq 10^{18},\rm Mod=1e6+3$</p></blockquote><p>首先考虑答案就是<br>$$<br>\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}<br>$$<br>然后就变成了如果把这个东西求出来<del>传统艺能.jpg</del></p><p>1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。</p><p>2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来</p><p>3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$.</p><p>4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到<br>$$<br>\begin{aligned}<br>(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&amp;=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\ &amp;=(\prod\limits_{i=1}^{k}i,2^n)\ &amp;=(k!,2^n)<br>\end{aligned}<br>$$</p><p>再结合抽屉原理，只需要枚举$2$的幂就可以算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; ll Son, Mom ;</span><br><span class="line">ll N, M, Inv, _gcd, qwq, i, base = <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= Mod ;</span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">base &lt;&lt;= <span class="number">1</span> ; <span class="keyword">if</span> (base &gt;= M) &#123; ans = <span class="number">0</span> ; <span class="keyword">break</span> ;&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1 1"</span>), <span class="number">0</span> ;  Son = <span class="number">1</span> ;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M - <span class="number">1</span> ; i &lt;&lt;= <span class="number">1</span>) qwq += (M - <span class="number">1</span>) / i ;  </span><br><span class="line">_gcd = expow(<span class="number">2</span>, qwq), </span><br><span class="line">  Inv = expow(_gcd, Mod - <span class="number">2</span>) ; </span><br><span class="line">  Mom = expow(<span class="number">2</span>, N  % (Mod - <span class="number">1</span>) * (M - <span class="number">1</span>) % (Mod - <span class="number">1</span>)) ;</span><br><span class="line">  (Mom *= Inv) %= Mod ; </span><br><span class="line">  <span class="keyword">if</span> (M - <span class="number">1</span> &gt;= Mod) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, Mom, Mom), <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; M ; ++ i) </span><br><span class="line">    Son = Son * (expow(<span class="number">2</span>, N) - i + Mod) % Mod ; </span><br><span class="line">  (Son *= Inv) %= Mod, </span><br><span class="line">  Son = ((Mom - Son) % Mod + Mod) % Mod ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Son &lt;&lt; <span class="string">" "</span> &lt;&lt; Mom &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个马来西亚老哥出的一场&lt;code&gt;Div2&lt;/code&gt;，题目还算有点意思，于是就virtual了后三个题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-840 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-840/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-840/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:07.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。</p><p>但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。</p><p>$n\leq 10^5$</p></blockquote><p>刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的……</p><p>然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）<br>$$<br>\begin{aligned}<br>F(n,k)&amp;=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\\&amp;=\frac{n+1}{k+1}<br>\end{aligned}<br>$$<br>然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。</p><p>你需要选出一些边（不一定联通），使得这些边构成的图符合要求。</p><p>$n\leq 3\cdot 10^5$</p></blockquote><p>首先考虑如果没有<code>-1</code>并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。</p><p>发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。</p><p>然后分类讨论：<code>0</code>的点和<code>1</code>的点</p><ul><li><code>0</code>的点。直接忽略，因为不产生影响；</li><li><code>1</code>的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。</li></ul><p>于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span> ; <span class="keyword">int</span> ret = base[u] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ST(to(k))) </span><br><span class="line">      res[++ tot] = (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ret ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (base[u] &lt; <span class="number">0</span>) ret = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), </span><br><span class="line">  (base[i] &lt; <span class="number">0</span>) ? mr1 = i : (mr2 ^= base[i]) ;</span><br><span class="line"><span class="keyword">if</span> (!mr1 &amp;&amp; mr2) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">ST(mr1 ? mr1 : <span class="number">1</span>) ;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  sort(res + <span class="number">1</span>, res + tot + <span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。</p></blockquote><p>考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$后，两个数相同时，其乘积才会为完全平方数。</p><p>那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。</p><p>那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$<br>$$<br>f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll d, ll z)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (z)&#123;</span><br><span class="line"><span class="keyword">if</span> (z &amp; <span class="number">1</span>) (res *= d) %= Mod ;</span><br><span class="line">( d *= d ) %= Mod, z &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i] ; <span class="keyword">bool</span> mk = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">ll p = trunc(<span class="built_in">sqrt</span>(base[i] * grp[j])) ;</span><br><span class="line"><span class="keyword">if</span> (p * p == base[i] * grp[j])&#123;++ tm[j], mk = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mk) grp[++ cnt] = base[i], tm[cnt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span> (Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (Frac[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; tot += tm[i], ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= tot ; ++ j) </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tm[i] ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --)</span><br><span class="line"><span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt; N) </span><br><span class="line">            (dp[i][t] += </span><br><span class="line">             Frac[tm[i]] * Cm[tm[i] - <span class="number">1</span>][k - <span class="number">1</span>] % Mod </span><br><span class="line">           * Cm[j][l] % Mod * Cm[tot - j + <span class="number">1</span>][k - l] % Mod </span><br><span class="line">           * dp[i - <span class="number">1</span>][j] % Mod) %= Mod ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[cnt][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>这个D曾经单独写过：<a href="http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/">Link</a></p><p>233反正就是乱搞就对了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E2</title>
    <link href="http://www.orchidany.cf/2019/11/14/xiaone-2/"/>
    <id>http://www.orchidany.cf/2019/11/14/xiaone-2/</id>
    <published>2019-11-14T01:59:40.000Z</published>
    <updated>2019-12-15T06:33:45.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛第二弹</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>$𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 </p></blockquote><p>性质题，找不出来人似乎就没了233</p><p>考虑最优情况下肯定会是<strong>单调地跳</strong>，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。</p><p>小$c$开始了漫长的<code>debug</code>的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。</p><p>等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出<code>NO</code></p></blockquote><p>题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。</p><p>我也是贪心做的，不过是正着做的。没有限制时，如果上一个是<code>(</code>，那我这一个就安排成<code>)</code>就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是<code>()(</code>这样，第三个括号被强制为右括号，就顺便把前一个右括号改成<code>(</code>，即变为<code>(()</code>，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; M, i = <span class="number">1</span> ; i &lt;= M ; ++ i) ok[qr()] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (ok[i] &amp;&amp; !stk[base[i]].size())&#123;</span><br><span class="line">ans[i] = <span class="number">1</span> ; </span><br><span class="line">stk[base[i]].pb(mat[buc[base[i]]]) ;</span><br><span class="line">ans[i] = <span class="number">1</span>, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = <span class="number">0</span> ;</span><br><span class="line">mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> mat[i] = stk[base[i]].back(), ans[i] = <span class="number">1</span>, </span><br><span class="line"> mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (!ans[i]) <span class="built_in">stack</span>[++ t] = i ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">stack</span>[t --] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%d "</span>, ans[i] ? <span class="string">'-'</span> : <span class="string">'+'</span>, base[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个${a}$的子集来凑出$x$。同时，求最小$|{a}|$下凑出所有$x$的方案总数。</p></blockquote><p>第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。</p><p>第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ .</p><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。</p><p>JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。</p></blockquote><p><del>质疑题面在恰饭</del></p><p>一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。</p><p>然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。</p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。</p><p>$n,q\leq 100,000$</p></blockquote><p>一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。</p><p>考虑推式子<br>$$<br>\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\\<br>x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\\<br>y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}<br>$$<br>然后如果我们令$val_i=y\cdot A_i-x \cdot  B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去<code>uoj</code>群里问了一圈发现这个被<code>lxl</code>规约到了$n \sqrt n$的问题上面……</p><p>然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了<code>100ms~6500ms</code>这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。</p><p>然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? </span><br><span class="line">        blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇数块正着排，偶数块倒着排，就会快好多。</p><p>然后最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写了一下午QAQ</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[MAXN] ; <span class="keyword">int</span> l, r, buc[MAXM], val[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> blg[MAXN], T[MAXM &lt;&lt; <span class="number">2</span>], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, X, Y, M, S, U, base[MAXN], cnt[<span class="number">2</span>][MAXM], pre[MAXN][<span class="number">2</span>], res, res2 ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> T[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R, p, v) ;</span><br><span class="line">    T[rt] = max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">0</span>][val[p]]) cnt[<span class="number">0</span>][val[p]] = Nxt[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">1</span>][val[p]]) cnt[<span class="number">1</span>][val[p]] = Pre[p] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;<span class="comment">// cout &lt;&lt; T[1] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">0</span>][val[p]] = min(cnt[<span class="number">0</span>][val[p]], p) ;</span><br><span class="line">    cnt[<span class="number">1</span>][val[p]] = max(cnt[<span class="number">1</span>][val[p]], p) ;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        base[i] = s[i] - <span class="string">'A'</span>,</span><br><span class="line">        pre[i][base[i]] = pre[i - <span class="number">1</span>][base[i]] + <span class="number">1</span>,</span><br><span class="line">        pre[i][base[i] ^ <span class="number">1</span>] = pre[i - <span class="number">1</span>][base[i] ^ <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][<span class="number">0</span>] - X * pre[i][<span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">-1</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i &gt;= <span class="number">0</span> ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + <span class="number">1</span>, buc[val[i]] = i ;</span><br><span class="line">    M = qr() ; S = <span class="built_in">pow</span>(M, <span class="number">0.5832</span>) ; U = <span class="built_in">ceil</span>((<span class="keyword">double</span>)M / S) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">0</span>], <span class="number">63</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">1</span>], <span class="number">-1</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = (i - <span class="number">1</span>) * S + <span class="number">1</span> ; j &lt;= i * S ; ++ j) blg[j] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) q[i].l = qr() - <span class="number">1</span>, q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + M + <span class="number">1</span>, comp) ; l = <span class="number">0</span>, r = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) upd(++ r) ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) upd(-- l) ;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">        ans[q[i].id] = res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233</p><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote><p>你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。</p><p>算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。</p><p>你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了）</p><p>然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。</p><p>现在，你需要求出完成上述一系列动作走过的最短路程。</p><p>$n \leq 20$</p></blockquote><p>一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。</p><p>然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个<code>floyd</code>，然后每次的代价就是</p><p>$$<br>\mathsf{\min _{x\in S,y\in T}(f_{S,x}+dis_{x,y}+g_{T,y})+\min _{x\in S,y\in T}(g_{S,x}+dis_{x,y}+f_{T,y}})<br>$$</p><p>然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[MAXS][MAXN], pre[MAXS][<span class="number">2</span>], sz[MAXS], ans ;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, ans = Inf ;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span> (f)) ; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) dis[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= E ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; k &gt;&gt; o,</span><br><span class="line">        A[j][k] = A[k][j] = o,</span><br><span class="line">        dis[j][k] = dis[k][j] = o ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span> * (dis[<span class="number">0</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>])), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][now] = min(f[i][now], f[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ; g[<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)][N - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)) + <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> g[i][now] = min(g[i][now], g[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; g[M][1] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] != N / <span class="number">2</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> stA = i, stB = (~i &amp; M), res = Inf, fg = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stA)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stB) </span><br><span class="line">res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//        if (!fg) res = 0 ;</span></span><br><span class="line">stB ^= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>), stB |= <span class="number">1</span> ;</span><br><span class="line">stA ^= <span class="number">1</span>, stA |= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stB)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;</span><br><span class="line"><span class="comment">//if (!fg) ans *= 2 ;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校内模拟赛第二弹&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="校内模拟赛" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数据结构/线段树" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 2</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-15T06:33:12.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要就是整理一下dsu on tree的进阶版习题。</p><a id="more"></a><h1 id="0x01-rm-Cf375D-Tree-and-Queries"><a href="#0x01-rm-Cf375D-Tree-and-Queries" class="headerlink" title="$0x01$ $\rm Cf375D$  Tree and Queries"></a>$0x01$ $\rm Cf375D$  Tree and Queries</h1><blockquote><p>给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 </p></blockquote><p>考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，<code>calc</code>到每个点的时候先<code>del</code>掉原来的再<code>upd</code>新的信息……然后就做完了233</p><p>然而一开始的时候我调了好久，因为我是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] -- ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _count(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)&#123;</span><br><span class="line"><span class="keyword">bool</span> fg = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!chk[base[u]]) </span><br><span class="line">chk[base[u]] = <span class="number">1</span>, </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, val), fg = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; </span><br><span class="line"><span class="keyword">if</span> (!fg) chk[base[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_do(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_del(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很对的亚子，但是错就错在<strong>必须每个点独立计算完贡献才能考虑下一个点</strong>，否则下一个点的信息就是错误的——也就是说不能整体<code>del</code>再整体<code>upd</code>，必须逐个逐个的<code>del</code>和<code>upd</code>。。然而事实上关键问题还是在$buc$的统计上出了问题233</p><p>于是最后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] ++ ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] -- ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(query(<span class="number">1</span>, <span class="number">1</span>, N, qs[u][k] + <span class="number">1</span>, N)) ;</span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths"><a href="#0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths" class="headerlink" title="$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"></a>$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</h1><blockquote><p> 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 </p></blockquote><p>似乎是<code>Cf570D</code>的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的：</p><blockquote><p>我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数</p></blockquote><p>然后就是考虑怎么维护这个东西。</p><ul><li><p>不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$.</p></li><li><p>经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。</p></li></ul><p>看上去应该这么实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">f[dis[u]] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> &amp; ans, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans = max(ans, f[dis[u]] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans = max(ans, f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>), ans[u] = max(ans[u], ans[to(k)]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span>, </span><br><span class="line">ans[u] = max(ans[u], ans[son[u]]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != fa) </span><br><span class="line">calc(to(k), u, ans[u], dep[u]), update(to(k), u) ;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u]] - dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] - dep[u]) ;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。</p><p>唔，感觉这个题还是比较有技巧性的233</p><h1 id="0x03-rm-NOIP2018-模拟-·-树"><a href="#0x03-rm-NOIP2018-模拟-·-树" class="headerlink" title="$0x03$ $\rm NOIP2018$模拟 · 树"></a>$0x03$ $\rm NOIP2018$模拟 · 树</h1><p>这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：<a href="https://www.luogu.org/problem/U92408" target="_blank" rel="noopener">$\rm Link$</a></p><p>题面：</p><blockquote><p>给定一棵树。</p><p>令$[L,R]$描述的是序号在$[L,R]$内的点的集合。</p><p>同时，令函数$\boldsymbol F({ \rm S})$表示令集合$\rm S$内的点联通的需要的最小边数。</p><p>问题则是求：</p><p>$$<br>\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])<br>$$</p><p>$n\leq 100,000$</p></blockquote><hr><p>一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。</p><p>子树内的比较容易维护，考虑假设现在有了${1,2,3},{5,6}$两个集合，将其视作两个连通块，当加进来${4}$时，会和左右都相连接，不妨假设先与${1,2,3}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用<strong>并查集+并查集的$size$</strong>来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。</p><p>之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的<code>ans_out</code>显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，<code>set</code>里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了<br>$$<br>calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)<br>$$<br>原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。</p><p>所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], op[MAXN] ;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span> ; &#125;</span><br><span class="line"><span class="keyword">void</span> _clear()&#123;</span><br><span class="line">s.clear() ;</span><br><span class="line">ansout = calc(N), ansin = <span class="number">0</span>, </span><br><span class="line">s.insert(<span class="number">0</span>), s.insert(N + <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> x == fr[x] ? x : fr[x] = _find(fr[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">s.insert(u) ; op[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; :: iterator l, r, mid ;</span><br><span class="line">l = r = mid = s.find(u), l --, r ++ ;</span><br><span class="line">ansout += calc(*r - *mid - <span class="number">1</span>) + calc(*mid - *l - <span class="number">1</span>) - calc(*r - *l - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (op[u - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u - <span class="number">1</span>), f2 = _find(u) ; </span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op[u + <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u + <span class="number">1</span>), f2 = _find(u) ;</span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">fuck(u) ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> _update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">op[u] = <span class="number">0</span>, fr[u] = u, bg[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> _delete(to(k), u) ; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">_update(u, fa), ans += calc(N) - ansout - ansin ; </span><br><span class="line"><span class="keyword">if</span> (!mk) _delete(u, fa), _clear() ; vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Warning"><a href="#rm-Warning" class="headerlink" title="$\rm Warning$"></a>$\rm Warning$</h1><ul><li><p>注意一个地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br></pre></td></tr></table></figure><p>把这两句写反了会调一下午，欢迎尝试quq</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是整理一下dsu on tree的进阶版习题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 1</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-17T01:32:32.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly ~Direct~ Counting~ on~ Tree}$，“优雅的树上暴力统计”。</p><a id="more"></a><h1 id="rm-0x01-前言-amp-技术分析"><a href="#rm-0x01-前言-amp-技术分析" class="headerlink" title="$\rm 0x01$ 前言$\&amp;$技术分析"></a>$\rm 0x01$ 前言$\&amp;$技术分析</h1><p>严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛：</p><blockquote><p>1、维护子树信息；</p><p>2、不能带修改操作。</p></blockquote><p>但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。</p><p>然后来看技术分析。</p><p>首先，假设我们有这样一个问题：</p><blockquote><p>给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。</p><p>$n,q\leq 5\cdot1e5$</p><p>一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。</p></blockquote><p>考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。</p><p>考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。</p><p>现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。</p><p>所以这样就解决了维护树上信息的问题，复杂度$n\log n$。</p><h1 id="0x02-入门题目选整"><a href="#0x02-入门题目选整" class="headerlink" title="$0x02$ 入门题目选整"></a>$0x02$ 入门题目选整</h1><p>感觉大部分<code>blog</code>找的题目都很不清真233</p><h2 id="rm-Task1-rm-Cf600E-Lomsat-gelral"><a href="#rm-Task1-rm-Cf600E-Lomsat-gelral" class="headerlink" title="$\rm Task1$ $\rm Cf600E$ Lomsat gelral"></a>$\rm Task1$ $\rm Cf600E$ Lomsat gelral</h2><p>一句话题意</p><blockquote><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 </p></blockquote><p>考虑套$\rm EDCT$的板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line"><span class="keyword">if</span> (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa, <span class="number">1</span>) ; ans[u] = res ; <span class="keyword">if</span> (son[u]) vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (!mk) calc(u, fa, <span class="number">-1</span>), res = <span class="number">0</span>, max_cnt = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最后的<code>calc</code>函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">buc[clr[u]] += mk ; </span><br><span class="line"><span class="keyword">if</span> (mk &gt; <span class="number">0</span> &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[clr[u]] &gt; max_cnt) </span><br><span class="line">    res = <span class="number">0</span>, max_cnt = <span class="number">1l</span>l * buc[clr[u]] ;</span><br><span class="line">res += <span class="number">1l</span>l * clr[u] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; </span><br><span class="line">calc(to(k), u, mk) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Task2-Cf570D-Tree-Requests"><a href="#rm-Task2-Cf570D-Tree-Requests" class="headerlink" title="$\rm Task2 ~Cf570D$ Tree Requests"></a>$\rm Task2 ~Cf570D$ Tree Requests</h2><p>一句话题意：</p><blockquote><p>给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. </p></blockquote><p>这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] ^= (<span class="number">1</span> &lt;&lt; base[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (x) ret += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret &lt;= <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(getl(buc[qs[u][k]])) ; </span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly ~Direct~ Counting~ on~ Tree}$，“优雅的树上暴力统计”。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-814 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/13/codeforces-814/"/>
    <id>http://www.orchidany.cf/2019/11/13/codeforces-814/</id>
    <published>2019-11-13T13:34:25.000Z</published>
    <updated>2019-12-15T10:28:10.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场<code>cn</code> round，然后每次<code>cn</code> round的最后一题都会很奇怪……</p><a id="more"></a><h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega $"></a>$\Omega $</h1><p>$\rm virtual$了一场……说实话这种<code>div2 only</code>的场次最后一题就经常比较毒……</p><p><del>老规矩，前面几题用来水字数</del></p><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>给出一个长度为$N$的非负整数序列$a_i$与长度为$K$的正整数序列$b_i$，满足$a_i$中刚好有$K$个$0$，且任一正整数在序列$a$和序列$b$中的出现次数的和不会超过$1$。</p><p>现在试判断是否存在一种方法，使得用$b_i$中的元素替换$a_i$中的$0$得到的序列不是递增序列。 </p></blockquote><p>sb一眼题，显然如果递减放进去还是递增就无解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline bool cmp(int a, int b)&#123; return a &gt; b ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; K ; int j = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ;</span><br><span class="line">for (i = 1 ; i &lt;= K ; ++ i) cin &gt;&gt; t[i] ; sort(t + 1, t + K + 1, cmp) ;</span><br><span class="line">for (i = 1 ; i &lt;= N ; ++ i) if (!base[i]) base[i] = t[j ++] ;</span><br><span class="line">for (i = 1 ; i &lt; N ; ++ i) if (base[i] &gt; base[i + 1]) return puts(&quot;Yes&quot;), 0 ;</span><br><span class="line">return puts(&quot;No&quot;), 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给定两个长度为$n$的不相同序列$a$和$b$，这两个序列至少有一个位置不同</p><p>现在需要构造一个长度为$n$的排列$p$，使得$p$与$a$只有一个地方不同，且$p$与$b$也只有一个地方不同</p></blockquote><p>一眼就可以看出最多有两个位置不同，否则一定不合法。考虑分类讨论，如果只有一个位置不同那就放上那个没出现过的数字；如果有两个位置不同，那就考虑是$A$中第一个位置放多了还是第二个位置放多了，放上$B$的就完了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), Ma[A[i]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), Mb[B[i]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i] != B[i]) pos[++ cnt] = i ; </span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!Ma.count(i) &amp;&amp; !Mb.count(i)) &#123; A[pos[<span class="number">1</span>]] = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Ma[A[pos[<span class="number">1</span>]]] &gt; <span class="number">1</span> &amp;&amp; !Ma[B[pos[<span class="number">1</span>]]])&#123; </span><br><span class="line">A[pos[<span class="number">1</span>]] = B[pos[<span class="number">1</span>]] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">A[pos[<span class="number">2</span>]] = B[pos[<span class="number">2</span>]] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来觉得是道构造题，后来发现是道细节模拟题。。。</p><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给你一个由小写字母构成的字符串.<br>有$q$个询问，每个询问给出数字$m$和小写字母$c$，你可以任意地修改字符串中的$m$个字符，求最多能够使字符串中含有多少个连续相同的字母$c$.<br>每个询问各自独立.<br>$|\rm S|\leq 1,500$</p></blockquote><p>其实感觉复杂度一点也不对……比如我觉得这题可以做到$5e4$以上……</p><p>考虑弱化版（原版）的解法，大概就是用$f_{i,j}$表示前$i$个字符用了$k$次机会最长的连续段有多长。然后就可以直接$O(26n^2)$给预处理出来，每次询问回答一下即可。</p><p>但是我们发现这玩意儿复杂度一点也不平衡，因为预处理贼慢但是回答贼快。于是考虑有哪些性质没用。我们考虑预处理出原串中对于一个字符$c$，最近的两个$c$之间的位置来，然后如果要修改就显然先修改跨度小的$c_i$和$c_{i+1}$中间的部分，因为这样肯定不会更劣。同时只有把中间的非$c$区域占满才能使之连通，故每次对于一个给定的$k$，二分查找一下可以占满的区间，剩下的随便铺，对于这些占满的区间提前预处理出贡献的前缀和就完了。复杂度大概是$q\log n+26n$</p><p>然而升级版只是口胡，什么时候闲下来再写吧qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] == <span class="string">'a'</span> + i) dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] - <span class="string">'a'</span> == i) dp[i][j][k] = dp[i][j - <span class="number">1</span>][k] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> dp[i][j][k] = max(dp[i][j][k], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">ans[i][k] = max(ans[i][k], dp[i][j][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;k, &amp;In) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[(<span class="keyword">int</span>)In - <span class="string">'a'</span>][k] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p> 有$n$个圆，将其分为两组。每组中，只有奇数个圆覆盖的区域的才会算入面积，求可能的最大面积。 </p></blockquote><p>首先考虑贪心。大概就是说原本的覆盖一定可以看做一团一团独立的子问题。将圆按照面积大小排序，之后考虑选每一堆最大的放到第一堆，然后把与之原本冲突的放到第二堆。这样可以发现最终减去的部分面积变成了之前产生贡献的部分面积……然而这不重要，重要的是这样保证了每次选的一定都是面积最大的圆的集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (check_in(base[i], base[j])) ++ mark[j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (!mark[i] || (mark[i] &amp; <span class="number">1</span>)) Ans += get_S(base[i]) ; <span class="keyword">else</span> Ans -= get_S(base[i]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans) ;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这个贪心似乎不好想，于是考虑一种精妙的$\rm dp$<del>其实更不好想</del>。考虑按照圆从大到小枚举顺次连边，最后连出来的会是一个森林状物。然后对于这个东西， 定义$dp[u][0/1][0/1]$表示以点$u$为根的子树里面，除$u$之外分成两堆之后，两堆分别的高度为偶数/奇数时的最优值。这东西就可以直接分类讨论求和+转移。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(C A, C B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_S</span><span class="params">(C A)</span></span>&#123; <span class="keyword">return</span> Pi * A.r * A.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_in</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r + B.r &gt; dist(A, B) ; &#125;</span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next, to ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> faa)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">2</span>][<span class="number">2</span>] ; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == faa) <span class="keyword">continue</span> ;</span><br><span class="line">do_dp(to(k), u) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">f[ii][jj] += dp[to(k)][ii][jj] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">dp[u][ii][jj] = max(</span><br><span class="line">                f[ii ^ <span class="number">1</span>][jj] + (<span class="number">1l</span>l * (ii ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r), </span><br><span class="line">f[ii][jj ^ <span class="number">1</span>] + (<span class="number">1l</span>l * (jj ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (check_in(base[i], base[j])) </span><br><span class="line"><span class="keyword">if</span> (!fa[j] || base[fa[j]].r &gt; base[i].r) fa[j] = i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (fa[i]) Add(i, fa[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)<span class="keyword">if</span> (!fa[i]) do_dp(i, <span class="number">0</span>), Ans += dp[i][<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans * Pi) ;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给出$n$个点和每个点的度让你构造出一张无向图满足以下两条性质：</p><ul><li><p>$1.$点1到点$i$仅有<strong>唯一</strong>一条最短路</p></li><li><p>$2.$点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度</p></li></ul><p>求能构成满足条件的无向图的个数   $n\leq 50, 2\leq degree_i\leq 3$</p></blockquote><p>这种计数题会是不可能会的，这辈子都不可能会了qaq</p><p>考虑一个$idea$，因为这张图无权，所以最短路一定会是$\it bfs$的分层。那么对于一个$i$来讲，他的要么和$i-1$在同一层，要么就在$i-1$的下一层。</p><p>那么考虑记$f_{i,j}$表示前$i$个点中有$j$个和$i$在同一层的方案数。那么考虑这东西的转移跟上一层中点的度数有关，也就是需要记$dp_{k,c_1,c_2}$表示当前层有$k$个点，上一层度数为$2$的点有$c_1$个，度数为$3$的点有$c_2$个这一子状态的方案数。那么有如下：<br>$$<br>dp_{i,j,k}=\begin{cases}{1} &amp; (i=j=k=0)\ \ {\sum\limits_{l=2}^{k-1} dp_{i,j,k-l-1} \cdot\left(\begin{array}{c}{k-1} \ {l}\end{array}\right) \cdot N_{l+1}} &amp;(i=j=0,k&gt;0) \ \ {(j-1) \cdot dp_{i,j-2,k}+k \cdot dp_{i,j,k-1}} &amp; (i=0,j&gt;0)\ \{j \cdot dp_{i-1,j-1,k}+k \cdot dp_{i-1,j+1,k-1}} &amp; (i&gt;0)\ \{0}\end{cases}<br>$$<br>其中$N_i$表示<strong>$\boldsymbol{i-}$项链数</strong>，也就是长度为$i$、元素各异、镜像对称的单环的数量，计算方式如下：<br>$$<br>N_i=\begin{cases} 1 &amp; (i=2)\ \frac{(i-1)!}{2} &amp;(i&gt;2)\ 0 &amp; \rm{otherwise}\ \end{cases}<br>$$<br>对于第二个转移，就是考虑向上一层插入一个点使其成为度数为$3$的点。考虑因为度数为$3$且题目要求“有位移最短路”，所以同一层中只有可能是简单的平边相连。所以就是考虑枚举原来的点里面可以与新加入的点组成项链的方案数。注意这里项链数必须$&gt;2$原因是题目中强调了不能有两个点之间连$&gt;1$条边。</p><p>对于第三个转移，考虑插入一个点使其度数为$2$，这一步转移即考虑$j-1$个点中选择一个可能变成$2$度的点和新加近来这个点相连有$j-1$种方案，相连之后两个点度数都变为$2$；同时考虑另一种可能性，就是这一个点和一个可能变成$3$度的点相连，那么原来的二度点变为三度点，新加进来的变成二度点。</p><p>对于第四个转移，考虑这一层最后一个加进来的节点，要么和上一层中一个可能变成$2$度的点相连要么和可能变成$3$度的点相连。</p><p>然后最后的答案就是枚举最后一层的点数<br>$$<br>ans =\sum_{j=1}^{n}f_{n,j}\cdot g_{0,c_1,c_2}<br>$$<br>其中$c_1$和$c_2$表示枚举到现在有多少个$d=2$和$d=3$的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> N, clr1, clr2, base[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, l ; ll dp[MAXN][MAXN] ;</span><br><span class="line">ll Ans, A[MAXN], f[MAXN][MAXN][MAXN], Cm[MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N  ; Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ; </span><br><span class="line"><span class="keyword">for</span> ( A[<span class="number">1</span>] = A[<span class="number">0</span>] = <span class="number">0</span>, A[<span class="number">2</span>] = A[<span class="number">3</span>] = <span class="number">1</span>, i = <span class="number">4</span> ; i &lt;= N ; ++ i) A[i] = A[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % Mod ;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; <span class="comment">//Calculate g</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - j ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!j &amp;&amp; k)</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt; k ; ++ l)</span><br><span class="line">(f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - l - <span class="number">1</span>] * Cm[k - <span class="number">1</span>][l] % Mod * A[l + <span class="number">1</span>] % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="number">2</span>) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j - <span class="number">2</span>][k] * (j - <span class="number">1</span>) % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">if</span> (k) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - <span class="number">1</span>] * k % Mod) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N - i ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - i - j ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j) (f[i][j][k] += f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * j % Mod) %= Mod ;</span><br><span class="line"><span class="keyword">if</span> (k) (f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * k % Mod) %= Mod ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; f[i][j][k] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Calculate dp</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; dp[base[<span class="number">1</span>] + <span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = base[<span class="number">1</span>] + <span class="number">2</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i - base[<span class="number">1</span>] - <span class="number">1</span> ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, k = <span class="number">1</span> ; k &lt;= i - j ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[i - j - k + <span class="number">1</span>] &lt;= <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">(dp[i][j] += (dp[i - j][k] * f[j][clr1][clr2] % Mod)) %= Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[N - i + <span class="number">1</span>] == <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">(Ans += (dp[N][i] * f[<span class="number">0</span>][clr1][clr2]) % Mod) %= Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一场&lt;code&gt;cn&lt;/code&gt; round，然后每次&lt;code&gt;cn&lt;/code&gt; round的最后一题都会很奇怪……&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E1</title>
    <link href="http://www.orchidany.cf/2019/11/13/xiaonei-1/"/>
    <id>http://www.orchidany.cf/2019/11/13/xiaonei-1/</id>
    <published>2019-11-13T13:10:22.000Z</published>
    <updated>2019-12-16T07:55:15.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛选整</p><p>大概难度都是TG里面$2$~$3$左右的。</p><a id="more"></a><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><blockquote><p>给定直线上$n\leq 2000$个建筑的坐标，两种覆盖方式，$A:$覆盖长度为$L$，可以用$p$次；$B$：覆盖长度为$2L$，可以用$q$次。求最小的$L$.</p></blockquote><hr><p>首先就是可以知道$p,q$可以缩到$p+q\leq n$，否则答案就是$1$。</p><p>之后考虑二分一个$L$，$check$其正确性。$check$时感觉贪心并不是很好贪，可能会有比较妙的贪心，但这个地方选择一种更加稳妥的$dp$。考虑$f_{i,j}$表示两种覆盖分别用了$i,j$个最多能覆盖到哪个建筑，则<br>$$<br>f_{i,j}=\max(go_p[f_{i-1,j}+1], go_q[f_{i,j-1}+1])<br>$$<br>其中$go_x[P]$表示在位置$P$使用第$x$种覆盖能够覆盖多少建筑。于是最后复杂度$O(n^2\log n)$.</p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><blockquote><p>定义<code>string</code>类型的递推$f_0=’0’$，$f_1=’1’$，$f_i=f_{i-2}+f_{i-1}$，其中$+$表示<code>string</code>类型的连接。多组询问，询问$f_n$中区间$\rm [L,R]$内的串。$n\leq 1e9,~\rm L\leq R\leq 2e9,\sum (R-L)\leq 1e7$</p></blockquote><hr><p>拿到这题首先应该手写出前$6$项来找规律……</p><p>发现$f_i.size()$就是斐波那切数列的第$i$项，并且序号奇偶性相同的两项$f_i,f_j$，当$j&lt;i$时满足$f_j$是$f_i$的前缀，这东西可以数学归纳出来<del>并且肉眼看不出来</del>。</p><p>之后可以发现$\rm L,R\leq 2e9$，而斐波那切数列的第$50$项已经超过了这个范围。于是考虑对于一个询问$f_n[L,R]$，先把$n$缩到$50$以内，然后分奇偶性赋值为$48/49$，然后每次考虑把$f_n$分成$f_{n-2}+f_{n-1}$，分治下去。注意到其实是可以预处理一些状态来提速，于是选择预处理前$20$项左右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; f[n].substr(L, R - L + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line"><span class="keyword">if</span> (L &lt; fib[n - <span class="number">2</span>]) solve(n - <span class="number">2</span>, L, min(R, fib[n - <span class="number">2</span>])) ; </span><br><span class="line"><span class="keyword">if</span> (R &gt;= fib[n - <span class="number">2</span>]) solve(n - <span class="number">1</span>, max(<span class="number">0l</span>l, L - fib[n - <span class="number">2</span>]), R - fib[n - <span class="number">2</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><blockquote><p>我们有一张方格纸，他大概长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g7908v9b.png" alt></p><p>我们现在要从左上角$(0,0)$到右下角$(n,m)$画一条直线，然后询问它经过黑格子的长度与总长度的比值，并输出一个互质分数的形式。</p></blockquote><p>sb结论题，以下是结论，觉得证的挺好的（</p><blockquote><p>无论怎样，$rqy$太强了！！</p><p>以下是$rqy$给的严谨证明：</p><ul><li><p>对于每个二元组$(n,m)$，$(\frac{n}{\gcd(n,m)},\frac{m}{\gcd(n,m)})$ 的本质与$(n,m)$是一样的。</p></li><li><p>当$n$是偶数<strong>或者</strong>$m$是偶数的时候，答案显然是$\frac{1}{2}$，因为我们可以考虑把所有的颜色翻转，答案是一样的。</p></li><li><p>余下的情况，由于我们现在已经缩小了问题规模使得$n,m$互质，所以只有可能是$n、m$均为奇数，此时我们考虑如下（前方高能）：</p></li><li><p>由于横向有$m$段，纵向有$n$段，所以总共这条直线可以分成$n \times m$段，当然，有些段的颜色相同。我们这么做的目的是为了保证<strong>每一段不会跨过每个格子的边界，即同一段的每个部分都会是相同的颜色</strong></p></li><li><p>通过观察可以得到，对于从左上到右下的第$i$段，它应该在第$\lfloor \frac{i}{n} \rfloor$<strong>列</strong>，第$\lfloor \frac{i}{m} \rfloor$<strong>行</strong>。注意这个地方，虽然$n$表示的是行，但是$\lfloor \frac{i}{n} \rfloor$表示的是列。道理其实很简单：</p><ul><li>对于第$i$段，它占的部分是$\frac{i}{n \times m}$ ，所以所属的行应该是$\lfloor \frac{i}{n \times m} \cdot n \rfloor$，所属的列为$\lfloor \frac{i}{n \times m} \cdot m \rfloor$，约分一下答案显而易见。 </li></ul></li><li><p>基于前两条，我们会有一个比较平凡的结论：对于某一段$i$，当$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$为偶数的时候，这一段在黑色的格子上；是奇数的时候，这一段在白色格子上。</p></li><li><p>我们可以考虑对$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$搞一些事情：<br>$$<br>\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor\begin{align} \ \\&amp;\equiv\frac{i - i \mod n}{n}+\frac{i - i \mod m}{m} \pmod 2\ &amp;\equiv 2i - i \mod n - i \mod m \pmod 2\  &amp; \equiv i \mod n  + i  \mod m \pmod 2\end{align}<br>$$</p></li></ul><p>上式的目的其实就是通过对$2$取模建立同余式，由于$n,m$均为奇数，所以在$\mod 2$意义下都是$1$，可以直接除掉。那么接下来我们考虑，这样的$i$有多少个呢？很显然的，在$0 \to n - 1$中，共有$\frac {n-1}{2}$个奇数,$\frac{n+1}{2}$个偶数；在$0 \to m-1$中，共有$\frac {m-1}{2}$个奇数，$\frac {m+1}{2}$个偶数。因为只有奇偶性相同时，才属于黑色格子，所以由中国剩余定理得<br>$$<br>\begin{aligned}\sum check(i) &amp;= \frac{n-1}{2} \cdot \frac{m-1}{2} + \frac{n+1}{2} \cdot \frac{m+1}{2} \\&amp; = \frac{2nm + 2}{4}\end{aligned}<br>$$</p><p>那么最终答案就是<br>$$<br>\frac {\sum check(i)}{n \cdot m} = \frac{n \cdot m+1}{2n \cdot m}<br>$$</p></blockquote><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>给定一棵树，某些点是关键点。每条边有代价，每次可以删掉一条边并且获得这条边的代价。求最少的代价，使得所有关键点不连通。$n\leq 300,000$</p></blockquote><hr><p>直观的想法是$dp$，即记$f_x$表示处理完以$x$为根的子树内的关键点（不互相连通）的最少代价。但是发现这样似乎很难转移，因为转移时要考虑子树之间的关键点是否连通。于是考虑再记$g_x$表示处理完以$x$为根的子树内关键点互相不连通，且不与外界连通的最小代价。</p><p>那么考虑转移，记$x$为当前节点，$y$为$x$的子节点：</p><ul><li><p>当$x$为关键点时，有：<br>$$<br>\begin{align<em>}<br>f_x&amp;=\sum g_y \\<br>g_x&amp;=f_x+pre_x<br>\end{align</em>}<br>$$</p></li><li><p>当$x$不为关键点时，有<br>$$<br>f_x=\min(\sum f_y-f_{y’}+g_{y’})\\<br>g_x=\min(f_x+pre_x, \sum g_y)<br>$$</p></li></ul><p>唔，这个第二个转移的$f_x$还是需要编一编的，大概就是考虑现在只需要不让子树内部连通，那么就可以选出一棵子树来内部不连通，其他子树都不和外部连通，可知这样是最优的（因为天选之子不需要“不和外部连通”）。</p><p>学习了，学习了。</p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>现在有如下一个表达式： $0 ~a_1 b_1 a_2 b_2 … a_n b_n$。其中$a_i$为一个位运算符（$\boldsymbol{and/or/xor}$），$b_i$是一 个整数。每一对$a_i,b_i$有$c_i$的概率会消失，求表达式的结果的期望。  </p></blockquote><hr><p>需要建立某种神秘的条件反射，就是遇到位运算的题目就要想到“位与位之间是无关的”。那么就可以直接按位做，令$f_{i,0/1}$表示计算完前$i$对，现在这一位为$0/1$的概率是多少。转移时别忘了加上当前这一对被删除的概率，即$f_{i-1,0/1}$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校内模拟赛选整&lt;/p&gt;
&lt;p&gt;大概难度都是TG里面$2$~$3$左右的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="校内模拟赛" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="有趣的二分答案" scheme="http://www.orchidany.cf/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="动态规划-树形DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数学/概率,期望" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】分治在FFT上的应用</title>
    <link href="http://www.orchidany.cf/2019/08/27/fzfft-md/"/>
    <id>http://www.orchidany.cf/2019/08/27/fzfft-md/</id>
    <published>2019-08-27T09:40:53.000Z</published>
    <updated>2019-12-15T06:33:59.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是cdq分治+FFT。</p><p>分治FFT解决的问题的一般形式：</p><p>给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且<br>$$<br>f_i=\sum_{j=1}^{i} f_{i-j} g_j<br>$$<br>求$f_1,f_2\cdots f_{n-1}$</p><a id="more"></a><p>先展开观察性质<br>$$<br>\begin{aligned}f_1&amp;=g_1f_0,\\ f_2&amp;=g_1f_1+g_2f_0,<br>\\ f_3&amp;=g_1f_2+g_2f_1+g_3f_0\\ f_4&amp;=g_1f_3+g_2f_2+g_3f_1+g_4f_0=g_1^4\end{aligned}<br>$$<br>我们发现如果将整个序列分成两半，前一半对后一半的贡献是：<br>$$<br>o_p=\sum_{i=l}^{\rm{mid}}f_ig_{p-i}<br>$$<br>其中$p\in(\rm{mid},r]$，$o$是额外的贡献。</p><p>我们发现，其实这是个卷积的形式，毕竟对于普通的卷积定义是：<br>$$<br>c_i=\sum_{j\leq i} a_jb_{i-j}<br>$$<br>于是我们就可以通过分治，每次暴力NTT计算前一半对后一半的贡献，类似于cdq分治的操作，复杂度$n\log ^2n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">if</span> (!l) F[l] = <span class="number">1</span> ; <span class="keyword">return</span> ;&#125; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, L = r - l + <span class="number">1</span>, Len = <span class="number">1</span>, l1 = <span class="number">0</span> ;</span><br><span class="line">    cdqNTT(l, mid) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt;= L) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="built_in">memcpy</span> (P, G, <span class="keyword">sizeof</span>(LL) * (r - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memcpy</span> (Q, F + l, <span class="keyword">sizeof</span>(LL)*(mid - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memset</span> (P + r - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - r + l)) ;</span><br><span class="line">    <span class="built_in">memset</span> (Q + mid - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - mid + l)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>), NTT(Q, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = P[i] * Q[i] % Mod ;</span><br><span class="line">    NTT(P, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) (F[i] += P[i - l]) %= Mod ; cdqNTT(mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]) ;</span><br><span class="line">    cdqNTT(<span class="number">0</span>, N - <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, F[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，得出结论我的分治没学好qaq</p><p>但是如果换一个角度观察，设出两个形式幂级数，即令<br>$$<br>\begin{aligned}<br>\rm{F}&amp;=\sum f_ix^i\\\<br>\rm{G}&amp;=\sum g_ix^i<br>\end{aligned}<br>$$<br>然后我们把他俩卷起来，且因为F本身就是卷积的形式，即有：<br>$$<br>\begin{aligned}<br>\rm{F} *\rm{G} &amp; =\sum x^i\sum_{j\leq i} f_ig_j<br>\\\<br>&amp;= \sum x_i f_{i+1}\\\<br>&amp;= \rm{F}-f_0<br>\end{aligned}<br>$$<br>那么先移项，之后两边同时卷一个$\rm{G}-1$ 的逆就可以得到：<br>$$<br>\rm{F}= \frac{1}{1-G}<br>$$<br>于是直接求一个逆就完了，复杂度$n\log n$。</p><p>不得不说这也算是一个小技巧了qwq</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实就是cdq分治+FFT。&lt;/p&gt;
&lt;p&gt;分治FFT解决的问题的一般形式：&lt;/p&gt;
&lt;p&gt;给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且&lt;br&gt;$$&lt;br&gt;f_i=\sum_{j=1}^{i} f_{i-j} g_j&lt;br&gt;$$&lt;br&gt;求$f_1,f_2\cdots f_{n-1}$&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="分治" scheme="http://www.orchidany.cf/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="多项式的应用" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Berlekamp-Massey算法</title>
    <link href="http://www.orchidany.cf/2019/08/26/BM/"/>
    <id>http://www.orchidany.cf/2019/08/26/BM/</id>
    <published>2019-08-26T09:35:31.000Z</published>
    <updated>2019-12-16T00:12:07.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Berlekamp-Massey</strong>算法用于在$O(n^2)$的时间内求解数列的递推式。形式化地讲，给定$a_i(i=0,1,2,3…n-1)$，求一组$b_j(j=0,1,2,3…m)$，满足：<br>$$<br>\forall i\geq m, a_i=\sum _{j=0}^{m} a_{i-j}b_i<br>$$<br>其中或许会有条件限制$m$最小。</p><a id="more"></a><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>考虑现在我们已经有了一个递推式$[f]$且满足了前$k$项</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Berlekamp-Massey&lt;/strong&gt;算法用于在$O(n^2)$的时间内求解数列的递推式。形式化地讲，给定$a_i(i=0,1,2,3…n-1)$，求一组$b_j(j=0,1,2,3…m)$，满足：&lt;br&gt;$$&lt;br&gt;\forall i\geq m, a_i=\sum _{j=0}^{m} a_{i-j}b_i&lt;br&gt;$$&lt;br&gt;其中或许会有条件限制$m$最小。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Berlekamp-Massey算法" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Berlekamp-Massey%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Berlekamp-Massey" scheme="http://www.orchidany.cf/tags/Berlekamp-Massey/"/>
    
      <category term="数学/常系数齐次线性递推" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】快速沃尔什变换</title>
    <link href="http://www.orchidany.cf/2019/08/26/fwt/"/>
    <id>http://www.orchidany.cf/2019/08/26/fwt/</id>
    <published>2019-08-26T03:50:28.000Z</published>
    <updated>2019-12-15T06:34:13.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速沃尔什变换(FWT)</strong>是一种广义上的<strong>傅里叶变换</strong>，可以解决<strong>子集并卷积</strong>、<strong>子集交卷积</strong>以及<strong>子集对称差卷积</strong>。</p><p>而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决<strong>子集对称差卷积</strong>，即：<br>$$<br>c_i=\sum_{j\oplus k=i} a_jb_k<br>$$<br>其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。</p><a id="more"></a><hr><h1 id="再谈线性变换实质"><a href="#再谈线性变换实质" class="headerlink" title="再谈线性变换实质"></a>再谈线性变换实质</h1><p>首先是构造，我们考虑线性变换的本质，需要有:<br>$$<br>{\rm FWT(C)}_i={\rm FWT(B)}_i\cdot{\rm FWT(A)}_i<br>$$<br>那么一个思路就是先设一个辅助函数$\varphi(i,x)$出来：<br>$$<br>{\rm FWT(F)}_i=\sum_{j\geq 0}\varphi(j,i) \cdot f_j<br>$$<br>那么就会有：<br>$$<br>\sum_{j\geq 0}\varphi(j,i) \cdot c_j=\sum_{j\geq 0}\varphi(j,i) \cdot a_j\times \sum_{j\geq 0}\varphi(j,i) \cdot b_j<br>$$<br>然后把$c_i=\sum_{j\oplus k=i} a_jb_k$带进去并调整：<br>$$<br>\begin{aligned}<br>\sum_{j\geq 0}\varphi(j,i) \cdot \sum_{p\oplus q=j} a_pb_q &amp; =\sum_{j\geq 0}\varphi(j,i) \cdot a_j \times\sum_{j\geq 0}\varphi(j,i) \cdot b_j\\\<br>\sum_{p \geq 0} \sum_{q\geq 0}\varphi(p\oplus q,i)\cdot a_pb_q &amp; =\sum_{p\geq 0}\sum_{q\geq 0}\varphi(p,i) \cdot \varphi(q,i)\cdot a_pb_q\\\<br>\end{aligned}<br>$$<br>发现$\sum_{p\geq 0}\sum _{q\geq 0}a_pb_q$是可以消掉的，于是就有：<br>$$<br>\varphi(p\oplus q,i)=\varphi(p,i)\cdot \varphi(q,i)<br>$$</p><h1 id="构造-varphi"><a href="#构造-varphi" class="headerlink" title="构造$\varphi$"></a>构造$\varphi$</h1><p>对于异或操作来说，异或前后$1$的个数的奇偶性不会改变。即也就是说$i,j$中$1$的个数加起来和$i\oplus j$中1的个数的奇偶性是一样的。形式化地讲：</p><p>$$<br>\rm bitcount(i)+bitcount(j)\equiv bitcount(i~\oplus ~j)~(\bmod 2)<br>$$</p><p>证明：</p><p>考虑$i \oplus j$的每一位：</p><ul><li>若$i$和$j$的这一位相同，那么就会变成$0$，$1$的个数减二或不变；</li><li>如不同，那么就一定是$(xx1xx)\oplus(xx0xx)=(xx1xx)$，$1$的个数还是不变。</li></ul><p>而我们发现这个引理解决的是相加不变的问题，而我们需要的$\varphi$函数需要满足相乘不变，于是自然而然地想到要放到幂上去。</p><p>于是就定义了$\varphi$:<br>$$<br>\varphi(s,t)=(-1)^{|s\cap t|}<br>$$<br>换成数值的表示方法：<br>$$<br>\varphi(i,j)=(-1)^{\rm bitcount \mathcal{(i ~\rm{and}~ j)}}<br>$$<br>这么定义的原因是：<br>$$<br>(i \cap x) \oplus(j \cap x)=(i \oplus j) \cap x<br>$$<br>即<strong>异或对交有分配律</strong>，那么：</p><p>$$<br>{\rm{FWT(F)}}_i=\sum_{j \geq 0}(-1)^{|i\cap j|}f_j<br>$$</p><p><del>于是就喜提一个指数级算法</del></p><h1 id="真正的-rm-FWT"><a href="#真正的-rm-FWT" class="headerlink" title="真正的$\rm{FWT}$"></a>真正的$\rm{FWT}$</h1><p>我们发现似乎这东西没有办法dp，于是考虑：</p><blockquote><p>每一次考虑新加入第$i$个物品取不取的情况，将当前集合分为$i$取和$i$不取，$i$取的放右边，$i$不取的放左边。</p><p>$i$取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小$−1$。$i$不取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小同样的不变。 </p><p>这样考虑原有状态，左右两边对$i$不取的贡献都是$\text{++}$，因为集合大小不变。左边对$i$取的贡献是$+$，右边对$i$取的贡献是$\text{−−}$，因为都取$i$的话并集增加了$1$，贡献取反。</p></blockquote><p>然后其实就是个模拟的思路，由于$(1xxxxxx)_2$和$(0xxxxxx)_2$的数量是一致的，所以我们可以将小于$(1000000)_2$的分为一类，大于等于$(1000000)_2$的分为一类，从数值上看就是前一半和后一半。</p><p>总之就是个FFT🦋操作的思路啦。</p><p>然后对于逆变换，因为我们刚才的结论有：<br>$$<br>\begin{aligned}{F[j+k] =F[j+k]+F[i+j+k]} \\ {F[i+j+k]=F[j+k]-F[i+j+k]}\end{aligned}<br>$$<br>所以我们现在为了得到原来的$F[i+j+k]$和$F[j+k]$，直接<br>$$<br>\begin{array}{c}{F[j+k]=\frac{F[j+k]+F[j+i+k]}{2}} \ {F[j+i+k]=\frac{F[j+k]-F[j+i+k]}{2}}\end{array}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, m = <span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>), x, y ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                x = f[j + k], y = f[i + j + k] ;</span><br><span class="line">                f[j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + y) % Mod ;</span><br><span class="line">                f[i + j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + Mod - y) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是时间复杂度就是$n \log n$了。</p><h1 id="rm-FWT-做or-and卷积"><a href="#rm-FWT-做or-and卷积" class="headerlink" title="$\rm FWT$做or/and卷积"></a>$\rm FWT$做or/and卷积</h1><p>艹，真是被血坑了。</p><p>才发现原来FWT做or/and卷积就是跟FMT一个道理：<br>$$<br>\boldsymbol{or}: F[i+j+k]+=F[j+k]\\\<br>\boldsymbol{and}: F[j+k]+=F[i+j+k]<br>$$<br>然后逆变换就直接把加号改成减号就好了……原因就是“不取这个东西”一定是“取这个东西”的子集。</p><p>但是当时我认真学习FMT的时候，<code>Rockdu</code>博客里面FMT的代码是FWT的！！！然后再看别人的代码我就懵O了好久……</p><p>真是zz</p><p>但是终于理解了<code>JOHNKRAM</code>神仙的话：</p><p><img src="https://s2.ax1x.com/2019/08/30/mjCdF1.jpg" alt></p><p>不得不说是很形象了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>其实Lugou上的板子的复杂度是$2^n n$的，我一开始就觉得暴力枚举子集没啥问题，结果最后发现枚举子集不是枚举$(n)_2$的子集，而是枚举$(2^n)_2$的子集……白学了白学了</li><li>唉，本来就是功能相同的FWT和FMT，看错代码真是GG</li><li>其实只有对称差卷积难理解一些，交并卷积都是很形象的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;快速沃尔什变换(FWT)&lt;/strong&gt;是一种广义上的&lt;strong&gt;傅里叶变换&lt;/strong&gt;，可以解决&lt;strong&gt;子集并卷积&lt;/strong&gt;、&lt;strong&gt;子集交卷积&lt;/strong&gt;以及&lt;strong&gt;子集对称差卷积&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决&lt;strong&gt;子集对称差卷积&lt;/strong&gt;，即：&lt;br&gt;$$&lt;br&gt;c_i=\sum_{j\oplus k=i} a_jb_k&lt;br&gt;$$&lt;br&gt;其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="快速沃尔什变换(FWT)" scheme="http://www.orchidany.cf/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
  </entry>
  
</feed>
