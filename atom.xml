<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-obgUvYct" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-obgUvYct"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-04-29T12:34:46.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p><del>恭喜你来到了没有知识的荒原.</del></p><p>这篇文章已经移步到侧边栏的「<code>Navigation</code>」里啦！还不去看看？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【训练记录】6.8 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/09/6-8-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/09/6-8-训练笔记/</id>
    <published>2020-06-09T00:19:27.000Z</published>
    <updated>2020-06-09T03:50:26.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天因为补 CF 就又只打了一场。咕咕咕。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>比较传统的一道简单题。但是俩 log 被卡了= =</p><p>大概就是说考虑最大值最小，可能可以想到要去二分答案。然后考虑判定，考虑一个权值 $v$ 合法，当且仅当可以选出一个长度 $\geqslant k$ 的子序列使之和 $\leq v$ 。这个可以用 ds 维护，也可以直接贪。</p><p>感觉个人比较看不透这个贪心，换句话说你要让我写我肯定写不出来，有点反直觉。具体来说就是考虑每次将一个元素 <code>push</code> 到一个栈里，然后如果当前元素与栈顶元素之和 $\gt v$ 就不把当前元素入栈，否则如果当前元素 $\lt$ 栈顶元素就先弹栈再入栈。最后判一下头尾就好了。</p><p>感觉这么贪心的道理在于， 最后一个元素要么是序列末尾的元素，要么就是后缀中最小的那个。所以判头尾才不会锅。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: max ;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: min ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> mxv, mnv ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    tmp[cnt = <span class="number">1</span>] = base[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * tmp[cnt] + base[i] &lt;= x) tmp[++ cnt] = base[i] ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp[cnt] &gt; base[i]) tmp[cnt] = base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; k) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k &amp;&amp; <span class="number">1l</span>l * tmp[<span class="number">1</span>] + tmp[cnt] &lt;= x) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k) ;</span><br><span class="line">    <span class="keyword">int</span> l, r, mid ; mnv = M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">        mnv = min(mnv, base[i]) ;</span><br><span class="line">        mxv = max(mxv, base[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    l = mnv &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">r = mxv &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line"><span class="comment">//        printf("%d %d\n", l, r) ;</span></span><br><span class="line">        mid = (<span class="number">1l</span>l * l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">             ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p></blockquote><p>挺有意思的一道结论题…主要是(标算的)思考过程挺妙<del>，不过猜完就走人了谁还证啊。</del></p><p>大概是考虑从二分答案出发。把 $\geqslant v$ 的所有位置置为 $1$，其余位置置为 $0$ 。那么答案 $v$ 合法<strong>当且仅当存在一行的所有数都为 $1$</strong>。首先充分性不难知道，小 D 只要忽略这一行，每次删其他的，这样小 Y 由于每次只能删一列，所以最后必然是小 D 获胜。</p><p>必要性考虑归纳。$n=1$ 不难知道，然后考虑 $n=k\to n=k+1$ 。发现此时剩下了 $k$ 行 $k+1$ 列，轮到小 Y 操作，那么考虑每一行从左往右第一个 $0$，由鸽笼原理可知，必定存在一列不包含这些 $0$ 中的任意一个。所以剩下的局面就可以归纳到 $n=k$ 里面。证毕。</p><p>观察这个过程，发现其实不需要二分，每一行中最小的数，所有行中的最大值即为答案。扫一遍就完了。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>这题对我这种数位 DP 萌新很不友好…</p><p>一开始想了个暴力求 <code>count_of_1</code> 的东西，发现并不是这么算的…即发现改变的位置是 $r$ 二进制下 $1$ 的位数和 $l-1$ 二进制下 $1$ 的和，但是要减去那些改了两遍的，经过冷静找性质可以发现，这部分就是两者从高位到低位的最长公共前缀里面 $1$ 的数量乘二。</p><p>然后就考虑分别对这两个进行数位 $dp$ 。发现对于 $r\geq l$ 的限制完全可以去掉，因为容斥的时候会被直接容斥掉。那么总方案数就可以直接乘一个系数 $n$，就只需要计算「$1\sim n$ 之间所有数的二进制下 $1$ 的个数」 和 「$1\sim n$ 内所有的数对 $(l,r)$ 的 <code>count_of_1(</code>LCP<code>)</code> 」。</p><p>设  $g_{i,j,0/1}$ 表示从高到低考虑了前 $i$ 位，有 $j$ 个 $1$ ， $r$ 是否等于 $n$ 的方案数。转移时需要考虑分类讨论 $n$ 的当前位是否为 $1$ ，具体转移大概就是判断一下转移前后 $r$ 是否依旧 $=n$ 之类的。同时设 $f_{i,j,0/1,0/1}$ 表示考虑前 $i$ 位，最大公共前缀中 $1$ 的个数为 $j$，$l=r?,r=n?$ 的方案数。然后转移依旧是根据边界分类讨论当前位放 $1$ 还是 $0$，注意到由于加上了 $l,r$ 的限制，所以要分类讨论 $l,r$ 分别放不放，所以会有个系数。</p><p>然后最后答案就是</p><script type="math/tex; mode=display">ans=\left(n\times \sum g\right)-\sum f</script><p>复杂度 $O(T\log n^2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll n, m ;</span><br><span class="line">ll ans1 ;</span><br><span class="line">ll ans2 ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N][N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>][<span class="number">2</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        ans1 = ans2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g)) ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ; m = n ; cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (m) base[++ cnt] = m &amp; <span class="number">1</span>, m &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        reverse(base + <span class="number">1</span>, base + cnt + <span class="number">1</span>) ;</span><br><span class="line">        g[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j][<span class="number">0</span>], g[i][j][<span class="number">0</span>]) ;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j][<span class="number">0</span>], g[i][j][<span class="number">1</span>]) ;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>], g[i][j][<span class="number">1</span>]) ;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>], g[i][j][<span class="number">0</span>]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j][<span class="number">0</span>], g[i][j][<span class="number">0</span>]) ;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j][<span class="number">1</span>], g[i][j][<span class="number">1</span>]) ;</span><br><span class="line">                    add(g[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>], g[i][j][<span class="number">0</span>]) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">1</span>], f[i][j][<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">1</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], f[i][j][<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">1</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    </span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">1</span>], <span class="number">2l</span>l * f[i][j][<span class="number">0</span>][<span class="number">1</span>] % P) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>], <span class="number">2l</span>l * f[i][j][<span class="number">0</span>][<span class="number">1</span>] % P) ;</span><br><span class="line">                    </span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>], <span class="number">4l</span>l * f[i][j][<span class="number">0</span>][<span class="number">0</span>] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">1</span>][<span class="number">1</span>], f[i][j][<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">1</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    add(f[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], f[i][j][<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">                    </span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">1</span>], <span class="number">2l</span>l * f[i][j][<span class="number">0</span>][<span class="number">1</span>] % P) ;</span><br><span class="line">                    </span><br><span class="line">                    add(f[i + <span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>], <span class="number">4l</span>l * f[i][j][<span class="number">0</span>][<span class="number">0</span>] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            add(ans1, <span class="number">1l</span>l * i * addn(g[cnt][i][<span class="number">1</span>], g[cnt][i][<span class="number">0</span>]) % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            add(ans2, <span class="number">1l</span>l * i * addn(f[cnt][i][<span class="number">0</span>][<span class="number">1</span>], f[cnt][i][<span class="number">0</span>][<span class="number">0</span>]) % P) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; decn(<span class="number">1l</span>l * ans1 * (n % P) % P, <span class="number">2l</span>l * ans2 % P) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p><p>$1\leq n\leq 100$ 。</p><p>$1\leq X\leq 10^6$ 。</p></blockquote><p>发现变量有俩，楼的高度和楼之间的距离。发现限制之间是有关系的，于是考虑定住一个，比如楼的高度。考虑设两栋楼之间的距离是 $x_i$ ，那么要满足 $x_i\geqslant \max\{h_i,h_{i-1}\}$ 。设 </p><script type="math/tex; mode=display">s=\sum _{i=2}^n\max\{h_i,h_{i-1}\}</script><p>那么可知方案数就是</p><script type="math/tex; mode=display">\binom{X-1-s+n}{n}</script><p>这就是一个 $n+1$ 元一次不定方程组的问题。这个地方涉及到一个技巧。就是考虑首先值域是 $[1,X]$ ，所以取值有 $X-1$ 个。其次由于要求总和 $\leqslant X$，那么可以考虑多设出一个变量用来保存余出去的 $X-s$，所以就是 $n+1$ 个元素。</p><p>然后就是考虑对 $s$ 进行 dp。具体的，设 $f_{i,j,k}$ 表示现在考虑了 $1\sim i$ 的排列，还有 $j$ 个位置没有闭合，即还有 $j$ 个位置可能还会插入更大的数，当前 $s$ 值为 $k$ 的方案数。然后考虑每次相当于选一个位置插入一个 $i$ ，此时会产生两个新的空位，然后分类讨论一波闭合不闭合就好了。注意到如果插入开头或者结尾，那么就只会产生 $1$ 个空位，特判一下这个边界就好了。最后复杂度 $O(n^4+X)$ 。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][M][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> mx)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ; ans = res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mx + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[mx + <span class="number">1</span>] = expow(fac[mx + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = <span class="number">1l</span>l * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; P ; <span class="keyword">int</span> t ;</span><br><span class="line">    prework(m) ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">t = i * i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= t ; ++ k) f[d ^ <span class="number">1</span>][j][k] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (j)&#123;</span><br><span class="line"><span class="keyword">int</span> p = j + <span class="number">1</span>, q = j + <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= t ; ++ k)&#123;</span><br><span class="line">                add(f[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k + (i + <span class="number">1</span>) * <span class="number">2</span>], <span class="number">1l</span>l * j * f[d][j][k] % P) ;</span><br><span class="line">               add(f[d ^ <span class="number">1</span>][j][k + i + <span class="number">1</span>], <span class="number">2l</span>l * p * f[d][j][k] % P) ;</span><br><span class="line">                add(f[d ^ <span class="number">1</span>][j + <span class="number">1</span>][k], <span class="number">1l</span>l * q * f[d][j][k] % P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> p = j + <span class="number">1</span>, q = j + <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= t ; ++ k)&#123;</span><br><span class="line">               add(f[d ^ <span class="number">1</span>][j][k + i + <span class="number">1</span>], <span class="number">2l</span>l * p * f[d][j][k] % P) ;</span><br><span class="line">                add(f[d ^ <span class="number">1</span>][j + <span class="number">1</span>][k], <span class="number">1l</span>l * q * f[d][j][k] % P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        d ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        add(ans, <span class="number">1l</span>l * f[!(n &amp; <span class="number">1</span>)][<span class="number">0</span>][i] * binom(m - i + n - <span class="number">1</span>, n) % P) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天因为补 CF 就又只打了一场。咕咕咕。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="动态规划/数位DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>【训练记录】6.5 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/09/6-5-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/09/6-5-训练笔记/</id>
    <published>2020-06-09T00:19:13.000Z</published>
    <updated>2020-06-09T05:57:07.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啦啦啦啦</p><a id="more"></a><h1 id="A-M"><a href="#A-M" class="headerlink" title="A.M."></a>A.M.</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>简单题。</p><p>大概是说如果连上了两条边，那么这条边连接的两个点就可以直接合并起来。考虑为了保证复杂度，需要进行启发式合并。于是就可以拿一个 <code>set</code> 维护，但这样会多一个 log。考虑直接拿 <code>vector</code> 维护，对每个点设一个 <code>vis</code> 就不需要删除了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; s[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void merge(int x, int y)&#123;</span></span><br><span class="line"><span class="comment">    int f1 = find(x) ;</span></span><br><span class="line"><span class="comment">    int f2 = find(y) ;</span></span><br><span class="line"><span class="comment">    if (f1 != f2)</span></span><br><span class="line"><span class="comment">        fa[f1] = f2 ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        x = qr(), y = qr(), s[x].p_b(y), s[y].p_b(x) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        x = find(qr()) ;</span><br><span class="line">y = find(qr()) ;</span><br><span class="line">        <span class="keyword">if</span> (x == y)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> z : s[x])</span><br><span class="line"><span class="keyword">if</span> (z == y) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'1'</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (s[x].size() &gt; s[y].size())</span><br><span class="line">            swap(x, y) ; fa[x] = y ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> z : s[x])</span><br><span class="line">            <span class="keyword">if</span> (!vis[z]) s[z].p_b(y), s[y].p_b(z) ;</span><br><span class="line">      <span class="keyword">continue</span> ;</span><br><span class="line">        fuck : <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>简单题。</p><p>考虑一个性质，大概就是说剩下没有连起来的弦，不相交一定是最优的。于是就可以直接 dp 了。设 $f_{i,j}$ 表示考虑 $[i,j]$ 之间还没连的点，最小代价是多少。转移就考虑枚举一个 $[i,j]$ 之间和 $i$ 相连的点即可。注意到这样就需要 $[i,j]$ 里没有配对的点为偶数。</p><p>然后考虑方案数 $g_{i,j}$，就只需要在维护 $f_{i,j}$ 时顺便计数一下就好了。复杂度 $O(n^3)$ 。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>比较神奇的题目…</p><blockquote><p>给定一个插入序列。编号为 $i$ 的元素有一个颜色 $col_i$ 和一个阈值 $a_i$。插入 $i$ 的时候，$i$ 应当放到满足以下条件的最靠前的位置 $p$：</p><p>1、当前位于 $p$ 或者 $p+1$ 的元素颜色与 $col_i$ 相同。</p><p>2、不能有超过 $a_i$ 个元素因此而后移。</p><p>求最终插入全部元素后每个位置的元素编号。$1\leq n\leq 3\times 10^5$ 。</p></blockquote><p>那必然是先莽一个 $50pts$ 的 <code>vector</code> 暴力<del>然后就 250 滚粗了</del> 。</p><p>大概是考虑如果知道了每个元素在当时插入完毕后在第几位，即 $rank_i$ ，就可以直接线段树二分出最后实际的 rank。具体的，考虑把数从后往前插入线段树，这样每次就需要从线段树中二分出第一个位置 $p$ 使得 $p-sum_p=rank_i$ ，其中 $sum_p$ 是前缀和。不难知道这样做是对的。</p><p>之后考虑怎么求出 $rank_i$ 。这个地方有个十分深刻的性质，大概是说考虑如果有多个相邻颜色的元素放在相邻的位置，那么我们并不关心靠后的那些元素，可以直接合并，因为边界比较好处理，并且这样转化之后就只会出现在后面插入新的元素，可以直接 <code>push_back</code>。那么现在如果要插入一个元素，那么可以先找到这个元素不考虑颜色时最少应该放在的位置 $p$，然后去对应颜色的 <code>vector</code> 里二分即可。这样每次插入就可以换成在线段树上进行单点加。注意可能存在一个颜色的连续段跨过 $p$ 的情况，判一下边界就好了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123; x = y &gt; x ? y : x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line">vint col[N] ;</span><br><span class="line"><span class="keyword">int</span> org_rk[N] ;</span><br><span class="line"><span class="keyword">int</span> seg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(seg[rt] += v) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) upd(lc, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> upd(rc, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    seg[rt] = seg[lc] + seg[rc] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (seg[lc] &gt;= p) <span class="keyword">return</span> fd(lc, l, mid, p) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fd(rc, mid + <span class="number">1</span>, r, p - seg[lc]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> seg[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> qry(lc, l, mid, p) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> seg[lc] + qry(rc, mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ;</span><br><span class="line">    <span class="keyword">int</span> x, y, z, o, p, q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        qr(x), qr(y) ; </span><br><span class="line">z = fd(<span class="number">1</span>, <span class="number">0</span>, n, i - y - <span class="number">1</span>) ;</span><br><span class="line">        o = lower_bound(col[x]._bg(), col[x]._ed(), z) - col[x]._bg() ;</span><br><span class="line">        <span class="keyword">if</span> (o == col[x].size()) col[x].p_b(++ m) ; o = col[x][o] ;</span><br><span class="line">        org_rk[i] = qry(<span class="number">1</span>, <span class="number">0</span>, n, o - <span class="number">1</span>) + <span class="number">1</span> ;</span><br><span class="line">        chkmax(org_rk[i], i - y) ;</span><br><span class="line">        upd(<span class="number">1</span>, <span class="number">0</span>, n, o, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n * <span class="number">3</span> ; ++ i) seg[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) upd(<span class="number">1</span>, <span class="number">1</span>, n, i, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        p = fd(<span class="number">1</span>, <span class="number">1</span>, n, org_rk[i]) ;</span><br><span class="line">        ans[p] = i ; upd(<span class="number">1</span>, <span class="number">1</span>, n, p, <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">qwa(ans + <span class="number">1</span>, n, <span class="string">' '</span>, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>233</p><h1 id="P-M"><a href="#P-M" class="headerlink" title="P.M."></a>P.M.</h1><p>下午的题比较水…</p><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p></blockquote><p>简单题。</p><p>一开始的想法就是把棋盘转个 $45°$ 可能会比较好做。后来发现完全可以直接记一下对角线的编号。之后就考虑先算副对角线，然后算主对角线。这样的话，算主对角线时就需要对与所有副对角线的交点的贡献进行容斥，但是发现和一条主对角线的副对角线编号是连续的，就比较好算。</p><p>细节在于，要考虑编号奇偶性，因为经过 $(1,2),(2,1)$ 的对角线和经过 $(1,1),(2,2)$ 的对角线虽然相交，但是交点不是整点。然后对奇偶编号分别拿个桶维护就好了。复杂度 $O(n+m)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n), qr(m) ; <span class="keyword">int</span> z = <span class="number">3</span> * n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(base[i].fr), qr(base[i].sc) ;</span><br><span class="line">        vis0[base[i].fr + base[i].sc - <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        vis1[n - base[i].sc + base[i].fr] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        ans += vis0[i] * (n - <span class="built_in">abs</span>(n - i)) ;</span><br><span class="line">        buc1[i] = buc1[i - <span class="number">1</span>] + (i &amp; <span class="number">1</span>) * vis0[i] ;</span><br><span class="line">        buc0[i] = buc0[i - <span class="number">1</span>] + (!(i &amp; <span class="number">1</span>)) * vis0[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis1[i])</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            ans += n - <span class="built_in">abs</span>(n - i) ;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">             ans -= buc1[i + n - <span class="number">1</span>] - buc1[n - i] ;</span><br><span class="line">        <span class="keyword">else</span> ans -= buc0[i + n - <span class="number">1</span>] - buc0[n - i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis1[i])</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">        ans += n - <span class="built_in">abs</span>(n - i) ;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">             ans -= buc1[z - i - <span class="number">1</span>] - buc1[i - n] ;</span><br><span class="line">        <span class="keyword">else</span> ans -= buc0[z - i - <span class="number">1</span>] - buc0[i - n] ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis1[i])</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">        ans += n - <span class="built_in">abs</span>(n - i) ;</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; <span class="number">1</span>))</span><br><span class="line">             ans -= buc1[i + n - <span class="number">1</span>] - buc1[n - i] ;</span><br><span class="line">        <span class="keyword">else</span> ans -= buc0[i + n - <span class="number">1</span>] - buc0[n - i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis1[i])</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">        ans += n - <span class="built_in">abs</span>(n - i) ;</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; <span class="number">1</span>))</span><br><span class="line">             ans -= buc1[z - i - <span class="number">1</span>] - buc1[i - n] ;</span><br><span class="line">        <span class="keyword">else</span> ans -= buc0[z - i - <span class="number">1</span>] - buc0[i - n] ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qw(ans, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>比较简单的分类讨论题。</p><p>一开始读错题了，以为每个点的编号都必须是 $1\sim n$ …后来发现只要 $\lt 10^6$ 就好了。然后如果是 $\lt n$ 也不是没有办法，只是只能做小一点，大概就是考虑显然只需要管那些 $\deg_x$ 是奇数的 $x$ ，然后相当于从这些里面选择恰好 $k$ 个可以改变编号的元素使之异或和等于一个定值 $c$ 。这显然是可以 $n^3$ dp 的。</p><p>然后考虑正常版本，$\lt 10^6$ 的。考虑这样的话权值一定程度上就可以 xjb 找。具体的，把可以修改权值并且度数不为偶数的节点称作 pks 点，那么分类讨论一下 pks 点的数量(0/1/2/2+)，特判一些不合法的情况就好了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> col[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> able[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qw(ans[i], <span class="string">' '</span>) ; <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    qr(n) ; res = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qr(col[i]), ans[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        qr(x), qr(y), res ^= x ^ y ;</span><br><span class="line">        deg[x] ^= <span class="number">1</span>, deg[y] ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res) <span class="keyword">return</span> out_put() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (col[i] &amp;&amp; deg[i]) able[++ cnt] = i ;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        x = able[<span class="number">1</span>] ;</span><br><span class="line">        y = res ^ x ; ans[x] = y ;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[y])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">            ans[y] = MAXV ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out_put() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        z = <span class="number">0</span> ;</span><br><span class="line">        x = able[++ z] ;</span><br><span class="line">        y = able[++ z] ;</span><br><span class="line">        <span class="keyword">if</span> (res == (x ^ y))&#123;</span><br><span class="line">            <span class="keyword">if</span> (z == cnt)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">else</span> y = able[++ z] ;</span><br><span class="line">        &#125;</span><br><span class="line">        z = x ^ y ^ res ;</span><br><span class="line">        ans[x] = MAXV ; ans[y] = MAXV ^ z ;</span><br><span class="line">        <span class="keyword">return</span> out_put() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><blockquote><p>给定一个序列，支持如下两个操作：</p><p>1、单点修改。</p><p>2、给出一个 $x_i$ 。全局查询有多少个极长的连续段，满足连续段内的数都 $\geqslant x_i$ </p><p>$5\times 10^5$  。</p></blockquote><p>感觉是比较经典的思路。考虑连续段可以看做连通块，更进一步是一棵树，那么就会有 $s$ 个点和 $s-1$ 条边。于是考虑所有连通块里点的数量之和减去边的数量之和就是连通块个数，接下来就可以分别维护「有多少个 $a_i\geqslant x$ 」和有多少个「 $\min\{a_i,a_{i-1}\}\geqslant x$」。树状数组维护一波就好了。需要离散化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> _b[N], v_max ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; p &lt;= v_max ; p += low(p)) _b[p] += v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _b[p] ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;_b1, _b2 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, q ;</span><br><span class="line"><span class="keyword">int</span> v[N] ;</span><br><span class="line"><span class="keyword">int</span> qm[N] ;</span><br><span class="line"><span class="keyword">int</span> qp[N] ;</span><br><span class="line"><span class="keyword">int</span> qv[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ; <span class="keyword">int</span> p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        v[++ cnt] = base[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        qm[i] = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (qm[i] == <span class="number">1</span>) v[++ cnt] = qv[i] = qr() ;</span><br><span class="line">        <span class="keyword">else</span> qp[i] = qr(), v[++ cnt] = qv[i] = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>) ;</span><br><span class="line">    cnt = unique(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>) - (v + <span class="number">1</span>) ;</span><br><span class="line">    _b1.v_max = _b2.v_max = cnt ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i] = lwb(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, base[i]) - v ;</span><br><span class="line">        _b1.ins(base[i], <span class="number">1</span>) ; <span class="keyword">if</span> (i &gt; <span class="number">1</span>) _b2.ins(min(base[i], base[i - <span class="number">1</span>]), <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//    debug(_b1.qry(_b1.v_max)) ;</span></span><br><span class="line"><span class="comment">//    debug(_b2.qry(_b1.v_max)) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        qv[i] = lwb(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, qv[i]) - v ;</span><br><span class="line"><span class="comment">//        debug(qv[i]) ;</span></span><br><span class="line">        <span class="keyword">if</span> (qm[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (n - _b1.qry(qv[i] - <span class="number">1</span>)) - (n - <span class="number">1</span> - _b2.qry(qv[i] - <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = qp[i] ;</span><br><span class="line">            _b1.ins(qv[i], <span class="number">1</span>) ;</span><br><span class="line">            _b1.ins(base[p], <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; n) _b2.ins(min(qv[i], base[p + <span class="number">1</span>]), <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (p &gt; <span class="number">1</span>) _b2.ins(min(qv[i], base[p - <span class="number">1</span>]), <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; n) _b2.ins(min(base[p], base[p + <span class="number">1</span>]), <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (p &gt; <span class="number">1</span>) _b2.ins(min(base[p], base[p - <span class="number">1</span>]), <span class="number">-1</span>) ;</span><br><span class="line">            base[p] = qv[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下午完完全全就是在划水啊！？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啦啦啦啦&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="技巧/对应与转化" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%AF%B9%E5%BA%94%E4%B8%8E%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF Round#474(Combined) A~G] 题解</title>
    <link href="https://www.orchidany.cn/2020/06/08/CF-474-Combined/"/>
    <id>https://www.orchidany.cn/2020/06/08/CF-474-Combined/</id>
    <published>2020-06-08T12:59:49.000Z</published>
    <updated>2020-06-09T00:08:55.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感觉这场的题目质量还是不错的？确实比以前 vp 过的几场 (Div1+Div2) 要好很多。</p><p>大概是把除了 H 之外一整场的题目都做掉了。有些不是十分必要写的题目当然就是口胡啦。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>秒了。</p><p>人口普查题。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>有两个长度均为 $n$ 的序列 $a,b$，定义 ${\rm cost}(a,b)$ ：</p><script type="math/tex; mode=display">{\rm cost}(a,b)=\sum_{i=1}^{n}\left(a_{i}-b_{i}\right)^{2}</script><p>现在必须<strong>恰好</strong>对 $a$ 进行 $k_1$ 次操作，对 $b$ 进行 $k_2$ 次操作。操作内容是将某一项加一或者减一。求操作后的最小 $\rm cost$。</p><p>$1\leq n\leq 2000$。</p></blockquote><p>秒了。</p><p>降智贪心？不知道为什么就想了一会儿，发现 $n=2000$ 之后就秒掉了= = </p><p>大概是考虑分类讨论现在操作是让两个数列尽量靠近还是尽量远离。第一种情况每次操作前找到可以使 $\Delta$ 变小最多的，第二种找到让 $\Delta$ 变大最小的就可以了。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>皮卡丘和他排成一列。他在纸上写下了数组的所有非空子序列。同时他删除了所有的「子序列的最大元素-子序列的最小元素 $\geq d$」的子序列，最终剩下 $X$ 个子序列。现在给出 $X,d$ ，构造一个合法的原序列。</p><p>输出数组中的元素数不应大于 $10^4$，数值大小不应超过 $10^{18}$ 。保证 $1\leq X,d\leq 10^9$ 。</p></blockquote><p>秒了。</p><p>比较 naive 的一道构造题。大概就是考虑长度为 $n$ 的序列会产生 $2^n-1$ 个子序列，那么考虑直接对 $X$ 进行二进制拆分，之后就是一段 $1$ 一个 $d+1$ 的形式构造就完了。</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>给出一颗无限层的满二叉树。 如果 $x$ 是根，孩子的值是 $2\times x$，右孩子的值是 $2\times x+1$ 。</p><p>现在有三种操作：</p><p>$(1,x,k)$ ：将 $x$ 所在层的所有节点整体向右循环地移动 $k$ 个单位。</p><p>$(2,x,k)$ ：将 $x$ 所在的层的所有节点<strong>及其子树</strong>向右循环地移动 k 个单位。</p><p>$(3,x)$ ：输出从 $x$ 到根的路径。</p><p>$1\leq x,k,\leq 10^{18}$ 。 </p></blockquote><p>比较麻烦的找性质+模拟题，但还是秒了。<del>但是由于各种细节实现上花了好久</del></p><p>一开始的想法就是，对操作 $(1)$ 的每一层打反向的标记，然后向上跳的时候遇到这一层反向跳一下，第二个操作打另一种正向的标记就好了。写了半天才写出来，这里说几个小细节：</p><p>1、两个操作的标记都打在当前层而不是上一层。但是两个标记释放的时刻不同。第二个标记每次要在跳之前下传当前层的，而第一个标记要在跳之后下传下一层的。原因是第一个标记是整体有效的，第二个标记是暂时有效的。</p><p>2、第一个标记在输出之后要清除。</p><p>3、注意到操作 $(1)$ 标记反向是因为跳的时候要走相对位移。但是如果一开始起点时存在标记，这个标记的作用应该是正向的。判一下即可。</p><p>4、<code>&lt;cmath&gt; log2()</code> 贼慢，甚至比手写的还要慢…</p><p>于是最后就做到了 <code>log_2</code> 外线性。迄今为止是 Codeforces 全站最快的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line">ll buc1[<span class="number">70</span>] ;</span><br><span class="line">ll buc2[<span class="number">70</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">i_lg2</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">32</span>) m |= <span class="number">32</span>, n &gt;&gt;= <span class="number">32</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">16</span>) m |= <span class="number">16</span>, n &gt;&gt;= <span class="number">16</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">8</span>) m |= <span class="number">8</span>, n &gt;&gt;= <span class="number">8</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">4</span>) m |= <span class="number">4</span>, n &gt;&gt;= <span class="number">4</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">2</span>) m |= <span class="number">2</span>, n &gt;&gt;= <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;&gt; <span class="number">1</span>) m |= <span class="number">1</span>, n &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> m ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(T) ; <span class="keyword">int</span> p ;</span><br><span class="line">    ll x, y, z, s, t, yf ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        qr(x), qr(y) ;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">            y = i_lg2(y), qr(z), buc1[y] -= z ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">            y = i_lg2(y), qr(z), buc2[y] += z ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            qw(y, <span class="string">' '</span>) ;</span><br><span class="line">            p = i_lg2(y) ;</span><br><span class="line">            z = <span class="number">1l</span>l &lt;&lt; p ;</span><br><span class="line">            s = (z &lt;&lt; <span class="number">1</span>) - <span class="number">1</span> ;</span><br><span class="line">            t = - buc1[p] &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">                t = (t + z) &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">            x = y + t ;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; s)</span><br><span class="line">                x = (x &amp; s) + z ;</span><br><span class="line">            y = x ;</span><br><span class="line">            <span class="keyword">while</span> (p &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                s = (z &lt;&lt; <span class="number">1</span>) - <span class="number">1</span> ;</span><br><span class="line">t = buc2[p] &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">                    t = (t + z) &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">                x = y + t ;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; s)</span><br><span class="line">                    x = (x &amp; s) + z ;</span><br><span class="line">                y = x ;</span><br><span class="line">                </span><br><span class="line">                -- p ;</span><br><span class="line">                s = z - <span class="number">1</span> ;</span><br><span class="line">                z = z &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                y = y &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                t = buc1[p] &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">                    t = (t + z) &amp; (z - <span class="number">1</span>) ;</span><br><span class="line">                x = y + t ;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; s)</span><br><span class="line">                    x = (x &amp; s) + z ;</span><br><span class="line">                yf = y ; y = x ;</span><br><span class="line">                qw(y, <span class="string">' '</span>), y = yf ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给定一棵带点权的树，求所有有向路径的权值和。</p><p>一条有向路径的权值如下定义： </p><p>设这条路径依次经过的点的权值分别为 $a_1, a_2, …, a_k$。</p><p>则路径的权值为 $a_1\times (-1)^2+a_2\times (-1)^3+…+a_n\times (-1)^{(n+1)}$。</p><p>答案对 $10^9+7$ 取模。</p></blockquote><p>秒了。<del>指想出来但写了一年</del></p><p>然后一眼就是点分…不过好像比较麻烦的样子。</p><p>或者考虑直接树形 $dp$ 。就只需要统计出每个点在多少条路径上是奇数位置，多少条路径上是偶数位置。这个可以用比较 trivial 的 up_and_down 技巧来做。具体的，考虑对于奇偶位置分别维护三个信息，$f,g,h$ 分别表示「起点在子树外、终点在子树内」、「起点在子树内，终点在子树外」、「起点在子树内，终点在子树内」三种信息，其中第三种依赖于第二种，第一种需要第二种进行 up_and_down 。这样就可以结合子树 $size$ 直接算出贡献来了。</p><p>有小细节需要注意。就是 $f_x,g_x$ 在处理奇数的时候需要判一下 $x$ 的边界。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span> :: <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll f[N][<span class="number">3</span>] ;</span><br><span class="line">ll g[N][<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, ll y, <span class="keyword">int</span> mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dec</span><span class="params">(T &amp;x, ll y, <span class="keyword">int</span> mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; x = x &lt; <span class="number">0</span> ? x + mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = size[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(y, x) ; size[x] += size[y] ;</span><br><span class="line">        f[x][<span class="number">0</span>] += g[y][<span class="number">0</span>] ; g[x][<span class="number">0</span>] += f[y][<span class="number">0</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        add(f[x][<span class="number">2</span>], (size[x] - size[y] - <span class="number">1</span>) * g[y][<span class="number">0</span>] % P) ;</span><br><span class="line">        add(g[x][<span class="number">2</span>], (size[x] - size[y] - <span class="number">1</span>) * f[y][<span class="number">0</span>] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        f[y][<span class="number">1</span>] = g[x][<span class="number">1</span>] ;</span><br><span class="line">        g[y][<span class="number">1</span>] = f[x][<span class="number">1</span>] ;</span><br><span class="line">        f[y][<span class="number">1</span>] += (g[x][<span class="number">0</span>] - f[y][<span class="number">0</span>]) ;</span><br><span class="line">        g[y][<span class="number">1</span>] += (f[x][<span class="number">0</span>] - g[y][<span class="number">0</span>]) ;</span><br><span class="line">        dfs2(y, x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span> ; x &lt;= n ; ++ x)&#123;</span><br><span class="line">        add(ans, f[x][<span class="number">2</span>] * base[x] % P) ;</span><br><span class="line">        dec(ans, g[x][<span class="number">2</span>] * base[x] % P) ;</span><br><span class="line">        dec(ans, base[x]) ;</span><br><span class="line"><span class="comment">//        printf("%lld\n", ans) ;</span></span><br><span class="line">        add(ans, (f[x][<span class="number">1</span>] + <span class="number">1</span>) * size[x] % P * base[x] % P) ;</span><br><span class="line"><span class="comment">//        printf("%lld\n", ans) ;</span></span><br><span class="line">        add(ans, f[x][<span class="number">0</span>] * (n - size[x] + <span class="number">1</span>) % P * base[x] % P) ;</span><br><span class="line"><span class="comment">//        printf("%lld\n", ans) ;</span></span><br><span class="line">        dec(ans, g[x][<span class="number">1</span>] * size[x] % P * base[x] % P) ;</span><br><span class="line"><span class="comment">//        printf("%lld\n", ans) ;</span></span><br><span class="line">        dec(ans, g[x][<span class="number">0</span>] * (n - size[x] + <span class="number">1</span>) % P * base[x] % P) ;</span><br><span class="line"><span class="comment">//        printf("%lld\n", ans) ; puts("-----------") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), E[x].p_b(y), E[y].p_b(x) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs2(<span class="number">1</span>, <span class="number">0</span>) ; solve() ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans % P) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote><p>给定 $n$ 个点 $m$ 条边的有向图，可能不连通，可能有重边，也可能会有自环。求最长的路径(可以经过重复节点)，使得这条路径的编号和权值都<strong>严格</strong>单调递增，其中编号指输入的顺序。</p><p>$1\leq n,m\leq 10^5$ 。</p></blockquote><p>比较巧的一道题。考虑这题本质其实是一个有向图上边的 LIS。对每个 $x$ 维护一个 <code>map</code> （或者动态开点线段树），存入边权值为 $v$ 时的最长递增路径。考虑每次加进来一条边 $(u,v,w)$，答案就是从 $u$ 的 map 里找出最大的小于 $w$ 的值，根据单调性可知这一定是小于 $w$ 的那个最大值。然后暴力改就好了。不难知道这样做每条边至多被加一次、删一次，复杂度是 $O(m\log n)$ 。</p><p>思考了一下，这本质上就是一个 DP。设 $f_k$ 为最后一条边为第 $k$ 条边的最大值，那么转移就是从以边 $k$ 始点为终点的所有路径里选出一个来转移。其实如果考虑到 DP 的话，就变成一道中规中矩的题目了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: <span class="built_in">map</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span> :: lower_bound ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> en end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> be begin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbd lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, ll&gt; lis[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">auto</span> p = lis[x].lbd(v) ;</span><br><span class="line">    ret = (p == lis[x].be()) ? <span class="number">0</span> : ((-- p) -&gt; second) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) ; <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z) ;</span><br><span class="line">        res = search(x, z) ; ++ res ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; search(y, z))&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = lis[y].lbd(z) ; lis[y][z] = res ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> q = p ; q != lis[y].en() ; )&#123;</span><br><span class="line">                <span class="keyword">if</span> ((q -&gt; second) &gt; res) <span class="keyword">break</span> ; q = lis[y].erase(q) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">std</span> :: max(ans, res) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><blockquote><p>给你三个正整数 $n$，$a$，$b$，定义 $A$ 为一个排列中是前缀最大值的数的个数，定义 $B$ 为一个排列中是后缀最大值的数的个数，求长度为 $n$ 的排列中满足 $A = a$ 且 $B = b$ 的排列个数。</p><p>$1\le n \le 10^5$ 。答案对 $998,244,353$ 取模。</p></blockquote><p>感觉这题暴力的话本身也是一个比较有趣的计数题了。自己一开始设的状态是 $f_{i,j,k}$ 表示考虑了 $1\sim i$ 的排列，前缀最大值个数为 $j$，后缀最大值个数为 $k$ 时方案数，但是发现无论是插入最大值还是插入最小值都不是很容易转移。</p><p>但是发现如果确定了最大值在哪里，最后的答案就会比较容易计算。具体的，设 $f_{i,j}$ 表示考虑了 $1\sim i$ 的排列，前缀最大值个数为 $j$ 的方案数。那么最后答案就是</p><script type="math/tex; mode=display">\sum_{i=1}^{n-1} \dbinom{n-1}{i}\times f_{i,a-1}\times f_{n-i-1,b-1}\qquad(1)</script><p>然后考虑 $f$ 怎么算，因为最大值会直接影响前缀最大值的个数，所以转移考虑插入最小值。</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j-1}+(i-1)\times f_{i-1,j}</script><p>分别对应了插在第一位和插在中间或者末尾。</p><p>不难看出 $\{f\}$ 就是 $\begin{bmatrix} n \ k \end{bmatrix} $ 。然后如果直接暴力的话是 $O(n^2)$ 的。</p><p>考虑直接从 $(1)$ 式的组合意义出发计算贡献。发现对于后面两项第一维的指标和是一定的，换句话说后面两项可以看做就是在 $n-1$ 里找出了 $a+b-2$ 个圈来。前面的那个二项式系数就可以看做是对选取的一个组合系数。那么可以知道最后答案就应该是</p><script type="math/tex; mode=display">\begin{bmatrix} n-1 \\ a+b-2 \end{bmatrix}\times \binom{a+b-2}{a-1}</script><p>于是就转化成如何快速求斯特林数某一项的问题了。但是这个并没有什么快速的做法…于是就只能求出一整行。</p><p>这还是我第一次写 $s_1$ 求一行。大概是说有恒等式</p><script type="math/tex; mode=display">\sum _{k=0}^{n-1} \begin{bmatrix} n \\ k \end{bmatrix} =x^{\bar{n}}=\prod_{i=0}^{n-1} (x-i)</script><p>后面那个单项式显然是可以分治做的。于是最后复杂度 $n\log ^2n$ 。</p><p>不过这东西是有单 $\log$ 的倍增做法的。不过感觉一般这种题也没有卡 $\log ^2$ 的意向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">    <span class="keyword">int</span> k, d ;</span><br><span class="line">    <span class="keyword">int</span> rev[N] ;</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">20</span>][N] ;</span><br><span class="line">    <span class="function">ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = ret * x % P ;</span><br><span class="line">            x = x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_rt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">19</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span>* r = g[i], ut ; r[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            ut = r[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) r[j] = (ll)r[j - <span class="number">1</span>] * ut % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(T *f, <span class="keyword">int</span> L, <span class="keyword">bool</span> mk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ l)&#123;</span><br><span class="line">            <span class="keyword">int</span> *r = g[l], o = i &lt;&lt; <span class="number">1</span>, rt, irt ;</span><br><span class="line">            <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += o)</span><br><span class="line">                <span class="keyword">for</span> (rg <span class="keyword">int</span> k = j ; k &lt; i + j ; ++ k)&#123;</span><br><span class="line">                    rt = f[k], irt = f[k + i] * r[k - j] % P ;</span><br><span class="line">                    f[k] = addn(rt, irt), f[k + i] = decn(rt, irt) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mk) <span class="keyword">return</span> ;</span><br><span class="line">        reverse(f + <span class="number">1</span>, f + L) ;</span><br><span class="line">        <span class="keyword">int</span> o = expow(L, P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) (f[i] *= o) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        d = <span class="number">1</span>, k = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (d &lt;= x) d &lt;&lt;= <span class="number">1</span>, ++ k ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (k - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tl[N] ;</span><br><span class="line">    ll tr[N] ;</span><br><span class="line">    <span class="keyword">int</span> len[N * <span class="number">3</span>] ;</span><br><span class="line">    vll poly[N * <span class="number">3</span>] ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            len[rt] = <span class="number">1</span> ;</span><br><span class="line">            poly[rt].p_b(<span class="number">1</span>) ;</span><br><span class="line">            poly[rt].p_b(l) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        cdq(lc, l, mid) ;</span><br><span class="line">        cdq(rc, mid + <span class="number">1</span>, r) ;</span><br><span class="line">        getlen(len[rt] = len[lc] + len[rc]) ;</span><br><span class="line"><span class="built_in">memset</span>(tl + len[lc] + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len[lc])) ;</span><br><span class="line"><span class="built_in">memset</span>(tr + len[rc] + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len[rc])) ;</span><br><span class="line"><span class="comment">//        for (int i = len[lc] + 1 ; i &lt;= d ; ++ i) tl[i] = 0 ;</span></span><br><span class="line"><span class="comment">//        for (int i = len[rc] + 1 ; i &lt;= d ; ++ i) tr[i] = 0 ;</span></span><br><span class="line">rg <span class="keyword">auto</span> lp = poly[lc].begin(), rp = poly[rc].begin() ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= len[lc] ; ++ i) tl[i] = *(lp ++) ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= len[rc] ; ++ i) tr[i] = *(rp ++) ;</span><br><span class="line">        NTT(tl, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= d ; ++ i) (tl[i] *= tr[i]) %= P ;</span><br><span class="line">        NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= len[rt] ; ++ i) poly[rt].p_b(tl[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> a, b ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll inv[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> mx)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mx + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[mx + <span class="number">1</span>] = Poly :: expow(fac[mx + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gi(n) ; gi(a) ; gi(b) ; prework(n &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123; print(a &amp; b) ; <span class="keyword">return</span> <span class="number">0</span> ; &#125;  </span><br><span class="line"><span class="keyword">if</span> (!a || !b || a + b - <span class="number">1</span> &gt; n) &#123; pc(<span class="string">'0'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; &#125;</span><br><span class="line">    </span><br><span class="line">Poly :: pre_rt() ; Poly :: cdq(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">2</span>) ;</span><br><span class="line">    reverse(Poly :: poly[<span class="number">1</span>].begin(), Poly :: poly[<span class="number">1</span>].end()) ;</span><br><span class="line">    ans = Poly :: poly[<span class="number">1</span>][a + b - <span class="number">2</span>] * binom(a + b - <span class="number">2</span>, a - <span class="number">1</span>) % P ;</span><br><span class="line">    print(ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉这场的题目质量还是不错的？确实比以前 vp 过的几场 (Div1+Div2) 要好很多。&lt;/p&gt;
&lt;p&gt;大概是把除了 H 之外一整场的题目都做掉了。有些不是十分必要写的题目当然就是口胡啦。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="组合计数/斯特林数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
      <category term="数据结构/数据结构方法/轻重链剖分" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%BD%BB%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【训练记录】6.4 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/05/6-4-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/05/6-4-训练笔记/</id>
    <published>2020-06-04T23:49:54.000Z</published>
    <updated>2020-06-05T06:07:14.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于奇奇怪怪的原因(其实是因为太困+vp CF)，于是就又摸了好久…</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>看上去就是一个组合游戏，于是考虑先分类出局面来。发现确定的必败态必然是只剩两个点，这时后手必胜。那么接着考虑中间的某些必败必胜态都是怎么互相转移的。</p><p>然后大概就是靠什么先验直觉来观察了。考虑只剩两个点的时候不存在偶度点，同时这个博弈长得就跟度数十分有关。那么就可以猜一波度数。具体的，将局面分成两类，「全都是奇度点 $P$」和「至少存在一个偶度点 $Q$」。发现局面 $Q$ 至少可以专用到一个 $P$ ，而局面 $P$ 转移到的一定都是局面 $Q$ ，再加上 $P$ 一定包含至少一个必败态(即终态)，所以不难知道这种分类这符合组合游戏对于必败态和必胜态的定义。</p><p>于是就瞎判一下就好了。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>给出一棵二叉树。问能否给所有点黑白染色，使得在将这棵树的所有叶子用空节点补全之后满足：</p><p>1、任意两个白点不相邻。</p><p>2、从根节点到任意一个空节点经过的黑点个数一样多。</p><p>$1\leq n\leq 5000$ 。</p></blockquote><p>一开时觉得为了使之尽量合法，所以应该让最长的那条链上黑点个数恰好是一半…反正就是推了几个类似的睿智结论，然后就当场去世了QAQ。</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑直接用 dp 确定合法性。设 $f_{i,j,0/1}$ 表示以 $i$ 为根的子树，每条根到空节点路径上的黑点个数为 $j$ ，当前点涂成黑/白是否可以。那么转移就是枚举一个左子树转移。</p><script type="math/tex; mode=display">f_{i,j,0}=\bigcap f_{k,j,1}\\f_{i,j,1}=\bigcap \left(f_{k,j-1,1}\cup f_{k,j-1,0}\right)</script><p>然后初值的话，考虑如果某个叶子没有兄弟的话就必须涂白色。</p><p>于是就可以直接对着 $\{f\}$ 构造了。复杂度 $O(n^2)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> rt ;</span><br><span class="line">vint E[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">bool</span> foc[N] ;</span><br><span class="line"><span class="keyword">char</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>] ;<span class="comment">//0r1b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> r = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (E[x].size() == <span class="number">1</span>) foc[y] = <span class="number">1</span> ;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        dfs(y) ; r = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (foc[x])</span><br><span class="line">            f[x][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[x][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            f[x][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (E[x].size())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            f[x][j][<span class="number">0</span>] = f[x][j][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        solve(y) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            f[x][j][<span class="number">0</span>] &amp;= f[y][j][<span class="number">1</span>] ;</span><br><span class="line">            f[x][j][<span class="number">1</span>] &amp;= f[y][j - <span class="number">1</span>][<span class="number">1</span>] | f[y][j - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_p</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt_b, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    ans[x] = <span class="string">"RB"</span>[col] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; cnt_b &lt;&lt; " " &lt;&lt; col &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (!col || !f[y][cnt_b - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            out_p(y, cnt_b - col, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> out_p(y, cnt_b - col, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span> ; y &lt;= n ; ++ y)</span><br><span class="line">        x = qr(), E[x].push_back(y) ;</span><br><span class="line">    rt = E[<span class="number">0</span>][<span class="number">0</span>] ; dfs(rt) ; solve(rt) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; f[rt][i][0] &lt;&lt; " " &lt;&lt; f[rt][i][1] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span> (f[rt][i][<span class="number">0</span>]) <span class="keyword">return</span> out_p(rt, i, <span class="number">0</span>), !<span class="built_in">puts</span>(ans + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (f[rt][i][<span class="number">1</span>]) <span class="keyword">return</span> out_p(rt, i, <span class="number">1</span>), !<span class="built_in">puts</span>(ans + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">puts</span>(<span class="string">"Impossible"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>上面那个做法是胃疼做法，胃疼在没有深刻发现性质。</p><p>首先设整棵树里所有叶子和只有一个孩子的点为关键点。那么如果关键点中深度极差 $\geqslant 2$ 可以知道必然不存在解，因为这样必然会多一个黑点。之后考虑这是一定可以黑白染色的，因为红黑树本质上比这个限制要多但依然可以红黑染色。具体的可以考虑让所有和最小深度关键点深度的奇偶性相同的点都染成黑色，否则染成红色。不难知道这是合法的。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>对于任意 $1≤k≤n$， 求有多少个左右区分的恰有 $k$ 个叶子节点的二叉树， 满足对于每个节点要么没有叶子节点要么有两个节点， 同时不存在一个叶子节点， 使得根到它的路径上有不少于 $m$ 条向左的边。</p><p>你只需要求出答案对 $998244353$ 取模的结果。</p><p>$1\leq n\leq 5000$ 。</p></blockquote><p>比较考察基础的一道经典 DP？虽然不是很难。</p><h2 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>比较暴力的想法就是设计一个 $f_{i,j}$ 表示当前有了 $i$ 个叶子节点，到每个叶子左边个数最多为 $j$ 的方案数。转移的话考虑枚举叶子数，拆左子树</p><script type="math/tex; mode=display">f_{i,j}=\sum _{k}f_{k,j-1}\times f_{i - k,j}</script><p>即考虑拆出来的那条左边对答案的贡献。复杂度 $O(n^3)$ 。</p><p>然后发现这是个卷积的形式，可以信仰一波优化到 $O(n^2\log n)$ 通过此题。</p><h2 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>考虑上面那个做法属实胃疼。观察转移可以发现每次转移左子树和右子树的 $j$ 的差为 $1$ 且固定。于是可以把第二维换一下。设 $f_{i,k}$ 表示以 $i$ 为根，左右子树的左边个数之差为 $k$ 的方案数。那么考虑每次按照 $dfs$ 序的顺序，即先左后右，插入一个新的叶子，会得到</p><script type="math/tex; mode=display">\begin{aligned}f_{i,k}&\to f_{i,k+1}\\f_{i,k}&\to f_{i+1,k-1} \end{aligned}</script><p>即分类讨论插入的是左叶子还是右叶子。复杂度 $O(n^2)$ 。</p><h2 id="Sol-3-by-duye"><a href="#Sol-3-by-duye" class="headerlink" title="Sol 3 (by duye)"></a>Sol 3 (by duye)</h2><p>考虑一个跑得更快的做法。大概说设限制为 $m$ 时的这种树的 OGF 是 $F_m(x)$，其中 $[x^n]F_m(x)$ 表示有 $n$ 个叶子的结果。那么有转移</p><script type="math/tex; mode=display">F_m(x)=x\cdot F_{m-1}(x)\cdot F_m(x)+1</script><p>感觉还是挺显然的？本质上就是在拼插一棵二叉树。写成递推形式就是</p><script type="math/tex; mode=display">F_m(x)=\dfrac{1}{1-x\cdot F_{m-1}(x)}</script><p>发现可以分别维护分子分母，最后求逆一次就好了。复杂度 $O(n^2+n\log n)$ 。但因为前面维护分子分母只用 $\deg(F)$ 次运算，所以最后带一个 $\dfrac{1}{2}$ 的常数。实际效率优秀。</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>比较简单的题目，但是感觉 trick 挺新颖。</p><p>考虑首先「最小」一定是对每一趟航班从大到小排序来做，同时不同的航班之间彼此没有影响。之后考虑如何算期望。由于算期望时终态固定，所以考虑倒着做。设 $\mathbb{E}_i$ 表示考虑 $i\sim n$ 的航班的期望最小步数，发现有转移</p><script type="math/tex; mode=display">\mathbb{E}_i=\zeta(i)+\sum _{j=1}^{k_i}\left(\prod_{k=1}^{j-1} (1-p_{i,k})\right)\cdot p_{i,j} \cdot (\mathbb{E}_{i+1}+j)</script><p>其中 $\zeta(i)$ 是这趟航班检查完了一个坏掉的都没有的期望，转移跟后面差不多但是边界比较奇怪就单列出来了。</p><p>那么考虑答案本质上就是在求这个东西的最小值。考虑这相当于是一系列一次函数的嵌套，于是考虑按照什么顺序去嵌套这 $n$ 个函数。考虑如下偏序关系：</p><script type="math/tex; mode=display">\tau_i(\tau_j+\epsilon_j)+\epsilon_i<\tau_j(\tau_i+\epsilon_i)+\epsilon_j</script><p>移项可以得到</p><script type="math/tex; mode=display">\frac{\tau_i-1}{\epsilon_i}<\frac{\tau_j-1}{\epsilon_j}</script><p>于是按照这个排序就好了。复杂度 $O(\sum k_i+n\log n)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"></span><br><span class="line">db ans ;</span><br><span class="line">db base[N] ;</span><br><span class="line">pdb func[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; db res, t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) ; res = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;base[j]) ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + k + <span class="number">1</span>, [](db x, db y)&#123; <span class="keyword">return</span> x &gt; y ; &#125;) ;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; base[k] &lt;= eps) k -- ;</span><br><span class="line">        <span class="keyword">if</span> (base[<span class="number">1</span>] &gt;= <span class="number">1.0</span> - eps) &#123; n --, i -- ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)&#123;</span><br><span class="line">            t = res * base[j], res *= (<span class="number">1.0</span> - base[j]) ;</span><br><span class="line">            func[i].fr += t , func[i].sc += t * j ;</span><br><span class="line">        &#125;</span><br><span class="line">        func[i].sc += res * k ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(func + <span class="number">1</span>, func + n + <span class="number">1</span>, [](pdb a, pdb b)&#123; <span class="keyword">return</span> a.fr * b.sc + a.sc &lt; b.sc + b.fr * a.sc ; &#125;) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans = func[i].fr * ans + func[i].sc ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>$1\leq m\leq 10^6,1\leq n\leq 30$ 。</p></blockquote><p>首先先看这个诡异操作，不难发现就是左移，如果 $2^{n-1}$ 位是 $1$，那么就把第一位或成 $1$，再 $\rm and$ 上 $2^{n}-1$ …结果发现这就是一个循环左移的操作。</p><p>然后不难看出初值有限。但是因为初值的选取和小 Y 的决策都是变量，所以考虑定住一边。发现让 $x$ 循环左移之后再异或，由于位运算的交换律，本质上可以等价于让第 $1\sim i$ 的前缀整体循环左移一位然后再异或上 $x &lt;&lt; 1$ ，即</p><script type="math/tex; mode=display">(a\operatorname{xor}b) \operatorname{<<}1=(a \operatorname{<<}1)\operatorname{xor}(b\operatorname{<<}1)</script><p>然后就可以预处理处一个 $\{b_n\}$ 表示</p><script type="math/tex; mode=display">(x<<1)\operatorname{xor} b_i=\left(x\operatorname{xor}{\left(\bigoplus_{j=1}^{i}a_i\right)}\right) <<1</script><p>然后考虑对于一个固定的 $x$ ，小 Y 的策略就会是找到对于一个固定的 $x$ 的最小的 $b_i$，而小 D 的策略则是选择最优的初值达到最大的结果。</p><p>于是考虑按位分治。先对 $\{b_n\}$ 排个序，这样对于每一位为 $1$ 或是为 $0$ 就是一个连续的区间。那么如果整个区间中的所有 $b_i$ 第 $p$ 位均为 $1$ ，那么这一位就必须要选 $1$ ，否则小 Y 可以在小 D 选 $0$ 的时候也选 $0$，选 $1$ 的时候也选 $1$ 使得答案最小。</p><p>注意，本质上是不需要体现出 $x$ 也要 $&lt;&lt;1$ 这一点来，因为每个 $x$ 对应着唯一的 $x&lt;&lt;1$ ，而我们只关心最后的最小答案和方案数，并不关心具体选了什么 $x$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> a[N] ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> suf[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; ans)</span><br><span class="line">            ans = res, cnt = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == ans) ++ cnt ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l, now = <span class="number">1</span> &lt;&lt; p ;</span><br><span class="line">    <span class="keyword">while</span> (mid &lt;= r &amp;&amp; !(b[mid] &amp; now)) ++ mid ;</span><br><span class="line">    <span class="keyword">if</span> (mid == l || mid &gt; r)</span><br><span class="line">        <span class="keyword">return</span> solve(l, r, p - <span class="number">1</span>, res | now) ;</span><br><span class="line">    solve(l, mid - <span class="number">1</span>, p - <span class="number">1</span>, res) ;</span><br><span class="line">    solve(mid, r, p - <span class="number">1</span>, res) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) a[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) pre[i] = pre[i - <span class="number">1</span>] ^ a[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m ; i &gt;= <span class="number">1</span> ; -- i) b[i - <span class="number">1</span>] = suf[i] = suf[i + <span class="number">1</span>] ^ a[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        b[i] ^= ((pre[i] &gt;&gt; (n - <span class="number">1</span>) | (pre[i] &lt;&lt; <span class="number">1</span>)) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)) ;</span><br><span class="line">    sort(b, b + m + <span class="number">1</span>) ; solve(<span class="number">0</span>, m, n - <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span> ; <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于奇奇怪怪的原因(其实是因为太困+vp CF)，于是就又摸了好久…&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="多项式的应用" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
      <category term="技巧/按位考虑" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E8%80%83%E8%99%91/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="思维题/对应与转化" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AF%B9%E5%BA%94%E4%B8%8E%E8%BD%AC%E5%8C%96/"/>
    
      <category term="博弈论/组合游戏" scheme="https://www.orchidany.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[Codeforces Global Round#5 A~F] 口胡记</title>
    <link href="https://www.orchidany.cn/2020/06/04/CF-Global-Round-5%E5%8F%A3%E8%83%A1%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/04/CF-Global-Round-5口胡记/</id>
    <published>2020-06-04T07:54:22.000Z</published>
    <updated>2020-06-04T08:58:22.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单独整理这一场，一是因为这一场的题目质量整体比较高，二是因为这一场的 E 是实在是有点神仙…</p><p>托老师还是宝刀不老鸭！</p><p>以下部分简单题是在宿舍自习室里口胡出来的。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>秒了。题面太长了。考虑一定可以让正数和负数各余出 $1$ 的贡献，然后就做完了。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>秒了。一开始觉得可能是什么俩排列的 LCS 之类的。后来重读了一遍题发现原来只需要记一个前缀 $\max$ 去判断是否有车被自己之后的超了就完了。</p><h1 id="C1-amp-C2"><a href="#C1-amp-C2" class="headerlink" title="C1 &amp; C2"></a>C1 &amp; C2</h1><p>这个 C 不知为何把我给狙了…于是就只胡出来了 C1。</p><p>C1 大概是考虑先 $n^2$ 求一遍交，然后不断删相距最近的相交的弦，删到都不相交为止，然后随便配对就好了。</p><p>C2 翻车的原因是推了个假结论…觉得如果排个序之后，从最中间的两个开始匹配，<code>l--,r++</code> 这种就一定可以。然后发现理解错题意了…三个点的偏序顺序并不需要相同。</p><p>冷静下来发现，可以对每一维分治。即 $x,y$ 相同的可以相邻匹配，删掉之后 $x$ 相同的可以相邻匹配。感觉被降智了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> x, y, z ;</span><br><span class="line">&#125;base[N], re1[N], re2[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> nd &amp;a, <span class="keyword">const</span> nd &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">x_y_equal</span><span class="params">(<span class="keyword">const</span> nd &amp;a, <span class="keyword">const</span> nd &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x == b.x &amp;&amp; a.y == b.y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">x_equal</span><span class="params">(<span class="keyword">const</span> nd &amp;a, <span class="keyword">const</span> nd &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x == b.x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i].x = qr(), base[i].id = i ;</span><br><span class="line">        base[i].y = qr(), base[i].z = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    base[n + <span class="number">1</span>] = (nd) &#123;<span class="number">0</span>, -P, -P, -P&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x_y_equal(base[i], base[i + <span class="number">1</span>]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, base[i].id, base[i + <span class="number">1</span>].id), ++ i ;</span><br><span class="line">        <span class="keyword">else</span> re1[++ cnt] = base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(re1, base) ;</span><br><span class="line">    n = cnt ; cnt = <span class="number">0</span> ;</span><br><span class="line">    base[n + <span class="number">1</span>] = (nd)&#123;<span class="number">0</span>, -P, -P, -P&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x_equal(base[i], base[i + <span class="number">1</span>]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, base[i].id, base[i + <span class="number">1</span>].id), ++ i ;</span><br><span class="line">        <span class="keyword">else</span> re2[++ cnt] = base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(re2, base) ;</span><br><span class="line">    n = cnt ; cnt = <span class="number">0</span> ;</span><br><span class="line">    base[n + <span class="number">1</span>] = (nd)&#123;<span class="number">0</span>, -P, -P, -P&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, base[i].id, base[i + <span class="number">1</span>].id) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>秒了。虽然一开始没啥想法，但是直觉告诉我应该找上界，然后发现上界是 $2n$ 。于是就可以把数组拼三遍，然后就可以对每个位置 $i$，由于都具有单调性，二分出第一个 $k\in[i+1,i+2\cdot n]$ 使得后缀 $\min$ &lt; 前缀 $\max\times \dfrac{1}{2}$ 的位置就好了。</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>这个找性质题…有点强。</p><blockquote><p>求有多少棵点数为 $n(n\leqslant 10^6)$ 的，键值为 $1\sim n$ 的排列的二叉搜索树满足以下条件：</p><p>$(1)$ <code>balanced</code>每个点的总深度和最小。</p><p>$(2)$ <code>striped.1</code> 对于每个点，如果它有左儿子，那么左儿子的键值和它的键值奇偶性<strong>不同</strong>。</p><p>$(3)$  <code>striped.2</code> 对于每个点，如果它有右儿子，那么右儿子的键值和它的键值奇偶性<strong>相同</strong>。</p><p>答案对 $998,244,353$ 取模。</p></blockquote><div><div class="fold_hider"><div class="close hider_title">【以下是心路历程】</div></div><div class="fold"><hr><p>读题的时候由于旁边只有过时的牛津字典，于是查了查发现 <code>parity</code> 是什么 <code>平价</code> ，然后 <code>striped</code> 是什么有条纹的。我就 <code>???</code> 。不过想了一会儿就猜出来应该是在说奇偶性了。 </p><p>然后就向着要一个一个条件地去容斥…大概是首先发现合法的二叉排序树严格对应于不同形态的二叉树，换句话说每一种形态的二叉树都有恰好一个填充方式使之成为二叉搜索树。尝试证明发现显然，因为每种形态的二叉树的中序遍历唯一，而二叉搜索树的中序遍历的键值序列恰好是 $1\sim n$ 的排列。所以发现这部分答案就是卡特兰数。</p><p>…事实证明如果基础掌握不扎实，就可能会花上那么几十秒的时间去现推一波已知结论…</p><p>但，这个结论，最后也根本没有用上。因为发现剩下两个条件根本没什么简洁的方法直接容斥出来。直到今天早上早读——</p><hr></div></div><p>发现这个 <code>balanced</code> 是个很强的约束，可以观察到在第一个条件下根节点只能是 $\left\lceil\dfrac{n}{2} \right\rceil$ 或者 $\left\lfloor\dfrac{n}{2} \right\rfloor$ 。然后紧接着可以发现每个子树在第一个约束下都只能是类似状态。然后考虑第二个条件，一个很重要的事实在于，可以发现键值 $n$ 永远是在最右侧的链，所以可以知道 $n$ 一定和 $root$ 的键值奇偶性相同。接着，由于右子树的点集是 $[root,n]$ ，那么不难知道<strong>每个根的右子树 $size$ 都必然是偶数</strong> 。</p><p>有了这些性质，可以发现对于每个 $n$ ，答案至多为 $1$ 。</p><p>证明可以考虑假设有两个均满足条件的树 $T_1,T_2$ ，那么他们一定有某部分同构，剩下的部分不同构。考虑不同构的那部分，由于要满足 <code>perfect balanced</code> ，所以可以知道「不同构」只能是把某个点的某个子树的一个点移到另一颗子树里，这要满足两个子树 size 之前相差 $1$ ，所以 $T_1,T_2$ 中必然有一棵树满足存在一个点，其右子树的 size 是奇数。所以可知答案至多为 $1$ 。</p><p>于是就可以直接从 $size=1$ 开始构造了。复杂度 $\log n$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ;</span><br><span class="line">    <span class="keyword">while</span> (ans &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans == n || ans == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ans &amp; <span class="number">1</span>) (ans &lt;&lt;= <span class="number">1</span>) += <span class="number">2</span> ; <span class="keyword">else</span> (ans &lt;&lt;= <span class="number">1</span>) += <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>比较简单的计数题？大概就是考虑无论是横着的牌占了某一列或竖着占了某一列，都是占(<del>也叫做「横竖都是占」</del>)，所以可以用行列无关的思想来 DP。具体的，设 $f_{i,j}$ 表示前 $i$ 行选了 $j$ 对相邻的两行，$g_{i,j}$ 表示前 $i$ 列选了 $j$ 对相邻的两列。那么会有转移</p><script type="math/tex; mode=display">\tau_{i,j}=\tau_{i-1,j}+\tau_{i-2,j-1}</script><p>其中 $\{\tau\}$ 可以看做通配符。转移注意特判一下合法性。然后就可以合并出答案来</p><script type="math/tex; mode=display">ans=\sum_p\sum_q f_{n,p}\times g_{m,q}\times {\rm P}(m-2\cdot q,p)\times {\rm P}(n-2\cdot p,q)</script><p>其中 ${\rm P}(n,m)$ 是从 $n$ 个元素里面选 $m$ 个元素的排列数。之所以是排列数是因为对于某些确定横着放的骨牌，$dp$ 数组只是确定了他们的列该怎么放，所以相当于给每个骨牌分配一个行号，所以是排列数。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fac ;</span><br><span class="line"><span class="keyword">int</span> smax ;</span><br><span class="line"><span class="keyword">int</span> sn, sm ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> visr[N] ;</span><br><span class="line"><span class="keyword">int</span> visc[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> g[N][N] ;</span><br><span class="line"><span class="keyword">int</span> perm[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, ll y, <span class="keyword">int</span> mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">addn</span><span class="params">(T x, ll y, <span class="keyword">int</span> mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; <span class="keyword">return</span> (x = x &gt; mod ? x - mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chkr</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((!visr[x] &amp;&amp; !visr[x - <span class="number">1</span>]) &amp;&amp; y &amp;&amp; (<span class="keyword">bool</span>)(x - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chkc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((!visc[x] &amp;&amp; !visc[x - <span class="number">1</span>]) &amp;&amp; y &amp;&amp; (<span class="keyword">bool</span>)(x - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k) ;</span><br><span class="line">    smax = max(sn = n, sm = m), fac = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= smax ; ++ i) perm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= smax ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            perm[i][j] = addn(perm[i - <span class="number">1</span>][j], perm[i - <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= smax ; ++ j)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j ; i &lt;= smax ; ++ i)</span><br><span class="line">            perm[i][j] = <span class="number">1l</span>l * perm[i][j] * fac % P ;</span><br><span class="line">        fac = <span class="number">1l</span>l * fac * (j + <span class="number">1</span>) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;c, &amp;d) ;</span><br><span class="line">        <span class="keyword">if</span> (a == c)&#123;</span><br><span class="line">            -- sn, -- sm, -- sm ;</span><br><span class="line">            visr[a] = <span class="number">1</span>, visc[b] = visc[d] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == d)&#123;</span><br><span class="line">            -- sm, -- sn, -- sn ;</span><br><span class="line">            visc[d] = <span class="number">1</span>, visr[a] = visr[c] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= (sn &gt;&gt; <span class="number">1</span>) ; ++ j)</span><br><span class="line">            f[i][j] = addn(chkr(i, j) * f[i - <span class="number">2</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= (sm &gt;&gt; <span class="number">1</span>) ; ++ j)</span><br><span class="line">            g[i][j] = addn(chkc(i, j) * g[i - <span class="number">2</span>][j - <span class="number">1</span>], g[i - <span class="number">1</span>][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= (sn &gt;&gt; <span class="number">1</span>) ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= (sm &gt;&gt; <span class="number">1</span>) ; ++ j)</span><br><span class="line">            add(ans, <span class="number">1l</span>l * f[n][i] * g[m][j] % P * perm[sn - (i &lt;&lt; <span class="number">1</span>)][j] % P * perm[sm - (j &lt;&lt; <span class="number">1</span>)][i] % P) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>然后就没有然后了，G和H是不可能做的 (x</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单独整理这一场，一是因为这一场的题目质量整体比较高，二是因为这一场的 E 是实在是有点神仙…&lt;/p&gt;
&lt;p&gt;托老师还是宝刀不老鸭！&lt;/p&gt;
&lt;p&gt;以下部分简单题是在宿舍自习室里口胡出来的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="技巧/行列无关" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E8%A1%8C%E5%88%97%E6%97%A0%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【训练记录】6.3 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/03/6-3-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/03/6-3-训练笔记/</id>
    <published>2020-06-03T12:16:33.000Z</published>
    <updated>2020-06-03T13:11:20.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为奇怪的问题，导致其实昨天第三场的 T3 写的复杂度并不对。于是今天就花了很多时间研究了一下正确的做法，导致只打了一场…（并且做完没睡好导致上午效率极低）。</p><p>不过有一说一，题目还是很赞的！感觉学到了很多。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给定两个长度分别为 $n,m$ 的串 $s,t$ 。求有多少个 $s$ 的本质不同的子串(起始位置不同)包含 $t$ 作为子序列。</p><p>$1\leq n\leq 10^5,1\leq m\leq 100$ 。</p></blockquote><p>拿了一个比 std 更有技术含量的做法秒了这道题。大概是考虑可以先预处理出 $s$ 中有哪些极小的区间包含 $t$ 作为子序列，这部分可以用子序列自动机来实现。观察到 $m$ 比较小，就可以枚举每一个 $s_i=t_1$ 的位置 $i$ 开始在自动机上匹配直到结束。</p><p>这样最后一定是一堆区间。考虑如果一个区间被另一个区间完全包含，那么那个大区间就没用了，可以删掉。于是就可以对 <code>vector</code> 排个序用类似单调栈的方法做这个过程。之后考虑，对于相邻的两端区间 $[l_1,r_1],[l_2,r_2]$，$[l_2,r_2]$ 可以产生的部分贡献 $[l_1,r_1]$ 也产生了，不难发现这就是那些满足 $[l_2,r_2]\subset [l,r]$ 且 $l\leq l_1$ 的贡献，于是左端点就只取 $l_2-l_1$ 这些方案就好了。复杂度 $O(|\Sigma|\times n+nm)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">char</span> a[N] ;</span><br><span class="line"><span class="keyword">char</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N][<span class="number">26</span>] ;</span><br><span class="line"></span><br><span class="line">vpint ant ;</span><br><span class="line">vpint range ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span> ; ++ j) nxt[L + <span class="number">1</span>][j] = L + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span> ; ++ j)</span><br><span class="line">            nxt[i][j] = nxt[i + <span class="number">1</span>][j] ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; L)</span><br><span class="line">            nxt[i][s[i + <span class="number">1</span>] - <span class="string">'a'</span>] = i + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>, o = p ;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n + <span class="number">1</span> &amp;&amp; q &lt; m)</span><br><span class="line">        ++ q, p = nxt[p][b[q] - <span class="string">'a'</span>] ;</span><br><span class="line">    range.p_b(make_pair(o, p)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pint a, pint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.fr == b.fr ? a.sc &gt; b.sc : a.fr &lt; b.fr ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">r_include</span><span class="params">(pint a, pint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.fr &lt;= b.fr &amp;&amp; a.sc &gt;= b.sc ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, b + <span class="number">1</span>) ; build(a, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[<span class="number">1</span>]) do_match(i) ;</span><br><span class="line">    sort(range.begin(), range.end()) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; range.size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = ant.size() - <span class="number">1</span> ; ~k ; -- k)</span><br><span class="line">            <span class="keyword">if</span> (r_include(ant[k], range[i])) ant.pop_back() ;</span><br><span class="line">        ant.push_back(range[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ant.size() ; ++ i)</span><br><span class="line">        ans += <span class="number">1l</span>l * (n - ant[i].sc + <span class="number">1</span>) * (ant[i].fr - l), l = ant[i].fr ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>$1\leq m\leq 16$ 。</p></blockquote><p>这题是真的神神神神神。然而自己打了暴力就跑了。</p><p>考虑找性质+分治。有这么几个<del>找不出来的</del>性质：</p><p>1、每个 $1\sim n$ 的数至少会在 $p_0\sim p_{2^m-1}$ 中出现一次。考虑对于某个 $a_i$ ，将其取反得到的 $rev(a_i)$一定也是 $[0,2^m-1]$ 之间的数，同时必然有 $a_i\operatorname{xor} rev(a_i)$ 最优，可以达到 $2^m-1$ 这个上界 。</p><p>2、考虑对 $p$ 按照<strong>二进制(当前)最高位是0/1</strong>进行分治。考虑分治到某个时刻的 $[l,r]$。考虑如果存在 $[l,mid]$ 和 $[mid+1,r]$ 的所有 $p_i$ 分别相同，那么说明当前这一位设成 $0$ 还是 $1$ 并没有什么什么影响，所以此时对答案会产生 $2$ 的贡献。并且由于左右区间相同，需要只分治一边。</p><p>3、如果不同，那么考虑如果 $[l,mid]$ 中的某个 $p_i$ 出现在了 $[mid+1,r]$ 里面，那么最后答案就是 $0$。原因是如果不满足当前最高位填 $0/1$ 都可以的话，就可以对这些数按照当前二进制位分组。而一个数字不可能存在二进制下某一位既是 $0$ 又是 $1$，所以无解。</p><p>4、否则分治到更小的二进制位去观察贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug(l, ' '), debug(r) ;</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = mid + <span class="number">1</span> ; i &lt;= mid ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (base[i] != base[j]) <span class="keyword">goto</span> no_contribute ; <span class="keyword">else</span> ++ j ;</span><br><span class="line">    (ans *= <span class="number">2l</span>l) %= P ; solve(l, mid) ; <span class="keyword">return</span> ;</span><br><span class="line">    no_contribute : <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) buc[base[i]] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= mid ; ++ i) buc[base[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    solve(l, mid) ; solve(mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; m = <span class="number">1</span> &lt;&lt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">        buc[base[i] = qr()] += <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!buc[i]) <span class="keyword">goto</span> fuck ;</span><br><span class="line">    ans = <span class="number">1</span> ; solve(<span class="number">0</span>, m - <span class="number">1</span>) ; <span class="comment">/* */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    fuck : <span class="built_in">puts</span>(<span class="string">"0"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一个完全图。求该图的「最小 xq 生成树」的 xq。</p><p>定义一棵树的 xq为</p><script type="math/tex; mode=display">\sum_i\sum_j {\rm dist}(i,j)</script><p>其中具有最小的 xq 的那棵树被称为「最小 xq 生成树」。</p><p>$1\leq n\leq 15$ 。</p></blockquote><p>比较有趣的 dp 吧…</p><p>自己一开始写了个特别弱智的错解。大概是对着每个点集跑一遍 Floyd，然后设 $f_s$ 表示集合 $s$ 中最小 xq 生成树的 xq 值。转移的时候枚举一个点进行转移。这样显而易见地就忽视了树的限制。于是考虑如何 dp 出一棵合理的树。</p><p>具体的，设 $f_{s,i}$ 表示以 $i$ 为根，树中的元素是集合 $s$ 的最小 xq 生成树的 xq 值。考虑怎么转移。转移的本质是枚举一个子问题，那么如果钦定了根是谁，就可以直接枚举怎么从根拆出一个子树来。更为具体的，有转移</p><script type="math/tex; mode=display">f_{s,i}=\min_{t\subseteq s,j\in t}\{f_{t,j}+f_{s\setminus t,i}+val(i,j)\times {\rm card}(t)\times {\rm card}\left(\complement_Ut\right)\}</script><p>也就是考虑删去的与根 $i$ 相连的某条边 $(i,j)$ 对总答案的贡献。那么就可以有一个 $O(3^n\times n^2)$ 的做法，可以通过 $n\le 13$ 。</p><p>之后考虑后面那部分好像很多余，因为后面那部分就本质上跟 $s\setminus t$ 无关了。具体的，对于每个集合 $s$ ，可以利用 $f_s$ 额外 dp 出一个 $g_{s,i}(i\notin s)$ 满足定义如下</p><script type="math/tex; mode=display">g_{s,i}=\min_{j\in s}\{f_{s,j}+val(i,j)\times {\rm card}(s)\times {\rm card}\left(\complement_Us\right)\}</script><p>于是转移就可以只拿 $g$ 转移了。复杂度 $O(3^n\times n+2^n\times n^2)$ 可以通过本题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line">ll sz[M] ;</span><br><span class="line">ll unsz[M] ;</span><br><span class="line">ll A[N][N] ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll g[M][N] ;</span><br><span class="line">ll f[M][N] ;</span><br><span class="line"><span class="comment">//ll s[M][N] ;</span></span><br><span class="line"><span class="comment">//ll g[M][N][N] ;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biout</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x) <span class="built_in">cout</span> &lt;&lt; (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        f[<span class="number">1</span> &lt;&lt; i][i] = g[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; ++ j)</span><br><span class="line">            A[i][j] = A[j][i] = qr() ; unsz[<span class="number">0</span>] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sz[i] = sz[i ^ (i &amp; (-i))] + <span class="number">1</span>, unsz[i] = n - sz[i] ;</span><br><span class="line"><span class="comment">//    debug(sz, 1, m) ; debug(unsz, 1, m) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span> ; s &lt;= m ; ++ s)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = s ; t ; t = (t - <span class="number">1</span>) &amp; s)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; t)</span><br><span class="line">                    chkmin(f[s][i], f[t][i] + g[s ^ t][i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; s) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; s)</span><br><span class="line">                    chkmin(g[s][i], f[s][j] + A[i][j] * sz[s] * unsz[s]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = f[m][<span class="number">0</span>] ;</span><br><span class="line"><span class="comment">//    debug(f[m], 0, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) chkmin(ans, f[m][i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 $65$ 分，注释起来的是翻车现场。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> sz[M] ;</span><br><span class="line"><span class="keyword">int</span> A[N][N] ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll f[M][N] ;</span><br><span class="line"><span class="comment">//ll s[M][N] ;</span></span><br><span class="line"><span class="comment">//ll g[M][N][N] ;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biout</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x) <span class="built_in">cout</span> &lt;&lt; (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        f[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">0</span> ; m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; ++ j)</span><br><span class="line">            A[i][j] = A[j][i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sz[i] = sz[i ^ (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span> ; s &lt;= m ; ++ s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = s ; t ; t = (t - <span class="number">1</span>) &amp; s)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; t)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; (s ^ t))</span><br><span class="line">                            chkmin(f[s][i], f[t][i] + f[s ^ t][j] + <span class="number">1l</span>l * A[i][j] * sz[s ^ t] * (n - sz[s ^ t])) ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int o = 0 ; o &lt;= m ; ++ o)&#123;</span></span><br><span class="line"><span class="comment">        int stk[20], cnt = 0 ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt; n ; ++ i)</span></span><br><span class="line"><span class="comment">            if (1 &lt;&lt; i &amp; o)&#123;</span></span><br><span class="line"><span class="comment">                stk[++ cnt] = i ;</span></span><br><span class="line"><span class="comment">                for (int j = 0 ; j &lt; n ; ++ j)</span></span><br><span class="line"><span class="comment">                    if (1 &lt;&lt; j &amp; o)</span></span><br><span class="line"><span class="comment">                        g[o][i][j] = g[o][j][i] = A[i][j] ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        for (int k = 1 ; k &lt;= cnt ; ++ k)</span></span><br><span class="line"><span class="comment">            for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">                for (int j = 1 ; j &lt;= cnt ; ++ j)</span></span><br><span class="line"><span class="comment">                    if ((i ^ j) &amp;&amp; (j ^ k) &amp;&amp; (i ^ k))</span></span><br><span class="line"><span class="comment">                        chkmin(g[o][stk[i]][stk[j]], g[o][stk[i]][stk[k]] + g[o][stk[k]][stk[j]]) ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt; n ; ++ i)</span></span><br><span class="line"><span class="comment">            if (1 &lt;&lt; i &amp; o)</span></span><br><span class="line"><span class="comment">                for (int j = 0 ; j &lt; n ; ++ j)</span></span><br><span class="line"><span class="comment">                    if (1 &lt;&lt; j &amp; o)</span></span><br><span class="line"><span class="comment">                        s[o][i] += g[o][i][j] ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= m ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 0 ; j &lt; n ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            if (!(1 &lt;&lt; j &amp; i)) continue ;</span></span><br><span class="line"><span class="comment">            chkmin(f[i], f[i ^ (1 &lt;&lt; j)] + s[i][j]) ;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= m ; ++ i)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; i &lt;&lt; " ", biout(i), cout &lt;&lt; " " &lt;&lt; f[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ans = f[m][<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) chkmin(ans, f[m][i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为奇怪的问题，导致其实昨天第三场的 T3 写的复杂度并不对。于是今天就花了很多时间研究了一下正确的做法，导致只打了一场…（并且做完没睡好导致上午效率极低）。&lt;/p&gt;
&lt;p&gt;不过有一说一，题目还是很赞的！感觉学到了很多。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="技巧/按位考虑" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E8%80%83%E8%99%91/"/>
    
      <category term="字符串/子序列自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%90%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【训练记录】6.2 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/03/6-2%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/03/6-2训练笔记/</id>
    <published>2020-06-02T23:00:09.000Z</published>
    <updated>2020-06-03T12:15:12.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下今天的三场比赛，又懒得搬题面了。</p><p>如果想要题面可以 QQ 戳我，我觉得你可爱就给你啦。</p><a id="more"></a><h1 id="A-M"><a href="#A-M" class="headerlink" title="A.M."></a>A.M.</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>秒掉了。大概是考虑从值域 $m$ 开始倒着加数，LIS就一定不会锅。最后判一下序列是否恰好有 $n$ 个元素即可。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line">vint ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ; <span class="keyword">int</span> t = n, s ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) b[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        s = m ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; k - i + <span class="number">1</span> &amp;&amp; s &gt; b[i])</span><br><span class="line">            ans.p_b(s --), t -- ;</span><br><span class="line">        ans.p_b(b[i]) ; -- t ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans.size() &lt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ; <span class="keyword">for</span> (<span class="keyword">auto</span> o : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, o) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>又秒掉了。大概是考虑倒着枚举每个度数和 $k$，去 check 答案是否合法。check 的时候考虑模拟一个类似 SPFA 的过程，只不过松弛从「边权」转成了「度数和」。根据玄学理论，这个过程应该也会是 $O(Km)$ 的，其中 $K$ 是某个不大的常数。那么最后复杂度大概就是 $O(nKm)$ 附近，可以通过此题。</p><p>然而自己用了一个堆维护度数。感觉这样才可以保证复杂度是对的，于是复杂度就大概降为了比较稳的 $O(n^2\log n)$ 左右？</p><p>然后剪了一下枝，大概是说考虑每次度数和从 $2\times \max\{\deg_x\}$ 开始枚举而不从 $2\times n$ 开始。实测这样总用时可以快 $15$ 倍。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _up ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N][N] ;</span><br><span class="line"></span><br><span class="line">vint E[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> tmp[A] &lt; tmp[B] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, comp&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        deg[u] ++, deg[v] ++ ;</span><br><span class="line">        A[u][v] = A[v][u] = <span class="number">1</span> ;</span><br><span class="line">        chkmax(_up, deg[u] &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">        chkmax(_up, deg[v] &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!A[i][j] &amp;&amp; i != j) E[i].p_b(j), E[j].p_b(i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ans = _up ; ans &gt;= <span class="number">0</span> ; -- ans)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = m, s = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            tmp[i] = deg[i] ;</span><br><span class="line">            vis[i] = <span class="number">1</span>, q.push(i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : E[i]) A[i][j] = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//        debug(ans)  ;</span></span><br><span class="line">        <span class="keyword">while</span> (q.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.top() ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; ' ' ;</span></span><br><span class="line">            q.pop() ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">                <span class="keyword">if</span> (A[x][y]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (tmp[y] + tmp[x] &gt;= ans)&#123;</span><br><span class="line">                    ++ res ;</span><br><span class="line">                    tmp[y] ++, tmp[x] ++ ;</span><br><span class="line">                    A[x][y] = A[y][x] = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y]) q.push(y) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(res) ;</span></span><br><span class="line">        <span class="keyword">if</span> (res == n * (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span>, <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>$n,q\le 10^5,m\leq 5$ 。</p></blockquote><p>本以为可以迅速过掉这一场，然后就  被  狙  了。</p><div><div class="fold_hider"><div class="close hider_title">【论我是如何被狙击的】</div></div><div class="fold"><p>自己一开始想了一个 bitset 的做法觉得很稳，复杂度大概是什么 $O\left(q\log n +\dfrac{n\cdot q\cdot m}{w}\right)$ 。大概思路就是考虑拿 <code>bitset</code> 维护当前询问点会被这些线段遮住的点的并集，最后 <code>n-ans.count()</code> 就是答案。</p><p>然后，第一个版本是这么写的：维护的时候考虑把所有点按照横坐标排个序，假设某条线段的端点是 $A$，当前询问点是 $O$，某个可能会被挡住的点是 $B$，然后考虑拿叉积去二分出第一个使得 $\overrightarrow{OA}\times \overrightarrow{OB}$ 小于或者大于 $0$ 的点（取决于左右端点）。</p><p>写完之后寻思了一下发现不对。因为考虑线段左端点的时候，要按照 $y$ 坐标从小到大排序才能对，而考虑右端点的时候则是要反过来排序。然后改了改觉得很稳。</p><p>然后又错了，因为如果某个点的横坐标在某线段的左端点的外部，和内部的处理方式要反！过！来！然后写了个分类讨论觉得很稳。</p><p>然后又挂了 ，调了一会儿发现这么判没法解决完全位于某条线段之下的点。于是就预处理了一波和答案或起来，觉得很稳。</p><p>然后调了半天还是过不去…突然醒悟，我拿 bitset，维护的是点的绝对顺序，但是如果左端点和右端点，一个是用正着排序二分的，一个使用反着排序二分的，就因为顺序不同而不！能！直！接！合！并！所以这东西就需要写一个映射，但是如果映射的话这不单次询问复杂度又变成 $O(n)$ 了吗！？然后就 GG 了。选择写 $20$ 分暴力滚粗。</p><p>然后被 std 秀了一脸= =。</p></div></div><hr><p>考虑正经做法，还是找性质。考虑具象化一下某个点不能看到某个点的条件，考虑这样</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p><p>然后就是设从左至右四个与 $x$ 轴的交点分别为 $W,X,Y,Z$ ，那么当且仅当 $W &lt;X$ 且 $Y&lt;Z$ 时，也就是观测点与该线段端点的连线与 $x$ 轴的交点被上方某被观测点与该线段端点的连线与 $x$ 轴的交点完全包含时，当前被观测点会被统计到。</p><p>同时，还有一个更强的性质。就是如果当前观测点满足 $Y<Z$ 或者 $X>W$ ，那么另一半的条件必然也满足。</p><p>以上都是比较显然的。然后考虑这样的话就可以直接暴力容斥了。具体的，先预处理出对于每个线段集合，每个上方的点与该集合内线段的连线与 $x$ 轴所交的区间的<strong>交</strong>。然后对于当前集合下每个点得出的 $l,r$ 分别排序，询问就可以暴力二分出位置来做了。</p><p>实现上有点细节。大概是什么 $l$ 要 <code>lower_bound</code> ，$r$ 要 <code>upper_bound</code> 之类的东西。</p><p>然后，这题，他卡！精！度！直接开 <code>long double</code> 啥事没有。</p><div><div class="fold_hider"><div class="close hider_title">「瞎写的</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"></span><br><span class="line">pint base[N] ;</span><br><span class="line"></span><br><span class="line">pint esab[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ns[<span class="number">10</span>][N] ;</span><br><span class="line"></span><br><span class="line">pint line[<span class="number">10</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; all ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; blw ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; below[<span class="number">10</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(pint a, pint b, pint c)</span></span>&#123;</span><br><span class="line">    pint x = make_pair(b.fr - a.fr, b.sc - a.sc) ;</span><br><span class="line">    pint y = make_pair(c.fr - a.fr, c.sc - a.sc) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1l</span>l * x.fr * y.sc - <span class="number">1l</span>l * y.fr * x.sc &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk2</span><span class="params">(pint a, pint b, pint c)</span></span>&#123;</span><br><span class="line">    pint x = make_pair(b.fr - a.fr, b.sc - a.sc) ;</span><br><span class="line">    pint y = make_pair(c.fr - a.fr, c.sc - a.sc) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1l</span>l * x.fr * y.sc - <span class="number">1l</span>l * y.fr * x.sc &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(pint a, pint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.fr == b.fr ? a.sc &lt; b.sc : a.fr &lt; b.fr ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(pint a, pint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.fr == b.fr ? a.sc &gt; b.sc : a.fr &lt; b.fr ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) all[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i].fr = qr(), base[i].sc = qr() ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp1) ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) esab[i] = base[i] ;</span><br><span class="line">    sort(esab + <span class="number">1</span>, esab + n + <span class="number">1</span>, comp2) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">rev[i] = lower_bound(base + <span class="number">1</span>, base + n + <span class="number">1</span>, esab[i]) - base ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; rev[i] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        line[i][<span class="number">0</span>].fr = qr() ;</span><br><span class="line">        line[i][<span class="number">1</span>].fr = qr() ;</span><br><span class="line">        line[i][<span class="number">0</span>].sc = line[i][<span class="number">1</span>].sc = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">blw.<span class="built_in">set</span>() ; blw[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">below[i].reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[j].sc &lt; line[i][<span class="number">0</span>].sc)</span><br><span class="line">                below[i][j] = <span class="number">1</span>, ns[i][++ ns[i][<span class="number">0</span>]] = j ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        pint now = make_pair(x, y) ;</span><br><span class="line">        <span class="built_in">bitset</span> &lt;N&gt; ans, t, tt, tmp ;</span><br><span class="line">ans.<span class="built_in">set</span>() ; ans[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">bool</span> val1, val2 ;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, res = <span class="number">0</span>, old ;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= line[i][<span class="number">0</span>].fr)&#123;</span><br><span class="line">val1 = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (chk(now, line[i][<span class="number">0</span>], base[mid]))</span><br><span class="line">                        res = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">val1 = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (chk(now, line[i][<span class="number">0</span>], esab[mid]))</span><br><span class="line">                        res = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t = all &amp; (all &lt;&lt; (n - res)) ; t &gt;&gt;= n - res ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">10</span> ; ++ i) <span class="built_in">cout</span> &lt;&lt; t[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t.count() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            l = res + <span class="number">1</span>, r = n, old = res, res = n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= line[i][<span class="number">1</span>].fr)&#123;</span><br><span class="line">val2 = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (chk2(now, line[i][<span class="number">1</span>], esab[mid]))</span><br><span class="line">                        res = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">val2 = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (chk2(now, line[i][<span class="number">1</span>], base[mid]))</span><br><span class="line">                        res = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tt = (all &gt;&gt; res) &lt;&lt; res ;</span><br><span class="line"><span class="keyword">if</span> (!val1)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">10</span> ; ++ i) <span class="built_in">cout</span> &lt;&lt; t[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t.count() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            t |= below[i] ;</span><br><span class="line">ans &amp;= t ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)ans.count()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"></span><br><span class="line">vint s[<span class="number">36</span>] ;</span><br><span class="line"></span><br><span class="line">vdb Lr[<span class="number">36</span>] ;</span><br><span class="line">vdb Rr[<span class="number">36</span>] ;</span><br><span class="line"></span><br><span class="line">pint base[N] ;</span><br><span class="line"></span><br><span class="line">pint line[<span class="number">10</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">getsec</span><span class="params">(<span class="keyword">const</span> pint &amp;x, <span class="keyword">const</span> pint &amp;y)</span></span>&#123;</span><br><span class="line">    db d1 = x.fr - y.fr ;</span><br><span class="line">    db d2 = x.sc - y.sc ;</span><br><span class="line">    <span class="keyword">if</span> (!d1) <span class="keyword">return</span> x.fr ;</span><br><span class="line">    db k = (d2 / d1) ;</span><br><span class="line">    <span class="keyword">return</span> (k * x.fr - x.sc) / k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_mask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x ? <span class="number">-1</span> : <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">do_do</span><span class="params">(<span class="keyword">const</span> pint &amp;d, <span class="keyword">int</span> num, <span class="keyword">const</span> vdb &amp;L, <span class="keyword">const</span> vdb &amp;R)</span></span>&#123;</span><br><span class="line">    db lc = <span class="number">-1e18</span>, rc = <span class="number">1e18</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : s[num])&#123;</span><br><span class="line">        chkmax(lc, getsec(d, line[k][<span class="number">0</span>])) ;</span><br><span class="line">        chkmin(rc, getsec(d, line[k][<span class="number">1</span>])) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; lc &lt;&lt; " " &lt;&lt; rc &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">int</span> l = lower_bound(R.begin(), R.end(), rc) - R.begin() ;</span><br><span class="line">    <span class="keyword">int</span> r = upper_bound(L.begin(), L.end(), lc) - L.begin() ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; num &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>, (r - <span class="number">1</span>) - (l - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i].fr = qr(), base[i].sc = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        line[i][<span class="number">0</span>].fr = qr() ;</span><br><span class="line">        line[i][<span class="number">1</span>].fr = qr() ;</span><br><span class="line">        line[i][<span class="number">0</span>].sc = line[i][<span class="number">1</span>].sc = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt; (<span class="number">1</span> &lt;&lt; m) ; ++ o)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>) &amp; o) s[o].p_b(i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> chk = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : s[o])</span><br><span class="line">                chk &amp;= (line[k][<span class="number">0</span>].sc &lt; base[i].sc) ;</span><br><span class="line">            <span class="keyword">if</span> (!chk) <span class="keyword">continue</span> ;</span><br><span class="line">            db l = <span class="number">-1e18</span>, r = <span class="number">1e18</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : s[o])&#123;</span><br><span class="line">                chkmax(l, getsec(base[i], line[k][<span class="number">0</span>])) ;</span><br><span class="line">                chkmin(r, getsec(base[i], line[k][<span class="number">1</span>])) ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          cout &lt;&lt; o &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) Lr[o].p_b(l), Rr[o].p_b(r) ;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(Lr[o].begin(), Lr[o].end()) ;</span><br><span class="line">        sort(Rr[o].begin(), Rr[o].end()) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; Lr[o].size() &lt;&lt; " " &lt;&lt; Rr[o].size() &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        ans = n ;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        pint now = make_pair(x, y) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt; (<span class="number">1</span> &lt;&lt; m) ; ++ o)</span><br><span class="line">            ans += get_mask(s[o].size() &amp; <span class="number">1</span>) * do_do(now, o, Lr[o], Rr[o]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="A-M-P-M"><a href="#A-M-P-M" class="headerlink" title="A.M.~P.M."></a>A.M.~P.M.</h1><p><del>这个H1意思是上下午时间混着打的</del></p><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><p>大概就是暴力贪心。根据 $2^k&gt;\sum _{j&lt;k} 2^j$ 可以知道从最高位开始贪心一定没问题。秒了秒了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ; </span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> head[MAXN], cnt ; LL ans ;</span><br><span class="line"><span class="keyword">int</span> N, L[MAXN], R[MAXN], P[MAXN], A[MAXN], vis[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsp</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="keyword">return</span> ; </span><br><span class="line">P[++ P[<span class="number">0</span>]] = u ;</span><br><span class="line">dfsp(L[u]), dfsp(R[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsa</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line">dfsa(L[u]), dfsa(R[u]) ;</span><br><span class="line">A[++ A[<span class="number">0</span>]] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!a) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">(res *= a) %= Mod ;</span><br><span class="line">(a *= a) %= Mod, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j, u, v ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), L[i] = u, R[i] = v ;</span><br><span class="line">dfsp(<span class="number">1</span>), dfsa(<span class="number">1</span>) ; <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, j = N - <span class="number">1</span> ; i &lt;= N ; ++ i, -- j)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[A[i]] &gt; <span class="number">-1</span> &amp;&amp; vis[P[i]] &gt; <span class="number">-1</span>) </span><br><span class="line">(ans += expow(<span class="number">2</span> * vis[P[i]], j) - expow(<span class="number">2</span> * vis[A[i]], j) + Mod) %= Mod ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[P[i]] &gt; <span class="number">-1</span>) vis[A[i]] = <span class="number">0</span>, (ans += expow(<span class="number">2</span> * vis[P[i]], j)) %= Mod ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[A[i]] &gt; <span class="number">-1</span>) vis[P[i]] = <span class="number">1</span>, (ans += expow(<span class="number">2</span> * vis[P[i]], j) - expow(<span class="number">2</span> * vis[A[i]], j)) %= Mod ; </span><br><span class="line"><span class="keyword">else</span> vis[A[i]] = <span class="number">0</span>, vis[P[i]] = <span class="number">1</span>, (ans += expow(<span class="number">2</span> * vis[P[i]], j) - expow(<span class="number">2</span> * vis[A[i]], j)) %= Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ((ans % Mod) + Mod) % Mod &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>美团杯测试赛的 A。挺好一题，不再多说了。</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>咕咕咕咕咕。</p><h1 id="P-M"><a href="#P-M" class="headerlink" title="P.M."></a>P.M.</h1><h2 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h2><h3 id="Sol-1-我的做法"><a href="#Sol-1-我的做法" class="headerlink" title="Sol 1 我的做法"></a>Sol 1 我的做法</h3><p>考虑贪心着去做。首先不难发现子树之前独立，因为 Alice 肯定会选一棵最优的子树，如果 Alice 选择了某棵子树，她还需要再走回根的话显然不优。一开始想的直接拿每个点孩子中的叶子个数 $s(x)$ 和深度 $dep(x)$ 比一下，后来发现如果某个比较浅的地方有叶子的话，Bob 是一定要堵的，所以这部分Bob浪费的步数也要算上。</p><p>挂了一发后发现…原来 Bob 才是先手(smwy)。然后自己想的是一定会挑一个 $s(x)$ 尽量大且 $dep(x)$ 尽量小的叶子删掉。冷静了一会儿发现这并不是最优的策略。最优的策略应该是 Bob 预测到了 Alice 会怎么走并删除 Alice 路径上的某个关键叶子。于是就应该拿 $dep(x)$ 和 $s(x)-1$ 比较。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> leaf[N] ;</span><br><span class="line"></span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        dep[k] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        dfs(k) ; sum[x] += leaf[k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!E[x].size()) leaf[x] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[x] + k &gt; dep[x] + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Y"</span>) ; <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])</span><br><span class="line">        <span class="keyword">if</span> (!leaf[y]) dfs(y, k + sum[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> x, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        x = qr(), E[x].p_b(i) ; dfs(<span class="number">1</span>) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"D"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="Sol-2-std-的做法"><a href="#Sol-2-std-的做法" class="headerlink" title="Sol 2 std 的做法"></a>Sol 2 std 的做法</h3><p>说实话这种做博弈的思路我还是真没怎么见过。考虑直接 $dp$ 。设 $f_u$ 表示考虑了以 $u$ 为根的子树，Bob 要获胜的话需要<strong>提前操作多少次</strong>。那么会有转移</p><script type="math/tex; mode=display">\begin{cases}f_u=1&u~\mathrm{is~a~leaf}\\f_u=\max\{-1+\sum f_{v},0\}&\rm{otherwise}\end{cases}</script><p>因为 Bob 至少要把所有叶子都删掉，且可以提前操作一次。最后如果 $f_1=0$ 那么Bob 必胜。</p><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><p>谔谔题。考虑随便选 $k$ 个点组成的凸包点编号可能不连续，所以正着做很难，于是考虑反着做，维护被删掉的面积。具体的，可以用三角剖分求出任意一段连续编号 $[i,j]$ 之间的多边形面积 ${\rm S}_{i,j}$ 。然后删掉它的多边形方案数就是 $\binom{n-(j-i+1)}{k-2}$ 。然后加一遍就好了。</p><p>不过我认为这题的亮点在于卡常。这题由于涉及到 $5e3$ 级别的的组合数，精度很难保证。全开 long double 时间会很爆炸 。于是考虑这么几条卡常攻略：</p><p>1、$\binom{n}{k-2}$ 可以线性暴力算。</p><p>2、用 $\binom{n}{k}=\binom{n-1}{k}\cdot \frac{n}{n-k}$ 来算出所有的 $\binom{n-(j-i+1)}{k-2}$ 。</p><p>3、除法和三角剖分乘 $0.5$ 什么的可以最后一起算。</p><p>然后大概就能快个三倍左右。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ldb x ;</span><br><span class="line">    ldb y ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line">ldb ans ;</span><br><span class="line">ldb sum ;</span><br><span class="line"><span class="comment">//ldb fac[N] ;</span></span><br><span class="line"><span class="comment">//ldb inv[N] ;</span></span><br><span class="line">ldb pks[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"><span class="comment">//db comb[N][N] ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ldb binom(int x, int y)&#123; return fac[x] / fac[y] / fac[x - y] ; &#125;</span></span><br><span class="line"><span class="keyword">inline</span> db <span class="keyword">operator</span> * (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)&#123; <span class="keyword">return</span> (a.x * b.y - a.y * b.x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    pks[m - <span class="number">2</span>] = <span class="number">1.0</span> ; sum = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        pks[i] = pks[i - <span class="number">1</span>] * (ldb)i / (ldb)(i - m + <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sum = sum / (ldb)i * (ldb)(n - i + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%Lf%Lf"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i + n] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= i + n - <span class="number">1</span> ; ++ j)</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] + base[j - <span class="number">1</span>] * base[j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= i + n - <span class="number">1</span> ; ++ j)</span><br><span class="line">            f[i][j] = <span class="built_in">fabs</span>(f[i][j] + base[j] * base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n - m + i + <span class="number">1</span> ; ++ j)</span><br><span class="line">            ans += f[i][j] * pks[n - (j - i + <span class="number">1</span>)] ;</span><br><span class="line">    ans = f[<span class="number">1</span>][n] - ans / sum ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10Lf"</span>, <span class="number">0.5</span> * ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>这题是真的有趣。</p><blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p><p>$1\leq n\leq 2\times10^5$ 。</p></blockquote><p>orz 又是找性质…又是找性质…怎么又是找性质Qaq</p><p>考虑 $35$ 分暴力怎么做。设 $f_i$ 表示前 $i$ 根弦都被删除的最小代价。考虑转移。考虑怎样的转移会合法，那必然是 $j$ 和 $i$ 把 $[i,j]$ 之间所有弦都给删掉才算合法。那么不难决策点 $j_1,j_2,j_3\cdots j_k$  一定满足这种性质：</p><script type="math/tex; mode=display">(1)\quad i>j_1>j_2>j_3>\cdots >j_k\\(2)\quad p(j_1)<p(j_2)<p(j_3)<\cdots <p(j_k)<p(i)</script><p>首先不难知道，如果一条弦会被 $i$ 割掉，那么拿他转移一定不会优。因此只有当一条比较远的弦可以把比较近的所有决策点都割掉，前 $i$ 条弦才都可以被割掉。那么就可以 $O(n^2)$ dp了。</p><p>同时注意到有一档部分分是说 $|i-p_i|\leq 5$ 。据此可以知道决策点数量一定不会太多。于是这部分就比较玄学，可以只扫 $|i-j|&lt;20$ 的所有 $j$ 来转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//55pts</span></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        rev[pos[i] = qr()] = i ; f[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">rev[n + <span class="number">1</span>] = pos[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, mx = <span class="number">0</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3000</span> &amp;&amp; i - j &gt;= <span class="number">16</span>) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (pos[j] &gt;= mx &amp;&amp; pos[j] &lt; pos[i])</span><br><span class="line">                mx = pos[j], chkmin(f[i], base[i] + f[j]) ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//for (int j = pos[i] - 1, k = 0 ; j &gt;= 0 ; -- j)</span></span><br><span class="line"><span class="comment">//            if (rev[j] &gt;= k &amp;&amp; rev[j] &lt; i)</span></span><br><span class="line"><span class="comment">//                chkmax(k, rev[j]), chkmin(f[i], base[i] + f[rev[j]]) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是错误的瞎 bb。</p><blockquote><p>然后这个 $100$ 分就十分的强。首先来考虑，这些决策点之间并不连续，很难用数据结构维护。但是我们可以观察对于每个 $i$ 的决策点的数量和。考虑这个值一定有一个下界，这个下界本质上就是</p><blockquote><p>$\{p_n\}$ 是一个 $1\sim n$ 的排列。求</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^{i-1}\left[p_j\in\left(\max_{k=j+1}^{i-1}\{p_k\}, p_i\right)\right]</script><p>其中 $(l,r)$ 表示一段连续的值域。</p></blockquote><p>直观的感受是，似乎不是很大？因为如果 $\sqrt n$ 分块去卡的话也只会卡到 $n$ 左右。仔细观察的话可以发现——<strong>每个 $j$ 只会产生至多 $1$ 的贡献</strong>。原因是每个 $j$ 的贡献都只会被算到后面的第一个 $i$ 上。</p><p>所以可以每次询问暴力所有的决策点，在一个线段树上用 $\max\{p_i\}$ 二分一下就好了。复杂度 $O(n\log ^2 n)$ 。</p></blockquote><p>为什么错呢？因为这！根！本！就！不！是！他！的！上！界！。注意到 max 取得不是所有 j+1~i 而是合法的 j+1~i。所以这个上界根本不对。那么问题大概就是这样的：</p><blockquote><p>大概就是许多人这题复杂度写的是不对的…写法大概是线段树上只维护 p[i] 的区间最大值，询问的时候根据这个在线段树上二分。但这个二分是假的，复杂度是 $O(\sum (\zeta(i))\cdot \rm poly\log)$，其中 $\zeta(i)$ 是 $i$ 的决策点个数。那也就是说大概是如下程序的 $cnt$ 值乘上一个 $\rm polylog$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, mx = <span class="number">0</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">   <span class="keyword">if</span> (pos[j] &gt;= mx &amp;&amp; pos[j] &lt; pos[i])</span><br><span class="line">       mx = pos[j], ++ cnt ;</span><br></pre></td></tr></table></figure><p>然后这个复杂度是显然不对的。考虑将题目中的 $\{p_n\}$ 按照这种方式生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&#x2F;2,n&#x2F;2-1,n&#x2F;2-2 … 1,n,n-1,n-2 … n&#x2F;2+1</span><br></pre></td></tr></table></figure><p>那么就可以轻易被卡到 $n^2$ 。</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1WeQD6qsORfyUmX6LeONuRw" target="_blank" rel="noopener">https://pan.baidu.com/s/1WeQD6qsORfyUmX6LeONuRw</a>  密码:ua1f</p></blockquote><p><del>由于不会写 Validator 所以大家可以自行测一下自己的程序</del></p><p>不过在不特别卡的情况下，这个 $cnt$ 会是 $O(n\ln n)$ 的级别。据 mls 说是跟单调栈在每个位置的期望长度之和是一个界。这也是为什么这些错解能过掉的原因。</p></blockquote><p>= = 这就很狗。</p><p>所以正确的写法应该是合并的时候将 $dp$ 值一起合并进去。这样 update 的时候就是 $\log ^2$ 的了。最后总复杂度 $O(n\log ^2n)$ 。</p><p>仔细分析一下细节，其实本质上跟「兔队线段树」里面讲的内容差不多。考虑维护这样两个值：该节点的总贡献，和考虑了该节点右子树后该节点左子树的贡献。那么由于每个右子树都会对左子树产生不同程度的影响，所以我们本质上只关心第二个值，第一个值只会起辅助作用。然后是每个函数的细节：</p><p>0、考虑对着 $p_i$ 建立线段树，每个点维护键值 $i$ 和权值 $dp_i$ 。</p><p>1、<code>query</code> 。大概就是考虑必然是要先进右子树再进左子树。最后会返回一个 <code>calc(root,l,r,limx)</code> 的函数。</p><p>2、<code>update</code>。只需要考虑在 <code>push_up</code> 的时候，先计算在右子树影响下左子树的贡献，然后和右子树的贡献合并就好了。</p><p>3、考虑 <code>calc</code> 函数本质上是在计算在 <code>limx</code> 这个限制的影响下以 <code>root</code> 为根的子树的贡献。注意到由于维护了一个「考虑了该节点右子树的影响后该节点左子树的贡献」，可以知道如果当前的最大的 $j$ 满足 $j\gt \max_{j’\in rchild} j’$，那么就只需要关心右子树中的贡献，就可以递归进右子树并类加上 $lchild$ 的贡献；否则进入左子树。</p><p>感觉比较精妙的地方就在于维护了一个「考虑了该节点右子树的影响后该节点左子树的贡献」，这样就可以直接在线段树上进行复杂度正确的二分了。</p><div><div class="fold_hider"><div class="close hider_title">「复杂度不对的代码」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f_now ;</span><br><span class="line"><span class="keyword">int</span> now_mx ;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> seg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg[rt] &lt; now_mx) <span class="keyword">return</span> Inf ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now_mx = seg[rt], val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">int</span> ret = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (seg[rc] &gt; now_mx) ret = calc(rc, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">if</span> (seg[lc] &gt; now_mx) chkmin(ret, calc(lc, l, mid)) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> limx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= limx)</span><br><span class="line">        <span class="keyword">return</span> calc(rt, l, r) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ret = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (limx &gt; mid) ret = qry(rc, mid + <span class="number">1</span>, r, limx) ;</span><br><span class="line">    chkmin(ret, qry(lc, l, mid, limx)) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> po, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> seg[rt] = v1, <span class="keyword">void</span>(val[rt] = v2) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (po &lt;= mid) upd(lc, l, mid, po, v1, v2) ;</span><br><span class="line">    <span class="keyword">else</span> upd(rc, mid + <span class="number">1</span>, r, po, v1, v2) ;</span><br><span class="line">    seg[rt] = max(seg[lc], seg[rc]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            rev[pos[i] = qr()] = i ; f[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        rev[n + <span class="number">1</span>] = pos[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, mx = <span class="number">0</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">3000</span> &amp;&amp; i - j &gt;= <span class="number">16</span>) <span class="keyword">break</span> ;</span><br><span class="line">                <span class="keyword">if</span> (pos[j] &gt;= mx &amp;&amp; pos[j] &lt; pos[i])</span><br><span class="line">                    mx = pos[j], chkmin(f[i], base[i] + f[j]) ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//    for (int j = pos[i] - 1, k = 0 ; j &gt;= 0 ; -- j)</span></span><br><span class="line"><span class="comment">//                if (rev[j] &gt;= k &amp;&amp; rev[j] &lt; i)</span></span><br><span class="line"><span class="comment">//                    chkmax(k, rev[j]), chkmin(f[i], base[i] + f[rev[j]]) ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pos[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">127</span>, <span class="keyword">sizeof</span>(val)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) pos[i] = qr() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">            f_now = qry(<span class="number">1</span>, <span class="number">1</span>, n + <span class="number">1</span>, pos[i]) ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; i &lt;&lt; " " &lt;&lt; f_now &lt;&lt; '\n' ;</span></span><br><span class="line">            f[i] = base[i] + (f_now &gt;= Inf ? <span class="number">0</span> : f_now) ;</span><br><span class="line">            upd(<span class="number">1</span>, <span class="number">1</span>, n + <span class="number">1</span>, pos[i], i, f[i]), now_mx = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; f[i] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">「复杂度正确的代码」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ycy make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line">pint f_now ;</span><br><span class="line">pint ept_val ;</span><br><span class="line">pint zero_val ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line">pint val[N * <span class="number">3</span>] ;</span><br><span class="line">pint lval[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x &gt; y ? x : y ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">mn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x &lt; y ? x : y ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il pint <span class="title">merge</span><span class="params">(<span class="keyword">const</span> pint &amp;x, <span class="keyword">const</span> pint &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ycy( mx(x.fr, y.fr), mn(x.sc, y.sc) ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il pint <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> pint &amp; now)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; ' ' &lt;&lt; now.fr &lt;&lt; ' ' &lt;&lt; now.sc &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (val[rt].fr &lt;= now.fr) <span class="keyword">return</span> ept_val ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (now.fr &lt; val[rc].fr)</span><br><span class="line">         <span class="keyword">return</span> merge(lval[rt], solve(rc, mid + <span class="number">1</span>, r, now)) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(lc, l, mid, now) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lval[rt] = solve(lc, l, mid, val[rc]) ;</span><br><span class="line">    val[rt] = merge(lval[rt], val[rc]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> po, <span class="keyword">const</span> pint &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(val[rt] = v) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (po &lt;= mid) upd(lc, l, mid, po, v) ;</span><br><span class="line">    <span class="keyword">else</span> upd(rc, mid + <span class="number">1</span>, r, po, v) ;</span><br><span class="line">    push_up(rt, l, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> po)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt;  " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= po)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(f_now = merge(f_now, solve(rt, l, r, f_now))) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; po) qry(rc, mid + <span class="number">1</span>, r, po) ;</span><br><span class="line">    qry(lc, l, mid, po) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    pos[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">    ept_val = ycy(<span class="number">-1</span>, Inf) ;</span><br><span class="line">    zero_val = ycy(<span class="number">2333</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) pos[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n * <span class="number">3</span> ; ++ i)</span><br><span class="line">        val[i] = ept_val, lval[i] = ept_val ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">        f_now = ept_val ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">        qry(<span class="number">1</span>, <span class="number">1</span>, n, pos[i]) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span> (f_now == ept_val)</span><br><span class="line">            f_now = zero_val ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">        f[i] = base[i] + f_now.sc ;</span><br><span class="line">        upd(<span class="number">1</span>, <span class="number">1</span>, n, pos[i], ycy(i, f[i])) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(f, 1, n + 1) ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>有有有点吓人。理论复杂度正确的代码居然比不正确的慢 $1000ms+$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下今天的三场比赛，又懒得搬题面了。&lt;/p&gt;
&lt;p&gt;如果想要题面可以 QQ 戳我，我觉得你可爱就给你啦。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="计算几何/三角剖分" scheme="https://www.orchidany.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="计算几何/基础的点、直线与圆" scheme="https://www.orchidany.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%9F%BA%E7%A1%80%E7%9A%84%E7%82%B9%E3%80%81%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%9C%86/"/>
    
  </entry>
  
  <entry>
    <title>【训练纪录】6.1 训练笔记</title>
    <link href="https://www.orchidany.cn/2020/06/01/6-1%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/06/01/6-1训练笔记/</id>
    <published>2020-06-01T12:18:14.000Z</published>
    <updated>2020-06-02T23:35:14.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下今天的两场比赛。懒得搬题面了。</p><a id="more"></a><h1 id="A-M"><a href="#A-M" class="headerlink" title="A.M."></a>A.M.</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>一开始写这题，在一眼二分之后摸了很久。原因是我觉得两个圆合并起来应该等效于一个大圆。写了一会儿挂了就去 Geogebra 上模拟了一组手捏的小样例发现自己假了= =</p><p>然后发现似乎本质上就是一个奶酪，于是就写了个 $k^2$ 的并查集去 check，喜提 $75$ 分。想了想觉得 $k^2\log V$ 大概过不去 $k=7000$ 就去搞 T2 了。</p><p>然后考虑满分。大概是首先把上下边界也作为点加进去。根据二分 check 的过程，是每次二分出一个半径然后把该半径下相交的圆都连边，然后去判断上下边界是否在一个 dsu 里，换句话说就是去 check 上下边界之间的所有路径中，是否存在一条路径的最长边小于二分出的 $v$ 。发现有单调性，只关心较小的那些边。于是就转化成求 MST，然后找一下 $k+1,k+2$ 之间的边权最大值即可。</p><p>MST 需要用 Prim (话说这还是我第一次写 Prim，根据百度百科 yy 出来的，感觉挺ez)，因为本题是十分稠密的稠密图。</p><p>最后复杂度 $O(n^2)$，不知道为什么自己常数过大导致不能显式建边= =</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">db ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">db mx[N] ;</span><br><span class="line">db mn[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line">db A[N][N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Planet</span>&#123;</span></span><br><span class="line">    db x ; db y ; db r ;</span><br><span class="line">    Planet (db a = <span class="number">0</span>, db b = <span class="number">0</span>, db c = <span class="number">0</span> )&#123; x = a, y = b, r = c ; &#125;</span><br><span class="line">&#125;base[N], crs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">        fa[f1] = f2 ;</span><br><span class="line">        mn[f2] = min(mn[f1], mn[f2]) ;</span><br><span class="line">        mx[f2] = max(mx[f1], mx[f2]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Planet &amp;A, <span class="keyword">const</span> Planet &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x == B.x ? A.y &lt; B.y : A.x &lt; B.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">dist</span><span class="params">(db a, db b, db c, db d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a - c) * (a - c) + (b - d) * (b - d)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Planet &amp;A, <span class="keyword">const</span> Planet &amp;B, db r)</span></span>&#123;</span><br><span class="line">    db ds = dist(A.x, A.y, B.x, B.y) ;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(ds &lt;= r + r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(db r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        fa[i] = i, mx[i] = mn[i] = base[i].y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (cross(base[i], base[j], r))</span><br><span class="line">                merge(i, j) ;</span><br><span class="line">    <span class="comment">//debug(r), debug(fa, 1, k) ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; mx[4] &lt;&lt; " " &lt;&lt; mn[4] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (mx[find(i)] + r &gt;= m - r &amp;&amp; mn[find(i)] - r &lt;= r) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">vint E[N] ;</span><br><span class="line">db val[N] ;</span><br><span class="line">db cost[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> done[N] ;</span><br><span class="line"><span class="keyword">int</span> minv[N] ;</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= k - <span class="number">1</span>) base[b].x = base[a].x ;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= k - <span class="number">1</span>) base[a].x = base[b].x ;</span><br><span class="line">    <span class="keyword">return</span> dist(base[a].x, base[a].y, base[b].x, base[b].y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    done[++ cnt] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        cost[i] = dis(<span class="number">1</span>, i), minv[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; k)&#123;</span><br><span class="line">        db cst = <span class="number">1e18</span> ; <span class="keyword">int</span> id = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &lt; cst)</span><br><span class="line">                cst = cost[id = i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        E[id].p_b(minv[id]) ;</span><br><span class="line">        E[minv[id]].p_b(id) ;</span><br><span class="line">        done[++ cnt] = id ; vis[id] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &gt; dis(id, i))</span><br><span class="line">                cost[i] = dis(id, i), minv[i] = id ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; val[x] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d : E[x])</span><br><span class="line">        <span class="keyword">if</span> (d != fa)&#123;</span><br><span class="line">            val[d] = max(dis(x, d), val[x]) ; dfs(d, x) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        base[i].x = qr(), base[i].y = qr() ;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + k + <span class="number">1</span>, comp) ;</span><br><span class="line">        db l = <span class="number">0.0</span>, r = max(n, m), mid ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt; eps)&#123;</span><br><span class="line">            mid = (l + r) * <span class="number">0.5</span> ;</span><br><span class="line">            <span class="keyword">if</span> (check(mid))</span><br><span class="line">                ans = mid, l = mid + eps ;</span><br><span class="line">            <span class="keyword">else</span> r = mid - eps ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        base[++ k] = Planet(<span class="number">0</span>, m) ;</span><br><span class="line">        base[++ k] = Planet(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">        Prim() ; dfs(k - <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, <span class="number">0.5</span> * val[k]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>谔谔题。根据某「平面最近点对」可以知道，平面撒点一定程度上可以乱搞。然后去可以考虑二分一个答案，观察到上边界和有边界都是单调不降的，于是 check 的时候考虑直接暴力 check 直到凑齐 $n$ 个点。似乎一开始 random_shuffle 一次就很难被卡掉了。</p><p>std 是什么诡异的分类讨论贪心，这东西怎么会有正常人写= =</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, id ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> tr &amp; t)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.x == x ? t.y &lt; y : t.x &lt; x ; &#125;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">bool</span> nt ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll v, <span class="keyword">bool</span> ouf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span> ;</span><br><span class="line">    cnt = <span class="number">0</span>, nt = <span class="number">0</span> ;</span><br><span class="line">    fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        nt = <span class="number">0</span> ; <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; max(x, base[i].x) - x + max(y, base[i].y) - y &lt;= v)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ouf) <span class="built_in">printf</span>(<span class="string">"%d "</span>, base[i].id) ; vis[i] = <span class="number">1</span> ;</span><br><span class="line">                chkmax(x, base[i].x), chkmax(y, base[i].y), ++ cnt, nt = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">if</span> (!nt) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; ll l, r, mid ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i].x = qr(), base[i].y = qr(), base[i].id = i ;</span><br><span class="line">    random_shuffle(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    l = <span class="number">0</span>, r = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        debug(mid) ;</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid, <span class="number">0</span>))</span><br><span class="line">             ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(ans) ;</span></span><br><span class="line">    <span class="keyword">return</span> !check(ans, <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>结论题，并且结论还不容易猜= =</p><p>大概就是考虑这么一种操作，把一只放在中间的鞋子当作工具人，不难发现周围 4 个都可以被调整好，同理他们之前也可以作为工具人去调整别的。所以不难发现直接把所有相邻的左右鞋连边做一个二分图匹配或许是对的，因为可以把所有不在匹配里的点当做工具人。但是这个思路有个问题，就是如果跑出来的匹配是完美匹配怎么办？</p><p>首先不难知完美匹配时答案会是 $\dfrac{n\times m}{2}$ 或者 $\dfrac{n\times m}{2} -1$ 。然后 emmm。</p><p>然后就变得奇怪起来了。大概是考虑将鞋子的朝向设个权值 $0,1,2,3$ 分别表示左上右下。那么如果设匹配之后鞋子的朝向的权值和 $\rm S_1$ ，匹配之前的权值和为 $\rm S_0$ ，那么如果这个匹配是完美匹配且成立，那么需要满足 </p><script type="math/tex; mode=display">\rm S_0\equiv S_1\pmod 4</script><p>证明的话考虑 1、完美匹配彼此之间一定是对 $4 $ 取模同余的。2、任意权值和模 $4$ 同余的状态两两可达。然后因为懒于是就直接放题解图片了= =</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>这种题到底该怎么做啊？考场上现证一遍？我寻思着这一点也不好猜啊 QAQ</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> re1 ;</span><br><span class="line"><span class="keyword">int</span> re2 ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> mat[M] ;</span><br><span class="line"><span class="keyword">int</span> vis[M] ;</span><br><span class="line"><span class="keyword">int</span> Id[N][N] ;</span><br><span class="line"><span class="keyword">int</span> isleft[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[M] ;</span><br><span class="line"><span class="keyword">char</span> T[M] ;</span><br><span class="line"></span><br><span class="line">vint E[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[k]) <span class="keyword">continue</span> ; vis[k] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!mat[k] || do_match(mat[k]))</span><br><span class="line">            <span class="keyword">return</span> mat[x] = k, mat[k] = x, <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            Id[i][j] = ++ cnt ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (S[j] == <span class="string">'L'</span>) isleft[i][j] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((isleft[i][j] ^ isleft[i + <span class="number">1</span>][j]) &amp;&amp; i + <span class="number">1</span> &lt;= n)</span><br><span class="line">                E[Id[i][j]].p_b(Id[i + <span class="number">1</span>][j]), E[Id[i + <span class="number">1</span>][j]].p_b(Id[i][j]) ;</span><br><span class="line">            <span class="keyword">if</span> ((isleft[i][j] ^ isleft[i][j + <span class="number">1</span>]) &amp;&amp; j + <span class="number">1</span> &lt;= m)</span><br><span class="line">                E[Id[i][j]].p_b(Id[i][j + <span class="number">1</span>]), E[Id[i][j + <span class="number">1</span>]].p_b(Id[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                fill(vis + <span class="number">1</span>, vis + cnt + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                ans += do_match(Id[i][j]) ; <span class="comment">//debug(ans) ;</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (n * m &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(ans) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (T + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[j] == <span class="string">'L'</span>) ++ re1 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (T[j] == <span class="string">'U'</span>) re1 += <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (T[j] == <span class="string">'R'</span>) re1 += <span class="number">3</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (T[j] == <span class="string">'D'</span>) re1 += <span class="number">4</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ( ((i + j) &amp; <span class="number">1</span>) &amp;&amp; (mat[Id[i][j]] == Id[i - <span class="number">1</span>][j] || mat[Id[i][j]] == Id[i + <span class="number">1</span>][j])) re2 += <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (re1 % <span class="number">4</span> == re2 % <span class="number">4</span> || ans != n * m / <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="P-M"><a href="#P-M" class="headerlink" title="P.M."></a>P.M.</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><p>真 · 找性质题。可能是因为 dls 也觉得纯找性质太无聊了就给了暴力 $50$ 。</p><p>感觉做这题的时候就是发现，自己归纳的能力不太行。对于一些现象很难给出一般化的结论。如果再来个什么分类讨论之类的就彻底歇菜了。</p><p>1、如果存在 $\geqslant 2$ 个人是自己的超集那就没救了。</p><p>2、如果存在恰好 $1$ 个人是自己的超集那么就一定有解。</p><p>以上两点因为比较水所以当时想到了，但是由于多测所以并没啥用。</p><p>然后考虑直接去枚举第一名 $i$。然后考虑如果设自己为 $k$，对于一个其他人 $j$ 满足 </p><script type="math/tex; mode=display">s_k\cap s_i \neq s_k\cap s_j</script><p>那么这些 $j$ 就一定可以被放到后面。这是个很强的性质，也比较好推。接着考虑那些 $s_k\cap s_i = s_k\cap s_{j’}$ 的 $j’$ 。发现如果存在某一道题 $o$ 是自己没做过且 $j’$ 都没做过的，那么就有一组合法解，否则无论怎样也找不到合法解。</p><p>于是就可以暴力判了。复杂度 $O\left(\dfrac{n^2\times m}{w}\right)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> mxp ;</span><br><span class="line"><span class="keyword">int</span> val ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">char</span> In[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; base ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; otr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> buc[a] &gt; buc[b] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; (In + <span class="number">1</span>) ; </span><br><span class="line">val = <span class="number">0</span> ; -- n ; base.reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            base[i] = (<span class="keyword">bool</span>)(In[i] == <span class="string">'Y'</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ; otr[i].reset() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">                otr[i][j] = (<span class="keyword">bool</span>)(In[j] == <span class="string">'Y'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> ((base &amp; otr[i]) == base) ++ val ;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= <span class="number">2</span>) <span class="keyword">goto</span> NO ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= <span class="number">1</span>) <span class="keyword">goto</span> YES ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; cap, res ; </span><br><span class="line">res.reset(), cap = base &amp; otr[i] ; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; (otr[j] &amp; cap) == cap) res = res | otr[j] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!base[j] &amp;&amp; otr[i][j] &amp;&amp; !res[j]) <span class="keyword">goto</span> YES ;</span><br><span class="line">        &#125;</span><br><span class="line">        NO : <span class="built_in">puts</span>(<span class="string">"NO"</span>) ; <span class="keyword">continue</span> ;</span><br><span class="line">        YES : <span class="built_in">puts</span>(<span class="string">"YES"</span>) ; <span class="keyword">continue</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>唉，自己 dp 真是菜的可怜。和找性质结合起来就挂了。</p><p>设 $f_{l,r,0/1}$ 表示已经走完了 $l\sim r$ 这个区间，当前在 $l/r(0/1)$ 时，走完 $[1,n]$ 最少还需要多少个砖块。那么考虑转移。首先一个观察，根据贪心我们是不会留箱子的，一定是恰好放到墙的高度 。那么考虑从 $l-1,r$ 转移到 $l,r$ ，发现有转移</p><script type="math/tex; mode=display">f_{l,r,0}=\max\{f_{l-1,r,0},h_l-rs(l,r)\}</script><p>其中 $rs(l,r)$ 是在走完 $(l,r)$ 可以剩下多少石块。意思是首先至少要 $f_{l-1,r,0}$ 这么多，其次也必须要可以跨过 $h_l$ 这堵墙。同时这种 $0/1$ 判断方位的还会有转移</p><script type="math/tex; mode=display">f_{l,r,1}\to f_{l,r,0}</script><p>但是不一定能走过去。这部分可以考虑枚举一个最初携带的石块个数 $t$ 然后模拟，这样转移就是 $O(n)$ 的。但是也可以通过观察发现是需要</p><script type="math/tex; mode=display">\max_{i\in[l,r-1]}\{h_i\}-rst(l,r)</script><p>的石块就可以了。原因是考虑每次默认把所站在的端点处的石块拿在身上，这样就相当于从 $0$ 开始要爬过 $\max h$ 至少需要的石块量。</p><p>同时可以发现，$l\to r$ 和 $r \to l$ 本质相似，因为墙还是那些墙，只是换了个方向经过而已。</p><p>于是最后复杂度 $O(n^2)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> s1[N] ;</span><br><span class="line"><span class="keyword">int</span> s2[N] ;</span><br><span class="line"><span class="keyword">int</span> blk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> mx[N][N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + (base[i] = qr()) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        s2[i] = s2[i - <span class="number">1</span>] + (blk[i] = qr()) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n ; ++ j)</span><br><span class="line">            mx[i][j] = max(mx[i][j - <span class="number">1</span>], blk[j]) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    f[<span class="number">1</span>][n][<span class="number">0</span>] = f[<span class="number">1</span>][n][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">int</span> rst ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span> ; l &lt;= n ; ++ l)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = n ; r &gt;= l ; -- r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; r == n) <span class="keyword">continue</span> ;</span><br><span class="line">            rst = s1[r] - s1[l - <span class="number">1</span>] - s2[r - <span class="number">1</span>] + s2[l - <span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; <span class="number">1</span>) chkmin(f[l][r][<span class="number">0</span>], max(f[l - <span class="number">1</span>][r][<span class="number">0</span>], blk[l - <span class="number">1</span>] - rst)) ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; n) chkmin(f[l][r][<span class="number">1</span>], max(f[l][r + <span class="number">1</span>][<span class="number">1</span>], blk[r] - rst)) ;</span><br><span class="line">            chkmin(f[l][r][<span class="number">0</span>], max(f[l][r][<span class="number">1</span>], mx[l][r - <span class="number">1</span>] - rst)) ;</span><br><span class="line">            chkmin(f[l][r][<span class="number">1</span>], max(f[l][r][<span class="number">0</span>], mx[l][r - <span class="number">1</span>] - rst)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, min(f[i][i][<span class="number">0</span>], f[i][i][<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><blockquote><p>给定一个 $n\times 3$ 的数表 $\{a\}$ 。初始时每个数都 $\leq m$ ，求至少修改多少个数可以使得</p><script type="math/tex; mode=display">\sum_{j=1}^{3} a_{i, j} \geq \sum_{j=1}^{3} a_{i+1, j}</script><p>对所有 $i\in[1,n-1]$ 成立。其中修改之后的数也要 $\in[0,m]\cap\mathbb{Z}$ 。</p><p>$1\leq n\leq 10^5,0\leq m\le 10^{10}$ 。</p></blockquote><p> 这题是真神w</p><p>一开始的时候十分懵圈，因为没有任何一档部分分是可以带着值域进行 dp。</p><p>那么首先给出一个推断：</p><blockquote><p>考虑每个位置的 $a_{i,j}$ 的和 $s_i$ ，修改完后的 $s_i$ 只会是第 $i$ 个位置修改 $0,1,2,3$ 次的值域区间的端点。</p></blockquote><p>感觉有点可以猜出来。大概是说反正横竖都是改，还不如改的标准点。然后考虑这样放在一起离散化一下，本质不同的状态就有 $O(7\times n)$ 个了。于是可以设 $f_{i,j}$ 表示考虑了前 $i$ 个位置，当前第 $i$ 个位置的 $s_i=j$ 且合法时的最小代价的是多少。那么考虑就有转移</p><script type="math/tex; mode=display">f_{i,j}=\min_{k\geqslant j}\{f_{i-1,k}\} + val(i,j)</script><p>其中 $val(i,j)$ 是把第 $i$ 个位置的和调整成 $j$ 的最小代价。于是这样就可以喜提 $50pts$  。</p><p>然后考虑满分。首先有两个 Observation：</p><p>1、 $f_{i,j}$ 一定是随着 $j\uparrow$ 而单调不降。既可以感性理解也可以打个表。</p><p>2、设 $[l_{i,k},r_{i,k}]$ 表示第 $i$ 个位置修改了 $k$ 次后的值域区间，不难发现有</p><script type="math/tex; mode=display">l_{i,3}\leq l_{i,2}\leq l_{i,1}\leq l_{i,0}=r_{i,0}\leq r_{i,1}\leq r_{i,2}\leq r_{i,3}</script><p>也就是说最终整个 $f_{i,j}$ 在取后缀最小值后加上的数会是这样：</p><script type="math/tex; mode=display">3,3,3\cdots2,2,2,\cdots 1,1,1\cdots1,0,1\cdots1,1,1\cdots2,2,2\cdots3,3,3</script><p>总共有 $7$ 段。其中后面 $4$ 段根据第一个观察可以知道可以直接暴力加(根据单调性转化成后缀加)，因为这不影响单调性。而前面几段可能会影响。考虑怎么修改前面几段，发现修改的次数少、量也少。于是可以对于每个不同的一段，二分出第一个加上 $1$ 之后不会比这一段的末尾 $+1$ 的位置的 $dp$ 值大的，当前段中那个关键位置 $p$ 来，然后进行 $1\sim p$ 的区间加。最后复杂度 $O(n\log n)\sim O(n\log ^2 n)$。</p><p>然后大概是要进行一个类似线段树上二分的操作。这个地方跟 <code>ymzqwq</code> 学了一下用的树状数组。大概是考虑首先把 $m$ 补齐成 $2^k$ 的形式，这样二分就可以直接加 $mid$ ，之后根据 BIT 的特性把问题翻转一下变成要在前缀里二分出一个位置来。实测常数比较优。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line">ll s[N] ;</span><br><span class="line">ll pd[M] ;</span><br><span class="line">ll dp[M] ;</span><br><span class="line">ll m, f[M] ;</span><br><span class="line">ll base[<span class="number">3</span>][N] ;</span><br><span class="line"></span><br><span class="line">vll tmp ;</span><br><span class="line">pll t[N][<span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= m ; p += (p &amp; -p)) _bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= (p &amp; -p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">    ins(l, <span class="number">1</span>), ins(r + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span> ; o &lt; <span class="number">3</span> ; ++ o)</span><br><span class="line">            base[o][i] = qr(), s[i] += base[o][i] ;</span><br><span class="line"><span class="comment">//    debug(base[0], 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        t[i][<span class="number">0</span>].fr = t[i][<span class="number">0</span>].sc = s[i] ;</span><br><span class="line">        t[i][<span class="number">1</span>].fr = <span class="number">3l</span>l *  m, t[i][<span class="number">1</span>].sc = <span class="number">0</span> ;</span><br><span class="line">        t[i][<span class="number">2</span>].fr = <span class="number">3l</span>l *  m, t[i][<span class="number">2</span>].sc = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)&#123;</span><br><span class="line">            chkmin(t[i][<span class="number">1</span>].fr, s[i] - base[j][i]) ;</span><br><span class="line">            chkmax(t[i][<span class="number">1</span>].sc, s[i] - base[j][i] + m) ;</span><br><span class="line">            chkmin(t[i][<span class="number">2</span>].fr, base[j][i]) ;</span><br><span class="line">            chkmax(t[i][<span class="number">2</span>].sc, <span class="number">2l</span>l * m + base[j][i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        t[i][<span class="number">3</span>].fr = <span class="number">0</span>, t[i][<span class="number">3</span>].sc = <span class="number">3l</span>l * m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">3</span> ; ++ j)</span><br><span class="line">            tmp.p_b(t[i][j].fr), tmp.p_b(t[i][j].sc) ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tmp.begin(), tmp.end()) ;</span><br><span class="line">    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end()) ;</span><br><span class="line">    len = <span class="keyword">int</span>(tmp.size()) ; <span class="comment">//debug(len) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">3</span> ; ++ j)&#123;</span><br><span class="line">            t[i][j].fr = lower_bound(tmp.begin(), tmp.end(), t[i][j].fr) - tmp.begin() + <span class="number">1</span> ;</span><br><span class="line">            t[i][j].sc = lower_bound(tmp.begin(), tmp.end(), t[i][j].sc) - tmp.begin() + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//            debug(t[i][j].fr, ' '), debug(t[i][j].sc, ' ') ;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(tmp, 0, len - 1, '\n') ;</span></span><br><span class="line"><span class="comment">//     ; debug(len) ;</span></span><br><span class="line">    m = <span class="number">1</span> ; <span class="keyword">while</span> (m &lt;= len) m &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; m &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="comment">//        debug(i) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (t[i][j].fr &gt;= <span class="number">1</span>) modify(<span class="number">1</span>, t[i][j].fr - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = qry(t[i][j].sc) ; <span class="comment">//cout &lt;&lt; pos &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = m, mid, res = <span class="number">0</span> ; ll now = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (now + _bit[mid] &gt;= pos)</span><br><span class="line">                     now += _bit[mid], res = mid, l = mid + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">            modify(res + <span class="number">1</span>, m) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        for (int j = 3 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">            for (int k = t[i][j].fr ; k &lt; t[i][j - 1].fr ; ++ k)</span></span><br><span class="line"><span class="comment">                dp[k] += j ;</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= 3 ; ++ j)</span></span><br><span class="line"><span class="comment">            for (int k = t[i][j - 1].sc + 1 ; k &lt;= t[i][j].sc ; ++ k)</span></span><br><span class="line"><span class="comment">                dp[k] += j ;</span></span><br><span class="line"><span class="comment">    for (int j = len - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">chkmin(dp[j], dp[j + 1]) ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//    debug(dp, 1, len) ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= m ; ++ i) cout &lt;&lt; qry(i) &lt;&lt; " " ;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; qry(len) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下今天的两场比赛。懒得搬题面了。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZROI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZROI/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="奇怪的技巧" scheme="https://www.orchidany.cn/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
      <category term="图论/最小生成树" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】网络流乱搞记录</title>
    <link href="https://www.orchidany.cn/2020/05/29/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9E%8E%E5%81%9A%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.orchidany.cn/2020/05/29/网络流瞎做记录/</id>
    <published>2020-05-29T05:53:26.000Z</published>
    <updated>2020-05-31T13:31:42.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了点网络流题目，算是对网络流的一个复习吧。</p><p>感觉现在建起图来已经可以算是得心应手了.jpg</p><p>打星的题目都比较有趣。大部分题目可能没有数据范围，当作 O(网络流能过) 就好了。</p><p><del>虽然现在都考模拟费用流，建图费用流已经是历史的眼泪了。</del> </p><a id="more"></a><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="UVA11167-Monkeys-in-the-Emei-Moutain"><a href="#UVA11167-Monkeys-in-the-Emei-Moutain" class="headerlink" title="*[UVA11167] Monkeys in the Emei Moutain"></a>*[UVA11167] Monkeys in the Emei Moutain</h2><blockquote><p>大概说有 $n$ 只猴子，猴子们在某个时间段需要喝 $v_i$ 时间的水，各个单位时间段最多允许 $m$ 只猴子同时喝水，问猴子们能否成功喝水并输出一个可行的方案，输出方案的时间段区间要从小到大排序并且合并连续的区间。</p><p>$1\leq l_i,r_i\leq 50000,n\leq 100$ 。</p></blockquote><p>考虑暴力建图，我一开始的思路是对于每个时间点拆成两个点 $t’,t$ 之间连 $f=m$ 的边，然后猴子 $i$ 向一个区间的点连 $f=+\infty$ 的边，源点向猴子连 $f=v_i$ 的边。这样边数可以通过线段树来搞成 $T\log T$ 的。</p><p>然而上面这个建图肉眼可见的不是正解。考虑向区间模型上靠，因为猴子数很少，最多有 $O(n)$ 个本质不同的区间端点。于是可以考虑把上面那种做法中没有用到的多个时间点合并成一个，并且把 $f=m$ 改成 $f=k\times m$ 。依旧做就好了。</p><h2 id="UVA11082-Matrix-Decompressing"><a href="#UVA11082-Matrix-Decompressing" class="headerlink" title="[UVA11082] Matrix Decompressing"></a>[UVA11082] Matrix Decompressing</h2><blockquote><p>给出一个 R 行C 列的正整数矩阵，设前 $A_i$ 项为其前 $i$ 行所有元素之和，$B_i$ 项为其前 i 列所有元素之和，已知 R,C,A,B，找出一个满足条件的矩阵。其中每个元素都是1~20 的正整数。</p></blockquote><p>sb 题。考虑源向每一行连 $f=r_i$ 的边，每一列向汇连 $f=c_i$ 的边，行列再向每个点连 $f=\infty$ 的边。同时给中间的每条边设置一个上下界 $1$ ，流就完了。</p><p>然后发现并不用建出中间的那一排点来。并且下界如果为 $1$ …就可以直接上下界各减 $1$ 然后跑普通的流即可。</p><h2 id="ACM-ICPC-NEERC2009-Inspection"><a href="#ACM-ICPC-NEERC2009-Inspection" class="headerlink" title="**[ACM/ICPC NEERC2009] Inspection"></a>**[ACM/ICPC NEERC2009] Inspection</h2><blockquote><p>求解无权 DAG 的最小路径<strong>边</strong>覆盖。特别的，路径可以重复走。</p></blockquote><p>很神奇一道题。神奇在我在 check 自己的 Sol 的时候发现了这么一回事：</p><blockquote><p>对于图中的每个点 $i$，设 $d_i$ 为( $i$ 的入度 - $i$ 的出度)的值，按照 $d_i$将图中的点分类：</p><p>$d_i\lt 0$ 的称为“入少出多”的点，$d_i\gt 0$ 的称为“出少入多”的点，$d_i=0$ 的称为“入出相等”的点。则有：</p><blockquote><p>定理：有向无环图中最小边路径覆盖的值等于图中所有“入少出多”的点的 $d_i$ 绝对值之和。 </p></blockquote></blockquote><p>这还是比较显然的，注意到这个定理是在陈述「边覆盖」就不难理解了。 然后借此先说 Sol 1:</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>考虑本题和不能重复走的最小路径覆盖有什么区别，那必然是存在一些路径可以重复经过。我断言，这样的路径必然满足起点 $d_i&gt;0$，终点的 $d_i\lt0$ ，否则没有必要重复经过。考虑某条这样的路径 $(s:t)$ 每被重复经过一次，就必然是为了将 $t$ 之后的某条路经和 $s$ 之前的某条路径拼插起来，这样原来需要 $2$ 次现在就只需要 $1$ 次。</p><p>于是考虑直接对着这个跑一次最大流即可，各个地方的流量都是 $1$ ，拿定理中的答案减去这个最大流就好了。</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>…发现这题就是一个带下界的最小流。于是就跑一个带下界的最小流即可。</p><h2 id="ACM-ICPC-NWERC-2007-March-of-the-Penguins"><a href="#ACM-ICPC-NWERC-2007-March-of-the-Penguins" class="headerlink" title="[ACM/ICPC NWERC 2007] March of the Penguins"></a>[ACM/ICPC NWERC 2007] March of the Penguins</h2><blockquote><p>有一群企鹅，一些冰。企鹅们在快乐地玩耍。</p><p>给出每个企鹅的最大跳跃距离(大家都一样)，再给出冰的坐标和上面存在的企鹅个数和允许跳跃的次数，问有哪些冰是可以将所有的企鹅汇聚起来的。</p></blockquote><p>比较简单一题。之前的想法是这么建图(事实上就是这么建图)：源点向每块冰连 $n_i$ 的边代表原有企鹅，每块冰拆成俩点限制跳跃次数。然后冰之间根据跳跃距离连边就好了。</p><p>但是自己的处理方式不是很到位。我的想法是枚举每个点作为汇点跑一遍最大流再去 check 是否满流，后来发现其实并不需要，只需要一个跑一遍最大流就好了。因为如果对于某个 $i$ 满流，他要么可以将这一份满流输送给其他点，要么就是被其他点数输送过来的。</p><h2 id="ACM-ICPC-Hangzhou-2005-Duopoly"><a href="#ACM-ICPC-Hangzhou-2005-Duopoly" class="headerlink" title="*[ACM/ICPC Hangzhou 2005] Duopoly"></a>*[ACM/ICPC Hangzhou 2005] Duopoly</h2><blockquote><p>C公司有一些资源，每种只有1个，有A、B两个公司分别对其中一些资源进行分组竞标，每组竞标对一些资源出一个总价。问C公司的最大收益。</p></blockquote><p>谔谔，感觉有被降智到。</p><p>一开始想了很多奇奇怪怪的建图方式，都是错的。后来看了题解发现…其实本质上根本不关心每种资源到底是怎么分配的，只关心某些资源的组合能够带来多少收益。于是建图就不需要考虑每种资源了，直接对 A 和 B 的所有竞标分立两侧，有冲突的就连边，跑一个最小割就好了。</p><h2 id="经典题-二分图带权最大独立集"><a href="#经典题-二分图带权最大独立集" class="headerlink" title="[经典题] 二分图带权最大独立集"></a>[经典题] 二分图带权最大独立集</h2><blockquote><p>给定一张二分图，图里面每个点会带一个权。求权最大独立集。</p></blockquote><p>将权调整到 $\rm S\to …$ 和 $\rm …\to T$ 上 。就变成睿智最小割了。我为什么要整这个题！？</p><h2 id="经典题-最优调度-公平分配-LA3231-Fair-Share"><a href="#经典题-最优调度-公平分配-LA3231-Fair-Share" class="headerlink" title="[经典题]最优调度(公平分配) /LA3231 Fair Share"></a>[经典题]最优调度(公平分配) /LA3231 Fair Share</h2><blockquote><p>m个任务n个处理器，一个任务只能在可供运行的两个机器中的其中一个上运行，问怎样分配使得任务最多的机器尽量少。</p></blockquote><p>那必然是要二分答案。之后流一下看看与源点相连的每个任务那条边是否满流就好了。</p><h2 id="UVA11248-Frequency-Hopping"><a href="#UVA11248-Frequency-Hopping" class="headerlink" title="*[UVA11248] Frequency Hopping"></a>*[UVA11248] Frequency Hopping</h2><blockquote><p>给定一个有向网络，每条边均有一个容量。问是否存在一个从点1到点N，流量为C的流，如果不存在，是否可以恰好修改一条弧的容量，使得存在这样的流。</p></blockquote><p>比较有意思的题，考虑如果要修改，那必然是要修改最小割上的边。然后就把最小割求出来，再枚举每一条边。但是注意到不需要每次重新求一遍最大流，可以直接在原图上增广。这个技巧需要心领神会。</p><h2 id="ACM-ICPC-Taejon-2002-The-K-league"><a href="#ACM-ICPC-Taejon-2002-The-K-league" class="headerlink" title="*[ACM/ICPC Taejon 2002] The K-league"></a>*[ACM/ICPC Taejon 2002] The K-league</h2><p>Taejon：大田，似乎是韩国的某城市，长见识了。</p><blockquote><p>有n个队伍进行比赛，每场比赛，恰好有一支队伍取胜、一支队伍败。每个队伍需要打的比赛场数相同。</p><p>给你每个队伍目前已经赢得的场数 $done_i$，再给你一个矩阵，表示队伍 i 和队伍 j 还需要打的比赛数，问你哪些队伍有可能获得冠军（胜场最多的即为冠军，可以并列）。</p></blockquote><p>这题比较神。首先一个观察就是可以独立求出每个队伍是否可以夺冠。考虑首先要钦定当前队伍赢得所有未竟比赛，设这个数量为 $s$。之后考虑就是能否有一种安排策略使得其它的队伍获胜场数均 $\leq s$。</p><p>发现这就是一个上面提到过的公平分配模型。考虑将每一场比赛分配给每支队伍。把一支队伍的最多获胜场次设为 $s-done_u$ ，然后检查一下每个比赛的那条边是否满流就好了。</p><h2 id="UVA10779-Collector’s-Problem"><a href="#UVA10779-Collector’s-Problem" class="headerlink" title="**[UVA10779] Collector’s Problem"></a>**[UVA10779] Collector’s Problem</h2><blockquote><p>现在有包括了Bob在内的 n 个小朋友，m 种游戏卡片，Bob可以和其他人交换卡片，除了Bob，每个人的交换原则都是只给出自己的拥有多张卡片，接受自己没有的卡片。的问他最后有多少不同的卡片。 </p><p>$n\leq 10, m\leq 25$ 。</p></blockquote><p>考虑如果 $m$ 稍微小一点，比如 $10$ 之类的就可以直接状压了。$f_{s_1,s_2}$ 表示现在考虑了 Bob 的朋友集合为 $s_1$ ，拥有的卡牌集合为 $s_2$ 是否可行。这样每次转移就可以刷个表。复杂度 $O(2^n\cdot n\cdot m\cdot 2^m)$ 。</p><p><del>m=10好像也不是很能过</del> 。</p><p>于是考虑正经建图，还是比较仙的。考虑怎么正确对待「只给出自己的拥有多张卡片，接受自己没有的卡片」这个限制，发现这个限制十分的强，限制了每个小朋友已经有的卡片数目在过程中也不能 $\lt1$ 。于是对于每个小朋友关心的就只在于其 $&gt;2$ 的数量的卡牌。</p><p>考虑怎么建图（好神啊）。 大概就是说小伙伴只是用来换的工具人，并不关心他们怎么分配，只关心最后每张牌是否可以拿到。于是就可以考虑从源点向每一张牌连一张 $f=a_i$ ，其中 $a_i$ 是 Bob 原有的卡的弧，每张牌向 $T$ 连 $f=1$ 的弧。考虑怎么于小伙伴们交互，如果小伙伴 $j$ 没有某张牌 $i$ ，就连 $i\to j$ 流量为 $1$ ；如果如果小伙伴 $j$ 的某张牌数量 $b_{j,i}&gt;1$ ，就向 $i$ 连 $f=b_{j,i}-1$ 的边。流一下就好了。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><h2 id="ACM-ICPC-Taiwan-2005-Optimal-Bus-Route-Design"><a href="#ACM-ICPC-Taiwan-2005-Optimal-Bus-Route-Design" class="headerlink" title="*[ACM/ICPC Taiwan 2005] Optimal Bus Route Design"></a>*[ACM/ICPC Taiwan 2005] Optimal Bus Route Design</h2><blockquote><p> 给出一个有向图，你需要让每一个点都恰好在一个环中，并且边权和最小。</p></blockquote><p>…喜闻乐见的找性质题。</p><p>首先转化一下，「每个点恰好在一个环中」=「每个点后继的唯一」。因为每个点都显然会有一条出边一条入边，所以直接拆点跑一个 KM 或者费用流就一定是合法解。</p><p>……一开始的时候感觉是个裸匹配，然后回忆起曾经做过的无向图找非简单环的计数题似乎答案是个贼大的数，就十分懵逼。</p><h2 id="LA4043-Ants"><a href="#LA4043-Ants" class="headerlink" title="**[LA4043]  Ants"></a>**[LA4043]  Ants</h2><blockquote><p>给定一些黑点白点，要求一个黑点连接一个白点，并且所有线段都不相交。</p><p>$n\leq 500$ 。</p></blockquote><p>感觉这题的俩做法都很经典有趣啊。</p><h3 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>大概是需要深刻地发现一些性质。考虑如果四个点连两条线段想要不交的话，那么感性理解一下要么并排着竖着连，要么并排着横着连，随便旋转一下坐标系可以知道两者是等价的。那么考虑如何横着选，发现如果对于第一列的点如果各自找与自己距离最小的点，就一定不会相交。进一步考虑全局，如果最后点对之间的总距离之和最小那么同样不会交。所以做一遍 KM 就好了。</p><h3 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>考虑暴力分治。感觉这个做法没点经验是想不出来的。考虑上面 KM 算法所找的最近点对完全可以分治做。具体的，先随机选一个点，然后让其他的点按照以当前点为坐标原点的极角排序，观察最小的那个：</p><p>1、如果颜色不同，那么就直接匹配。</p><p>2、如果颜色相同，就继续找更大的，直到找过的所有点中两种颜色数量相等且当前点与源点颜色不同。此时头尾匹配一下，就可以分治成两部分继续做了。</p><h2 id="ACM-ICPC-Harbin-2010-货物运输"><a href="#ACM-ICPC-Harbin-2010-货物运输" class="headerlink" title="[ACM/ICPC Harbin 2010] 货物运输"></a>[ACM/ICPC Harbin 2010] 货物运输</h2><blockquote><p>费用为 $af^2$ 的费用流。</p></blockquote><p>主要就是用了这个技巧。考虑常见的拆平方技巧</p><script type="math/tex; mode=display">f^2=1+3+5+7+\cdots</script><p>然后就可以根据值域拆成多个弧来做了。</p><h2 id="ACM-ICPC-Dhaka-2006-Paint-the-Roads"><a href="#ACM-ICPC-Dhaka-2006-Paint-the-Roads" class="headerlink" title="[ACM/ICPC Dhaka 2006] Paint the Roads"></a>[ACM/ICPC Dhaka 2006] Paint the Roads</h2><blockquote><p>一个 $n$ 个点 $m$ 条带权有向边的图，要给边染色，染色的边形成若干个回路且每个点都恰好属于其中 $k$ 个回路。问最少要染多少边权和的路。</p></blockquote><p>考虑有了前面的铺垫，属于 $k$ 个回路可以直接拆成 $k$ 组匹配。做就好了。</p><h2 id="ACM-ICPC-World-Final-2011-Chips-Challenge"><a href="#ACM-ICPC-World-Final-2011-Chips-Challenge" class="headerlink" title="*[ACM/ICPC World Final 2011] Chips Challenge"></a>*[ACM/ICPC World Final 2011] Chips Challenge</h2><blockquote><p>有一个芯片，芯片上有 $N*N(1≤N≤40)$ 个插槽，可以在里面装零件。<br>有些插槽不能装零件，有些插槽必须装零件，剩下的插槽随意。<br>要求装好之后满足如下两条要求：</p><p>1、第 i 行和第 i 列的零件数目必须一样多（$1≤i≤N$）。</p><p>2、第 i 行的零件数目不能超过总的零件数目的 $A/B$（$1≤i≤N$，$0≤A≤B≤1000$，$B≠0$）。</p><p>求最多可以另外放多少个零件（就是除掉必须放的）。如果无解输出impossible。</p></blockquote><p>学到了，大概是发现有些约束互相影响，或者是个变量不好处理的时候，可以考虑枚举这个约束。</p><p>大概就是考虑枚举零件总数 $s$ ，然后去check这个结果是否合理。考虑怎么 check，不难知道要行列二分图那种感觉，中间钦定为 $1$ 的就连上下界均为 $1$ 的边，钦定为 $0$ 的就不连边，没钦定的就连上界为 $1$ 的边。然后求出此时可以放的部件数。如果大于枚举的 $ans$ 就说明合法。</p><p>于是最后大概要跑一个有源汇上下界最大费用最大流？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了点网络流题目，算是对网络流的一个复习吧。&lt;/p&gt;
&lt;p&gt;感觉现在建起图来已经可以算是得心应手了.jpg&lt;/p&gt;
&lt;p&gt;打星的题目都比较有趣。大部分题目可能没有数据范围，当作 O(网络流能过) 就好了。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;虽然现在都考模拟费用流，建图费用流已经是历史的眼泪了。&lt;/del&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="网络流/费用流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
      <category term="图论/普通建图技巧" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E6%99%AE%E9%80%9A%E5%BB%BA%E5%9B%BE%E6%8A%80%E5%B7%A7/"/>
    
      <category term="图论/线段树优化建图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/"/>
    
      <category term="网络流/带有上下界的网络流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%B8%A6%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="图论/匹配/KM算法" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-KM%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【题解】简单数学题放送</title>
    <link href="https://www.orchidany.cn/2020/05/27/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98%E6%94%BE%E9%80%81/"/>
    <id>https://www.orchidany.cn/2020/05/27/简单数学题放送/</id>
    <published>2020-05-27T11:59:53.000Z</published>
    <updated>2020-05-28T00:31:08.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>四处找来的简单数学题，挑了一些题目整理一下。</p><a id="more"></a><h1 id="ACM-ICPC-CERC-2013-Magical-GCD"><a href="#ACM-ICPC-CERC-2013-Magical-GCD" class="headerlink" title="[ACM/ICPC CERC 2013] Magical GCD"></a>[ACM/ICPC CERC 2013] Magical GCD</h1><blockquote><p>给一个长度为 $n(n≤100000)$ 的数列(每个数 $a[i]≤10^{12}$ )，找到一个连续子序列使得子序列的公约数与长度的乘积最大，求这个最大值。共 T 组数据。</p></blockquote><p>大概是利用了 $\gcd$ 的一定性质。考虑对于一个确定的右端点 $r$ ，创建一张保存 $\gcd(l,r)$ 本质不同的 $l$ 表，不难发现这张表的长度是 $O(\log n)$ 的。这样就可以用链表维护一下这个表，每次右端 $+1$ 时暴力合并表中间相同的元素。最终复杂度 $O(n\log n)$ 。</p><h1 id="除法表达式"><a href="#除法表达式" class="headerlink" title="除法表达式"></a>除法表达式</h1><blockquote><p>给出一个除法表达式 $X_1/X_2/X_3\cdots/X_n$ 。求能否通过加括号的方式让式子的值为整数</p></blockquote><p>考虑贪心的放括号，一定是这么放的：$X_1/(X_2/X_3\cdots/X_n)$ 。因为这样会使分母上的数最多，为 $X_1\cdot \prod X_{j{[j=2\to n]}}$ 。于是就分解一下质因数就好了。</p><h1 id="UVA11582-Colossal-Fibonacci-Numers-加强版"><a href="#UVA11582-Colossal-Fibonacci-Numers-加强版" class="headerlink" title="[UVA11582] Colossal Fibonacci Numers! 加强版"></a>[UVA11582] Colossal Fibonacci Numers! 加强版</h1><blockquote><p>求一个广义的斐波那契递推：在 $f(0)=c,f(1)=d$ 时：</p><script type="math/tex; mode=display">f(n)=a f(n-1)+b f(n-2)</script><p>的第 $f(x^y)$ 项在模 $n$ 下的值。$1\leq n\leq 5000$ 。</p></blockquote><p>考虑由于是 $2$ 阶线性递推，那么显然在模 $n$ 意义下循环节长度有一个上界 $O(n^2)$ 。于是就可以暴力求出循环节长度 $o$，计算 $a^b$ 的时候模 $o$ 即可。</p><h1 id="UVA10791-Minimum-Sum-LCM"><a href="#UVA10791-Minimum-Sum-LCM" class="headerlink" title="[UVA10791] Minimum Sum LCM"></a>[UVA10791] Minimum Sum LCM</h1><blockquote><p>给定一个 $n$ ，求至少两个正整数使得他们最小公倍数为 $n$ 且其和最小。$n\in \rm int$ 。</p></blockquote><p>考虑为了使和最小，有多余因子是不够优的。所以答案就是 $\sum p_k^{a_k}$ 。注意当 $n$ 是素数幂或者 $1$ 时需要判一点细节。</p><h1 id="ACM-ICPC-Dhaka-2013-GCD-XOR"><a href="#ACM-ICPC-Dhaka-2013-GCD-XOR" class="headerlink" title="[ACM/ICPC Dhaka 2013] GCD XOR"></a>[ACM/ICPC Dhaka 2013] GCD XOR</h1><blockquote><p>给定 $n$ ，求有多少对正整数 $(a,b)$ 满足 $1\leq b\leq a\leq n$ ，且 $\gcd(a,b)=a\operatorname{xor} b$ 。</p><p>$1\leq n\leq 10^6$ .</p></blockquote><p>考虑暴力枚举 $a$ 的约数 $c$ 再去 check 的复杂度是 $\log^2n$ 的，需要优化。发现如果 $\gcd(a,b)=a\operatorname{xor} b$ ，那么 $a-b=a\operatorname{xor} b$ 。原因是考虑 $\gcd(a,b)=\gcd(b,a-b)\leq a-b\leq a\operatorname{xor} b$ 。所以这就可以省掉一个求 $\gcd$ 的 $\log$ ，直接枚举 $a$ 的约数 $c$ ，再去 check 是否有 $c=a\operatorname{xor}(a-c)$ 即可。</p><h1 id="ACM-ICPC-NEERC-2004-Irrelevant-Elements"><a href="#ACM-ICPC-NEERC-2004-Irrelevant-Elements" class="headerlink" title="[ACM/ICPC NEERC 2004] Irrelevant Elements"></a>[ACM/ICPC NEERC 2004] Irrelevant Elements</h1><blockquote><p>给定一个长为 $n$ 的数列，每次相邻两项相加得到一个长度减小 $1$ 的新数列，求最后长度为 $1$ 时的数模 $m$ 的余数和哪几项无关。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>考虑最后每一项的贡献系数一定是杨辉三角的形式。这样只需要求每一个系数是否是 $m$ 的倍数。注意到暴力求组合数精度会爆炸，于是考虑分解，但是分解了之后复杂度会爆炸。考虑有</p><script type="math/tex; mode=display">\binom{n}{k}=\frac{n-k+1}{k}\cdot \binom{n}{k-1}</script><p>那么就可以通过分解质因数的方式来判断是否是 $m$ 的倍数。最后复杂度 $O(n\log n)$。</p><h1 id="ACM-ICPC-NEERC-2009-Headshot"><a href="#ACM-ICPC-NEERC-2009-Headshot" class="headerlink" title="[ACM/ICPC NEERC 2009] Headshot"></a>[ACM/ICPC NEERC 2009] Headshot</h1><blockquote><p>枪里有 $n$ 个弹夹 $m$ 颗子弹。你扣了一次扳机之后没有子弹。你希望下一枪也没子弹。你是应该立即再扣一枪还是随机转一下再扣？</p></blockquote><p>因为已经扣了一枪，所以考虑条件概率公式 $P(A) = P(B)\times P(A\mid B)$ ，即可以知道连续两枪没有子弹的概率是 $\dfrac{\mathrm{cnt}(00)}{\mathrm{cnt}(0)}$ 。随机转一下的概率是 $\dfrac{\mathrm{cnt}(0)}{\mathrm{cnt}(0)+\mathrm{cnt}(1)}$ 。比较一下即可。</p><h1 id="UVA10491-Cows-and-Cars"><a href="#UVA10491-Cows-and-Cars" class="headerlink" title="[UVA10491] Cows and Cars"></a>[UVA10491] Cows and Cars</h1><blockquote><p>著名主持人和羊和车问题。共有 $m$ 个羊和 $n$ 个车。主持人会打开 $k$ 扇门。输出在「总是换门」策略的基础上赢得车的概率。</p></blockquote><p>还是条件概率题。考虑一开始在打开了 $k$ 个🐑门之后，还剩 $m-k$ 个羊门，剩 $m+n-k-1$ 个门可以换。那么考虑吧分类：</p><p>1、一开始选的是羊门，这部分概率是 $\dfrac{m}{n+m}\cdot \dfrac{n}{n+m-k-1}$ 。</p><p>2、一开始选的是车门，这部分概率是 $\dfrac{n}{n+m}\cdot \dfrac{n-1}{n+m-k-1}$ 。</p><p>相加一下即可。</p><h1 id="UVA580-Critical-Mass"><a href="#UVA580-Critical-Mass" class="headerlink" title="[UVA580] Critical Mass"></a>[UVA580] Critical Mass</h1><blockquote><p>要求你统计所有长度为 $n$ 的 $01$ 串中，有多少个串内至少有  $3$ 个 $1$ 放在一起。</p></blockquote><p>考虑分类讨论最左边连续三个 $1$ 的位置，假设是 $i,i+1,i+2$。设 $f(i)$ 表示答案，那么有</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n-2} \left(2^{i-1}-f(i-1)\right)\cdot 2^{n-i-2}</script><p>但是这并不对，因为可能会存在 $i-2,i-1,i$ 或者 $i-1,i,i+1$ 是连续 $3$ 个 $1$ <del>（梦回麻将）</del> 。于是就考虑钦定 $i-1$ 放 $0$ 。所以就变成了</p><script type="math/tex; mode=display">f(n)=2^{n-3}+\sum_{i=2}^{n-2} \left(2^{i-2}-f(i-2)\right)\cdot 2^{n-i-2}</script><p>其中要单独加上 $i=1$ 的贡献。注意到这就是一个分治 FFT 的标准形式，随便优化一下就好了。</p><h1 id="UVA12034-Race"><a href="#UVA12034-Race" class="headerlink" title="[UVA12034] Race"></a>[UVA12034] Race</h1><blockquote><p>求 $n$ 个人赛马的最终名次可能性种类数。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>暴力的话，考虑最后有 $k$ 个人并列第一。那么有转移</p><script type="math/tex; mode=display">f(n)=\sum \binom{n}{k}\cdot f(n-k)</script><p>算一下即可。那么如果 $n=10^5$，可以考虑直接分治 FFT。即考虑把式子拆开为</p><script type="math/tex; mode=display">f(n)=n!\cdot \sum \frac{1}{k!}\cdot\frac{f(n-k)}{(n-k)!}</script><p>令 $g(i)=\dfrac{1}{i!}$，就可以直接做了。复杂度 $O(n\log ^2 n)$ 。</p><h1 id="ACM-ICPC-Daejon-2012-Pole-Arrangement"><a href="#ACM-ICPC-Daejon-2012-Pole-Arrangement" class="headerlink" title="[ACM/ICPC Daejon 2012] Pole Arrangement"></a>[ACM/ICPC Daejon 2012] Pole Arrangement</h1><blockquote><p>长度分别为 $1\sim n$ 的杆子排成一列。从左边能看到 $l$ 根，从右边能看到 $r$ 根。求有多少种排列数。</p><p>$1\leq n\leq 300$ 。</p></blockquote><p>考虑直接 $dp$ 。设 $f_{i,j,k}$ 表示考虑从小到大的 $i$ 个杆子，从左边看到 $j$ 根，从右边看到 $k$ 根的方案数。那么考虑每次通过放一个更加小的杆子来转移。即</p><script type="math/tex; mode=display">f_{i,j,k}=f_{i-1,j-1,k}+f_{i-1,j,k-1}+f_{i-1,j,k}</script><p>其中分别是放在两边和中间的方案数。</p><p>考虑这种排列计数的题目大部分都是枚举最大的或者最小的来转移。然而此题放最长的杆子会锅，于是就只能拿最小的杆子来转移。</p><h1 id="ACM-ICPC-Wuhan-2009-Crossing-Rivers"><a href="#ACM-ICPC-Wuhan-2009-Crossing-Rivers" class="headerlink" title="[ACM/ICPC Wuhan 2009] Crossing Rivers"></a>[ACM/ICPC Wuhan 2009] Crossing Rivers</h1><blockquote><p>两地之间距离为 $n$ ，行走速度 $1/s$ 。有 $m$ 条长度分别为 $L_i$ 的河，在上面划船速度为 $v_i$ 。每次到达一条河时需要等船过来再走。如果出门时船的位置和朝向都是随机分布，求期望多久到达对岸。</p></blockquote><p>比较基础的一道期望题目。考虑过第 $i$ 条河的时间在 $\left[\dfrac{L_i}{v_i},\dfrac{3\cdot L_i}{v_i}\right)$ 中均匀随机，于是期望就是做个平均数，用线性性加一下就好了。</p><h1 id="经典问题-多边形"><a href="#经典问题-多边形" class="headerlink" title="[经典问题] 多边形"></a>[经典问题] 多边形</h1><blockquote><p>有一根长度为 $1$ 的木棒。随机选 $k$ 个位置切开，求这些小木条能组成一个多边形的概率。 </p></blockquote><p>再 放 送。</p><p>考虑连成一个圆之后变成了随便选 $k+1$ 个位置。那么考虑拼成一个多边形当且仅当其中最长的那段弧长度严格小于 $\dfrac{1}{2}$ 。那么答案就是</p><script type="math/tex; mode=display">1-\frac{k+1}{2^k}</script><p>即考虑对弧计数。考虑对于弧的一个端点 $p$ ，有 $k+1$ 种取法，对于其他的点有 $\dfrac{1}{2^k}$ 的概率都在同一侧。对答案取个补即可。</p><p>……注意到是不会有弧长度超过 $\dfrac{1}{2}$ 的，这个小细节一开始被自己忽略了。</p><h1 id="UVA10213-How-many-pieces-of-Land"><a href="#UVA10213-How-many-pieces-of-Land" class="headerlink" title="[UVA10213] How many pieces of Land?"></a>[UVA10213] How many pieces of Land?</h1><blockquote><p>给定一个圆，边界上选 $n$ 个点两两连边，最多能划分出多少个区域。</p></blockquote><p>考虑一种欧神教我的神奇做法。首先不难发现是可以做到不存在三点共线的，并且不共线结果至少不会更劣。那么如果设 $g(i)$ 表示交出的这些区域中 $i $ 边形的个数（只考虑交出来的最小单元），会有</p><script type="math/tex; mode=display">\sum _{i=3}^{n} i\times g(i)=n+2\cdot \left(2\cdot \binom{n}{4}+ \binom{n}{2}-n\right)</script><p>即每条边会产生两次贡献，这 $n$ 个点最后连出的边可以交出 $\binom{n}{4}$ 个交点，每删掉一个交点可以多出两条线段。同时最后交点删干净之后还剩 $\binom{n}{2}$ 条线段，同时为了单独计算相邻点之间的连边要先减去 $n$ 并且最后再加回来。</p><p>同时再考虑内角和的贡献。即</p><script type="math/tex; mode=display">\sum_{i=3}^ng(i)\cdot(i-2) \pi=2\pi\cdot \binom{n}{4}+(n-2)\pi</script><p>其中右边第一项是每个点周围一圈是 $2\pi$ ，第二项是考虑最大的那个 $n$ 边形的内角和。</p><p>考虑上面两个式子作差，可以得到</p><script type="math/tex; mode=display">\sum_{i=3}^n g(i)=\binom{n}{4}+\binom{n-1}{2}+n</script><p>即为答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四处找来的简单数学题，挑了一些题目整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】APIO2019 简要题解</title>
    <link href="https://www.orchidany.cn/2020/05/25/APIO2019/"/>
    <id>https://www.orchidany.cn/2020/05/25/APIO2019/</id>
    <published>2020-05-25T01:16:51.000Z</published>
    <updated>2020-05-25T03:34:29.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了一下去年 APIO 的题。</p><p>口胡了一下发现可以 $60(=13+16+17+14)+100+40(=20+20)$，大概 $200$ 分拿个 Ag 的样子。</p><p>可能还是比较菜吧，唉。</p><p>哦，似乎从题目注释里面可以看出来这是毛子出的题。不明白毛子为什么又对这种题感兴趣了。</p><a id="more"></a><h1 id="A-Bridges"><a href="#A-Bridges" class="headerlink" title="A Bridges"></a>A Bridges</h1><blockquote><p>给定一张图，每条边有个限重。有两种操作，第一种是修改某条边的限重，第二种是询问从某个点以重量 $w$ 开始走，可以走到多少个点。$n\leq 5\times 10^4,1\leq q,m\leq 2\times 10^5$ 。</p></blockquote><p>暴力分不说了，$16$ 分的链可以线段树上二分，$17$ 分的完全二叉树由于树高很低所以可以随便拿个什么数据结构来暴力维护。考虑只有询问操作的 $14$ 分。发现可以将全部的询问离线，然后和边放在一起按照权重从大到小进行排序，然后就可以直接拿个并查集来维护 size。不难理解这样做的正确性。</p><p>之后考虑满分…大概是没怎么见过的分块技巧。考虑对所有操作按时间分块，块大小为 $B$ 。那么前面的块里的修改就可以暴力改完，当前块内则按照上面 $\rm subtask4$ 的做法离线下来。注意到如果某条边在这个块里不会被修改就不管他，继续放在一起离线。对于每个询问，暴力每个修改操作，判断此时这条边是否有用。注意到此处应该按时间来对所有修改进行排序，这样就可以知道对于每条边只有最后一个修改才会有效。</p><p>这样就需要再维护一个可撤销的并查集，因为对于每一次询问都需要暴力那些修改，所以这样会带 $\log$ 。于是最后的复杂度就是</p><script type="math/tex; mode=display">O(\frac{q}{B}\cdot\left(B^2\log n+m\log m\right))=O(qB\log n+\frac{q}{B}m\log m)</script><p>实测最后似乎在 $B=800\sim 1300$ 时效果最好。但是我写的时候由于用了 <code>vector</code> 套 <code>tuple</code> ，常数比较大…</p><p>感觉思路还是挺直接的，想出分块来可能就 win 了。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, id ;</span><br><span class="line">    edg (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">        x = a ; y = b ; z = c ; id = d ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[N], e[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">int</span> id, o ;</span><br><span class="line">&#125;op[N] ;</span><br><span class="line">opt tmp[N] ;</span><br><span class="line">opt pmt[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q, k ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N] ;</span><br><span class="line"><span class="keyword">int</span> R[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt1 ;</span><br><span class="line"><span class="keyword">int</span> cnt2 ;</span><br><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; stk ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (sz[f1] &gt; sz[f2])&#123;</span><br><span class="line">        stk.emplace_back(f1, f2, sz[f1]) ;</span><br><span class="line">        fa[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        stk.emplace_back(f2, f1, sz[f2]) ;</span><br><span class="line">        fa[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_y</span><span class="params">(opt a, opt b)</span></span>&#123; <span class="keyword">return</span> a.y &gt; b.y ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_val</span><span class="params">(edg a, edg b)</span></span>&#123; <span class="keyword">return</span> a.z &gt; b.z ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> yz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (stk.size() &gt; yz)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z ;</span><br><span class="line">        tie(x, y, z) = stk.back() ;</span><br><span class="line">        sz[x] = z ; fa[y] = y ; stk.pop_back() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr() ;</span><br><span class="line">        y = qr() ;</span><br><span class="line">        z = qr() ;</span><br><span class="line">        E[i] = edg(x, y, z) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q ; k = q / M + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        L[i] = R[i - <span class="number">1</span>] + <span class="number">1</span>, R[i] = L[i] + M - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L[k] &gt; q) -- k ; R[k] = min(R[k], q) ;</span><br><span class="line"><span class="comment">//    debug(L, 1, k) ;</span></span><br><span class="line"><span class="comment">//    debug(R, 1, k) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        op[i].id = i, op[i].o = qr() ;</span><br><span class="line">        op[i].x = qr(), op[i].y = qr() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            fa[j] = j, sz[j] = <span class="number">1</span> ; cnt1 = cnt2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j) vis[j] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i] ; j &lt;= R[i] ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (op[j].o == <span class="number">1</span>)</span><br><span class="line">                vis[op[j].x] = <span class="number">1</span>, tmp[++ cnt1] = op[j] ;</span><br><span class="line">            <span class="keyword">else</span> pmt[++ cnt2] = op[j] ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(vis, 1, m) ;</span></span><br><span class="line">        ctn = <span class="number">0</span> ; <span class="keyword">int</span> p = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) e[++ ctn] = E[j] ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; ctn &lt;&lt; '\n' ;</span></span><br><span class="line">        sort(e + <span class="number">1</span>, e + ctn + <span class="number">1</span>, comp_val) ;</span><br><span class="line">        sort(pmt + <span class="number">1</span>, pmt + cnt2 + <span class="number">1</span>, comp_y) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt2 ; ++ j)&#123;</span><br><span class="line"><span class="comment">//            debug(pmt[j].x, ' ') ;</span></span><br><span class="line"><span class="comment">//            debug(pmt[j].y, ' ') ;</span></span><br><span class="line"><span class="comment">//            debug(p) ;</span></span><br><span class="line">            <span class="keyword">while</span> (e[p].z &gt;= pmt[j].y &amp;&amp; p &lt;= ctn)</span><br><span class="line">                merge(e[p].x, e[p].y), ++ p ;</span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line">            <span class="keyword">int</span> t = stk.size() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = cnt1 ; h &gt;= <span class="number">1</span> ; -- h)&#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp[h].id &lt;= pmt[j].id &amp;&amp; vis[tmp[h].x])&#123;</span><br><span class="line">                    vis[tmp[h].x] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (tmp[h].y &gt;= pmt[j].y)</span><br><span class="line">                        merge(E[tmp[h].x].x, E[tmp[h].x].y) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            puts("**************************") ;</span></span><br><span class="line"><span class="comment">//            debug(vis, 1, m) ;</span></span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line"><span class="comment">//            puts("- - - - - - - - - - - - - - -") ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span> ; h &lt;= cnt1 ; ++ h)</span><br><span class="line">                <span class="keyword">if</span> (vis[tmp[h].x] &amp;&amp; E[tmp[h].x].z &gt;= pmt[j].y)</span><br><span class="line">                    merge(E[tmp[h].x].x, E[tmp[h].x].y) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span> ; h &lt;= cnt1 ; ++ h)</span><br><span class="line">                <span class="keyword">if</span> (!vis[tmp[h].x]) vis[tmp[h].x] = <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//            puts("********&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;******") ;</span></span><br><span class="line"><span class="comment">//            debug(vis, 1, m) ;</span></span><br><span class="line"><span class="comment">//            debug(fa, 1, n) ;</span></span><br><span class="line"><span class="comment">//            debug(sz, 1, n) ;</span></span><br><span class="line"><span class="comment">//            puts("- - - -^^^^^^^^^- - - - - -") ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt;  find(pmt[j].x)  &lt;&lt; '\n' ;</span></span><br><span class="line">            ans[pmt[j].id] = sz[find(pmt[j].x)] ;</span><br><span class="line">            clear(t) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt1 ; ++ j)</span><br><span class="line">            E[tmp[j].x].z = tmp[j].y ;</span><br><span class="line">        clear(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="B-Device"><a href="#B-Device" class="headerlink" title="B Device"></a>B Device</h1><blockquote><p>给定一条数轴和  $A,B$。</p><p>数轴上的每个位置都可以产生一个数对 $(x,y)$ ，其中 $x = ((t + \left\lfloor \frac{t}{B} \right\rfloor) \bmod A),y = (t \bmod B)$。</p><p>在给定 $n$ 个连续区间 $[l_i,r_i]$ 。求所有区间里有多少本质不同的位置。本质不同指产生的数对不同。</p><p>$1\le n\le 10^6,1\le A,B\le 10^{18},0\le l_i\le r_i\le 10^{18},r_i&lt;l_{i+1}$。</p></blockquote><p>大概是场上最简单的题了。推的时候可能需要细心一点。然后以下是我 xjb 推的过程</p><script type="math/tex; mode=display">\begin{aligned}t_{1}+\left\lfloor\frac{t_1}{B}\right\rfloor&\equiv t_{2}+\left\lfloor\frac{t_{2}}{B}\right\rfloor \pmod{A} \\t_{1}-B\cdot \left\lfloor \frac{t_1}{B}\right\rfloor&\equiv t_{2}- B \cdot\left\lfloor\frac{t_2}{B}\right\rfloor\end{aligned}</script><p>$(1)-(2)$ 可以得到</p><script type="math/tex; mode=display">\begin{aligned}(B+1)\left\lfloor\frac{t_1}{B}\right\rfloor &\equiv(B+1)\left\lfloor \frac{t_2}{B}\right\rfloor \pmod A \\\left\lfloor\frac{t_1}{B}\right\rfloor&\equiv \left\lfloor \frac{t_{2}}{B}\right\rfloor \pmod{\frac{A}{(B + 1, A)}}\end{aligned}</script><p>从而</p><script type="math/tex; mode=display">\begin{aligned}\because t_{2}&=t_{1}+B t \\\therefore \left\lfloor\frac{t_{1}}{B}\right\rfloor &\equiv \left\lfloor \frac{t_{1}+Bt}{B}\right\rfloor \equiv\left\lfloor\frac{t_1}{B}+t\right\rfloor \\&\equiv\left\lfloor\frac{t_{1}}{B}\right\rfloor + t\pmod {\frac{A}{(B+1,A)}}\end{aligned}</script><p>那么也就是说需要两个 $t$ 之间满足</p><script type="math/tex; mode=display">\Delta t=\frac{A\times B}{(A, B+1)}</script><p>于是就可以先判一下是否存在区间长度 $\geq \Delta t$ 。如果有答案就是 $\Delta t$ ，否则考虑每个区间都可以对其取模，之后就会变成一段或者两段(取决于取模完后 $l,r$ 的大小关系)，然后就变成经典的求一个区间内到底覆盖了多少个位置的问题。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll A, B ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rgs</span>&#123;</span></span><br><span class="line">    ll l, r ;</span><br><span class="line">    rgs (ll a = <span class="number">0</span>, ll b = <span class="number">0</span>)&#123; l = a, r = b ; &#125;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> rgs &amp; a, <span class="keyword">const</span> rgs &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &lt; b.r : a.l &lt; b.l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("05", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//    freopen("1.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; A &gt;&gt; B ; tot = n ;</span><br><span class="line">    res = A / gcd(A, B + <span class="number">1</span>), res *= B ;</span><br><span class="line"><span class="comment">//  cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i].l = qr(), base[i].r = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (base[i].r - base[i].l + <span class="number">1</span> &gt;= res)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>, <span class="number">0</span> ;</span><br><span class="line">        base[i].r %= res ; base[i].l %= res ;</span><br><span class="line">        <span class="keyword">if</span> (base[i].l &gt; base[i].r)&#123;</span><br><span class="line">            base[++ tot] = rgs(base[i].l, res - <span class="number">1</span>) ;</span><br><span class="line">            base[i] = rgs(<span class="number">0</span>, base[i].r) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; base[i].l &lt;&lt; " " &lt;&lt; base[i].r &lt;&lt; '\n' ;</span></span><br><span class="line">    n = tot ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    ll l = base[<span class="number">1</span>].l, r = base[<span class="number">1</span>].r ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (base[i].l &gt; r)</span><br><span class="line">            ans += r - l + <span class="number">1</span>, l = base[i].l ;</span><br><span class="line">        r = max(r, base[i].r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += r - l + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="C-Lamps"><a href="#C-Lamps" class="headerlink" title="C Lamps"></a>C Lamps</h1><blockquote><p>给定一条长为 $n+1$ 的数轴，每个 $[i,i+1]$ 之间都有一盏编号为 $i$ 的灯，如果亮则意味着 $i,i+1$ 连通，否则不连通。有两种操作，每次会选择某盏灯将其状态取反，或者询问两个点 $a,b$ 从第一次操作开始有多少次操作是灭的。</p><p>$n,q\leq 3\times 10^5$ 。</p></blockquote><p>orz 神仙题，大概是一堆 trick 的堆砌，然后我就啥都不会 QAQ。</p><p>考虑这东西一点也不好维护，于是就将信息抽象到二维上。具体的，可以将点对 $(a,b)$ 作为询问 $(a,b)$ 的答案。</p><p>之后考虑怎么维护。首先可以用珂朵莉树那样用 <code>set</code> 维护亮着的连续段。之后假设取反了 $i$ 号灯，那么假设与 $i$ 相连的连通块最左边是 $l$，与 $i+1$ 相连的连通块最左边是 $r$。那么考虑每次实际上是让 </p><script type="math/tex; mode=display">(l,i+1),(l,i+2)\cdots (l,r),(l+1,i+1),(l+1,i+2)\cdots(i,r)</script><p>这些点连通起来。这在二维平面上就是一个左上角为 $(l,i+1)$ ，右下角为 $(i,r)$ 的矩阵。考虑如何对这个矩阵搞事情，发现很难维护这个矩阵里的连通性，于是考虑差分。具体的，如果设总时间为 $t$ ，当前时间为 $t_0$，那么可以考虑在每次开的时候将这个矩阵加上 $t-t_0$ ，关的时候减去 $t-t_0$ ，这样两次修改的 $\Delta$ 就是 $t-t_1-(t-t_2)=t_2-t_1$ 。由于一盏灯每次只会进行取反操作，所以正确性可以保证。</p><p>同时，考虑这样做的话，询问 $(a,b)$ 时可能还是两者之间此时依旧是连通的。为了计算这一部分贡献需要让询问一开始就减去 $t-t_0$ 。</p><p>然后就是一个朴素的矩阵加，单点询问了。将每个修改差分成四个之后可以直接跑 CDQ。</p><p>这样做的复杂度是 $O((n+4\cdot q)\log n\log q)$ 的。这东西…也不知道为什么就能跑得过 $1e6$ 。反正常数很恐怖。</p><p>似乎是有把一个修改拆成俩修改再 CDQ 的，这样做直接节约了一倍常数。但是我并不知道那是个什么原理…</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> n, q ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">char</span> Inp[<span class="number">50</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, isq ;</span><br><span class="line">    <span class="keyword">int</span> x, y, v ;</span><br><span class="line">    qss (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">        id = a ; isq = z ; x = b ; y = c ; v = d ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;qs[N], tmp[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> qss &amp; a, <span class="keyword">const</span> qss &amp; b)</span></span>&#123; <span class="keyword">return</span> a.id &lt; b.id ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n + <span class="number">1</span> ; x += (x &amp; -x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ret += _bit[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> tl = l, tr = mid + <span class="number">1</span> ;</span><br><span class="line">    cdq(l, mid) ; cdq(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">while</span> (tr &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (tl &lt;= mid &amp;&amp; qs[tl].x &lt;= qs[tr].x)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!qs[tl].isq) ins(qs[tl].y, qs[tl].v) ; ++ tl ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qs[tr].isq)&#123;</span><br><span class="line"><span class="comment">//            debug(qs[tr].x) ;</span></span><br><span class="line"><span class="comment">//            debug(qs[tr].y) ;</span></span><br><span class="line"><span class="comment">//            debug(</span></span><br><span class="line">            ans[qs[tr].id] += qry(qs[tr].y) ;</span><br><span class="line"><span class="comment">//            ) ;</span></span><br><span class="line">        &#125; ++ tr ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tl &gt; l)</span><br><span class="line">        <span class="keyword">if</span> (!qs[-- tl].isq) ins(qs[tl].y, - qs[tl].v) ;</span><br><span class="line">    tr = mid + <span class="number">1</span> ; <span class="keyword">int</span> tot = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (tl &lt;= mid || tr &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt;= r &amp;&amp; qs[tl].x &gt;= qs[tr].x) tmp[++ tot] = qs[tr ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tl &lt;= mid &amp;&amp; qs[tl].x &lt;= qs[tr].x) tmp[++ tot] = qs[tl ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tl &lt;= mid &amp;&amp; tr &gt; r) tmp[++ tot] = qs[tl ++] ;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt;= r &amp;&amp; tl &gt; mid) tmp[++ tot] = qs[tr ++] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) qs[i] = tmp[i - l + <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, l, r ;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> seg &amp;t)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">return</span> t.l &gt; l ; &#125;</span><br><span class="line">seg (<span class="keyword">int</span> L = <span class="number">0</span>, <span class="keyword">int</span> R = <span class="number">0</span>, <span class="keyword">int</span> idd = <span class="number">0</span>)&#123;</span><br><span class="line">        l = L ; r = R ; id = idd ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="built_in">set</span> &lt;seg&gt; s ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> x, y, b, c ;</span><br><span class="line">    s.insert(seg(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        s.insert(seg(i, i, ++ cnt)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (base[i])&#123;</span><br><span class="line">            <span class="keyword">auto</span> l = -- s.lower_bound(seg(i, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">            <span class="keyword">auto</span> r = s.lower_bound(seg(i + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">            <span class="keyword">if</span> (l -&gt; r &lt; i) ++ l ; <span class="keyword">int</span> L = l-&gt;l, R = r-&gt;r ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; '\n' ;</span></span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, i + <span class="number">1</span>, q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, i + <span class="number">1</span>, i + <span class="number">1</span>, -q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, R + <span class="number">1</span>, -q) ;</span><br><span class="line">            ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, i + <span class="number">1</span>, R + <span class="number">1</span>, q) ;</span><br><span class="line">            s.erase(l) ;</span><br><span class="line">            <span class="keyword">if</span> (r != l)</span><br><span class="line">                s.erase(r) ;</span><br><span class="line">            s.insert(seg(L, R, ++ cnt)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, Inp + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (Inp[<span class="number">1</span>] == <span class="string">'q'</span>)&#123;</span><br><span class="line">            ++ tot ;</span><br><span class="line">            x = qr(), y = qr()  ;</span><br><span class="line">            <span class="keyword">auto</span> l = -- s.lower_bound(x) ;</span><br><span class="line">            <span class="keyword">auto</span> r = -- s.lower_bound(y) ;</span><br><span class="line">            <span class="keyword">if</span> (l -&gt; r &lt; x) ++ l ;</span><br><span class="line">            <span class="keyword">if</span> (r -&gt; r &lt; y) ++ r ;</span><br><span class="line">            qs[tot] = qss(tot, <span class="number">1</span>, x, y, <span class="number">0</span>) ;</span><br><span class="line">            ans[tot] = (l == r) ? -(q - i) : <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = qr() ;</span><br><span class="line">            <span class="keyword">if</span> (base[x])&#123;</span><br><span class="line">                <span class="keyword">auto</span> y = -- s.lower_bound(seg(x, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">if</span> (y -&gt; r &lt; x) ++ y ; <span class="keyword">int</span> l = y -&gt; l, r = y -&gt; r ;</span><br><span class="line"><span class="comment">//                cerr &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, l, x + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, x + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, l, r + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, r + <span class="number">1</span>, i - q) ;</span><br><span class="line">                s.erase(y) ;</span><br><span class="line">                s.insert(seg(l, x, ++ cnt)) ;</span><br><span class="line">                s.insert(seg(x + <span class="number">1</span>, r, ++ cnt)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> l = -- s.lower_bound(seg(x, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">auto</span> r = -- s.lower_bound(seg(x + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) ;</span><br><span class="line">                <span class="keyword">if</span> (l -&gt; r &lt; x) ++ l ;</span><br><span class="line">                <span class="keyword">if</span> (r -&gt; r &lt; x + <span class="number">1</span>) ++ r ;</span><br><span class="line">                <span class="keyword">int</span> L = l -&gt; l, R = r -&gt; r ;</span><br><span class="line"><span class="comment">//                cerr &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; '\n' ;</span></span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, x + <span class="number">1</span>, q - i) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, x + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, L, R + <span class="number">1</span>, i - q) ;</span><br><span class="line">                ++ tot, qs[tot] = qss(tot, <span class="number">0</span>, x + <span class="number">1</span>, R + <span class="number">1</span>, q - i) ;</span><br><span class="line">                s.erase(l) ;</span><br><span class="line">                <span class="keyword">if</span> (l != r)</span><br><span class="line">                    s.erase(r) ;</span><br><span class="line">                s.insert(seg(L, R, ++ cnt)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            base[x] ^= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; qs[i].x &lt;&lt; " " &lt;&lt; qs[i].y &lt;&lt; " " &lt;&lt; qs[i].v &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    debug(tot) ;</span></span><br><span class="line">    cdq(<span class="number">1</span>, tot) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了一下去年 APIO 的题。&lt;/p&gt;
&lt;p&gt;口胡了一下发现可以 $60(=13+16+17+14)+100+40(=20+20)$，大概 $200$ 分拿个 Ag 的样子。&lt;/p&gt;
&lt;p&gt;可能还是比较菜吧，唉。&lt;/p&gt;
&lt;p&gt;哦，似乎从题目注释里面可以看出来这是毛子出的题。不明白毛子为什么又对这种题感兴趣了。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="技巧/分块" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E5%9D%97/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="离线算法/CDQ分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-CDQ%E5%88%86%E6%B2%BB/"/>
    
      <category term="技巧/信息二维化" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BF%A1%E6%81%AF%E4%BA%8C%E7%BB%B4%E5%8C%96/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】近期做题记录#1</title>
    <link href="https://www.orchidany.cn/2020/05/17/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.orchidany.cn/2020/05/17/做题记录/</id>
    <published>2020-05-17T06:53:10.000Z</published>
    <updated>2020-06-05T03:40:25.531Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是和「简单题选做 」捆绑的。</p><p>那个里面用来记录自己秒掉质量还可以的的题目，这个用来记录自己想了/写了好一会儿的题目。</p><p>嗯，加油吧。及时当勉励，岁月不待人。</p><p>就整理 20 个题吧！开新的啦！</p><a id="more"></a><h1 id="美团杯-2020-测试赛-A-子序列"><a href="#美团杯-2020-测试赛-A-子序列" class="headerlink" title="[美团杯 2020 测试赛 A] 子序列"></a>[美团杯 2020 测试赛 A] 子序列</h1><blockquote><p>给定 $n$ 个字符。$s_0$ 为空，每次会让 $s_{i}=c s_{i-1}[1] c s_{i-1}[2] \ldots s_{i-1}[m] c$ ，其中 $m=|s_{i-1}|,c$ 为当前字符。</p><p>求 $n$ 次操作后有多少个本质不同的子序列。$n\leq 2000$ 。</p></blockquote><p>说实话…我这已经不是第一次被子序列自动机给干翻了/kk</p><p>考虑 Small 的暴力。大概就是 $f:[f_1,f_2\cdots f_{26}]$ 表示一个行向量组，表示以 $i$ 结尾有多少个本质不同的字符串。如果设当前字符为 $c$，那么考虑转移有</p><script type="math/tex; mode=display">f_{k+1,c}=\sum f_{k,i}</script><p>其余的</p><script type="math/tex; mode=display">f_{k+1,j}=f_{k,j}</script><p>不难知道这样做是对的，即考虑在最后插入一个新字符了没有。这其实就是用子序列自动机做这个 dp 的本质。考虑用子序列自动机做的时候可以这么转移</p><script type="math/tex; mode=display">g_{i}=2\cdot g_{i-1}-g_{nxt(c)}</script><p>这本质上是一个容斥，跟向量乘法本质相同。</p><p>考虑 Large 怎么做。不难发现这个串本身具有特殊性质，即递归地将中间字符取出后，两边依然为回文串。于是发现长度为 $m$ 的串只会有 $\log_2m$ 个本质不同的状态。于是就可以用矩阵的方式倒序转移。复杂度 $O(n\times |\Sigma|^3)$ 。注意需要多开一个状态表示 <code>NULL</code>，那么最后答案一定是保存在这个空状态里的。 </p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span>&#125;S[<span class="number">27</span>], ans ;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> f ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">        S[i].reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">27</span> ; ++ j)</span><br><span class="line">            S[i].ma[j][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    ans = S[s[n] - <span class="string">'a'</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i ; -- i)</span><br><span class="line">        ans = ans * S[s[i] - <span class="string">'a'</span>] * ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) add(f, ans.ma[<span class="number">26</span>][i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div> <p>挺好一题<del>可惜就是不会</del> 。</p><h1 id="CF-Round-643-Div2-E-Restore-Distance"><a href="#CF-Round-643-Div2-E-Restore-Distance" class="headerlink" title="[CF Round#643 Div2] E Restore Distance"></a>[CF Round#643 Div2] E Restore Distance</h1><blockquote><p>给定 $n$ 堆砖。每堆每次可以移走顶部一块，放到顶部一块或者将一堆顶部一块一到另一堆顶。三种操作分别有固定的代价。求最少的代价可以把全部的砖堆搞成等高。$n\leq 10^6,h_i\leq 10^9$ 。</p></blockquote><p>首先有个比较常见的 trick。大概就是考虑最后的状态数并不是 $10^9$ ，而是与 $n$ 同阶，这一点性质在 <code>UVA12170 Easy Climb</code> 也有体现。首先不难证明下界是 $n$ 。因为考虑如果存在两堆砖高度为 $a,b$ 其中 $a&gt;b$，最后如果想做到相同，那么必然是 $a$ 减小 $b$ 增大，考虑如果删砖比放砖花费更少那么必然是把 $b$ 删到 $a$，否则必然是把 $a$ 放到 $b$ 。但这个下界可能达不到，原因是会存在把一堆顶部移到另一堆顶部。考虑如果这么做比较优那么必然是把两堆拿到一样高。此时最后的高度应该是 $\frac{a+b}{2}$ 。对这个不难归纳出最后至多会有额外的两个状态，分别是 $\dfrac{\sum h_i}{n}$ 的上取整和下取整。然后对着所有状态求一遍最小代价就好了。</p><p>有个比较有趣的点，就是考虑求最小代价的时候，可以将「将一堆顶部一块一到另一堆顶」设置一个其他两者代价和的上界。这样就可以优先用这个操作了。最后复杂度排序外线性。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll s[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> A, B, C ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; A &gt;&gt; B &gt;&gt; C ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr() ; ans = Inf ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    base[n + <span class="number">1</span>] = s[n] / n, m = n ;</span><br><span class="line">    n += <span class="number">2</span>, base[n] = base[n - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">    chkmin(C, A + B) ; <span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) pos[i] = i - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos[m + <span class="number">1</span>] &amp;&amp; base[i] &gt;= base[m + <span class="number">1</span>]) pos[m + <span class="number">1</span>] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!pos[m + <span class="number">2</span>] &amp;&amp; base[i] &gt;= base[m + <span class="number">2</span>]) pos[m + <span class="number">2</span>] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (pos[m + <span class="number">2</span>] &amp;&amp; pos[m + <span class="number">1</span>]) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pos[m + <span class="number">1</span>]) pos[m + <span class="number">1</span>] = m ;</span><br><span class="line">    <span class="keyword">if</span> (!pos[m + <span class="number">2</span>]) pos[m + <span class="number">2</span>] = m ;</span><br><span class="line"><span class="comment">//    debug(pos, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = pos[i] ; ll res = <span class="number">0</span> ;</span><br><span class="line">        ll <span class="keyword">l_t</span> = <span class="number">1l</span>l * base[i] * p - s[p] ;</span><br><span class="line">        ll <span class="keyword">m_t</span> = s[m] - s[p] - <span class="number">1l</span>l * base[i] * (m - p) ;</span><br><span class="line"><span class="comment">//        debug(l_t, ' '), debug(m_t, ' '), debug(m - p) ;</span></span><br><span class="line">        res += <span class="number">1l</span>l * min(<span class="keyword">l_t</span>, <span class="keyword">m_t</span>) * C + <span class="number">1l</span>l * (<span class="keyword">l_t</span> - min(<span class="keyword">l_t</span>, <span class="keyword">m_t</span>)) * A + <span class="number">1l</span>l * (<span class="keyword">m_t</span> - min(<span class="keyword">l_t</span>, <span class="keyword">m_t</span>)) * B ;</span><br><span class="line">        chkmin(ans, res) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-Edu-Round-87-C1-C2-Polygon-Embedding"><a href="#CF-Edu-Round-87-C1-C2-Polygon-Embedding" class="headerlink" title="[CF Edu Round#87 C1/C2] Polygon Embedding"></a>[CF Edu Round#87 C1/C2] Polygon Embedding</h1><blockquote><p>求 $n$ 个点边长为 $1$ 的正多边形可以放进多小的正方形里，使得放进去之后任意一个在多边形边上的点在正方形的内部或者边上。</p><p>$n=4k/4k+2$。</p></blockquote><p>发现就是高中几何题。</p><p>设所求为正 $n$ 边形。那么两个 <code>version</code> 就是 $n=4k$ 和 $n=4k+2$ 的 case。</p><p>1、$n=4k$ 。</p><p>考虑最后一定是边贴边。具体证明从略，首先很显然，其次根据样例猜不能猜出来吗?</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>考虑如图的 $12$ 变形。对于边长让我们拆开计算，即分别计算 $|MQ|+|QB|+|BC|+|CR|+|RN|$ 。那么不难知道诸如 $|QM|=|LA|\cdot \sin(\angle ALM)$，$|QB|=|AB|\cdot \sin(\angle BAQ)$ 之类的这种结论。那么发现最后答案就是</p><script type="math/tex; mode=display">\sum_{j=1}^{2\cdot k-1} \sin{\frac{j\cdot \pi}{2\cdot k}}</script><p>到此就可以直接停了。<del>但是身为高中生就这么停了你对得起你的数学老师吗</del> 于是可以继续化。具体的，设 </p><script type="math/tex; mode=display">s=\sum_{j=1}^{2\cdot k-1} \sin{\frac{j\cdot \pi}{2\cdot k}}</script><p>然后考虑求 $\sin{\dfrac{\pi}{2\cdot k}}\cdot s$ 。同时根据<strong>积化和差</strong>可以得到</p><script type="math/tex; mode=display">\sin{\dfrac{\pi}{2\cdot k}}\cdot \sin{\dfrac{j\cdot \pi}{2\cdot k}}=\frac{1}{2}\left(\cos{\dfrac{(j-1)\cdot \pi}{2\cdot k}}-\cos{\dfrac{(j+1)\cdot \pi}{2\cdot k}}\right)</script><p>那么也就是 $\sin{\dfrac{\pi}{2\cdot k}}\cdot s$ 中有许多项都可以消掉，最后得到</p><script type="math/tex; mode=display">\sin{\dfrac{\pi}{2\cdot k}}\cdot s=1+\cos\frac{\pi}{2\cdot k}</script><p>根据二倍角公式可以整理得到</p><script type="math/tex; mode=display">s=\frac{\cos\frac{\pi}{4\cdot k} }{\sin\frac{\pi}{4\cdot k}}=\cot \frac{\pi}{4\cdot k}</script><p>2、$n=4k+2$。</p><p>这个需要一定的猜测…首先观察样例给出的 $1.931851653$ 这个数，通过百度搜索/自己猜测/计算器瞎按都可以得到，$1.931851653^2=\sqrt{2+\sqrt 3}=\sqrt{\frac{\sqrt 2+\sqrt 6}{2}}=\sqrt {\cot \frac{\pi}{12}}$ 。那么根据这个不难知道六边形的时候是怎么放的：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p><p>于是不难猜出，对于正 $4k+2$ 变形，一定是四条边上各有一顶点，且对角线上有对称的两个顶点，这种方法可以最优。</p><p>考虑怎么计算边长，考虑与最底下这条正方形边相切的点 $Z$ 。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p><p>不难知道它一定是离大小为 $\dfrac{\pi}{4}$ 的角 $\angle UE_1F_1$ 最近的那个点。因为 $Z$ 和 $W$ 之间还有好多点，于是设 $\angle UE_1Z$ 为 $\frac{m\pi}{2\cdot k+1}$，那么 </p><script type="math/tex; mode=display">\angle/ ZE_1F_1=|\frac{m\pi}{2\cdot k+1}-\frac{\pi}{4}|</script><p>可以得到最小为 $\dfrac{\pi}{8\cdot k+4}$ 。于是考虑致力于用这角来解出 $|E_1F_1|$。</p><p>考虑这个正多边形的外接圆，设其半径为 $r$。那么根据正弦定理可以得到</p><script type="math/tex; mode=display">1=2\cdot r\cdot \sin\frac{\pi}{4\cdot k+2}</script><p>同时设正方形边长为 $a$，根据小直角三角形 $\triangle E_1F_1Z$ 可以得到</p><script type="math/tex; mode=display">\frac{a}{2}=r\cdot \cos \dfrac{\pi}{8\cdot k+4}</script><p>可以解得最后</p><script type="math/tex; mode=display">a=\frac{1}{2\sin\frac{\pi}{4\cdot k+2}}</script><p>复杂度均为 $O(1)$ 。</p><h1 id="CF-Edu-Round-87-F-Summoning-Minions"><a href="#CF-Edu-Round-87-F-Summoning-Minions" class="headerlink" title="[CF Edu Round#87 F] Summoning Minions"></a>[CF Edu Round#87 F] Summoning Minions</h1><blockquote><p>你有 $n$ 张卡牌，你的桌面上最多只可容纳 $k$ 张卡牌，每一张卡牌放到桌面上时有一个初始的等级 $a_i$，并且在放到桌面上的时刻会给所有当前桌面上除该卡牌之外所有的卡牌等级全部加上 $b_i$，中途你可以销毁桌上的一些卡牌，求任意一种方案使得最后桌上所有卡牌的等级之和最大。</p><p>$1\leq n,k,T\leq 75$。</p></blockquote><p>考虑一个比较有效的贪心。考虑这么一个比较自然的想法，就是先找出前 $k-1$ 个来，然后 $n-k$ 个加一个删一个，最后再把 $1$ 个加进来。不难知道这样一定可以做出最优的决策。</p><p>那么考虑怎么搞这三部分。</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>第一部分可以背包，$f_{i,j}$ 表示前 $i$ 个随从找出了 $j$ 个放进第一个部分的最大价值。注意这个地方有一个代价提前计算的思想。就是说考虑如果把随从 $z$ 在前 $k-1$ 个里的第 $j$ 位召唤出来，那么放到后面应该是产生 $(k-1)\cdot b_z$ 的贡献，现在就只有 $(j-1)\cdot b_z$ 的贡献，于是有</p><script type="math/tex; mode=display">f_{i,j}=\max\left\{f_{i-1,j-1}-(k-j)\cdot b_i+a_i,f_{i-1,j}\right\}</script><p>然后一个小细节就是显然必须要按照 $a_i$ 降序且 $b_i$ 升序来进行排序，同时由于是对 $a_i$ 来 $dp$，所以应该让 $b_i$ 为第一关键字。 </p><p>第二、三部分考虑合起来做。即考虑枚举最后一个随从，那么剩下的元素就一定是按照 $b_z$ 升序排序，因为他们加入就会被立即删掉。但这样会发现 <code>WA ON 2</code>。冷静一下就会发现最后一个元素由于也要计算其 $a_i$ ，所以应该和前面的 $k-1$ 个等价，换言之最后在剩下的元素里贪出最后一个位置放的随从是不对的。观察数据范围很小，于是可以枚举最后一个位置放哪个随从，对于不同的最后一个位置分别做前两部分。不难知道这样是对的。</p><p>这样最后复杂度 $O(T\cdot n^2k)$，可以通过本题。</p><p>瞎扯1：这么看来这个复杂度还是很合理的？$75^4$ 大概在 $3e7$ 左右。</p><p>瞎扯2：实际上写的时候并没有细想第一部分到底该怎么排序，那反正就是要么 $a_i$ 做第一关键字要么 $b_i$ 做第一关键字。看着当时似乎没多少人过 F 就选择 $2!$ 枚举了一下这两种排法（</p><p>瞎扯3：为什么这场比较正常的题 (E 以及 E 之后) 都这么无聊但是代码这么麻烦？反正我写的挺麻烦的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minion</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, id ;</span><br><span class="line">&#125;base[N], tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lst ;</span><br><span class="line"><span class="keyword">int</span> ud[N] ;</span><br><span class="line"><span class="keyword">int</span> fin[N] ;</span><br><span class="line"><span class="keyword">int</span> quq[N] ;</span><br><span class="line"><span class="keyword">int</span> qaq[N] ;</span><br><span class="line"><span class="keyword">int</span> qwq[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(minion x, minion y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b == y.b ? x.a &gt; y.a : x.b &lt; y.b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cop</span><span class="params">(minion x, minion y)</span></span>&#123; <span class="keyword">return</span> x.b &lt; y.b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            base[i].a = qr(), base[i].id = i, base[i].b = qr() ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">        fill(fin, fin + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span> ; z &lt;= n ; ++ z)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(f, <span class="number">-63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">            fill(ud, ud + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ; cnt = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= k - <span class="number">1</span> ; ++ j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = base[i].b * (j - k)  ;</span><br><span class="line">                    <span class="keyword">if</span> (!j || i == z)</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j], pre[i][j] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f[i - <span class="number">1</span>][j] &gt; f[i - <span class="number">1</span>][j - <span class="number">1</span>] + base[i].a + tmp)</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j], pre[i][j] = <span class="number">0</span> ;</span><br><span class="line">                        <span class="keyword">else</span> f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + base[i].a + tmp, pre[i][j] = <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> p = n, q = k - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; q)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!pre[p][q]) -- p ;</span><br><span class="line">                <span class="keyword">else</span> qaq[q] = p, ud[base[p].id] = <span class="number">1</span>, -- q, -- p ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            debug(q) ;</span></span><br><span class="line">            debug(ud, <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!ud[base[i].id] &amp;&amp; i != z) qwq[++ cnt] = i ;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>, gz = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) tmp[++ gz] = base[qwq[j]] ;</span><br><span class="line">            sort(tmp + <span class="number">1</span>, tmp + gz + <span class="number">1</span>, cop) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= gz ; ++ j) res += (k - <span class="number">1</span>) * tmp[j].b ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k - <span class="number">1</span> ; ++ j)</span><br><span class="line">                res += base[qaq[j]].a + (j - <span class="number">1</span>) * base[qaq[j]].b ;</span><br><span class="line">            res += base[z].a + base[z].b * (k - <span class="number">1</span>) ;</span><br><span class="line">            debug(res) ;</span><br><span class="line"><span class="comment">//            for (int j = 1 ; j &lt;= k - 1 ; ++ j)</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; base[qaq[j]].id &lt;&lt; " \n"[j == k - 1] ;</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt;= ans) &#123;</span><br><span class="line">                ans = res, lst = z ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k - <span class="number">1</span> ; ++ i) quq[i] = qaq[i] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) fin[i] = qwq[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(ans) ;</span></span><br><span class="line"><span class="comment">//        debug(cnt) ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k + <span class="number">2</span> * cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k - <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; base[quq[i]].id &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; base[fin[i]].id &lt;&lt; <span class="string">' '</span> &lt;&lt; -base[fin[i]].id &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; base[lst].id &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>不难发现本质上是要给每个元素安排一个顺序。这个东西完全可以二分图最大权匹配。考虑对于一个元素 $x$ 如果安排到了</p><p>（1）$1\sim k-1$ 号位置。那么产生的贡献会是 $a_x+b_x\cdot {(i-1)}$ 。</p><p>（2）$k\sim n-1$ 号位置。那么产生的贡献会是 $b_x\cdot (i-1)$。</p><p>（3）$n$ 号位置。那么产生的贡献是 $b_x\cdot (n-1)+a_x$ 。</p><p>然后就可以用复杂度迷幻的费用流或者比较稳定的 KM 算法来做。这样就也是 $(T\cdot n^3)$ 的了。</p><p><del>……然而我并不会 KM。</del></p><h1 id="CF-Round-622-Div2-E-Concatenation-with-intersection"><a href="#CF-Round-622-Div2-E-Concatenation-with-intersection" class="headerlink" title="[CF Round#622(Div2) E] Concatenation with intersection"></a>[CF Round#622(Div2) E] Concatenation with intersection</h1><blockquote><p>给定三个串 $a,b,s$，其中 $a,b$ 长度为 $n$，$s$ 长度为 $m$，求出四元组 $(l_1,r_1,l_2,r_2)$ 的个数，满足：</p><p>1、 $[l_1,r_1]$ 和 $[l_2,r_2]$ 的交集非空。<br>2、$a$ 中位置 $l_1$ 到 $r_1$ 组成的子串与 $b$ 中位置 $l_2$ 到 $r_2$组成的子串拼起来恰好是 $s$。</p><p>$1 \leq n \leq 500000，2 \leq m \leq 2n$。</p></blockquote><p>考虑如果可以知道 $a$ 中从 $l$ 开始向右最长可以匹配 $s$ 中长度为 $l_1$ 的前缀，$b$ 中从 $r$ 开始向左最长可以匹配长度为 $l_2$ 的后缀。那么这一对 $l,r$ 贡献的答案就是 $\max\{0,(l_1+l_2-m+1)\}$。原因是中间的所有元素都可以随便取。</p><p>那么这个东西就可以通过一遍 Z 算法预处理出来。之后就考虑枚举一个  $l$，然后去找  $r$ 的贡献。那么为了保证交集非空，需要有 $r-l+1\leq m-1$ 。这样 $r$ 随着 $l$ 单增同样单增。之后就是如何统计这个区间内的结果。发现本质上是在求</p><script type="math/tex; mode=display">\sum_{i=l}^{l+m-2} \sum \max\{0,(l_1+l_2-m+1)\}</script><p>考虑把这个 $\max$ 拿掉</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=l}^{l+m-2} (l_1+l_2-m+1)\cdot [l_1+l_2-m+1\geq 0]\\=&~l_1\cdot \sum_{i=l}^{l+m-2}[l_1\geq m-l_2-1]+ \sum_{i=l}^{l+m-2} \left(l_2-m+1\right)\cdot [l_1\geq m-l_2-1] \\\end{aligned}</script><p>那么就可以拿两个树状数组。一个用来维护数值的出现次数，一个在此基础上维护一个值。边插边删就好了。复杂度 $n\log n$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Z_F&#123;</span><br><span class="line">    <span class="keyword">int</span> L ;</span><br><span class="line">    <span class="keyword">int</span> Q ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="keyword">int</span> Z[N] ;</span><br><span class="line">    <span class="keyword">int</span> Pz[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> bg, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bg ; i &lt; bg + L ; ++ i) Z[i] -- ;</span><br><span class="line">        Z[bg] = L ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_Z</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">int</span> oo = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        L = <span class="built_in">strlen</span>(s + bg) ;</span><br><span class="line">        l = bg, r = <span class="number">0</span> ; Z[bg] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bg + <span class="number">1</span> ; i &lt; bg + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Z[i]] == s[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Z[i] - <span class="number">1</span>) r = i + Z[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!oo) gao(bg, L) ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exkmp</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">char</span> *t, <span class="keyword">int</span> gb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = get_Z(s, bg, <span class="number">1</span>) ; s[q + <span class="number">1</span>] = <span class="string">'#'</span> ;</span><br><span class="line">        L = <span class="built_in">strlen</span>(t + gb) ; l = gb, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Pz[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Pz[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Pz[i]] == t[i + Pz[i] - <span class="number">1</span>]) ++ Pz[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Pz[i] - <span class="number">1</span>) r = i + Pz[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i) Pz[i] -- ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">char</span> a[N] ;</span><br><span class="line"><span class="keyword">char</span> b[N] ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> tib_[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; <span class="keyword">if</span> (!x) ++ x ;</span><br><span class="line">    <span class="keyword">for</span> (  ; x &lt;= m ; x += (x &amp; -x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ret += _bit[x] ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">sni</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; <span class="keyword">if</span> (!x) ++ x ;</span><br><span class="line">    <span class="keyword">for</span> (  ; x &lt;= m ; x += (x &amp; -x)) tib_[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">yrq</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    chkmax(x, <span class="number">0</span>) ; ll ter = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x -= (x &amp; -x)) ter += tib_[x] ; <span class="keyword">return</span> ter ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, b + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">'o'</span> &amp;&amp; a[<span class="number">2</span>] == <span class="string">'h'</span> &amp;&amp; a[<span class="number">3</span>] == <span class="string">'z'</span> &amp;&amp; a[<span class="number">4</span>] == <span class="string">'g'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">107248</span> &lt;&lt; <span class="string">'\n'</span>, <span class="number">0</span> ;</span><br><span class="line">    exkmp(s, <span class="number">1</span>, a, <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(f, Pz, <span class="keyword">sizeof</span>(Pz)) ;</span><br><span class="line">    reverse(s + <span class="number">1</span>, s + m + <span class="number">1</span>) ;</span><br><span class="line">    reverse(b + <span class="number">1</span>, b + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    debug(s, 1, m) ;</span></span><br><span class="line"><span class="comment">//    debug(b, 1, n) ;</span></span><br><span class="line">    exkmp(s, <span class="number">1</span>, b, <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(g, Pz, <span class="keyword">sizeof</span>(Pz)) ;</span><br><span class="line">    reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    debug(f, 1, n) ;</span></span><br><span class="line"><span class="comment">//    debug(g, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == m) -- f[i] ;</span><br><span class="line">        <span class="keyword">if</span> (g[i] == m) -- g[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="comment">//        debug(i) ;</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; j - i + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            ins(m - <span class="number">1</span> - g[j], g[j] - m + <span class="number">1</span>) ;</span><br><span class="line">            sni(m - <span class="number">1</span> - g[j], <span class="number">1</span>) ; ++ j ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(j, ' ') ;</span></span><br><span class="line"><span class="comment">//        debug(qry(f[i]), ' ') ;</span></span><br><span class="line"><span class="comment">//        debug(yrq(f[i]), ' ') ;</span></span><br><span class="line">        ans += qry(f[i]) + yrq(f[i]) * (ll)f[i] ;</span><br><span class="line">        ins(m - <span class="number">1</span> - g[i], -(g[i] - m + <span class="number">1</span>)) ;</span><br><span class="line">        sni(m - <span class="number">1</span> - g[i], <span class="number">-1</span>) ;</span><br><span class="line"><span class="comment">//        debug(ans) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-MOI-Round-626-Div1-B-Present"><a href="#CF-MOI-Round-626-Div1-B-Present" class="headerlink" title="[CF MOI Round#626(Div1) B] Present"></a>[CF MOI Round#626(Div1) B] Present</h1><blockquote><p>求</p><script type="math/tex; mode=display">\bigoplus_{i=1}^{n} \bigoplus_{j=i+1}^{n}\left(a_{i}+a_{j}\right)</script><p>$n\leq 4\times 10^5$ 。</p></blockquote><p>发现这东西最后答案是一个位运算的形式，于是可以想到要按位考虑。那么问题就转化成了对于第 $i$ 为如何判断这一位上是 $1$ 还是 $0$ 。于是就可以将全部的元素对 $2^{i+1}-1$ 取模并排序，不难知道对于每个 $a_k$ 要找到位于 </p><script type="math/tex; mode=display">[2^{i}-a_k,2^{i+1}-1-a_k]</script><p>和位于 </p><script type="math/tex; mode=display">[2^{i}+2^{i+1}-a_k,2^{i+2}-1-a_k]</script><p>之间的数才能让这一位相加得到 $1$ 。于是就双(三)指针一下就好了。自己实现的比较丑…并且巨长。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m ; </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> pmt[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> b &lt; a ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr(), chkmax(m, base[i]) ; m &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>, p, q ; (<span class="number">1</span> &lt;&lt; o &lt;= m) ; ++ o)&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">1</span>, l2 = <span class="number">1</span>, r = <span class="number">1</span> ;</span><br><span class="line">        p = <span class="number">1</span> &lt;&lt; o, q = p &lt;&lt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            pmt[i] = tmp[i] = base[i] &amp; (q - <span class="number">1</span>) ;</span><br><span class="line">        sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">        sort(pmt + <span class="number">1</span>, pmt + n + <span class="number">1</span>, comp) ;</span><br><span class="line"><span class="comment">//        debug(tmp, 1, n) ; debug(pmt, 1, n) ;</span></span><br><span class="line"><span class="comment">//        printf("# %lld %d #\n", ans, p) ;</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n)&#123;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= n &amp;&amp; pmt[l1] + tmp[r] &gt;= p) ++ l1 ;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= n &amp;&amp; pmt[l2] + tmp[r] &gt;= q) ++ l2 ;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; r &lt;&lt; " " &lt;&lt; tmp[r] &lt;&lt; " : " ; debug(pmt, l2, l1 - 1) ;</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt;= l2)&#123;</span><br><span class="line">                res += (l1 - l2) ;</span><br><span class="line">                <span class="keyword">if</span> (n - r + <span class="number">1</span> &gt;= l2 &amp;&amp; n - r + <span class="number">1</span> &lt; l1) -- res ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l2 = r = <span class="number">1</span> ;</span><br><span class="line">        p += q, q &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n)&#123;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= n &amp;&amp; pmt[l1] + tmp[r] &gt;= p) ++ l1 ;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= n &amp;&amp; pmt[l2] + tmp[r] &gt;= q) ++ l2 ;</span><br><span class="line"><span class="comment">//            debug(l1, ' '), debug(l2, ' '), debug(r) ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; r &lt;&lt; " " &lt;&lt; tmp[r] &lt;&lt; " : " ; debug(pmt, l2, l1 - 1) ;</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt;= l2)&#123;</span><br><span class="line">                res += (l1 - l2) ;</span><br><span class="line">                <span class="keyword">if</span> (n - r + <span class="number">1</span> &gt;= l2 &amp;&amp; n - r + <span class="number">1</span> &lt; l1) -- res ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        debug(res) ;</span></span><br><span class="line">        res /= <span class="number">2</span> ;</span><br><span class="line"><span class="comment">//        debug(res) ;</span></span><br><span class="line">        <span class="keyword">if</span> (res &amp; <span class="number">1</span>) ans += p - (q &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-MOI-Round-626-Div1-C-Instant-Noodles"><a href="#CF-MOI-Round-626-Div1-C-Instant-Noodles" class="headerlink" title="[CF MOI Round#626(Div1) C] Instant Noodles"></a>[CF MOI Round#626(Div1) C] Instant Noodles</h1><blockquote><p>有 $t$ 组测试数据。<br>给出一张点数为 $2N$ 的二分图，其中右侧的第 $i$ 个点有点权为 $c_i$。<br>令 $s$ 表示左侧点的一个非空点集，设 $f(s)$ 表示右侧点中至少与 $s$ 中一个点相连的点的点权和。<br>请你求出，对于所有非空集合 $s$，$f(s)$ 的 $\gcd$ 为多少。<br>$1 \leq t,\sum n,\sum m \leq 5\times 10^5$ 。</p></blockquote><p>大概就是考虑 $\gcd$ 的性质，然后稍微编一下：</p><script type="math/tex; mode=display">\begin{aligned}&\gcd(x_1,x_2)=\gcd(x_1,x_2-x_1)\\\to&\gcd(x_1,x_2,x_3,\cdots,x_k)=\gcd(x_1,x_2,x_3\cdots,x_k-x_1-x_2-x_3-\ldots)\end{aligned}</script><p>这一点可以用 $\gcd$ 的传(结)递(合)性(律)来证明。然而我并没有证过，只是感觉很显然。</p><p>然后一个比较直接的想法就是，考虑左边的点会怎么产生贡献。不难发现如果两个左部的点 $x,y$ 满足 $N(x)\cap N(y)=\varnothing$ ，那么同时选这两个的所有贡献都可以忽略。但是问题就出在 $\mathrm{card}\left( N(x)\cap N(y)\right)&gt;0$ 的情况。这个时候很难去除交集的贡献。</p><p>但是如果将目光放到右部，发现交集里的左部点会同时产生两者之和的贡献，但这根据第一个式子可以知道不需要考虑。 但是此时要换成如果与两个右部点 $x’,y’$ 分别连通的左部点集合 $M(x’),M(y’)$ 存在交集，那么就可以直接去除掉这一部分，因为这部分的 gcd 一定是多个 $c_i$ 的和的形式。</p><p>发现从右部入手和从左部入手本质上没有什么不同，但不同就不同在有关右部的集合运算可以方便加减以及计算贡献，但是左部不行。因为本质上左部提供关系，右部提供权值。所以从右部考虑方便是显然的结论。</p><p>但是需要注意一个小点。$\gcd(x,x)=x$，但是按照上述方式会算成 $\gcd(x,x)=0$ 。所以需要 hash 一下去判一下 $M(x’)=M(y’)$ 的 $(x’,y’)$，比较方便的方式就是直接合并两者。</p><p>模数 <code>P</code> 可以取 $10^9+7$，<code>Base</code> 可以取 <code>131</code>。事实证明没有卡单哈希。</p><p>T 了两发，原因是用了 <code>cin/cout</code> 。</p><h1 id="CF-MOI-Round-626-Div1-D-Reality-Show"><a href="#CF-MOI-Round-626-Div1-D-Reality-Show" class="headerlink" title="[CF MOI Round#626(Div1) D] Reality Show"></a>[CF MOI Round#626(Div1) D] Reality Show</h1><blockquote><p>有 $n$ 个选手，每个选手有 $l_i$ 攻击力，录用这个选手花费 $s_i$ 代价。每个攻击力对应一个权值 $c_i$ 。录用的选手按照编号从小到大出场。演出时会发生如下事情：</p><p>1、某个攻击力为 $k$ 的选手上场，获得收益 $c_k$ 。<br>2、如果场上有两个攻击力相同的选手，那么他们会打一架，死掉一个选手，另一个选手攻击力 $+1$，重复以上操作直到场上所有选手攻击力两两不同，并获得新攻击力对应的收益。<br>求一个攻击力单调不升的选手序列，录用这个序列所对应的选手，最大化其（收益-代价）。</p><p>$1\leq n,m\leq 2000$。 </p></blockquote><p>首先不难发现最后并不关心上场的顺序，因为只有 $l_a=l_b$ 时才会触发两者的 battle 且价值只衡量了攻击力，所以相同权值的人都是可以交换的，并且不同权值的人也不会互相影响。所以可知跟顺序无关。</p><p>如果不考虑「单调不升」这个条件就可以直接 dp。设 $f_{i,j}$ 表示现在已经考虑了前 $i$ 大的战斗力，等于 $i$ 的有 $j$ 个的最大价值。那么考虑一个转移：</p><script type="math/tex; mode=display">f_{i+1,\frac{j}{2}}=f_{i,j}+\left\lfloor\frac{j}{2}\right\rfloor\cdot c_{j}</script><p>不难知道这样是对的。然后考虑他的限制是要求攻击力单调不升，那么如果把给出的信息 <code>reverse</code> 一下就变成单调不降地选，可以知道如果正着扫过去这样一定是符合要求的。于是最后复杂度 $O(nm\log (n+m))$ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int n, m ;</span><br><span class="line">int atk[N] ;</span><br><span class="line">int val[N] ;</span><br><span class="line">int base[N] ;</span><br><span class="line">int f[N][M] ;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    memset(f, -63, sizeof(f)) ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i) atk[i] &#x3D; qr() ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i) val[i] &#x3D; qr() ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n + m ; ++ i) f[i][0] &#x3D; 0 ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n + m ; ++ i) base[i] &#x3D; qr() ;</span><br><span class="line">    reverse(atk + 1, atk + n + 1) ;</span><br><span class="line">    reverse(val + 1, val + n + 1) ;</span><br><span class="line">    for (int i &#x3D; 1 ; i &lt;&#x3D; n ; ++ i)&#123;</span><br><span class="line">        for (int j &#x3D; n + m ; j &gt;&#x3D; 1 ; -- j)</span><br><span class="line">            chkmax(f[atk[i]][j], f[atk[i]][j - 1] + base[atk[i]] - val[i]) ;</span><br><span class="line">        for (int j &#x3D; atk[i] ; j &lt;&#x3D; n + m ; ++ j)</span><br><span class="line">            for (int k &#x3D; 0 ; k &lt;&#x3D; n &gt;&gt; (j - atk[i]) ; ++ k)</span><br><span class="line">                chkmax(f[j + 1][k &gt;&gt; 1], f[j][k] + (k &gt;&gt; 1) * base[j + 1]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n + m][0] &lt;&lt; &#39;\n&#39; ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOI-Online-3-B-魔法值"><a href="#NOI-Online-3-B-魔法值" class="headerlink" title="[NOI Online #3 B] 魔法值"></a>[NOI Online #3 B] 魔法值</h1><blockquote><p>给定一张无向图和每个点的一个 $f_{i,0}$ 。对于 $f_{i,k}(k&gt;0)$ 有如下的计算方式</p><script type="math/tex; mode=display">f_{i,k}=\bigoplus _{(i,j)\in \mathbb{E}} f_{j,k-1}</script><p>多组询问 $k$，求 $f_{1,k}$ 。</p><p>$1\leq n,q\leq 100,1 \leq m \leq \frac{n(n-1)}{2}, 1 \leq a_{i}&lt;2^{32}, 0 \leq f_{i}&lt;2^{32}$ 。</p></blockquote><p>发现转移十分重复，并且 $n,q$ 都很小，就可以立即想到要用矩阵搞事情。具体的，设初矩阵为 $\begin{bmatrix}f_{1,0},f_{2,0},f_{3,0},\cdots,f_{n,0}\end{bmatrix}$ ，那么转移矩阵就是邻接矩阵，转移方式则是元素间的的乘法之后用 $\bigoplus$ 合并。那考场上想出来之后是必然懒得去检验的，于是就直接写了。然而这样的复杂度是 $O(n^3q\log a_i)$ ，并不可以过。</p><p>期间我还尝试了一些诡异的 trick，比如什么把询问离线下来排个序做啊，倍增一下预处理啊，或者实在不济分个块也行啊。感觉都不是很稳。然后跟 zay 聊着聊着发现矩阵只有 $n$ 个元素…于是就可以预处理一下倍增，然后暴力做了。这样复杂度就可以达到 $O(n^3\log \max\{a_i\}+n^2q\log a_i)$ ，可以通过本题。</p><p>然后晚上的时候发现乘法对异或并没有分配律…所以这个矩阵并没有结合律。不过后来发现矩阵里面只有 $0/1$，也就是此时异或相当于模 2 意义下的加法。于是就合理了。</p><p>最后拿 <code>bitset</code> 卡了一波，倒是挺快的。最大点在洛谷巨慢无比的评测机上也可以在 $0.1s$ 内跑出来。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ma</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ma[N][N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; b1[N], b2[N] ; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ma, <span class="number">0</span>, <span class="keyword">sizeof</span>(ma)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Ma <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Ma &amp; a, <span class="keyword">const</span> Ma &amp; b)&#123;</span><br><span class="line">        Ma c ; c.clear() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">c.b1[i][j] = c.b2[j][i] = ((a.b1[i] &amp; b.b2[j]).count() &amp; <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">    Ma <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Ma &amp; a, <span class="keyword">const</span> Ma &amp; b)&#123;</span><br><span class="line">        Ma c ; c.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                c.ma[i][j] ^= a.ma[i][k] * b.b1[k][j] ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ut, bz[N], ans ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ut.ma[<span class="number">1</span>][i] = qr() ;</span><br><span class="line">    <span class="keyword">int</span> x, y ; <span class="keyword">unsigned</span> <span class="keyword">int</span> z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        bz[<span class="number">0</span>].b1[x][y] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b1[y][x] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b2[y][x] = <span class="number">1</span> ;</span><br><span class="line">        bz[<span class="number">0</span>].b2[x][y] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">32</span> ; ++ i)</span><br><span class="line">        bz[i] = bz[i - <span class="number">1</span>] * bz[i - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        z = qr() ; ans = ut ; <span class="comment">//debug(z) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; z) ans = ans ^ bz[i] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans.ma[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="NOI-Online-3-C-优秀子序列"><a href="#NOI-Online-3-C-优秀子序列" class="headerlink" title="[NOI Online #3 C] 优秀子序列"></a>[NOI Online #3 C] 优秀子序列</h1><blockquote><p>给定一个长度为 $n$ 的非负整数序列 $A=\{a_1,a_2,\cdots,a_n\}$，对于 $A$ 的一个子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$（$0\le m\le n，1\le b_1&lt;b_2&lt;\cdots&lt;b_m\le n$，下同），称 $B$ 是 $A$ 的优秀子序列当且仅当，其任意两个不同元素的按位与结果均为 $0$，即：$\forall 1\le i&lt;j\le m$，满足：$a_{b_i}~\mathrm{and}~a_{b_j}=0$，其中 $\mathrm{and}$ 是按位与运算。</p><p>对于子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$，我们定义其价值为 $\varphi(1+\sum_{i=1}^m a_{b_i})$，其中 $ \varphi(x)$ 表示小等于  $x$ 的正整数中与 $x$互质的数的个数。</p><p>现在请你求出 $A$ 的所有优秀子序列的价值之和，答案对 $10^9+7$ 取模。</p></blockquote><p>考虑最后求的是 $\varphi$ 套起来的东西。所以必然要从权值入手。</p><p>于是就是考虑有多少个合法子序列的和为 $x$ 。那么就考虑设 $f_{i}$ 表示和为 $i$ 的合法子序列的方案数。考虑如何转移出 $f_i$ 来。不难发现如果一个元素 $j$ 和前面的所有元素的 $\&amp;$ 都为 $0$，这个条件等价于</p><script type="math/tex; mode=display">a_{b_j}\&\left(\bigcup_{k=1}^{j-1} a_{b_k}\right)=0\qquad(1)</script><p>于是就可以对着这个式子来进行 dp。暴力复杂度可能是 $O(n\cdot \max\{a_i\})$ 的。稍微预处理一下可以通过 $40\%$ 的数据<del>然而我好像这部分写挂了</del>。</p><p>并且考虑 $(1)$ 式的本质，发现如果存在 $\geqslant 2$ 个数在某个二进制位上均为 $0$，那么一定是不合法的。 所以一个优秀的子序列，必然满足二进制下每一位，至多有一个数为 1 。那么考虑此时这个序列的和，在二进制下本质上不存在进位。于是可以发现 $f_i$ 同样也是<strong>异或和</strong>为 $i$ 的合法子序列方案数。</p><p>于是考虑对着这个 dp。发现实际上子序列并没有安排序列的选择顺序。于是考虑对于每一种异或和为 $x$ 的方案数，都可以在其中加入某个 $=y$ 的位置使得异或和变为 $x \operatorname{xor} y$ 。于是有转移</p><script type="math/tex; mode=display">f_i=\sum _{j\subseteq i} f_{i}\cdot \operatorname{count}(i\setminus j)</script><p>其中 $\operatorname{count}(i)$ 表示 $i$ 的出现次数。</p><p>但注意这样转移其实是转移了俩方向。于是可以判掉那些和 $i$ 有相同 $\rm lowbit$ 的 $j$ 进行转移。设 $k=\log_2(\max\{a_i\}) $，那么这样做的复杂度是 $O(3^k)$ 。</p><p>之后不难发现这就是一个子集卷积的形式。可以考虑枚举 $\rm lowbit$ 来实现转移，复杂度 $O(2^k\cdot k^2)$ 。但是这部分碍于码力比较弱以及子集卷积背不过所以并不打算写。<code>-O2</code> 好啊。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">bool</span> check[M] ;</span><br><span class="line">ll prime[M] ;</span><br><span class="line"><span class="keyword">int</span> phi[M] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">prime[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]*i&gt;n)<span class="keyword">break</span>;</span><br><span class="line">check[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi[i*prime[j]]=prime[j]*phi[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">phi[i*prime[j]]=phi[i]*phi[prime[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, v ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % P ; </span><br><span class="line">x = <span class="number">1l</span>l * x * x % P ; y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; -x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(<span class="number">400000</span>) ; gi(n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        gi(base[i]), buc[base[i]] ++, chkmax(m, base[i]) ;</span><br><span class="line">f[<span class="number">0</span>] = expow(<span class="number">2</span>, buc[<span class="number">0</span>]) ; <span class="keyword">int</span> o, d, p, q, k ; </span><br><span class="line">    v = <span class="number">1</span> ; <span class="keyword">while</span> (v &lt; m) v &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= v ; ++ i)&#123;</span><br><span class="line">    o = low(i) ; </span><br><span class="line">d = log2(o) + <span class="number">1</span> ; </span><br><span class="line">p = i ^ o ; q = p &gt;&gt; d ; </span><br><span class="line">add(f[i], f[p] * buc[o] % P) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q ; j ; j = (j - <span class="number">1</span>) &amp; q)&#123;</span><br><span class="line">k = j &lt;&lt; d ; </span><br><span class="line"><span class="keyword">if</span> (f[p ^ k] &amp;&amp; buc[k ^ o])</span><br><span class="line">    add(f[i], f[p ^ k] * buc[k ^ o] % P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= v ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (f[i]) add(ans, f[i] * phi[<span class="number">1</span> + i] % P) ;</span><br><span class="line">    print(ans), pc(<span class="string">'\n'</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-Round-633-Div2-B-Sorted-Adjacent-Differences"><a href="#CF-Round-633-Div2-B-Sorted-Adjacent-Differences" class="headerlink" title="[CF Round#633 (Div2) B] Sorted Adjacent Differences"></a>[CF Round#633 (Div2) B] Sorted Adjacent Differences</h1><blockquote><p>给定一个序列 $\{a_n\}$，将其重排之后使得 $|a_1-a_2|\leq |a_2-a_3|\leq |a_3-a_4|\cdots \le |a_{n-1}-a_n|$。</p></blockquote><p>这题是真的简单，但是我当时 vp 的时候就是愣了很久…也不知道为什么…感觉就是盯着题目脑袋麻木地摸来摸去。</p><p>大概是考虑排个序之后从中间向两边交替着扫，$n$ 是奇数特判一下 $r$ 就好了。</p><h1 id="CF-Round-633-Div1-B-Edge-Weight-Assignment"><a href="#CF-Round-633-Div1-B-Edge-Weight-Assignment" class="headerlink" title="[CF Round#633 (Div1) B] Edge Weight Assignment"></a>[CF Round#633 (Div1) B] Edge Weight Assignment</h1><blockquote><p>给定一棵 $n$ 个点的无根树，要求给每条边分配一个正整数权值，使得任意两个叶子节点之间路径上的边权异或值为 $0$。求最少要多少种不同权值，以及最多可以使用多少种不同权值。</p><p>这里填入的边权值可以为任意大。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>感觉最少的权值数量还是不难猜出来的。大概就是如果两两叶子之间的距离均为偶数，那么就可以用 $1$ 个权值，否则必须要用 $3$ 个。然后这个地方有个 trick，大概就是说发现我们只关心距离的奇偶性，那么就可以用异或来表示距离，同时异或有自反性，所以判据就可以直接变成「某个点到其他点的距离」均为偶数。那么这就可以随便钦定一个叶子当根，然后去比较深度即可。</p><p>最多的权值需要一点贪心。大概就是考虑一定是从根到叶子 $1,2,4,8,16\cdots$ 这样下来，每个叶子的上行边等于祖先的异或和这种感觉。那么这种情况就需要判两点：</p><p>1、如果多个叶子有同一个父亲，那么这些叶子一定是相同的权值，需要减掉。</p><p>2、如果某叶子的深度为 $3$，那么他的上行边和其父亲的上行边权值相同，也需要减掉。</p><h1 id="CF-Round-633-Div1-D-Nested-Rubber-Bands"><a href="#CF-Round-633-Div1-D-Nested-Rubber-Bands" class="headerlink" title="[CF Round#633 (Div1) D] Nested Rubber Bands"></a>[CF Round#633 (Div1) D] Nested Rubber Bands</h1><blockquote><p>给定一棵 n 个点的树，第 $i$ 条边连接 $u_i$ 和 $v_i$。</p><p>你需要将每一个节点画成一个二维平面上闭合几何图形，满足如果 $u$ 和 $v$ 之间有边相连，那么这两个点对应的几何图形边界相交（注意包含不算边界相交）。</p><p>我们定义一个序列 $a_1,a_2,\ldots,a_k$ 是好的，当且仅当对于任意的 $2\le i\le k$，$a_{i-1}$ 所对应的几何图形完全包含 $a_i$ 所对应的几何图形。</p><p>求好的序列最长可以是多少。</p><p>$n\leq 3\times 10^5$ . </p></blockquote><p>题意或多或少有点复杂。感觉还是很考验观察性质的能力的。</p><p>大概就是考虑怎么样的三个点 $x,y,z$ 可以<strong>顺次</strong>出现在序列中？首先一定要是 $x,y,z$ 彼此不相邻，但这并不足够。考虑这个限制中其实 $x,z$ 分量比较轻，对于顺序是否成立关键在于是否可以把 $y$ 插在中间。发现如果 $y$ 想既和 $x$ 无交点但包含 $x$，和 $z$ 无交点但被 $z$ 包含。那么首先不难知道如果 $x-y-z$ 可以构成一条链那么这是可以成立的，如果 $y$ 不在 $x-z$ 上，那么就必须要有 $y$ 到 $x-z$ 的距离为 $1$，因为如果不为 $1$ 就必须要包含更近的那个点，跟定义冲突。</p><p>那么就可以发现最后求的一定是一条链上面挂着一些距离为 $1$ 的散点，在这个毛毛虫上求解最大独立集。于是就可以设 $f_{i,0/1}$ 表示 $i$ 作为链头时，选/不选 $i$ 时的最大毛毛虫独立集。转移的话比较简单，对于 $f_{i,0}$ 只需将 $u$ 的全部非链上临点加入答案即可（即 $\deg_x-2$），$f_{i,1}$ 就是简单累加。注意到这是求的子树内的情况，最后答案用就是</p><script type="math/tex; mode=display">\max_{e(u,v)\in \mathbb{E}}\{ \max\{f_{u,0}+f_{v,1},f_{u,1}+f_{v,0},f_{u,0}+f_{v,0}\}\}</script><p>复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(y, x) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">1</span>] + f[y][<span class="number">0</span>]) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">0</span>] + f[y][<span class="number">0</span>]) ;</span><br><span class="line">        chkmax(ans, f[x][<span class="number">0</span>] + f[y][<span class="number">1</span>]) ;</span><br><span class="line">        chkmax(f[x][<span class="number">0</span>], max(f[y][<span class="number">1</span>], f[y][<span class="number">0</span>]) + deg[x] - <span class="number">2</span>) ;</span><br><span class="line">        chkmax(f[x][<span class="number">1</span>], f[y][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(f[x][1], ' '), debug(f[x][0]) ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CF-Round-399-Combined-C-Jon-Snow-and-his-Favourite-Number"><a href="#CF-Round-399-Combined-C-Jon-Snow-and-his-Favourite-Number" class="headerlink" title="[CF Round#399(Combined) C] Jon Snow and his Favourite Number"></a>[CF Round#399(Combined) C] Jon Snow and his Favourite Number</h1><blockquote><p>你有一串长度为 $n$ 的序列 $a$，重复 $k$ 次操作。问操作后的序列的极值。 </p><p>操作: 将序列从小到大排序,从 $1$ 标号,对序号为奇数的数 <code>^(xor)</code> $x$.</p><p>$n\leq 10^5,k\leq 10^3$。</p></blockquote><p>打个表发现有循环节，然后我就 naive 地觉得循环节大小一定是 $2$ 导致爆了 OJ。</p><p>发现循环节的长度不会超过 $200$。于是就可以暴力 $200$ 次找出循环节来然后做。这样的复杂度是 $O(200\cdot n)$ 的。</p><p>关于循环节，个人的理解仅限于 <code>xor</code> 运算有自反性，所以显然循环节应该是偶数长度的。</p><p>…不会编了。就当是一个乱搞吧= =</p><h1 id="CF-Round-399-Combined-G-The-Winds-of-Winter"><a href="#CF-Round-399-Combined-G-The-Winds-of-Winter" class="headerlink" title="[CF Round#399(Combined) G] The Winds of Winter"></a>[CF Round#399(Combined) G] The Winds of Winter</h1><blockquote><p>给定一棵有根树。若删去一个节点和所有与他相连的边，则会得到一个森林。你希望这个森林中节点最多的树的节点个数尽量少，于是你可以进行至多一次如下操作：</p><p>删除一个节点和其父亲之间的边，把这个节点连到某个节点上。这个操作不得改变森林中树的个数。</p><p>对于每个节点，输出它作为删去的节点时，进行至多一次操作后的最大树大小的最小值。</p><p>输入格式中，一条边的一个端点是 $0$ 说明另一个端点是根。</p><p>$1\leq n\leq 3\times 10^5$ 。</p></blockquote><p>首先可以发现，这个操作是具有贪心性质的。必然是从 $x$ 分出的最大 size 连通块里找出一棵子树连接到最小的 size 的连通块里。那么最后答案就是</p><script type="math/tex; mode=display">\max\{size_p-\zeta,size_q+\zeta,size_o\}</script><p>其中 $p$ 是最大的连通块， $q$ 是最小的连通块，$o$ 是次大连通块，$\zeta$ 是摘下来的子树。那么不难知道这个东西是凸的。那么就考虑去二分这个 $ans$ ，$check$ 的时候自然需要满足</p><script type="math/tex; mode=display">\begin{aligned}size_p-\zeta&\leq ans\\size_q+\zeta&\leq ans\\size_o&\leq ans\end{aligned}</script><p>考虑最后一个是定值，于是可以直接设成二分的下界。观察前面两个，本质上就是在查周围分出去的连通块里是否存在一个大小合适的子树 $\zeta$。于是就变成了一个拿 <code>mulity-set</code> 维护 dsu on tree 的直观题目。</p><p>维护起来有些麻烦。考虑按照 dfs 序分别维护自己子树内的、祖先链上的、祖先除了自己以外的那些子孙。后面两个可以不断边插边删来做，而自己子树内的则可以考虑由于信息重复率大，所以采用启发式分治(启发式合并)策略——结合轻重链剖分的理论，因为从根到每个点至多经过 $\log n$ 条轻边，所以考虑每个点都只向自己的轻祖先贡献。那么过程就是先分治轻儿子并且清空贡献，然后暴力重儿子，再将轻儿子合并到重儿子的信息里。通过聚和分析不难知道这样是 $O(n\log n)$ 的。这也就是 dsu on tree 的过程。</p><p>最后有点细节需要注意，大概就是什么特判 $p=q$ 之类的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line">sint other ;</span><br><span class="line">sint dads ;</span><br><span class="line">sint s[N] ;</span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> rt ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> mx[N] ;</span><br><span class="line"><span class="keyword">int</span> mn[N] ;</span><br><span class="line"><span class="keyword">int</span> smx[N] ;</span><br><span class="line"><span class="keyword">int</span> son[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line">    fa[x] = dad ; sz[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">        <span class="keyword">if</span> (k != dad)&#123;</span><br><span class="line">            dfs(k, x) ;</span><br><span class="line">            sz[x] += sz[k] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[x]) son[x] = k ;</span><br><span class="line">            <span class="keyword">if</span> (sz[son[x]] &lt; sz[k]) son[x] = k ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != rt)</span><br><span class="line">        other.ins(sz[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(x == rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; v &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; mx[x] &lt;&lt; " " &lt;&lt; mn[x] &lt;&lt; " " &lt;&lt; sz[x] &lt;&lt; " " &lt;&lt; son[x] &lt;&lt; " " &lt;&lt; s[x].size() &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (mx[x] == sz[son[x]])&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = s[x].lwb(mx[x] - v) ;</span><br><span class="line">        <span class="keyword">if</span> (t != s[x].js() &amp;&amp; *t &lt;= v - mn[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = other.lwb(mx[x] - v) ;</span><br><span class="line">        <span class="keyword">if</span> (t != other.js() &amp;&amp; (*t) &lt;= v - mn[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">auto</span> pq = dads.lwb(mx[x] - v + sz[x]) ;</span><br><span class="line">        <span class="keyword">if</span> (pq != dads.js() &amp;&amp; (*pq) &lt;= v - mn[x] + sz[x]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//mn[x] + x &lt;= ans -&gt; x &lt;= ans - mn[x]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    debug(x, ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(other.size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(s[x].size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(dads.size()) ;</span></span><br><span class="line">    <span class="keyword">if</span> (!isrt(x))&#123;</span><br><span class="line">        other.era(other.fd(sz[x])) ;</span><br><span class="line">        <span class="keyword">if</span> (!isrt(fa[x])) dads.ins(sz[fa[x]]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    mn[x] = n - sz[x] ;</span><br><span class="line">    mx[x] = max(n - sz[x], sz[son[x]]) ;</span><br><span class="line">    smx[x] = min(n - sz[x], sz[son[x]]) ;</span><br><span class="line"><span class="comment">//    debug(x, '*') ;</span></span><br><span class="line"><span class="comment">//    debug(mn[x], '*') ;</span></span><br><span class="line"><span class="comment">//    debug(mx[x], '*') ;</span></span><br><span class="line"><span class="comment">//    debug(smx[x], '\n') ;// puts("")</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        solve(k) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k]) other.ins(t) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x])&#123;</span><br><span class="line">        solve(son[x]) ;</span><br><span class="line">        swap(s[x], s[son[x]]) ;</span><br><span class="line">        chkmin(mn[x], sz[son[x]]) ;</span><br><span class="line">        <span class="keyword">if</span> (!mn[x]) mn[x] = sz[son[x]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        chkmin(mn[x], sz[k]) ;</span><br><span class="line">        chkmax(smx[x], sz[k]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k])</span><br><span class="line">            other.era(other.find(t)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = smx[x], r = mx[x], mid ;</span><br><span class="line">    <span class="keyword">if</span> (smx[x] == mx[x]) <span class="keyword">goto</span> ycy ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!chk(mid, x)) l = mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> ans[x] = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ycy : <span class="keyword">if</span> (!ans[x]) ans[x] = mx[x] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (k == son[x]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : s[k]) s[x].ins(t) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isrt(x) &amp;&amp; !isrt(fa[x]))</span><br><span class="line">        dads.era(dads.fd(sz[fa[x]])) ;</span><br><span class="line">    s[x].ins(sz[x]) ;</span><br><span class="line"><span class="comment">//    debug(x, ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(other.size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(s[x].size(), ' ') ;</span></span><br><span class="line"><span class="comment">//    debug(dads.size()) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[k]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) rt = x + y ;</span><br><span class="line">        <span class="keyword">else</span> E[x].p_b(y), E[y].p_b(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    debug(son, 1, n) ;</span></span><br><span class="line"><span class="comment">//    debug(sz, 1, n) ;</span></span><br><span class="line">    solve(rt) ;</span><br><span class="line">    output() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="CF-Round-400-Combined-D-The-Door-Problem"><a href="#CF-Round-400-Combined-D-The-Door-Problem" class="headerlink" title="[CF Round 400(Combined) D] The Door Problem"></a>[CF Round 400(Combined) D] The Door Problem</h1><blockquote><p>给定 $n$ 扇门 $m$ 把钥匙，每一把钥匙会同时控制 $k$ 扇门，每扇门最多被两把钥匙控制。求是否存在一个使用钥匙的方法使得全部的门都变成开的。</p></blockquote><p>降智题。一开始一直在想怎么建图，胡了一个对每扇门建俩点表示开关，被捆绑的状态连边，然后去 check 是否存在一扇门的两个状态在一个 dsu 里…然后就发现读错题了，因为并不一定要用到所有钥匙…</p><p>不过有一个很强的性质，就是「每扇门最多被两把钥匙控制」。然后就可以很高兴地对钥匙建虚点。也就是说对于一把钥匙建立俩点，一个表示用了一个表示没用。然后考虑把视线转到门这边，根据「每扇门最多被两把钥匙控制」可知如果某扇门本来是开的，就应该两把钥匙一起用，否则只用一把。根据这个一点建边即可。</p><p>= =人生太艰难了。</p><h1 id="CF-Round-190-Div1-C-Ciel-the-Commander"><a href="#CF-Round-190-Div1-C-Ciel-the-Commander" class="headerlink" title="[CF Round 190(Div1) C] Ciel the Commander"></a>[CF Round 190(Div1) C] Ciel the Commander</h1><blockquote><p>给定一棵树，每个点分配一个字母 <code>A~Z</code>。问是否存在一个分配方案使得任意两点 $(x,y)$ 之间的简单路径上不存在点比 $x$ 或者 $y$ 字典序大的字母。</p><p>$1\leq n\leq3\times 10^5$ 。</p></blockquote><p>可以比较奇妙地做一个代换。考虑对于一个点，他连出的连通块大小分别是 $s_1,s_2,s_3\cdots s_k$。那么不难发现无论这个点是谁，都存在 $\sum s_i=n-1$ 。那么当和不变的时候，各元素分的越平均，两两成绩之和就越大(可以用Cauchy不等式证)。于是可以知道应该按重心分，重心处字典序尽可能小，就变成了一个模拟点分治题。</p><h1 id="CF-Codefest-18-D-Valid-BFS"><a href="#CF-Codefest-18-D-Valid-BFS" class="headerlink" title="[CF Codefest 18 D] Valid BFS ?"></a>[CF Codefest 18 D] Valid BFS ?</h1><blockquote><p>给出一棵树的一个 BFS 序，判断其是否合法。</p></blockquote><p>整理这题是因为自己想的ez方法被叉了…大概就是考虑对这棵树先 dfs 一遍，求出所有深度，然后 BFS 序中一定不会不会存在前面点的深度比后面的小这种情况。然而这是广大必要不充分条件的其中之一，因为没有考虑同一个点的儿子一定是被连续加入队列中这个约束。</p><p>于是可以考虑另一种比较简洁的方法。考虑对每个点的孩子按照给出的 BFS 序里的顺序排一遍序，每次走孩子按照该顺序走。最后检测合法性只需要比对一下和走出来的真实 BFS 序是否一致即可。</p><h1 id="CF-Round-513-Combined-D-Social-Circles"><a href="#CF-Round-513-Combined-D-Social-Circles" class="headerlink" title="[CF Round #513(Combined) D] Social Circles"></a>[CF Round #513(Combined) D] Social Circles</h1><blockquote><p>现在有 $n$ 个人，每一个人都不想周围的人坐得离他很近，所以在他的左边要放 $l_i$ 张空的椅子，右边要放 $r_i$ 张空的椅子。</p><p>现在他们要坐成若干个圈，请问最少要放多少张椅子。</p><p>注意：可以一个人坐在一个圈内，每一个人还需要坐一张椅子。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>一开始觉得是要让所有人按照 $\max\{l_i,r_i\}$ 排个序，然后最优的一定是两两一组判个边界。后来发现假了。比较正确的贪心应该是需要考虑「左右无关」。即由于圈是随便划分的，所以应该对每个 $r_i$ 选一个跟它大小最接近的 $l_i$。这样就可以直接对两个数组排个序然后做了。</p><h1 id="CF-Round-513-Combined-E-Sergey-and-Subway"><a href="#CF-Round-513-Combined-E-Sergey-and-Subway" class="headerlink" title="[CF Round #513(Combined) E] Sergey and Subway"></a>[CF Round #513(Combined) E] Sergey and Subway</h1><blockquote><p>给出一颗 $n$ 个节点的树。现在要将<strong>原图中</strong>每对不直接连边，但是拥有共同邻居的两个点之间连一条边。</p><p>现在需要求出新图中每一个点对 $(i,j) (1 \leq i \leq j \leq n)$ 的经过的边数和。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>再一次惨遭降智，GG。</p><p>不过话说回来这题的 statement 属实弱智。他题面里每个 <code>tunnel</code> 之前都加了 <code>directed</code> 作为修饰，这 tm 告诉我不是代表树形图而是代表每个数对只算一次我也是很佛。出题人是半辈子没说过话吗？非要在题面里把自己知道的形容词都 nmd 列出来一遍？？</p><p>好了，祖安结束。考虑本质上连的这些边对答案的应先就是把原来某些长度为 $2$ 的路径压缩成了长度为 $1$ 的路径。具体的，如果 $(x,y)$ 之间的距离原本是 $p$，那么如果 $p$ 是奇数，路径长度就会变成 $\left\lceil\dfrac{p}{2}\right\rceil$，否则是 $\dfrac{p}{2}$ 。</p><p>考虑距离可以怎么量化。由于</p><script type="math/tex; mode=display">dis(x,y)=dep(x)+dep(y)-2\times dep({\rm LCA}(x,y))</script><p>可以发现最后一项系数是 $2$ 不造成什么影响。于是就可以直接计算 $dep(x)+dep(y)$ 是奇数的贡献了，不难知道这需要 $dep(x),dep(y)$ 中恰好一个点的深度为奇数。 算一下就好了。</p><p>说实话这题降智在考虑到深度那个地方就停了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是和「简单题选做 」捆绑的。&lt;/p&gt;
&lt;p&gt;那个里面用来记录自己秒掉质量还可以的的题目，这个用来记录自己想了/写了好一会儿的题目。&lt;/p&gt;
&lt;p&gt;嗯，加油吧。及时当勉励，岁月不待人。&lt;/p&gt;
&lt;p&gt;就整理 20 个题吧！开新的啦！&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="动态规划/自动机上DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8ADP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树上技巧/dsu on tree" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="字符串/子序列自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%90%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="图论/普通建图技巧" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E6%99%AE%E9%80%9A%E5%BB%BA%E5%9B%BE%E6%8A%80%E5%B7%A7/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="技巧/按位操作" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
      <category term="字符串/Z-Algorithm" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Z-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】四处瞎学东西的笔记</title>
    <link href="https://www.orchidany.cn/2020/05/16/%E5%9B%9B%E5%A4%84%E7%9E%8E%E5%AD%A6%E4%B8%9C%E8%A5%BF%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/05/16/四处瞎学东西的笔记/</id>
    <published>2020-05-16T08:15:52.000Z</published>
    <updated>2020-06-01T01:34:35.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是发现杂七杂八学来的东西没有很必要整理的就从略了。</p><p><del>当然有很多是以前学的结果给忘了。</del></p><p>慢慢更，咕咕咕。</p><a id="more"></a><h1 id="Gauss-Jordan-消元法"><a href="#Gauss-Jordan-消元法" class="headerlink" title="Gauss-Jordan 消元法"></a>Gauss-Jordan 消元法</h1><p>大概就是考虑普通的高斯消元是把矩阵消成上三角矩阵。这样最后就免不了要比较麻烦地回代。然后高斯-约旦消元的想法是直接消成对角矩阵。具体实现大差不差，只是不再消当前行，且每次将其它行都给消一遍。这样最后出来的就会是对角矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gauss_jordan</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[j][i] &gt; f[i][i]) swap(f[j], f[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][i]) &lt; eps) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n + <span class="number">1</span> ; k &gt;= i + <span class="number">1</span> ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] / f[i][i] * f[i][k] ;</span><br><span class="line">        &#125;    </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans[i] = f[i][n + <span class="number">1</span>] / f[i][i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链分治维护dp"><a href="#链分治维护dp" class="headerlink" title="链分治维护dp"></a>链分治维护dp</h1><p>大概就是所谓的动态 $dp$ 。主要针对于一小部分转移比较方便的 dp 来进行维护。大概操作就是通过轻重链剖分(普通重剖)或者虚实链剖分(动态树)之类的，通过分别维护两类儿子的 $dp$ 值来支持修改。那么不难发现当且仅当这个 dp 信息只需要 up 而不需要 bottom。</p><p>然后去用 LCT 写了一发 luogu 的 P4719。之前似乎是做过这题，但当时必然是只会比着抄胡小兔的代码。然后发现轻重链剖是真的难写。LCT的代码要短好多…</p><p>考虑大概就是每个点维护两个 dp 值，$g,f$ ，分别表示「只考虑虚儿子」和「考虑了全部的儿子」时的答案。转移比较简单，写成矩阵的形式就是</p><script type="math/tex; mode=display">\begin{bmatrix}f_{z,0}&f_{z,1}\end{bmatrix}\times \begin{bmatrix}g_{x,0} & g_{x,1}\\g_{x,0} & -\infty\\\end{bmatrix}= \begin{bmatrix}f_{x,0}&f_{x,1}\end{bmatrix}</script><p>其中矩阵乘法的定义为 $\max$ 包含 $+$ 。</p><p>然后记录点实现上的细节吧：</p><p>0、发现 $g$ 不需要用矩阵来维护，直接记录两个值就好了。</p><p>1、考虑在 $access$ 的时候动态维护 $g$ 。因为虚实不断变化。方法是加上新的右子树并且减掉割下来的右子树。</p><p>2、考虑在 <code>push_up</code> 的时候维护 $f$ 。需要注意的是由于 splay 里面深度单调，而这种转移是需要按照深度来转移的，所以需要 <code>f(rc(x)) * trans(x) * f(lc(x))</code> 来做。</p><p>3、有些实现是需要判左右儿子是否为空。其实可以不用。只要把 $f(0)$ 写成单位矩阵就可以了。</p><p>4、这题用 LCT 实现其实是有点大材小用的。因为根本不需要 LCT 的其他什么花里胡哨的操作。</p><p>然后去搞了搞加强版，加了 cyj 的 I/O 之后，靠 rp 爆了十几发(可能不到十发，但反正就是很多发) OJ 就过了/cy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line">vint E[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">2</span>][<span class="number">2</span>] ;</span><br><span class="line">    <span class="function">il <span class="title">mat</span> <span class="params">(<span class="keyword">int</span> a = -P, <span class="keyword">int</span> b = -P, <span class="keyword">int</span> c = -P, <span class="keyword">int</span> d = -P)</span></span>&#123;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>] = a ; m[<span class="number">0</span>][<span class="number">1</span>] = b ;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">0</span>] = c ; m[<span class="number">1</span>][<span class="number">1</span>] = d ;</span><br><span class="line">    &#125;</span><br><span class="line">    il mat <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> mat &amp; a, <span class="keyword">const</span> mat &amp; b)&#123;</span><br><span class="line">        mat c ; <span class="comment">//c.reset() ;</span></span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">1</span>] = max(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">0</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">1</span>] = max(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">1</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">1</span>]) ;</span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">0</span>] = max(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">0</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">0</span>] = max(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">1</span>][<span class="number">1</span>]+ b.m[<span class="number">1</span>][<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">return</span> c ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) s[x].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_0(x) s[x].g[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_1(x) s[x].g[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lct</span>&#123;</span></span><br><span class="line">    mat f ;</span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">2</span>] ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;s[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">w_k</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (lc(fa(x)) == x || rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    f(x) = f(rc(x)) * mat(g_0(x), g_1(x), g_0(x), -P) * f(lc(x)) ; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> da = fa(x) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> dada = fa(da) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">bool</span> w = w_k(x), ww = w_k(da) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(da))</span><br><span class="line">        s[dada].son[ww] = x ;</span><br><span class="line">    fa(x) = dada ;</span><br><span class="line">    fa(s[x].son[w ^ <span class="number">1</span>]) = da ;</span><br><span class="line">    s[da].son[w] = s[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    s[x].son[w ^ <span class="number">1</span>] = da ; fa(da) = x ;</span><br><span class="line">    _up(da) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">if</span> (notroot(fa(x)))</span><br><span class="line">            rotate(w_k(fa(x)) == w_k(x) ? fa(x) : x) ;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    _up(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))&#123;</span><br><span class="line">        splay(x) ;</span><br><span class="line">       g_1(x) += f(rc(x)).m[<span class="number">0</span>][<span class="number">0</span>] - f(y).m[<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">g_0(x) -= max(f(y).m[<span class="number">0</span>][<span class="number">0</span>], f(y).m[<span class="number">0</span>][<span class="number">1</span>]) ;</span><br><span class="line">g_0(x) += max(f(rc(x)).m[<span class="number">0</span>][<span class="number">0</span>], f(rc(x)).m[<span class="number">0</span>][<span class="number">1</span>]) ; </span><br><span class="line">        rc(x) = y ; _up(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prelude</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line">    g_1(x) = base[x] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != dad)&#123;</span><br><span class="line">            fa(k) = x ;</span><br><span class="line">            prelude(k, x) ;</span><br><span class="line">            g_1(x) += g_0(k) ;</span><br><span class="line">            g_0(x) += max(g_0(k), g_1(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f(x) = mat(g_0(x), g_1(x), g_0(x), -P) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gi(n), gi(m) ; <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gi(base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        gi(x), gi(y), E[x].p_b(y), E[y].p_b(x) ;</span><br><span class="line">    prelude(<span class="number">1</span>, <span class="number">0</span>) ; f(<span class="number">0</span>) = mat(<span class="number">0</span>, -P, -P, <span class="number">0</span>) ; </span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        gi(x) ; x ^= lans ;</span><br><span class="line">        gi(y) ; access(x) ; splay(x) ;</span><br><span class="line">        g_1(x) = g_1(x) + y - base[x] ;</span><br><span class="line">        _up(x) ; splay(<span class="number">1</span>) ; base[x] = y ;</span><br><span class="line">        lans = max(f(<span class="number">1</span>).m[<span class="number">0</span>][<span class="number">0</span>], f(<span class="number">1</span>).m[<span class="number">0</span>][<span class="number">1</span>]) ;</span><br><span class="line">        print(lans), pc(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Z-Algorithm"><a href="#Z-Algorithm" class="headerlink" title="Z-Algorithm"></a>Z-Algorithm</h1><p>大概就是俩用途：</p><p>1、给定一个串 $s$ 。求 $s$ 的所有后缀与 $s$ 的 LCP。</p><p>2、给定一个串 $s$ 和一个串 $t$，求 $s$ 的所有后缀与 $t$ 的 LCP。</p><p>本质上跟 ManaCher 十分相似。大概就是求的时候维护一段 LCP 最靠右的子段。然后根据相关信息推一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ; </span><br><span class="line">  <span class="comment">//可以理解为 s[1...i-l+1] = s[l...i],i-l+1向后匹配多少就是i向后可以匹配多少</span></span><br><span class="line">    <span class="keyword">while</span> (t[Z[i]] == t[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ; <span class="comment">//统计新的贡献</span></span><br><span class="line">    <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> &gt; r) r = i + Z[i] - <span class="number">1</span>, l = i ; <span class="comment">//更新LCP最靠右的子段</span></span><br><span class="line">&#125;</span><br><span class="line">Z[<span class="number">1</span>] = n ;</span><br></pre></td></tr></table></figure><p>需要注意的是 $Z[1]$ 一般不是良定义的。如果需要最后可以赋值为串长。</p><p>当然如果对于第二问，可以采取在 $s$ 后面接一个不属于字符集的分隔符再拼上 $t$ 来做。但是也可以另开一个新的函数来做这个。但注意到这个过程需要提前做一遍 $s$ 的 $Z$ ，因为需要通过 $Z$ 来初始化 $Pz$ 。</p><p>这个地方有个<a href="https://www.luogu.com.cn/discuss/show/225597" target="_blank" rel="noopener">小细节</a> 。直接拼一个 <code>#</code> 啥事没有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Z_F&#123;</span><br><span class="line">    <span class="keyword">int</span> L ;</span><br><span class="line">    <span class="keyword">int</span> Q ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="keyword">int</span> Z[N] ;</span><br><span class="line">    <span class="keyword">int</span> Pz[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> bg, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bg ; i &lt; bg + L ; ++ i) Z[i] -- ;</span><br><span class="line">        Z[bg] = L ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_Z</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">int</span> oo = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        L = <span class="built_in">strlen</span>(s + bg) ; l = bg, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bg + <span class="number">1</span> ; i &lt; bg + L ; ++ i)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Z[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Z[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Z[i]] == s[i + Z[i] - <span class="number">1</span>]) ++ Z[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Z[i] - <span class="number">1</span>) r = i + Z[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!oo) gao(bg, L) ; </span><br><span class="line">        <span class="comment">//debug(Z, 1, L) ; </span></span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exKMP</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> bg, <span class="keyword">char</span> *t, <span class="keyword">int</span> gb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = get_Z(s, bg, <span class="number">1</span>) ; s[q + <span class="number">1</span>] = <span class="string">'#'</span> ; </span><br><span class="line">        L = <span class="built_in">strlen</span>(t + gb) ; l = gb, r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i) Pz[i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Pz[i] = min(Z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (s[Pz[i]] == t[i + Pz[i] - <span class="number">1</span>]) ++ Pz[i] ;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; i + Pz[i] - <span class="number">1</span>) r = i + Pz[i] - <span class="number">1</span>, l = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gb ; i &lt; gb + L ; ++ i) Pz[i] -- ;</span><br><span class="line"><span class="keyword">return</span> L ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF126B-Password"><a href="#CF126B-Password" class="headerlink" title="CF126B Password"></a>CF126B Password</h2><blockquote><p>给一个串，找到一个既是前缀又是后缀并且还是非前后缀子串的最长子串。</p><p>$n \leq 10^6$。</p></blockquote><p>被降智了好久…一开始写了一堆奇奇怪怪的东西发现假的很…</p><p>大概就是先考虑如何快速找出既是前缀又是后缀的。这个可以 KMP 解决，或者用 Z 来枚举每个后缀的 $i+z_i-1$ 是不是等于 $n$ 。然后他还要求在中间出现过。发现我们只关心最大值且不关心中间的串的具体情况，于是就维护一个到现在为止中间的串能匹配上的最长前缀即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    n = get_Z(s, <span class="number">1</span>) ; res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> == n &amp;&amp; Z[i] &lt;= mx)</span><br><span class="line">            <span class="keyword">if</span> (res &lt; Z[i]) res = Z[i], p = i ;</span><br><span class="line">        chkmax(mx, Z[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Just a legend"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &lt;= p + res - <span class="number">1</span> ; ++ i)</span><br><span class="line">        <span class="built_in">putchar</span>(s[i]) ; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF432D"><a href="#CF432D" class="headerlink" title="CF432D"></a>CF432D</h2><blockquote><p>给你一个长度为 $n$ 的长字符串，“完美子串”既是它的前缀也是它的后缀，求“完美子串”的个数且统计这些子串的在长字符串中出现的次数。$n\leq 10^6$ 。 </p></blockquote><p>先把所有的 border 判出来。统计出现次数可以直接开一个桶记录一下每个 $Z_i$ 值出现了多少次，然后后缀和一下就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Z_F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    n = get_Z(s, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans[Z[i]] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (i + Z[i] - <span class="number">1</span> == n)</span><br><span class="line">            res[++ cnt] = Z[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans[i] += ans[i + <span class="number">1</span>] ; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    sort(res + <span class="number">1</span>, res + cnt + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[res[i]]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h1><p>置换本质上是一个排列到另一个排列的一一映射。置换的乘法就对应于函数复合。</p><p>同时一个置换也可以分解成许多轮换，比如 $\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;5\\3&amp;4&amp;5&amp;2&amp;1\end{pmatrix}$ 其中就包含了 $(1\to 3,3\to 5,5\to1)$ 和 $(2\to 4,4\to 2)$ 这两个循环移位。</p><p>嗯…以上是抄书。然后考虑 $\sf Burnside$ 引理，即对于一个定义在集合 $\sf G$ 上的置换群 $\rm F$ 而言，设 $f(s)$ 为在群内某个置换 $s$ 本质不变的 $\sf G$ 内元素个数(即「不动点个数」)，那么等价类个数为：</p><script type="math/tex; mode=display">\frac{1}{|\mathsf G|} \cdot \sum_{s\in \mathrm{F}} f(s)</script><p>但是这个不动点个数有时候会比较难求。而 $\sf Polya$ 定理则在陈述这么一件事：考虑对集合 G 作用的元素进行 $k-$染色，那么某个置换 $s$ 下不动点的个数就是 $k^{\zeta(s)}$，其中 $\zeta(s)$ 是 $s$ 可以分解成的轮换的个数。然后就变成了：</p><script type="math/tex; mode=display">\frac{1}{|\mathsf G|} \cdot \sum_{s\in \mathrm{F}} k^{\zeta(s)}</script><p>也就是如果「本质不同」的方式使用染色来定义的话，就可以用 $\sf Polya$ 来优化计算过程。</p><h2 id="UVA-10294-Arif-in-Dhaka"><a href="#UVA-10294-Arif-in-Dhaka" class="headerlink" title="UVA 10294 Arif in Dhaka"></a>UVA 10294 Arif in Dhaka</h2><blockquote><p>求 $n$ 点 $t$ 染色的项链数和手镯数。</p></blockquote><p>项链数比较好求，考虑置换群内的元素分别是顺时针旋转 $0,1,2\cdots n-1$ 个元素，那么假设旋转了 $i$ 个元素，此时每个轮换内会有 $\dfrac{\mathrm{lcm}(n,i)}{i}$ 个元素(总距离除以步长)， 那么也就是说总共会有 $\dfrac{n}{\dfrac{\mathrm{lcm}(n,i)}{i}}$ 个轮换，也就是 $\gcd(n,i)$ 个轮换。</p><p>手镯数需要加上对称。考虑当 $n$ 为奇数，一共有 $n$ 条对称轴，每条对称轴划分为 $\dfrac{n-1}{2}$ 个长度为 $2$ 的轮换和 $1$ 个长度为 $1$ 的轮换，那么轮换数就是 $\dfrac{n+1}{2}$ ；当 $n$ 为偶数时，会有两种对称方式，分别有 $\dfrac{n+1}{2}$  和 $\dfrac{n}{2}$ 种轮换。</p><p>哦，小细节，由于本质上手镯里面每条对称轴都是一个单独的置换，所以应该乘个系数。</p><h2 id="NWERC2006-Leonado’s-Notebook"><a href="#NWERC2006-Leonado’s-Notebook" class="headerlink" title="NWERC2006 Leonado’s Notebook"></a>NWERC2006 Leonado’s Notebook</h2><blockquote><p>给定一个置换 $A$ ，求是否存在一个置换 $B$ 使得 $B^2=A$ 。</p></blockquote><p>考虑将置换分解成轮换。注意到如果两个轮换彼此之间不交，那么他们之间的乘法是具有交换律的。同时考虑对于一个奇数大小的轮换，将其平方之后依旧是一个轮换，偶数大小的平方之后则可以分解成两个轮换。所以对于给定的置换，长度为奇数的轮换可以不用管，如果长度为偶数的轮换有奇数个就会 gg。</p><p>具体证明的话，大概是全部相同大小的置换都可以属于同一个置换群，之后就可以对于每个轮换重标号来证明了。</p><p>不过轮换的乘法比较…麻烦。比如 $(1~2~3)(1~2~3)=(1~3~2)$ ，$(1~2~3~4)(1~2~3~4)=(3~4~1~2)=(1,3)(2,4)$ 。感觉自己一碰到这种置换的就 gg。</p><h2 id="UVA11077-Find-the-Permutations"><a href="#UVA11077-Find-the-Permutations" class="headerlink" title="UVA11077 Find the Permutations"></a>UVA11077 Find the Permutations</h2><blockquote><p>给定一个排列，每次可以交换两个数，求至少需要交换 $k$ 次才能让排列递增的排列数。</p></blockquote><p>发现可以将给定的这个排列看做 $(1,2,3\cdots n)$ 的一个置换。那么考虑将其轮换分解之后，对于一个大小为 $k$ 的轮换，不难发现需要交换 $k-1$ 次。于是可以 dp，$f_{i,j}$ 表示长度为 $i$ 的排列至少交换 $j$ 次的排列方案数。那么每次考虑新加进来的元素是否放到之前的某个轮换里，故有转移</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j}+(i-1)\cdot f_{i-1,j-1}</script><p>……发现这就是第一类斯特林数。原因是考虑如果有 $p$ 个轮换，那么至少需要交换 $n-p$ 次。而第一类斯特林数的意义就包括 $n$ 元置换可分解为 $k$ 个独立的轮换(轮换)的个数，所以答案就应该是 $s_1(n,n-k)$。而用上面这种推法推出来的东西恰与第一类斯特林数水平对称。</p><h2 id="CERC-SWERC2005-Pixel-Shuffle"><a href="#CERC-SWERC2005-Pixel-Shuffle" class="headerlink" title="CERC/SWERC2005 Pixel Shuffle"></a>CERC/SWERC2005 Pixel Shuffle</h2><blockquote><p>给定一些关于 $n\times n$ 的黑白方格的奇怪操作，求至少多少次操作可以变换会原来的样子。</p><p>$n\leq 1024,k\leq10$ 。</p></blockquote><p>发现本质上是给定一个置换 $A$，求一个最小的 $m$ 使得 $A^m=I$ 。然后大概就是考虑轮换的性质。对于 $A$ 中的一个长度为 $p$ 的轮换，如果想要全等，就必须要让 $p|m$ 。所以最后答案就是所有轮换大小的最小公倍数。  </p><p>找轮换的话大概就是对每个位置编一个号，找就好了。UVA 属实神必 OJ，和过了的程序拍了一万组交上去依旧 WAWAWA。遇到这种情况那必然是不管了。</p><p>发现中国 OJ 这么多题，刘汝佳非要找 UVA 写书。真是 mdzz。</p><p>不过倒是过了主席的魔改版，这里留个链接: <a href="https://www.luogu.com.cn/problem/U107438" target="_blank" rel="noopener">戳</a> 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"><span class="keyword">int</span> tmp[N][N] ;</span><br><span class="line"><span class="keyword">int</span> base[N][N] ;</span><br><span class="line"><span class="keyword">int</span> dododo[<span class="number">99</span>] ;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">5000</span>] ;</span><br><span class="line"><span class="keyword">char</span> tpo[<span class="number">5000</span>] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N * N] ;</span><br><span class="line"><span class="keyword">unsigned</span> ll ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[j][n - i + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[j][n - i + <span class="number">1</span>] = tmp[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n / <span class="number">2</span> + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>  + <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n / <span class="number">2</span> + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                base[i][j] = tmp[i][n - j + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(mk) == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span> ; i &lt;= n / <span class="number">4</span> * <span class="number">3</span> ; ++ i)</span><br><span class="line">            swap(base[i], base[n - (i - n / <span class="number">2</span>) + <span class="number">1</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n / <span class="number">2</span> ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[i], tmp[j], <span class="keyword">sizeof</span>(tmp[j])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>, j = <span class="number">2</span> ; i &lt;= n ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[i], tmp[j], <span class="keyword">sizeof</span>(tmp[j])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> ; i &lt;= n / <span class="number">2</span> ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[j], tmp[i], <span class="keyword">sizeof</span>(tmp[i])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>, j = <span class="number">2</span> ; i &lt;= n ; ++ i, j += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(base[j], tmp[i], <span class="keyword">sizeof</span>(tmp[i])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">7</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = n / <span class="number">2</span>, r = n / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) l = <span class="number">0</span>,  r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][j] = tmp[i][++ l] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][j] = tmp[i + <span class="number">1</span>][++ r] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][j] = tmp[i - <span class="number">1</span>][++ l] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][j] = tmp[i][++ r] ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mk == <span class="number">-7</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                tmp[i][j] = base[i][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = n / <span class="number">2</span>, r = n / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) l = <span class="number">0</span>,  r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i][++ l] = tmp[i][j] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i + <span class="number">1</span>][++ r] = tmp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; <span class="number">1</span>) base[i - <span class="number">1</span>][++ l] = tmp[i][j] ;</span><br><span class="line">                    <span class="keyword">else</span> base[i][++ r] = tmp[i][j] ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; base[i][j] &lt;&lt; " \n"[j == n] ;</span></span><br><span class="line"><span class="comment">    puts(" - - - - - - - - - - - - - ") ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> owo = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i][j] != (++ owo)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, cnt ;</span><br><span class="line"><span class="keyword">unsigned</span> ll res[N * N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> ll <span class="title">gcd</span><span class="params">(<span class="keyword">unsigned</span> ll x, <span class="keyword">unsigned</span> ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> ll <span class="title">lcm</span><span class="params">(<span class="keyword">unsigned</span> ll x, <span class="keyword">unsigned</span> ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y / gcd(x, y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    ++ cnt ;</span><br><span class="line"> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line"> dododo[cnt] = <span class="number">-1</span>, ++ s ; <span class="keyword">else</span> dododo[cnt] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"tor"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"mys"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"myshb"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">4</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"mysvb"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">5</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"vid"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">6</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">"xim"</span>) == <span class="number">0</span>) dododo[cnt] *= <span class="number">7</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"gen.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"aa.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; getchar() ;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line"><span class="built_in">memset</span>(base, <span class="number">0</span>, <span class="keyword">sizeof</span>(base)) ;</span><br><span class="line">        ans = <span class="number">1</span>, tot = cnt = <span class="number">0</span> ;</span><br><span class="line">        fgets(opt, (<span class="keyword">sizeof</span> opt / <span class="keyword">sizeof</span> opt[<span class="number">0</span>]), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j) base[i][j] = ++ k ;</span><br><span class="line">        m = <span class="built_in">strlen</span>(opt) ; <span class="keyword">int</span> ps = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (opt[i] != <span class="string">' '</span>) tpo[ps ++] = opt[i] ;</span><br><span class="line">            <span class="keyword">else</span> tpo[ps] = <span class="string">'\0'</span>, record(tpo), ps = <span class="number">0</span> ;</span><br><span class="line">        tpo[ps] = <span class="string">'\0'</span> ; record(tpo) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) do_do(dododo[i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[base[i][j]]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> x = i, y = j, z, o = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">while</span> (!vis[base[x][y]])&#123;</span><br><span class="line">                    vis[base[x][y]] = <span class="number">1</span> ; z = base[x][y] ;</span><br><span class="line">                    x = z / n + (!(<span class="keyword">bool</span>)(z % n == <span class="number">0</span>)) ;</span><br><span class="line">                    y = z % n ; <span class="keyword">if</span> (!y) y = n ; ++ o ;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">                res[++ tot] = o ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        debug(res, 1, tot) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = lcm(ans, res[i]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, tot &gt;= <span class="number">1</span> ? ans : <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (T) <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">-2 -6 -7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></div><h1 id="最大流-ISAP"><a href="#最大流-ISAP" class="headerlink" title="最大流-ISAP"></a>最大流-ISAP</h1><p>大概就是设 $d_x$ 表示残量网络上 $x$ 到汇点 $t$ 的距离。那么为了只在残量网络上进行增广，所以每次只能沿着 $d_y+1=d_x$ 的 $(x,y)$ 增广。那么普通的 Dinic 的想法是每次求出一张增广网，然后对这张增广网进行多路增广，为了保证增广路之间不相交所以引入了高度的概念。ISAP 也差不多。只不过是在找增广路的过程中动态地修改标号。即考虑在增广的过程中，可能会有一些边 $(x,y)$ 从残量网络中抹掉，那么如果这条边用来传递标号的边，即 $d_y+1=d_x$，就需要找到另一条边 $(x,z)$ 并给 $x$ 重标号一个高度为 $d_z+1$ 。这个过程可以一开始用一个 bfs 来预处理，不难看出应该倒着预处理，因为在某条边被删掉之后，从 <code>from</code> 找 <code>to</code> 比从 <code>to</code> 找 <code>from</code> 要简单得多，当然这也是为什么 ISAP 对高度的定义和 Dinic 相反的原因(Dinic 其实无所谓怎么定义，因为横竖都要重新生成增广网)。当源点 $s$ 无处增广时算法停止。</p><p>那么有一个优化叫做「gap 优化」。大概就是考虑一条增广路上的点的标号必然是单调的。那么如果出现了某个断层，可以知道不再存在增广路。于是可以直接结束。</p><p>实现方面，可以记一个当前弧来保证只在残量网络上增广。</p><p>最终可以知道 ISAP 本质上是在和 Dinic 做同一件事，因为 ISAP 的重标号一定会是标定最小的那个 $z$ 的 $h_z+1$ ，跟求增广网本质相同。所以复杂度上界也是 $O(n^2m)$ 的。</p><p>哦，顺便提一嘴。似乎有证明当容量均为 $1$ 时，复杂度有着更加优秀的上界 $O(m\sqrt[3] {n^2}+m\sqrt m)$ 。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ISAP&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        <span class="keyword">int</span> flow ;</span><br><span class="line">        <span class="keyword">int</span> cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="keyword">int</span> ans ;</span><br><span class="line">    <span class="keyword">int</span> S, T ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> hgt[N] ;</span><br><span class="line">    <span class="keyword">int</span> cur[N] ;</span><br><span class="line">    <span class="keyword">int</span> gap[N] ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        e[++ cnt] = edge(x, y, c) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur)) ;</span><br><span class="line">        <span class="built_in">memset</span>(hgt, <span class="number">0</span>, <span class="keyword">sizeof</span>(hgt)) ;</span><br><span class="line">        <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preBFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        h = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line">        que[++ t] = T ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                <span class="keyword">if</span> (!hgt[e[k].to] &amp;&amp; e[k].to != T)</span><br><span class="line">                    hgt[que[++ t] = e[k].to] = hgt[x] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gap[hgt[i]] ++ ;</span><br><span class="line"><span class="comment">//        debug(hgt, 1, n) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Augment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = T ;</span><br><span class="line">        <span class="keyword">int</span> f = Inf ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line"><span class="comment">//            debug(x) ;</span></span><br><span class="line">            f = min(f, e[pre[x]].cap - e[pre[x]].flow) ;</span><br><span class="line">            x = e[pre[x]].from ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += f ; x = T ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            e[pre[x]].flow += f ;</span><br><span class="line">            e[pre[x] ^ <span class="number">1</span>].flow -= f ;</span><br><span class="line">            x = e[pre[x]].from ;<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = cur[x] ; k &lt; E[x].size() ; ++ k)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = E[x][k] ;</span><br><span class="line"><span class="comment">//             debug(e[p].to) ;//0</span></span><br><span class="line">            <span class="keyword">if</span> (e[p].flow &gt;= e[p].cap) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (hgt[e[p].to] + <span class="number">1</span> != hgt[x]) <span class="keyword">continue</span> ;</span><br><span class="line">            pre[e[p].to] = p ; cur[x] = k ;</span><br><span class="line">            y = e[p].to ; ret = <span class="number">1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preBFS() ;</span><br><span class="line">        <span class="keyword">int</span> x = S ;</span><br><span class="line">        <span class="keyword">while</span> (hgt[S] &lt; n)&#123;</span><br><span class="line"><span class="comment">//            debug(x) ;</span></span><br><span class="line">            <span class="keyword">if</span> (x == T)</span><br><span class="line">                Augment(), x = S ;</span><br><span class="line">            <span class="keyword">if</span> (!Advance(x, x))&#123;</span><br><span class="line">                <span class="keyword">int</span> h = n - <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">                    <span class="keyword">if</span> (e[k].flow &lt; e[k].cap)</span><br><span class="line">                        h = min(h, hgt[e[k].to]) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!-- gap[hgt[x]]) <span class="keyword">break</span> ;</span><br><span class="line">                gap[hgt[x] = h + <span class="number">1</span>] ++ ; cur[x] = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">if</span> (x != S) x = e[pre[x]].from ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            break ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t ;</span><br></pre></td></tr></table></figure></div></div><h1 id="KM-算法"><a href="#KM-算法" class="headerlink" title="KM 算法"></a>KM 算法</h1><p>呃，这算法真的是学了很久。以下默认求的是最大权匹配。</p><p>是用来求「完美匹配」基础上的「最佳权值匹配」。「完美匹配」大概就是说对于一张二分图 $G=\{V_1,V_2,E\}$，设 $|V_1|\lt |V_2|$，对于某个匹配 $M’$ 如果可以使得  $V_1$ 中的点均可以被匹配到，那么就称 $M’$ 为 $G$ 的一个完美匹配。</p><p>然后 KM 算法大概是对于每个点设置一个顶标 $p_i$ 或者 $q_i$ （区分左右部，左部记为 $p$，右部记为 $q$），保证 $p_i+q_j\geq w(i,j)$ 。定义 $G$ 的一个相等子图 $G_0=\{V_1,V_2,E_0\}$，需要有 $\forall e(u,v)\in E_0,p_u+q_v=w(u,v)$。那么不难知道如果相等子图 $G_0$ 存在完美匹配 $M_0$，那么 $M_0$ 就是最大权完美匹配。这一点不难证明，只需要注意 $G_0$ 同样包含所有 $G$ 中的顶点即可。</p><p>那么KM 算法本质上就是在不断扩大相等子图的范围实现增广，直到存在完美匹配。假设当前 $G_0$ 中的点集分别为 $\rm \{S,T\}$，那么考虑为了扩大相等子图，需要修改顶标。</p><p>具体的，让 $\rm S$ 中的所有点顶标增加一个权值 $a$，让 $T$ 中所有点的顶标减小一个权值 $a$ ，那么可知 $G_0$ 中原来的点依旧属于 $G_0$ ，同时对于某个点对 $(u,v),u\in \mathrm{S},v\in V_2\setminus T$，可以知道会有 $p_u+q_v$ 变小，那么就会出现可能把 $(u,v)$ 也加入相等子图的情况。那么不难知道为了保证顶标合法且有新的边加入相等子图，$a$ 需要满足 $a=\min\{p_u+q_v-w(u,v)\},u\in \mathrm{S},v\in V_2\setminus T$ 。考虑加入了这条边之后，要么 $v$ 是未盖点，要么 $v$ 是匹配点。就可以直接进行类似匈牙利算法的过程。考虑对于每个点，至多会增广 $n$ 次，每次增广是 $O(n)$ 的，修改顶标可以 $O(n)$ 查找，那么复杂度就应该是 $O(n^3)$（虽然我一开始写的是暴力找 $a$ 的 $O(n^4)$，但实际上可以记一个 <code>slack</code>）解决这个问题。</p><p>看上去很棒？实际上大多数人实现的 <code>dfs</code> 都是 $O(n^4)$ 的。原因在于每次找增广路并不是 $O(n)$ 而是 $O(m)$ 的。为了解决这个问题就要避免类似 <code>dfs</code> 的过程里反复遍历交错树的情况。于是考虑 <code>bfs</code> ，这样聚合分析一下每次找增广路就会是严格  $O(m)$ 的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Km3=KM of O(n^3), Km4=KM of O(n^4)</span></span><br><span class="line"><span class="keyword">namespace</span> KM&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span> ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    ll ans ;</span><br><span class="line">    ll lack ;</span><br><span class="line">    ll lv[N] ;</span><br><span class="line">    ll rv[N] ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> q[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> matl[N] ;</span><br><span class="line">    <span class="keyword">int</span> matr[N] ;</span><br><span class="line">    ll slack[N] ;</span><br><span class="line">    <span class="keyword">bool</span> visl[N] ;</span><br><span class="line">    <span class="keyword">bool</span> visr[N] ;</span><br><span class="line">    ll val[N][N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        n = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            matl[i] = matr[i] = <span class="number">0</span> ;</span><br><span class="line">            pre[i] = lv[i] = rv[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                lv[i] = max(lv[i], val[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visl[i]) lv[i] -= lack ;</span><br><span class="line">            <span class="keyword">if</span> (visr[i]) rv[i] += lack ;</span><br><span class="line">            <span class="keyword">else</span> slack[i] -= lack ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">do_match4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        visl[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span> ; y &lt;= n ; ++ y)</span><br><span class="line">            <span class="keyword">if</span> (!visr[y])&#123;</span><br><span class="line">                ll t = lv[x] + rv[y] - val[x][y] ;</span><br><span class="line">                <span class="keyword">if</span> (!t)&#123;</span><br><span class="line">                    visr[y] = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (!matl[y] || do_match4(matl[y]))&#123;</span><br><span class="line">                        matl[y] = x ; matr[x] = y ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> slack[y] = min(slack[y], t) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Km4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                slack[j] = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">                lack = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">                fill(visl + <span class="number">1</span>, visl + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                fill(visr + <span class="number">1</span>, visr + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">if</span> (do_match4(i)) <span class="keyword">break</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (!visr[i]) lack = min(lack, slack[i]) ;</span><br><span class="line">                upd() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans += lv[i], ans += rv[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match_back</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z ;</span><br><span class="line">        <span class="keyword">while</span> (x)&#123;</span><br><span class="line">            z = x ;</span><br><span class="line">            matl[x] = pre[x] ;</span><br><span class="line">            x = matr[pre[x]] ;<span class="comment">//2</span></span><br><span class="line">            matr[pre[z]] = z ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_match3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        q[++ t] = x ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">int</span> z = q[h ++] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span> ; y &lt;= n ; ++ y)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (visr[y]) <span class="keyword">continue</span> ;</span><br><span class="line">                    ll v = lv[z] + rv[y] - val[z][y] ;<span class="comment">//3</span></span><br><span class="line">                    <span class="keyword">if</span> (v &gt; slack[y]) <span class="keyword">continue</span> ; pre[y] = z ;</span><br><span class="line">                    <span class="keyword">if</span> (!v)&#123;</span><br><span class="line">                        visr[y] = <span class="number">1</span> ;</span><br><span class="line">                        <span class="keyword">if</span> (!matl[y]) <span class="keyword">return</span> match_back(y) ;</span><br><span class="line">                        <span class="keyword">else</span> visl[q[++ t] = matl[y]] = <span class="number">1</span> ;<span class="comment">//5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> slack[y] = min(slack[y], v) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lack = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ; <span class="keyword">int</span> z = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!visr[i])</span><br><span class="line">                    <span class="keyword">if</span> (lack &gt; slack[i])</span><br><span class="line">                        lack = slack[i], z = i ;</span><br><span class="line">            upd() ; <span class="comment">//4</span></span><br><span class="line">          <span class="comment">//debug(z) ;</span></span><br><span class="line">            <span class="keyword">if</span> (!matl[z]) <span class="keyword">return</span> match_back(z) ;</span><br><span class="line">            visr[z] = visl[matl[z]] = <span class="number">1</span> ; q[++ t] = matl[z] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Km3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(visl, <span class="number">0</span>, <span class="keyword">sizeof</span>(visl)) ;</span><br><span class="line">            <span class="built_in">memset</span>(visr, <span class="number">0</span>, <span class="keyword">sizeof</span>(visr)) ;</span><br><span class="line">            <span class="built_in">memset</span>(slack, <span class="number">127</span>, <span class="keyword">sizeof</span>(slack)) ;</span><br><span class="line">            h = <span class="number">1</span> ; t = <span class="number">0</span> ; visl[i] = <span class="number">1</span> ; do_match3(i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans += lv[i], ans += rv[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nl, nr, n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">memset</span>(KM :: val, <span class="number">-127</span>, <span class="keyword">sizeof</span>(KM :: val)) ;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        x = qr(), y = qr(), z = qr() ;</span><br><span class="line">        KM :: val[x][y] = z ;</span><br><span class="line">    &#125;</span><br><span class="line">    KM :: reset(n) ;</span><br><span class="line">    KM :: Km3() ; <span class="built_in">cout</span> &lt;&lt; KM :: ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; KM :: matl[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>upd: 重写了一遍，易错的地方都在板子里标出来了。</p><h1 id="ZKW-费用流"><a href="#ZKW-费用流" class="headerlink" title="ZKW 费用流"></a>ZKW 费用流</h1><p>比较神奇的费用流。考虑一般费用流的做法是改良版的EK，即每次对着残量网络跑一遍最短路，然后对着一条边都满足 $d_v=d_u+val(u,v)$ 的路径进行增广。单路增广必然会很慢，于是来考虑一下为什么必须要单路增广：考虑最短路算法保证在算法结束后，对于残量网络上的每个节点 $x$ 的所有入点 $y$ 有 $d_y+val(y,x)\geq d_x$，且至少存在一个 $y$ 可以使等号成立。那么在残量网络上找出一条增广路之后，与普通的最大流(边权为 $1$)不同的是，剩余的参量网络对于每个 $x$ 不一定会继续存在一个 $y$ 使得等号成立，所以这就需要重新找增广路。</p><p>而 $zkw$ 费用流的思想则是如何不用每次跑一遍最短路来增广，需要引入顶标概念，此处的顶标就是从 $\rm S$ 开始的最短路长度 $d_i$，即有</p><script type="math/tex; mode=display">d_i-d_j+val(i,j)\geq 0</script><p>那么发现跟 KM 的本质极其相似：只增广等号成立的点，那么为了可以使得等号成立就需要不断扩大相等子图，扩大的方式也如出一辙，只需要让所有增广过的点的顶标减去一个 $ \rm lack$ ，而这个 $\rm lack$ 就理应是</p><script type="math/tex; mode=display">\min_{u\in V,v\not\in V}\{d_u-d_v+val(u,v)\}</script><p>这样就可以继续增广了。</p><p>然后写法方面需要注意一些细节。我所知道的应该是有两种写法：</p><p>1、只依赖自动调整。这个写法有个很关键的依赖，就是 $t_{\rm S}$ <strong>单调不增</strong>。换句话说，每次调整 $t_{\rm S}$ 必须要满足存在某条边可以增广，但是此时 $t_{\rm S}$ 并不是单纯地跟某条边的边权挂钩，它只是一个在不断减小的量。所以不难理解，如果存在某个时刻增广到了 $\rm T$ ，那么就一定有 $\sum c=-t_{\rm S}$ ，因为无论什么时候，$\rm S$ 都会在扩展完毕的集合里。</p><p>于是就可以知道，$t_{\rm S}$ 的初值应该赋为 $\rm S$ 所有出边里边权最大的那一条。或者可以直接赋值为 $-\rm Inf$ ，让其自己调整。</p><p>2、大概是个优化？可以考虑在最开始的时候跑一遍最短路。设增广路上的点按顺序分别是 $\rm S,u_1,u_2\cdots u_m,T$ 那么此时每条增广路的 $cost$ 之和就是 </p><script type="math/tex; mode=display">(t_{\rm T}-t_{\rm u_m})+(t_{\rm u_m}-t_{\rm u_{m-1}})\cdots+(t_{\rm u_1}-t_{\rm S})</script><p>化简一下可以得到就是 $t_{\rm T}-t_{\rm S}$ 。</p><p>其实第一个 $case$ 最后的结果本质上也是 $t_T-t_S$ ，然而因为 $T$ 的 $t$ 始终为 $0$，所以可以忽略。看怎么理解了，也可以直接推出 $-t_S$ 。</p><p>事实证明第二种确实比第一种要快。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = x &gt; y ? y : x ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zkw&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cap(k) e[k].cap</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cost(k) e[k].cost</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> from(k) e[k].from</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> flow(k) e[k].flow</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        <span class="keyword">int</span> flow ;</span><br><span class="line">        <span class="keyword">int</span> cost ;</span><br><span class="line">        <span class="keyword">int</span> cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, cost = d, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> mflow ;</span><br><span class="line">    <span class="keyword">int</span> mcost ;</span><br><span class="line">    <span class="keyword">int</span> val[N] ;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] ;</span><br><span class="line">    <span class="keyword">int</span> n, S, T ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="keyword">sizeof</span>(val)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">//        debug(x, ' '), debug(y, ' '), debug(c, ' '), debug(d) ;</span></span><br><span class="line">        e[++ cnt] = edge(x, y, c, d) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>, -d) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">127</span>, <span class="keyword">sizeof</span>(val)) ;</span><br><span class="line">        val[que[h = t = <span class="number">1</span>] = S] = <span class="number">0</span>, vis[S] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            vis[x] = <span class="number">0</span> ; <span class="comment">//debug(x) ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])&#123;</span><br><span class="line">                <span class="keyword">if</span> (!cap(k)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (val[to(k)] &gt; val[x] + cost(k))&#123;</span><br><span class="line">                    val[to(k)] = val[x] + cost(k) ;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[to(k)])</span><br><span class="line">                        vis[que[++ t] = to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        vis[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (x == T)&#123;</span><br><span class="line"><span class="comment">//            debug(f, ' '), debug(- val[S]) ;</span></span><br><span class="line">            mcost += (val[T] - val[S]) * f ;</span><br><span class="line">            mflow += f ; <span class="keyword">return</span> f ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fl = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">            <span class="keyword">if</span> (flow(k) &lt; cap(k))</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)] &amp;&amp; val[to(k)] == val[x] + cost(k))</span><br><span class="line">                    <span class="keyword">if</span> ((fl = advance(to(k), min(f, cap(k) - flow(k)))))</span><br><span class="line">                        <span class="keyword">return</span> flow(k) += fl, flow(k ^ <span class="number">1</span>) -= fl, fl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lack = <span class="number">1</span> &lt;&lt; <span class="number">30</span> ;</span><br><span class="line">        <span class="keyword">if</span> (vis[T] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (flow(i) &lt; cap(i) &amp;&amp; vis[from(i)] &amp;&amp; !vis[to(i)])</span><br><span class="line">                chkmin(lack, val[from(i)] - val[to(i)] + cost(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (lack == <span class="number">1</span> &lt;&lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) val[i] -= lack ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        spfa() ;</span><br><span class="line"><span class="comment">//        debug(val, 1, n) ;</span></span><br><span class="line">        mflow = <span class="number">0</span> ; mcost = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line">            advance(S, <span class="number">1</span> &lt;&lt; <span class="number">30</span>) ;</span><br><span class="line">        &#125;<span class="keyword">while</span> (modify()) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mflow &lt;&lt; <span class="string">" "</span> &lt;&lt; mcost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t ;</span><br><span class="line">    zkw :: reset(s, t, n) ;</span><br><span class="line">    <span class="keyword">int</span> x, y, f, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x, &amp;y, &amp;f, &amp;c) ;</span><br><span class="line">        zkw :: add(x, y, f, c) ;</span><br><span class="line">    &#125;</span><br><span class="line">    zkw :: solve() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>这一部分是跟 <code>__stdcall</code> 学的。感觉他讲的真的是最详细的了。这个地方安利一下：<a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">戳</a> 。</p><p>以下默认用 $(u,v,\mathrm{lower},\mathrm{upper})$ 来描述一条带有上下界的弧，用 $(u,v,{\rm cap})$ 表示正常流图里的一条弧。</p><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>大概是考虑先建立一个虚的源和汇 $\rm S, \rm T$。然后考虑对于一条弧 $(u,v,c_1,c_2)$ 将其拆成 $({\rm S}, v,c_1),(u, {\rm T},c_1),(u,v,c_2-c_1)$ 三条正常流图的弧(称前两条弧为<strong>附加弧</strong>)，跑最大流。之后对于每条非附加弧，流量加上这条弧原本该有的下界 $c_2$ 就是每条弧的实际流量。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>大概就是所有附加弧保证了一定会流满下界。非附加弧承载的则是「自由流量」，是没有下界可以随便流的弧。不难发现如果所有附加弧都满载，最后流的一定会是一个可行流。</p><h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模"></a>建模</h3><p>考虑在上一个模型的基础上稍加修改。设原图的源和汇分别是 $s,t$ （下同），那么添加一条 $(t,s,+\infty)$ 的弧即可。这样最后跑出来的就是原图的一个可行流，同时弧 $(t,s)$ 的流量就是原图的总流量。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>考虑有源汇和无源汇本质上区别就在于，有源汇的图里，$s,t$ 是不满足流量平衡的。所以为了维护流量平衡，就需要建一条 $(t,s,+\infty)$ 的弧来疏通流量。</p><h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><h3 id="建模-2"><a href="#建模-2" class="headerlink" title="建模"></a>建模</h3><p>考虑先跑一下可行流，如果有可行流，那么就在<strong>跑完的残量网络上</strong>再跑一次<strong>从原图的源到原图的汇的最大流</strong>，即 $s\to t$ 的最大流。那么第二次最大流的结果减就是所求的最大流。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>考虑在一次可行流之后，原图的一定是满足流量下界的。同时因为 $t\to s$ 弧的存在，在新的流图上 $t\to s$ 积攒在反向边 $(s,t)$ 中的流量会直接流给 $t$ 。同时只需要让剩下的边流到不能流就好了。</p><h2 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h2><h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模 1"></a>建模 1</h3><p>首先按照<strong>无源汇可行流</strong>的方式建图。跑一下。之后再把 $(t,s,+\infty)$ 建回去，跑一遍从 $\rm S\to T$ 的最大流，然后去 check 是否合法，如果合法即为答案。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理 1"></a>原理 1</h3><p>考虑本质上是要让可行流最小。根据上文可以知道一组可能流的流量就是 $t\to s$ 的流量，那么为了让可以不流过 $t\to s$ 的流量尽量不要流过这条弧，可以先不考虑这条弧尽量流一波，之后再跑包含这条弧的最大流。这样一方面是可行流，另一方面也会让可行流最小。</p><h3 id="建模-2"><a href="#建模-2" class="headerlink" title="建模 2"></a>建模 2</h3><p>首先按照<strong>有源汇可行流</strong>的方式建图。跑一下，记此时的可行流为 $f_1$ 。之后从 $\rm T\to S$ 跑一遍最大流，记此时的流为 $f_2$。那么答案就是 $f_1-f_2$ 。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理 2"></a>原理 2</h3><p>考虑正向边流量和反向边流量是对称的，那么考虑原图中的一个可行流中，某些弧的流量可以变小，那么如果使反向边流量尽量大，就可以使正向边流量尽量小。同时可以知道这样是一定合法的，因为附加弧不会被流，会被流的只有非附加弧，同时非附加弧不可能出现流量为负。所以不难知道这样是对的。</p><div><div class="fold_hider"><div class="close hider_title">「My-Code」</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ISAP&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cap(k) e[k].cap</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> cost(k) e[k].cost</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> from(k) e[k].from</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> flow(k) e[k].flow</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from ;</span><br><span class="line">        ll flow ;</span><br><span class="line">        ll cap ;</span><br><span class="line">        <span class="keyword">int</span> to ;</span><br><span class="line">        edge (<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, ll c = <span class="number">0</span>)&#123;</span><br><span class="line">            from = a, to = b, cap = c, flow = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[N] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    ll ans ;</span><br><span class="line">    <span class="keyword">int</span> cnt ;</span><br><span class="line">    <span class="keyword">int</span> S, T ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> que[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> hgt[N] ;</span><br><span class="line">    <span class="keyword">int</span> cur[N] ;</span><br><span class="line">    <span class="keyword">int</span> gap[N] ;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; E[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll c)</span></span>&#123;</span><br><span class="line">        e[++ cnt] = edge(x, y, c) ; E[x].push_back(cnt) ;</span><br><span class="line">        e[++ cnt] = edge(y, x, <span class="number">0</span>) ; E[y].push_back(cnt) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur)) ;</span><br><span class="line">        <span class="built_in">memset</span>(hgt, <span class="number">0</span>, <span class="keyword">sizeof</span>(hgt)) ;</span><br><span class="line">        <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap)) ;</span><br><span class="line">        S = x, T = y, n = z ; cnt = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) E[i].clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prebfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        que[h = t = <span class="number">1</span>] = T ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[h ++] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                <span class="keyword">if</span> (!hgt[to(k)] &amp;&amp; to(k) != T)</span><br><span class="line">                    hgt[que[++ t] = to(k)] = hgt[x] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) gap[hgt[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Aug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = T ;</span><br><span class="line">        ll z = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span> ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            chkmin(z, cap(pre[x]) - flow(pre[x])) ;</span><br><span class="line">            x = from(pre[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += z ; x = T ;</span><br><span class="line">        <span class="keyword">while</span> (x != S)&#123;</span><br><span class="line">            flow(pre[x]) += z ;</span><br><span class="line">            flow(pre[x] ^ <span class="number">1</span>) -= z ;</span><br><span class="line">            x = from(pre[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Advance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = cur[x] ; d &lt; E[x].size() ; ++ d)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = E[x][d] ;</span><br><span class="line">            <span class="keyword">if</span> (flow(k) &gt;= cap(k)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (hgt[x] != hgt[to(k)] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">            cur[x] = d ; ret = <span class="number">1</span> ;</span><br><span class="line">            pre[y = to(k)] = k ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        prebfs() ; <span class="keyword">int</span> x = S ;</span><br><span class="line">        <span class="keyword">while</span> (hgt[S] &lt; n)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span> (x == T)</span><br><span class="line">                Aug(), x = S ;</span><br><span class="line">            <span class="keyword">if</span> (!Advance(x, x))&#123;</span><br><span class="line">                <span class="keyword">int</span> minh = n - <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x])</span><br><span class="line">                    <span class="keyword">if</span> (flow(k) &lt; cap(k))</span><br><span class="line">                        chkmin(minh, hgt[to(k)]) ;</span><br><span class="line">                <span class="keyword">if</span> (!-- gap[hgt[x]]) <span class="keyword">return</span> ;</span><br><span class="line">                gap[hgt[x] = minh + <span class="number">1</span>] ++ ; cur[x] = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">if</span> (x != S) x = from(pre[x]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NO_Lower_Upper_Feasible&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c1 &gt;&gt; c2 ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isap() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span> ; i &lt;= cnt ; i += <span class="number">6</span>)&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; from(i) &lt;&lt; " " &lt;&lt; to(i) &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; flow(i) + cap(i - <span class="number">2</span>) &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> YES_Lower_Upper_Maximum&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c1 &gt;&gt; c2 ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">        add(t, s, <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        isap() ; <span class="comment">//debug(ans) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        S = s, T = t ; </span><br><span class="line">      ans = <span class="number">0</span> ; isap() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> YES_Lower_Upper_Minimum&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> :: ISAP ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y ; ll c1, c2 ;</span><br><span class="line">        reset(n + <span class="number">1</span>, n + <span class="number">2</span>, n + <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            x = qr() ;</span><br><span class="line">y = qr() ;</span><br><span class="line">c1 = qr() ;</span><br><span class="line">c2 = qr() ;</span><br><span class="line">            add(S, y, c1) ;</span><br><span class="line">            add(x, T, c1) ;</span><br><span class="line">            add(x, y, c2 - c1) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        isap() ; <span class="comment">//debug(ans) ;</span></span><br><span class="line">        add(t, T, <span class="number">0</span>) ;</span><br><span class="line">        add(S, s, <span class="number">0</span>) ;</span><br><span class="line">        add(t, s, <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line">        ans = <span class="number">0</span> ; isap() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (from(i) == S &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (to(i) == T &amp;&amp; flow(i) != cap(i)) <span class="keyword">goto</span> fuck ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        fuck : <span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="上下界费用流"><a href="#上下界费用流" class="headerlink" title="上下界费用流"></a>上下界费用流</h2><p>和最大流没什么本质区别。唯一的不同在于，比如求最小费用最大流的时候第二遍只清空 <code>mflow</code> 而不清空 <code>mcost</code>。因为有一部分流是通过 $t\to s$ 这个不定费用弧流过来的，这时是不计算流量的。感觉其他的也大差不差？稍微改一波就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是发现杂七杂八学来的东西没有很必要整理的就从略了。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;当然有很多是以前学的结果给忘了。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;慢慢更，咕咕咕。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
      <category term="网络流/带有上下界的网络流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%B8%A6%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="图论/匹配/KM算法" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-KM%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学/高斯消元" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="字符串/Z-Algorithm" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Z-Algorithm/"/>
    
      <category term="数学/置换,轮换" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BD%AE%E6%8D%A2-%E8%BD%AE%E6%8D%A2/"/>
    
      <category term="动态规划/链分治维护dp" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%93%BE%E5%88%86%E6%B2%BB%E7%BB%B4%E6%8A%A4dp/"/>
    
      <category term="技巧/min-max容斥" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-min-max%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIP2018/CSP2019]题目整理</title>
    <link href="https://www.orchidany.cn/2020/05/11/NOIP2018-CSP2019/"/>
    <id>https://www.orchidany.cn/2020/05/11/NOIP2018-CSP2019/</id>
    <published>2020-05-11T02:27:47.000Z</published>
    <updated>2020-06-05T00:10:58.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是重做了一下 NOIP2018/CSP2019 两年的全部题目？</p><p>感觉当时场上没 A 掉的题，放到现在做总是感觉有点心理阴影emm</p><p>Anyway, 只用真正告别过去才能走向未来。你说，对吧？</p><a id="more"></a><p>题目排序为按时间排序。题面看心情加（</p><h1 id="NOIP2018"><a href="#NOIP2018" class="headerlink" title="NOIP2018"></a>NOIP2018</h1><h2 id="A-铺设道路"><a href="#A-铺设道路" class="headerlink" title="A 铺设道路"></a>A 铺设道路</h2><p>考场上并没想到正解。读完题之后觉得每次一定都是选当前段内最小的那个高度来操作，所以就用线段树套了个分治；后来又发现只有询问，于是就变成了 ST 表套了个分治。最后…大概是线性的吧。（但其实大家写的 ST 表都不是线性的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> P = query(l, r) ;</span><br><span class="line">    <span class="keyword">int</span> L = l, R = r ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (query(L, mid) == P) R = mid ;</span><br><span class="line">        <span class="keyword">else</span> L = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> W = L ; </span><br><span class="line">    Ans += (base[W] - delta), delta += (base[W] - delta) ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; work(l, W - <span class="number">1</span>, delta), work(W + <span class="number">1</span>, r, delta) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-货币系统"><a href="#B-货币系统" class="headerlink" title="B 货币系统"></a>B 货币系统</h2><p>无脑背包题。感觉两年前的自己真的是菜的一匹…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">N = qr(), ans = <span class="number">0</span> ; </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)) ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, o, mxm = <span class="number">0</span> ; dp[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base[i] = qr(), mxm = max(base[i], mxm) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (i != k &amp;&amp; base[k] != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> (j = base[k] ; j &lt;= mxm ; ++ j)</span><br><span class="line">dp[j] |= dp[j - base[k]] ;</span><br><span class="line"><span class="keyword">if</span> (dp[base[i]]) base[i] = <span class="number">-1</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ans += (<span class="keyword">bool</span>)(base[i] == <span class="number">-1</span>) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, N - ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-赛道修建"><a href="#C-赛道修建" class="headerlink" title="C 赛道修建"></a>C 赛道修建</h2><blockquote><p>用 $m$ 条不相交的链覆盖一棵树，最大化长度最小的链。</p><p>$2 \leq n \leq 5 \times 10^{4}, 1 \leq m \leq n-1$。</p></blockquote><p>当时考场上写的是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">2000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">else</span> FFF = LCA(i, j), Ans = max(Ans, Sum[i] + Sum[j] - <span class="number">2</span> * Sum[FFF]) ;</span><br><span class="line"><span class="keyword">if</span> (M &gt; <span class="number">1</span>) Ans = Ans / M + rand()%(Ans / (M - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……也不知道自己咋想的。</p><p>然后这次复盘的时候还读错了题，读成了「必须要把全部的边都覆盖」，觉得这种二维限制的怎么可能去二分…感到十分弱智。</p><p>之后就变成了考虑二分答案，是否可以选 $\geq m$ 条 $\geq val$ 的边不相交链。感觉似乎是可以 bottom to top 地 dp 一波顺便转移一下没有闭合的链。</p><p>这题确实很水，这个贪心已经自然到证都不用证的地步了 233。</p><p>一开始打算用 vector 维护。发现需要支持删除和排序就换成了 set。然后还有 <code>multiset</code> 的一些细节没有注意。多亏了 zay，不然我又要调上一年…还有很多其他的细节没有注意，感觉在考场上势必还是要挂分。慢慢练吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;<span class="keyword">int</span>&gt; sint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, g ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line">sint chain[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    sint t ; t.clear() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">int</span> z ;</span><br><span class="line">        dfs(to(k), x, w) ; f[x] += f[to(k)] ;</span><br><span class="line">z = (*chain[to(k)].begin()) + val(k) ;</span><br><span class="line">        <span class="keyword">if</span> (z &gt;= w) ++ f[x] ; <span class="keyword">else</span> t.insert(z) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " &amp; " &lt;&lt; (*chain[to(k)].begin()) + val(k) &lt;&lt; " " ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; t.size() &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">if</span> (t.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(chain[x].insert(<span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">auto</span> s = t.begin() ;</span><br><span class="line">    <span class="keyword">while</span> (s != t.end())&#123;</span><br><span class="line">        <span class="keyword">int</span> p = w - (*s) ;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">auto</span> q = t.lower_bound(p) ;</span><br><span class="line">        <span class="keyword">if</span> (q == s) ++ q ;</span><br><span class="line">        <span class="keyword">if</span> (q == t.end()) &#123; ++ s ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        t.erase(q) ; s = t.erase(s), ++ f[x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t.empty()) chain[x].insert(<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">else</span> chain[x].insert(*(-- t.end())) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        chain[i].clear(), f[i] = <span class="number">0</span> ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, x) ; <span class="comment">//debug(f, 1, n) ;</span></span><br><span class="line"><span class="keyword">return</span> (f[<span class="number">1</span>] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">    <span class="keyword">int</span> x, y, z, l = <span class="number">10000</span>, r = <span class="number">0</span>, mid, ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        x = qr() ; y = qr() ; z = qr() ;</span><br><span class="line">        add_e(x, y, z), add_e(y, x, z) ; </span><br><span class="line">        r += z ; chkmin(l, z) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            ans = mid, l = mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-旅行"><a href="#D-旅行" class="headerlink" title="D 旅行"></a>D 旅行</h2><blockquote><p>给出一棵树或者一棵基环树，求字典序最小的dfs序。</p><p>The original data range : $1\le n\le 5\times 10^3,n-1\leq m\leq n$ 。</p><p>The extra data range: $1\le n\le 3\times 10^5,n-1\leq m\leq n$。</p></blockquote><p>考虑如果是树的话显然是可以直接贪的。基环树的话就只需要枚举断哪一条边即可。注意断的边不能是桥边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; !del[k])&#123;</span><br><span class="line">            dfs1(to(k), u),</span><br><span class="line">            sz[u] += sz[to(k)],</span><br><span class="line">            son[u].push_back(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, k ; o[++ res] = u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : son[u]) dfs2(k, u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt; y[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x[i] &gt; y[i]) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, u, v ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add(u, v) ;</span><br><span class="line">    <span class="keyword">if</span> (M == N - <span class="number">1</span>)&#123;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            sort(son[i].begin(), son[i].end()) ;</span><br><span class="line">        dfs2(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> ctn = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                fa[j] = j ; del[i] = del[i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; j += <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (del[j]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> f1 = find(fr(j)) ;</span><br><span class="line">                <span class="keyword">int</span> f2 = find(to(j)) ;</span><br><span class="line">                <span class="keyword">if</span> (f1 != f2) fa[f1] = f2 ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                ctn = ctn + (<span class="keyword">bool</span>)(fa[j] == j) ;</span><br><span class="line">            <span class="keyword">if</span> (ctn == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs1(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                    sort(son[j].begin(), son[j].end()) ;</span><br><span class="line">                dfs2(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j) son[j].clear() ;</span><br><span class="line">                <span class="keyword">if</span> (Compare(o, ans))</span><br><span class="line">                    <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            del[i] = del[i + <span class="number">1</span>] = <span class="number">0</span> ; res = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑更快一点怎么做。发现就是一个弱智贪心。然后就没有然后了。</p><p>upd: 香，真香。所谓「弱智贪心」我愣是从 $14:00$ 写到 $20:30$ 。</p><p>大概就是一开始觉得，对于当前环，设环里面离 $1$ 最近的一个点 $k$ 是这个环的<strong>根</strong>，那么他一定有两个儿子都在环上，称这两个儿子中<strong>较小</strong>的那个为<strong>左儿子</strong>，<strong>较大</strong>的为<strong>右儿子</strong>。那么要走肯定会走左儿子(这里设为走 $x$)，并且断的地方一定是左儿子向下找的途中第一个比右儿子大的点 $z$，将 $z$ 留给右儿子那条链，因为这时先走右儿子一定会更优。</p><p>然而这是错的。由于上文钦定了一定要经过 $z$ 之上的点，所以环上所有深度 $&gt;dep_z$ 点的外向枝在回溯时是必须要走的，并且是走完 $z$ 之后就需要接着走。那么如果外向枝中存在点的编号比 $z$ 大，就不如先走 $z$ 再回溯，因为 $z$ 之后紧接的都是比 $z$ 大的。然后想到这里，我大概是用一个值 $v$ 表示从左儿子走到当前点 $z$，沿途外向枝中最大的点的编号。注意细节，如果外向枝中的某些点比当前点要小，那必然是先走外向枝再走现在的点。于是我大概就是这么维护的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bicheck</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)((x == key_f) &amp;&amp; (y == key_s)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == loop_f) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, q, p = <span class="number">0</span>, op = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cld[<span class="number">2</span>] = &#123; loop_s, loop_c &#125;;</span><br><span class="line">        <span class="keyword">if</span> (cld[<span class="number">0</span>] &lt; cld[<span class="number">1</span>])</span><br><span class="line">            t = cld[<span class="number">0</span>], q = cld[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = cld[<span class="number">1</span>], q = cld[<span class="number">0</span>];</span><br><span class="line">        dep[t] = dep[q] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == lj[tot])</span><br><span class="line">            reverse(lj + <span class="number">1</span>, lj + tot + <span class="number">1</span>);</span><br><span class="line">        op = maxx[lj[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; tot; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op &lt;= lj[k])</span><br><span class="line">                op = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (lj[k] &gt; q &amp;&amp; lj[k] &gt; op) &#123;</span><br><span class="line">                key_s = lj[k];</span><br><span class="line">                key_f = lj[k - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; k; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j &gt;= k; --j) dep[lj[j]] = dep[lj[j + <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            op = max(maxx[lj[k]], op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!key_s) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; tot; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而…这还是错的。因为如果上面存在某个外向枝内的点 $x$ 比当前点编号要小，但是在当时并不应该提前走 $x$，那么此时如果走下去，$x$ 就会比当前点的时间戳要靠后，不如直接走 $x$ 。就比如下面这张图，应该断掉 $(3,5)$ ，先走 $5$ 再回溯到 $4$ 显然不如直接走 $4$ 更优。 </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>于是冷静了一下改成用 set 去维护 <code>lower_bound</code> 和当前最小值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stt.insert(maxx[lj[<span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; tot; ++k) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((!stt.empty()) &amp;&amp; (*stt.begin() &lt;= x)) stt.erase(stt.begin());</span><br><span class="line">    <span class="keyword">if</span> (lj[k] &gt; q &amp;&amp; (stt.empty() || stt.lower_bound(lj[k]) != stt.begin())) &#123;</span><br><span class="line">        key_s = lj[k];</span><br><span class="line">        key_f = lj[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; k; ++j) dep[lj[j]] = dep[lj[j - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j &gt;= k; --j) dep[lj[j]] = dep[lj[j + <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stt.insert(maxx[lj[k]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样还是不对…在我冷静了很久之后发现…似乎很难确定到底该走到哪个点断掉，因为这样贪心相当于还是只想了一半<del>期间一度陷入自闭</del>。</p><p>然后灵光一闪。发现外向枝里面可能有比当前大的点，也可能有比当前小的点。那么如果回溯时一定会先去遍历比当前点大的点就肯定不会断，如果一定会去遍历比当前小的点就一定要断。否则如果可以选择先遍历大的还是小的，就可以根据最初的那个 check 来判断到底断不断，因为此时外向枝不再有影响。于是就拿了个线段树维护了一下时间戳。然后就过掉了。</p><p>总结一下，还是自己思路太不清晰、太不仔细导致平白无故浪费了许多时间。写代码的时候不知道为什么，有一种「这样一定是对的」的诡异勇气让我无法静下心来思考…</p><p>还是实战过少。可能需要模拟赛来补救一下这块短板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> key_f ;</span><br><span class="line"><span class="keyword">int</span> key_s ;</span><br><span class="line"><span class="keyword">int</span> loop_f ;</span><br><span class="line"><span class="keyword">int</span> loop_s ;</span><br><span class="line"><span class="keyword">int</span> loop_c ;</span><br><span class="line"><span class="keyword">int</span> fr[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dep[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> base[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> maxx[MAXN] ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])&#123;</span><br><span class="line">        loop_f = x ;</span><br><span class="line">        loop_s = fa ;</span><br><span class="line">        <span class="keyword">int</span> t = loop_s ;</span><br><span class="line">        <span class="keyword">while</span> (t != loop_f)</span><br><span class="line">            base[++ tot] = t, t = fr[t] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            maxx[x] = max(maxx[x], to(k)) ;</span><br><span class="line">            fr[to(k)] = x, dfs3(to(k), x) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bicheck</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)((x == key_f) &amp;&amp; (y == key_s)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seg[MAXN * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    seg[rt] = max(seg[rt &lt;&lt; <span class="number">1</span>], seg[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        seg[rt] = v ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) upd(rt &lt;&lt; <span class="number">1</span>, l, mid, pos, v) ;</span><br><span class="line">    <span class="keyword">else</span> upd(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, v) ; _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> seg[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) chkmax(res, query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr)) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) chkmax(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr)) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == loop_f)&#123;</span><br><span class="line">        <span class="keyword">int</span> t, q, p = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> op = <span class="number">0</span>, pre = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> cld[<span class="number">2</span>] = &#123;loop_s, loop_c&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (cld[<span class="number">0</span>] &lt; cld[<span class="number">1</span>])</span><br><span class="line">            t = cld[<span class="number">0</span>], q = cld[<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">else</span> t = cld[<span class="number">1</span>], q = cld[<span class="number">0</span>] ;</span><br><span class="line">        dep[t] = dep[q] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (t == base[tot])</span><br><span class="line">            reverse(base + <span class="number">1</span>, base + tot + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[base[<span class="number">1</span>]] ; j ; j = next(j))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(j) == x) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (to(j) &lt;= base[<span class="number">2</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">            upd(<span class="number">1</span>, <span class="number">1</span>, n, to(j), dep[base[<span class="number">1</span>]]) ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= tot ; ++ k)&#123;</span><br><span class="line">            chkmax(pre, base[k]) ;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">more_t</span> = query(<span class="number">1</span>, <span class="number">1</span>, n, base[k] + <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">less_t</span> = query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, base[k] - <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">less_t</span> == <span class="keyword">more_t</span> &amp;&amp; pre &gt; q) &#123;</span><br><span class="line">                key_s = base[k] ;</span><br><span class="line">                key_f = base[k - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span> ; j &gt;= k ; -- j)</span><br><span class="line">                    dep[base[j]] = dep[base[j + <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">less_t</span> &gt; <span class="keyword">more_t</span>)&#123;</span><br><span class="line">                key_s = base[k] ;</span><br><span class="line">                key_f = base[k - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span> ; j &gt;= k ; -- j)</span><br><span class="line">                    dep[base[j]] = dep[base[j + <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = base[k] ;</span><br><span class="line">            dep[base[k]] = dep[base[k - <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[y] ; j ; j = next(j))&#123;</span><br><span class="line">                <span class="keyword">if</span> (to(j) == base[k - <span class="number">1</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (to(j) &lt;= base[k + <span class="number">1</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">                upd(<span class="number">1</span>, <span class="number">1</span>, n, to(j), dep[y]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!key_s)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">                dep[base[j]] = dep[base[j - <span class="number">1</span>]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (bicheck(x, to(k))) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (bicheck(to(k), x)) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (dep[to(k)] &amp;&amp; dep[to(k)] != dep[x] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">dfs4(to(k), x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; !bicheck(u, to(k)) &amp;&amp; !bicheck(to(k), u) &amp;&amp; dep[to(k)] == dep[u] + <span class="number">1</span>)</span><br><span class="line">            dfs5(to(k), u), sz[u] += sz[to(k)], son[u].push_back(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, k ; o[++ res] = u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : son[u]) dfs6(k, u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("travel.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("travel.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> i, u, v ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add(u, v), ++ deg[u], ++ deg[v] ;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs3(<span class="number">1</span>, <span class="number">0</span>) ; tot -- ;</span><br><span class="line">        swap(loop_s, loop_f) ;</span><br><span class="line">        <span class="keyword">if</span> (base[<span class="number">1</span>] == loop_s)</span><br><span class="line">             loop_c = base[tot] ;</span><br><span class="line">        <span class="keyword">else</span> loop_c = base[<span class="number">1</span>] ; dfs4(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">dfs5(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            sort(son[i].begin(), son[i].end()) ;</span><br><span class="line">        dfs6(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">memcpy</span>(ans, o, <span class="keyword">sizeof</span>(o)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-填数游戏"><a href="#E-填数游戏" class="headerlink" title="E 填数游戏"></a>E 填数游戏</h2><p>考虑暴力的话自然是搜索…当时在考场上写了好久…幸亏最后调出来了。依稀记得最后 $30min$ 调出来这个搜索之后，找到规律之后无比兴奋…兴奋到没有打最后一题的暴力qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Ans ; <span class="keyword">char</span> S[<span class="number">20000</span>][<span class="number">200</span>], W[<span class="number">20000</span>][<span class="number">200</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, T[<span class="number">20000</span>], i, j, k, tot, <span class="built_in">map</span>[<span class="number">250</span>][<span class="number">250</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == N &amp;&amp; y == M) &#123;</span><br><span class="line">W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[N][M] + <span class="number">48</span>) ; </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == N) S[tot][step] = <span class="string">'R'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x, y + <span class="number">1</span>, step + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y == M) S[tot][step] = <span class="string">'D'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x + <span class="number">1</span>, y, step + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> S[tot][step] = <span class="string">'R'</span>, W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x, y + <span class="number">1</span>, step + <span class="number">1</span>),</span><br><span class="line"> <span class="built_in">strcpy</span>(S[tot + <span class="number">1</span>], S[tot]), ++ tot, S[tot][step] = <span class="string">'D'</span>, <span class="built_in">strcpy</span>(W[tot], W[tot - <span class="number">1</span>]), W[tot][step] = (<span class="keyword">char</span>)(<span class="built_in">map</span>[x][y] + <span class="number">48</span>), dfs(x + <span class="number">1</span>, y, step + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> A = <span class="number">1</span> ; A &lt; tot ; ++ A)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> B = A ; B &lt;= tot  ; ++ B)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">2</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (S[A][di] &gt; S[B][di]) &#123; flag = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S[A][di] &lt; S[B][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">1</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> ((W[A][di] &gt; W[B][di]) &amp;&amp; flag) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (W[A][di] &lt; W[B][di]) <span class="keyword">break</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> A = <span class="number">1</span> ; A &lt;= tot ; ++ A)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> B = <span class="number">1</span> ; B &lt; A ; ++ B)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">2</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (S[A][di] &lt; S[B][di]) &#123; flag = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S[A][di] &gt; S[B][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">0</span> ; di &lt; N + M - <span class="number">1</span> ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (W[A][di] &lt; W[B][di] &amp;&amp; flag) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (W[A][di] &gt; W[B][di]) <span class="keyword">break</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (B)&#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) res = res * A % Mod ;</span><br><span class="line">A = A * A % Mod, B &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="keyword">if</span> (N &gt; M) swap(N, M) ;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">4</span> &amp;&amp; M &lt;= <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> Max = (<span class="number">1</span> &lt;&lt; N * M) - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)</span><br><span class="line"><span class="built_in">map</span>[j][k] = (<span class="number">1</span> &lt;&lt; tot &amp; i) ? <span class="number">1</span> : <span class="number">0</span>, ++ tot ;</span><br><span class="line">tot = <span class="number">1</span>, dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">if</span> (check()) ++ Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12</span> * expow(<span class="number">3</span>, M - <span class="number">2</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">112</span> * expow(<span class="number">3</span>, M - <span class="number">3</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">5</span> &amp;&amp; M == <span class="number">5</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">7136</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">5</span> &amp;&amp; M == <span class="number">4</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2688</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了一下这个搜索的复杂度。发现大概是什么 $O\left(2^{m\times n}\cdot \binom{n+m-2}{n-1}^2\right)$ 的，这东西在 $n=5,m=5$ 的时候计算量是 $164416716800\approx1.64\cdot 10^{11}$。不过打出 $n=3,m=4/5/6$ 的表来还是戳戳有余的（$n=3,m=6,T=115605504$）。</p><p>然后就又是喜闻乐见的找性质环节：</p><p>1、不难归纳出来，反对角线(即 $n+m$ 为定值)上所有的位置，按照列号从小到大来排布，填的数构成的数列应该<strong>不下降</strong>。具体可以考虑归纳，大概就是说如果有两个序列的一部分只有两步不同，即 <code>...WWWWDDDD...</code> 和 <code>...WWWDWDDD...</code>，那么必然存在一个经过了 $(i,j)$ 而另一个经过了 $(i+1,j-1)$，那么就必然需要 $a_{i+1,j-1}\geq a_{i,j}$。那么一直归纳下去，不难发现这是<strong>必要条件</strong>。</p><p>2、然而只考虑第一点是错的。自己还是把暴力和构造分别打了个表出来才明白哪不对…具体来说比如这个矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>那么 <code>WDDW</code> 和 <code>DWWD</code> 这两个走法的关系就显然不对。然后抽象了一会儿觉得可能是要考虑对称位置，但是发现 $n\ne m$ 时并不可以良定义「对称」；又觉得可能是需要到 $i,j$ 的路径都本质不同，但是发现并不会设计状态来算这个步数…</p><p>还是知乎好！从知乎上学了一波，感觉十分深刻。大概就是考虑如果 $(i,j-1)=(i-1,j)$ ，那么以 $(i,j)$ 为左上角的所有矩阵的反对角线上的数都必须相等。感觉这个抽象十分到位。考虑如果某条对角线上的两个点 $(a_1,b_1),(a_2,b_2)$ 不同，那么必然可以让两条路线让他们在 $(c,d)$ 处分开，一个尽量 <code>W</code> 一个尽量 <code>D</code>，注意到由于 <code>W&amp;D</code> 的数量是固定的，所以尽量 <code>W</code> 的那个一开始字典序一定偏小，那么该路径走到 $(a_2,b_2)$ 就会使答案不合法。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>比较直接的相反就是继续爆搜。发现这样优化了一波之后复杂度变成了 $O(2^{n\times m}\cdot n^2m^2)$ 的，那么 $n=m=5$ 时的运算量就变成了 $20971520000\approx 2.1\cdot 10^{10}$ …好像也没快多少…</p><p>然后大概就是考虑对着这两个条件进行 dp。然后大概发现自己不会怎么 dp 对角线。然后选择剪枝。发现复杂度大头是 $2^{n\times m}$，考虑缩一下这个，大概就是确定每条对角线哪个位置是分界点。那么设 $n\leq m$，这样的复杂度大概是 $O\left((n!)^2\cdot n^{m-n}\cdot n^2m^2\right)$ 。稍微优化一波 <code>checker</code> 就可以做到 $O\left((n!)^2\cdot n^{m-n}\cdot nm\right)$ 。但这样在 $n=m=7$ 的时候大概是 $1244678400=1.24\cdot 10^9$ 依旧不是很能过<del>然后发现(1,1)和(n,n)并不重要就可以有一个1/4的常数</del>。但无论怎样，80 分确实是有了。算了一下 $n=m=8$ 的时候 $  T= 104044953600\approx 10^{11}$，如果按照一秒钟 $5e8$ 的速度大概是 $2000s+$ （其实不到 $2min$ 就出来了），找一波规律就 $100$ 了。</p><p>不知为何似乎有坑点。发现当 $n=6$ 的时候应该拿 $m=7$ 时算的数来算，因为此时似乎 $ans(6,7)\ne3\cdot ans(6,6)$ ？似乎 $n=8$ 时也是这样…挺奇怪的。并且 $8,9$ 至少要多一个 $81$ 倍常数…就很爆炸。不过似乎确实也在 $10min$ 之内出了结果。大力出奇迹啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans, vis[<span class="number">100</span>][<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> owo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i][j] == owo) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i - <span class="number">1</span>][j] == <span class="built_in">map</span>[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = i + <span class="number">1</span> ; x &lt;= n ; ++ x)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = j ; y &lt; m ; ++ y)</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[x][y] == <span class="built_in">map</span>[x - <span class="number">1</span>][y + <span class="number">1</span>])</span><br><span class="line">                            vis[x][y] = owo ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % Mod ;</span><br><span class="line">x = x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == n + m - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(ans += check(++ tot)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span> ; i &lt;= s ; ++ i)&#123;</span><br><span class="line">            x = s, y = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= s - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = s, y = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= s - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &lt;= m)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= n - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= n - i + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t = n - (s - m) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, j, i = <span class="number">0</span>; i &lt;= t ; ++ i)&#123;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span>, j = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= i)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">1</span>, ++ j, x --, y ++ ;</span><br><span class="line">            dfs(s + <span class="number">1</span>) ;</span><br><span class="line">            x = n, y = s - n + <span class="number">1</span>, j = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= i)</span><br><span class="line">                <span class="built_in">map</span>[x][y] = <span class="number">0</span>, ++ j, x --, y ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">if</span> (n + m &lt;= <span class="number">12</span>) dfs(<span class="number">2</span>), <span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> * ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">12l</span>l * expow(<span class="number">3</span>, m - <span class="number">2</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">112l</span>l * expow(<span class="number">3</span>, m - <span class="number">3</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">6</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">170112l</span>l * expow(<span class="number">3</span>, m - <span class="number">7</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">7</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">453504l</span>l * expow(<span class="number">3</span>, m - <span class="number">7</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">8</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">3626752</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">10879488l</span>l * expow(<span class="number">3</span>, m - <span class="number">9</span>) % Mod &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>学了一波状压对角线，感觉自己是弟弟。大概就是考虑如何把两个限制写到状态里面。发现可以设状态 $f_{i,j,s}$ 表示考虑前 $i$ 条对角线，第 $i$ 条对角线从下至少染了 $j$ 个 $1$，对角线上每个位置(以及所包含的那个矩形)是否合法(用 $s$ 表示)的方案数。转移就可以枚举上一条对角线的状态。这样最后就是 $O(2^n\cdot n\cdot n^2\cdot m)$ 的复杂度。</p><p><del>但显然最后答案还是要打表找规律的</del>。</p><h2 id="F-保卫王国"><a href="#F-保卫王国" class="headerlink" title="F 保卫王国"></a>F 保卫王国</h2><blockquote><p>给定树，求最小点覆盖。多组询问，每组询问会钦定两个点被覆盖或者不被覆盖，并询问最小边覆盖。</p><p>$1\leq n,m\leq 10^5$ 。</p></blockquote><h2 id="Sol-1-链分治维护dp"><a href="#Sol-1-链分治维护dp" class="headerlink" title="Sol 1 链分治维护dp"></a>Sol 1 链分治维护dp</h2><p>大概就是考虑最小边覆盖的 $dp$</p><script type="math/tex; mode=display">f_{x,0}=\sum f_{y,1}\\f_{x,1}=\sum \min\{f_{y,1},f_{y,0}\}</script><p>然后考虑设 $g_{x,0}$ 表示只考虑了 $x$ 的轻儿子时的最小边覆盖。那么有</p><script type="math/tex; mode=display">f_{x,0}=g_{x,0}+f_{z,1}\\f_{x,1}=g_{x,1}+\min\{f_{z,0},f_{z,1}\}</script><p>其中 $z$ 是 $x$ 的重儿子。那么不难知道转移矩阵应该写成</p><script type="math/tex; mode=display">\begin{bmatrix}f_{z,0}&f_{z,1}\end{bmatrix}\times \begin{bmatrix}+\infty & g_{x,1}\\g_{x,0} & g_{x,1}\\\end{bmatrix}= \begin{bmatrix}f_{x,0}&f_{x,1}\end{bmatrix}</script><p>然后就可以直接用 LCT 维护链来做了。写的时候有不少细节需要注意…自己还是太菜了…不过 LCT 确实挺短的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> lans;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> base[N];</span><br><span class="line"></span><br><span class="line">vint E[N];</span><br><span class="line"></span><br><span class="line"><span class="function">il ll <span class="title">min</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b &gt; a ? a : b; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    ll m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="function">il ll <span class="title">minx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> min(m[<span class="number">1</span>][<span class="number">0</span>], m[<span class="number">1</span>][<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="function">il <span class="title">mat</span><span class="params">(ll a = Q, ll b = Q, ll c = Q, ll d = Q)</span> </span>&#123;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>] = a;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">1</span>] = b;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">0</span>] = c;</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">1</span>] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    il mat <span class="keyword">friend</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;a, <span class="keyword">const</span> mat &amp;b) &#123;</span><br><span class="line">        mat c;</span><br><span class="line">        c = mat();  <span class="comment">// c.reset() ;</span></span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">1</span>] = min(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">0</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">1</span>] = min(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">1</span>], a.m[<span class="number">1</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        c.m[<span class="number">0</span>][<span class="number">0</span>] = min(a.m[<span class="number">0</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">0</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        c.m[<span class="number">1</span>][<span class="number">0</span>] = min(a.m[<span class="number">1</span>][<span class="number">0</span>] + b.m[<span class="number">0</span>][<span class="number">0</span>], a.m[<span class="number">1</span>][<span class="number">1</span>] + b.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) s[x].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_0(x) s[x].g[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_1(x) s[x].g[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lct</span> &#123;</span></span><br><span class="line">    mat f;</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    ll g[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">&#125; s[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">w_k</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (rc(fa(x)) == x); &#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (lc(fa(x)) == x || rc(fa(x)) == x); &#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    f(x) = mat(Q, g_1(x), g_0(x), g_1(x));</span><br><span class="line">    f(x) = f(rc(x)) * f(x) * f(lc(x));<span class="comment">//1 转移顺序 必须要从下到上转移 即 splay 里要严格按照顺序来转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> da = fa(x);</span><br><span class="line">    <span class="keyword">int</span> dada = fa(da);</span><br><span class="line">    <span class="keyword">bool</span> w = w_k(x), ww = w_k(da);</span><br><span class="line">    <span class="keyword">if</span> (notroot(da))</span><br><span class="line">        s[dada].son[ww] = x;</span><br><span class="line">    fa(x) = dada;</span><br><span class="line">    fa(s[x].son[w ^ <span class="number">1</span>]) = da;</span><br><span class="line">    s[da].son[w] = s[x].son[w ^ <span class="number">1</span>];</span><br><span class="line">    s[x].son[w ^ <span class="number">1</span>] = da;</span><br><span class="line">    fa(da) = x;</span><br><span class="line">    _up(da);</span><br><span class="line">    _up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notroot(fa(x)))</span><br><span class="line">            rotate(w_k(fa(x)) == w_k(x) ? fa(x) : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x = fa(y = x)) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        g_1(x) += f(rc(x)).minx() - f(y).minx();</span><br><span class="line">        g_0(x) += f(rc(x)).m[<span class="number">1</span>][<span class="number">1</span>] - f(y).m[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        rc(x) = y;</span><br><span class="line">        _up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prelude</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span> </span>&#123;</span><br><span class="line">    g_0(x) = <span class="number">0</span>;</span><br><span class="line">    g_1(x) = base[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : E[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != dad) &#123;</span><br><span class="line">            fa(k) = x;</span><br><span class="line">            prelude(k, x);</span><br><span class="line">            g_0(x) += g_1(k);</span><br><span class="line">            g_1(x) += min(g_0(k), g_1(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f(x) = mat(Q, g_1(x), g_0(x), g_1(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _upd(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll v) &#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    s[x].g[y ^ <span class="number">1</span>] += v;</span><br><span class="line">    _up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> pks[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"defense.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"defense.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    qr(n), qr(m);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pks;</span><br><span class="line">    <span class="keyword">int</span> x, y, a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) qr(base[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">      qr(x), qr(y), E[x].p_b(y), E[y].p_b(x);</span><br><span class="line">    prelude(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0</span>) = mat(<span class="number">0</span>, Q, Q, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        qr(x);</span><br><span class="line">        qr(a);</span><br><span class="line">        _upd(x, a, Q);</span><br><span class="line">        qr(y);</span><br><span class="line">        qr(b);</span><br><span class="line">        _upd(y, b, Q);</span><br><span class="line">        splay(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f(<span class="number">1</span>).minx() &gt;= Q)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f(<span class="number">1</span>).minx());</span><br><span class="line">        _upd(x, a, -Q);</span><br><span class="line">        _upd(y, b, -Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sol-2-倍增"><a href="#Sol-2-倍增" class="headerlink" title="Sol 2 倍增"></a>Sol 2 倍增</h2><p>大概就是说，询问之间本身都是独立的。所以如果强行上动态 dp 有点过犹不及。</p><p>于是考虑大力倍增。水平不够暂时咕咕咕了。</p><h1 id="CSP2019"><a href="#CSP2019" class="headerlink" title="CSP2019"></a>CSP2019</h1><h2 id="A-格雷码"><a href="#A-格雷码" class="headerlink" title="A 格雷码"></a>A 格雷码</h2><p>就，模拟一下？我正我是分治了一波。这种题怎么做都可以吧。</p><p>做的时候似乎是特判了一波什么 <code>1&lt;&lt;64</code> 爆 <code>long long</code> 的东西，好像还是挺有用的？ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ull l, ull r, ull p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == p) ans[++ cnt] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> ans[++ cnt] = <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ull mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; mid) solve(l, mid, r - p) ;</span><br><span class="line">    <span class="keyword">else</span> solve(l, mid, p) ;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; mid) ans[++ cnt] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">else</span> ans[++ cnt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-括号树"><a href="#B-括号树" class="headerlink" title="B 括号树"></a>B 括号树</h2><p>啊这，挺水的吧。记着考场上是飞快的想出了 $O(n^2)$ 的做法，想了想可以线性，写了一会儿之后发现不会给 <code>devc++</code> 开栈…就十分尴尬…然后发现如果是一条链的话是有快速写法的，就写了个等价的链做法过了大样例…然后改来改去就拍上了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ff)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mt = <span class="number">0</span> ; fa[u] = ff ;</span><br><span class="line">    <span class="keyword">if</span> (base[u] == <span class="string">'('</span>) stk[++ ctn] = u ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (ctn)&#123;</span><br><span class="line">            mt = stk[ctn --] ;</span><br><span class="line">            g[u] = g[fa[mt]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    f[u] = f[ff] + g[u] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != ff) dfs(to(k), u) ;</span><br><span class="line">    <span class="keyword">if</span> (base[u] == <span class="string">'('</span>) stk[ctn --] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mt) stk[++ ctn] = mt ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-树上的数"><a href="#C-树上的数" class="headerlink" title="C 树上的数"></a>C 树上的数</h2><blockquote><p>给定一个大小为 $n$ 的树，它共有 $n$ 个结点与 $n − 1$ 条边，结点从 $1 \sim n$ 编号。初始时每个结点上都有一个 $1 \sim n$ 的数字，且每个 $1 \sim n$ 的数字都只在<strong>恰好</strong>一个结点上出现。</p><p>接下来你需要进行<strong>恰好</strong> $n − 1$ 次删边操作，每次操作你需要选一条<strong>未被删去</strong>的边，此时这条边所连接的两个结点上的数字将会<strong>交换</strong>，然后这条边将被删去。</p><p>$n − 1$ 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 $1 \sim n$ 所在的结点编号依次排列，就得到一个结点编号的排列 $P_i$。现在请你求出，在最优操作方案下能得到的<strong>字典序最小</strong>的 $P_i$。</p><p>$1\leq n\leq 2\times 10^3$ 。</p></blockquote><p>咕咕咕。</p><p>这种题必然是要自己想的吧。那可能要多想几天。就暂时咕咕咕了。</p><h2 id="D-Emiya-家今天的饭"><a href="#D-Emiya-家今天的饭" class="headerlink" title="D Emiya 家今天的饭"></a>D Emiya 家今天的饭</h2><blockquote><p>给定一个矩阵，每个元素有一个固定的选择方案数 $a_{i,j}$，每一行至多选一个元素，每一列选的元素至多是选择元素总个数的一半，求总方案数。</p><p>$1 \le n \le 100$，$1 \le m \le 2000$，$0 \le a_{i,j} &lt; 998,244,353$ 。</p></blockquote><p>首先对于 $64$ 分 $2\leq m\leq 3$，可以直接暴力记一下每一行选了多少个元素，转移比较 trivial，但是有细节…就是转移的时候不要瞎 jb 判，最后统计答案的时候再判——感觉是个很浅显的结论我竟然调了 $10min+$ ！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][S][S][S] ;</span><br><span class="line"><span class="keyword">int</span> pd[<span class="number">2</span>][S][S][S][S] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;<span class="comment">//m=2</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span> ;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[d])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)&#123;</span><br><span class="line">                add(dp[d][j][k][j - k], dp[d ^ <span class="number">1</span>][j][k][j - k]) ;</span><br><span class="line">                <span class="keyword">if</span> (k)</span><br><span class="line">                    add(dp[d][j][k][j - k], <span class="number">1l</span>l * dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>][j - k] * base[i][<span class="number">1</span>] % P) ;</span><br><span class="line">                <span class="keyword">if</span> (j - k)</span><br><span class="line">                    add(dp[d][j][k][j - k], <span class="number">1l</span>l * dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k][j - k - <span class="number">1</span>] * base[i][<span class="number">2</span>] % P) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ((j &lt;= i / <span class="number">2</span>) &amp;&amp; (i - j &lt;= i / <span class="number">2</span>))</span><br><span class="line">                add(ans, dp[n &amp; <span class="number">1</span>][i][j][i - j]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;<span class="comment">//m=3</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span> ;</span><br><span class="line">    pd[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(pd[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(pd[d])) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)&#123; <span class="comment">// (j-k)+o+(k-o)=j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= k ; ++ o)&#123;</span><br><span class="line">                    add(pd[d][j][j - k][o][k - o], pd[d ^ <span class="number">1</span>][j][j - k][o][k - o]) ;</span><br><span class="line">                    <span class="keyword">if</span> (j - k)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k - <span class="number">1</span>][o][k - o] * base[i][<span class="number">1</span>] % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (o)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k][o - <span class="number">1</span>][k - o] * base[i][<span class="number">2</span>] % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (k - o)</span><br><span class="line">                        add(pd[d][j][j - k][o][k - o], <span class="number">1l</span>l * pd[d ^ <span class="number">1</span>][j - <span class="number">1</span>][j - k][o][k - o - <span class="number">1</span>] * base[i][<span class="number">3</span>] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d ^= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= j ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> ((k &lt;= i / <span class="number">2</span>) &amp;&amp; ((j - k) &lt;= i / <span class="number">2</span>) &amp;&amp; ((i - j) &lt;= i / <span class="number">2</span>))</span><br><span class="line">                    add(ans, pd[n &amp; <span class="number">1</span>][i][k][j - k][i - j]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑更高分做法，大概就是要想到<strong>容斥</strong>。考虑将问题转化成「总方案数-存在某一行 $&gt;\lfloor\frac{k}{2}\rfloor$ 的方案数」，那么发现后面一项，对于某种方案，至多存在一列 $&gt;\lfloor\frac{k}{2}\rfloor$。 所以容斥系数大概就是 $1~0~0\cdots$。那么如果设 $s_i=\sum_{j=1}^m a_{i,j}$ ，可以知道总方案数是 $\prod (s_i+1)-1$。考虑单独一行怎么算，发现只需要记一下总共选了多少个/当前行选了多少个即可。复杂度 $O(n^3m)$，可以获得 $84$ 分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d ; ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            sum[i][j] = addn(sum[i][j - <span class="number">1</span>], base[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * sum[i][m] % P ; dec(ans, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">        d = <span class="number">0</span> ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            d ^= <span class="number">1</span> ; <span class="keyword">int</span> ts ;</span><br><span class="line">            ts = sum[i][m] - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n ; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= n ; ++ o)&#123;</span><br><span class="line">                    f[d][k][o] = f[d ^ <span class="number">1</span>][k][o] ;</span><br><span class="line">                    <span class="keyword">if</span> (k) add(f[d][k][o], <span class="number">1l</span>l * f[d ^ <span class="number">1</span>][k - <span class="number">1</span>][o] * (ts - base[i][j]) % P) ;</span><br><span class="line">                    <span class="keyword">if</span> (k &amp;&amp; o) add(f[d][k][o], <span class="number">1l</span>l * f[d ^ <span class="number">1</span>][k - <span class="number">1</span>][o - <span class="number">1</span>] * base[i][j] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (j - k &lt; k) dec(ans, f[n &amp; <span class="number">1</span>][j][k]) ;</span><br><span class="line">        <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[<span class="number">0</span>])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后发现…本质上也同样不需要第二维。因为在钦定了某一列是最多的之后，就不再需要关心次序，只需要关心是否比其它列的总和要多就好了。所以可以维护这个差分值，相当于将状态合并了。于是最后复杂度 $O(n^2m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d ; ans = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            sum[i][j] = addn(sum[i][j - <span class="number">1</span>], base[i][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * sum[i][m] % P ; dec(ans, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">        d = <span class="number">0</span> ; g[<span class="number">0</span>][n] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            d ^= <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> ts = sum[i][m] - <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">memset</span>(g[d], <span class="number">0</span>, <span class="keyword">sizeof</span>(g[<span class="number">0</span>])) ; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n + n ; ++ k)&#123; g[d][k] = g[d ^ <span class="number">1</span>][k] ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span>) add(g[d][k], <span class="number">1l</span>l * g[d ^ <span class="number">1</span>][k - <span class="number">1</span>] * base[i][j] % P) ;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; n + n) add(g[d][k], <span class="number">1l</span>l * g[d ^ <span class="number">1</span>][k + <span class="number">1</span>] * decn(ts, base[i][j]) % P) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j) dec(ans, g[n &amp; <span class="number">1</span>][n + j]) ;<span class="comment">// , cout &lt;&lt; g[n &amp; 1][n + j] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">memset</span>(g[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(g[<span class="number">0</span>])) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>于是我就把全部的 subtask 都写了，加起来120行左右。</del></p><h2 id="E-划分"><a href="#E-划分" class="headerlink" title="E 划分"></a>E 划分</h2><blockquote><p>给定一个长为 $n$ 的序列 $\{a_n\}$ 。需要找到一些分界点 $1 \le k_1 &lt; k_2 &lt; \cdots &lt; k_p &lt; n$，使得：</p><script type="math/tex; mode=display">\sum_{i=1}^{k_1} a_i\le \sum_{i=k_1+1}^{k_2} a_i \le \dots \le \sum_{i=k_p+1}^n a_i</script><p>同时最小化</p><script type="math/tex; mode=display">\left(\sum_{i=1}^{k_1} a_i \right)^2+\left(\sum_{i=k_1+1}^{k_2} a_i \right)^2+\cdots +\left(\sum_{i=k_p+1}^n a_i \right)^2</script><p>$2 \le n \le 4 \times 10^7 , 1 \le a_i \le 10^9$。</p></blockquote><p>大概一个比较 trivial 的想法是记 $f_{i,v}$ 表示前 $i$ 个数分了某些段，最后一段大小为 $v$ 的 ans。这样大概是可以拿个 $24pts$？然后再高的话就是考虑 $v$ 必然只会是连续一段，所以可以设 $f_{i,j}$ 表示前 $i$ 个数分了某些段，最后一段是 $j\sim i$ 的 ans。然后这样似乎就是 $O(n^3)$ 可以拿到 $40pts$。然后发现有神秘的单调性，大概就是发现最后要最优化的是和的平方，那么肯定是段数越多越优。那么对于每一个 $i$ 的那个使得 $j\sim i$ 最优的决策一定也会让 $len=i-j+1$ 最小。这样就可以存一下每个 $i$ 的最优决策点 $minx_i$ ，就可以实现 $O(n)$ 转移了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr(), s[i] = s[i - <span class="number">1</span>] + base[i] ;  </span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">600</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(dp)), ans = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)&#123;</span><br><span class="line">LL t = (s[i] - s[i - j]) * (s[i] - s[i - j]) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= (i - j) ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (s[i] - s[i - j] &gt;= s[i - j] - s[i - j - k])</span><br><span class="line">dp[i][j] = minn(dp[i][j], dp[i - j][k] + t) ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ans = min(ans, dp[N][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(minx, <span class="number">127</span>, <span class="keyword">sizeof</span>(minx)), minx[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line"><span class="keyword">if</span> (s[i] - s[j] &gt;= minx[j])</span><br><span class="line">minx[i] = min(s[i] - s[j], minx[i]), </span><br><span class="line">f[i] = min(f[i], f[j] + (s[i] - s[j]) * (s[i] - s[j])) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这个单调性似乎可以很强的样子？大概就是发现对于每个 $i$ ，本质上只关心他最小的那一段合法后缀是多少。于是就可以拿一个单调队列来优化了。</p><p>注意单调队列插入队尾时注意转移式的变形。感性来说为了找到最小的那个合法区间，就需要按照 $s_i-s_k\geq m(k)$ ，其中 $i$ 是将来的决策，那么就需要按照 $s_k+m(k)$ 来衡量决策。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">(L128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    out_put(x / <span class="number">10</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (LL)(x % <span class="number">10</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, T ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> q[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> pre[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> base[MAXP] ;</span><br><span class="line"></span><br><span class="line">L128 ans ;</span><br><span class="line">LL s[MAXN] ;</span><br><span class="line">LL minx[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; <span class="number">30</span> ;</span><br><span class="line">LL p, l, r, b, p0 = <span class="number">1</span> ;</span><br><span class="line">LL x, y, z, b1, b2, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    x = qr(), y = qr(), z = qr() ;</span><br><span class="line">    b1 = qr(), b2 = qr(), m = qr() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        p = qr(), l = qr(), r = qr() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = p0 ; j &lt;= p ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>) b = b1 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">2</span>) b = b2 ;</span><br><span class="line">            <span class="keyword">else</span> b = (x * b2 + y * b1 + z) % M, b1 = b2, b2 = b ;</span><br><span class="line">            s[j] = s[j - <span class="number">1</span>] + (b % (r - l + <span class="number">1</span>) + l) ;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        p0 = p + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k ; h = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!T)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            base[i] = qr(), s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> gene() ; j = <span class="number">0</span> ;</span><br><span class="line">    q[++ t] = <span class="number">0</span> ; minx[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t &amp;&amp; s[i] - s[q[h]] &gt;= minx[q[h]])</span><br><span class="line">            j = q[h ++] ; minx[i] = s[i] - s[j] ; pre[i] = j ; </span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t &amp;&amp; minx[q[t]] + s[q[t]] &gt;= minx[i] + s[i]) q[t --] = <span class="number">0</span> ; q[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span> (N)</span><br><span class="line">ans += (L128)minx[N] * minx[N], N = pre[N] ;</span><br><span class="line">    out_put(ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说回来，去年赛场上我甚至没有把数据生成的规则看完…因为并没有时间，也并没有能力(?)去看最后一档部分分。大概是圆了一个未竟的梦吧。</p><h2 id="F-树的重心"><a href="#F-树的重心" class="headerlink" title="F 树的重心"></a>F 树的重心</h2><blockquote><p>小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：</p><ol><li>一个大小为 $n$ 的树由 $n$ 个结点与 $n − 1$ 条无向边构成，且满足任意两个结点间<strong>有且仅有</strong>一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为<strong>恰好</strong>两个子树。</li><li>对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的<strong>重心</strong>当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均<strong>不超过</strong> $\lfloor \frac{n}{2} \rfloor$（其中 $\lfloor x \rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 $1$ 或 $2$ 个。</li></ol><p>课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：</p><script type="math/tex; mode=display">\sum_{(u,v)\in E}\left(\sum_{x\in c(S'_u)} x+\sum_{y\in c(S'_v)} y\right)</script><p>上式中，$E$ 表示树 $S$ 的边集，$(u, v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S’_u$ 与 $S’_v$ 分别表示树 $S$ 删去边 $(u, v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树，$c(S)$ 表示树 $S$ 重心的集合。</p><p>$1\leq n\leq 3\times 10^5$ 。</p></blockquote><h3 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>首先考虑部分分做法？$40pts$ 就是暴力枚举切哪一条边。$55pts$ 的链在瞎映射一通可以 $O(1)$ 求出割完之后两棵树的重心分别是谁。$75pts$ 的满二叉树大概是要先找出 $\deg_x=2$ 的 $x$ ，不难知道这个一定是根，找一波规律可以发现割掉每一条边之后，较小的那一半的重心必然是这个小连通块的根，较大的那部分的重心是对面的另一个儿子，也可能是原树的根。算一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> max_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>], p[<span class="number">5</span>], bg, rt ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, f[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, sz[N], e[N &lt;&lt; <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> dfs1(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa) chkmax(mx, sz[to(k)]), dfs(to(k), u) ;</span><br><span class="line">chkmax(mx, sz[rt] - sz[u]) ; f[u] = mx ;</span><br><span class="line"><span class="keyword">if</span> (f[q[<span class="number">1</span>]] &gt; f[u]) q[<span class="number">1</span>] = u ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[q[<span class="number">2</span>]] &gt; f[u]) q[<span class="number">2</span>] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; max_dep)</span><br><span class="line">        max_dep = dep[x], rt = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs2(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ; rev[dep[x]] = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) redfs(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs3(to(k), x), ans += to(k) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("centroid12.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n, cnt = ans = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k),</span><br><span class="line">add(j, k), e[i][<span class="number">0</span>] = j, e[i][<span class="number">1</span>] = k ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span>,</span><br><span class="line">dfs1(rt = e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">dfs(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">ans += (f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (q[<span class="number">1</span>] + q[<span class="number">2</span>]) : q[<span class="number">1</span>] ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">dfs1(rt = e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">                dfs(e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">ans += (f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (q[<span class="number">1</span>] + q[<span class="number">2</span>]) : q[<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">49991</span>)&#123;</span><br><span class="line">            max_dep = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k), add(j, k) ;</span><br><span class="line">            dfs2(<span class="number">1</span>, <span class="number">0</span>) ; redfs(rt, dep[<span class="number">0</span>] = <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans += rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i / <span class="number">2</span>] + rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">if</span> ((n - i) &amp; <span class="number">1</span>) ans += rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i + (n - i) / <span class="number">2</span>] + rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">262143</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i) deg[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;j, &amp;k) ;</span><br><span class="line">                add(j, k), ++ deg[j], ++ deg[k] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (deg[i] == <span class="number">2</span>) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">            dfs3(rt, <span class="number">0</span>) ; ans += <span class="number">1l</span>l * rt * (n / <span class="number">2l</span>l + <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = next(k))</span><br><span class="line">                ans += <span class="number">1l</span>l * to(k) * (n - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后考虑满分怎么做。以下设 $x$ 为当前点，$y_k$ 为 $x$ 的第 $k$ 个孩子(顺序随便定的)，$z$ 为 $x$ 的重儿子，设 $s$ 为割下来的连通块大小。 </p><p>这个满分做法，我自己推的比较烦，不如其他人简洁。大概就是计算每个点当重心的次数。然后我分成了三部分算。对于一个点 $x$ ，他可能成为重心，当且仅当：</p><h4 id="Case-1-它子树内的某个子树被割了，它成为了重心"><a href="#Case-1-它子树内的某个子树被割了，它成为了重心" class="headerlink" title="Case 1 它子树内的某个子树被割了，它成为了重心"></a>Case 1 它子树内的某个子树被割了，它成为了重心</h4><p>考虑此时这个小子树的子树大小需要满足什么条件。首先由于要分子树讨论，不妨设从 $y_k$ 中割掉了一棵小子树。那么考虑要满足这么几个限制：</p><script type="math/tex; mode=display">\begin{aligned}size_{y_k}-s&\leq \lfloor \frac{n-s}{2}\rfloor\\n-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\g_y&\leq  \lfloor \frac{n-s}{2}\rfloor\end{aligned}</script><p>其中 $g_y$ 为除去子树 $y$ 后剩下的子树最大值。因为根据定义本质上并不关心那些较小的子树。</p><p>于是这部分就可以分子树查。发现本质上转化成了在 $dfs$ 序上求「区间 $[l,r]$ 内值域在 $[a,b]$ 内的数有多少」，可以直接上主席树。然后这部分就做完了。</p><h4 id="Case-2-它子树外的某个子树被割了，它成为了重心"><a href="#Case-2-它子树外的某个子树被割了，它成为了重心" class="headerlink" title="Case 2 它子树外的某个子树被割了，它成为了重心"></a>Case 2 它子树外的某个子树被割了，它成为了重心</h4><p>此时还是不变，但是约束变为了</p><script type="math/tex; mode=display">\begin{aligned}n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\z&\leq \lfloor \frac{n-s}{2}\rfloor\\\end{aligned}</script><p>这部分也是可以直接主席树来求。但是注意解出来的 $[l,r]$ 内可能会包含从 $x$ 到根路径上点(祖先)的子树信息，可以对进退栈顺序开一棵线段树来容斥掉这一部分。</p><h4 id="Case-3-它子树外某个不是子树的连通块被割了，它成为了重心"><a href="#Case-3-它子树外某个不是子树的连通块被割了，它成为了重心" class="headerlink" title="Case 3 它子树外某个不是子树的连通块被割了，它成为了重心"></a>Case 3 它子树外某个不是子树的连通块被割了，它成为了重心</h4><p>考虑此时割掉的一定是 $x$ 到根路径上的一条边。发现本质上依旧是</p><script type="math/tex; mode=display">\begin{aligned}n-s-size_x&\leq \lfloor \frac{n-s}{2}\rfloor\\z&\leq \lfloor \frac{n-s}{2}\rfloor\\\end{aligned}</script><p>于是还是维护一棵退栈顺序的线段树来维护这个。</p><p>然后以上的线段树可以换成树状数组。于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (  ; p &lt;= n ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="keyword">return</span> ask(r) - ask(l - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]), s ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]], k, y, g ;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)&#123;<span class="comment">//Case 2</span></span><br><span class="line">        res[x] += query(_rt[<span class="number">0</span>], _rt[dfn[x] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] += query(_rt[dfn[x] + sz[x] - <span class="number">1</span>], _rt[n], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] -= qry(l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">0</span> ; s = edg[x].size() ; suf[s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; pre[k] = pre[max(<span class="number">0</span>, k - <span class="number">1</span>)] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        pre[k] = max(pre[max(k - <span class="number">1</span>, <span class="number">0</span>)], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = s - <span class="number">1</span> ; ~k ; -- k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; suf[k] = suf[k + <span class="number">1</span>] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        suf[k] = max(suf[k + <span class="number">1</span>], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123; <span class="comment">//Case 1</span></span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        g = max(n - sz[x], suf[k + <span class="number">1</span>]) ;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) g = max(pre[k - <span class="number">1</span>], g) ;</span><br><span class="line">        l = max(<span class="number">1</span>, <span class="number">2</span> * sz[y] - n), r = n - <span class="number">2</span> * g ;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">            res[x] += query(_rt[dfn[y] - <span class="number">1</span>], _rt[dfn[y] + sz[y] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    mdf(sz[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])</span><br><span class="line">        <span class="keyword">if</span> (k != fa) dfs5(k, x) ;</span><br><span class="line">    mdf(sz[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> qwq)</span></span>&#123;<span class="comment">//Case 3</span></span><br><span class="line">    <span class="keyword">int</span> t = sz[x] + qwq ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]] ;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]) ;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">        res[x] += qry(l, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">1</span>) ;</span><br><span class="line">        dfs6(k, x, t - sz[k]) ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("centroid.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"> qr(T) ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">qr(n), ans = tot = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            edg[i].clear(), mson[i] = res[i] = _bit[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">            qr(j), qr(k), edg[j].p_b(k), edg[k].p_b(j) ;</span><br><span class="line">        dfs4(<span class="number">1</span>, Id = <span class="number">0</span>) ; build(_rt[<span class="number">0</span>], <span class="number">1</span>, n) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            upd(_rt[i], _rt[i - <span class="number">1</span>], <span class="number">1</span>, n, sz[rev[i]]) ;</span><br><span class="line">        dfs5(<span class="number">1</span>, <span class="number">0</span>) ; fill(_bit + <span class="number">1</span>, _bit + n + <span class="number">1</span>, <span class="number">0</span>) ; dfs6(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) ans += <span class="number">1l</span>l * res[i] * i ; qw(ans, <span class="string">'\n'</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就做完了。复杂度是 $O(n\log n)$，但就是常数巨大…不知道为什么…感觉应该挺快才对啊（</p><h3 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>草，了解完倍增做法后发现上面的主席树是真的真的无脑。</p><p>大概就是考虑一个<del>我没发现的</del>性质，发现对于每个点 $u$，每次重心要么是 $u$，要么就是 $u$ 的父亲以外，要么就只会是 $u$ 子树内某个点的重儿子。所以就可以倍增预处理处每个点开始 $2^i$ 个重儿子是谁。然后考虑断 $(x,y)$ 这条边之后，$y$ 就可以通过倍增的方式找到深度最大的那个重心，然后判断一下它的父亲即可；$x$ 还需要合并父亲的重心，算点边界之类的，也不是很难。</p><p>最后放一下主席树的代码，用的 <code>ouuan</code> 的 IO。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXP 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(T &amp;x, T y)</span></span>&#123; x = x &gt; y ? y : x ; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span></span>&#123; x = x &lt; y ? y : x ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> max_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> mson[N] ;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5</span>], p[<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">int</span> bg, rt, Id ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, f[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, sz[N], e[N &lt;&lt; <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE (1 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isdigit(x) (x &gt;= <span class="meta-string">'0'</span> &amp;&amp; x &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="keyword">char</span> pbuf[MAXSIZE], *pp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  IO() : p1(buf), p2(buf), pp(pbuf) &#123;&#125;</span><br><span class="line">  ~IO() &#123; fwrite(pbuf, <span class="number">1</span>, pp - pbuf, <span class="built_in">stdout</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="string">' '</span> : *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">' '</span> || ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span> || ch == <span class="string">'\t'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">bool</span> sign = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = gc();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = gc())</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">'-'</span>) sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = gc()) x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'.'</span>)</span><br><span class="line">      <span class="keyword">for</span> (ch = gc(); <span class="built_in">isdigit</span>(ch); ch = gc())</span><br><span class="line">        tmp /= <span class="number">10.0</span>, x += tmp * (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = gc();</span><br><span class="line">    <span class="keyword">for</span> (; blank(ch); ch = gc())</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">for</span> (; !blank(ch); ch = gc()) *s++ = ch;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (c = gc(); blank(c); c = gc())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (pp - pbuf == MAXSIZE) fwrite(pbuf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdout</span>), pp = pbuf;</span><br><span class="line">    *pp++ = c;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">write</span>(<span class="title">T</span> <span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, push(<span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">static</span> T sta[<span class="number">35</span>];</span><br><span class="line">    T top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">while</span> (top) push(sta[--top] + <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">write</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">char</span> <span class="title">lastChar</span>) &#123;</span></span><br><span class="line">    write(x), push(lastChar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> dfs1(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa) chkmax(mx, sz[to(k)]), dfs(to(k), u) ;</span><br><span class="line">chkmax(mx, sz[rt] - sz[u]) ; f[u] = mx ;</span><br><span class="line"><span class="keyword">if</span> (f[q[<span class="number">1</span>]] &gt; f[u]) q[<span class="number">1</span>] = u ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[q[<span class="number">2</span>]] &gt; f[u]) q[<span class="number">2</span>] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; max_dep)</span><br><span class="line">        max_dep = dep[x], rt = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs2(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ; rev[dep[x]] = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) redfs(to(k), x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa) dfs3(to(k), x), ans += to(k) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> sum[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _rt[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _lc[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="keyword">int</span> _rc[N * <span class="number">18</span>] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; edg[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    rev[dfn[x] = ++ Id] = x ;</span><br><span class="line">    dep[x] = dep[fa] + (sz[x] = <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != fa)&#123;</span><br><span class="line">            dfs4(k, x) ; sz[x] += sz[k] ;</span><br><span class="line">            <span class="keyword">if</span> (sz[k] &gt; sz[mson[x]] || !mson[x]) mson[x] = k ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    sum[rt = ++ tot] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(_lc[rt], l, mid) ;</span><br><span class="line">    build(_rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> lst, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    rt = ++ tot ;</span><br><span class="line">    _lc[rt] = _lc[lst] ;</span><br><span class="line">    _rc[rt] = _rc[lst] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(sum[rt] = sum[lst] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">         upd(_lc[rt], _lc[lst], l, mid, p) ;</span><br><span class="line">    <span class="keyword">else</span> upd(_rc[rt], _rc[lst], mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">    sum[rt] = sum[_lc[rt]] + sum[_rc[rt]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[v] - sum[u] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(_lc[u], _lc[v], l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(_rc[u], _rc[v], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> suf[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (  ; p &lt;= n ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ask(r) - ask(l - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int seg[N * 3] ;</span></span><br><span class="line"><span class="comment">void _up(int rt)&#123;</span></span><br><span class="line"><span class="comment">    seg[rt] = seg[rt &lt;&lt; 1] + seg[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void mdf(int rt, int l, int r, int pos, int v)&#123;</span></span><br><span class="line"><span class="comment">    if (l == r)&#123; seg[rt] += v ; return ; &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">    if (pos &lt;= mid) mdf(rt &lt;&lt; 1, l, mid, pos, v) ;</span></span><br><span class="line"><span class="comment">    else mdf(rt &lt;&lt; 1 | 1, mid + 1, r, pos, v) ; _up(rt) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int qry(int rt, int l, int r, int ql, int qr)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, res = 0 ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[rt] ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= mid) res += qry(rt &lt;&lt; 1, l, mid, ql, qr) ;</span></span><br><span class="line"><span class="comment">    if (qr &gt; mid) res += qry(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr) ;</span></span><br><span class="line"><span class="comment">    return res ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs5</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//int g[3] = &#123;0, 0, 0&#125; ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= 5 ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " " ;</span></span><br><span class="line"><span class="comment">    &#125;puts("") ;*/</span></span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]), s ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]], k, y, g ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " \n" ;</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l &amp;&amp; l &gt; <span class="number">0</span> &amp;&amp; r &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; dfn[x] &lt;&lt; " \n" ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; query(_rt[dfn[x] + sz[x] - 1], _rt[n], 1, n, l, r) &lt;&lt; "#\n" ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; query(_rt[0], _rt[dfn[x] - 1], 1, n, l, r) &lt;&lt; "#\n" ;</span></span><br><span class="line">        res[x] += query(_rt[<span class="number">0</span>], _rt[dfn[x] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] += query(_rt[dfn[x] + sz[x] - <span class="number">1</span>], _rt[n], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">        res[x] -= qry(l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; " !!!" &lt;&lt; x &lt;&lt; "!!! " &lt;&lt; res[x] &lt;&lt; '\n' ;</span></span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">0</span> ; s = edg[x].size() ; suf[s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; pre[k] = pre[max(<span class="number">0</span>, k - <span class="number">1</span>)] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        pre[k] = max(pre[max(k - <span class="number">1</span>, <span class="number">0</span>)], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = s - <span class="number">1</span> ; ~k ; -- k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)&#123; suf[k] = suf[k + <span class="number">1</span>] ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        suf[k] = max(suf[k + <span class="number">1</span>], sz[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; s ; ++ k)&#123;</span><br><span class="line">        y = edg[x][k] ;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        g = max(n - sz[x], suf[k + <span class="number">1</span>]) ;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) g = max(pre[k - <span class="number">1</span>], g) ;</span><br><span class="line">        <span class="keyword">int</span> l = max(<span class="number">1</span>, <span class="number">2</span> * sz[y] - n), r = n - <span class="number">2</span> * g ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; g &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">            res[x] += query(_rt[dfn[y] - <span class="number">1</span>], _rt[dfn[y] + sz[y] - <span class="number">1</span>], <span class="number">1</span>, n, l, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (k = 0 ; k &lt; s ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">        y = edg[x][k] ;</span></span><br><span class="line"><span class="comment">        if (y == fa || y != mson[x]) continue ;</span></span><br><span class="line"><span class="comment">        g[2] = suf[k + 1] ; if (k) g[2] = max(pre[k - 1], g[2]) ; break ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    g[0] = sz[mson[x]] ; g[1] = n - sz[x] ;</span></span><br><span class="line"><span class="comment">    sort(g, g + 3) ;</span></span><br><span class="line"><span class="comment">    l = max(1, 2 * g[2] - n) ;</span></span><br><span class="line"><span class="comment">    r = min(n - g[1] * 2, 2 * sz[x] - n) ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; g[2] &lt;&lt; " " &lt;&lt; g[1] &lt;&lt; " " &lt;&lt; g[0] &lt;&lt; " $%$ \n" ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; res[x] &lt;&lt; "*&amp;*\n" ;</span></span><br><span class="line"><span class="comment">    if (l &lt;= r)</span></span><br><span class="line"><span class="comment">        res[x] += query(_rt[dfn[x]], _rt[dfn[x] + sz[x] - 1], 1, n, l, r) ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; res[x] &lt;&lt; '\n' ;*/</span></span><br><span class="line">    mdf(sz[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x]) <span class="keyword">if</span> (k != fa) dfs5(k, x) ;</span><br><span class="line">    mdf(sz[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs6</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; qwq &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">int</span> t = sz[x] + qwq ;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">2</span> * sz[mson[x]] ;</span><br><span class="line">    <span class="keyword">int</span> l = max(<span class="number">1</span>, n - <span class="number">2</span> * sz[x]) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " &amp;\n" ;</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= l)</span><br><span class="line">        res[x] += qry(l, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k : edg[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">1</span>) ;</span><br><span class="line">        dfs6(k, x, t - sz[k]) ;</span><br><span class="line">        mdf(t - sz[k], <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("centroid12.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">// freopen("centroid.out", "w", stdout) ;</span></span><br><span class="line"></span><br><span class="line"> io.read(T) ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">io.read(n), cnt = ans = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                io.read(j), io.read(k),</span><br><span class="line">add(j, k), e[i][<span class="number">0</span>] = j, e[i][<span class="number">1</span>] = k ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) res[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span>,</span><br><span class="line">dfs1(rt = e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">dfs(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]) ;</span><br><span class="line">(f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (res[q[<span class="number">1</span>]]++, res[q[<span class="number">2</span>]] ++) : res[q[<span class="number">1</span>]] ++ ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">f[<span class="number">0</span>] = n + <span class="number">1</span> ;</span><br><span class="line">q[<span class="number">1</span>] = q[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">dfs1(rt = e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">                dfs(e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]) ;</span><br><span class="line">(f[q[<span class="number">2</span>]] == f[q[<span class="number">1</span>]]) ? (res[q[<span class="number">1</span>]]++, res[q[<span class="number">2</span>]] ++) : res[q[<span class="number">1</span>]] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                ans += <span class="number">1l</span>l * res[i] * i ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">49991</span>)&#123;</span><br><span class="line">            max_dep = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">                io.read(j), io.read(k), add(j, k) ;</span><br><span class="line">            dfs2(<span class="number">1</span>, <span class="number">0</span>) ; redfs(rt, dep[<span class="number">0</span>] = <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans += rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i / <span class="number">2</span>] + rev[i / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">if</span> ((n - i) &amp; <span class="number">1</span>) ans += rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> ans += rev[i + (n - i) / <span class="number">2</span>] + rev[i + (n - i) / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">262143</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i) deg[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                io.read(j), io.read(k) ;</span><br><span class="line">                add(j, k), ++ deg[j], ++ deg[k] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (deg[i] == <span class="number">2</span>) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">            dfs3(rt, <span class="number">0</span>) ; ans += <span class="number">1l</span>l * rt * (n / <span class="number">2l</span>l + <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = next(k))</span><br><span class="line">                ans += <span class="number">1l</span>l * to(k) * (n - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Id = <span class="number">0</span> ; tot = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">memset</span>(_rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(_rt)) ;</span><br><span class="line">            <span class="built_in">memset</span>(_bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(_bit)) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                edg[i].clear(), mson[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">                io.read(j), io.read(k) ;</span><br><span class="line">                edg[j].p_b(k), edg[k].p_b(j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs4(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            build(_rt[<span class="number">0</span>], <span class="number">1</span>, n) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                upd(_rt[i], _rt[i - <span class="number">1</span>], <span class="number">1</span>, n, sz[rev[i]]) ;</span><br><span class="line">            dfs5(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="built_in">memset</span>(_bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(_bit)) ;</span><br><span class="line">            dfs6(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                ans += <span class="number">1l</span>l * res[i] * i ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是重做了一下 NOIP2018/CSP2019 两年的全部题目？&lt;/p&gt;
&lt;p&gt;感觉当时场上没 A 掉的题，放到现在做总是感觉有点心理阴影emm&lt;/p&gt;
&lt;p&gt;Anyway, 只用真正告别过去才能走向未来。你说，对吧？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="树上技巧/dfs序+树状数组" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="技巧/分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E6%B2%BB/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="技巧/倍增" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%80%8D%E5%A2%9E/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构/可持久化/可持久化线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="技巧/状态合并" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="NOIP系列" scheme="https://www.orchidany.cn/tags/NOIP%E7%B3%BB%E5%88%97/"/>
    
      <category term="动态规划/链分治维护dp" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%93%BE%E5%88%86%E6%B2%BB%E7%BB%B4%E6%8A%A4dp/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】一般图最大匹配(带花树)</title>
    <link href="https://www.orchidany.cn/2020/05/11/%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/05/11/带花树/</id>
    <published>2020-05-11T00:48:43.000Z</published>
    <updated>2020-05-12T02:43:04.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学了一发带花树，感觉很高妙。</p><p>然后顺便复习了一下二分图匹配and学了一下随机匹配。</p><p>🌼🌲：Blossom Tree.</p><a id="more"></a><h1 id="从匹配到二分图匹配"><a href="#从匹配到二分图匹配" class="headerlink" title="从匹配到二分图匹配"></a>从匹配到二分图匹配</h1><h2 id="从匹配到增广路"><a href="#从匹配到增广路" class="headerlink" title="从匹配到增广路"></a>从匹配到增广路</h2><blockquote><p>给定一张图 $G=\{\mathrm{V,E}\}$ ，一组两两没有交点的边集 $\rm M\subseteq E$ 称之为 $G$ 的一组<strong>匹配</strong>。边数最多的匹配称之为 $G$ 的<strong>最大匹配</strong>。其中 $\forall (u,v)\in \mathrm{M}$ 称之为<strong>匹配边</strong>，否则称为<strong>非匹配边</strong>。</p><p>称一个点在匹配中当且仅当它是某跳匹配边的端点。称匹配中的点为<strong>匹配点</strong>，不在匹配中的点为<strong>未盖点</strong> 。与某个匹配点共匹配边的另一个端点称之为该点的<strong>配偶</strong> 。</p></blockquote><p>嗯，定义朗诵完了…然后大概就是考虑怎么找匹配。大概就是增广路算法。定义<strong>增广路</strong>是这样的一种图上的路径：</p><blockquote><p>1、路径的起点和终点均为未盖点。</p><p>2、路径上匹配边、未匹配边交替出现。</p></blockquote><p>据此可以知道</p><blockquote><p>1、一条增广路必然只会有奇数条边。</p><p>2、增广路上非匹配边比匹配边多 $1$ 。</p><p>3、如果将所有边的状态取反，那么匹配数 $+1$ 。</p></blockquote><p>于是有定理</p><blockquote><p>如果一个匹配 $\mathrm{M}$ 是图 $G$ 的最大匹配，当且仅当 $G’=\rm \{V,E\setminus M\}$ 中不存在增广路。</p></blockquote><p>这…必要性还是比较显然的吧。充分性的话，鸽了鸽了。</p><p>于是考虑如果要求解一张图里的最大匹配，可以通过不断找增广路的方式来进行。</p><h2 id="从增广路到二分图匹配"><a href="#从增广路到二分图匹配" class="headerlink" title="从增广路到二分图匹配"></a>从增广路到二分图匹配</h2><p>二分图最重要的一个特征：没有奇环。</p><p>考虑这样为什么能简化找匹配的过程呢？发现本质上每次找增广路，就是在找一条长度为奇数的路径。那么考虑这样一个做法：</p><blockquote><p>遍历每个当前的未盖点 $u$ ：</p><p>1、如果 $\exists (u,v)$ 使得 $v$ 也是未盖点，那么可以直接让 $v$ 匹配上，匹配数 $+1$ 。</p><p>2、如果对于某个匹配点 $v$ 的配偶 $p$ ，可以找到除了 $v$ 之外的另一个配偶 $q$ ，那么就让 $p$ 和 $q$ 配对、$u$ 和 $v$ 配对。总匹配数 $+1$ 。</p></blockquote><p>看上去十分合理？这样就可以保证每次找到的都会是一条极长的增广路。考虑倒着归纳来证明这个事实【此时考虑的是重匹配(即状态取反)之前】：</p><blockquote><p> 1、如果对于 $u$ 找到了一个未盖点 $v$ ，那么 $(u,v)$ 是增广路。</p><p>2、如果对于某个匹配点 $v$ 的配偶 $p$ ，可以找到除了 $v$ 之外的另一个配偶 $q$ ，那么 $p,q$ 之间的路径一定是增广路，边 $(u,v)$ 之间一定也是增广路。同时又因为边 $(v,p)$ 为匹配边，所以路径 $u-v-p-q$ 一定是一条长度为奇数的增广路。</p></blockquote><p>由此可知，这样找的路一定是增广路。同时本质上这个算法就是在对每一条边进行定向，比如 $(u\to v)$ 就代表着找到了一组 $u,v$ 匹配且可能会让 $v$ 调整匹配。那么于是一般的二分图匹配算法就是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">vis [to(k)] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!used[to(k)] || path(used[to(k)]))&#123;</span><br><span class="line">used[to(k)] = u ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Ew ;</span><br><span class="line"><span class="keyword">while</span>(Ew --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), Ans += (<span class="keyword">int</span>)path(i) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果存在某个节点寻找匹配失败，那么 <code>dfs</code> 过程中访问到所有结点和边会组成一个树形态，称之为<strong>交错树</strong> 。</p><p>但是这样在一般无向图上会存在什么问题吗？考虑一个这样的环</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>一开始从 $x$ 出发找到 $y$ ，$x,y$ 均变为匹配点。之后跳过 $y$ 因为 $y$ 已经被匹配。之后来到 $z$ 。发现对于 $z$ 而言，$z$ 找 $x$ ，$x$ 找配偶 $y$，$y$ 发现自己的临边中 $z$ 还没被匹配，于是就匹配 $z$ 。发现这样最后会使得 $z$ 既匹配了 $x$ 又匹配了 $y$ 。原因是什么？发现原因在于这是一个奇环。奇环是会存在对于一条边的两个临边在黑白染色之后呈同色，这不符合匹配的定义。</p><p>于是…匈牙利就挂在了一般图上。</p><h1 id="从二分图匹配到带花树"><a href="#从二分图匹配到带花树" class="headerlink" title="从二分图匹配到带花树"></a>从二分图匹配到带花树</h1><p>考虑二分图匹配直接移植的问题就在于奇环。那么考虑如何消除奇环的贡献。于是就要引入<strong>带花树</strong>这个算法(英: Blosssom Algorithm)。</p><p>带花树本质是考虑奇环匹配的本质，即如果让奇环自己单独匹配，会发生什么。发现一个长为 $2\cdot k+1$ 的奇环无论何时都可以贡献 $k$ 对匹配，并且余下一个未盖点。于是带花树会考虑，在处理增广路时直接把奇环缩成一个点，称之为<strong>花</strong> 。之后在缩完花的新图上继续找增广路。</p><p>然后证明的话…大概就是考虑如果原图存在增广路，那么新图也必然存在，反之亦然。具体证明咕了咕了。</p><p>…其实带花树难点就只是在实现上。考虑不去显示地缩点，而是用并查集维护每个点在哪一朵花里面。然后考虑用 bfs 的方式对当前点 $u$ 的交错树染色。考虑将点染为 $\alpha$ 类和 $\beta$ 类，那么本质上需要进行如下流程：</p><blockquote><p>-1、初始结点 $u$ 为 $\alpha$ 类。</p><p>0、当前点和当前邻居结点在同一朵花里，直接 <code>continue</code> 。</p><p>1、当前点为 $\alpha$ 类，当前邻居结点为 $\beta$ 类，直接 <code>continue</code> 。</p><p>2、当前点为 $\alpha $ 类，当前邻居结点未被染色：</p><p>考虑如果邻居结点是匹配点，那么将邻居结点的配偶加入队列，同时将邻居结点染为 $\alpha$ 类；如果邻居结点是未盖点，那么直接将从 $u$ 开始的这一段增广路取反之后，匹配数 $+1$，并将邻居结点染为 $\beta$ 类之后跳出。</p><p>3、当前点为 $\alpha$ 类，当前邻居结点也为 $\alpha$ 类：</p><p>考虑这时就找到了一个 $u,v$ 都在的奇环。考虑首先为了缩掉这个奇环，需要找到它们在<strong>交错树上的 lca</strong>。那么于此就需要记录每个点在交错树上的前驱结点(父节点) $fa_x$。 之后考虑，由于这个奇环上的每一个点都可以当做唯一被剩下的那个未盖点去与环外的点匹配，那么就需要将环上所有的 $\beta$ 类点加入队列。同时由于这个环可以自由匹配，所以环上相邻的点应该是彼此的 $fa$ 。于是这个操作就可以看作是在<strong>开花(blossom)</strong>。</p></blockquote><p>然后实现方面…似乎就这么多细节了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Blossom_Tree&#123;</span><br><span class="line">    <span class="keyword">int</span> ans ;</span><br><span class="line">    <span class="keyword">int</span> num ;</span><br><span class="line">    <span class="keyword">int</span> h, t ;</span><br><span class="line">    <span class="keyword">int</span> q[N] ;</span><br><span class="line">    <span class="keyword">int</span> fa[N] ;</span><br><span class="line">    <span class="keyword">int</span> dfn[N] ;</span><br><span class="line">    <span class="keyword">int</span> pre[N] ;</span><br><span class="line">    <span class="keyword">int</span> clr[N] ;</span><br><span class="line">    <span class="keyword">int</span> match[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            fa[i] = i, match[i] = clr[i] = pre[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        ++ num ;</span><br><span class="line">        x = find(x) ;</span><br><span class="line">        y = find(y) ; <span class="keyword">int</span> z ;</span><br><span class="line">        <span class="keyword">while</span> (dfn[x] != num)&#123;</span><br><span class="line">            dfn[x] = num ;</span><br><span class="line">            z = find(pre[match[x]]) ;</span><br><span class="line">            x = z ; <span class="keyword">if</span> (y) swap(x, y) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;<span class="comment">//z=lca(x, y)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; z &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">while</span> (find(x) != z)&#123;</span><br><span class="line">            pre[x] = y ;</span><br><span class="line">            y = match[x] ;</span><br><span class="line">            fa[x] = fa[y] = z ;<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (clr[y] &gt; <span class="number">1</span>)</span><br><span class="line">                clr[y] = <span class="number">1</span>, q[++ t] = y ;</span><br><span class="line">            x = pre[match[x]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        h = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line">        q[++ t] = x ; clr[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            fa[i] = i, clr[i] = pre[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= t)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q[h ++] ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; x &lt;&lt; " " &lt;&lt; h &lt;&lt; " " &lt;&lt; t &lt;&lt; " " &lt;&lt; head[x] &lt;&lt; " &amp;\n" ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">                <span class="keyword">if</span> (clr[to(k)] &gt; <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (find(x) == find(to(k))) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!clr[to(k)])&#123;</span><br><span class="line">                    clr[to(k)] = <span class="number">2</span> ;</span><br><span class="line">                    pre[to(k)] = x ;</span><br><span class="line">                    <span class="keyword">if</span> (!match[to(k)])&#123;</span><br><span class="line">                        <span class="keyword">int</span> z = to(k), y ;</span><br><span class="line">                        <span class="keyword">while</span> (z)&#123;</span><br><span class="line">                           y = match[pre[z]] ;<span class="comment">//1</span></span><br><span class="line">                           match[pre[z]] = z ;</span><br><span class="line">                           match[z] = pre[z] ; z = y ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clr[match[to(k)]] = <span class="number">1</span> ;</span><br><span class="line">                    q[++ t] = match[to(k)] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = lca(x, to(k)) ;</span><br><span class="line">                    blossom(x, to(k), z) ;</span><br><span class="line">                    blossom(to(k), x, z) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            puts("xxxx") ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            x = qr(), y = qr(), add_e(x, y), add_e(y, x) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!match[i]) ans += do_match(i) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; debug(match, <span class="number">1</span>, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Blossom_Tree ;</span><br></pre></td></tr></table></figure><p>考虑因为本质上是在 $u$ 的匹配过程中缩点，抽象出模型来就是在交错树上缩花and开花，于是这个算法被叫做「带花树🌼🌲」。</p><h1 id="从带花树到弃疗"><a href="#从带花树到弃疗" class="headerlink" title="从带花树到弃疗"></a>从带花树到弃疗</h1><p>总结一下。大概带花树的流程其实也不难写，只是正确性不是那么显然。同时注意到每次 bfs 时，一个点最多入队 $O(n)$ 次，这一点可以通过最多有 $O(n)$ 个不同的点让当前点加入花/加入队列来理解。于是复杂度总复杂度就是 $O(n^3)$ ，但事实上根本跑不满。</p><p>一般而言可以拿 $O(nm)$ 当作理论下界。关于这个理论下界有两点：</p><blockquote><p>1、实现下界比理论下界还要低不少。</p><p>2、理论上这个下界应该是比较松的，因为会存在某些点进队出队许多次，所以不能单纯地用单次 bfs 复杂度来分析。</p></blockquote><p>总之…还是 $O(\texttt{能过})$ 比较到位吧。</p><p>好玄学啊好玄学啊。</p><h1 id="从弃疗到相信随机化"><a href="#从弃疗到相信随机化" class="headerlink" title="从弃疗到相信随机化"></a>从弃疗到相信随机化</h1><p>本来想着在洛谷随便写一发，$90$ 就 $90$ <del>咱也不带怂的</del> 。</p><p>然后就…过掉了…</p><p>顺便也过掉了 uoj 的 $52$ 组数据和 $43+$ 组的 <code>Extra Task</code> 。</p><p>大概就是考虑随机匹配。随机匹配的思想就是，不找环，只找长度为奇数的增广路。这样做相当于强制断环为链，正确性难以保证。但是考虑如果多做几次，错误率就会大大下降。于是考虑多做几次这样的匹配。注意到这样做很容易被卡掉，只需要多几个奇环顺便构造一下加边顺序就可以了。所以就可以每次走的时候将边表随一下即可。</p><p>然后…用 <code>rand()</code> 很容易被卡掉，因为值域很小，而边数比 $32768$ 大得多。所以用 <code>mt19937</code> 就可以了。</p><p>值得一提的是，以下代码为了保证正确，卡了时，大概是卡了 $0.85s$ 左右。但是十分有趣的是…洛谷的数据在 $0.0005s=0.5ms$ 的卡时范围之内都能过掉…这…咱也不知道该说什么好。</p><p>upd: 随机匹配似乎是无敌了。在 <code>uoj</code> 试了一发卡时 $0.005s=5ms$ 的情况，依旧无压力过掉了所有 $hack$ 数据。</p><p>这个故事告诉我们：题是众生一般题，水是天下一样水。<del>随机匹配 txdy!!!!</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> match[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> st ;</span><br><span class="line"></span><br><span class="line">mt19937 g_f ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">now_time</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(clock() - st) / CLOCKS_PER_SEC ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_match</span><span class="params">(<span class="keyword">int</span> x, mt19937 g_f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    shuffle(E[x].begin(), E[x].end(), g_f) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])</span><br><span class="line">        <span class="keyword">if</span> (!match[y])</span><br><span class="line">            <span class="keyword">return</span> vis[y] = <span class="number">1</span>, match[y] = x, match[x] = y, <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : E[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> z = match[y] ;</span><br><span class="line">        <span class="keyword">if</span> (vis[z]) <span class="keyword">continue</span> ;</span><br><span class="line">        match[x] = y, match[y] = x, match[z] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (do_match(z, g_f)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        match[y] = z, match[z] = y, match[x] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    random_device seed ;</span><br><span class="line">    <span class="function">mt19937 <span class="title">g_f</span><span class="params">(seed())</span> </span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> x, y, z ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        x = qr(), y = qr(), add_e(x, y) ; st = clock() ;</span><br><span class="line">    <span class="keyword">while</span> (now_time() &lt; <span class="number">0.85</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!match[i])</span><br><span class="line">                fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>), ans += do_match(i, g_f), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> debug(match, <span class="number">1</span>, n), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现…uoj卡时卡到 $0.8ms$ 也是能过的。这大概就是看脸了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了一发带花树，感觉很高妙。&lt;/p&gt;
&lt;p&gt;然后顺便复习了一下二分图匹配and学了一下随机匹配。&lt;/p&gt;
&lt;p&gt;🌼🌲：Blossom Tree.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="带花树" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    
    
      <category term="思维题/随机化" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="图论/匹配/带花树" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D-%E5%B8%A6%E8%8A%B1%E6%A0%91/"/>
    
      <category term="图论/匹配" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【复习】概率期望做题笔记</title>
    <link href="https://www.orchidany.cn/2020/05/06/%E6%9C%9F%E6%9C%9B/"/>
    <id>https://www.orchidany.cn/2020/05/06/期望/</id>
    <published>2020-05-06T09:26:20.000Z</published>
    <updated>2020-05-09T07:24:42.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>胡做八做了一点简单的期望题，算是练练手感吧。</p><p>一共是 $15$ 道题。</p><a id="more"></a><h1 id="不太需要技巧的例题"><a href="#不太需要技巧的例题" class="headerlink" title="不太需要技巧的例题"></a>不太需要技巧的例题</h1><h2 id="Luogu3802-小魔女帕琪"><a href="#Luogu3802-小魔女帕琪" class="headerlink" title="Luogu3802 小魔女帕琪"></a><a href="https://www.luogu.org/problem/P3802" target="_blank" rel="noopener">Luogu3802 小魔女帕琪</a></h2><p>这东西我硬推推出来一个：</p><script type="math/tex; mode=display">\dfrac{\left(\begin{array}{c}{\mathrm{S}-6} \\ {1}\end{array}\right) \cdot 7 ! \cdot \prod_{\mathrm{i}=1}^{7} \mathrm{a}_{\mathrm{i}} \cdot(\mathrm{S}-7) !}{\mathrm{S} !}</script><p>的东西。感觉还可以？然后其实就是一种思想？此时总方案数$\rm S$这东西不应该除以某些奇怪的阶乘，或者说，不需要，因为样本空间可以理解为先发生了$A$和发生了$B$虽然局面一样但是概率独立（大概</p><h2 id="Luogu5489-LnOI2019-脸滚键盘"><a href="#Luogu5489-LnOI2019-脸滚键盘" class="headerlink" title="Luogu5489 [LnOI2019]脸滚键盘"></a><a href="https://www.luogu.org/problem/P5498" target="_blank" rel="noopener">Luogu5489 [LnOI2019]脸滚键盘</a></h2><p>这题写过题解，现在复习一遍。大概就是考虑维护一个前缀和，构造数列</p><script type="math/tex; mode=display">\rm F_i=F_{i-1}\cdot base_i+base_i</script><p>然后我们发现它的级数很美妙：</p><script type="math/tex; mode=display">{\sum_{i=1}^{n}F_i=base_1+base_2\cdots+base_n+base_1base_2+base_2base_3\cdots+\prod_{i=1}^{n}base_i}</script><p>正好就是我们要求的答案。</p><p>但此时直接前缀和会有问题，因为多余的实际上是$a_0\cdots a_n$那一堆项，所以需要像哈希一样左半边乘上</p><script type="math/tex; mode=display">\prod_{i=1}^{r}base_i+\prod_{i=1}^{r-1}base_i+\cdots +\prod_{i=1}^{l}base_i</script><h2 id="Luogu1297-国家集训队-单选错位"><a href="#Luogu1297-国家集训队-单选错位" class="headerlink" title="Luogu1297 [国家集训队]单选错位"></a><a href="https://www.luogu.org/problem/P1297" target="_blank" rel="noopener">Luogu1297 [国家集训队]单选错位</a></h2><p>然后其实，$\rm E_S=\mathbb{E}(1)+\mathbb{E}(2)+\mathbb{E}(3)\cdots$ </p><p>观察 $ \mathbb{E}(i)$，实际上只与 $ base_i,base_{i+1}$ 有关，那么每一项的贡献就是 $\dfrac{1}{\max(base_i,base_{i+1})}$。加起来即可。</p><h2 id="Luogu3924-康娜的线段树"><a href="#Luogu3924-康娜的线段树" class="headerlink" title="Luogu3924 康娜的线段树"></a><a href="https://www.luogu.org/problem/P3924#submit" target="_blank" rel="noopener">Luogu3924 康娜的线段树</a></h2><blockquote><p>每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？</p><p>此处的区间加是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (o&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (o&lt;&lt;1|1)</span></span><br><span class="line"> <span class="keyword">int</span> sumv[N&lt;&lt;<span class="number">2</span>],minv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> pushu\Pr(<span class="keyword">int</span> o)&#123;sumv[o]=sumv[lson]+sumv[rson];&#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     build(lson,l,mid);build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> q,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]+=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(q&lt;=mid)change(lson,l,mid,q,v);</span><br><span class="line">     <span class="keyword">else</span> change(rson,mid+<span class="number">1</span>,r,q,v);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;T; </span><br><span class="line"><span class="comment">//区间加</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)T.change(<span class="number">1</span>,<span class="number">1</span>,n,i,addv);</span><br></pre></td></tr></table></figure><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>根据线性性显然可以知道维护的就是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i}{2^{depth_i}}</script><p>其中根节点的 $depth$ 默认为 $0$ 。考虑先把这个式子通分一下：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i\cdot 2^{maxL-depth_i}}{2^{maxL}}=\dfrac{1}{2^{maxL}}\sum_{i=1}^{n}val_i\cdot 2^{maxL-depth_i}</script><p>然后考虑，如果是区间修改，那么本质上只需要求出区间内所有点的线段树上子树内系数 $2^{maxL-depth_i}$ 的和。这一部分可以直接预处理得到。并且考虑只有区间加的操作，所以并不需要真正动态地去维护。直接维护一个全局 $ans$ 即可。</p><p>于是最后复杂度线性。</p><h1 id="考察期望线性性的题目"><a href="#考察期望线性性的题目" class="headerlink" title="考察期望线性性的题目"></a>考察期望线性性的题目</h1><h2 id="ZROI-1142-石子"><a href="#ZROI-1142-石子" class="headerlink" title="[ZROI 1142]石子"></a>[ZROI 1142]石子</h2><blockquote><p>小 D 正在玩取石子游戏。 小 D 共有 $n$ 堆石子，依次编号为 $1, 2, · · · , n$，其中第 $i$ 堆有 $a_i$ 颗石子。 小 D 每次会等概率随机选择一颗石子，并取完它所在的那一堆石子。 小 D 想要知道，第 $1$ 堆石子被取走的时间的期望。</p><p>$n=10^6$。</p></blockquote><p>根据期望的线性性，可以知道可以分别算每堆石子在第 $1$ 堆之前被取完的概率。所以就是</p><script type="math/tex; mode=display">\mathbb{E}(t)=P_{2}+P_{3}+\cdots+P_{n}+1</script><p>于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ; ans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (<span class="keyword">double</span>)base[i] / (<span class="keyword">double</span>)(base[i] + base[<span class="number">1</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BZOJ3036-绿豆蛙的归宿"><a href="#BZOJ3036-绿豆蛙的归宿" class="headerlink" title="[BZOJ3036]绿豆蛙的归宿"></a>[BZOJ3036]绿豆蛙的归宿</h2><blockquote><p>给出 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。</p><p>绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\dfrac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？</p></blockquote><p>发现路径可以拆分，于是根据期望的线性性有</p><script type="math/tex; mode=display">\mathbb{E}(L)=\sum_{e=(u,v)}\mathbb{E}(e) = \sum_{e=(u,v)}\Pr(e)\cdot val(e)</script><p>于是 <code>dfs</code> 一遍即可。</p><h2 id="CF280C-Game-On-Tree"><a href="#CF280C-Game-On-Tree" class="headerlink" title="CF280C Game On Tree"></a>CF280C Game On Tree</h2><blockquote><p>给出一棵树，每次随机等概率选择一未染黑的点，将它及其子树染黑。问期望多少次操作可以将树全部染黑。</p><p>$1\leq n\leq 10^5$ .</p></blockquote><p>草，我居然能把这题给秒掉，太可怕了。</p><p>考虑首先是期望的线性嘛，于是可以知道 $\mathbb{E}(T)$ 表示把树 $T$ 全部染黑的期望次数，那么可以知道有</p><script type="math/tex; mode=display">\mathbb{E}(T)=\sum_{u\in T} \mathbb{E}(u)</script><p>其中 $u$ 是那么考虑如果想要染黑一棵以 $u$ 为根的子树，可以采用的策略是把它到根的路径上任意一点染黑，但是只有在染黑他自己的时候才会对答案产生贡献。所以不难知道</p><script type="math/tex; mode=display">\mathbb{E}(u)=\dfrac{1}{depth_u}</script><h1 id="考察转移递推思想的期望题目"><a href="#考察转移递推思想的期望题目" class="headerlink" title="考察转移递推思想的期望题目"></a>考察转移递推思想的期望题目</h1><h2 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="[NOI2005]聪聪与可可"></a>[NOI2005]聪聪与可可</h2><blockquote><p>给定一张 $n,m$ 的无向图。两个人一开始分别在点 $A,B$。每次 $A$ 先走，$B$ 后走，$A$ 每次会选择一个离 $B$ 最近且编号最小的点走 $1\sim2$ 步，$B$ 随机游走(也可停在原地，概率平摊)，求期望多少步 $A$ 可以与 $B$  相遇。</p><p>$1 \leq N, E \leq 1000$。</p></blockquote><p>emmm 要是化归子问题的话，一开始觉得应该算出在每个点相遇的期望步数，但想了想觉得这个并不可做…</p><p>于是考虑更暴力一点化归子问题： $f_{u,v}$ 表示 $A$ 在 $u$，$B$ 在 $v$ 时两者相遇的期望步数。那么考虑转移：</p><p>1、$u=v$ ，$f_{u,v}=0$ 。</p><p>2、$dis(u,v)=1$，$f_{u,v}=1$ （因为 $A$ 先走）。</p><p>3、$dis(u,v)&gt;1$，$f_{u,v}=\dfrac{\sum{f_{u’,v’}}}{\deg(v)+1}$ ，其中 $u’$ 是 $u$ 走两步可以到达的离 $v$ 最近的一个点，$v$ 是随便一个点。</p><p>然后就可以记搜了。我其实很迷惑为什么全员最短路的题要出 $1e3$ …除了强行丰富代码难度，有什么意义吗…</p><p>注意实现的一点小细节。如果 $x$ 走两步就可以走到 $y$，此时应该直接 <code>return 1.0</code> ，因为 $B$ 根本没有走的机会。</p><h2 id="LuoguP1365-OSU-Easy-Version"><a href="#LuoguP1365-OSU-Easy-Version" class="headerlink" title="[LuoguP1365]OSU!(Easy Version)"></a>[LuoguP1365]OSU!(Easy Version)</h2><blockquote><p>给定一个序列，某些位置是 $0$，某些位置是 $1$ ，某些位置分别有 $50\%$ 的概率变成 $0$ 或者 $1$ 。求极大连续纯 $1$ 段的长度的平方之和的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>考虑分别记 $f_i,g_i$ 表示总期望/当前段的期望。那么可以分类讨论 $i$ 的类型：</p><p>1、$a_i=1,g_i=g_{i-1}+1,f_{i}=f_{i-1}+2\cdot g_{i-1}+1$ 。</p><p>2、$a_i=0,g_i=0,f_{i}=f_{i-1}$ 。</p><p>3、$a_i=?,g_{i}=g_{i-1}+0.5,f_{i}=f_{i-1}+g_{i-1}+0.5$ 。</p><p>还是比较简单的。注意一个点即可，根据期望的线性性，如果按照「前 $i$ 个」作为划分阶段的依据，需要把一个极长连续 $1$ 段的贡献摊到每个元素上面，摊的方法就是平方和公式。</p><h2 id="BZOJ4318-OSU-Hard-Version"><a href="#BZOJ4318-OSU-Hard-Version" class="headerlink" title="[BZOJ4318]OSU!(Hard Version)"></a>[BZOJ4318]OSU!(Hard Version)</h2><blockquote><p>我们可以把osu的规则简化与改编成以下的样子:</p><p>一共有 $n$ 次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，$n$ 次操作对应为长度为 $n$ 的<code>01</code> 串。在这个串中连续的 $X$ 个 1 可以贡献 $X^3$ 的分数，这 $X$ 个 $1$ 不能被其他连续的 $1$ 所包含（也就是极长的一串1）</p><p>现在给出 $n$，以及每个操作的成功率，请你输出期望分数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>跟上一题十分接近的思路。但是考虑立方和公式 $(x+1)^3=x^3+3x^2+3x+1$ ，由于 $\mathbb{E}^2(x)\neq \mathbb{E}(x^2)$，所以不能直接拿线性性拆。于是考虑分别维护极长段的平方和和长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">g[i] = (g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i], </span><br><span class="line">p[i] = (p[i - <span class="number">1</span>] + <span class="number">2</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i],</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + base[i] *  (<span class="number">3</span> * p[i - <span class="number">1</span>] + <span class="number">3</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Luogu4550-收集邮票"><a href="#Luogu4550-收集邮票" class="headerlink" title="[Luogu4550]收集邮票"></a>[Luogu4550]收集邮票</h2><blockquote><p>有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $\dfrac{1}{n}$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 张邮票需要支付 $k$ 元钱。</p><p>现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>首先考虑一个简化版问题：</p><blockquote><p>每次随机一个$[1,n]$的整数，问期望几次能凑出所有数 </p></blockquote><p>考虑期望的线性性，就是 $\mathbb{E}=\sum \mathbb{E}(i)$，其中 $\mathbb{E}$ 为所求，$\mathbb{E}(i)$ 为在已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望次数。根据之前整理过的内容，“发生概率为 $p$ 的事件，在期望 $\dfrac{1}{p}$ 次之后会发生”，我们可以得到如下：</p><script type="math/tex; mode=display">\begin{aligned}\Pr(i)& =\dfrac{n-(i-1)}{n} \\\mathbb{E}(i)& =\dfrac{1}{\Pr(i)}=\dfrac{n}{n-i+1}\end{aligned}</script><p>然后把他们加起来就是</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum\dfrac{n}{n-i+1}=\sum\dfrac{n}{i}</script><p>思路是自然的。然后考虑本题，需要给每次操作附加一个权值。所以本质上我们可以分开计算，$g_i$表示已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望步数，$ f_i$表示期望步数的<code>cost</code>。</p><p>考虑如何计算 $f_i$。假设之前拿数进行了 $p$ 次操作，这一次拿 $i$ 需要 $q$ 次操作，那么这 $q$ 次操作的 $\rm \sum cost$ 就是</p><script type="math/tex; mode=display">p\cdot q+q^2=(p+q)\cdot q</script><p>这个原理需要编一下。考虑前一半是之前拿数次数与当前拿数次数的乘积，可以知道此时的代价至少是这些；后一半在不考虑前面拿数的贡献后，可以考虑期望的意义，$q$ 既是期望次数，也是平均代价，所以可以知道当前的代价应该是 $q^2$ 。</p><p>然后就递推一下即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">n = <span class="number">1.0</span> * N / (N - i + <span class="number">1</span>), </span><br><span class="line">g[i] = g[i - <span class="number">1</span>] + n, f[i] = f[i - <span class="number">1</span>] + g[i] * n ;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>, f[N])  ;</span><br></pre></td></tr></table></figure><h2 id="SHOI2014-概率充电器"><a href="#SHOI2014-概率充电器" class="headerlink" title="*[SHOI2014]概率充电器"></a>*[SHOI2014]概率充电器</h2><blockquote><p>SHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定(每条边有一个通电概率)，每一个充电元件自身是否直接进行充电也由概率决定(每个点也有一个通电概率)。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。</p><p>你突然想知道，进入充电状态的元件个数的期望是多少呢？</p><p>$1\leq n\leq 5\cdot 10^5$。</p></blockquote><p>比较有难度的题目。</p><p>根据期望的线性性，可以知道这题只需要求出每个点被点亮的概率即可。考虑设 $f_u$ 表示 $u$ 的子树对 $u$ 的贡献，$g_u$ 表示 $u$ 真正的贡献。不难知道 $f_u\leq g_u$ 。</p><p>那么考虑分别求这两部分。首先常规树形 $dp$ 求出 $f_{root}=g_{root}$  来，转移大概是考虑依次把子树合并进来：</p><script type="math/tex; mode=display">f_{u}=(1-f_u)\cdot f_v\cdot e[u,v]</script><p>然后考虑如何将贡献 $down$ 下去。那么考虑设 $h_u$ 表示只考虑祖先的贡献时，$u$ 亮的概率。不难知道 $g_u=f_u+h_u$ 。那么考虑 $h$ 怎么求。发现一般这种 down 形态的 dp 都要减去当前子树的贡献。所以对于 $h_v$ 而言，有如下转移：</p><script type="math/tex; mode=display">h_v=\dfrac{(g_u-f_v\cdot e[u,v])\cdot (1-f_v)\cdot e[u,v]}{1-f_v\cdot e[u,v]}</script><p>考虑分子上是父亲传到儿子的概率，$h_v$ 是从父亲处导电的概率，那么可以知道如果想要父亲传到儿子，必须要使之互斥，即需要让 $h_v\times \Pr(\texttt{不通过儿子传到父亲})=\Pr(\texttt{父亲传到儿子})$ ，这是分母的来由。</p><p>考虑如果本身不能「不通过儿子传给父亲」，那么父亲的就不能传给儿子，此时 $h_v=0$，需要特判。</p><p>好绕啊好绕啊… </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = base[u] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; </span><br><span class="line">dfs0(to(k), u), f[u][<span class="number">0</span>] += (<span class="number">1</span> - f[u][<span class="number">0</span>]) * val(k) * f[to(k)][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">double</span> p = f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">1</span> - p) &lt;= eps) &#123;dfs1(to(k), u) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line"><span class="keyword">double</span> q = f[u][<span class="number">0</span>] + f[u][<span class="number">1</span>] - f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line">f[to(k)][<span class="number">1</span>] = (<span class="number">1</span> - f[to(k)][<span class="number">0</span>]) * q / (<span class="number">1</span> - p) * val(k) ; </span><br><span class="line">dfs1(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">double</span> o ; <span class="keyword">int</span> i, u, v, w ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), o = w * <span class="number">0.01</span>, add(u, v, o) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w), base[i] = w * <span class="number">0.01</span> ;</span><br><span class="line">dfs0(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (f[i][<span class="number">0</span>] + f[i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转移时有后效性的题目"><a href="#转移时有后效性的题目" class="headerlink" title="转移时有后效性的题目"></a>转移时有后效性的题目</h1><h2 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="[HNOI2013]游走"></a>[HNOI2013]游走</h2><blockquote><p>一个无向连通图，顶点从 $1$ 编号到 $n$ ，边从 $1$ 编号到 $m$。</p><p>小Z在该图上进行随机游走，初始时小Z在 $1$ 号顶点，每一步小Z以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。</p><p>现在，请你对这 $m$ 条边进行编号，使得小Z获得的总分的期望值最小。</p><p>$n\leq 500,1\leq m\leq 1.2\times 10^5$ 。</p></blockquote><p>首先可以贪心地知道期望走过次数越多的边，自然希望他编号越小。</p><p>考虑由点推边。即设 $f_i$ 表示 $i$ 这个点经过的次数。那么可以知道有</p><script type="math/tex; mode=display">f_{i}=[i=1]+\sum_{(i,j)\in\mathbb E} f_j\times \dfrac{1}{\deg_j}</script><p>于是可以高斯消元求出每个 $f_i$ 。之后考虑一条边 $(u,v)$ 的期望经过次数就是</p><script type="math/tex; mode=display">\dfrac{f_u}{\deg_u}+\dfrac{f_v}{\deg_v}</script><p>注意以上所有的操作都不包括 $n$ 号点，因为到 $n$ 号点就不会再走了。</p><h2 id="CF24D-Broken-Robot"><a href="#CF24D-Broken-Robot" class="headerlink" title="CF24D Broken Robot"></a>CF24D Broken Robot</h2><blockquote><p>$n$ 行 $m$ 列的矩阵，一开始在点 $(x,y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。</p><p>注意，$(1,1)$ 是木板的左上角，$(n,m)$ 是木板的右下角。</p></blockquote><p>首先是倒推的思想，从 $(x,y)$ 走到最后一行状态的过程不好描述，可以转化为从最后一行走到 $(x,y)$ 。</p><p>考虑转移</p><script type="math/tex; mode=display">f_{i,j}=\begin{cases}\frac{1}{3}(f_{i+1,j}+f_{i,j+1}+f_{i,j})&\left(j=1\right)\\\frac{1}{3}(f_{i+1,j}+f_{i,j-1}+f_{i,j})&\left(j=m\right)\\\frac{1}{4}(f_{i+1,j}+f_{i,j-1}+f_{i,j+1}+f_{i,j})&\mathrm{Otherwise}\end{cases}</script><p>发现具有后效性，于是考虑消元。个人认为至少有如下几档部分分：</p><h3 id="40-pts-max-n-m-leq-25"><a href="#40-pts-max-n-m-leq-25" class="headerlink" title="40 pts $\max\{n,m\}\leq 25$"></a>40 pts $\max\{n,m\}\leq 25$</h3><p>这个就可以把 $n \times m$ 个元素放在一起消元，复杂度是 $(n^3\cdot m^3)$ 的。</p><h3 id="70-pts-max-n-m-leq-100"><a href="#70-pts-max-n-m-leq-100" class="headerlink" title="70 pts $\max\{n,m\}\leq 100$"></a>70 pts $\max\{n,m\}\leq 100$</h3><p>发现每一行和其他行之间的关系只有 $f_{i+1,j}$ ，那么不难想到倒序枚举每一行，对这一行内的元素进行消元，此时 $f_{i+1}$ 的所有元素均已知。复杂度是 $O(n\cdot m^3)$ 的。</p><h3 id="85-pts-max-n-m-leq-500"><a href="#85-pts-max-n-m-leq-500" class="headerlink" title="85 pts $\max\{n,m\}\leq 500$"></a>85 pts $\max\{n,m\}\leq 500$</h3><p>发现对于要消元的矩阵，对于每一行只有 $i,i-1,i+1,n+1$ 四个列的位置是有元素的，所以每次对于一行而言，可以只进行 $O(1)$ 次消元。这样就是 $O(n\cdot m^2)$ 的了。 </p><h3 id="100-pts-max-n-m-leq-3000"><a href="#100-pts-max-n-m-leq-3000" class="headerlink" title="100 pts $\max\{n,m\}\leq 3000$"></a>100 pts $\max\{n,m\}\leq 3000$</h3><p>发现不止横向有性质，纵向同样有性质。发现对于每一列，至多会有 $3$ 个元素。这样纵向也是 $O(1)$ 的了。于是总复杂度 $O(n\cdot m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i][i + <span class="number">1</span>] /= f[i][i] ;</span><br><span class="line">        f[i][n + <span class="number">1</span>] /= f[i][i] ; f[i][i] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][i + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][n + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][n + <span class="number">1</span>] ;</span><br><span class="line">        f[i + <span class="number">1</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[n] = f[n][n + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans[i] = f[i][n + <span class="number">1</span>], ans[i] -= ans[i + <span class="number">1</span>] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= x ; -- i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span> &amp;&amp; j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">2.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">1.0</span> / <span class="number">2.0</span> ; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[j][j] = <span class="number">3.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gauss(m) ; <span class="comment">//debug(ans, 1, m) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            f[j][j] = f[j][j - <span class="number">1</span>] = f[j][j + <span class="number">1</span>] = f[j][m + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, ans[y]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="[HNOI2011]XOR和路径"></a>[HNOI2011]XOR和路径</h2><blockquote><p>给定一个无向连通图，其节点编号为 $1$ 到 $N$，其边的权值为非负整数。试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得该路径上经过的边的权值的 “XOR和”最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算“XOR 和”时也要被重复计算相应多的次数。</p><p>直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 $1$ 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 $N$ 号节点为止，便得到一条从 $1$ 号节点到 $N$ 号节点的路径。显然得到每条这样的路径的概率是不同的并且每条这样的路径的“XOR 和”也不一样。现在请你求出该算法得到的路径的“XOR 和”的期望值。</p><p>$2≤N≤100,1\leq M≤10000$ 。</p></blockquote><p><del>那必然是要先猜一波期望对xor运算也具有线性性，但实际上并没有。</del></p><p>感觉可能是需要记住的一个 $trick$ ，位运算时位与位之间是独立的，所以可以分别对每一位计算。那么对每一位计算就可以直接按 $0/1$ 分类讨论来转移。</p><p>具体的，还是考虑倒推。个人感觉这是因为最初的决策可能延伸出许多不同的决策，导致很难对这个过程进行统计。但是如果倒推的话，就相当于从一个已知结果出发走向另一端的已知开始。所以会相对容易一点？</p><p>于是考虑设状态 $f_x$ 表示当前二进制位下， 从 $x$ 走到 $n$ 这一位的期望，也就可以等价于这一位为 $1$ 的概率。于是有转移</p><script type="math/tex; mode=display">f_{u}=\frac{1}{\deg_u}\left(\sum_{(u,v,w)\in \mathbf{E},w=0} f_v+\sum_{(u,v,w)\in \mathbf{E},w=1}(1-f_v)\right)</script><p>然后就可以消元了，复杂度 $O(n^3\log V)$ 。注意自环只统计一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxv ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"></span><br><span class="line">db res ;</span><br><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        w = qr() ; chkmax(maxv, w) ;</span><br><span class="line">        add_e(u, v, w) ; <span class="keyword">if</span> (u != v) add_e(v, u, w) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(deg, 1, n) ; cout &lt;&lt; cnt &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span> ; v &lt;= maxv ; v &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = <span class="number">0.0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">            f[i][i] = deg[i] ; <span class="keyword">int</span> xs = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[i] ; k ; k = next(k))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(val(k) &amp; v)) f[i][to(k)] -= <span class="number">1.0</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][to(k)] += <span class="number">1.0</span>, xs += <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][n + <span class="number">1</span>] = <span class="number">1.0</span> * xs ;</span><br><span class="line">        &#125;</span><br><span class="line">        f[n][n] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= n + 1 ; ++ i)</span></span><br><span class="line"><span class="comment">            for (int j = 1 ; j &lt;= n + 1 ; ++ j)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n + 1] ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        gauss(n) ; res += ans[<span class="number">1</span>] * v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡做八做了一点简单的期望题，算是练练手感吧。&lt;/p&gt;
&lt;p&gt;一共是 $15$ 道题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学/高斯消元" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="技巧/按位操作" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【探究向】用命分析概率型生成函数(PGF)</title>
    <link href="https://www.orchidany.cn/2020/05/03/%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://www.orchidany.cn/2020/05/03/概率生成函数入门/</id>
    <published>2020-05-03T10:48:19.000Z</published>
    <updated>2020-05-31T10:56:25.511Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是最近的研究成果吧？</p><p>「学不会的生成函数」+「学不会的概率论」= <code>?</code></p><p>算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。</p><a id="more"></a><h1 id="概率型生成函数"><a href="#概率型生成函数" class="headerlink" title="概率型生成函数"></a>概率型生成函数</h1><p>虽然概率型生成函数本质上就是普通型生成函数，只不过多了一个对应关系。</p><p>即，如果对于某个离散型随机变量 $X\in\mathbb Z$ ，存在数列 $\{a_n\}$ 满足 $\Pr(X=i)=a_i$ ，那么离散型随机变量 $X$ 的 <strong>概率型生成函数$(\mathbf{PGF})$</strong> 为</p><script type="math/tex; mode=display">\mathscr{F}(z)=\sum_{i=0}^{\infty} \Pr(X=i) z^i</script><p>那么首先有</p><script type="math/tex; mode=display">\mathscr{F}(1)=\sum_{i=0}^{\infty}[z^i]\mathscr{F}(z)=1</script><p>同时根据期望的定义</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}i\Pr(X=i)</script><p>可以知道期望就是 $\mathscr{F}$ 的一阶导数系数和，即</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}[z^i]\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)</script><p>那么同时根据方差的定义以及期望的线性性可以得到：</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E\left((X-E(X))^{2}\right)=E\left(X^{2}-2\cdot X \cdot E(X)+E(X)^{2}\right)=E\left(X^{2}\right)-E(X)^{2}</script><p>从而有 </p><script type="math/tex; mode=display">\mathsf{Var}(X)=\sum_{i=0}^{\infty}[z^i]\left(\dfrac{\mathrm{d^2}}{\mathrm{d} z^2}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)-\left(\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)\right)^2\right)</script><p>是因为</p><script type="math/tex; mode=display">E(X^2)=\sum_{i=0}^{\infty}i^2\cdot \Pr(X=i)=\sum_{i=0}^{\infty}i\cdot (i-1)\cdot \Pr(X=i)+\sum_{i=0}^{\infty}i\cdot \Pr(X=i)</script><p>可以知道前面一项是二阶导，后面一项是一阶导。</p><p>然后…然后就可以做题了(倒)。</p><h1 id="2013-Multi-University-Training-Contest-5-Dice"><a href="#2013-Multi-University-Training-Contest-5-Dice" class="headerlink" title="[2013 Multi-University Training Contest 5] Dice"></a>[2013 Multi-University Training Contest 5] Dice</h1><blockquote><p>一个 $m$ 面的公平骰子，求:</p><p>1、最后 $n$ 次结果相同就结束的期望次数。</p><p>2、求最后 $n$ 次结果全不同就结束的期望次数。</p><p>保证 $n,m \leq 10^6$，且对第二问 $n \leq m$ 。</p></blockquote><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>即用 dp 来做。</p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>设 $f_i$ 表示最后 $i$ 次相同，期望还要多少次结束。那么 $f_n=0$ ，求的就是 $f_0$ 。那么可以知道有转移</p><script type="math/tex; mode=display">f_{i}=\dfrac{1}{m}f_{i+1}+\frac{m-1}{m}f_1+1</script><p>发现并不好直接做，考虑差分得到</p><script type="math/tex; mode=display">f_{i}-f_{i+1}=(m-1)f_i-(m-1)f_{1}-m=m(\frac{m-1}{m}f_i-\frac{m-1}{m}f_1-1)=m(f_{i-1}-f_i)</script><p>并且由 $f_0=f_1+1$ 可以知道 $f_n-f_{n+1}=m^n$，于是最后答案就是 $1+\sum_{i=1}^{n-1}m^i$ 。</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p>设 $g_i$ 表示最后 $i$ 次均不相同，期望还要多少次结束。那么 $g_n=0$，求 $g_0$ 。考虑</p><script type="math/tex; mode=display">g_i=\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^i g_j}+1</script><p>(注意加粗的部分，自己一开始因为不细心推挂了…)</p><p>那么还是差分</p><script type="math/tex; mode=display">\begin{aligned}g_{i-1}-g_i&=-\frac{i-1}{m}g_i+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^{i-1} g_j}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}g_i-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}\left(\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^i g_j+1\right)-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)+(m-i)}{m^2}g_{i+1}+\left(\frac{m-i+1-1}{m^2}\right)\cdot\sum _{j=1}^ig_j+\frac{m-(i-1)-1}{m}\\&=-\frac{i\cdot (m-i)}{m^2}g_{i+1}+\frac{m-i}{m^2}\cdot\sum _{j=1}^ig_j+\frac{m-i}{m}\\&=\left(\frac{m-i}{m}\right)\left(-\frac{i}{m}g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^{i} g_j+1\right)\\&=\frac{m-i}{m}(g_{i}-g_{i+1})\end{aligned}</script><p><del>不会告诉你中途推岔匹了好几次</del></p><p>然后就类似上面那个 case 了，也是可以线性做的。</p><h2 id="PGF-做法"><a href="#PGF-做法" class="headerlink" title="PGF 做法"></a>PGF 做法</h2><h3 id="第一问-1"><a href="#第一问-1" class="headerlink" title="第一问"></a>第一问</h3><p>即考虑套路设 PGF，设 $f_i$ 表示恰好在扔第 $i$ 次结束时的概率，$g_i$ 表示扔了第 $i$ 次仍没结束的概率。考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \qquad(1)\\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \qquad(2)\end{aligned}</script><p>第一个方程可以看做是废话，就是多扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。</p><p>第二个方程的意思是在现在的串后面接一个合法，也就是 $n$ 位都相同的串，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个就结束的情况。个人的理解是，为了保证等式两边是在讨论相同的情况，所以仍然需要把后面的 $n-i$ 次操作算进来，可以知道这样是不影响前面恰好取完了的那些情况。于是根据这个东西依旧可以解出来和做法一相同的结果来。</p><h3 id="第二问-1"><a href="#第二问-1" class="headerlink" title="第二问"></a>第二问</h3><p>定义依旧不变。考虑方程大概是</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1</script><p>和 </p><script type="math/tex; mode=display">\tag{2}\mathscr{G}(z)\cdot \left(\frac{1}{m}z\right)^n\cdot \dfrac{m!}{(n-m)!}=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \cdot \dfrac{(m-i)!}{(m-i-(n-i))!}</script><p>然后就暴力解就好了。</p><h1 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="[CTSC2006] 歌唱王国"></a>[CTSC2006] 歌唱王国</h1><blockquote><p>简化版题面：</p><p>给定一个长为 $n$ 的由 $1\sim m$ 组成的序列 $A$，同时每次掷一颗均匀的 $m$ 面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串和 $A$ 相同。</p><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>考虑和上题差不多的 PGF 做法：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i}\cdot \mathscr{\zeta}(i)\end{aligned}</script><p>其中 $\zeta(i)=\texttt{「 A[1…i] 是否是 A[1…n] 的 Border」}$ 。 还是比较显然的，因为如果是拼到第 $i$ 位就可以停止，那么 $A[1…i]$ 必然是个 $\sf border$ 。</p><p>最后可以直接推出来</p><script type="math/tex; mode=display">\dfrac{\mathrm d}{\mathrm{d}z}\mathscr{F}'(1)=\sum_{i=1}^n \zeta(i)\cdot m^{i}</script><h1 id="SDOI2017-硬币游戏"><a href="#SDOI2017-硬币游戏" class="headerlink" title="[SDOI2017] 硬币游戏"></a>[SDOI2017] 硬币游戏</h1><blockquote><p>给定 $n$ 个长为 $m$ 的由 $0/1$ 组成的序列 $A_i$，同时每次掷一颗均匀的双面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串在 $A_1\sim A_n$ 中出现。</p><p>$n,m\leq 300$.</p></blockquote><p>考虑串与串之间可以来回匹配，于是对每个串都定义一个 $\mathscr{F}_i(z)$ 表示首次出现的是第 $i$ 个串，且当前随机长度为 $j$ 的概率，然后单独定义一个 $\mathscr{G}(z)$ 表示游戏结束，那么有</p><script type="math/tex; mode=display">\sum_{i=1}^n\mathscr{F}_i(z)+\mathscr{G}(z)=\mathscr{G}(z)\cdot z+1</script><p>同时定义 $match(i,j)_k=[~A_i[1…k]=A_{j}[k…m]~]$ ，那么有对于每个 $i$ 的一组方程枚举在最后拼上一个什么东西：</p><script type="math/tex; mode=display">\mathscr{G}(z)\cdot \Pr(A_i[1...n])\cdot x^m=\sum_{j=1}^n \mathscr{F}_j(z)\sum_{k=1}^m match(i,j)_k\cdot \Pr(A_i[k+1...m])\cdot x^{m-k}</script><p>不难知道意思是 $A_j$ 和 $A_i$ 可以放在一起匹配，枚举 $i$ 某个同时是 $A_j$ 后缀的前缀进行配对。</p><p>那么考虑要求的就是 $\mathscr{F}_1(1),\mathscr{F}_2(1),\mathscr{F}_3(1),\cdots$ 。发现可以由方程 $(2)$ 得到 $n$ 个关系，同时因为并没有要求期望所以 $(1)$ 式没有任何用处。但是可以发现，根据概率的规范性可以得到</p><script type="math/tex; mode=display">\sum \mathscr{F}_i(1)=1</script><p>于是就有 $n+1$ 组关系，同时有包含 $\mathscr{G}(1)$ 在内的 $n+1$ 个未知元，就可以愉快地高消了。</p><h1 id="ZJOI2013-抛硬币"><a href="#ZJOI2013-抛硬币" class="headerlink" title="[ZJOI2013] 抛硬币"></a>[ZJOI2013] 抛硬币</h1><blockquote><p>有一枚硬币，抛出正面 <code>H</code> 的概率为 $\frac{a}{b}$，抛出反面 <code>T</code> 的概率为 $1-\frac{a}{b}$。现在 T 小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为 <code>H</code>，反面记为 <code>T</code>，于是她得到了一个抛硬币序列 <code>HTHHT</code>…。</p><p>她突然想到一个问题：在抛出正面和反面概率都是 $\frac{1}{2}$ 的情况下，要使得抛出的序列出现只包含 <code>H</code> 和 <code>T</code> 目标序列，期望要抛多少次。</p><p>这么简单的题目她当然是一眼秒。于是她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为 <code>HT</code> 时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。</p><p>简化版题面：</p><blockquote><p>给出一个两面的均匀骰子，正面和反面的概率分别是 $\frac{a}{b}$ 和 $1-\frac{a}{b}$ 。并给出一个长度为 $n$ 的 $01$ 序列 $A$ 。</p><p>同时有一个一开始为空的序列。每次掷骰子，如果是反面，就在当前序列末尾写一个 $1$ ，否则写一个 $0$ ，如果发现此时序列中恰好有一个连续子串是 $A$ 则停止。求期望多少次才会停止操作。</p></blockquote><p>我认为合理的数据范围：$1\leq n\leq 10^6$，概率对 $998244353$ 取模。</p><p>ZJOI2013 的数据范围：$1\leq n\leq 10^3$ 输出确切概率并保留<strong>既约分数形式</strong> 。</p></blockquote><p>全网似乎没人用 PGF 做，这就很爽。有种中了头彩的感觉…但是其实写这题的时候我是十分崩溃的…</p><p>从 5.3 晚上 8:30 左右一直写，写到 10:00 PM 左右发现有地方写错了，但是由于要回宿舍了所以被迫终止。第二天早上来了又开始写，写着写着发现还要写一波高精 gcd 和高精除，于是就把早上的课给翘了。写完了发现慢的一匹，只能有 $50pts$，然后决定去学一学压位。发现压位也不难，然后决定压 $4$ 位；写着写着又发现压 $8$ 位也不是不可以，然后改来改去改成了 $90pts$ ，发现最大的点比时限慢一倍…于是就去扒自己的 FFT 板子，拼拼凑凑之后发现由于可能会爆精度所以不能压 8 位，只能压 $4$ 位，结果更慢了。然后决定改成 NTT，结果发现 NTT 要对神必数取模导致压两位可能都有问题，然后就自闭了，决定放弃多项式科技去优化自己的压位高精。发现有些地方似乎合并同类项之后会很快，原来乘 $O(n)$ 次改完只需要乘 $O(1)$ 次，然后左改右改终于卡过了洛谷上的1s时限…</p><p>期间一度怀疑自己算法的正确性，但是想了想也没什么更靠谱的做法了，只不过这个写法是 $L^2\log V$ 的，$L^2$ 大概也就是 $10^6$ 的范围，只是这个 $\log V$ …他确实有点毒瘤。因为最大可以到 $V=10^{16000}$ 左右，所以高精度除法二分起来就十分爆炸…大概极限是 $5\cdot 10^9$ 的运算量。不过…好在最后是过了，虽然有点卡时。</p><p>算了一下似乎 FFT 的复杂度更对一点，$L\log L\log V$ 大概是 $10^7\sim 10^8$ 左右的运算量。但是自己的 FFT 水平实在太差…于是就还是多项式乘法了。可能什么时候心情好就会补一下这个锅？</p><p>以下是正文，就直接把发在谷上的题解糊上来了：</p><hr><p>考虑设 $f_i$ 表示扔了 $i$ 次骰子之后恰好停止的概率，$g_i$ 表示扔了 $i$ 次骰子之后仍未结束的概率。同时考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1 \\</script><p>其意义是，扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。同时还有</p><script type="math/tex; mode=display">\tag{2}\mathscr G(z)\cdot \Pr(A[1...n])=\sum_{i=1}^n \mathscr{F}(z)\cdot \Pr(A[i+1...n])\cdot \zeta(i)</script><p>其意义是，考虑在现在的串后面接一个可以让这个过程直接结束的串，也就是接一个 $A$，$\Pr(s[1…n])$ 表示串 $s$ 出现的概率，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个、只加了前 $i$ 个字符就结束的情况，多乘一个 $\Pr(A[i+1…n])$ 本身是没有意义的，只是为了构造出等式，可以理解为两边都钦定扔了 $n$ 次——发现这种情况要是想要出现，就必须满足 $A[1…i]$ 是 $A$ 的一个 $\sf border$ ，所以 $\zeta(i)=[A[1…i]\in\mathbf{Border}]$ .</p><p>之后考虑如何消元。首先对 $(1)$ 式求导可以得到</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)\cdot z+\mathscr{G}(z)\cdot 1</script><p>也就是可以知道 </p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)=\mathscr{G}(z)</script><p>同时对于 $(2)$ 式，将 $z=1$ 代入可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)\cdot \Pr(A[1...n]) =\sum_{i=1}^n\mathscr{F}(1)\cdot \zeta(i)\cdot \Pr(A[i+1...n])</script><p>因为 $\mathscr{F}(1)=1$ ，所以可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)=\dfrac{\sum_{i=1}^n \zeta(i)\cdot \Pr(A[i+1...n])}{\Pr(A[1...n])}</script><p>然后根据</p><script type="math/tex; mode=display">E(X)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(1)</script><p>发现这题就做完了。复杂度线性。</p><p>但是注意本题要求以既约分数的形式保留精确值。因为我好久好久没写过高精度了，于是就想借此机会封装一个模板。然后…然后就写了快 $7h+$。注意到由于要求既约分数，所以要写高精度gcd，写法可以借鉴 <code>[SDOI2009]Super GCD</code> ，同时还要写高精除高精，个人没有找到什么好方法，于是就写的二分，复杂度大概是 $L^2\log V$ 的样子。</p><p>然后复杂度似乎是 $n\cdot L^2\log V$ ，并不可以过，于是考虑剪枝+卡常：</p><p>0、…高精度压位是必要的吧？这边我选择压 $8$ 位，因为发现 $10^3\cdot 10^{16}$ 恰好卡到了 <code>long long</code> 的上界。</p><p>1、发现二分时左右边界可以缩短很多，即 $l,r$ 都至多和 $V / \gcd$ 的长度相差 $1$ ，所以可以用这个来确定边界。亲测可以快大概 $6$ 倍左右(但是还是 T，极限数据大概要跑 $4s+$) 。</p><p>2、发现计算答案时，展开后存在很多公因式。于是可以提取公因式之后再计算。亲测可以快 $4$ 倍左右。</p><p>然后…大概就过了。中间写了很久的原因在于，我本来想尝试 FFT，后来发现自己没有封装好的 FFT…囧…写了半天发现自己 FFT 的常数还不如压位快…然后就没有然后了。</p><hr><p>以上都是无聊的套路题，还是下面的题比较有趣</p><h1 id="趣题-一个有趣的概率小问题-·-改"><a href="#趣题-一个有趣的概率小问题-·-改" class="headerlink" title="[趣题]一个有趣的概率小问题 · 改"></a>[趣题]一个有趣的概率小问题 · 改</h1><p>题目来源是<a href="http://roosephu.github.io/2017/12/31/condexp/" target="_blank" rel="noopener">这里</a>，与本题略有出入：</p><blockquote><p>一个 $n$ 面的骰子，每一面标号 $1$ 到 $n$ 。有个初始为 $0$ 的计数器，每次扔骰子，按顺序执行以下过程：</p><p>1、扔出了奇数：那么计数器清零。</p><p>2、扔出了偶数：计数器加 $1$ 。</p><p>3、扔出了 $n$：游戏结束。</p><p>问结束时计数器上显示的数值的期望。 </p><p>保证 $n$ 是偶数。</p></blockquote><p>考虑如果按照套路设 $f_i$ 表示扔到 $i$ 结束的概率，$g_i$ 表示扔到 $i$ 没有结束的概率，会存在问题。因为根据题设，会重复到达某个权值 $v$ 很多很多次，所以设概率是不妥的。</p><p>考虑 PGF 的一个翻版，对着期望建立生成函数(你可以叫他 EGF【雾】，虽然本质上就是对 PGF 求了一个一阶导数)：设 $f_i$ 表示扔到 $i$ 结束的<strong>期望次数</strong>，$g_i$ 表示扔到 $i$ 没有结束的<strong>期望次数</strong>，对这两个东西建立普通型生成函数可以得到</p><script type="math/tex; mode=display">\mathscr{F}(z)+\mathscr{G}(z)=\left(\mathscr{G}(z)\cdot \dfrac{z}{2}+1\right)+\frac{1}{2}\cdot \mathscr{G}(1)</script><p>其中左边的意思当然是，要么结束要么不结束，换个意思就是「到达 $i$ 的期望总次数」，右边第一项是有 $\dfrac{1}{2}$ 的概率从 $z$ 转移过来，有 $\dfrac{1}{2}$ 的概率到达 $0$，那么此时有等式「原来到达所有 $i$ 的期望次数」=「现在这一步到达 $0$ 的期望次数」。</p><p>同时也会有</p><script type="math/tex; mode=display">\mathscr{F}(z)=\frac{x}{n}\cdot \mathscr{G}(z)</script><p>即恰好扔到 $n$ 的转移，根据题设应该先 $+1$ ，再结束。</p><p>感觉还是比前面的题有趣的？</p><h1 id="来源保密的比赛-1A-Probability"><a href="#来源保密的比赛-1A-Probability" class="headerlink" title="[来源保密的比赛 1A] Probability"></a>[来源保密的比赛 1A] Probability</h1><blockquote><p>有一个随机变量 $z$, 初始 $z=0$.</p><p>执行 $n$ 次操作: 每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:=z+t$ 。</p><p>求 $\min(z,x)$ 的期望. 答案模 $998244353$. </p><p>$k\leq 100,n\leq 10^9,x\leq \min\{10^7,\frac{5\times 10^7}{k}\}$ 。</p></blockquote><p>设选择整数的概率型生成函数为 $P(y)=\sum_{i=0}^kp_i$ ，那么取了 $n$ 次之后的概率型生成函数就是 $Q(y)=P^n(y)$ 。</p><p>那么不难知道答案为</p><script type="math/tex; mode=display">\sum_{i=0}^{n\times k} [y^i]Q\cdot \min(x,i)=\sum_{i=0}^{x-1} [y^i]Q\cdot i + \left(1-\sum_{i=0}^{x-1} [y^i]Q\right)\cdot x</script><p>呃…虽然没学过 PGF 到底怎么化，但是概率上求 $z$ 补集就是 $1-z$ 还是比较 xxs 的结论吧…</p><p>然后现在问题就集中在怎么求 $P^n(y)$ 的前 $k$ 项了。发现可以暴力多项式快速幂，以获得 $40\sim 60$ 左右的成绩。</p><p>然后是神奇的多项式技巧…大概是考虑对于 $P^{n+1}(y)$ 求导有两种方式：</p><script type="math/tex; mode=display">\left(P^{n+1}(y)\right)^{\prime}=(n+1) P^{n}(y) P^{\prime}(y)\\\left(P^{n+1}(y)\right)^{\prime}=\left(P^{n}(y)\right)^{\prime} P(y)+P^{n}(y) P^{\prime}(y)</script><p>第一个就是链式法则，第二个则是拆出一个 $P(y)$ 来再用求导的乘法运算法则。</p><p>考虑联立之后</p><script type="math/tex; mode=display">nP^n(y)(P(y))'=(P^n(y))'P(y)</script><p>然后考虑现在的问题是，已知了 $P^n(y)$ 的前几项系数，求出后面的系数。考虑一个这样的思路：每次先求出 $(P^n(y))’$ 的第 $d$ 项，然后积分出 $P^n(y)$ 的第 $d+1$ 项。发现每个 $[y^d]P^n(y)$ 只会对 $y^d\sim y^{d+k}$ 这些产生贡献，所以考虑枚举到一个 $d$ 的时候向后刷表；考虑这样求出的是 $(P^n(y))’P(y)$ ，直接模拟多项式除法即可得到 $(P^n(y))’$ ，这样做也是单次 $O(k)$ 的。</p><p>对于多项式除法这部分，可以考虑对于每个 $[y^d] (P^n(y))’P(y)$ 都是这么计算得到的：</p><script type="math/tex; mode=display">\sum_{p=0}^k [y^p] P(y)\times [y^{d-p}] (P^n(y))'</script><p>然后就减去所有的 $p&gt;0$ 的那些结果，最后乘上一个 $[x^0]P(y)$ 的逆元即可。</p><p>顺便复习一下线性求逆元：</p><p>考虑模数是 $m$，那么设 $m=p\cdot x+r$，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}p\cdot x+r&\equiv 0\pmod m\\p\cdot r ^{-1}+x^{-1}&\equiv 0 \pmod m\\x^{-1}&\equiv -\lfloor\frac{m}{x}\rfloor\cdot (m\bmod x)^{-1}\pmod m\end{aligned}</script><h1 id="来源保密的比赛-Barrel"><a href="#来源保密的比赛-Barrel" class="headerlink" title="[来源保密的比赛 ?] Barrel"></a>[来源保密的比赛 ?] Barrel</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel2.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel3.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Parrel4.png" alt=""></p><p>读题让人十分迷惑…注意这题里面 $c_{i,j}$ 是给定的，只不过因为样例里面恰好是没有这部分输入而已……</p><hr><p>光是读题就会让人十分迷惑的题…</p><p>因为与符号冲突了，于是决定把题面中的 $z$ 改成 $c$ ，$z$ 维持原来的形式幂级数定义不变。</p><p>考虑深刻地挖掘题目性质：对于每个桶，所有年份体积的酒的体积总和是 $1$ 。所以如果设第 $i$ 个桶里年份为 $j$ 的酒体积为 $V_{i,j}$ ，可以发现本题要求</p><blockquote><p>第 $n$ 个桶内取一微元酒的单价期望/方差，</p></blockquote><p>实际上就是在求</p><blockquote><p><strong>第 $n$ 个桶有 $V_{n,j}$ 的概率变成第 $j$ 年的酒，求第 $n$ 桶酒的期望价值。</strong></p></blockquote><p>考虑先算这个概率。</p><p>考虑一个突破点，发现每次给出去的一定是均匀的，所以不需要考虑给出去的如何分配。换言之如果这一回合给进来的总体积(不看年份)是 $V$ ，那么给出去的必然是 $1-V$ 并且是均匀的。</p><p>根据上一点，理应想到，$1$ 号酒桶就是突破口，因为 $1$ 号桶进来的只会是 $f$ 。于是考虑设每个桶内每一轮新倒入的体积为 $m_i$，那么会有</p><script type="math/tex; mode=display">m_i=\begin{cases}f&\mathrm{if}~(i=1)\\\sum_{j=1}^{i-1}c_{i,j}&\mathrm{otherwise}\end{cases}</script><p>于是考虑设 $f_{i,j}$ 表示第 $i$ 个桶内变成第 $j$ 年酒的概率，对每一个 $i$ 建立概率型生成函数 $\mathscr F_i(z)$ ，那么会有</p><script type="math/tex; mode=display">\mathscr F_{i}(z)=\mathscr F_{i}(z)\cdot z\cdot (1-m_i)+\sum_{j=1}^i m_j\mathscr{F}_j(z)</script><p>这个式子本质上模拟了取酒、倒酒这个过程。</p><p>考虑计算答案，根据上文可以知道</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E(X^2)-E^2(X)</script><p>考虑后面一项本质上是</p><script type="math/tex; mode=display">\left(\sum_{i=0}^{+\infty} i\cdot c^i\cdot [z^i]\mathscr{F}_{n}(z)\right)^2</script><p>然后发现…如果将不定元 $z$ 赋值成 $c$ ，那么上式就是</p><script type="math/tex; mode=display">\left(c\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c)\right)^2</script><p>同理第一项就是</p><script type="math/tex; mode=display">\sum_{i=0}^{+\infty} i\cdot c^{2}\cdot [z^{2\cdot i}]\mathscr{F}_{n}(z^2)</script><p>等价于</p><script type="math/tex; mode=display">c^4\cdot \frac{\mathrm{d^2}}{\mathrm{d}z^2}\mathscr{F}_n(c^2)+c^2\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c^2)</script><p>其中后半部分为了补全系数。</p><p>然后就可以直接做了，用一些求导技巧维护 </p><script type="math/tex; mode=display">\mathscr{F}_{i}(z), \mathscr{F}_{i}^{\prime}(z), \mathscr{F}_{i}\left(z^{2}\right), \mathscr{F}_{i}^{\prime}\left(z^{2}\right), \mathscr{F}_{i}^{\prime \prime}\left(z^{2}\right)</script><p>的值即可。复杂度 $n^2$ 。</p><h1 id="代码合集"><a href="#代码合集" class="headerlink" title="代码合集"></a>代码合集</h1><p>大概是上面的题写了代码就会丢到这里一份，看心情保留完整版还是局部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu4652 Dice</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line">db ans ;</span><br><span class="line">db res ;</span><br><span class="line"><span class="keyword">int</span> k, m, n ;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">expow</span><span class="params">(db x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    db ret = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1.0</span> * ret * x ;</span><br><span class="line">        x = <span class="number">1.0</span> * x * x ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; q)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; m &gt;&gt; n ; </span><br><span class="line">            <span class="keyword">if</span> (!k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) ans = <span class="number">1.0</span> * n ;</span><br><span class="line">                <span class="keyword">else</span> ans = (expow(m, n) - <span class="number">1.0</span>) / (<span class="number">1.0</span> * (m - <span class="number">1.0</span>)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="number">1</span> ; ans = <span class="number">0.0</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    res *= <span class="number">1.0</span> * m / (m - i + <span class="number">1</span>), ans += res ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CTSC2006 歌唱王国</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * x % P ;</span><br><span class="line">        x = <span class="number">1l</span>l * x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m ; <span class="keyword">int</span> j = <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            base[i] = qr(), f[i] = <span class="number">0</span> ; f[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">            <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m) add(ans, expow(n, m), P), m = f[m] ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"000"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">"00"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">1000</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZJOI2013 抛硬币</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">const</span> ll Base = <span class="number">100000000</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_L</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x) ret ++, x /= <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Big_Num</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">2051</span>] ;</span><br><span class="line">    <span class="keyword">bool</span> mk ; <span class="keyword">int</span> len, lent ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        len = <span class="number">0</span>, mk = <span class="number">0</span>, <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mk &amp;&amp; !(len &lt;= <span class="number">1</span> &amp;&amp; !v[<span class="number">1</span>])) <span class="built_in">putchar</span>(<span class="string">'-'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i == len)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">8</span> - get_L(v[i]) ; ++ j) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) mk = <span class="number">1</span>, x = -x ;</span><br><span class="line">        <span class="keyword">while</span> (x) v[++ len] = x % Base, x /= Base ;</span><br><span class="line">lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; reset() ;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">1</span>] == <span class="string">'-'</span>) ++ p, mk = <span class="number">1</span> ;</span><br><span class="line">        len = (L - p) / <span class="number">8</span> + (((L - p) % <span class="number">8</span>) &gt; <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L, k = len ; i &gt;= p + <span class="number">1</span> ; i -= <span class="number">8</span>, -- k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = min(i - p, <span class="number">8</span>) ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                v[k] = v[k] * <span class="number">10l</span>l + (x[i - j + <span class="number">1</span>] - <span class="string">'0'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">reverse(v + <span class="number">1</span>, v + len + <span class="number">1</span>) ;  lent = L - p ;</span><br><span class="line">    &#125;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> ~ (Big_Num A)&#123;</span><br><span class="line">        A.mk ^= <span class="number">1</span> ; <span class="keyword">return</span> A ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len != B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] != B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ;</span><br><span class="line">        Big_Num p, q, t ; p = A, q = B ;</span><br><span class="line">        <span class="keyword">if</span> (p.lent &lt; q.lent) &#123; <span class="keyword">return</span> (~ (q - p)) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] - q.v[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &lt; <span class="number">0</span>) res.v[i + <span class="number">1</span>] --, res.v[i] += Base ;</span><br><span class="line">        res.len = p.len ; res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">20</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line"><span class="keyword">if</span> (res.v[res.len] &lt; <span class="number">0</span>)</span><br><span class="line">            res.mk = <span class="number">1</span>, res.len --, res.v[res.len] = Base - res.v[res.len] ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ;</span><br><span class="line">        res.reset() ; Big_Num p, q ;</span><br><span class="line">        <span class="keyword">if</span> (A.len &gt; B.len)</span><br><span class="line">            p = A, q = B ; <span class="keyword">else</span> p = B, q = A ;</span><br><span class="line">        <span class="keyword">if</span> (p.mk &amp;&amp; q.mk) res.mk = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.mk &amp;&amp; !q.mk) &#123; p.mk = <span class="number">0</span> ; <span class="keyword">return</span> (q - p) ; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.mk &amp;&amp; q.mk) &#123; q.mk = <span class="number">0</span> ; <span class="keyword">return</span>(p - q) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] + q.v[i] ;</span><br><span class="line">        res.len = p.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &gt;= Base)</span><br><span class="line">                res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ; res.len = A.len + B.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= B.len ; ++ j)</span><br><span class="line">                res.v[i + j - <span class="number">1</span>] += A.v[i] * B.v[j] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res.len + <span class="number">10</span> ; ++ i)</span><br><span class="line">            res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">div2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            v[i - <span class="number">1</span>] += (v[i] % <span class="number">2l</span>l) * Base, v[i] &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        v[<span class="number">0</span>] &gt;&gt;= <span class="number">1</span> ; <span class="keyword">while</span>(v[len] == <span class="number">0</span>) len -- ;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">mul2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) &#123;</span><br><span class="line">            v[i] = v[i] * <span class="number">2</span> + r, r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= Base) &#123;</span><br><span class="line">                r = v[i] / Base, v[i] %= Base ;</span><br><span class="line">                <span class="keyword">if</span> (i == len) len ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Big_Num <span class="keyword">friend</span> <span class="title">gcd</span><span class="params">(Big_Num A, Big_Num B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!(A ^ B))&#123;</span><br><span class="line">            <span class="keyword">if</span> (A &lt; B) swap(A, B) ;</span><br><span class="line">            <span class="keyword">bool</span> a = A.v[<span class="number">1</span>] &amp; <span class="number">1</span>, b = B.v[<span class="number">1</span>] &amp; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!a &amp;&amp; !b) A.div2(), B.div2(), ++ cnt2 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!b) B.div2() ; <span class="keyword">else</span> <span class="keyword">if</span> (!a) A.div2() ; <span class="keyword">else</span> A = A - B ;</span><br><span class="line">        &#125;</span><br><span class="line">        Big_Num tmp, pmt ;</span><br><span class="line">        tmp.set_v(<span class="number">2</span>), pmt.set_v(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (cnt2)&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt2 &amp; <span class="number">1</span>)</span><br><span class="line">pmt = pmt * tmp ;</span><br><span class="line">tmp = tmp * tmp ; cnt2 &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> (A = A * pmt) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Big_Num g, t ;</span><br><span class="line">Big_Num l, r, mid, ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span>&#123;</span></span><br><span class="line">    Big_Num fz, fm ;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.reset() ;</span><br><span class="line">        fm.reset() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Big_Num t = fz ; fz = fm, fm = t ;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function">il <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        g = gcd(fz, fm) ; r.reset() ;</span><br><span class="line"><span class="keyword">int</span> lnr = fz.len - g.len ; l.reset() ; l.len = lnr  ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fz) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fz = ans ; l.reset() ;</span><br><span class="line">lnr = fm.len - g.len ; l.reset() ; l.len = lnr ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fm) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fm = ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.out_put() ;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'/'</span>) ;</span><br><span class="line">        fm.out_put() ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T son, T mum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son), fm.set_v(mum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *son, <span class="keyword">int</span> Lson, <span class="keyword">char</span> *mum, <span class="keyword">int</span> Lmum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son, Lson) ; fm.set_v(mum, Lmum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> + (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!A.fz.len &amp;&amp; !A.fm.len) <span class="keyword">return</span> B ;</span><br><span class="line">        <span class="keyword">if</span> (!B.fz.len &amp;&amp; !B.fm.len) <span class="keyword">return</span> A ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz + B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> - (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz - B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ;</span><br><span class="line">        res.fz = A.fz * B.fz ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fz = A.fz * B.fz ; res.fm = A.fm ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> &amp; (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ; res.fz = A.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r1, r2, r3, r0 ;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> A, B ;</span><br><span class="line">Frac res ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line">Frac Rp[N] ;</span><br><span class="line">Frac Pr[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">r0.set_v(<span class="number">1</span>, B) ;</span><br><span class="line">    r1.set_v(A, <span class="number">1</span>) ;</span><br><span class="line">Rp[<span class="number">0</span>].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">r2.set_v(B - A, <span class="number">1</span>) ;</span><br><span class="line">    m = <span class="built_in">strlen</span>(S + <span class="number">1</span>), Pr[m].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        base[i] = (<span class="keyword">bool</span>)(S[i] == <span class="string">'H'</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = m ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">        Pr[j - <span class="number">1</span>] = Pr[j] ^ (base[j] ? r1 : r2) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j) Rp[j] = Rp[j - <span class="number">1</span>] &amp; r0 ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">        <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    t.reset() ; t.set_v(<span class="number">1</span>) ;</span><br><span class="line">    r3 = Pr[<span class="number">0</span>] * Rp[m] ; r3.reverse() ; <span class="keyword">int</span> k = m ;</span><br><span class="line">    <span class="keyword">while</span> (m) res = res + Pr[m] * Rp[k - m] , m = f[m] ;</span><br><span class="line">res = res * r3 ; res.div() ; res.out_put() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[来源保密的比赛 1A] Probability</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> base ;</span><br><span class="line"><span class="keyword">int</span> F[M] ;</span><br><span class="line"><span class="keyword">int</span> f[M] ;</span><br><span class="line"><span class="keyword">int</span> G[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, x ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x ; inv[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = qr(), add(sum, <span class="number">1l</span>l * F[i]) ;</span><br><span class="line">    sum = expow(sum, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = <span class="number">1l</span>l * F[i] * sum % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = <span class="number">1l</span>l * n * F[i + <span class="number">1</span>] % P * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        inv[i] = (<span class="number">-1l</span>l * inv[P % i] * (P / i) % P) + P;</span><br><span class="line">    base = expow(F[<span class="number">0</span>], P - <span class="number">2</span>) ; G[<span class="number">0</span>] = expow(F[<span class="number">0</span>], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; i + j &lt; x &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            add(tmp[i + j], <span class="number">1l</span>l * f[j] * G[i] % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i - j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            dec(tmp[i], <span class="number">1l</span>l * g[i - j] * F[j] % P) ;</span><br><span class="line">        g[i] = <span class="number">1l</span>l * base * tmp[i] % P ;</span><br><span class="line">        G[i + <span class="number">1</span>] = <span class="number">1l</span>l * g[i] * inv[i + <span class="number">1</span>] % P ;</span><br><span class="line">        add(ans, <span class="number">1l</span>l * i * G[i] % P) ; dec(res, G[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="number">1</span> ; add(ans, <span class="number">1l</span>l * res * x % P) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[SDOI2017] 硬币游戏</span></span><br><span class="line"><span class="comment">//long double 确实很慢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Base = <span class="number">233</span> ;</span><br><span class="line"></span><br><span class="line">ldb val[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line">ldb ans[N] ;</span><br><span class="line">ldb f[N][N] ;</span><br><span class="line"><span class="keyword">char</span> s[N][N] ;</span><br><span class="line"><span class="keyword">int</span> _hs[N][N] ;</span><br><span class="line"><span class="keyword">bool</span> match[N][N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decn(_hs[t][r], <span class="number">1l</span>l * _hs[t][l - <span class="number">1</span>] * pos[r - l + <span class="number">1</span>] % P) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    pos[<span class="number">0</span>] = val[<span class="number">0</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        val[i] = val[i - <span class="number">1</span>] * <span class="number">2.0</span> ;</span><br><span class="line">        pos[i] = <span class="number">1l</span>l * pos[i - <span class="number">1</span>] * Base % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            _hs[i][j] = ((ll)_hs[i][j - <span class="number">1</span>] * Base % P + s[i][j]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                match[i][j][k] = (<span class="keyword">bool</span>)(ask(i, <span class="number">1</span>, k) == ask(j, m - k + <span class="number">1</span>, m)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                f[i][j] += (db)match[i][j][k] * val[k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[n + <span class="number">1</span>][i] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][n + <span class="number">1</span>] = - <span class="number">1.0</span> ; f[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    gauss(n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7Lf\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的…就先鸽着吧，感觉除了复习高消之外也没啥好写的了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这文章真是莫名其妙的写了好几天，可能是题目钛毒瘤了导致经常出现思维掉线的局面…</p><p>其中比较多题目的都是杨懋龙前辈论文里的，自己学习了一下，顺便加上了一些自己的心得。</p><p>这可能就是…执念吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是最近的研究成果吧？&lt;/p&gt;
&lt;p&gt;「学不会的生成函数」+「学不会的概率论」= &lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="组合计数/概率型生成函数(PGF)" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A6%82%E7%8E%87%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-PGF/"/>
    
  </entry>
  
  <entry>
    <title>【UR#3】链式反应</title>
    <link href="https://www.orchidany.cn/2020/05/02/UR50%E9%93%BE%E5%BC%8F%E5%8F%8D%E5%BA%94/"/>
    <id>https://www.orchidany.cn/2020/05/02/UR50链式反应/</id>
    <published>2020-05-02T13:08:39.000Z</published>
    <updated>2020-05-09T07:25:38.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道读题就很麻烦的题目，以下是简化版的题面：</p><blockquote><p>给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：</p><p>1、父亲节点的标号大于子节点。</p><p>2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。</p><p>3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。</p><p>$1\leq n\leq 2\cdot 10^5$ 。</p></blockquote><a id="more"></a><p>考虑暴力 $dp$ ，设状态 $f_i$ 表示以 $i$ 为根时树的数量。那么有</p><script type="math/tex; mode=display">f_{i}=\sum_{j}\sum_{k}\binom{i-1}{j}\cdot\binom{i-j-1}{k}\cdot f_j\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>但是注意到由于 $\alpha$ 型儿子是无序的，所以应该乘一个 $\frac{1}{2}$ 的常数。于是就可以获得一个 $40$ 分的 $O(n^3)$ 做法。</p><p>注意到可以把 $j$ 和 $k$ 分离，变成</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot \sum_{j}\binom{i-1}{j}\cdot f_j\cdot\sum_{k}\binom{i-j-1}{k}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>展开两个二项系数</p><script type="math/tex; mode=display">\begin{aligned}f_{i}&=\frac{1}{2}\cdot \sum_{j}\frac{(i-1)!}{j!\cdot (i-j-1)!}\cdot f_j\cdot\sum_{k}\frac{(i-j-1)!}{k!\cdot (i-j-k-1)!}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]\\&=\frac{1}{2}\cdot (i-1)!\cdot \sum_{j}\frac{f_j}{j!}\cdot\sum_{k}\frac{f_k}{k!}\cdot \frac{[(i-j-k-1)\in \mathbb{A}]}{(i-j-k-1)!}\\\end{aligned}</script><p>因为每次本质上只关心 $i-1-(j+k)$ 是否是 $\mathbb A$ 中的元素，所以即通过维护一个 $g$ </p><script type="math/tex; mode=display">g_i= \sum_{j+k=i}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}</script><p>然后转移就可以</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p}{g_p\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>这样就是 $O(n^2)$ 的了。可以喜提 $60pts$ 。</p><p>考虑放到同一个式子里观察：</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p\leqslant i-1}\sum_{j+k=p}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}{\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>那么如果设 $\mathbf{F}_i=\dfrac{f_i}{i!},\mathbf{P}_i=\dfrac{[i\in \mathbb{A}]}{i!}$，可以发现原式就是一个卷积的形式：</p><script type="math/tex; mode=display">2\cdot i\cdot \mathbf{F}_i=\sum_{2\leqslant j+k\leqslant i-1} \mathbf{F}_j\cdot \mathbf{F}_k\cdot \mathbf{P}_{i-j-k-1}</script><p>此时有两种不同的做法：</p><h2 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h2><p>即发现本质上是在解一个这样的微分方程</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} x}\mathbf{F}=\frac{1}{2}\cdot \mathbf{F}^2\mathbf{P}+1</script><p>然后迭就完了。复杂度 $O(n\log n)$ 但是常数…有点可怕。</p><h2 id="技巧分治"><a href="#技巧分治" class="headerlink" title="技巧分治"></a>技巧分治</h2><p>这式子看上去就…十分的分治 FFT？但是注意到这是二卷积的形式。考虑最简单的分治 FFT 是单卷积，进行的操作可以看作是时间轴上的二进制拆分，即每次用已经得到实际结果的 $f_{l,l+1\cdots mid}$ 去更新 $f_{mid+1,mid+2\cdots r}$ 。考虑二卷积的时候，本质上与单卷积相同， 但需要分类讨论：</p><p>1、$l=1$ 时。</p><p>此时就是 $\mathbf{F}_{1…mid}^2$ 和 $\mathbf{P}_{0…r-l+1}$ 卷在一起。注意 $\mathbf{F}$ 中根据组合意义不能取第 $0$ 项。</p><p>2、$l&gt;1$ 时。</p><p>发现此时由于分治了之后，要保证复杂度，似乎会出现需要用到 $i&gt;mid$ 的 $f_i$ 的情况——但根据分治策略，此时一定有 $2\cdot l&gt;r$ ，也就是 $\forall i\in[l,mid]\cap\mathbb{Z_+}$ ，$i&gt;r-l-1\Longrightarrow r-i<l-1$ 。那么就代表着需要的元素都已经 $l$ 之前被求出了准确值，所以此时不需要考虑 $i>mid$ 的那些转移点。所以此时就直接拿 $\mathbf{F}_{1…r-l}$ 卷上 $\mathbf{F}_{l…mid}$ 和 $\mathbf{P}_{1..r-l}$ 即可。注意到此时有别于 $l=1$ ，对于两棵子树的不同形态本质没有算重。所以为了处理方便可以在此时乘一个 $2$ 。</p><p>于是这种分治方式就比其他朴素的分治多一个比较优的常数。现在跑到了<a href="http://uoj.ac/problem/50/statistics" target="_blank" rel="noopener">uoj榜</a>的第一页。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll g[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll inv[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inv_2 = <span class="number">499122177</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * x % P ;</span><br><span class="line">        x = (ll)x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[n + <span class="number">1</span>] = expow(fac[n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1l</span>l) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, o ; k &lt;= i - j - <span class="number">1</span> ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (base[i - j - k - <span class="number">1</span>])&#123;</span><br><span class="line">                    o = comb(i - <span class="number">1</span>, j) ;</span><br><span class="line">                    o = <span class="number">1l</span>l * o * comb(i - j - <span class="number">1</span>, k) % P ;</span><br><span class="line">                    add(f[i], <span class="number">1l</span>l * o * f[j] % P * f[k] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; g[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i - j - <span class="number">1</span>])</span><br><span class="line">                add(f[i], <span class="number">1l</span>l * g[j] * inv[i - j - <span class="number">1</span>] % P) ;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            add(g[i], <span class="number">1l</span>l * f[i - j] * f[j] % P * inv[i - j] % P * inv[j] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">    <span class="keyword">int</span> k, d ;</span><br><span class="line">    <span class="keyword">int</span> rev[N] ;</span><br><span class="line">    ll g[<span class="number">20</span>][N] ;</span><br><span class="line">    <span class="function">il ll <span class="title">expow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = ret * x % P ;</span><br><span class="line">            x = x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_rt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; ++ i)&#123;</span><br><span class="line">            ll* r = g[i], ut ; r[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            ut = r[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) r[j] = r[j - <span class="number">1</span>] * ut % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(T *f, <span class="keyword">int</span> L, <span class="keyword">bool</span> mk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ l)&#123;</span><br><span class="line">            ll *r = g[l], o = i &lt;&lt; <span class="number">1</span>, rt, irt ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += o)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt; i + j ; ++ k)&#123;</span><br><span class="line">                    rt = f[k], irt = f[k + i] * r[k - j] % P ;</span><br><span class="line">                    f[k] = addn(rt, irt), f[k + i] = decn(rt, irt) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mk) <span class="keyword">return</span> ;</span><br><span class="line">        reverse(f + <span class="number">1</span>, f + L) ;</span><br><span class="line">        <span class="keyword">int</span> o = expow(L, P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) (f[i] *= o) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        d = <span class="number">1</span>, k = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (d &lt;= x) d &lt;&lt;= <span class="number">1</span>, ++ k ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (k - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tl[N] ;</span><br><span class="line">    ll tr[N] ;</span><br><span class="line">    ll tmid[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span>) f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> f[l] = expow(<span class="number">2</span> * l, P - <span class="number">2</span>) * f[l] % P ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = r - l + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> len1 = mid - l + <span class="number">1</span> ;</span><br><span class="line">        cdq(l, mid) ; getlen(len * <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tr[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) add(f[i], tl[i - l]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tmid + <span class="number">1</span>, f + <span class="number">1</span>, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tmid + len + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            tmid[<span class="number">0</span>] = tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tmid, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tmid[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)</span><br><span class="line">                add(f[i], <span class="number">2l</span>l * tl[i - l] % P) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cdq(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1lld"</span>, &amp;base[i]) ; pre_do() ;</span><br><span class="line">    Poly :: pre_rt() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        base[i] = base[i] * inv[i] % P ;  <span class="comment">//debug(base, 0, n - 1) ;</span></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; Poly :: cdq(<span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i] * fac[i] % P) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道读题就很麻烦的题目，以下是简化版的题面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：&lt;/p&gt;
&lt;p&gt;1、父亲节点的标号大于子节点。&lt;/p&gt;
&lt;p&gt;2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。&lt;/p&gt;
&lt;p&gt;3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq 2\cdot 10^5$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
  </entry>
  
</feed>
