<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-EoAakqjy" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EoAakqjy"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-04-29T12:34:46.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p><del>恭喜你来到了没有知识的荒原.</del></p><p>这篇文章已经移步到侧边栏的「<code>Navigation</code>」里啦！还不去看看？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【复习】概率期望做题笔记</title>
    <link href="https://www.orchidany.cn/2020/05/06/%E6%9C%9F%E6%9C%9B/"/>
    <id>https://www.orchidany.cn/2020/05/06/期望/</id>
    <published>2020-05-06T09:26:20.000Z</published>
    <updated>2020-05-09T07:24:42.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>胡做八做了一点简单的期望题，算是练练手感吧。</p><p>一共是 $15$ 道题。</p><a id="more"></a><h1 id="不太需要技巧的例题"><a href="#不太需要技巧的例题" class="headerlink" title="不太需要技巧的例题"></a>不太需要技巧的例题</h1><h2 id="Luogu3802-小魔女帕琪"><a href="#Luogu3802-小魔女帕琪" class="headerlink" title="Luogu3802 小魔女帕琪"></a><a href="https://www.luogu.org/problem/P3802" target="_blank" rel="noopener">Luogu3802 小魔女帕琪</a></h2><p>这东西我硬推推出来一个：</p><script type="math/tex; mode=display">\dfrac{\left(\begin{array}{c}{\mathrm{S}-6} \\ {1}\end{array}\right) \cdot 7 ! \cdot \prod_{\mathrm{i}=1}^{7} \mathrm{a}_{\mathrm{i}} \cdot(\mathrm{S}-7) !}{\mathrm{S} !}</script><p>的东西。感觉还可以？然后其实就是一种思想？此时总方案数$\rm S$这东西不应该除以某些奇怪的阶乘，或者说，不需要，因为样本空间可以理解为先发生了$A$和发生了$B$虽然局面一样但是概率独立（大概</p><h2 id="Luogu5489-LnOI2019-脸滚键盘"><a href="#Luogu5489-LnOI2019-脸滚键盘" class="headerlink" title="Luogu5489 [LnOI2019]脸滚键盘"></a><a href="https://www.luogu.org/problem/P5498" target="_blank" rel="noopener">Luogu5489 [LnOI2019]脸滚键盘</a></h2><p>这题写过题解，现在复习一遍。大概就是考虑维护一个前缀和，构造数列</p><script type="math/tex; mode=display">\rm F_i=F_{i-1}\cdot base_i+base_i</script><p>然后我们发现它的级数很美妙：</p><script type="math/tex; mode=display">{\sum_{i=1}^{n}F_i=base_1+base_2\cdots+base_n+base_1base_2+base_2base_3\cdots+\prod_{i=1}^{n}base_i}</script><p>正好就是我们要求的答案。</p><p>但此时直接前缀和会有问题，因为多余的实际上是$a_0\cdots a_n$那一堆项，所以需要像哈希一样左半边乘上</p><script type="math/tex; mode=display">\prod_{i=1}^{r}base_i+\prod_{i=1}^{r-1}base_i+\cdots +\prod_{i=1}^{l}base_i</script><h2 id="Luogu1297-国家集训队-单选错位"><a href="#Luogu1297-国家集训队-单选错位" class="headerlink" title="Luogu1297 [国家集训队]单选错位"></a><a href="https://www.luogu.org/problem/P1297" target="_blank" rel="noopener">Luogu1297 [国家集训队]单选错位</a></h2><p>然后其实，$\rm E_S=\mathbb{E}(1)+\mathbb{E}(2)+\mathbb{E}(3)\cdots$ </p><p>观察 $ \mathbb{E}(i)$，实际上只与 $ base_i,base_{i+1}$ 有关，那么每一项的贡献就是 $\dfrac{1}{\max(base_i,base_{i+1})}$。加起来即可。</p><h2 id="Luogu3924-康娜的线段树"><a href="#Luogu3924-康娜的线段树" class="headerlink" title="Luogu3924 康娜的线段树"></a><a href="https://www.luogu.org/problem/P3924#submit" target="_blank" rel="noopener">Luogu3924 康娜的线段树</a></h2><blockquote><p>每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？</p><p>此处的区间加是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (o&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (o&lt;&lt;1|1)</span></span><br><span class="line"> <span class="keyword">int</span> sumv[N&lt;&lt;<span class="number">2</span>],minv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> pushu\Pr(<span class="keyword">int</span> o)&#123;sumv[o]=sumv[lson]+sumv[rson];&#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     build(lson,l,mid);build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> q,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l==r)&#123;sumv[o]+=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(q&lt;=mid)change(lson,l,mid,q,v);</span><br><span class="line">     <span class="keyword">else</span> change(rson,mid+<span class="number">1</span>,r,q,v);</span><br><span class="line">     pushu\Pr(o);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;T; </span><br><span class="line"><span class="comment">//区间加</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)T.change(<span class="number">1</span>,<span class="number">1</span>,n,i,addv);</span><br></pre></td></tr></table></figure><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>根据线性性显然可以知道维护的就是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i}{2^{depth_i}}</script><p>其中根节点的 $depth$ 默认为 $0$ 。考虑先把这个式子通分一下：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\dfrac{val_i\cdot 2^{maxL-depth_i}}{2^{maxL}}=\dfrac{1}{2^{maxL}}\sum_{i=1}^{n}val_i\cdot 2^{maxL-depth_i}</script><p>然后考虑，如果是区间修改，那么本质上只需要求出区间内所有点的线段树上子树内系数 $2^{maxL-depth_i}$ 的和。这一部分可以直接预处理得到。并且考虑只有区间加的操作，所以并不需要真正动态地去维护。直接维护一个全局 $ans$ 即可。</p><p>于是最后复杂度线性。</p><h1 id="考察期望线性性的题目"><a href="#考察期望线性性的题目" class="headerlink" title="考察期望线性性的题目"></a>考察期望线性性的题目</h1><h2 id="ZROI-1142-石子"><a href="#ZROI-1142-石子" class="headerlink" title="[ZROI 1142]石子"></a>[ZROI 1142]石子</h2><blockquote><p>小 D 正在玩取石子游戏。 小 D 共有 $n$ 堆石子，依次编号为 $1, 2, · · · , n$，其中第 $i$ 堆有 $a_i$ 颗石子。 小 D 每次会等概率随机选择一颗石子，并取完它所在的那一堆石子。 小 D 想要知道，第 $1$ 堆石子被取走的时间的期望。</p><p>$n=10^6$。</p></blockquote><p>根据期望的线性性，可以知道可以分别算每堆石子在第 $1$ 堆之前被取完的概率。所以就是</p><script type="math/tex; mode=display">\mathbb{E}(t)=P_{2}+P_{3}+\cdots+P_{n}+1</script><p>于是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ; ans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (<span class="keyword">double</span>)base[i] / (<span class="keyword">double</span>)(base[i] + base[<span class="number">1</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BZOJ3036-绿豆蛙的归宿"><a href="#BZOJ3036-绿豆蛙的归宿" class="headerlink" title="[BZOJ3036]绿豆蛙的归宿"></a>[BZOJ3036]绿豆蛙的归宿</h2><blockquote><p>给出 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。</p><p>绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\dfrac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？</p></blockquote><p>发现路径可以拆分，于是根据期望的线性性有</p><script type="math/tex; mode=display">\mathbb{E}(L)=\sum_{e=(u,v)}\mathbb{E}(e) = \sum_{e=(u,v)}\Pr(e)\cdot val(e)</script><p>于是 <code>dfs</code> 一遍即可。</p><h2 id="CF280C-Game-On-Tree"><a href="#CF280C-Game-On-Tree" class="headerlink" title="CF280C Game On Tree"></a>CF280C Game On Tree</h2><blockquote><p>给出一棵树，每次随机等概率选择一未染黑的点，将它及其子树染黑。问期望多少次操作可以将树全部染黑。</p><p>$1\leq n\leq 10^5$ .</p></blockquote><p>草，我居然能把这题给秒掉，太可怕了。</p><p>考虑首先是期望的线性嘛，于是可以知道 $\mathbb{E}(T)$ 表示把树 $T$ 全部染黑的期望次数，那么可以知道有</p><script type="math/tex; mode=display">\mathbb{E}(T)=\sum_{u\in T} \mathbb{E}(u)</script><p>其中 $u$ 是那么考虑如果想要染黑一棵以 $u$ 为根的子树，可以采用的策略是把它到根的路径上任意一点染黑，但是只有在染黑他自己的时候才会对答案产生贡献。所以不难知道</p><script type="math/tex; mode=display">\mathbb{E}(u)=\dfrac{1}{depth_u}</script><h1 id="考察转移递推思想的期望题目"><a href="#考察转移递推思想的期望题目" class="headerlink" title="考察转移递推思想的期望题目"></a>考察转移递推思想的期望题目</h1><h2 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="[NOI2005]聪聪与可可"></a>[NOI2005]聪聪与可可</h2><blockquote><p>给定一张 $n,m$ 的无向图。两个人一开始分别在点 $A,B$。每次 $A$ 先走，$B$ 后走，$A$ 每次会选择一个离 $B$ 最近且编号最小的点走 $1\sim2$ 步，$B$ 随机游走(也可停在原地，概率平摊)，求期望多少步 $A$ 可以与 $B$  相遇。</p><p>$1 \leq N, E \leq 1000$。</p></blockquote><p>emmm 要是化归子问题的话，一开始觉得应该算出在每个点相遇的期望步数，但想了想觉得这个并不可做…</p><p>于是考虑更暴力一点化归子问题： $f_{u,v}$ 表示 $A$ 在 $u$，$B$ 在 $v$ 时两者相遇的期望步数。那么考虑转移：</p><p>1、$u=v$ ，$f_{u,v}=0$ 。</p><p>2、$dis(u,v)=1$，$f_{u,v}=1$ （因为 $A$ 先走）。</p><p>3、$dis(u,v)&gt;1$，$f_{u,v}=\dfrac{\sum{f_{u’,v’}}}{\deg(v)+1}$ ，其中 $u’$ 是 $u$ 走两步可以到达的离 $v$ 最近的一个点，$v$ 是随便一个点。</p><p>然后就可以记搜了。我其实很迷惑为什么全员最短路的题要出 $1e3$ …除了强行丰富代码难度，有什么意义吗…</p><p>注意实现的一点小细节。如果 $x$ 走两步就可以走到 $y$，此时应该直接 <code>return 1.0</code> ，因为 $B$ 根本没有走的机会。</p><h2 id="LuoguP1365-OSU-Easy-Version"><a href="#LuoguP1365-OSU-Easy-Version" class="headerlink" title="[LuoguP1365]OSU!(Easy Version)"></a>[LuoguP1365]OSU!(Easy Version)</h2><blockquote><p>给定一个序列，某些位置是 $0$，某些位置是 $1$ ，某些位置分别有 $50\%$ 的概率变成 $0$ 或者 $1$ 。求极大连续纯 $1$ 段的长度的平方之和的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>考虑分别记 $f_i,g_i$ 表示总期望/当前段的期望。那么可以分类讨论 $i$ 的类型：</p><p>1、$a_i=1,g_i=g_{i-1}+1,f_{i}=f_{i-1}+2\cdot g_{i-1}+1$ 。</p><p>2、$a_i=0,g_i=0,f_{i}=f_{i-1}$ 。</p><p>3、$a_i=?,g_{i}=g_{i-1}+0.5,f_{i}=f_{i-1}+g_{i-1}+0.5$ 。</p><p>还是比较简单的。注意一个点即可，根据期望的线性性，如果按照「前 $i$ 个」作为划分阶段的依据，需要把一个极长连续 $1$ 段的贡献摊到每个元素上面，摊的方法就是平方和公式。</p><h2 id="BZOJ4318-OSU-Hard-Version"><a href="#BZOJ4318-OSU-Hard-Version" class="headerlink" title="[BZOJ4318]OSU!(Hard Version)"></a>[BZOJ4318]OSU!(Hard Version)</h2><blockquote><p>我们可以把osu的规则简化与改编成以下的样子:</p><p>一共有 $n$ 次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，$n$ 次操作对应为长度为 $n$ 的<code>01</code> 串。在这个串中连续的 $X$ 个 1 可以贡献 $X^3$ 的分数，这 $X$ 个 $1$ 不能被其他连续的 $1$ 所包含（也就是极长的一串1）</p><p>现在给出 $n$，以及每个操作的成功率，请你输出期望分数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>跟上一题十分接近的思路。但是考虑立方和公式 $(x+1)^3=x^3+3x^2+3x+1$ ，由于 $\mathbb{E}^2(x)\neq \mathbb{E}(x^2)$，所以不能直接拿线性性拆。于是考虑分别维护极长段的平方和和长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">g[i] = (g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i], </span><br><span class="line">p[i] = (p[i - <span class="number">1</span>] + <span class="number">2</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) * base[i],</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + base[i] *  (<span class="number">3</span> * p[i - <span class="number">1</span>] + <span class="number">3</span> * g[i - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Luogu4550-收集邮票"><a href="#Luogu4550-收集邮票" class="headerlink" title="[Luogu4550]收集邮票"></a>[Luogu4550]收集邮票</h2><blockquote><p>有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $\dfrac{1}{n}$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 张邮票需要支付 $k$ 元钱。</p><p>现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>首先考虑一个简化版问题：</p><blockquote><p>每次随机一个$[1,n]$的整数，问期望几次能凑出所有数 </p></blockquote><p>考虑期望的线性性，就是 $\mathbb{E}=\sum \mathbb{E}(i)$，其中 $\mathbb{E}$ 为所求，$\mathbb{E}(i)$ 为在已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望次数。根据之前整理过的内容，“发生概率为 $p$ 的事件，在期望 $\dfrac{1}{p}$ 次之后会发生”，我们可以得到如下：</p><script type="math/tex; mode=display">\begin{aligned}\Pr(i)& =\dfrac{n-(i-1)}{n} \\\mathbb{E}(i)& =\dfrac{1}{\Pr(i)}=\dfrac{n}{n-i+1}\end{aligned}</script><p>然后把他们加起来就是</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum\dfrac{n}{n-i+1}=\sum\dfrac{n}{i}</script><p>思路是自然的。然后考虑本题，需要给每次操作附加一个权值。所以本质上我们可以分开计算，$g_i$表示已经取出 $i-1$ 个数字时，取到第 $i$ 个数字的期望步数，$ f_i$表示期望步数的<code>cost</code>。</p><p>考虑如何计算 $f_i$。假设之前拿数进行了 $p$ 次操作，这一次拿 $i$ 需要 $q$ 次操作，那么这 $q$ 次操作的 $\rm \sum cost$ 就是</p><script type="math/tex; mode=display">p\cdot q+q^2=(p+q)\cdot q</script><p>这个原理需要编一下。考虑前一半是之前拿数次数与当前拿数次数的乘积，可以知道此时的代价至少是这些；后一半在不考虑前面拿数的贡献后，可以考虑期望的意义，$q$ 既是期望次数，也是平均代价，所以可以知道当前的代价应该是 $q^2$ 。</p><p>然后就递推一下即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">n = <span class="number">1.0</span> * N / (N - i + <span class="number">1</span>), </span><br><span class="line">g[i] = g[i - <span class="number">1</span>] + n, f[i] = f[i - <span class="number">1</span>] + g[i] * n ;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>, f[N])  ;</span><br></pre></td></tr></table></figure><h2 id="SHOI2014-概率充电器"><a href="#SHOI2014-概率充电器" class="headerlink" title="*[SHOI2014]概率充电器"></a>*[SHOI2014]概率充电器</h2><blockquote><p>SHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定(每条边有一个通电概率)，每一个充电元件自身是否直接进行充电也由概率决定(每个点也有一个通电概率)。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。</p><p>你突然想知道，进入充电状态的元件个数的期望是多少呢？</p><p>$1\leq n\leq 5\cdot 10^5$。</p></blockquote><p>比较有难度的题目。</p><p>根据期望的线性性，可以知道这题只需要求出每个点被点亮的概率即可。考虑设 $f_u$ 表示 $u$ 的子树对 $u$ 的贡献，$g_u$ 表示 $u$ 真正的贡献。不难知道 $f_u\leq g_u$ 。</p><p>那么考虑分别求这两部分。首先常规树形 $dp$ 求出 $f_{root}=g_{root}$  来，转移大概是考虑依次把子树合并进来：</p><script type="math/tex; mode=display">f_{u}=(1-f_u)\cdot f_v\cdot e[u,v]</script><p>然后考虑如何将贡献 $down$ 下去。那么考虑设 $h_u$ 表示只考虑祖先的贡献时，$u$ 亮的概率。不难知道 $g_u=f_u+h_u$ 。那么考虑 $h$ 怎么求。发现一般这种 down 形态的 dp 都要减去当前子树的贡献。所以对于 $h_v$ 而言，有如下转移：</p><script type="math/tex; mode=display">h_v=\dfrac{(g_u-f_v\cdot e[u,v])\cdot (1-f_v)\cdot e[u,v]}{1-f_v\cdot e[u,v]}</script><p>考虑分子上是父亲传到儿子的概率，$h_v$ 是从父亲处导电的概率，那么可以知道如果想要父亲传到儿子，必须要使之互斥，即需要让 $h_v\times \Pr(\texttt{不通过儿子传到父亲})=\Pr(\texttt{父亲传到儿子})$ ，这是分母的来由。</p><p>考虑如果本身不能「不通过儿子传给父亲」，那么父亲的就不能传给儿子，此时 $h_v=0$，需要特判。</p><p>好绕啊好绕啊… </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = base[u] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; </span><br><span class="line">dfs0(to(k), u), f[u][<span class="number">0</span>] += (<span class="number">1</span> - f[u][<span class="number">0</span>]) * val(k) * f[to(k)][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">double</span> p = f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">1</span> - p) &lt;= eps) &#123;dfs1(to(k), u) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line"><span class="keyword">double</span> q = f[u][<span class="number">0</span>] + f[u][<span class="number">1</span>] - f[to(k)][<span class="number">0</span>] * val(k) ; </span><br><span class="line">f[to(k)][<span class="number">1</span>] = (<span class="number">1</span> - f[to(k)][<span class="number">0</span>]) * q / (<span class="number">1</span> - p) * val(k) ; </span><br><span class="line">dfs1(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">double</span> o ; <span class="keyword">int</span> i, u, v, w ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), o = w * <span class="number">0.01</span>, add(u, v, o) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w), base[i] = w * <span class="number">0.01</span> ;</span><br><span class="line">dfs0(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">ans += (f[i][<span class="number">0</span>] + f[i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转移时有后效性的题目"><a href="#转移时有后效性的题目" class="headerlink" title="转移时有后效性的题目"></a>转移时有后效性的题目</h1><h2 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="[HNOI2013]游走"></a>[HNOI2013]游走</h2><blockquote><p>一个无向连通图，顶点从 $1$ 编号到 $n$ ，边从 $1$ 编号到 $m$。</p><p>小Z在该图上进行随机游走，初始时小Z在 $1$ 号顶点，每一步小Z以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。</p><p>现在，请你对这 $m$ 条边进行编号，使得小Z获得的总分的期望值最小。</p><p>$n\leq 500,1\leq m\leq 1.2\times 10^5$ 。</p></blockquote><p>首先可以贪心地知道期望走过次数越多的边，自然希望他编号越小。</p><p>考虑由点推边。即设 $f_i$ 表示 $i$ 这个点经过的次数。那么可以知道有</p><script type="math/tex; mode=display">f_{i}=[i=1]+\sum_{(i,j)\in\mathbb E} f_j\times \dfrac{1}{\deg_j}</script><p>于是可以高斯消元求出每个 $f_i$ 。之后考虑一条边 $(u,v)$ 的期望经过次数就是</p><script type="math/tex; mode=display">\dfrac{f_u}{\deg_u}+\dfrac{f_v}{\deg_v}</script><p>注意以上所有的操作都不包括 $n$ 号点，因为到 $n$ 号点就不会再走了。</p><h2 id="CF24D-Broken-Robot"><a href="#CF24D-Broken-Robot" class="headerlink" title="CF24D Broken Robot"></a>CF24D Broken Robot</h2><blockquote><p>$n$ 行 $m$ 列的矩阵，一开始在点 $(x,y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。</p><p>注意，$(1,1)$ 是木板的左上角，$(n,m)$ 是木板的右下角。</p></blockquote><p>首先是倒推的思想，从 $(x,y)$ 走到最后一行状态的过程不好描述，可以转化为从最后一行走到 $(x,y)$ 。</p><p>考虑转移</p><script type="math/tex; mode=display">f_{i,j}=\begin{cases}\frac{1}{3}(f_{i+1,j}+f_{i,j+1}+f_{i,j})&\left(j=1\right)\\\frac{1}{3}(f_{i+1,j}+f_{i,j-1}+f_{i,j})&\left(j=m\right)\\\frac{1}{4}(f_{i+1,j}+f_{i,j-1}+f_{i,j+1}+f_{i,j})&\mathrm{Otherwise}\end{cases}</script><p>发现具有后效性，于是考虑消元。个人认为至少有如下几档部分分：</p><h3 id="40-pts-max-n-m-leq-25"><a href="#40-pts-max-n-m-leq-25" class="headerlink" title="40 pts $\max\{n,m\}\leq 25$"></a>40 pts $\max\{n,m\}\leq 25$</h3><p>这个就可以把 $n \times m$ 个元素放在一起消元，复杂度是 $(n^3\cdot m^3)$ 的。</p><h3 id="70-pts-max-n-m-leq-100"><a href="#70-pts-max-n-m-leq-100" class="headerlink" title="70 pts $\max\{n,m\}\leq 100$"></a>70 pts $\max\{n,m\}\leq 100$</h3><p>发现每一行和其他行之间的关系只有 $f_{i+1,j}$ ，那么不难想到倒序枚举每一行，对这一行内的元素进行消元，此时 $f_{i+1}$ 的所有元素均已知。复杂度是 $O(n\cdot m^3)$ 的。</p><h3 id="85-pts-max-n-m-leq-500"><a href="#85-pts-max-n-m-leq-500" class="headerlink" title="85 pts $\max\{n,m\}\leq 500$"></a>85 pts $\max\{n,m\}\leq 500$</h3><p>发现对于要消元的矩阵，对于每一行只有 $i,i-1,i+1,n+1$ 四个列的位置是有元素的，所以每次对于一行而言，可以只进行 $O(1)$ 次消元。这样就是 $O(n\cdot m^2)$ 的了。 </p><h3 id="100-pts-max-n-m-leq-3000"><a href="#100-pts-max-n-m-leq-3000" class="headerlink" title="100 pts $\max\{n,m\}\leq 3000$"></a>100 pts $\max\{n,m\}\leq 3000$</h3><p>发现不止横向有性质，纵向同样有性质。发现对于每一列，至多会有 $3$ 个元素。这样纵向也是 $O(1)$ 的了。于是总复杂度 $O(n\cdot m)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i][i + <span class="number">1</span>] /= f[i][i] ;</span><br><span class="line">        f[i][n + <span class="number">1</span>] /= f[i][i] ; f[i][i] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][i + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) f[i + <span class="number">1</span>][n + <span class="number">1</span>] -= f[i + <span class="number">1</span>][i] * f[i][n + <span class="number">1</span>] ;</span><br><span class="line">        f[i + <span class="number">1</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[n] = f[n][n + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        ans[i] = f[i][n + <span class="number">1</span>], ans[i] -= ans[i + <span class="number">1</span>] * f[i][i + <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= x ; -- i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span> &amp;&amp; j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">2.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">1.0</span> / <span class="number">2.0</span> ; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">                f[j][j] = <span class="number">2.0</span> / <span class="number">3.0</span>, f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">3.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[j][j] = <span class="number">3.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j - <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][j + <span class="number">1</span>] = - <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">                f[j][m + <span class="number">1</span>] = <span class="number">1.0</span> + ans[j] * <span class="number">1.0</span> / <span class="number">4.0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gauss(m) ; <span class="comment">//debug(ans, 1, m) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            f[j][j] = f[j][j - <span class="number">1</span>] = f[j][j + <span class="number">1</span>] = f[j][m + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, ans[y]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="[HNOI2011]XOR和路径"></a>[HNOI2011]XOR和路径</h2><blockquote><p>给定一个无向连通图，其节点编号为 $1$ 到 $N$，其边的权值为非负整数。试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得该路径上经过的边的权值的 “XOR和”最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算“XOR 和”时也要被重复计算相应多的次数。</p><p>直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 $1$ 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 $N$ 号节点为止，便得到一条从 $1$ 号节点到 $N$ 号节点的路径。显然得到每条这样的路径的概率是不同的并且每条这样的路径的“XOR 和”也不一样。现在请你求出该算法得到的路径的“XOR 和”的期望值。</p><p>$2≤N≤100,1\leq M≤10000$ 。</p></blockquote><p><del>那必然是要先猜一波期望对xor运算也具有线性性，但实际上并没有。</del></p><p>感觉可能是需要记住的一个 $trick$ ，位运算时位与位之间是独立的，所以可以分别对每一位计算。那么对每一位计算就可以直接按 $0/1$ 分类讨论来转移。</p><p>具体的，还是考虑倒推。个人感觉这是因为最初的决策可能延伸出许多不同的决策，导致很难对这个过程进行统计。但是如果倒推的话，就相当于从一个已知结果出发走向另一端的已知开始。所以会相对容易一点？</p><p>于是考虑设状态 $f_x$ 表示当前二进制位下， 从 $x$ 走到 $n$ 这一位的期望，也就可以等价于这一位为 $1$ 的概率。于是有转移</p><script type="math/tex; mode=display">f_{u}=\frac{1}{\deg_u}\left(\sum_{(u,v,w)\in \mathbf{E},w=0} f_v+\sum_{(u,v,w)\in \mathbf{E},w=1}(1-f_v)\right)</script><p>然后就可以消元了，复杂度 $O(n^3\log V)$ 。注意自环只统计一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxv ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"></span><br><span class="line">db res ;</span><br><span class="line">db ans[N] ;</span><br><span class="line">db f[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        w = qr() ; chkmax(maxv, w) ;</span><br><span class="line">        add_e(u, v, w) ; <span class="keyword">if</span> (u != v) add_e(v, u, w) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug(deg, 1, n) ; cout &lt;&lt; cnt &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span> ; v &lt;= maxv ; v &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = <span class="number">0.0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">            f[i][i] = deg[i] ; <span class="keyword">int</span> xs = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = head[i] ; k ; k = next(k))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(val(k) &amp; v)) f[i][to(k)] -= <span class="number">1.0</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][to(k)] += <span class="number">1.0</span>, xs += <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][n + <span class="number">1</span>] = <span class="number">1.0</span> * xs ;</span><br><span class="line">        &#125;</span><br><span class="line">        f[n][n] = <span class="number">1.0</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= n + 1 ; ++ i)</span></span><br><span class="line"><span class="comment">            for (int j = 1 ; j &lt;= n + 1 ; ++ j)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n + 1] ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        gauss(n) ; res += ans[<span class="number">1</span>] * v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡做八做了一点简单的期望题，算是练练手感吧。&lt;/p&gt;
&lt;p&gt;一共是 $15$ 道题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学/高斯消元" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="技巧/按位操作" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【探究向】用命分析概率型生成函数(PGF)</title>
    <link href="https://www.orchidany.cn/2020/05/03/%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://www.orchidany.cn/2020/05/03/概率生成函数入门/</id>
    <published>2020-05-03T10:48:19.000Z</published>
    <updated>2020-05-07T11:00:39.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是最近的研究成果吧？</p><p>「学不会的生成函数」+「学不会的概率论」= <code>?</code></p><p>算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。</p><a id="more"></a><h1 id="概率型生成函数"><a href="#概率型生成函数" class="headerlink" title="概率型生成函数"></a>概率型生成函数</h1><p>虽然概率型生成函数本质上就是普通型生成函数，只不过多了一个对应关系。</p><p>即，如果对于某个离散型随机变量 $X\in\mathbb Z$ ，存在数列 $\{a_n\}$ 满足 $\Pr(X=i)=a_i$ ，那么离散型随机变量 $X$ 的 <strong>概率型生成函数$(\mathbf{PGF})$</strong> 为</p><script type="math/tex; mode=display">\mathscr{F}(z)=\sum_{i=0}^{\infty} \Pr(X=i) z^i</script><p>那么首先有</p><script type="math/tex; mode=display">\mathscr{F}(1)=\sum_{i=0}^{\infty}[z^i]\mathscr{F}(z)=1</script><p>同时根据期望的定义</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}i\Pr(X=i)</script><p>可以知道期望就是 $\mathscr{F}$ 的一阶导数系数和，即</p><script type="math/tex; mode=display">E(X)=\sum_{i=0}^{\infty}[z^i]\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)</script><p>那么同时根据方差的定义以及期望的线性性可以得到：</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E\left((X-E(X))^{2}\right)=E\left(X^{2}-2\cdot X \cdot E(X)+E(X)^{2}\right)=E\left(X^{2}\right)-E(X)^{2}</script><p>从而有 </p><script type="math/tex; mode=display">\mathsf{Var}(X)=\sum_{i=0}^{\infty}[z^i]\left(\dfrac{\mathrm{d^2}}{\mathrm{d} z^2}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)-\left(\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)\right)^2\right)</script><p>是因为</p><script type="math/tex; mode=display">E(X^2)=\sum_{i=0}^{\infty}i^2\cdot \Pr(X=i)=\sum_{i=0}^{\infty}i\cdot (i-1)\cdot \Pr(X=i)+\sum_{i=0}^{\infty}i\cdot \Pr(X=i)</script><p>可以知道前面一项是二阶导，后面一项是一阶导。</p><p>然后…然后就可以做题了(倒)。</p><h1 id="2013-Multi-University-Training-Contest-5-Dice"><a href="#2013-Multi-University-Training-Contest-5-Dice" class="headerlink" title="[2013 Multi-University Training Contest 5] Dice"></a>[2013 Multi-University Training Contest 5] Dice</h1><blockquote><p>一个 $m$ 面的公平骰子，求:</p><p>1、最后 $n$ 次结果相同就结束的期望次数。</p><p>2、求最后 $n$ 次结果全不同就结束的期望次数。</p><p>保证 $n,m \leq 10^6$，且对第二问 $n \leq m$ 。</p></blockquote><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>即用 dp 来做。</p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>设 $f_i$ 表示最后 $i$ 次相同，期望还要多少次结束。那么 $f_n=0$ ，求的就是 $f_0$ 。那么可以知道有转移</p><script type="math/tex; mode=display">f_{i}=\dfrac{1}{m}f_{i+1}+\frac{m-1}{m}f_1+1</script><p>发现并不好直接做，考虑差分得到</p><script type="math/tex; mode=display">f_{i}-f_{i+1}=(m-1)f_i-(m-1)f_{1}-m=m(\frac{m-1}{m}f_i-\frac{m-1}{m}f_1-1)=m(f_{i-1}-f_i)</script><p>并且由 $f_0=f_1+1$ 可以知道 $f_n-f_{n+1}=m^n$，于是最后答案就是 $1+\sum_{i=1}^{n-1}m^i$ 。</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p>设 $g_i$ 表示最后 $i$ 次均不相同，期望还要多少次结束。那么 $g_n=0$，求 $g_0$ 。考虑</p><script type="math/tex; mode=display">g_i=\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^i g_j}+1</script><p>(注意加粗的部分，自己一开始因为不细心推挂了…)</p><p>那么还是差分</p><script type="math/tex; mode=display">\begin{aligned}g_{i-1}-g_i&=-\frac{i-1}{m}g_i+\frac{1}{m}\cdot \boldsymbol{\sum_{j=1}^{i-1} g_j}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}g_i-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)}{m^2}g_{i+1}-\left(\frac{i-1}{m^2}-\frac{m}{m^2}\right)\cdot\sum _{j=1}^ig_j-\frac{m}{m^2}\left(\frac{m-i}{m} g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^i g_j+1\right)-\frac{i-1}{m}+1\\&=-\frac{(i-1)(m-i)+(m-i)}{m^2}g_{i+1}+\left(\frac{m-i+1-1}{m^2}\right)\cdot\sum _{j=1}^ig_j+\frac{m-(i-1)-1}{m}\\&=-\frac{i\cdot (m-i)}{m^2}g_{i+1}+\frac{m-i}{m^2}\cdot\sum _{j=1}^ig_j+\frac{m-i}{m}\\&=\left(\frac{m-i}{m}\right)\left(-\frac{i}{m}g_{i+1}+\frac{1}{m}\cdot \sum_{j=1}^{i} g_j+1\right)\\&=\frac{m-i}{m}(g_{i}-g_{i+1})\end{aligned}</script><p><del>不会告诉你中途推岔匹了好几次</del></p><p>然后就类似上面那个 case 了，也是可以线性做的。</p><h2 id="PGF-做法"><a href="#PGF-做法" class="headerlink" title="PGF 做法"></a>PGF 做法</h2><h3 id="第一问-1"><a href="#第一问-1" class="headerlink" title="第一问"></a>第一问</h3><p>即考虑套路设 PGF，设 $f_i$ 表示恰好在扔第 $i$ 次结束时的概率，$g_i$ 表示扔了第 $i$ 次仍没结束的概率。考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \qquad(1)\\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \qquad(2)\end{aligned}</script><p>第一个方程可以看做是废话，就是多扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。</p><p>第二个方程的意思是在现在的串后面接一个合法，也就是 $n$ 位都相同的串，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个就结束的情况。个人的理解是，为了保证等式两边是在讨论相同的情况，所以仍然需要把后面的 $n-i$ 次操作算进来，可以知道这样是不影响前面恰好取完了的那些情况。于是根据这个东西依旧可以解出来和做法一相同的结果来。</p><h3 id="第二问-1"><a href="#第二问-1" class="headerlink" title="第二问"></a>第二问</h3><p>定义依旧不变。考虑方程大概是</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1</script><p>和 </p><script type="math/tex; mode=display">\tag{2}\mathscr{G}(z)\cdot \left(\frac{1}{m}z\right)^n\cdot \dfrac{m!}{(n-m)!}=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i} \cdot \dfrac{(m-i)!}{(m-i-(n-i))!}</script><p>然后就暴力解就好了。</p><h1 id="CTSC2006-歌唱王国"><a href="#CTSC2006-歌唱王国" class="headerlink" title="[CTSC2006] 歌唱王国"></a>[CTSC2006] 歌唱王国</h1><blockquote><p>简化版题面：</p><p>给定一个长为 $n$ 的由 $1\sim m$ 组成的序列 $A$，同时每次掷一颗均匀的 $m$ 面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串和 $A$ 相同。</p><p>$1\leq n,m\leq 10^6$ 。</p></blockquote><p>考虑和上题差不多的 PGF 做法：</p><script type="math/tex; mode=display">\begin{aligned}\mathscr F(z)+\mathscr G(z)&=z\cdot \mathscr G(z)+1 \\\mathscr G(z)\cdot \left(\frac{1}{m}z\right)^n&=\sum_{i=1}^n \mathscr{F}(z)\cdot \left(\frac{1}{m}z\right)^{n-i}\cdot \mathscr{\zeta}(i)\end{aligned}</script><p>其中 $\zeta(i)=\texttt{「 A[1…i] 是否是 A[1…n] 的 Border」}$ 。 还是比较显然的，因为如果是拼到第 $i$ 位就可以停止，那么 $A[1…i]$ 必然是个 $\sf border$ 。</p><p>最后可以直接推出来</p><script type="math/tex; mode=display">\dfrac{\mathrm d}{\mathrm{d}z}\mathscr{F}'(1)=\sum_{i=1}^n \zeta(i)\cdot m^{i}</script><h1 id="SDOI2017-硬币游戏"><a href="#SDOI2017-硬币游戏" class="headerlink" title="[SDOI2017] 硬币游戏"></a>[SDOI2017] 硬币游戏</h1><blockquote><p>给定 $n$ 个长为 $m$ 的由 $0/1$ 组成的序列 $A_i$，同时每次掷一颗均匀的双面骰子，求期望掷多少次骰子才可以使得序列中存在一个连续的子串在 $A_1\sim A_n$ 中出现。</p><p>$n,m\leq 300$.</p></blockquote><p>考虑串与串之间可以来回匹配，于是对每个串都定义一个 $\mathscr{F}_i(z)$ 表示首次出现的是第 $i$ 个串，且当前随机长度为 $j$ 的概率，然后单独定义一个 $\mathscr{G}(z)$ 表示游戏结束，那么有</p><script type="math/tex; mode=display">\sum_{i=1}^n\mathscr{F}_i(z)+\mathscr{G}(z)=\mathscr{G}(z)\cdot z+1</script><p>同时定义 $match(i,j)_k=[~A_i[1…k]=A_{j}[k…m]~]$ ，那么有对于每个 $i$ 的一组方程枚举在最后拼上一个什么东西：</p><script type="math/tex; mode=display">\mathscr{G}(z)\cdot \Pr(A_i[1...n])\cdot x^m=\sum_{j=1}^n \mathscr{F}_j(z)\sum_{k=1}^m match(i,j)_k\cdot \Pr(A_i[k+1...m])\cdot x^{m-k}</script><p>不难知道意思是 $A_j$ 和 $A_i$ 可以放在一起匹配，枚举 $i$ 某个同时是 $A_j$ 后缀的前缀进行配对。</p><p>那么考虑要求的就是 $\mathscr{F}_1(1),\mathscr{F}_2(1),\mathscr{F}_3(1),\cdots$ 。发现可以由方程 $(2)$ 得到 $n$ 个关系，同时因为并没有要求期望所以 $(1)$ 式没有任何用处。但是可以发现，根据概率的规范性可以得到</p><script type="math/tex; mode=display">\sum \mathscr{F}_i(1)=1</script><p>于是就有 $n+1$ 组关系，同时有包含 $\mathscr{G}(1)$ 在内的 $n+1$ 个未知元，就可以愉快地高消了。</p><h1 id="ZJOI2013-抛硬币"><a href="#ZJOI2013-抛硬币" class="headerlink" title="[ZJOI2013] 抛硬币"></a>[ZJOI2013] 抛硬币</h1><blockquote><p>有一枚硬币，抛出正面 <code>H</code> 的概率为 $\frac{a}{b}$，抛出反面 <code>T</code> 的概率为 $1-\frac{a}{b}$。现在 T 小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为 <code>H</code>，反面记为 <code>T</code>，于是她得到了一个抛硬币序列 <code>HTHHT</code>…。</p><p>她突然想到一个问题：在抛出正面和反面概率都是 $\frac{1}{2}$ 的情况下，要使得抛出的序列出现只包含 <code>H</code> 和 <code>T</code> 目标序列，期望要抛多少次。</p><p>这么简单的题目她当然是一眼秒。于是她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为 <code>HT</code> 时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。</p><p>简化版题面：</p><blockquote><p>给出一个两面的均匀骰子，正面和反面的概率分别是 $\frac{a}{b}$ 和 $1-\frac{a}{b}$ 。并给出一个长度为 $n$ 的 $01$ 序列 $A$ 。</p><p>同时有一个一开始为空的序列。每次掷骰子，如果是反面，就在当前序列末尾写一个 $1$ ，否则写一个 $0$ ，如果发现此时序列中恰好有一个连续子串是 $A$ 则停止。求期望多少次才会停止操作。</p></blockquote><p>我认为合理的数据范围：$1\leq n\leq 10^6$，概率对 $998244353$ 取模。</p><p>ZJOI2013 的数据范围：$1\leq n\leq 10^3$ 输出确切概率并保留<strong>既约分数形式</strong> 。</p></blockquote><p>全网似乎没人用 PGF 做，这就很爽。有种中了头彩的感觉…但是其实写这题的时候我是十分崩溃的…</p><p>从 5.3 晚上 8:30 左右一直写，写到 10:00 PM 左右发现有地方写错了，但是由于要回宿舍了所以被迫终止。第二天早上来了又开始写，写着写着发现还要写一波高精 gcd 和高精除，于是就把早上的课给翘了。写完了发现慢的一匹，只能有 $50pts$，然后决定去学一学压位。发现压位也不难，然后决定压 $4$ 位；写着写着又发现压 $8$ 位也不是不可以，然后改来改去改成了 $90pts$ ，发现最大的点比时限慢一倍…于是就去扒自己的 FFT 板子，拼拼凑凑之后发现由于可能会爆精度所以不能压 8 位，只能压 $4$ 位，结果更慢了。然后决定改成 NTT，结果发现 NTT 要对神必数取模导致压两位可能都有问题，然后就自闭了，决定放弃多项式科技去优化自己的压位高精。发现有些地方似乎合并同类项之后会很快，原来乘 $O(n)$ 次改完只需要乘 $O(1)$ 次，然后左改右改终于卡过了洛谷上的1s时限…</p><p>期间一度怀疑自己算法的正确性，但是想了想也没什么更靠谱的做法了，只不过这个写法是 $L^2\log V$ 的，$L^2$ 大概也就是 $10^6$ 的范围，只是这个 $\log V$ …他确实有点毒瘤。因为最大可以到 $V=10^{16000}$ 左右，所以高精度除法二分起来就十分爆炸…大概极限是 $5\cdot 10^9$ 的运算量。不过…好在最后是过了，虽然有点卡时。</p><p>算了一下似乎 FFT 的复杂度更对一点，$L\log L\log V$ 大概是 $10^7\sim 10^8$ 左右的运算量。但是自己的 FFT 水平实在太差…于是就还是多项式乘法了。可能什么时候心情好就会补一下这个锅？</p><p>以下是正文，就直接把发在谷上的题解糊上来了：</p><hr><p>考虑设 $f_i$ 表示扔了 $i$ 次骰子之后恰好停止的概率，$g_i$ 表示扔了 $i$ 次骰子之后仍未结束的概率。同时考虑对这两个东西建立 PGF，分别为 $\mathscr{F,G}$， 那么有方程：</p><script type="math/tex; mode=display">\tag{1}\mathscr F(z)+\mathscr G(z)=z\cdot \mathscr G(z)+1 \\</script><p>其意义是，扔了一次之后，要么结束要么不结束，$\mathscr G$ 右移一位可以看作是 $g_{i-1}$ 。同时还有</p><script type="math/tex; mode=display">\tag{2}\mathscr G(z)\cdot \Pr(A[1...n])=\sum_{i=1}^n \mathscr{F}(z)\cdot \Pr(A[i+1...n])\cdot \zeta(i)</script><p>其意义是，考虑在现在的串后面接一个可以让这个过程直接结束的串，也就是接一个 $A$，$\Pr(s[1…n])$ 表示串 $s$ 出现的概率，那么可以知道等式左边的含义是「一定可以结束」；等式右边则是考虑可能会存在没有加满 $n$ 个、只加了前 $i$ 个字符就结束的情况，多乘一个 $\Pr(A[i+1…n])$ 本身是没有意义的，只是为了构造出等式，可以理解为两边都钦定扔了 $n$ 次——发现这种情况要是想要出现，就必须满足 $A[1…i]$ 是 $A$ 的一个 $\sf border$ ，所以 $\zeta(i)=[A[1…i]\in\mathbf{Border}]$ .</p><p>之后考虑如何消元。首先对 $(1)$ 式求导可以得到</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)+\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{G}(z)\cdot z+\mathscr{G}(z)\cdot 1</script><p>也就是可以知道 </p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(z)=\mathscr{G}(z)</script><p>同时对于 $(2)$ 式，将 $z=1$ 代入可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)\cdot \Pr(A[1...n]) =\sum_{i=1}^n\mathscr{F}(1)\cdot \zeta(i)\cdot \Pr(A[i+1...n])</script><p>因为 $\mathscr{F}(1)=1$ ，所以可以得到</p><script type="math/tex; mode=display">\mathscr{G}(1)=\dfrac{\sum_{i=1}^n \zeta(i)\cdot \Pr(A[i+1...n])}{\Pr(A[1...n])}</script><p>然后根据</p><script type="math/tex; mode=display">E(X)=\dfrac{\mathrm{d}}{\mathrm{d} z}\mathscr{F}(1)</script><p>发现这题就做完了。复杂度线性。</p><p>但是注意本题要求以既约分数的形式保留精确值。因为我好久好久没写过高精度了，于是就想借此机会封装一个模板。然后…然后就写了快 $7h+$。注意到由于要求既约分数，所以要写高精度gcd，写法可以借鉴 <code>[SDOI2009]Super GCD</code> ，同时还要写高精除高精，个人没有找到什么好方法，于是就写的二分，复杂度大概是 $L^2\log V$ 的样子。</p><p>然后复杂度似乎是 $n\cdot L^2\log V$ ，并不可以过，于是考虑剪枝+卡常：</p><p>0、…高精度压位是必要的吧？这边我选择压 $8$ 位，因为发现 $10^3\cdot 10^{16}$ 恰好卡到了 <code>long long</code> 的上界。</p><p>1、发现二分时左右边界可以缩短很多，即 $l,r$ 都至多和 $V / \gcd$ 的长度相差 $1$ ，所以可以用这个来确定边界。亲测可以快大概 $6$ 倍左右(但是还是 T，极限数据大概要跑 $4s+$) 。</p><p>2、发现计算答案时，展开后存在很多公因式。于是可以提取公因式之后再计算。亲测可以快 $4$ 倍左右。</p><p>然后…大概就过了。中间写了很久的原因在于，我本来想尝试 FFT，后来发现自己没有封装好的 FFT…囧…写了半天发现自己 FFT 的常数还不如压位快…然后就没有然后了。</p><hr><p>以上都是无聊的套路题，还是下面的题比较有趣</p><h1 id="趣题-一个有趣的概率小问题-·-改"><a href="#趣题-一个有趣的概率小问题-·-改" class="headerlink" title="[趣题]一个有趣的概率小问题 · 改"></a>[趣题]一个有趣的概率小问题 · 改</h1><p>题目来源是<a href="http://roosephu.github.io/2017/12/31/condexp/" target="_blank" rel="noopener">这里</a>，与本题略有出入：</p><blockquote><p>一个 $n$ 面的骰子，每一面标号 $1$ 到 $n$ 。有个初始为 $0$ 的计数器，每次扔骰子，按顺序执行以下过程：</p><p>1、扔出了奇数：那么计数器清零。</p><p>2、扔出了偶数：计数器加 $1$ 。</p><p>3、扔出了 $n$：游戏结束。</p><p>问结束时计数器上显示的数值的期望。 </p><p>保证 $n$ 是偶数。</p></blockquote><p>考虑如果按照套路设 $f_i$ 表示扔到 $i$ 结束的概率，$g_i$ 表示扔到 $i$ 没有结束的概率，会存在问题。因为根据题设，会重复到达某个权值 $v$ 很多很多次，所以设概率是不妥的。</p><p>考虑 PGF 的一个翻版，对着期望建立生成函数(你可以叫他 EGF【雾】，虽然本质上就是对 PGF 求了一个一阶导数)：设 $f_i$ 表示扔到 $i$ 结束的<strong>期望次数</strong>，$g_i$ 表示扔到 $i$ 没有结束的<strong>期望次数</strong>，对这两个东西建立普通型生成函数可以得到</p><script type="math/tex; mode=display">\mathscr{F}(z)+\mathscr{G}(z)=\left(\mathscr{G}(z)\cdot \dfrac{z}{2}+1\right)+\frac{1}{2}\cdot \mathscr{G}(1)</script><p>其中左边的意思当然是，要么结束要么不结束，换个意思就是「到达 $i$ 的期望总次数」，右边第一项是有 $\dfrac{1}{2}$ 的概率从 $z$ 转移过来，有 $\dfrac{1}{2}$ 的概率到达 $0$，那么此时有等式「原来到达所有 $i$ 的期望次数」=「现在这一步到达 $0$ 的期望次数」。</p><p>同时也会有</p><script type="math/tex; mode=display">\mathscr{F}(z)=\frac{x}{n}\cdot \mathscr{G}(z)</script><p>即恰好扔到 $n$ 的转移，根据题设应该先 $+1$ ，再结束。</p><p>感觉还是比前面的题有趣的？</p><h1 id="来源保密的比赛-1A-Probability"><a href="#来源保密的比赛-1A-Probability" class="headerlink" title="[来源保密的比赛 1A] Probability"></a>[来源保密的比赛 1A] Probability</h1><blockquote><p>有一个随机变量 $z$, 初始 $z=0$.</p><p>执行 $n$ 次操作: 每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:=z+t$ 。</p><p>求 $\min(z,x)$ 的期望. 答案模 $998244353$. </p><p>$k\leq 100,n\leq 10^9,x\leq \min\{10^7,\frac{5\times 10^7}{k}\}$ 。</p></blockquote><p>设选择整数的概率型生成函数为 $P(y)=\sum_{i=0}^kp_i$ ，那么取了 $n$ 次之后的概率型生成函数就是 $Q(y)=P^n(y)$ 。</p><p>那么不难知道答案为</p><script type="math/tex; mode=display">\sum_{i=0}^{n\times k} [y^i]Q\cdot \min(x,i)=\sum_{i=0}^{x-1} [y^i]Q\cdot i + \left(1-\sum_{i=0}^{x-1} [y^i]Q\right)\cdot x</script><p>呃…虽然没学过 PGF 到底怎么化，但是概率上求 $z$ 补集就是 $1-z$ 还是比较 xxs 的结论吧…</p><p>然后现在问题就集中在怎么求 $P^n(y)$ 的前 $k$ 项了。发现可以暴力多项式快速幂，以获得 $40\sim 60$ 左右的成绩。</p><p>然后是神奇的多项式技巧…大概是考虑对于 $P^{n+1}(y)$ 求导有两种方式：</p><script type="math/tex; mode=display">\left(P^{n+1}(y)\right)^{\prime}=(n+1) P^{n}(y) P^{\prime}(y)\\\left(P^{n+1}(y)\right)^{\prime}=\left(P^{n}(y)\right)^{\prime} P(y)+P^{n}(y) P^{\prime}(y)</script><p>第一个就是链式法则，第二个则是拆出一个 $P(y)$ 来再用求导的乘法运算法则。</p><p>考虑联立之后</p><script type="math/tex; mode=display">nP^n(y)(P(y))'=(P^n(y))'P(y)</script><p>然后考虑现在的问题是，已知了 $P^n(y)$ 的前几项系数，求出后面的系数。考虑一个这样的思路：每次先求出 $(P^n(y))’$ 的第 $d$ 项，然后积分出 $P^n(y)$ 的第 $d+1$ 项。发现每个 $[y^d]P^n(y)$ 只会对 $y^d\sim y^{d+k}$ 这些产生贡献，所以考虑枚举到一个 $d$ 的时候向后刷表；考虑这样求出的是 $(P^n(y))’P(y)$ ，直接模拟多项式除法即可得到 $(P^n(y))’$ ，这样做也是单次 $O(k)$ 的。</p><p>对于多项式除法这部分，可以考虑对于每个 $[y^d] (P^n(y))’P(y)$ 都是这么计算得到的：</p><script type="math/tex; mode=display">\sum_{p=0}^k [y^p] P(y)\times [y^{d-p}] (P^n(y))'</script><p>然后就减去所有的 $p&gt;0$ 的那些结果，最后乘上一个 $[x^0]P(y)$ 的逆元即可。</p><p>顺便复习一下线性求逆元：</p><p>考虑模数是 $m$，那么设 $m=p\cdot x+r$，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}p\cdot x+r&\equiv 0\pmod m\\p\cdot r ^{-1}+x^{-1}&\equiv 0 \pmod m\\x^{-1}&\equiv -\lfloor\frac{m}{x}\rfloor\cdot (m\bmod x)^{-1}\pmod m\end{aligned}</script><h1 id="来源保密的比赛-Barrel"><a href="#来源保密的比赛-Barrel" class="headerlink" title="[来源保密的比赛 ?] Barrel"></a>[来源保密的比赛 ?] Barrel</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel2.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Barrel3.png" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="Parrel4.png" alt=""></p><p>读题让人十分迷惑…注意这题里面 $c_{i,j}$ 是给定的，只不过因为样例里面恰好是没有这部分输入而已……</p><hr><p>光是读题就会让人十分迷惑的题…</p><p>因为与符号冲突了，于是决定把题面中的 $z$ 改成 $c$ ，$z$ 维持原来的形式幂级数定义不变。</p><p>考虑深刻地挖掘题目性质：对于每个桶，所有年份体积的酒的体积总和是 $1$ 。所以如果设第 $i$ 个桶里年份为 $j$ 的酒体积为 $V_{i,j}$ ，可以发现本题要求</p><blockquote><p>第 $n$ 个桶内取一微元酒的单价期望/方差，</p></blockquote><p>实际上就是在求</p><blockquote><p><strong>第 $n$ 个桶有 $V_{n,j}$ 的概率变成第 $j$ 年的酒，求第 $n$ 桶酒的期望价值。</strong></p></blockquote><p>考虑先算这个概率。</p><p>考虑一个突破点，发现每次给出去的一定是均匀的，所以不需要考虑给出去的如何分配。换言之如果这一回合给进来的总体积(不看年份)是 $V$ ，那么给出去的必然是 $1-V$ 并且是均匀的。</p><p>根据上一点，理应想到，$1$ 号酒桶就是突破口，因为 $1$ 号桶进来的只会是 $f$ 。于是考虑设每个桶内每一轮新倒入的体积为 $m_i$，那么会有</p><script type="math/tex; mode=display">m_i=\begin{cases}f&\mathrm{if}~(i=1)\\\sum_{j=1}^{i-1}c_{i,j}&\mathrm{otherwise}\end{cases}</script><p>于是考虑设 $f_{i,j}$ 表示第 $i$ 个桶内变成第 $j$ 年酒的概率，对每一个 $i$ 建立概率型生成函数 $\mathscr F_i(z)$ ，那么会有</p><script type="math/tex; mode=display">\mathscr F_{i}(z)=\mathscr F_{i}(z)\cdot z\cdot (1-m_i)+\sum_{j=1}^i m_j\mathscr{F}_j(z)</script><p>这个式子本质上模拟了取酒、倒酒这个过程。</p><p>考虑计算答案，根据上文可以知道</p><script type="math/tex; mode=display">\mathsf{Var}(X)=E(X^2)-E^2(X)</script><p>考虑后面一项本质上是</p><script type="math/tex; mode=display">\left(\sum_{i=0}^{+\infty} i\cdot c^i\cdot [z^i]\mathscr{F}_{n}(z)\right)^2</script><p>然后发现…如果将不定元 $z$ 赋值成 $c$ ，那么上式就是</p><script type="math/tex; mode=display">\left(c\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c)\right)^2</script><p>同理第一项就是</p><script type="math/tex; mode=display">\sum_{i=0}^{+\infty} i\cdot c^{2}\cdot [z^{2\cdot i}]\mathscr{F}_{n}(z^2)</script><p>等价于</p><script type="math/tex; mode=display">c^4\cdot \frac{\mathrm{d^2}}{\mathrm{d}z^2}\mathscr{F}_n(c^2)+c^2\cdot \frac{\mathrm{d}}{\mathrm{d}z}\mathscr{F}_n(c^2)</script><p>其中后半部分为了补全系数。</p><p>然后就可以直接做了，用一些求导技巧维护 </p><script type="math/tex; mode=display">\mathscr{F}_{i}(z), \mathscr{F}_{i}^{\prime}(z), \mathscr{F}_{i}\left(z^{2}\right), \mathscr{F}_{i}^{\prime}\left(z^{2}\right), \mathscr{F}_{i}^{\prime \prime}\left(z^{2}\right)</script><p>的值即可。复杂度 $n^2$ 。</p><h1 id="代码合集"><a href="#代码合集" class="headerlink" title="代码合集"></a>代码合集</h1><p>大概是上面的题写了代码就会丢到这里一份，看心情保留完整版还是局部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu4652 Dice</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line">db ans ;</span><br><span class="line">db res ;</span><br><span class="line"><span class="keyword">int</span> k, m, n ;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">expow</span><span class="params">(db x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    db ret = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1.0</span> * ret * x ;</span><br><span class="line">        x = <span class="number">1.0</span> * x * x ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; q)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; m &gt;&gt; n ; </span><br><span class="line">            <span class="keyword">if</span> (!k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) ans = <span class="number">1.0</span> * n ;</span><br><span class="line">                <span class="keyword">else</span> ans = (expow(m, n) - <span class="number">1.0</span>) / (<span class="number">1.0</span> * (m - <span class="number">1.0</span>)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="number">1</span> ; ans = <span class="number">0.0</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    res *= <span class="number">1.0</span> * m / (m - i + <span class="number">1</span>), ans += res ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CTSC2006 歌唱王国</span></span><br><span class="line"><span class="comment">//author: Orchidany</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * x % P ;</span><br><span class="line">        x = <span class="number">1l</span>l * x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m ; <span class="keyword">int</span> j = <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            base[i] = qr(), f[i] = <span class="number">0</span> ; f[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">            <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m) add(ans, expow(n, m), P), m = f[m] ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"000"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">"00"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; <span class="number">1000</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZJOI2013 抛硬币</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">const</span> ll Base = <span class="number">100000000</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_L</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x) ret ++, x /= <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Big_Num</span>&#123;</span></span><br><span class="line">    ll v[<span class="number">2051</span>] ;</span><br><span class="line">    <span class="keyword">bool</span> mk ; <span class="keyword">int</span> len, lent ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        len = <span class="number">0</span>, mk = <span class="number">0</span>, <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mk &amp;&amp; !(len &lt;= <span class="number">1</span> &amp;&amp; !v[<span class="number">1</span>])) <span class="built_in">putchar</span>(<span class="string">'-'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i == len)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">8</span> - get_L(v[i]) ; ++ j) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, v[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) mk = <span class="number">1</span>, x = -x ;</span><br><span class="line">        <span class="keyword">while</span> (x) v[++ len] = x % Base, x /= Base ;</span><br><span class="line">lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; reset() ;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">1</span>] == <span class="string">'-'</span>) ++ p, mk = <span class="number">1</span> ;</span><br><span class="line">        len = (L - p) / <span class="number">8</span> + (((L - p) % <span class="number">8</span>) &gt; <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L, k = len ; i &gt;= p + <span class="number">1</span> ; i -= <span class="number">8</span>, -- k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = min(i - p, <span class="number">8</span>) ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                v[k] = v[k] * <span class="number">10l</span>l + (x[i - j + <span class="number">1</span>] - <span class="string">'0'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">reverse(v + <span class="number">1</span>, v + len + <span class="number">1</span>) ;  lent = L - p ;</span><br><span class="line">    &#125;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> ~ (Big_Num A)&#123;</span><br><span class="line">        A.mk ^= <span class="number">1</span> ; <span class="keyword">return</span> A ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len != B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] != B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B) ;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il <span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.len &lt; B.len) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.len &gt; B.len) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (A.v[i] &gt; B.v[i]) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.v[i] &lt; B.v[i]) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ;</span><br><span class="line">        Big_Num p, q, t ; p = A, q = B ;</span><br><span class="line">        <span class="keyword">if</span> (p.lent &lt; q.lent) &#123; <span class="keyword">return</span> (~ (q - p)) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] - q.v[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &lt; <span class="number">0</span>) res.v[i + <span class="number">1</span>] --, res.v[i] += Base ;</span><br><span class="line">        res.len = p.len ; res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">20</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line"><span class="keyword">if</span> (res.v[res.len] &lt; <span class="number">0</span>)</span><br><span class="line">            res.mk = <span class="number">1</span>, res.len --, res.v[res.len] = Base - res.v[res.len] ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ;</span><br><span class="line">        res.reset() ; Big_Num p, q ;</span><br><span class="line">        <span class="keyword">if</span> (A.len &gt; B.len)</span><br><span class="line">            p = A, q = B ; <span class="keyword">else</span> p = B, q = A ;</span><br><span class="line">        <span class="keyword">if</span> (p.mk &amp;&amp; q.mk) res.mk = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.mk &amp;&amp; !q.mk) &#123; p.mk = <span class="number">0</span> ; <span class="keyword">return</span> (q - p) ; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.mk &amp;&amp; q.mk) &#123; q.mk = <span class="number">0</span> ; <span class="keyword">return</span>(p - q) ; &#125;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len ; ++ i) res.v[i] = p.v[i] + q.v[i] ;</span><br><span class="line">        res.len = p.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= p.len + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i] &gt;= Base)</span><br><span class="line">                res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Big_Num <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Big_Num &amp; A, <span class="keyword">const</span> Big_Num &amp; B)&#123;</span><br><span class="line">        Big_Num res ; res.reset() ; res.len = A.len + B.len ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.len ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= B.len ; ++ j)</span><br><span class="line">                res.v[i + j - <span class="number">1</span>] += A.v[i] * B.v[j] ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res.len + <span class="number">10</span> ; ++ i)</span><br><span class="line">            res.v[i + <span class="number">1</span>] += res.v[i] / Base, res.v[i] %= Base ;</span><br><span class="line">        res.v[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = res.len + <span class="number">10</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res.v[i]) &#123; res.len = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.len) res.len ++ ;</span><br><span class="line">        res.lent = (res.len - <span class="number">1</span>) * <span class="number">8</span> + get_L(res.v[res.len]) ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">div2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = len ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            v[i - <span class="number">1</span>] += (v[i] % <span class="number">2l</span>l) * Base, v[i] &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        v[<span class="number">0</span>] &gt;&gt;= <span class="number">1</span> ; <span class="keyword">while</span>(v[len] == <span class="number">0</span>) len -- ;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">mul2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) &#123;</span><br><span class="line">            v[i] = v[i] * <span class="number">2</span> + r, r = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= Base) &#123;</span><br><span class="line">                r = v[i] / Base, v[i] %= Base ;</span><br><span class="line">                <span class="keyword">if</span> (i == len) len ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lent = (len - <span class="number">1</span>) * <span class="number">8</span> + get_L(v[len]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Big_Num <span class="keyword">friend</span> <span class="title">gcd</span><span class="params">(Big_Num A, Big_Num B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt2 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!(A ^ B))&#123;</span><br><span class="line">            <span class="keyword">if</span> (A &lt; B) swap(A, B) ;</span><br><span class="line">            <span class="keyword">bool</span> a = A.v[<span class="number">1</span>] &amp; <span class="number">1</span>, b = B.v[<span class="number">1</span>] &amp; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!a &amp;&amp; !b) A.div2(), B.div2(), ++ cnt2 ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!b) B.div2() ; <span class="keyword">else</span> <span class="keyword">if</span> (!a) A.div2() ; <span class="keyword">else</span> A = A - B ;</span><br><span class="line">        &#125;</span><br><span class="line">        Big_Num tmp, pmt ;</span><br><span class="line">        tmp.set_v(<span class="number">2</span>), pmt.set_v(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (cnt2)&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt2 &amp; <span class="number">1</span>)</span><br><span class="line">pmt = pmt * tmp ;</span><br><span class="line">tmp = tmp * tmp ; cnt2 &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> (A = A * pmt) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Big_Num g, t ;</span><br><span class="line">Big_Num l, r, mid, ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span>&#123;</span></span><br><span class="line">    Big_Num fz, fm ;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.reset() ;</span><br><span class="line">        fm.reset() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Big_Num t = fz ; fz = fm, fm = t ;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function">il <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        g = gcd(fz, fm) ; r.reset() ;</span><br><span class="line"><span class="keyword">int</span> lnr = fz.len - g.len ; l.reset() ; l.len = lnr  ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fz) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fz = ans ; l.reset() ;</span><br><span class="line">lnr = fm.len - g.len ; l.reset() ; l.len = lnr ;</span><br><span class="line">l.v[l.len] = <span class="number">1</span> ; r.len = lnr + <span class="number">1</span> ; r.v[r.len] = <span class="number">90000000</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) ; mid.div2() ;</span><br><span class="line">            <span class="keyword">if</span> (mid * g &gt;= fm) ans = mid, r = mid - t ; <span class="keyword">else</span> l = mid + t ;</span><br><span class="line">        &#125;</span><br><span class="line">        fm = ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">out_put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fz.out_put() ;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'/'</span>) ;</span><br><span class="line">        fm.out_put() ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(T son, T mum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son), fm.set_v(mum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">set_v</span><span class="params">(<span class="keyword">char</span> *son, <span class="keyword">int</span> Lson, <span class="keyword">char</span> *mum, <span class="keyword">int</span> Lmum)</span></span>&#123;</span><br><span class="line">        fz.set_v(son, Lson) ; fm.set_v(mum, Lmum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> + (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!A.fz.len &amp;&amp; !A.fm.len) <span class="keyword">return</span> B ;</span><br><span class="line">        <span class="keyword">if</span> (!B.fz.len &amp;&amp; !B.fm.len) <span class="keyword">return</span> A ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz + B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> - (Frac A, Frac B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        <span class="keyword">if</span> (!(A.fm ^ B.fm))&#123;</span><br><span class="line">            Big_Num p = A.fm, q = B.fm, o, s, t ;</span><br><span class="line">            o = p * q ; s = q * A.fz ; t = p * B.fz ;</span><br><span class="line">            A.fm = o ; B.fm = o ; A.fz = s ; B.fz = t ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.fm = A.fm ; res.fz = A.fz - B.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ;</span><br><span class="line">        res.fz = A.fz * B.fz ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fz = A.fz * B.fz ; res.fm = A.fm ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    il Frac <span class="keyword">friend</span> <span class="keyword">operator</span> &amp; (<span class="keyword">const</span> Frac &amp; A, <span class="keyword">const</span> Frac &amp; B)&#123;</span><br><span class="line">        Frac res ; res.reset() ;</span><br><span class="line">        res.fm = A.fm * B.fm ; res.fz = A.fz ; <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r1, r2, r3, r0 ;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> A, B ;</span><br><span class="line">Frac res ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line">Frac Rp[N] ;</span><br><span class="line">Frac Pr[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">r0.set_v(<span class="number">1</span>, B) ;</span><br><span class="line">    r1.set_v(A, <span class="number">1</span>) ;</span><br><span class="line">Rp[<span class="number">0</span>].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">r2.set_v(B - A, <span class="number">1</span>) ;</span><br><span class="line">    m = <span class="built_in">strlen</span>(S + <span class="number">1</span>), Pr[m].set_v(<span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        base[i] = (<span class="keyword">bool</span>)(S[i] == <span class="string">'H'</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = m ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">        Pr[j - <span class="number">1</span>] = Pr[j] ^ (base[j] ? r1 : r2) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j) Rp[j] = Rp[j - <span class="number">1</span>] &amp; r0 ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; base[j + <span class="number">1</span>] != base[i]) j = f[j] ;</span><br><span class="line">        <span class="keyword">if</span> (base[j + <span class="number">1</span>] == base[i]) ++ j ; f[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    t.reset() ; t.set_v(<span class="number">1</span>) ;</span><br><span class="line">    r3 = Pr[<span class="number">0</span>] * Rp[m] ; r3.reverse() ; <span class="keyword">int</span> k = m ;</span><br><span class="line">    <span class="keyword">while</span> (m) res = res + Pr[m] * Rp[k - m] , m = f[m] ;</span><br><span class="line">res = res * r3 ; res.div() ; res.out_put() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[来源保密的比赛 1A] Probability</span></span><br><span class="line"><span class="comment">//author : Orchidany</span></span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> base ;</span><br><span class="line"><span class="keyword">int</span> F[M] ;</span><br><span class="line"><span class="keyword">int</span> f[M] ;</span><br><span class="line"><span class="keyword">int</span> G[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, x ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x ; inv[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = qr(), add(sum, <span class="number">1l</span>l * F[i]) ;</span><br><span class="line">    sum = expow(sum, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = <span class="number">1l</span>l * F[i] * sum % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = <span class="number">1l</span>l * n * F[i + <span class="number">1</span>] % P * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        inv[i] = (<span class="number">-1l</span>l * inv[P % i] * (P / i) % P) + P;</span><br><span class="line">    base = expow(F[<span class="number">0</span>], P - <span class="number">2</span>) ; G[<span class="number">0</span>] = expow(F[<span class="number">0</span>], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; i + j &lt; x &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            add(tmp[i + j], <span class="number">1l</span>l * f[j] * G[i] % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i - j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            dec(tmp[i], <span class="number">1l</span>l * g[i - j] * F[j] % P) ;</span><br><span class="line">        g[i] = <span class="number">1l</span>l * base * tmp[i] % P ;</span><br><span class="line">        G[i + <span class="number">1</span>] = <span class="number">1l</span>l * g[i] * inv[i + <span class="number">1</span>] % P ;</span><br><span class="line">        add(ans, <span class="number">1l</span>l * i * G[i] % P) ; dec(res, G[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="number">1</span> ; add(ans, <span class="number">1l</span>l * res * x % P) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[SDOI2017] 硬币游戏</span></span><br><span class="line"><span class="comment">//long double 确实很慢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Base = <span class="number">233</span> ;</span><br><span class="line"></span><br><span class="line">ldb val[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line">ldb ans[N] ;</span><br><span class="line">ldb f[N][N] ;</span><br><span class="line"><span class="keyword">char</span> s[N][N] ;</span><br><span class="line"><span class="keyword">int</span> _hs[N][N] ;</span><br><span class="line"><span class="keyword">bool</span> match[N][N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decn(_hs[t][r], <span class="number">1l</span>l * _hs[t][l - <span class="number">1</span>] * pos[r - l + <span class="number">1</span>] % P) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = i ; db t ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[r][i] &lt; f[j][i]) swap(f[r], f[j]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L + <span class="number">1</span> ; j &gt;= i ; -- j) f[r][j] /= f[r][i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = L + <span class="number">1</span> ; k &gt;= i ; -- k)</span><br><span class="line">                f[j][k] -= f[j][i] * f[r][k] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[L] = f[L][L + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        ans[i] = f[i][L + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= L ; ++ j)</span><br><span class="line">            ans[i] -= ans[j] * f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    pos[<span class="number">0</span>] = val[<span class="number">0</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        val[i] = val[i - <span class="number">1</span>] * <span class="number">2.0</span> ;</span><br><span class="line">        pos[i] = <span class="number">1l</span>l * pos[i - <span class="number">1</span>] * Base % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            _hs[i][j] = ((ll)_hs[i][j - <span class="number">1</span>] * Base % P + s[i][j]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                match[i][j][k] = (<span class="keyword">bool</span>)(ask(i, <span class="number">1</span>, k) == ask(j, m - k + <span class="number">1</span>, m)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                f[i][j] += (db)match[i][j][k] * val[k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[n + <span class="number">1</span>][i] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][n + <span class="number">1</span>] = - <span class="number">1.0</span> ; f[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1.0</span> ;</span><br><span class="line">    gauss(n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7Lf\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的…就先鸽着吧，感觉除了复习高消之外也没啥好写的了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这文章真是莫名其妙的写了好几天，可能是题目钛毒瘤了导致经常出现思维掉线的局面…</p><p>其中比较多题目的都是杨懋龙前辈论文里的，自己学习了一下，顺便加上了一些自己的心得。</p><p>这可能就是…执念吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是最近的研究成果吧？&lt;/p&gt;
&lt;p&gt;「学不会的生成函数」+「学不会的概率论」= &lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算是比较详细地研究了一下这部分内容吧。个人认为是全网能找到最详细的指南了 qwq。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="组合计数/概率型生成函数(PGF)" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A6%82%E7%8E%87%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-PGF/"/>
    
  </entry>
  
  <entry>
    <title>【UR#3】链式反应</title>
    <link href="https://www.orchidany.cn/2020/05/02/UR50%E9%93%BE%E5%BC%8F%E5%8F%8D%E5%BA%94/"/>
    <id>https://www.orchidany.cn/2020/05/02/UR50链式反应/</id>
    <published>2020-05-02T13:08:39.000Z</published>
    <updated>2020-05-09T07:25:38.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道读题就很麻烦的题目，以下是简化版的题面：</p><blockquote><p>给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：</p><p>1、父亲节点的标号大于子节点。</p><p>2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。</p><p>3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。</p><p>$1\leq n\leq 2\cdot 10^5$ 。</p></blockquote><a id="more"></a><p>考虑暴力 $dp$ ，设状态 $f_i$ 表示以 $i$ 为根时树的数量。那么有</p><script type="math/tex; mode=display">f_{i}=\sum_{j}\sum_{k}\binom{i-1}{j}\cdot\binom{i-j-1}{k}\cdot f_j\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>但是注意到由于 $\alpha$ 型儿子是无序的，所以应该乘一个 $\frac{1}{2}$ 的常数。于是就可以获得一个 $40$ 分的 $O(n^3)$ 做法。</p><p>注意到可以把 $j$ 和 $k$ 分离，变成</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot \sum_{j}\binom{i-1}{j}\cdot f_j\cdot\sum_{k}\binom{i-j-1}{k}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]</script><p>展开两个二项系数</p><script type="math/tex; mode=display">\begin{aligned}f_{i}&=\frac{1}{2}\cdot \sum_{j}\frac{(i-1)!}{j!\cdot (i-j-1)!}\cdot f_j\cdot\sum_{k}\frac{(i-j-1)!}{k!\cdot (i-j-k-1)!}\cdot f_k\cdot [(i-j-k-1)\in \mathbb{A}]\\&=\frac{1}{2}\cdot (i-1)!\cdot \sum_{j}\frac{f_j}{j!}\cdot\sum_{k}\frac{f_k}{k!}\cdot \frac{[(i-j-k-1)\in \mathbb{A}]}{(i-j-k-1)!}\\\end{aligned}</script><p>因为每次本质上只关心 $i-1-(j+k)$ 是否是 $\mathbb A$ 中的元素，所以即通过维护一个 $g$ </p><script type="math/tex; mode=display">g_i= \sum_{j+k=i}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}</script><p>然后转移就可以</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p}{g_p\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>这样就是 $O(n^2)$ 的了。可以喜提 $60pts$ 。</p><p>考虑放到同一个式子里观察：</p><script type="math/tex; mode=display">f_{i}=\frac{1}{2}\cdot (i-1)!\cdot \sum_{p\leqslant i-1}\sum_{j+k=p}\dfrac{f_j}{j!}\cdot \dfrac{f_{k}}{k!}{\cdot \frac{[(i-p-1)\in \mathbb{A}]}{(i-p-1)!}}</script><p>那么如果设 $\mathbf{F}_i=\dfrac{f_i}{i!},\mathbf{P}_i=\dfrac{[i\in \mathbb{A}]}{i!}$，可以发现原式就是一个卷积的形式：</p><script type="math/tex; mode=display">2\cdot i\cdot \mathbf{F}_i=\sum_{2\leqslant j+k\leqslant i-1} \mathbf{F}_j\cdot \mathbf{F}_k\cdot \mathbf{P}_{i-j-k-1}</script><p>此时有两种不同的做法：</p><h2 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h2><p>即发现本质上是在解一个这样的微分方程</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} x}\mathbf{F}=\frac{1}{2}\cdot \mathbf{F}^2\mathbf{P}+1</script><p>然后迭就完了。复杂度 $O(n\log n)$ 但是常数…有点可怕。</p><h2 id="技巧分治"><a href="#技巧分治" class="headerlink" title="技巧分治"></a>技巧分治</h2><p>这式子看上去就…十分的分治 FFT？但是注意到这是二卷积的形式。考虑最简单的分治 FFT 是单卷积，进行的操作可以看作是时间轴上的二进制拆分，即每次用已经得到实际结果的 $f_{l,l+1\cdots mid}$ 去更新 $f_{mid+1,mid+2\cdots r}$ 。考虑二卷积的时候，本质上与单卷积相同， 但需要分类讨论：</p><p>1、$l=1$ 时。</p><p>此时就是 $\mathbf{F}_{1…mid}^2$ 和 $\mathbf{P}_{0…r-l+1}$ 卷在一起。注意 $\mathbf{F}$ 中根据组合意义不能取第 $0$ 项。</p><p>2、$l&gt;1$ 时。</p><p>发现此时由于分治了之后，要保证复杂度，似乎会出现需要用到 $i&gt;mid$ 的 $f_i$ 的情况——但根据分治策略，此时一定有 $2\cdot l&gt;r$ ，也就是 $\forall i\in[l,mid]\cap\mathbb{Z_+}$ ，$i&gt;r-l-1\Longrightarrow r-i<l-1$ 。那么就代表着需要的元素都已经 $l$ 之前被求出了准确值，所以此时不需要考虑 $i>mid$ 的那些转移点。所以此时就直接拿 $\mathbf{F}_{1…r-l}$ 卷上 $\mathbf{F}_{l…mid}$ 和 $\mathbf{P}_{1..r-l}$ 即可。注意到此时有别于 $l=1$ ，对于两棵子树的不同形态本质没有算重。所以为了处理方便可以在此时乘一个 $2$ 。</p><p>于是这种分治方式就比其他朴素的分治多一个比较优的常数。现在跑到了<a href="http://uoj.ac/problem/50/statistics" target="_blank" rel="noopener">uoj榜</a>的第一页。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll g[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll inv[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inv_2 = <span class="number">499122177</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * x % P ;</span><br><span class="line">        x = (ll)x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[n + <span class="number">1</span>] = expow(fac[n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1l</span>l) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, o ; k &lt;= i - j - <span class="number">1</span> ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (base[i - j - k - <span class="number">1</span>])&#123;</span><br><span class="line">                    o = comb(i - <span class="number">1</span>, j) ;</span><br><span class="line">                    o = <span class="number">1l</span>l * o * comb(i - j - <span class="number">1</span>, k) % P ;</span><br><span class="line">                    add(f[i], <span class="number">1l</span>l * o * f[j] % P * f[k] % P) ;</span><br><span class="line">                &#125;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtask2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; g[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i - j - <span class="number">1</span>])</span><br><span class="line">                add(f[i], <span class="number">1l</span>l * g[j] * inv[i - j - <span class="number">1</span>] % P) ;</span><br><span class="line">        f[i] = <span class="number">1l</span>l * f[i] * Inv_2 % P * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i - <span class="number">1</span> ; ++ j)</span><br><span class="line">            add(g[i], <span class="number">1l</span>l * f[i - j] * f[j] % P * inv[i - j] % P * inv[j] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">    <span class="keyword">int</span> k, d ;</span><br><span class="line">    <span class="keyword">int</span> rev[N] ;</span><br><span class="line">    ll g[<span class="number">20</span>][N] ;</span><br><span class="line">    <span class="function">il ll <span class="title">expow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">                ret = ret * x % P ;</span><br><span class="line">            x = x * x % P ; y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_rt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; ++ i)&#123;</span><br><span class="line">            ll* r = g[i], ut ; r[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            ut = r[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) r[j] = r[j - <span class="number">1</span>] * ut % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(T *f, <span class="keyword">int</span> L, <span class="keyword">bool</span> mk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ l)&#123;</span><br><span class="line">            ll *r = g[l], o = i &lt;&lt; <span class="number">1</span>, rt, irt ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += o)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt; i + j ; ++ k)&#123;</span><br><span class="line">                    rt = f[k], irt = f[k + i] * r[k - j] % P ;</span><br><span class="line">                    f[k] = addn(rt, irt), f[k + i] = decn(rt, irt) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mk) <span class="keyword">return</span> ;</span><br><span class="line">        reverse(f + <span class="number">1</span>, f + L) ;</span><br><span class="line">        <span class="keyword">int</span> o = expow(L, P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) (f[i] *= o) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        d = <span class="number">1</span>, k = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (d &lt;= x) d &lt;&lt;= <span class="number">1</span>, ++ k ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (k - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tl[N] ;</span><br><span class="line">    ll tr[N] ;</span><br><span class="line">    ll tmid[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span>) f[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> f[l] = expow(<span class="number">2</span> * l, P - <span class="number">2</span>) * f[l] % P ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = r - l + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> len1 = mid - l + <span class="number">1</span> ;</span><br><span class="line">        cdq(l, mid) ; getlen(len * <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tr[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) add(f[i], tl[i - l]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tl, base, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tr + <span class="number">1</span>, f + l, <span class="keyword">sizeof</span>(ll) * len1) ;</span><br><span class="line">            <span class="built_in">memcpy</span>(tmid + <span class="number">1</span>, f + <span class="number">1</span>, <span class="keyword">sizeof</span>(ll) * len) ;</span><br><span class="line">            <span class="built_in">memset</span>(tl + len, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tr + len1 + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len1 + <span class="number">1</span>)) ;</span><br><span class="line">            <span class="built_in">memset</span>(tmid + len + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * (d - len + <span class="number">1</span>)) ;</span><br><span class="line">            tmid[<span class="number">0</span>] = tr[<span class="number">0</span>] = <span class="number">0</span> ; NTT(tl, d, <span class="number">0</span>) ; NTT(tmid, d, <span class="number">0</span>) ; NTT(tr, d, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; d ; ++ i)</span><br><span class="line">                (tl[i] *= tmid[i] % P * tr[i] % P) %= P ;</span><br><span class="line">            NTT(tl, d, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)</span><br><span class="line">                add(f[i], <span class="number">2l</span>l * tl[i - l] % P) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cdq(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1lld"</span>, &amp;base[i]) ; pre_do() ;</span><br><span class="line">    Poly :: pre_rt() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        base[i] = base[i] * inv[i] % P ;  <span class="comment">//debug(base, 0, n - 1) ;</span></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span> ; Poly :: cdq(<span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i] * fac[i] % P) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道读题就很麻烦的题目，以下是简化版的题面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 $n$ 和集合 $\mathbb{A}$，对于 $i=1..n$ 求多少 $i$ 个节点有标号的多叉树满足：&lt;/p&gt;
&lt;p&gt;1、父亲节点的标号大于子节点。&lt;/p&gt;
&lt;p&gt;2、一个点如果有儿子，则有两个无序的 $α$ 型儿子，有 $c$ 个无序的 $β$ 型儿子，其中$c∈\mathbb{A}$。&lt;/p&gt;
&lt;p&gt;3、如果一个点是根节点或 $α$ 型儿子，那么它可以有儿子或者是一个叶节点；如果一个点是 $β$ 型儿子，那么它只能是一个叶节点。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq 2\cdot 10^5$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="多项式的应用/分治FFT" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%B2%BBFFT/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】正睿5.1省选集训</title>
    <link href="https://www.orchidany.cn/2020/05/01/ZR5-1/"/>
    <id>https://www.orchidany.cn/2020/05/01/ZR5-1/</id>
    <published>2020-05-01T11:05:53.000Z</published>
    <updated>2020-05-09T07:25:01.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>被爆锤，生活失去希望了（雾）。</p><p>这波被揍的很彻底，也激发了我的斗志(发现自己前两个月真是比咸鱼还咸鱼)。</p><p>啊啊啊啊凭什么我这么菜！冲冲冲！</p><p>这次的题是小象出的。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>有一个随机变量 $z$, 初始 $z=0$.</p><p>执行 $n$ 次操作: 每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:=z+t$ 。</p><p>求 $\min(z,x)$ 的期望. 答案模 $998244353$. </p><p>$k\leq 100,n\leq 10^9,x\leq \min\{10^7,\frac{5\times 10^7}{k}\}$ 。</p></blockquote><p>……自闭就完事了。</p><p>赛时觉得这是个期望推式子题，于是化了一波 $\min(z,x)$ :</p><script type="math/tex; mode=display">E(\min(z,x))=\frac{1}{2}\left(E(x)+E(z)+E(|x-z|)\right)</script><p><del>嗯，十分有道理，但是我还是不会x</del></p><p>赛后慎老师告诉我 $40$ 分可以直接背包。我想了想，觉得自己可能给这个班丢脸了…</p><p>然后考虑正解。设选择整数的概率型生成函数为 $P(y)=\sum_{i=0}^kp_i$ ，那么取了 $n$ 次之后的概率型生成函数就是 $Q(y)=P^n(y)$ 。</p><p>那么不难知道答案为</p><script type="math/tex; mode=display">\sum_{i=0}^{n\times k} [y^i]Q\cdot \min(x,i)=\sum_{i=0}^{x-1} [y^i]Q\cdot i + \left(1-\sum_{i=0}^{x-1} [y^i]Q\right)\cdot x</script><p>呃…虽然没学过 PGF 到底怎么化，但是概率上求 $z$ 补集就是 $1-z$ 还是比较 xxs 的结论吧…</p><p>然后现在问题就集中在怎么求 $P^n(y)$ 的前 $k$ 项了。发现可以暴力多项式快速幂，以获得 $40\sim 60$ 左右的成绩。</p><p>然后是神奇的多项式技巧…大概是考虑对于 $P^{n+1}(y)$ 求导有两种方式：</p><script type="math/tex; mode=display">\left(P^{n+1}(y)\right)^{\prime}=(n+1) P^{n}(y) P^{\prime}(y)\\\left(P^{n+1}(y)\right)^{\prime}=\left(P^{n}(y)\right)^{\prime} P(y)+P^{n}(y) P^{\prime}(y)</script><p>第一个就是链式法则，第二个则是拆出一个 $P(y)$ 来再用求导的乘法运算法则。</p><p>考虑联立之后</p><script type="math/tex; mode=display">nP^n(y)(P(y))'=(P^n(y))'P(y)</script><p>然后考虑现在的问题是，已知了 $P^n(y)$ 的前几项系数，求出后面的系数。考虑一个这样的思路：每次先求出 $(P^n(y))’$ 的第 $d$ 项，然后积分出 $P^n(y)$ 的第 $d+1$ 项。发现每个 $[y^d]P^n(y)$ 只会对 $y^d\sim y^{d+k}$ 这些产生贡献，所以考虑枚举到一个 $d$ 的时候向后刷表；考虑这样求出的是 $(P^n(y))’P(y)$ ，直接模拟多项式除法即可得到 $(P^n(y))’$ ，这样做也是单次 $O(k)$ 的。</p><p>对于多项式除法这部分，可以考虑对于每个 $<a href="P^n(y">y^d</a>)’P(y)$ 都是这么计算得到的：</p><script type="math/tex; mode=display">\sum_{p=0}^k[y^p]P(y)\times [y^{d-p}](P^n(y))'</script><p>然后就减去所有的 $p&gt;0$ 的那些结果，最后乘上一个 $[x^0]P(y)$ 的逆元即可。</p><p>草，这还是我第一次做概率生成函数……我觉得我的正睿 rating 已经不(都)重(掉)要(没)了，所以就当学新东西了吧…</p><p>这份代码截止在我交上去的时候还是全站速度 rank4，想了想觉得可能是线性求逆元立了功。于是顺便复习一下线性求逆元：</p><p>考虑模数是 $m$，那么设 $m=p\cdot x+r$，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}p\cdot x+r&\equiv 0\pmod m\\p\cdot r ^{-1}+x^{-1}&\equiv 0 \pmod m\\x^{-1}&\equiv -\lfloor\frac{m}{x}\rfloor\cdot (m\bmod x)^{-1}\pmod m\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> base ;</span><br><span class="line"><span class="keyword">int</span> F[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> G[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, x ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x ; inv[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = qr(), add(sum, <span class="number">1l</span>l * F[i]) ;</span><br><span class="line">    sum = expow(sum, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        F[i] = <span class="number">1l</span>l * F[i] * sum % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = <span class="number">1l</span>l * n * F[i + <span class="number">1</span>] % P * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        inv[i] = (<span class="number">-1l</span>l * inv[P % i] * (P / i) % P) + P;</span><br><span class="line">    base = expow(F[<span class="number">0</span>], P - <span class="number">2</span>) ; G[<span class="number">0</span>] = expow(F[<span class="number">0</span>], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; i + j &lt; x &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            add(tmp[i + j], <span class="number">1l</span>l * f[j] * G[i] % P) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i - j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= k ; ++ j)</span><br><span class="line">            dec(tmp[i], <span class="number">1l</span>l * g[i - j] * F[j] % P) ;</span><br><span class="line">        g[i] = <span class="number">1l</span>l * base * tmp[i] % P ;</span><br><span class="line">        G[i + <span class="number">1</span>] = <span class="number">1l</span>l * g[i] * inv[i + <span class="number">1</span>] % P ;</span><br><span class="line">        add(ans, <span class="number">1l</span>l * i * G[i] % P) ; dec(res, G[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="number">1</span> ; add(ans, <span class="number">1l</span>l * res * x % P) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>用从小到大逐位确定的方法生成一个由 $n$ 个 $0$, $n$ 个 $1$ 组成的随机 $01$ 串 $s$ :</p><p>如果当前已经生成了 $n$ 个 $0$ 或 $1$，新生成的位一定对应地为 $1$ 或 $0$ ; 否则以 $50\%$ 的概率生成 $0$, $50\%$ 的概率生成 $1$.</p><p>有 $q$ 组询问, 每组询问给 $k$ 个数 $a_1,a_2,⋯,a_k$ 求 $s_{a_1}=s_{a_2}=⋯=s_{a_k}$ 的概率. 答案模 $998244353$.</p><p>$n\leq 2\times 10^5,q\leq 2\times 10^5,\sum k \leq 2\times 10^5$</p></blockquote><p>我对概率这东西有时候真的很迷…有时候可以直接算，有时候不可以…自己还是太弱菜。本来打算如果可以过省选，就系统地学一下概率论…现在可能是不可能了。</p><p>记字符串中最后一个出现的 <code>1</code> 的位置为 $a$，<code>0</code> 的位置为 $b$ ，那么该字符串存在的概率就是 $\dfrac{1}{2^{\min\{a,b\}}}$。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>记 $s$ 为前 $n$ 个字母的集合 $\{a,b,c,⋯\}$。</p><p>将 $s$ 中所有大小不超过 $k$ 的非空子集划分成尽量少的组, 使得:</p><p>1、每个子集恰好在一个组中.</p><p>2、对于同一组的任意两个子集, 他们的交为空.</p><p>3、每组的所有集合大小之和不超过 $k$.</p><p>$1\leq k\leq n\leq 17$ 。</p></blockquote><p>我怀疑象故意卡 dfs…因为所有点里面最小的两个点是 $n=6,k=4$ 和 $n=6,k=5$。但是我写的 dfs 只能算到 $n=6,k=3$…$n=6,k=4$ 跑了一整场比赛都没跑出来…</p><p>不会带花树和 Hull 定理，于是决定先咕咕咕了，留下一份 dfs 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> Id[M] ;</span><br><span class="line"><span class="keyword">int</span> sz[M] ;</span><br><span class="line"><span class="keyword">int</span> siz[M] ;</span><br><span class="line"><span class="keyword">int</span> sum[M] ;</span><br><span class="line"><span class="keyword">int</span> subs[M] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; res[M] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; base[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; x) <span class="built_in">putchar</span>(<span class="string">'a'</span> + i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; s)&#123;</span><br><span class="line">            ans = s ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s ; ++ i) res[i] = base[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = x + <span class="number">1</span>, t = s + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= s ; ++ j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[j] &amp; subs[y]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (sum[j] + sz[subs[y]] &gt; k) <span class="keyword">continue</span> ;</span><br><span class="line">        base[j][y] = <span class="number">1</span> ; siz[j] |= subs[y] ; sum[j] += sz[subs[y]] ;</span><br><span class="line">        dfs(x + <span class="number">1</span>, s) ;</span><br><span class="line">        base[j][y] = <span class="number">0</span> ; siz[j] ^= subs[y] ; sum[j] -= sz[subs[y]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    base[t][y] = <span class="number">1</span> ; siz[t] = subs[y] ; sum[t] = sz[subs[y]] ;</span><br><span class="line">    dfs(x + <span class="number">1</span>, t) ; base[t][y] = <span class="number">0</span> ; siz[t] = sum[t] = <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sz[i] = sz[i - (i &amp; -i)] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt;= k) subs[Id[i] = ++ cnt] = i ;</span><br><span class="line">    ans = m + <span class="number">1</span> ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= ans ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i].count() &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (res[i][j]) output(subs[j]), <span class="built_in">putchar</span>(<span class="string">' '</span>) ;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得我可能是真的不会 dfs…这一个 dfs 调了我快 90min…还是太不认真了啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被爆锤，生活失去希望了（雾）。&lt;/p&gt;
&lt;p&gt;这波被揍的很彻底，也激发了我的斗志(发现自己前两个月真是比咸鱼还咸鱼)。&lt;/p&gt;
&lt;p&gt;啊啊啊啊凭什么我这么菜！冲冲冲！&lt;/p&gt;
&lt;p&gt;这次的题是小象出的。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ZhengRuiOI" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/ZhengRuiOI/"/>
    
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="微分方程" scheme="https://www.orchidany.cn/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="组合计数/概率型生成函数(PGF)" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A6%82%E7%8E%87%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-PGF/"/>
    
  </entry>
  
  <entry>
    <title>【复习】概率期望复习笔记</title>
    <link href="https://www.orchidany.cn/2020/05/01/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B2/"/>
    <id>https://www.orchidany.cn/2020/05/01/概率期望2/</id>
    <published>2020-05-01T05:16:36.000Z</published>
    <updated>2020-05-07T07:56:27.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>胡乱整理了有关期望的一些东西。</p><p>为什么自己老是学了就忘呢……</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>什么“所有情况的概率加权平均值blabla”，一般用处不大？</p><p>或者形式化一点，$ \rm \mathbb{E}(X)=\sum_i(~\Pr(X=i)\cdot i~) $</p><h1 id="期望的线性性"><a href="#期望的线性性" class="headerlink" title="期望的线性性"></a>期望的线性性</h1><p>唔，这个地方其实应用是很广泛的。大概就是对于两个事件 $\rm X,Y$，$\rm \mathbb{E}(aX+bY)=aE(X) +bE(Y)$ 。</p><p>对于这东西的证明大概如下：</p><script type="math/tex; mode=display">\begin{aligned}  \mathbb{E}(\mathrm{\mathrm{X}}+\mathrm{Y}) & {=  \sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)\cdot(i+j)} \\ & {  =\sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j) \cdot i+\sum_{i} \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)  \cdot j} \\ &{ =\sum_{i} i \cdot  \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j)  \cdot j+\sum_{i} j \cdot  \sum_{j} \Pr (\mathrm{\mathrm{X}}=i \& \& \mathrm{Y}=j) \cdot  i} \\ & { =\sum_{i} \Pr (\mathrm{X}=i) \cdot  i+\sum_{j} \Pr (\mathrm{Y}=j) \cdot  j} \\ & { =\mathbb{E}(\mathrm{\mathrm{X}})+\mathbb{E}(\mathrm{Y})}\end{aligned}</script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="期望经典模型"><a href="#期望经典模型" class="headerlink" title="期望经典模型"></a>期望经典模型</h1><h2 id="容斥模型"><a href="#容斥模型" class="headerlink" title="容斥模型"></a>容斥模型</h2><blockquote><p>有 $n$ 个随机变量 $\rm X[1…n]$，每个随机变量都是从 $\rm 1…S$ 中 随机一个整数，求 $\rm max(X[1…n])$ 的期望。 </p></blockquote><p>根据期望的线性性可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\rm \mathbb{E}& =\sum _{i=1}^{\mathrm{S}}\Pr(\max=i)\times i\\\ & =\sum _{i=1}^{\mathrm{S}}i\cdot (\Pr(\max\leq i)-\Pr(\max\leq i-1))\\ &  = \sum_{i=1}^{\mathrm{S}}i\cdot \left(\left(\dfrac{i}{\mathrm{S}}\right)^n - \left(\dfrac{i-1}{\mathrm{S}}\right)^n\right)\end{aligned}</script><p>这个容斥技巧好像还是挺常见的吧？</p><h2 id="等价模型"><a href="#等价模型" class="headerlink" title="等价模型"></a>等价模型</h2><p>实际上是取球问题，大概思路就是取每一个球是<strong>独立</strong>的，这一点在期望的线性性上体现得比较明显：</p><h3 id="放球问题-I"><a href="#放球问题-I" class="headerlink" title="放球问题 I"></a>放球问题 I</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后<strong>不放回</strong>，求取出的数字之和的期望 。</p></blockquote><p>还是期望的线性性：</p><script type="math/tex; mode=display">\mathbb{E}\left(\sum_{i=1}^{n} X_{i}\right)=\sum_{i=1}^{n} \mathbb{E}\left(X_{i}\right)=\sum_{i=1}^{n} \Pr(X=i) \times i=\sum_{i=1}^{n} \dfrac{m}{n} \times i=\dfrac{m}{n} \sum_{i=1}^{n} i=\dfrac{m}{n} \times \dfrac{n(n+1)}{2}=\dfrac{m(n+1)}{2}</script><p>这个地方个人理解的为什么 $\Pr(X=i)=\dfrac{m}{n}$，是考虑首先显然每个球平等，且摸到之后贡献为 $1$，所以可以知道有 $\sum_{i=1}^{n}\mathbb{E}(X=i)=m$，那么由于每个球都一样，所以 $\Pr(X=i)=\mathbb{E}(X=i)=\dfrac{m}{n}$。</p><h3 id="放球问题-II"><a href="#放球问题-II" class="headerlink" title="放球问题 II"></a>放球问题 II</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后<strong>放回</strong>，求取出的数字之和的期望 。</p></blockquote><p>考虑无论放回不放回，拿到 $i$ 的概率都是 $\dfrac{1}{n}\times m$ ，所以和第一问结果一样。</p><h3 id="放球问题-III"><a href="#放球问题-III" class="headerlink" title="放球问题 III"></a>放球问题 III</h3><blockquote><p>箱中有 $n$ 个球 $1…n$，你要从中拿 $m$ 次球，拿了后以 $p_1$ 的概率放回，以 $p_2$ 的概率放回两个和这个相同的球，求取出的数字之和的期望。</p></blockquote><p>这个地方可能有点绕。但是就是“球球平等”的思想。虽然有点难理解，但是考虑 问题 I 中我们推导的过程只用了「球球平等」这一条，所以可知这样也是对的。</p><h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><p>…就是游走模型。大概就是说假设一个点的出度为 $k$，他么他有 $\dfrac{1}{k}$ 的概率走到周围其他点。</p><h3 id="链上游走"><a href="#链上游走" class="headerlink" title="链上游走"></a>链上游走</h3><blockquote><p>在一条 $n$ 个点的链上随机游走，求从一段端走到另一端的期望步数</p></blockquote><p>考虑分阶段进行。根据线性性，$ \mathbb{E}(T)=\sum_{i=1}^{n-1} \mathbb{E}(X_i)$。其中 $\mathbb{E}(X_i)$ 表示从 $i$ 第一次走到 $i+1$ 的期望步数。</p><p>然后我们列方程，考虑一步转移走到了 $ i+1$ 还是 $i-1$ ：  </p><script type="math/tex; mode=display">\mathbb{E}(X_i)=\dfrac{1}{2}+\dfrac{1}{2}\cdot(1+\mathbb{E}(X_i)+\mathbb{E}(X_i-1))</script><p>解出来得</p><script type="math/tex; mode=display">\mathbb{E}(X_i)=2+\mathbb{E}(X_i-1)</script><h3 id="完全图游走"><a href="#完全图游走" class="headerlink" title="完全图游走"></a>完全图游走</h3><blockquote><p>在一个 $n$ 个点的完全图上游走，求从一个点到另一个点期望步数。 </p></blockquote><p>完全图的话，每个点走到每个点的概率都是 $\dfrac{1}{n-1}$。于是这个题就有好多种不同的解法，比如用一个推论“概率为 $P$ 的事件期望 $\dfrac{1}{P}$ 次后发生”，就可以直接证明 $\mathbb{E}(t) = n-1$。</p><h3 id="完全二分图游走"><a href="#完全二分图游走" class="headerlink" title="完全二分图游走"></a>完全二分图游走</h3><blockquote><p>在一个 $2n$ 个点的完全二分图上游走，求一个点走到另一个点的期望步数。</p></blockquote><p>解方程的思想，分类讨论是在同侧还是异侧。</p><p>记 $\mathbb{E}_a$ 表示在同侧的期望步数， $\mathbb{E}_b$ 表示在异侧的期望步数。那么考虑有：</p><script type="math/tex; mode=display">\mathbb{E}_a=\mathbb{E}_b+1\\\mathbb{E}_b=\dfrac{1}{n}+\dfrac{n-1}{n}\cdot(\mathbb{E}_a+1)</script><p>然后解出来 $\mathbb{E}_b=2\cdot n-1,\mathbb{E}_a=2\cdot n$ …为什么感觉很不对的样子呢…但是这么列方程肯定是没错的。 </p><h3 id="菊花图游走"><a href="#菊花图游走" class="headerlink" title="菊花图游走"></a>菊花图游走</h3><blockquote><p>在一张 $n$ 个点的菊花图上游走，求从根走到另一个点的期望步数。</p></blockquote><p>考虑一共有三种情况：</p><p>1、叶子走到根 $\mathbb{E}(a)=1$ 。</p><p>2、根走到叶子 $\mathbb{E}(b)=\dfrac{1}{n-1}+\dfrac{n-2}{n-1}\times (\mathbb{E}(c)+1)$。</p><p>3、叶子走到叶子 $\mathbb{E}(c)=1+\mathbb{E}(b)$。</p><p>解方程可以得到 $，$$\mathbb{E}(b)=2\cdot n-3,\mathbb{E}(c)=2\cdot 2-2$ 。</p><h3 id="树上游走"><a href="#树上游走" class="headerlink" title="树上游走"></a>树上游走</h3><blockquote><p>在一棵 $n$ 个点的树上游走，问从根走到 $x$ 的期望步数。</p></blockquote><p>唔，其实有好多不同版本，也可以就是从 $y$ 走到 $x$ 的期望步数，因为游走问题是不存在有根树的，所以直接把 $y$ 拽起来当根也没什么问题。然后就是考虑链做法里面的思想，设 $f_u$ 表示 $u$ 第一次走到他父亲的期望步数，然后就有方程</p><script type="math/tex; mode=display">f_u=\dfrac{1}{deg_u}+\dfrac{1}{deg_u}\sum_{v\in son _u}(1+f_u+f_x)</script><p>前者是走上去的，后者是不小心走下去的。然后期望的线性性加起来即可。</p><p><del>然后就是高消时间了</del></p><p>呃，或许这个是可以 up and down 的？好像不行，我傻了。</p><h1 id="期望思考题"><a href="#期望思考题" class="headerlink" title="期望思考题"></a>期望思考题</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>构造一张 $200$ 个点的无向图，使得上面从 $\rm S$ 走到 $\rm T$ 的随机游走期望步数 $\geq 100,0000$。</p></blockquote><p>考虑是一条链的时候大概有 $O(n^2)$ 的期望步数，在一张完全图上有 $O(n)$ 的期望步数，于是就可以考虑在 $\rm S$ 上连出一张 $100$ 个点的完全图，然后在一条链连到 $T$，就是 $n^3$ 的期望步数。具体实现似乎需要微调的亚子233.</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（1）</p><blockquote><p>随机一个长度为 $n$ 的排列 $p$，问前 $i$ 个数字中 $p_i$ 是最大数字的概率。</p></blockquote><p>…算都不用算就知道是$\dfrac{1}{i}$ 。</p><p>（2）</p><blockquote><p>随机一个长度为 $n$ 的排列 $p$，问前 $i$ 个数字中 $p_i$ 是最大数字的 $i$ 的个数的平方的期望。</p></blockquote><p>首先设 $x_i$ 表示第 $i$ 个数是不是前 $i$ 个数中最大的数字，那么 $x_i=0/1$。那么总个数 $\rm S=\it\sum x_i$，总个数的平方的期望就是 $\mathrm{\mathbb{E}(S^2)}=\mathrm{ E}((\sum x_i)^2)$，之后就开始化式子：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{\mathbb{E}(S^2)}&= \mathrm{E}((\sum x_i)^2)\\ &=\mathrm{E}( \sum x_i^2+\sum_{i\neq j}x_ix_j)\\ &=\mathrm{E}(\sum x_i^2)+\mathrm{E}(\sum_{i\neq j}x_ix_j)\end{aligned}</script><p>以上用的都是期望的线性性。然后最后考虑用（1）中的结论，$\Pr(x_i=1)=\dfrac{1}{i}$，就可以得到：</p><script type="math/tex; mode=display">\mathrm{\mathbb{E}(S^2)}= \sum_{i\neq j}\dfrac{1}{ij}+\sum \dfrac{1}{i^2}</script><p>这东西显然是有平凡的通项公式，但是懒得推了233。 </p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>随机一个 $1\sim n$ 的排列，求 $i$ 在 $j$ 前面的概率。</p></blockquote><p>这显然是 $\dfrac{1}{2}$ 。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（1）</p><blockquote><p>随机一个长度为 $n$ 的排列，求一个长为 $m$ 的 <strong>子序列</strong> $s[1…m]$ 在该排列中出现的概率。</p></blockquote><p>考虑对称性，$n$ 排列对 $m$ 序列随机，也可以看做 $m$ 序列对 $n$ 排列随机。其实怎么想无所谓——更直观的是考虑重排 $s$，对于每一个随机序列，都有且仅有一种 $s$ 的重排方式会在其中作为子序列。所以答案就是 $\dfrac{1}{m!}$ 。</p><p>（2）</p><blockquote><p>随机一个长度为 $n$ 的排列，求一个长为 $m$ 的<strong>连续子序列</strong> $s[1…m]$ 在该排列中出现的概率。</p></blockquote><p>思考同样的结论放在(2)里面到底多算了哪些情况。首先就是我们要乘上一个 $\dfrac{1}{\binom{n}{m}}$，因为现在不能从 $n$ 中随便选出 $m$ 个位置来放，只能选择相邻的 $m$ 项。但是这还不够，因为我们还少算了以每个元素开头的连续子序列情况，所以应该再乘上 $n-m+1$，于是答案就是</p><script type="math/tex; mode=display">\dfrac{n-m+1}{m!\binom{n}{m}}=\dfrac{n-m+1}{P_n^m}=\dfrac{(n-m+1)!}{n!}</script><p>说句题外话，从不等关系来讲，会有 $\dfrac{(n-m+1)!}{n!} \leq \dfrac{1}{m!}$，因为(2)的方案数一定小于等于(1)，那么(2)发生的概率一定小于等于(1)。然后移个项就会有 $(n-m+1)!m!\leq n!$ 这种东西；或者从组合意义上来讲，会有 $(n-m+1)!\leq \dfrac{n!}{m!}$，即“ $n-m+1$ 个不同元素的排列数小于等于从 $n$ 个不同元素里面选出 $n-m$ 个元素进行排列的方案数”。</p><p>By the way，当且仅当 $n=m$ 时等号成立。</p><p>呃，似乎并不是很有意思，我还以为能推出什么有意思的东西来着233</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>给一个序列，每次随机删一个元素，问第 $i$ 个元素和第 $j$ 个元素相邻的概率。</p></blockquote><p>然而是个组合题。</p><p>考虑每个数是什么时候被删除的，按删除顺序组成一个序列。因为是随机删除，所以删除序列也是随机的。接着考虑删除序列里面 $[i…j]$ 这段区间的排列总方案数是 $(j-i+1)!$，当且仅当 $[i+1…j-1]$ 都被删除且 $i,j$ 还没被删除时合法，这样的方案数是 $(j-i+1-2)!\cdot P_2^2$，于是概率就是</p><script type="math/tex; mode=display">\dfrac{2\cdot (j-i-1)!}{(j-i+1)!}</script><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>给定⼀棵树，将他的边随机⼀个顺序后依次插⼊，求 $u,v$ 期望什么时候连通。</p></blockquote><p>考虑两个点连通只与他们之间的边数有关。设这个数量为 $k$ ，可以知道答案为</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=k}^{n-1}i\cdot \dfrac{(n-1-k)!(k-1)!\binom{i-1}{k-1}}{(n-1)!}</script><p>即用线性性枚举「恰好第 $i$ 次连通」。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><blockquote><p>给 $1…n$ 这 n 个数，每次随机选择⼀个还在的数并且删掉他的所有约数，求期望⼏次删完</p></blockquote><p>跟 CF280C 那题本质上很相似。考虑一个数被删掉当且仅当他的倍数被删掉，同时只会有自己被删掉时产生 $1$ 的贡献，所以可以知道答案就是 $\mathbb{E}(X)=\sum \dfrac{1}{\lfloor\frac{n}{x}\rfloor}$ 。</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><blockquote><p>给定 $n$ 个硬币，第 $i$ 个硬币的价值为 $w_i$，每次随机取⾛⼀个硬币，获得的收益是左右两个硬币的价值的乘积，求期望总价值。</p></blockquote><p>想了一会儿之后发现是个弱智题。</p><p>考虑这个问题里面的单位决策数应该是 $O(n^2)$ 级别的二元组 $(i,j)$，也就是考虑对每一组 $(i,j)$ 分别算概率，发现这个概率就是 $i,i+1,i+2\cdots j$ 中随机删数，$[i+1,j-1]$ 在 $i,j$ 之前被删掉的概率，于是就可以直接算了。</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i,j} w_i\cdot w_j\cdot \Pr(i,j)=\sum_{i,j} w_i\cdot w_j\cdot \frac{(i-j-1)!}{(i-j+1)!}</script><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><blockquote><p>有 $n$ 个数 $a[1…n]$，每次等概率选出两个数，然后合并成⼀个新的数放回来，得到的收益是新的数的值，求总收益的期望。</p></blockquote><p>自然是考虑分别计算每个数期望被选到的次数。然后对这个东西用线性性展开可以知道，可以分别求每个数在每一次合并中被选到的概率，那么就是</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=1}^{n}\frac{2}{n-i-1}\cdot 1=\sum_{i=2}^n \frac{2}{i}</script><p>即每次选择两个堆合并、选到 $x$ 那个堆的概率。</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><blockquote><p>给定⼀个数列 $w[1…n]$，随机⼀个排列 $h$，如果 $h[i]$ ⽐ $h[i-1]$ 和 $h[i+1]$ 都⼤，就获得 $w[i]$ 的收益，求期望收益。</p></blockquote><p>自己想的方法是暴力组合，考虑用线性性展开之后，变成分别对每个数算自己成为最大值的概率，发现这个概率就是</p><script type="math/tex; mode=display">\Pr(X=\max)=\sum_{i=3}^n\frac{1}{n}\times \dfrac{\binom{i-1}{2}}{\binom{n-1}{2}}</script><p>然后可以展开得到</p><script type="math/tex; mode=display">\begin{aligned}\Pr(X=\max)&=\frac{1}{n\cdot (n-1)\cdot (n-2)}\cdot \sum_{i=3}^{n-1}(i-1) \cdot (i-2)\\&=\frac{1}{n\cdot (n-1)\cdot (n-2)}\cdot \sum_{i=1}^{n-3}i \cdot (i+1) \end{aligned}</script><p>然后一个比较神奇的事情，后面那个 $\sum$ 是有闭形式的。即：</p><script type="math/tex; mode=display">\sum_{i=1}^n(i+1)\cdot i=\frac{(n+1)\cdot (n+2)\cdot (n+3)}{3}</script><p>然后相乘之后可知…$\Pr(X=\max)$ 就是 $\frac{1}{3}$ 。实际上也可以从更感性的角度来理解，三个数里面，成为最大的数概率自然是 $\frac{1}{3}$ 。</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><blockquote><p>有 $n$ 个⿊球，$m$ 个⽩球，每次等概率取出⼀个球(不放回)，将取出来的球的颜⾊写成⼀个 $01$ 序列，求 <code>01</code> 的期望出现次数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">分值</th><th style="text-align:center">$\max\{n,m\}$</th><th style="text-align:center">特殊性质</th></tr></thead><tbody><tr><td style="text-align:center">$\rm Subtask1$</td><td style="text-align:center">$5$</td><td style="text-align:center">$\leqslant 20$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask2$</td><td style="text-align:center">$30$</td><td style="text-align:center">$\leqslant 300$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask3$</td><td style="text-align:center">$25$</td><td style="text-align:center">$\leqslant 5000$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask4$</td><td style="text-align:center">$10$</td><td style="text-align:center">$\leqslant 5\cdot 10^6$</td><td style="text-align:center">$n=m$</td></tr><tr><td style="text-align:center">$\rm Subtask5$</td><td style="text-align:center">$15$</td><td style="text-align:center">$\leqslant 10^6$</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">$\rm Subtask5$</td><td style="text-align:center">$15$</td><td style="text-align:center">$\leqslant 10^{9}$</td><td style="text-align:center">\</td></tr></tbody></table></div></blockquote><h3 id="5pts-做法"><a href="#5pts-做法" class="headerlink" title="5pts 做法"></a>5pts 做法</h3><p>枚举所有可能的颜色排列，复杂度 $O(n\cdot 2^n)$。</p><h3 id="20pts-做法"><a href="#20pts-做法" class="headerlink" title="20pts 做法"></a>20pts 做法</h3><p>设 $X$ 表示出现次数，那么有</p><script type="math/tex; mode=display">\mathbb{E}(X)=\sum_{i=1}^{\min\{n,m\}}\Pr(X=i)\cdot i</script><p>考虑这个 $X=i$ 怎么算，本质上是求 $01$ 排列有多少种方案存在恰好 $i$ 个 <code>01</code>，也就只需要计算 $i$ 个相隔距离 $\geq 1$ 的 $0$ 的方案数。这个地方想了一会儿没找到什么闭形式，于是打算直接 $dp$ 。</p><p>设 $f_{i,j,k,0/1}$ 表示前 $i$ 位有 $j$ 个 $0$ ，其中有 $k$ 个 $01$ ，且第 $i$ 位放了 $0/1$ 的方案数，那么有转移</p><script type="math/tex; mode=display">f_{i+1,j,k+1,1}\leftarrow f_{i,j,k,0}\to f_{i+1,j+1,k,0}\\f_{i+1,j+1,k,0}\leftarrow f_{i,j,k,1}\to f_{i+1,j,k,1}\\</script><p>然后算就好了，时空复杂度均为 $O(n^3)$ 。</p><h3 id="60pts-做法"><a href="#60pts-做法" class="headerlink" title="60pts 做法"></a>60pts 做法</h3><p>发现继续沿用对着每个 $i$ 求贡献的做法。发现本质上就是从长为 $n+m$ 的序列里面选出 $i$ 个不相邻的 <code>0</code> 的方案数。考虑转化一下这个问题。首先可以转化成从 $1\sim n +m$ 里面选择 $i$ 个不相邻的数的方案数。之后考虑对于选出来的数 $a_1,a_2,a_3\cdots a_i$ ，从小到大排序后一定满足</p><script type="math/tex; mode=display">a_1<a_2-1<a_3-1<a_4-1< \cdots<a_{i}-1</script><p>考虑令 </p><script type="math/tex; mode=display">b_1=a_1-1,b_2=a_2-2,b_3=a_3-3,b_4=a_4-4\cdots b_i=a_i-i</script><p>发现这样随便选择两个相邻的 $b_{k},b_{k+1}$ 都会有</p><script type="math/tex; mode=display">b_k=a_k-k<a_{k+1}-1-k=a_{k+1}-{k+1}=b_{k+1}</script><p>也就是从 $1\sim n+m-i$ 中选择可以相邻的 $\{b\}$ 的方案数等于在 $1\sim n+m$ 中选择不能相邻的 $\{a\}$ 的方案数。于是可以知道有 $i$ 个 $01$ 时的方案数就是</p><script type="math/tex; mode=display">f_i=\binom{n+m-i}{i}\cdot \binom{n+m-2\cdot i}{n-i}</script><p>注意到因为序列其他位置的方案数也要考虑，所以需要再乘上一个剩下未知的方案数。但是注意到，剩下位置可能还会存在 $01$ ，所以 $f_i$ 本质上算的是「至少 $i$ 个的方案数」。设 $g_i$ 表示「恰好 $i$ 个的方案数」，那么可知：</p><script type="math/tex; mode=display">g_i=\sum_{j\geq i} \binom{j}{i} \cdot (-1)^{j-i}f_j</script><p>因为有二项式反演：</p><script type="math/tex; mode=display">f(n)=\sum_{i=n}^{m}\left(\begin{array}{c}i \\ n\end{array}\right) g(i) \Leftrightarrow g(n)=\sum_{i=n}^{m}(-1)^{i-n}\left(\begin{array}{c}i \\ n\end{array}\right) f(i)</script><p>然后就可以获得一个时空复杂度均为 $O(n^2)$ 的做法。</p><h3 id="70pts-做法"><a href="#70pts-做法" class="headerlink" title="70pts 做法"></a>70pts 做法</h3><p>有特殊性质 $n=m$。可以通过进一步对上一个做法用组合恒等式来化简，或者直接找规律，可以发现当 $n=m$ 时，$g_i=\binom{n}{i}^2$。于是就可以线性做了。</p><h3 id="85pts-做法"><a href="#85pts-做法" class="headerlink" title="85pts 做法"></a>85pts 做法</h3><p>并不会，有人来教教我吗？不过似乎二项式反演是可以做到 $\log^2$ 的？这可能需要什么多项式科技。</p><h3 id="100pts-做法"><a href="#100pts-做法" class="headerlink" title="100pts 做法"></a>100pts 做法</h3><p>发现对于期望，只需要算出所有情况下 $01$ 数量的总和，除以全部的合法排列数即可。考虑这个总和也是可以分开算的，即可以算对于每个可能出现的 <code>01</code> 计算与之对应的有多少贡献。于是答案就是：</p><script type="math/tex; mode=display">\frac{(n+m-1)\cdot \binom{n+m-2}{m-1}}{\binom{n+m}{m}}</script><p>化简一下可以得到答案为</p><script type="math/tex; mode=display">\frac{n\times m}{n+m}</script><p>复杂度 $O(\log n)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">550</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P2 = <span class="number">5050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P3 = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> ans1 ;</span><br><span class="line"><span class="keyword">int</span> ans2 ;</span><br><span class="line"><span class="keyword">int</span> ans3 ;</span><br><span class="line"><span class="keyword">int</span> fac[P3] ;</span><br><span class="line"><span class="keyword">int</span> inv[P3] ;</span><br><span class="line"><span class="keyword">int</span> comb[P2][P2] ;</span><br><span class="line"><span class="keyword">int</span> f[P3], g[P3], h[P3] ;</span><br><span class="line"><span class="keyword">int</span> dp[P1 * <span class="number">2</span>][P2][P2][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j][k][<span class="number">1</span>], dp[i][j][k][<span class="number">1</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>][<span class="number">1</span>], dp[i][j][k][<span class="number">0</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k][<span class="number">0</span>], dp[i][j][k][<span class="number">0</span>]) ;</span><br><span class="line">                add(dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k][<span class="number">0</span>], dp[i][j][k][<span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        h[i] = addn(dp[n + m][m][i][<span class="number">0</span>], dp[n + m][m][i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + m ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j - <span class="number">1</span>], comb[i - <span class="number">1</span>][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        f[i] = (ll)comb[n + m - i][i] * comb[n + m - <span class="number">2</span> * i][m - i] % P ; <span class="comment">// comb[n + m][m] ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= m ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(g[i], (ll)f[j] * comb[j][i] % P) : dec(g[i], (ll)f[j] * comb[j][i] % P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans1, <span class="number">1l</span>l * h[i] * (ll)i % P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans2, <span class="number">1l</span>l * g[i] * (ll)i % P) ;</span><br><span class="line">    ans3 = (ll)n * m % P * expow(n + m, P - <span class="number">2</span>) % P ;</span><br><span class="line">    ans1 = (ll)ans1 * expow(comb[n + m][m], P - <span class="number">2</span>) % P ;</span><br><span class="line">    ans2 = (ll)ans2 * expow(comb[n + m][m], P - <span class="number">2</span>) % P ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, ans1, ans2, ans3) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡乱整理了有关期望的一些东西。&lt;/p&gt;
&lt;p&gt;为什么自己老是学了就忘呢……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>简单题选做·4</title>
    <link href="https://www.orchidany.cn/2020/05/01/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B74/"/>
    <id>https://www.orchidany.cn/2020/05/01/简单题选做·4/</id>
    <published>2020-04-30T23:49:03.000Z</published>
    <updated>2020-04-30T23:49:03.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【泛做】从零开始的数位DP生活</title>
    <link href="https://www.orchidany.cn/2020/04/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E4%BD%8DDP%E7%94%9F%E6%B4%BB/"/>
    <id>https://www.orchidany.cn/2020/04/27/从零开始的数位DP生活/</id>
    <published>2020-04-27T09:13:20.000Z</published>
    <updated>2020-04-29T12:35:54.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…</p><p>冲冲冲！</p><a id="more"></a><h1 id="Luogu4317-花神的数论题"><a href="#Luogu4317-花神的数论题" class="headerlink" title="[Luogu4317] 花神的数论题"></a>[Luogu4317] 花神的数论题</h1><blockquote><p>话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\prod_{i=1}^{N}\text{sum}(i)$ ，也就是  $\text{sum}(1)\sim\text{sum}(N)$  的乘积。</p><p>对于 100% 的数据，$N≤10^{15}$ 。</p></blockquote><p><del>为什么花神出的题花不会呢，为什么为什么</del> 。</p><h1 id="LuoguP1822-魔法指纹"><a href="#LuoguP1822-魔法指纹" class="headerlink" title="[LuoguP1822] 魔法指纹"></a>[LuoguP1822] 魔法指纹</h1><blockquote><p>对于任意一个至少两位的正整数 $n$，按如下方式定义 $magic(n)$ ：将 $n$ 按十进制顺序写下来，依次对相邻两个数写下差的绝对值。这样，得到了一个新数，去掉前导 $0$，则定义为 $magic(n)$。若 $n$ 为一位数，则 $magic(n)=n$。</p><p>对任意一个数 $n$，序列 $n,magic(n),magic(magic(n)),…$ 迟早会变成一个一位数。最后的这个值称为数 $n$ 的 $magic$ 指纹。</p><p>对 $100\%$ 数据，$0&lt;A≤B≤1,000,000,000$ 。</p></blockquote><h1 id="loj10165-Windy数"><a href="#loj10165-Windy数" class="headerlink" title="[loj10165] Windy数"></a>[loj10165] Windy数</h1><blockquote></blockquote><p>咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…&lt;/p&gt;
&lt;p&gt;冲冲冲！&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/数位DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做·第3季</title>
    <link href="https://www.orchidany.cn/2020/04/26/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC3%E5%AD%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/简单题选做·第3季/</id>
    <published>2020-04-26T12:52:04.000Z</published>
    <updated>2020-04-30T23:44:09.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>终于！终于不是UVA了！</del></p><p>主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。</p><p>争取一句话题解…这一弹大概有 $30$ 道题左右吧。 </p><a id="more"></a><h1 id="Luogu4318-完全平方数"><a href="#Luogu4318-完全平方数" class="headerlink" title="[Luogu4318]完全平方数"></a>[Luogu4318]完全平方数</h1><blockquote><p>小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。</p><p>这天是小 X 的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小 X 讨厌的数。他列出了所有小 X 不讨厌的数，然后选取了第 K 个数送给了小 X。小 X 很开心地收下了。</p><p>然而现在小 W 却记不起送给小 X 的是哪个数了。你能帮他一下吗？</p><p>$K\leq 10^9$</p></blockquote><p>考察 $\mu$ 的容斥意义的神题 orz</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>发现 $\mu$ 函数的性质，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子，且 $x$ 的不同素因子个数为 $k$。</p><p>所以就考虑先二分，二分完了求一下 $1\sim x$ 中不是完全平方数倍数的数的数量是否 <code>&gt;mid</code>。考虑这个东西怎么求。发现根据容斥，可以知道应该是「有 $0$ 个不同质因子的平方的倍数数量」-「有 $1$ 个不同质因子的平方的倍数数量」+「有 $2$ 个不同质因子的平方的倍数数量」。</p><p>另一方面，考虑对着每个<strong>不含平方因子</strong>的数 $x$ 计数，计包含 $x^2$ 的数的个数。根据容斥可以得到答案应该是：</p><script type="math/tex; mode=display">\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \dfrac{n}{i^2}\rfloor</script><p>原理是，根据 $\mu$ 的性质，具有平方因子的数不会被统计，同时容器系数恰好就是 $\mu$。</p><p>这东西可以直接 $\sqrt n$ 求。复杂度 $T \cdot \sqrt n \log n$</p><p>顺便记录一个很绝的 <code>idea:</code></p><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p><script type="math/tex; mode=display">\sum _{i=1}^{x}\mu^2(x)\leq K</script><p>然后这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个东西一定程度上证明了</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \mu(i)^{2}=\sum_{i=1}^{\lfloor\sqrt{n}\rfloor} \mu(i)\left\lfloor\frac{n}{i^{2}}\right\rfloor</script><p>这其实是可以反演出来的。考虑对左边进行变形，令 $\zeta(x)$ 表示 $x$ 最大的平方因子。那么有</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^n\mu^2(i)\\=&\sum_{i=1}^n [\zeta(i)=1]\\=&\sum_{i=1}^n\sum_{d|\zeta(i)}\mu(d)\\=&\sum_{i=1}^n\sum_{d^2|\zeta(i)}\mu(d)\\=&\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d^2}\rfloor\\=&\sum_{d=1}^{\lfloor\sqrt n\rfloor}\mu(d)\lfloor\frac{n}{d^2}\rfloor\end{aligned}</script><p>其中第三个等号是借助了 $\mu$ 的性质：因为 $\zeta(i)$ 根据定义本身是一个完全平方数，所以如果 $d|\zeta(i)$ 但是 $d$ 不包含平方因子，说明 $d^2|\zeta(i)$ ；包含平方因子会被 $\mu(d)=0$ 直接干掉。最后一个等号是因为可以知道 $d&gt;\lfloor\sqrt n\rfloor$ 时最后一个因式恒为 $0$ 。</p><p>这似乎是某次听课听来的内容…但是当时并没有整理这个。想来已经是远古时期的回忆了。</p><h1 id="UVA1614-Hell-on-the-Markets"><a href="#UVA1614-Hell-on-the-Markets" class="headerlink" title="[UVA1614]Hell on the Markets"></a>[UVA1614]Hell on the Markets</h1><blockquote><p>给出一个数列 $\{a_n\}$，保证 $\forall i, 1\leq a_i\leq i$。求是否可以分成相等的两半，并给出方案。</p><p>$n\leq 10^5$。</p></blockquote><p>考虑一个引理。如果 $\forall i, 1\leq a_i\leq i$ 的话，那么 $\forall v\in[1,\sum_{j=1}^ia_j]\cap \mathbb{Z_+}$ 都可以被凑出来。 证明的话考虑数学归纳。即现在只需要证明 $[s_{i-1}+1,s_{i-1}+a_i]$ 可以被凑出来即可。发现对于一个 $s_{i-1}+k$ 而言，因为根据归纳 $[1,s_{i-1}]$ 都可以被 $a_1\sim a_{i-1}$凑出来且有 $s_i+k-a_i\leq s_{i-1}$ ，所以证毕。</p><p>那么综上，在判断 $v=\frac{\sum_{i=1}^na_i}{2}$ 是否可以被凑出来时，根据上面的贪心特性，要从后向前推，每次选择一个当前小于 $v$ 的最大值减掉即可。</p><h1 id="HNOI2011-数学作业"><a href="#HNOI2011-数学作业" class="headerlink" title="[HNOI2011]数学作业"></a>[HNOI2011]数学作业</h1><blockquote><p>给定正整数 $n,m$，要求计算 $\text{Concatenate}(n) \bmod  m$  的值，其中 $\text{Concatenate}(n)$ 是将 $1 \sim n$ 所有正整数 顺序连接起来得到的数。</p><p>$1\le n \le 10^{18}$，$1\le m \le 10^9$。</p></blockquote><p>…考虑递推，那自然是 $f_{i}=(f_{i-1}\cdot T+i)\bmod m$ 。其中 T 是根据不同的数字位数而变的这么一个计数器。于是就是分段矩乘即可。 </p><h1 id="Luogu5110-块速递推"><a href="#Luogu5110-块速递推" class="headerlink" title="[Luogu5110]块速递推"></a>[Luogu5110]块速递推</h1><blockquote><p><script type="math/tex">a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1</script> 。</p><p>求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。</p><p>$1\leq T\leq 5\times 10^7,1\leq n\leq 10^{18}$ 。</p></blockquote><p>朴素的矩乘是 $8\cdot \log n$ 的样子。这样算出来复杂度是 $O(8\cdot T\cdot \log n)$ ，好像很慢的样子。</p><p>于是考虑预处理一点东西。比较常见的方法当然就是分块来做，预处理 $a^{1},a^{2},a^{3}\cdots a^{\sqrt n},a^{2\cdot \sqrt n},a^{3\cdot \sqrt n}\cdots$ 这些。那么复杂度度转化成了 $O(\sqrt n\log\sqrt n+8\cdot T)$。</p><p>注意到可以借助扩展欧拉定理 $a^b\equiv a^{b\bmod \varphi(m)+\varphi(m)}\pmod{m}$ 使得复杂度变成 $O(\sqrt{Mod}\log\sqrt{Mod}+8\cdot T)$ 。信仰一波就过了。</p><h1 id="USACO13JAN-Seating-G"><a href="#USACO13JAN-Seating-G" class="headerlink" title="[USACO13JAN]Seating G"></a>[USACO13JAN]Seating G</h1><blockquote><p>有一排 $n$ 个座位，$m$ 次操作。</p><p>A操作：将 $a$ 名客人安置到最左的连续 $a$ 个空位中，没有则不操作。</p><p>L操作：$[a,b]$ 的客人离开。</p><p>求A操作的失败次数。</p><p>$n,m,10^5$ 。</p></blockquote><p>这…大概就是维护区间最长连续和然后再直接线段树上二分吧…发现自从领悟了线段树上二分之后，好多奇怪的线段树题也就都这么回事了…</p><h1 id="UVA1620-Lazy-Susan"><a href="#UVA1620-Lazy-Susan" class="headerlink" title="[UVA1620] Lazy Susan"></a>[UVA1620] Lazy Susan</h1><blockquote><p>现在有一个大转盘，上面有 $n$ 个珠子，分别写有 $1\sim n$ 之间的正整数。</p><p>给出这些珠子的排列方式，现在你可以每次翻转连续的四个珠子。问你至少要进行几次操作，才能将这个转盘上的珠子变成 $1,2,…,n-1,n$ 的排列方式。</p><p>$4\leq n\leq 10^6$ 。</p></blockquote><p>感觉还是比较有意思的题目？虽然是个结论题 233</p><p>首先考虑考虑序列中某段长度为 $x$ ，内部含有 $y$ 个逆序对的子段 $[l,r]$ 的性质：</p><p>(1) 该子段无论怎么重排，对 $[1,l-1]$ 的贡献不变，对 $[r+1,n]$ 的贡献不变。</p><p>(2) 该子段内部，顺序与逆序两种排布的逆序对数量之和为 $\frac{x^2+x}{2}$。</p><p>(3) 根据 $(1)$ 和 $(2)$ 可以得知，每次操作后，逆序对数量的变化量一定是 $(\frac{x^2+x}{2}-y)-y$ 。</p><p>回归到本题，可以知道每次逆序对的变化量肯定是 $6-2\cdot y$ 的形式。注意到序列翻转时，其他的指标都没有变，只有逆序对变了，所以可以用逆序对数量来衡量可达性。注意到每次增多/减少的数量都会是偶数，所以如果这个环不存在一个断裂使得逆序对数量为偶数，那么就不可以被变换成 $1,2,3,4\cdots n$ 。</p><p>这题原本的数据范围是 $10^3$ ，当然可以暴力枚举每个断裂。注意到，如果 $n$ 是奇数，且存在某个断裂的逆序对数也是奇数，那么这个环的所有断裂逆序对数都会是奇数。证明可以考虑，每次断裂的变化相当于把开头的元素移到结尾。那么假设当前开头元素是第 $k$ 大，那么可以知道这个元素会贡献 $n-k$ 个逆序对，移动到尾部后则会贡献 $k-1$ 个逆序对，$\Delta = k - 1 - n + k=2\cdot k - n - 1$ ，可知 $\Delta$ 本身一定是偶数。于是证毕，不可能出现偶数个逆序对的情况。</p><h1 id="APIO2012-派遣"><a href="#APIO2012-派遣" class="headerlink" title="[APIO2012]派遣"></a>[APIO2012]派遣</h1><blockquote><p>在这个帮派里，有一名忍者被称之为 Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。</p><p>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。</p><p>你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。</p><p>写一个程序，给定每一个忍者 $i$ 的上级 $B_i$ ，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$ ，输出在预算内满足上述要求时顾客满意度的最大值。</p><p><strong>简化版题面：给定一棵树，求</strong> </p><script type="math/tex; mode=display">\max_{u\in T}\{L_u\cdot t_u\}</script><p><strong>其中设</strong> $s$ <strong>是以</strong> $u$ <strong>为根的子树中的某个点集，</strong>$\mathrm{card}$ <strong>表示集合的元素个数， 则</strong></p><script type="math/tex; mode=display">t_u=\max_s\{\mathrm{card}(s)\cdot [ \sum_{i\in s} c_i\leq m]\}</script><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>读题读半天系列x</p><p>…发现是暴力，暴力选每个点当根，然后拿一个支持快速合并的数据结构对子树内的点进行合并，选出重量最小的那几个即可。注意到暴力合并的话似乎是要二分…这样一般而言复杂度就变成两个 $\log$ 了。但是如果每次插入完之后，统计答案时选择不断删掉当前 $c_i$ 最大的元素，这样就可以在保证正确性的同时降低询问的复杂度。发现可以直接拿左偏树来维护。复杂度 $O(n\log n)$ 。</p><h1 id="Luogu1858-多人背包"><a href="#Luogu1858-多人背包" class="headerlink" title="[Luogu1858]多人背包"></a>[Luogu1858]多人背包</h1><blockquote><p>01背包的前 $k$ 优解。</p><p>$k\le 50,m\le 5000,n\le 200$ .</p></blockquote><p>考虑暴力做并不简单，一个直观的想法就是再记一维 $k$ ，即 $f_{i,v,k}$ 表示考虑了前 $i$ 个物品，总体积为 $v$ 的 $k$ 优解是多少。考虑转移。通过观察单调性，可以发现当 $p&gt;q$ 时， $i-1,v$ 时的 $p$  优解是不会对 $i,v+w_i$ 时的 $q$ 优解产生贡献的，也就是说对于一个状态 $f_{i,v,k}$ ，都是从某个 $f_{i-1,v,j}$ 或者 $f_{i-1,v-w_i,j}+v_i$ 转移过来的。于是考虑直接把这两个状态集归并排序一下即可。复杂度 $O(n\cdot m\cdot k)$ 。</p><h1 id="SCOI2016-萌萌哒"><a href="#SCOI2016-萌萌哒" class="headerlink" title="[SCOI2016]萌萌哒"></a>[SCOI2016]萌萌哒</h1><blockquote><p>一个长度为 $n$ 的大数，用 $s_1s_2s_3 \cdots s_n$表示，其中 $s_i$ 表示数的第 $i$ 位， $s_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串$s_{l_1}s_{l_1+1}s_{l_1+2} \cdots s_{r_1}$与$s_{l_2}s_{l_2+1}s_{l_2+2} \cdots s_{r_2}$完全相同。</p><p>求本质不同的大数个数。</p><p>$1\le n\le 10^5$，$1\le m\le 10^5$ 。</p></blockquote><p>（以下默认并查集的复杂度是 $O(\log n)$ ，实际上这是一个很松的上界）</p><p>考虑暴力做当然是对每个位置开一个并查集，然后对于每个修改暴力 <code>for</code> 过去，这样最后答案就是 $9\cdot 10^{cnt-1}$ ，其中 $cnt$ 是不同的集合数量。这样做是 $O(nm\log n)$ 修改、$O(n\log n)$ 查询的。发现这样做的复杂度十分不平衡。考虑将复杂度向查询倾斜，即优化修改操作的复杂度。</p><p>考虑二进制拆分。对每个位置 $i$ 维护 $i\sim i+2^k-1$ 的连通状态，这样每次修改就是 $\log ^2n$ 的了。之后考虑对于一个长为 $2^k$ 的区间，可以push_down成两个长为 $2^{k-1}$ 的子区间再分别连边。于是查询的时候就可以直接查询了。</p><p>总复杂度 $O(m\log ^2n+n\log ^2 n)$ 。</p><h1 id="SCOI2010-生成字符串"><a href="#SCOI2010-生成字符串" class="headerlink" title="[SCOI2010]生成字符串"></a>[SCOI2010]生成字符串</h1><blockquote><p>lxhgww 最近接到了一个生成字符串的任务，任务需要他把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，但是任务还要求在组成的字符串中，在任意的前 $k$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。现在 lxhgww 想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？</p><p>$1\leq m,n\leq 10^6$ 。</p></blockquote><p>这…理论上如果没有个数限制的话就是卡特兰数了吧。</p><p>考虑一个转化，从 $(0,0)$ 开始出发，设当前点为 $(x,y)$ 每次如果遇到 $1$ 就走到 $(x+1,y-1)$ ，每次遇到 $0$ 就走到 $(x+1,y+1)$，那么最终就是走到 $(n+m,m-n)$ 的、不跨过直线 $x=0$ 方案数。这…似乎是一个十分经典的组合问题了。大概就是考虑把走到 $y=1$ 这条直线以下的那些路径全都翻转到 $y=1$ 以下（做镜像对称），那么就可以看做是从 $(0,2)$ 走到 $(n+m,m-n)$ 的方案数。所以答案就是两者相减。</p><p>考虑怎么算这两部分。发现本质上从 $(0,0)$ 走到 $(n+m,m-n)$ 、每次向右下或者右上走的方案数。一种比较简单的理解就是从 $n+m$ 步里面选出 $n$ 步向右下走的方案数，所以答案是 $\binom{n+m}{m}-\binom{n+m}{m-1}$ ，因为从 $(0,2)$ 开始走相当于把其中向上走的某一步魔改成了成了向下走的，所以 $m$ 要减一。</p><h1 id="SP19148-Kill-them-All"><a href="#SP19148-Kill-them-All" class="headerlink" title="[SP19148]Kill them All"></a>[SP19148]Kill them All</h1><blockquote><p>$n$ 只怪兽，每一次可让 Digo 杀或 Sharry 杀。求在每杀掉一只怪物后，Digo 的击杀数都比 Sharry 的击杀数多的方案数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>回顾历史的时候顺便发现了这道题…</p><p>大概就是上个题把 $\geq $ 换成了 $&gt;$ 。考虑首先让 $1$ 号怪兽必须被 <code>Digo</code> 干掉，那么就变成了从 $(1,0)$ 出发，走 $n-1$ 步，途中不能碰到 $y=0$ 的方案数。考虑最后走到的地方只会是 $(n,\lceil\frac{n}{2}\rceil),(n,\lceil\frac{n}{2}\rceil+1)\cdots (n,n)$，那么不妨对这些东西分别计数，那么答案就是</p><script type="math/tex; mode=display">1+\sum_{i=1}^{\lceil\frac{n}{2}\rceil-1}\left(\binom{n-1}{i}-\binom{n-1}{i-1}\right)</script><p>其中第一个 $1$ 是全部被 <code>Digo</code> 干掉的方案数。那么可以知道…这个式子里面前面的都被消掉了，最后只剩一个 $1+\binom{n-1}{\lceil\frac{n}{2}\rceil-1}-\binom{n-1}{0}=\binom{n-1}{\lceil\frac{n}{2}\rceil-1}$ 。 然后就没有然后了。</p><h1 id="UVA11149-Power-of-Matrix"><a href="#UVA11149-Power-of-Matrix" class="headerlink" title="[UVA11149]Power of Matrix"></a>[UVA11149]Power of Matrix</h1><blockquote><p>给定整数 $k$ 和一个 $n$ 阶矩阵 $A$ ，求 </p><script type="math/tex; mode=display">A+A^2+A^3+A^4+\cdots+A^k</script><p>$n\leq 100,k\leq 10^6$ 。</p></blockquote><p>这题其实有两种做法。一种做法是 $O(n^3\log k)$ 的，另一种也是 $O(n^3\log k)$ 的，只不过会多一个 $8$ 的常数。</p><h2 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑对着这个找规律（雾），大概是考虑分块做，发现原来的式子可以写成：</p><script type="math/tex; mode=display">A+A^2+A^3+\cdots +A^{\sqrt k}+A^{\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})+A^{2\cdot\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})\cdots</script><p>那么就可以预处理再做了。这样复杂度是 $O(n^3\sqrt k)$ 的，好像大概是 $10^9$ 的复杂度…过不去。</p><p>不过既然分块可以，那倍增应该也可以。具体的，可以这么化：</p><script type="math/tex; mode=display">A^1+A^1\cdot A^1 + A^2\times (A^1+A^2)+A^4\times(A^1+A^2+A^3+A^4)</script><p>那么这样就可以先预处理出 $n^3\log k$ 个 $A,A^2,A^4\cdots$ ，然后就可以再用 $n^3\log k$ 的时间预处理出 $s_1,s_2,s_4\cdots$ 其中 $s_i=\sum{A^i}$ 。之后就可以直接二进制拆分了。总复杂度 $n^3\log k$ 。</p><h2 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>考虑直接对所有矩阵的和进行递推。计 $A^u$ 为当前矩阵的 $u$ 次幂，那么不妨构造一个复合矩阵</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">s_i = \sum \limits_{j = 1}^{i}A^i</script><p>发现它可以这么转移：</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix} = \begin{bmatrix}A^{k-1}\\s_{k-1}\end{bmatrix}\cdot \begin{bmatrix}A &0\\I_n&I_n\end{bmatrix}</script><p>其中 $I_n$ 表示 $n$ 阶单位矩阵。然后就没有然后了。注意到这样做矩阵其实是升阶了，所以会带一个常数。</p><h1 id="SDOI2011-打地鼠"><a href="#SDOI2011-打地鼠" class="headerlink" title="[SDOI2011]打地鼠"></a>[SDOI2011]打地鼠</h1><blockquote><p>打地鼠是这样的一个游戏：地面上有一些地鼠洞，地鼠们会不时从洞里探出头来很短时间后又缩回洞中。玩家的目标是在地鼠伸出头时，用锤子砸其头部，砸到的地鼠越多分数也就越高。</p><p>游戏中的锤子每次只能打一只地鼠，如果多只地鼠同时探出头，玩家只能通过多次挥舞锤子的方式打掉所有的地鼠。你认为这锤子太没用了，所以你改装了锤子，增加了锤子与地面的接触面积，使其每次可以击打一片区域。如果我们把地面看做 $m\times n$ 的方阵，其每个元素都代表一个地鼠洞，那么锤子可以覆盖 $r\times c$ 区域内的所有地鼠洞。但是改装后的锤子有一个缺点：每次挥舞锤子时，对于这的区域中的所有地洞，锤子会打掉恰好一只地鼠。也就是说锤子覆盖的区域中，每个地洞必须至少有 $1$ 只地鼠，且如果某个地洞中地鼠的个数大于 $1$，那么这个地洞只会有 $1$ 只地鼠被打掉，因此每次挥舞锤子时，恰好有$r\times c$ 只地鼠被打掉。由于锤子的内部结构过于精密，因此在游戏过程中你不能旋转锤子（即不能互换 $r$ 和 $c$）。</p><p>你可以任意更改锤子的规格(即你可以任意规定 $r$ 和 $c$ 的大小)，但是改装锤子的工作只能在打地鼠前进行(即你不可以打掉一部分地鼠后，再改变锤子的规格)。你的任务是求出要想打掉所有的地鼠，至少需要挥舞锤子的次数。</p><p>Hint：由于你可以把锤子的大小设置为 $1\times 1$，因此本题总是有解的。</p><p>$1\leq m,n\leq 100$。</p></blockquote><p>以下是翻车现场，这题根本没有「行列无关」的性质：</p><blockquote><p>一道十分经典的行列无关技巧普及题目。但这题行列无？关比较的深刻。</p><p>考虑如果暴力枚举的话，复杂度大概是枚举 $r\times c$ 之后再一个一个打，这样复杂度是 $O(n^6)$，实现的好一点就可以 $O(n^4\log^2 n)$ 。但是，如果这题满足行列无关的话，就可以 $r$ 和 $c$ 分别枚举。准确来说，对于另一维设为 $1$，那么可以只去找这一维的最大值。考虑这么做判断的复杂度就是 $O(n^3)$，枚举的复杂度是 $O(n)$ 。那么最后总复杂度就是 $O(n^4)$ 。</p><p>那么唯一的问题在于如何证明行列无关在这题里面是对的。考虑对于所枚举的锤子大小所覆盖的某个区域，其中有两个点 $(a,b)$ 和 $(c,d)$ ，不同行也不同列，但是可以知道 $(a,b)$ 和 $(c,b)$ 的确定关系，$(c,d)$ 和 $(c,b)$ 的确定关系。即我断言，如果 $(a,b)$ 和 $(c,b)$ 满足同时合法，$(c,d)$ 和 $(c,b)$ 也同时合法，那么这三个点就可以同时合法，反之则不可以。</p><p>考虑这个断言为什么合理。发现每次如果以 $(c,b)$ 为量度去砸，那么 $(c,d)$ 和 $(a,b)$ 被砸的次数都只会与 $(c,b)$ 的地鼠数量有关，因为 $(c,b)$ 必须被精确砸完……</p><p><del>编不下去了，就当记结论了</del></p></blockquote><p>然后就是一个二维差分，然后就没了。</p><h1 id="Luogu1357-花园"><a href="#Luogu1357-花园" class="headerlink" title="[Luogu1357]花园"></a>[Luogu1357]花园</h1><blockquote><p>小 L 有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1 \sim n$。花园 $1$ 和 $n$ 是相邻的。</p><p>他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则：任意相邻 $m$ 个花圃中都只有不超过 $k$ 个 C 形的花圃，其余花圃均为 P 形的花圃。</p><p>请帮小 L 求出符合规则的花园种数对 $10^9+7$ 取模的结果。</p><p>$1\leq n\leq 10^{15},2\leq m\leq 5$。</p></blockquote><p>发现一共只有两种方格，并且转移只跟 $m$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p><p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，就可以快速幂了。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> u, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == m + <span class="number">1</span>)&#123;</span><br><span class="line">ok[s] = <span class="number">1</span> ;  </span><br><span class="line">ans.ma[s &gt;&gt; <span class="number">1</span>][s] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (u == k &amp;&amp; ~s &amp; <span class="number">1</span>) <span class="keyword">return</span> ;  </span><br><span class="line">ans.ma[(s &gt;&gt; <span class="number">1</span>)|st[m]][s] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line">dfs(x + <span class="number">1</span>, u, s) ; </span><br><span class="line"><span class="keyword">if</span> (u &gt;= k) <span class="keyword">return</span> ;   </span><br><span class="line">dfs(x + <span class="number">1</span>, u + <span class="number">1</span>, s | st[x]) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line">st[i] = (<span class="number">1</span> &lt;&lt; i) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; ans = expow(ans, n) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> &lt;&lt; m ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (ok[i]) add(res, <span class="number">1l</span>l * ans.ma[i][i], P) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA11134-Fabled-Rooks"><a href="#UVA11134-Fabled-Rooks" class="headerlink" title="[UVA11134]Fabled Rooks"></a>[UVA11134]Fabled Rooks</h1><blockquote><p>在一个 $n\times n$（$1\leq n\leq 5000$）的棋盘上放置 $n$ 个车，每个车都只能在给定的一个矩形( $x_{l_i},x_{r_i},y_{l_i},y_{r_i}$) 里放置，使其 $n$ 个车两两不在同一行和同一列，判断并给出解决方案。</p></blockquote><p>一道(真正)考察了行列无关知识的题目。</p><p>考虑放每个车时行与列显然是无关的，所以就可以分开做。那就是给定一堆区间，每个区间内选一个点使之不被放在同一个位置。贪一波就完了。</p><h1 id="NOI2005-瑰丽华尔兹"><a href="#NOI2005-瑰丽华尔兹" class="headerlink" title="[NOI2005]瑰丽华尔兹"></a>[NOI2005]瑰丽华尔兹</h1><blockquote><p>舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。</p><p>艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。</p><p>$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。K是时间段的数量，T 是总时间。</p></blockquote><p>考虑最朴素的 $dp$ 就是 $f_{t,i,j}$ 表示时刻 $t$ 时在位置 $(i,j)$ 结尾的最长路径。转移时 $O(1)$ 的。但由于状态数太高导致不得不放弃。发现本质上每段时间内，转移的方向唯一。所以可以按段来 $dp$ ，$f_{k,i,j}$ 表示经过了 $k$ 段之后，结尾于位置 $(i,j)$ 的最长路径。这样状态数就是 $O(nmk)$ 的、转移是 $O(\max\{n,m\})$ 的了。发现由于每一段决策区间单调，且决策点彼此之间存在单调性，于是可以拿单调队列优化到均摊 $O(1)$ 转移。</p><h1 id="BalticOI2008-Elect"><a href="#BalticOI2008-Elect" class="headerlink" title="[BalticOI2008]Elect"></a>[BalticOI2008]Elect</h1><blockquote><p>$n$ 个政党要组成一个联合内阁，每个党都有自己的席位数。 </p><p>现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。 </p><p>对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。</p><p>求最大席位并构造一组解。</p><p>$1\leq n\leq 300,1\leq m\leq 10^5$ 。</p></blockquote><p>大概是长个经验？</p><p>发现倒着贪心并不是对的…虽然观察数据范围发现 $O(nm)$ 可过，但是一般情况下很难想到要去背包，因为有一个「多余」的限制…</p><p>但是发现如果从大到小排完序之后再背包，当前加进去的东西一定是最小的。此时如果出现把这个东西拿出来，剩下的都一定比这个大。所以不难理解这么更新的正确性。</p><p>考虑如何记录方案。可以对于每种权值都开一个 <code>bitset</code>，对于每种权值，第一次更新的时候顺便更新 <code>bitset</code>（根据单调性这样一定是最合法的那个）。那么最后的复杂度就是 $O(nm+\frac{nm}{w})$。注意到这么写的意义在于，通过聚和分析可以得知，对于每个权值 $m$ 至多会与其他的价值 $or$ 一次，所以本质上是 $O(\frac{nm}{w})$ 而不是 $O(\frac{n^2m}{w})$（虽然也能过就是了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> half, sum ;</span><br><span class="line"><span class="keyword">int</span> i, v, ans, n ; </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; b[MAXM] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &gt; b.fr ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; f[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].fr) ;</span><br><span class="line">sum += base[i].fr, base[i].sc = i ; </span><br><span class="line">&#125;</span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, cmp) ; half = sum &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (v = sum ; v &gt;= base[i].fr ; v --)&#123; </span><br><span class="line"><span class="keyword">if</span> (!f[v] &amp;&amp; f[v - base[i].fr])</span><br><span class="line">b[v] = b[v - base[i].fr], b[v].<span class="built_in">set</span>(base[i].sc), f[v] = <span class="number">1</span> ;    </span><br><span class="line"><span class="keyword">if</span> (v &gt; half &amp;&amp; f[v] &amp;&amp; v - base[i].fr &lt;= half) ans = max(ans, v) ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[ans].count() &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (b[ans][i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LuoguP1531-鬼子进村"><a href="#LuoguP1531-鬼子进村" class="headerlink" title="[LuoguP1531]鬼子进村"></a>[LuoguP1531]鬼子进村</h1><blockquote><p>县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：</p><ol><li><p>若消息为 <code>D x</code>：鬼子将 $x$ 号房子摧毁了，地道被堵上。</p></li><li><p>若消息为 <code>R</code> ：村民们将鬼子上一个摧毁的房子修复了。</p></li><li><p>若消息为 <code>Q x</code>：有一名士兵被围堵在 $x$ 号房子中。</p></li></ol><p>李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。</p><p>$1\leq n,m\leq 5\times 10^4$。</p></blockquote><p><del>降智题，说实话我第一眼觉得那必然是 LCT；又觉得可达性不好统计，然后就懵了 1min</del></p><p>其实是有两种方法的：</p><h2 id="Sol-1-2"><a href="#Sol-1-2" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑暴力线段树维护，修复和拆毁都是单点修改。查询的话自然是查询一个点左边第一个 $0$ 的位置、右边第一个 $0$ 的位置。首先这显然是可以外层二分，内层区间查询来做到 $\log ^2$ 的（其实也可以不线段树维护，用分块技巧，$O(1)$ 查询区间和、 $O(\sqrt n)$ 单点加的分块，也可以通过本题，同时虽然插入删除都是 $O(\sqrt n)$ 的，但是询问变成了 $\log$ 的）；或者直接在线段树上二分，做到一个 $\log$ 。</p><h2 id="Sol-2-2"><a href="#Sol-2-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>发下有一个性质并没有很好利用起来<del>(虽然本身就是一个很没用的性质)</del>。每次删除的点一定是之前插入的点。所以考虑对于所有炸毁的点维护一棵平衡树，以 $pos$ 作为键值，那么每次查询本质上就是询问前驱和后继。</p><p>……还有要注意可能本身就被炸了，判一下就好了。这种方法也是 $1$ 个 $\log$ 的。</p><h1 id="AT3741-String-Problem"><a href="#AT3741-String-Problem" class="headerlink" title="[AT3741] String Problem"></a>[AT3741] String Problem</h1><blockquote><p>给出两个字符串S和T. 通过执行以下操作，判断是否可以将字符串S转换为字符串T.</p><ul><li>操作 A：删除S中任意位置的字母 A .</li><li>操作 B：在S的任意位置插入一个字母 B .</li></ul><p>S 和 T 的字符都为大写字母，并且 S 和 T 的长度 $\le 1000$ 。</p></blockquote><p>……其实是水题，不过发生了一些奇妙的事情，然后就打算整理一下我的做法？感觉其他人的做法都一毛一样…</p><p>大概就是首先根据样例解释的提示，可以想出一个「先加 B 再删 A」的思路，然后发现前半部分就是一个魔改的 LCS，后半部分就只需要记录一下最少要用多少个 B，看看 s 比 t 多的那些字符是否全是 A 就好了。</p><h1 id="Contest-Hunter5105-Cookies"><a href="#Contest-Hunter5105-Cookies" class="headerlink" title="[Contest Hunter5105] Cookies"></a>[Contest Hunter5105] Cookies</h1><blockquote><p>圣诞老人共有 $m$ 个饼干，准备全部分给 $n$ 个孩子。每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g_i$。如果有 $a_i$ 个孩子拿到的饼干数比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $g_i\times a_i$ 的怨气。给定 $n$、$m$ 和序列 $g$，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。</p><p>$1≤n≤30, n≤m≤5000, 1\leq g_i\leq 10^7$。</p></blockquote><p>首先不难想到要按照 $g_i$ 从大到小排个序，因为肯定要让 $g_i$ 大的人分到更多的饼干。之后设 $f_{i,j}$ 为前 $i$ 个人分了 $j$ 块饼干的最小怨气总和。发现并不好转移。因为要考虑有多少个人和 $i$ 获得的饼干数量相同。此时当然可以考虑多记一维，但是发现其实我们不关心饼干的具体数量，只关心彼此之间的相对关系。</p><p>考虑对于一个状态 $f_{i,j}$ ，如果让第 $i$ 个人只拿到 $1$ 个饼干，则考虑枚举前面有多少人同样拿了 $1$ 个饼干，此时有</p><script type="math/tex; mode=display">f_{i,j}=\min_{k=1}^i\{f_{i-k-1,j-k}+(i-k-1)\cdot \sum_{o=i-k}^ig_o\}</script><p>注意到次数由于钦定了后 $k$ 个人都拿 $1$ 个饼干，所以前后就无关了，需要重新计算这 $k$ 个人的贡献。</p><p>如果让第 $i$ 个人拿到 $&gt;1$ 块饼干，那么考虑由于不关心具体数量，所以这种情况等价于让所有人都少拿一块饼干，即 $f_{i,j}=f_{i,j-i}$ 。于是最后就对这两种情况取一个 $\min$ 即可。</p><h1 id="UVA1621-Jumping-Around"><a href="#UVA1621-Jumping-Around" class="headerlink" title="[UVA1621] Jumping Around"></a>[UVA1621] Jumping Around</h1><blockquote><p>一条 $[0,n]$ 数轴，一开始在 $0$ 处。每次可以选择向左/右以步长为 $1/2/3$ 跳到对应位置，分别只能最多跳 $a,b,c$ 次，保证 $a+b+c=n,a&gt;3,b&gt;3,c&gt;3$ 。求构造一种跳的方案，使得跳到 $1\sim n$ 每个位置恰好 $1$ 次。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>比较有趣的构造题吧…也是化归子问题的构造技巧。</p><p>考虑如果 $c=0$，如果此时 $a&gt;1$ ，那么可以先不断向右以步长为 $1$ 走，直到 $a=1$，然后考虑以步长为 $2$ 向右跳，跳到不能继续跳的时候考虑向左或者向右用一个 $a$，之后再以步长为 $2$ 向左跳回来。可以知道这样一定是合法的。</p><p>如果 $c&gt;0$ ，那么考虑化归到上一种情况。自然是想到，用完全部的 $c$ 跳到某个位置 $p$ 后，$1\sim p$ 都被覆盖了。这个地方有点神：</p><p>（1）如果 $3|c$，大概是考虑先用 $c/3$ 次跳到 $c$ ，然后向右用一个 $a$ ，再向左跳到 $1$ ，再向右用一个 $a$，再向右跳到 $c+2$ 。之后就变成了第一个问题。注意到由于 $a&gt;3$，所以这种方法总是可行的。</p><p>（2）如果 $3|(c+1)$ ，考虑向右用一个 $a$ 转化到 $(1)$ 的情况。发现 $(1)$ 最多需要用到 $3$ 个 $1$ 且 $a&gt;3$ ，这样做总是可行的。</p><p>（3）如果 $3|(c+2)$，考虑先向右一个 $c$ ，再向左一个 $b$，再向右一个 $a$。那么现在的 $c$ 的数量可以被 $3$ 整除。但是考虑由于(1)中的等价位置 $1$ 已经在第一次被跳了，所以最后一步要用 $b$ 。可以知道这样最多用 $2$ 个 $b$ ，也是合法的。 </p><h1 id="Luogu3795-钟式映射"><a href="#Luogu3795-钟式映射" class="headerlink" title="[Luogu3795]钟式映射"></a>[Luogu3795]钟式映射</h1><blockquote><p>设集合 $N=M=\left\{x|x\in N_+,x\leq k,k\in N_+\right\}$ 。设 $f$ 为 $N$ 到 $M$ 的映射。求满足 $f[f(x)]=x$ 的不同的映射 $f$ 的个数。</p><p>$k\leq 10^{8}$ 。</p></blockquote><p>说实话…我遇到这种题就会战术后仰然后不会…类似于什么置换啊、复合映射啊，我就蒙圈的很。</p><p>考虑新加入一个元素。对于一个 $x$，要么 $f(x)=x$，要么就会有一个 $y$ 和 $x$ 配对。所以有</p><script type="math/tex; mode=display">g_i=g_{i-1}+g_{i-2}\cdot (i-1)</script><p>然后就递推即可。</p><p>感觉这个式子本质上和错排可能会有点类似。考虑一个 $n-$完全错位排列 的方案数。假设 $n$ 号元素排到了 $k$ 号位置上，$k$ 号元素恰好也排在了 $n$ 号位置上，那么就是 $(n-1)\cdot g_{n-2}$ ；否则 $k$ 号元素随便错排，那么就是 $(n-1)\cdot g_{n-1}$。那么就是</p><script type="math/tex; mode=display">g_{i}=(i - 1)\cdot(g_{n-1}+g_{n-2})</script><p>感觉递推思想方面是有类似的吧…自己还是…太不聪明了啊</p><p>别找那些理由，就是泥萌的不努力！</p><h1 id="UVA1451-Average"><a href="#UVA1451-Average" class="headerlink" title="[UVA1451]Average"></a>[UVA1451]Average</h1><blockquote><p>给定一个长度为 $n$ 的 $01$ 串，选一个长度至少为 $L$  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 $1$ ~ $n$，因此 $[1,n]$ 就是完整的字符串。</p><p>$1\le n\le 100000,1\le L\le 1000$。</p></blockquote><p><del>又到了复习斜率优化的时间了，斜率优化，常读常新。</del></p><p>考虑前缀和一下就转化成了对每个 $i$ 找到一个 $j&lt;i$ 使得 $\frac{s_i-s_j}{i-j}$ 最大。发现这就是在求最大的斜率。考虑本质上 $x$ 坐标和 $y$ 坐标都是不降的，所以为了斜率单增，要维护一个下凸壳。于是拿一个单调栈维护斜率就好了。复杂度线性。</p><h1 id="HNOI2008-玩具装箱"><a href="#HNOI2008-玩具装箱" class="headerlink" title="[HNOI2008]玩具装箱"></a>[HNOI2008]玩具装箱</h1><blockquote><p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。</p><p>为了方便整理，P教授要求：</p><ul><li><p>在一个一维容器中的玩具编号是连续的。</p></li><li><p>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。</p></li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。</p><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$</p></blockquote><p>大概是斜率优化板板题？考虑方程：</p><script type="math/tex; mode=display">f_{i}=\min_{j=1}^{i-1}\{f_{j}+(i-j+s(i)-s(j)-L)^2\}</script><p>然后考虑拆一下，并且令 $p(i)=s(i)+i,q(i)=s(i)+i+L$ ，那么：</p><script type="math/tex; mode=display">f_{i}=f_{j-1}+(p(i)-q(j))^2=f_{j-1}+p(i)^2-2\cdot p(i)\cdot q(j)+q(j)^2</script><p>那么证明斜率优化可行的基本讨论就是找一个 $j$ 和一个 $k$ 来比大小：</p><p>若 $j&gt;k$ 且 $j$ 比 $k$ 优，那么有</p><script type="math/tex; mode=display">\begin{aligned}f_{j-1}-2\cdot p(i)\cdot q(j)+q(j)^2&<f_{k-1}-2\cdot p(i)\cdot q(k)+q(k)^2\\2\cdot p(i)\cdot q(k)-2\cdot p(i)\cdot q(j)&<f_{k-1}-f_{j-1}+q(k)^2-q(j)^2\end{aligned}</script><p>设 $X_i=q(i),Y_i=f_{i-1}-q(i)^2$，那么有</p><script type="math/tex; mode=display">2\cdot p(i)>\frac{Y_{k}-Y_{j}}{X_{k}-X_{j}}</script><p>也就说当这个式子满足的时候，存在 $j&gt;k$ 且 $j$  比 $k$ 优。</p><p>所以对此可以直接采用斜率优化。注意到 $X$ 单增的同时，斜率本身不降；同时据此可以知道应该维护一个上凸壳，所以可以直接取到队首进行转移的元素。复杂度线性。</p><h1 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="[HAOI2008]硬币购物"></a>[HAOI2008]硬币购物</h1><blockquote><p>共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。</p><p>某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。</p><p>$1 \leq c_i, d_i, s \leq 10^5$，$1 \leq n \leq 1000$。</p></blockquote><p>比较常规的容斥题目。考虑由于硬币个数的限制，大概是要做一个多重背包计数，这样复杂度是 $O(4\cdot n\cdot s)$，大概是 $4e8$ 的级别，如果常数小的话没准信仰一波也是可以过的。</p><p>考虑更加正经一点的做法。发现虽然硬币个数很多，但是种类很少，同时发现不限制使用次数的方案数是很好计算的，于是考虑容斥。$f_v$ 表示不考虑硬币个数，用四种面值凑出 $v$ 的方案数。那么考虑如何统计不合法的方案数。考虑对于一种硬币 $(c_i,d_i)$，看上去，所有他的不合法方案应该是 </p><script type="math/tex; mode=display">\sum_{j=d_i+1}^{+\infty} f_{s-c_i\cdot j}</script><p>但是发现背包模型在计算方案时，状态本身具有简并性。 也就是对于任何一个状态 $f_{i,k}$ 都是被更小的 $f_{i,k-t\cdot c_i}$ 给拼插起来的。所以方案数应该为</p><script type="math/tex; mode=display">f_{s-c_i\cdot (d_i+1)}</script><p>于是容斥一下即可。复杂度 $O(4\cdot s+16\cdot n)$ 。</p><h1 id="CF933A-A-Twisty-Movement"><a href="#CF933A-A-Twisty-Movement" class="headerlink" title="[CF933A]A Twisty Movement"></a>[CF933A]A Twisty Movement</h1><blockquote><p>给定一个序列 A，你可以翻转其中的一个区间内的数，求翻转后的序列的最长不下降子序列的长度。（$|A|\le 2000,1\le a_i \le 2$ ）</p><p>$1\leq n\leq 10^3$。</p></blockquote><p>自己想了一个暴力做法。大概是对于每个位置 $s$ ，可以比较方便地维护出 $s$ 之前以 $0/1$ 结尾的最长上升子序列，同时也可以维护出 $s$ 之后以 $0/1$ 开头结尾的最长上升子序列，这一部分不是那么直观，但是考虑对于一个位置 $p$ ，一定是有某个位置 $q&gt;p$ 使得 $p+1\sim q$ 之间只选 $0$，$q+1\sim n$ 之间只选 $1$ 。这个东西倒着预处理似乎可以 $poly(\log)$ 或者线性，但是由于数据范围所以可以直接暴力。然后每次枚举两个端点暴力即可。中间可能要进行一下玄学的 dp。</p><p>……但其实是可以直接暴力 $dp$ 的。考虑最后选取的一定是一个形如 $1…2….1…2…$ 的子序列，于是就可以设状态 $f_{i,0/1/2/3/4}$ 表示分成了 $0/1/2/3/4$  后的、形如这样的子序列。转移的话就是相邻状态转移即可。复杂度线性。</p><p>当然这题也存在一个闲的胃疼的高级做法，就是线段树上分别维护 $1 \rightarrow 1,1 \rightarrow 2,2 \rightarrow 1,2 \rightarrow 2$ 的最长上升子序列，然后暴力枚举每个区间，复杂度 $O(n^2\log n)$ 。</p><p>emmm 启发了一个 Idea 但是自己不会做，惨惨。</p><h1 id="LuoguP6435-「EZEC-1」数列"><a href="#LuoguP6435-「EZEC-1」数列" class="headerlink" title="[LuoguP6435] 「EZEC-1」数列"></a>[LuoguP6435] 「EZEC-1」数列</h1><blockquote><p>给你一个正整数 $n$，有数列 $\{a_n\}:1,2,3,…,n$。</p><p>分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：</p><p> $1\times a+2\times b+c,2\times a+3\times b +c,…,(n-1)\times a+n\times b+c$。</p><p>对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。</p><p>$1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$ 。</p></blockquote><p>…比较有意思的题目？本质上数学题。</p><p>考虑直接递推。设 $f_k$ 表示经历完 $k$ 次操作之后的第一项。那么考虑最开始 $a_2-a_1$ 的值是 $1$ ，之后每次会变成原来的 $(a+b)$ 倍，那么也就是有：</p><script type="math/tex; mode=display">f_{i}=a\cdot f_{i-1}+b\cdot (f_{i-1}+(a+b)^{i-2})+c</script><p>那么也就是</p><script type="math/tex; mode=display">f_i=(a+b)\cdot f_{i-1}+b\cdot(a+b)^{i-2}+c</script><p>考虑高中数学技巧</p><script type="math/tex; mode=display">\frac{f_i}{(a+b)^i}=\frac{f_{i-1}}{(a+b)^{i-1}}+\frac{b}{(a+b)^2}+\frac{c}{(a+b)^i}</script><p>那么可以通过差分得到</p><script type="math/tex; mode=display">f_i=(i-1)\cdot b\cdot (a+b)^{i-2}+(a+b)^{i-1}+c\cdot \sum_{j=0}^{i-2}(a+b)^j</script><p>发现前面很好算，后面是一个等比数列的形式。由于不保证 $p$ 是素数，所以不能直接求逆元。于是考虑分治乘法。具体的，对于一个 $\sum_{i=1}^n(a+b)^i$ 可以这么算：</p><script type="math/tex; mode=display">\sum_{i=1}^n(a+b)^i=\begin{cases}(a+b)^{\frac{n}{2}}\cdot \sum_{i=1}^{\frac{n}{2}}(a+b)^i+\sum_{i=1}^{\frac{n}{2}-1}(a+b)^i&\mathrm{if}~(n~\mathrm{is~even}) \\(a+b)^{\lfloor \frac{n}{2}\rfloor }\cdot \sum_{i=1}^{\lfloor \frac{n}{2}\rfloor }(a+b)^i+\sum_{i=1}^{\lfloor \frac{n}{2}\rfloor -1}(a+b)^i + (a+b)^n &\mathrm{otherwise}\end{cases}</script><p>然后就可以分治做下去了。复杂度 $\rm poly(\log )$ 。</p><h1 id="UVA1611-Crane"><a href="#UVA1611-Crane" class="headerlink" title="[UVA1611] Crane"></a>[UVA1611] Crane</h1><blockquote><p>输入 $n$ 个数，要求把它变成升序排列，每次操作都可以交换一个长度为偶数的区间的左右两半。要求操作数 $\leq 2n$ 。</p><p>$n\leq 10^6$ 。</p></blockquote><p>大概是一道降智题…</p><p>考虑一个逐步缩小问题规模的思想。元素从小到大考虑，每次把当前未考虑的数列中最小元素 $x$ 移动到他该在的位置 $x$。考虑 $pos_x-x$ 与$\frac{n-x+1}{2}$ 的大小关系，如果 $2\cdot(pos_x-x)+1\leq n-x+1 $，那么就可以直接对区间 $[x,2\cdot pos_x-x]$ 进行操作，否则要先对 $[x,pos_x]$ 进行操作使其不会越界，因为此时 $pos_x-x$ 的长度会缩短为原来的 $\frac{1}{2}$，而由于最长时 $pos_x-x=n-x$ ，所以可知这样一定不会越界。</p><h1 id="LuoguP5007-DDOSvoid-的疑惑"><a href="#LuoguP5007-DDOSvoid-的疑惑" class="headerlink" title="[LuoguP5007] DDOSvoid 的疑惑"></a>[LuoguP5007] DDOSvoid 的疑惑</h1><blockquote><p>给定一棵以 1 为根的有根树，定义树的一个毒瘤集为一个集合，并且集合中任意两个元素之间不存在祖先与后代关系。</p><p>定义一个毒瘤集的毒瘤指数为集合内所有元素的价值之和</p><p>要求给定树的所有毒瘤集的毒瘤指数之和，答案对 $10^8+7$ 取模。</p><p>但这个问题太难了，所以我们考虑化简。</p><p>因为点的编号跟它毒瘤指数密切相关，所以我们将会再给出一个整数 T，T = 1 表示 i 号点的毒瘤指数为 i，T = 0，表示所有点的毒瘤指数都是 1。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>懵了半天还是不会做……</p><p>不难发现这个可以以子树为状态来转移。然后考虑如何将孩子的贡献转移到根，发现需要处理的本质上是合并两棵树的所有毒瘤集。假设两棵树的毒瘤集权值和分别为 $F_1,F_2$，那么发现合并得到的 $F$ 应该至少为 $F_1+F_2$，并且还需要考虑两棵树对彼此的贡献。即将一棵树中的所有元素都分批合并进另一棵树的集合里产生的贡献。</p><p>那么不难知道要记录一下各自树中毒瘤集的个数。于是考虑从下向上 $dp$。设 $g_u$ 表示以 $u$ 为根的子树中毒瘤集的个数，$f_u$ 表示权值和。那么每次考虑将一棵新的子树 $v$ 并进来，所以有转移：</p><script type="math/tex; mode=display">g_u=g_v\times g_u+g_v+g_u\\f_u=f_u\times g_v+f_v\times g_u+f_u+f_v</script><p>复杂度 $O(n)$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;终于！终于不是UVA了！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。&lt;/p&gt;
&lt;p&gt;争取一句话题解…这一弹大概有 $30$ 道题左右吧。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="技巧/分块" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E5%9D%97/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="技巧/倍增" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%80%8D%E5%A2%9E/"/>
    
      <category term="数学/扩展欧几里德" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="数据结构/左偏树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
      <category term="暴力,brute-force" scheme="https://www.orchidany.cn/tags/%E6%9A%B4%E5%8A%9B-brute-force/"/>
    
      <category term="动态规划/状态合并" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="技巧/行列无关" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E8%A1%8C%E5%88%97%E6%97%A0%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round2] C~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-题解/</id>
    <published>2020-04-26T03:40:56.000Z</published>
    <updated>2020-04-26T12:23:44.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依旧是按照个人做题时认为的难度排序…</p><p>打比赛的时候严重翻车，比赛经验还是太差劲了啊！</p><p><del>于是这篇文章就变成了游记+翻车实录</del></p><a id="more"></a><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>作为苏打绿死忠的我…觉得普及这个 T1 题目背景and题目名称都很赞！</p><h1 id="C-涂色游戏"><a href="#C-涂色游戏" class="headerlink" title="C 涂色游戏"></a>C 涂色游戏</h1><blockquote><p>你有 $10^{20}$ 个格子，它们从 $0$ 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色：</p><ol><li>编号是 $p_1$ 倍数的格子（包括 $0$ 号格子，下同）染成红色。</li><li>编号是 $p_2$ 倍数的格子染成蓝色。</li><li>编号既是 $p_1$ 倍数又是 $p_2$ 倍数的格子，你可以选择染成红色或者蓝色。</li></ol><p>其中 $p_1$ 和 $p_2$ 是给定的整数，若格子编号是 $p_1$ 或 $p_2$ 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 $k$ 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 $p_1$, $p_2$, $k$，你想知道是否有一种染色方案不是无聊的。</p><p>对于所有测试点：$1 \leq T\leq 10^6$，$1\leq p_1,p_2,k\le 10^9$。</p></blockquote><p>以下是做题时凌乱的内心活动</p><blockquote><p>先开题…嗯，混乱地读了半天题，觉得大概是问是否存在一个 $x$ 和一个 $y$ 使得 $p_1&gt;p_2$ 时</p><script type="math/tex; mode=display">y\cdot p_1\leq x\cdot p_2\leq (x+k-1)\cdot p_2\leq (y+1)\cdot p_1</script><p>然后发现似乎很难处理编号是 $[p_1,p_2]$ 及其倍数的情况。然后就开始摸。摸了一会儿之后发现几个性质：</p><p>1、最多只用考虑 <code>yxyxy</code> 这种分布，即最多算上一个 $x$ 和 $y$ 的公倍数。因为如果存在连续两个 $x$ 和 $y$ 的公倍数之间，没有单独的 $y$ 的倍数，那么就说明 $x|y\cdot t,x|y\cdot (t+1)$，也就证明了 $x|y$ ，而这种情况是显然 <code>Yes</code> 的； </p><p>2、大概是每 $\rm lcm$ 一次循环…然后…</p></blockquote><hr><p>然后，读了半天题，才发现读题读反了…这题是要你去 <code>check</code> 是否对于任意一个 $y$ 都存在一个 $x$ 使得</p><script type="math/tex; mode=display">y\cdot p_1< x\cdot p_2< (x+k-1)\cdot p_2< (y+1)\cdot p_1</script><p>同时也不用考虑 $\rm lcm$ 的问题了，因为遇到 $\rm lcm$ 肯定会涂 $p_1$ 色。所以上式直接换成了拟序。</p><p>那么也就是考虑是否满足</p><script type="math/tex; mode=display">p_1-1\geq (k-1)\cdot p_2</script><p>其中为什么是 $p_1-1$ 呢？因为不考虑 $\rm lcm$ 时这就是最近的界。但是注意到这个界有点宽，当且仅当 $(p_1,p_2)=1$ 的时候，存在这种最劣的情况，即式子 $bp_2-ap_1=1$ 存在整数解。</p><p>然后大概就是个代换，发现同时除以 $(p_1,p_2)$ 之后与原结果是等价的。然后就没了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !y ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k, g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        n = qr(), m = qr(), k = qr() ; </span><br><span class="line">        g = gcd(n, m), n /= g, m /= g ;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ll)(k - <span class="number">1</span>) * min(n, m) &lt; max(n, m) - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-建设城市"><a href="#D-建设城市" class="headerlink" title="D 建设城市"></a>D 建设城市</h1><blockquote><p>球球是一位建筑师。一天，他收到市长的任务：建设城市。球球打算建造 $2n$ 座高楼。为了保证城市美观，球球做出了如下计划：</p><ul><li><p>球球喜欢整齐的事物。他希望高楼从左向右排成一行，编号依次为 $1\sim 2n$。</p></li><li><p>球球喜欢整数，他要求每座高楼的高度都是正整数。</p></li><li><p>由于材料限制，高楼的高度无法超过 $m$。</p></li><li><p>球球喜欢中间高，两边低的造型。他要求前 $n$ 座高楼的高度不下降，后 $n$ 座高楼的高度不上升。</p></li><li><p>球球打算选两座编号为 $x,y$ 的高楼作为这座城市的地标。他认为只有当这两座高楼高度相等时，才会让城市变得美观。</p></li></ul><p>球球把自己的想法告诉了市长。市长希望得知所有建设城市的方案数。两种方案不同，当且仅当某座高楼的高度在两个方案中不同。这个问题可难倒了球球。球球找到了你，希望你能帮他算出答案。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。</p></blockquote><p>下午 vp 这道题的时候是真的降智…首先先上已经写好的题解吧：</p><hr><p>首先考虑不加 $a_x=a_y$ 的限制，单纯计算一个不递减序列的方案数。</p><p>发现本质上是这么一个问题：从 $(0,1)$ 开始走，每一步可以向右走，或者向右上走（此处右上指的是 $(x,y)\to(x+1,y+k)\quad k&gt;0$ 的走法），最终走到 $(n,1),(n,2),(n,3)\cdots (n,m)$ 的方案数。那么不难发现，本质上是在对于两个楼之间的高度差进行拼插。若令 $h_0=0,d_{i}=h_{i}-h_{i-1}$ 的话， 那么本质上就是在解一个如下的方程：</p><script type="math/tex; mode=display">d_1+d_2+\cdots+d_n=m</script><p>本质上就是在求这个式子中非负整数解得个数…然而并不是。由于 $1$ 号楼必然高度 $\geq 1$ ，所以差分之后， 需要保证 $d_1&gt;0$ 。</p><p>考虑做一个容斥，用 $d_1\geq 0$ 的答案减去 $d_1=0$ 时的答案。对于 $d_1\geq 0$ ，本质上就是一个 $n$ 元一次不定方程非负整数解计数。那么答案就是 $\binom{n+m-1}{m}$ 。$d_1=0$ 时，相当于用 $n-1$ 个未知元凑出 $m$ 来，方案数就是 $\binom{n+m-2}{m}$ 。所以可知如果不考虑 $x$ 和 $y$ 的限制，答案应该为 $\left(\binom{n+m-1}{m}-\binom{n+m-2}{m}\right)^2$ 。</p><p>考虑加上 $x$ 和 $y$ 的限制。那么需要分类讨论。</p><p>1、考虑如果 $x$ 和 $y$ 在同侧，那么可以都转化到 $1\leq x\leq y\leq n$ 的情况来做。那么 $x,y$ 之间的数都要相等假设此时 $x$ 和 $y$ 均等于 $z$，那么 $1\sim x$ 的方案数就是 $\binom{x+z-1}{z}-\binom{x+z-2}{z}$ ，$y\sim n$ 的方案数就是 $\binom{n-y+z}{z}$，因为此时相相当于有 $n-y+1$ 个未知元，和为 $z$ 的非负整数解个数。最后把这两部分拼插一下即可。</p><p>2、考虑如果 $x$ 和 $y$ 在异侧，那么两者本质上就没有关系了。于是考虑分别处理 $1\sim x,1\sim y,x\sim n,y\sim n$ 的答案，最后拼插一下即可。</p><p>于是复杂度线性。</p><hr><p>然后是花絮…这题说实话我做了很久很久…以下事情按时间线排布：</p><ul><li>看了这题，觉得 $60$ 分很 ez，然后就在想 $100$ 分怎么搞。因为上次 NOIonline 给我的经验是，生成函数是可以进普及组的，于是觉得这个 100 一定是个生成函数。</li><li>wqy 说是 xxs 组合题。我想了一会儿觉得大概可以转化成从 $(0,1)$ 走到 $(n,m)$ ，每一步可以平着走或者飞到右边一列一个更高的高度上。算了一波，觉得可能跟 $m$ 的 $n$ 元可含 $0$ 有序拆分有关…觉得不太行。</li><li>wqy 说是插板法。我觉得自己是个弱智。因为「 $m$ 的 $n$ 元可含 $0$ 有序拆分」 本质上就是 $n$ 元一次不定方程组 <script type="math/tex; mode=display">x_1+x_2+\cdots +x_n=m</script></li></ul><p>的非负整数解组数。于是觉得枚举 $x$ 的高度然后做就很稳，遂开始写代码。</p><ul><li>写了半天，恍惚中觉得应该对 $\binom{n+m-1}{m}$ 这东西做一个前缀和，因为 $x$ 的高度如果是 $h$ ，那么 $x-1$ 的高度似乎可以是 $0\sim h$ …【注意！这个地方是有两个bug！！</li><li>连写带调试过了好久，发现自己是弟弟，前缀和压根不对。因为枚举的是 $x$ 的高度，所以对于每个 $x$ 的高度，$[1…x-1]$ 的不同方案已经被准确计数了…发现自己的思路乱的很。</li><li>又写了很久，还是不对，心情郁闷。冷静了一下发现 $1$ 号位置，即 $x_1$ ，取值不能为 $0$ 。想了想，觉得容斥一下就好了。</li><li>最后发现 $70$ 分。下了数据之后思考了一下，发现是 <code>case1</code> 里面，如果 $x$ 和 $y$ 都在另一侧，那么转过来应该是 $y&lt;x$…</li></ul><p>写完之后感觉自己花了这么多时间，十分弟弟。总结一下问题：</p><p>1、平时深入思考的情况比较少，遇到这种需要认真思考的东西，思路就会很乱很乱。</p><p>2、自己思维方式一直存在很大问题，加上草稿打的十分乱，就让人做题的时候内心不安静。</p><p>要抓紧改正啊。<del>虽然我觉得可能是我太困了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> num[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> numx[N] ;</span><br><span class="line"><span class="keyword">int</span> numy[N] ;</span><br><span class="line"><span class="keyword">int</span> xnum[N] ;</span><br><span class="line"><span class="keyword">int</span> ynum[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n, x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y ; ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m + n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[m + n + <span class="number">1</span>] = expow(fac[m + n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = (ll)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!((n - x &gt;= <span class="number">0</span>) ^ (n - y &gt;= <span class="number">0</span>)))&#123;</span><br><span class="line">        x = x &lt; n ? x : n - (x - n) + <span class="number">1</span> ;</span><br><span class="line">        y = y &lt; n ? y : n - (y - n) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) swap(x, y) ; numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = binom(n - y + i, i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) num[i] = addn(num[i - <span class="number">1</span>], decn(binom(n + i - <span class="number">1</span>, i), binom(n + i - <span class="number">2</span>, i))) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans, (ll)numx[i] % P * numy[m - i] % P) ;</span><br><span class="line">        ans = (ll)ans * num[m] % P ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    y = n - (y - n) + <span class="number">1</span> ;</span><br><span class="line">    xnum[<span class="number">0</span>] = ynum[<span class="number">0</span>] = numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = decn(binom(y + i - <span class="number">1</span>, i), binom(y + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) xnum[i] = binom(n - x + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ynum[i] = binom(n - y + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        add(ans, (ll)numx[i] % P * numy[i] % P * ynum[m - i] % P * xnum[m - i] % P) ; <span class="comment">//, cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-简单子序列问题"><a href="#E-简单子序列问题" class="headerlink" title="E 简单子序列问题"></a>E 简单子序列问题</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。</p><p>现在，请你求出 </p><script type="math/tex; mode=display">\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2</script><p>由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。</p><p>对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。</p></blockquote><p>这题似乎是普及题，但是我不知道为什么，就把这题转化到了这个题的对称问题上…导致这题做了很久很久很久…</p><p>以下是题解：</p><hr><p>我来说一个很不正常的解法…不正常在他特别麻烦…特别难调…</p><p>我的做法是先算出全部区间的贡献：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^n(j-i)^2=\sum_{i=1}^n(1^2+2^2+3^2+\cdots +(n-i)^2)</script><p>也就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{(n-i)(n-i+1)(2\times (n-i)+1)}{6}</script><p>然后考虑减掉那些不合法的。具体的，预处理出每个位置左边最近的那个相同颜色的下标 $pre_x$ 。那么 $x$ 和 $pre_x$ 会对左端点在 $1\sim pre_x$ ，右端点在 $x+1\sim n$ 的区间产生贡献。贡献怎么算呢？</p><p>考虑假设一个区间长为 $L$ 。那么第一组 $(pre_x,x)$ 出现时，会有</p><script type="math/tex; mode=display">L^2\to (L-1)^2=L^2-2L+1=L^2-(2L-1)</script><p>第二组出现时：</p><script type="math/tex; mode=display">(L-1)^2\to (L-2)^2=(L-1)^2-2(L-1)+1=(L-1)^2-(2L-3)</script><p>以此类推，当一个区间存在 $t$ 个重复颜色时（即假设某种颜色的数量为 $c$，那么这种颜色的「重复颜色数」为 $c-1$），他需要减去 $(2\cdot t\cdot L-t^2)$ 的贡献。</p><p>考虑拆成两半做：</p><p>1、$2\cdot t\cdot L$</p><p>需要枚举每个位置 $i$ ，设 $j=pre_i$ 。记 $p=\max\{(n-i+1),i\},q=\min\{i,(n-i+1)\}$ 。即 $p$ 是左右两边较长的那个区间，$q$ 是较短的那个。同时记当前区间长度为 $d$，即 $d=i-pre_i$ 。以下默认省略前面的系数 $2$ 。</p><p>那么需要再分三类讨论会被产生贡献的区间长度 $L$ ，以下在计算 $L$ 时，用 $d+\Delta$ 来代替：</p><blockquote><p>（1）$d+1\leq L\leq q+d$ </p><p>对于每个这样的 $L$ ，会存在 $L-d$ 个区间产生合法贡献，所以这部分贡献就是</p></blockquote><script type="math/tex; mode=display">\sum_{L=d+1}^{q+d}L\cdot i=\sum_{i=1}^{q}(d+i)\cdot i</script><blockquote><p>可以通过预处理 $\sum i$ ，$\sum i^2$ 快速计算。</p><p>（2） $q+d+1\leq L\leq p+d$ </p><p>对于每个这样的 $L$ ，由于不能全部取到，所以至多会有 $q$ 个。所以这部分贡献是：</p></blockquote><script type="math/tex; mode=display">\sum_{L=q+d+1}^{p+d}L\cdot q=\sum_{i=q+1}^{p}(d+i)\cdot q</script><blockquote><p>这部分比较好算。</p><p>（3） $p+d+1\leq L\leq n$</p><p>对于每个这样的 $L$ ，发现最多只能取到 $n-L+1$ 次。所以这部分贡献是</p></blockquote><script type="math/tex; mode=display">\sum_{L=p+d+1}^{n}L\cdot (n-L+1)=\sum_{i=p+1}^{n-d}(n-d-i+1)\cdot (d+i)</script><blockquote><p>这一部分同样可以通过预处理来快速计算。</p></blockquote><p>综上，这一部分的复杂度是排序外线性。</p><p>2、$-t^2$ </p><p>设 $i$ 右边第一个和 $i$ 同颜色的元素为 $r_i$ 。</p><p>也就是现在把问题转化成了「{区间内重复出现的数字个数 $-1$ 的平方和」。考虑扫描线。一开始将所有的数都加进线段树。从左开始，每次都删掉一个最左边的元素 $i$。如果这个元素的颜色依旧出现在后面的序列中，那么可以知道对于所有右端点 $\geq r_i$ 的区间，都会少掉一个 $(i, r_i)$ 组成的 <code>pair</code>，也就是会少掉一个重复颜色的元素。所以就是后缀减 $-1$ and 询问后缀的平方和，线段树维护即可。</p><p>这一部分复杂度 $O(n\log n)$ 。   </p><p>如何卡常：</p><p>1、不要用 <code>map</code> .</p><p>2、(mayaohua 在 uoj 群里的高论)发现中间，一段区间内部的平方的和本质上是不会爆 <code>long long</code> 的，所以可以减少取模次数。</p><hr><p>心路历程：</p><ul><li>A 完 T1 之后，发现这题「不就是记一下上次出现的位置，然后减掉左端点在 $[1,pre_x]$、右端点在 $[x,n]$ 内的贡献吗？妥了妥了！」<del>期间甚至嘲讽了一波这题很套路</del></li><li>算了一下发现…这个平方和好像很难算。一波拆分之后，觉得应该分成两半做。比较难的似乎是后面的 $t^2$(很久很久的以后我才发现不是这样)。</li><li>然后开始写写写，期间由于思路混乱(D里面提到的缺点集中展现)，于是写了一会儿才写完(但此时，我只想到了前两部分，没有考虑第三部分)。</li><li>写完之后才意识到…我似乎把这个问题转化到了一个和原问题等难的问题上…就很降智。然后决定先写 $50pts$ 的暴力做法。</li><li>写完暴力才意识到原来扫描线就好了…于是开始写线段树。</li><li>这个线段树我写的就…就很梦幻…我不记得我写过这么梦幻的线段树。大概就是 bug 满天飞…体验极差…</li><li>最终总算是调完了，和 $50pts$ 暴力对着拍了几组觉得很稳。</li><li>因为总觉得自己第一部分推的有问题，所以写了个 $n^3$ 暴力。写完才发现挂惨了…</li><li>冷静了很久，发现是自己推挂了。于是推了推第三部分，发现展开之后式子很长。然后 <code>main</code> 函数中间的那个 <code>for</code> 就写了很长…</li><li>最后在谷上测发现自己 TLE+取模挂了，于是把 <code>map</code> 改成 <code>sort+lower_bound</code> 就 A 掉了…</li></ul><p>…技不如人，技不如人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dec</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; x = x &lt; <span class="number">0</span> ? x + mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">addn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; <span class="keyword">return</span> (x = x &gt; mod ? x - mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">decn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; <span class="keyword">return</span> (x = x &lt; <span class="number">0</span> ? x + mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line">ll tg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] = val[l]  ;</span><br><span class="line">        t[rt] = s[rt] * s[rt] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(ls, l, mid) ;</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">s[rt] = s[ls] + s[rs] ;</span><br><span class="line">t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tg[rt])&#123;</span><br><span class="line">        ll p = tg[rt] * tg[rt] % P ;</span><br><span class="line">        ll pr = r - ((l + r) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">        ll pl = ((l + r) &gt;&gt; <span class="number">1</span>) - l + <span class="number">1</span> ;</span><br><span class="line">        tg[ls] += tg[rt], tg[rs] += tg[rt] ;</span><br><span class="line">        dec(t[ls], decn(<span class="number">2l</span>l * s[ls] * tg[rt] % P, p * pl)) ;</span><br><span class="line">        dec(t[rs], decn(<span class="number">2l</span>l * s[rs] * tg[rt] % P, p * pr)) ;</span><br><span class="line">        dec(s[ls], tg[rt] * pl % P) ; dec(s[rs], tg[rt] * pr % P) ; tg[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        dec(t[rt], decn(<span class="number">2l</span>l * s[rt] % P, <span class="number">1l</span>l * (r - l + <span class="number">1</span>))) ;</span><br><span class="line">        dec(s[rt], <span class="number">1l</span>l * (r - l + <span class="number">1</span>)) ; tg[rt] += <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    s[rt] = s[ls] + s[rs] ; t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ll res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) res += query(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) res += query(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll sum1[N] ;</span><br><span class="line">ll sum2[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll fuck[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">base[i] = tmp[i] = qr() ;</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) pos[i] = buc[base[i]] ; buc[base[i]] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        sum1[i] = addn(sum1[i - <span class="number">1</span>], i) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">sum2[i] = addn(sum2[i - <span class="number">1</span>], i * i)  ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(ans, (i + <span class="number">1</span>) * i * (<span class="number">2l</span>l * i + <span class="number">1l</span>l) % P) ;</span><br><span class="line">    ans = ans * Inv6 % P ;</span><br><span class="line">    ll q, maxx, minx, m, p, len1, len2, d ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos[i])</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">q = n - i + <span class="number">1</span> ;</span><br><span class="line">        maxx = q, minx = pos[i] ;</span><br><span class="line">        p = i - pos[i], m = n - p ;</span><br><span class="line">        d = decn(sum1[m], sum1[maxx]) ;</span><br><span class="line">        <span class="keyword">if</span> (minx &gt; maxx) swap(minx, maxx) ;</span><br><span class="line">        len2 = m - maxx, len1 = maxx - minx ;</span><br><span class="line">      <span class="comment">//part1</span></span><br><span class="line">        add(res, sum2[minx]) ;</span><br><span class="line">        add(res, sum1[minx] * p) ;</span><br><span class="line">      <span class="comment">//part2</span></span><br><span class="line">        add(res, p * minx * len1) ;</span><br><span class="line">        add(res, minx * decn(sum1[maxx], sum1[minx], P) % P) ;</span><br><span class="line">        <span class="comment">//part3</span></span><br><span class="line">        dec(res, <span class="number">2l</span>l * p * d % P) ;</span><br><span class="line">        dec(res, p * p * len2 % P) ;</span><br><span class="line">add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * d % P) ;</span><br><span class="line">dec(res, decn(sum2[m], sum2[maxx])) ;</span><br><span class="line">        add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * p * len2 % P) ;</span><br><span class="line">        dec(ans, <span class="number">2l</span>l * res % P) ; res = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">           fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                buc[base[j]] ++ ;</span><br><span class="line">                fuck[i][j] = fuck[i][j - <span class="number">1</span>] + (buc[base[j]] &gt; <span class="number">1</span>) ;</span><br><span class="line">                add(ans, fuck[i][j] * fuck[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        nxt[i] = buc[base[i]] ? buc[base[i]] : n + <span class="number">1</span>, buc[base[i]] = i ;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        buc[base[i]] ++, val[i] = val[i - <span class="number">1</span>] + (buc[base[i]] &gt; <span class="number">1</span>) ;</span><br><span class="line">    build (<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, i, n) % P) ;</span><br><span class="line">        <span class="keyword">if</span> (nxt[i] &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, nxt[i], n) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-游戏"><a href="#F-游戏" class="headerlink" title="F 游戏"></a>F 游戏</h1><blockquote><p>小 A 和小 B 正在玩一个游戏：有一棵包含 $n=2m$ 个点的有根树（点从 $1\sim n$ 编号），它的根是 $1$ 号点，初始时两人各拥有 $m$ 个点。游戏的每个回合两人都需要选出一个自己拥有且之前未被选过的点，若对手的点在自己的点的子树内，则该回合自己获胜；若自己的点在对方的点的子树内，该回合自己失败；其他情况视为平局。游戏共进行 $m$ 回合。</p><p>作为旁观者的你只想知道，在他们随机选点的情况下，第一次非平局回合出现时的回合数的期望值。</p><p>为了计算这个期望，你决定对于 $k=0,1,2,\cdots,m$，计算出非平局回合数为 $k$ 的情况数。两种情况不同当且仅当存在一个小 A 拥有的点 $x$，小 B 在 $x$ 被小 A 选择的那个回合所选择的点不同。</p><p>由于情况总数可能很大，你只需要输出答案对 $998244353$ 取模后的结果。</p><p>$n\leq 5000$ 。</p></blockquote><p><del>第一眼看到「期望」字样其实我是想弃的。</del></p><p>不算十分有趣的题，比较中规中矩地考察了<del>我没有的</del>硬实力。</p><p>考虑因为是随机选点，先要计算一个 $f_{i,j}$ 表示子树 $i$ 内凑出 $j$ 个不同的「非平局点对」的方案数。转移考虑两部分:</p><p>1、子树之间的贡献：就是普通的树上背包那么转移。注意到如果界定的好是可以 $n^3\to n^2$ 的。</p><p>2、根与子树之间的贡献：加法原理一波带走即可。</p><p>然后考虑 $f_{1,i}$ 就是整棵树凑出 $i$ 个不合法对，也就是不平局 $i$ 次的方案数。考虑利用这个东西，本质上还是很难求出共非平局 $k$ 次的方案数，因为无法快速统计剩下那些平局的贡献。但是考虑，可以快速计算出非平局 $\geq k$ 次的方案数，就是 $f_{1,k}\cdot (\frac{n}{2}-k)! $ 。至于为什么呢…可以理解为剩下 $n-2\cdot k$ 个人，固定住一半个人，剩下一半的人随便找一个匹配，那么方案数就是剩下一半人的全排列，即 $(\frac{n-2\cdot k}{2})!$ 。</p><p>那么考虑令 $f_i$ 表示至少非平局 $i$ 次的方案数，设 $g_i$ 为恰好平局 $i$ 次的方案数，那么根据二项式反演有 </p><script type="math/tex; mode=display">f_i=\sum_{j=i}^{m}g_j\binom{j}{i}\cdot (-1)^{j-i}</script><p>于是复杂度 $O(n^2)$，略卡常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll F[N] ;</span><br><span class="line">ll G[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll tmp[N] ;</span><br><span class="line">ll f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> suma[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll comb[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span> ; f[x][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa)</span><br><span class="line"><span class="keyword">continue</span> ; do_dp(to(k), x) ;</span><br><span class="line">fill(tmp, tmp + size[to(k)] + size[x] + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = min(size[x], n / <span class="number">2</span>) ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = min(size[to(k)], n / <span class="number">2</span> - i) ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f[to(k)][j])</span><br><span class="line">add(tmp[i + j], f[x][i] * f[to(k)][j] % P, P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size[x] + size[to(k)] ; ++ i) f[x][i] = tmp[i] ;</span><br><span class="line">        suma[x] += suma[to(k)] ; size[x] += size[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line"><span class="keyword">if</span> (!base[x])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(size[x] - suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(".in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">//freopen(".out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, fac[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]), suma[i] = base[i] ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add_e(u, v) ; do_dp(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>], P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        F[i] = f[<span class="number">1</span>][i] * fac[n / <span class="number">2</span> - i] % P ;</span><br><span class="line"><span class="comment">//debug(f[1], 0, n) ; debug(F, 0, n) ; debug(fac, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(G[i], F[j] * comb[j][i] % P, P) : dec(G[i], F[j] * comb[j][i] % P, P) ;</span><br><span class="line">    debug(G, <span class="number">0</span>, n / <span class="number">2</span>, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是太弱啊…不过打这一场比赛确实很浪费精力，毕竟一道线段树+一道 xxs 组合加起来我能调 $7h$ 也是相当弱菜了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是按照个人做题时认为的难度排序…&lt;/p&gt;
&lt;p&gt;打比赛的时候严重翻车，比赛经验还是太差劲了啊！&lt;/p&gt;
&lt;p&gt;&lt;del&gt;于是这篇文章就变成了游记+翻车实录&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round1] A~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/24/NOIOLRound1-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/24/NOIOLRound1-题解/</id>
    <published>2020-04-24T11:47:41.000Z</published>
    <updated>2020-04-29T13:12:52.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…</p><p>于是就打算整理一下这六道题。感觉…还是有点东西的吧。</p><p>题目难度按我自己心目中的升序排序。</p><blockquote><p>心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。</p></blockquote><a id="more"></a><h1 id="A-文具订购"><a href="#A-文具订购" class="headerlink" title="A 文具订购"></a>A 文具订购</h1><blockquote><p>小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：</p><ol><li>圆规，每个 $7$ 元。</li><li>笔，每支 $4$ 元。</li><li>笔记本，每本 $3$ 元。</li></ol><p>小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：</p><ol><li>$n$ 元钱必须正好用光，即 $7a+4b+3c=n$。</li><li>在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。</li><li>在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。</li></ol><p>请你帮助小明求出满足条件的最优方案。可以证明若存在方案，则最优方案唯一。</p><p>对于全部的测试点，保证 $0 \leq n \leq 10^5$。</p></blockquote><p>考虑贪心。发现大概是 $14$ 元一套，于是就从 $\lfloor\frac{n}{14}\rfloor$ 枚举到 $0$ 。如果钱数不是 $14$ 的倍数，当然是把剩下的用来买 $3$ 和 $4$ 最合理。于是就模拟一遍即可，同时再去找 $a+b+c$ 的最大值。大概是 div2B 的难度？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = n / <span class="number">14</span> ;</span><br><span class="line">    <span class="keyword">while</span> (ans &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        outp = <span class="number">0</span> ;</span><br><span class="line">        a = b = c = ans ;</span><br><span class="line">        pq = a * <span class="number">14</span>, res = n - pq ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= res / <span class="number">3</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> ((res - i * <span class="number">3</span>) % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                outp = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> * ans + i + (res - i * <span class="number">3</span>) / <span class="number">4</span> &gt; a + b + c)</span><br><span class="line">                    b = ans + (res - i * <span class="number">3</span>) / <span class="number">4</span>, c = ans + i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (outp)</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c) ;</span><br><span class="line">        <span class="keyword">else</span> ans -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-冒泡排序"><a href="#B-冒泡排序" class="headerlink" title="B 冒泡排序"></a>B 冒泡排序</h1><blockquote><p>给定一个 $1 ∼ n$ 的排列 $p_i$，接下来有 $m$ 次操作，操作共两种：</p><ol><li>交换操作：给定 $x$，将当前排列中的第 $x$ 个数与第 $x+1$ 个数交换位置。</li><li>询问操作：给定 $k$，请你求出当前排列经过 $k$ 轮冒泡排序后的逆序对个数。</li></ol><p>对一个长度为 $n$ 的排列 $p_i$ 进行一轮冒泡排序的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1 to n-1:</span><br><span class="line">  if p[i] &gt; p[i + 1]:</span><br><span class="line">    swap(p[i], p[i + 1])</span><br></pre></td></tr></table></figure><br>对于所有测试点：$2 \leq n,m \leq 2 \times 10^5$，$t_i \in \{1,2\}$，$1 \leq x &lt; n$，$0 \leq k &lt; 2^{31}$。</p></blockquote><p>这题在考场上写了神必线段树…复杂度也不对…就很弱智。</p><p>大概就是首先要去洞见冒泡排序的一个性质。每轮冒泡排序会让每个元素排到他后面第一个比他大的元素之前，把最大的元素移到序列最后。假设这是一对 $(i,j)$ ，$j$ 是 $i$ 后面第一个大于 $i$ 的元素。那么考虑这个操作使得， $i$ 移动到 $j$ 前面一个位置，同时所有 $x$ 之间不会彼此交换。</p><p>回顾这一过程，发现 $i+1\le x\le j-1$ 的所有 $x$ 的逆序对(此处特指 $x$ 与 $1\sim x-1$ 形成的逆序对)数量都会向前移动一位且不变(中间只会进行跟 $i$ 有关的操作)，且由于本质上 $i$ 与前面构成的逆序对数量等于 $j$ 与前面构成的逆序对数量 (因为此时并不存在一个比 $i$ 小的 $k$ 满足 $a_k&gt;a_i$ ，因为根据冒泡排序这会让 $a_i$ 被 $a_k$ 换掉成为前面某个「对」的 $x’$) ，所以此时 $j$ 的逆序对数为 $0$，那么 $i$ 的逆序对数也为 $0$ 。</p><p>更进一步，本题相当于需要维护一个序列 $\{p_n\}$，支持：</p><p>1、单点加/减（维护初始逆序对数</p><p>2、询问</p><script type="math/tex; mode=display">\left(\sum_{p_i>k} p_i\right)-\left(\sum_{p_i > k} k\right)</script><p>考虑这东西就拿一个树状数组维护一下权值就好了。复杂度 $m\log n$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    <span class="keyword">int</span> p ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &lt; y.v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= n ; p += low(p)) b[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += b[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] += c1 ;</span><br><span class="line">        t[rt] += c2 ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, c1, c2) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, c1, c2) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    t[rt] = t[rt &lt;&lt; <span class="number">1</span>] + t[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask1(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask1(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask2(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask2(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> t, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].v), base[i].p = i ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        res[base[i].p] = ask(base[i].p) ;</span><br><span class="line">        ans += res[base[i].p] ; add(base[i].p, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, res[i], res[i], <span class="number">1</span>) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;c) ;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(res[c], res[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], -res[c], <span class="number">-1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], -res[c + <span class="number">1</span>], <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (base[c].v &lt; base[c + <span class="number">1</span>].v) </span><br><span class="line">res[c + <span class="number">1</span>] ++ ; <span class="keyword">else</span> res[c] -- ;  </span><br><span class="line">            swap(base[c], base[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], res[c], <span class="number">1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], res[c + <span class="number">1</span>], <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ret ;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = ask1(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line">                ret -= (ll)c * ask2(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; c &lt;&lt; " " &lt;&lt; ask1(1, 1, n, c + 1, n) &lt;&lt; " " &lt;&lt; ask2(1, 1, n, c + 1, n) &lt;&lt; endl ;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>最后还是写的线段树，略略略</del></p><h1 id="C-跑步"><a href="#C-跑步" class="headerlink" title="C 跑步"></a>C 跑步</h1><blockquote><p>小 H 是一个热爱运动的孩子，某天他想给自己制定一个跑步计划。小 H 计划跑 $n$ 米，其中第 $i(i \geq 1)$ 分钟要跑 $x_i$ 米（$x_i$ 是正整数），但没有确定好总时长。</p><p>由于随着跑步时间增加，小 H 会越来越累，所以小 H 的计划必须满足对于任意 $i(i &gt;1)$ 都满足 $x_i \leq x_{i-1}$。</p><p>现在小 H 想知道一共有多少个不同的满足条件的计划，请你帮助他。两个计划不同当且仅当跑步的总时长不同，或者存在一个 $i$，使得两个计划中 $x_i$ 不相同。</p><p>由于最后的答案可能很大，你只需要求出答案对 $p$ 取模的结果。 </p><p>对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq p &lt; 2^{30}$。</p></blockquote><p>发现就是整数拆分问题。分拆数问题本质上是 $n$ 也无标号的第二类斯特林数问题（第二类斯特林数是 $n$ 有标号但是 $k$ 无标号）。</p><p>那么对于这个问题，考虑两种 $dp$.</p><ul><li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}+f_{i-j,j}</script><p>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢掉一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</p><ul><li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script><p>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</p><p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p><p>但是上述做法是 $n^2$ 的。总结两个 $dp$ 的优劣，发现如果采用根号分治的策略，对于 $f$ 只转移 $&lt; \sqrt n$ 的，对于 $g$ 只转移 $\geq \sqrt n$ 的，那么两者均只需要 $n\sqrt n$ 的时空代价（因为大于 $\sqrt n$ 的数不会用超过 $\sqrt n$ 个）。</p><p>具体的，考虑对先用 $f$ 求出来 $j&lt; \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字：就是第一维把 $\sqrt n$ 当作步长转移即可。</p><p>之后考虑如何合并答案。发现 $f,g$ 对于同一个 $n$，计数的部分互斥且互补，那么就可以直接乘法原理解决。合并是个卷积状物，但由于本题只需要求第 $n$ 项，所以直接算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">403</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, p ;</span><br><span class="line"><span class="keyword">int</span> f[N][B] ;</span><br><span class="line"><span class="keyword">int</span> g[N][B] ;</span><br><span class="line"><span class="keyword">int</span> X[N], Y[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">    S = n / B + <span class="number">1</span> ; X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; B ; ++ i) f[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; B ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) f[i][j] = f[i][j - <span class="number">1</span>] ;</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p ;</span><br><span class="line">            X[i] = f[i][j] ; <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; X[i] &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span> ; Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S &amp;&amp; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B) (g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) (g[i][j] += g[i - j][j]) %= p ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S ; ++ j)</span><br><span class="line">            (Y[i] += g[i][j]) %= p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        (ans += <span class="number">1l</span>l * X[i] * Y[n - i] % p) %= p ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-序列"><a href="#D-序列" class="headerlink" title="D 序列"></a>D 序列</h1><blockquote><p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p><p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p><p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p><p>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in \{1,2\}$，$1\le u_i,v_i \le n$。</p></blockquote><p>被教育了，我大概并查集这方面就是白痴中的战斗机了。</p><p>考虑大概能琢磨出这么几个没啥用的性质：1、如果 $a,b$ 和 $b,c$ 两对之间分别被 $1$ 相连，那么相当于 $a$ 和 $c$ 被 $1$ 相连；2、如果 $a,b$ 之间 $0$ 相连，$b,c$ 之间 $0$ 相连，那么可以知道 $a$ 和 $c$ 就相当于有一条 $1$ 边。</p><p>然后…大概就可以搞一个边带权并查集了。同一个集合内部如果只有 $1$ 边，那么总和可以随意分配；如果某个集合内部向自己连了 $1$ 边和 $0$ 边，那么就可以让某两个元素同时加减，只要和是偶数即可。</p><p>其实也不难吧…还是自己过于弱菜啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> D[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x] ;</span><br><span class="line">    <span class="keyword">int</span> dad = find(fa[x]) ;</span><br><span class="line">    val[x] ^= val[fa[x]] ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = dad ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2)</span><br><span class="line">res[f1] |= val[x] ^ val[y] ^ c ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">val[f1] = val[x] ^ val[y] ^ c ;</span><br><span class="line">        fa[f1] = f2 ; res[f2] |= res[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sign</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> t, u, v, ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            val[i] = f[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">fa[i] = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), D[i] = A[i] - B[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;u, &amp;v) ;</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">1</span>) t -= <span class="number">2</span> ; merge(t, u, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">f[i] += D[i] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f[p] += get_sign(val[i]) * D[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p != i) f[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (res[i] &amp;&amp; f[i] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[i] != <span class="number">0</span>)  &#123; ans = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">puts</span>(ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-魔法"><a href="#E-魔法" class="headerlink" title="E 魔法"></a>E 魔法</h1><blockquote><p>C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。</p><p>现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。</p><p>注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 </p><p>$1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。</p><p>$1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。</p></blockquote><p>其实也不难？考虑暴力做的话就是分层图最短路，状态数是 $O(nk)$ 的。可以拿到洛谷数据的 $70$ 分。大概就是先拿每条边预处理出 $f_{i,j,1}$ 表示 $(i,j)$ 之间只修改了 $1$ 次的答案。考虑转移的话，自然就是以 $1$ 为步长转移(小技巧，只用枚举最小规模的子问题)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; ll w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; pq ;</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">-1</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i ^ j) dis[i][j] = (ll)<span class="number">1e12</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w) ;</span><br><span class="line">        A[u][v] = w, dis[u][v] = min(dis[u][v], w) ;</span><br><span class="line">        edg[i][<span class="number">0</span>] = u, edg[i][<span class="number">1</span>] = v, edg[i][<span class="number">2</span>] = w ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = dis[i][j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = edg[k][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">int</span> y = edg[k][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                f[i][j][<span class="number">1</span>] = min(f[i][j][<span class="number">1</span>], dis[i][x] + dis[y][j] - (ll)edg[k][<span class="number">2</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= pq ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= n ; ++ o)</span><br><span class="line">                    f[i][j][k] = min(f[i][j][k], f[i][o][k - <span class="number">1</span>] + f[o][j][<span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">if</span> (!pq) <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n][pq] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最后的转移形式为 </p><script type="math/tex; mode=display">f_{i,j,k}=\min_{o}\{f_{i,o,k-1}+f_{o,j,1}\}</script><p>这是一个扩展矩乘的形式。所以可以直接把预处理出来的 $f_{i,j,1}$ 作为矩阵的元素，快速幂即可。</p><h1 id="F-最小环"><a href="#F-最小环" class="headerlink" title="F 最小环"></a>F 最小环</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $a_i$，下标从 $1$ 开始编号。我们将该序列视为一个首尾相邻的环，更具体地，对于下标为 $i$, $j(i \leqslant j)$ 的两个数 $a_i$, $a_j$，它们的距离为 $\min(j-i, i+n-j)$。</p><p>现在再给定 $m$ 个整数 $k_1$, $k_2$,…, $k_m$，对每个 $k_i(i=1$, $2$,…, $m)$，你需要将上面的序列 $a_i$ 重新排列，使得环上任意两个距离为 $k_i$ 的数字的乘积之和最大。</p><p>对于所有测试数据：$1 \leqslant m \leqslant n \leqslant 2 \times 10^5$，$0 \leqslant k \leqslant \lfloor n/2\rfloor$，$1 \leqslant a_i \leqslant 10^5$。</p></blockquote><p>为什么把这题放在 F 呢？因为一方面我最优化比较菜，另一方面我一看这种题就有种「信我，你不会」感觉233</p><p>这居然是个贪心…我也是人傻掉… 感觉自己贪心真的是菜爆了啊！</p><p>首先考虑相邻的元素大概是 $t~,~t+k~,~t+2\times k~,~t+3\times k~,~t+4\times k\cdots \pmod{n}$ 这种。记这个数列为「$t$ 在模 $n$ 意义下关于 $k$ 的轨迹」。</p><p>那么可以解一下方程求得循环节的长度：</p><script type="math/tex; mode=display">t\equiv t+p\times k\pmod n</script><p>根据同余的基本性质可以得出</p><script type="math/tex; mode=display">p\equiv 0\pmod {\frac{n}{(n,k)}}</script><p>那么可以知道最小的循环长度为 $\frac{n}{(n,k)}$ 。那么最多就会有 $(n,k)$ 条不同的轨迹。</p><p>另一方面，如果存在两个不同的 $t_0,t_1$，他们某一刻轨迹产生了相交，即</p><script type="math/tex; mode=display">t_0+p\times k\equiv t_1+q\times k\pmod{n}</script><p>那么会有</p><script type="math/tex; mode=display">(t_0-t_1)\equiv k\times (q-p)\pmod n</script><p>因为这个式子等价于一个一元二次不定方程，可知如果这个式子可以解出一组整数解，必须满足 </p><script type="math/tex; mode=display">(n,k)|(t_0-t_1)</script><p>那么也就是说，如果两个 $t$ 的轨迹有相交，那么需要这两个 $t$ 之间的距离是 $(n,k)$ 的倍数。这也间接证明了，至多只会有 $(n,k)$ 条本质不同的轨迹。</p><p>考虑根据排序不等式，乘积方面一定是大的和大的拼在一起，小的和小的拼在一起更优。所以可以预处理每个不同的环长 $\zeta$ ，对于每一个 $\zeta$，把从大到小排好序的 $a_i$ ，$a_1\sim a_{\zeta}$ 分到第一组，$a_{\zeta+1}\sim a_{2\cdot \zeta}$ 分到第二组，以此类推。考虑对于同一组，最好的放的方式就是类似这样：</p><script type="math/tex; mode=display">\ldots n-3,n-1,n,n-2,n-4\ldots</script><p>于是就可以按照奇偶性分个类预处理了。复杂度 $O(nd(n)+m\log n)$ 。后面那个 $\log$ 是求 $\gcd$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ll ans ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line">ll res[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base, base + n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j += i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i - <span class="number">2</span> ; ++ k)</span><br><span class="line">                    res[i] += (ll)base[j + k] * (ll)base[j + k + <span class="number">2</span>] ;</span><br><span class="line">                res[i] += (ll)base[j] * (ll)base[j + <span class="number">1</span>] ;</span><br><span class="line">res[i] += (ll)base[j + i - <span class="number">1</span>] * (ll)base[j + i - <span class="number">2</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">ans += (ll)base[i] * (ll)base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) ;</span><br><span class="line"><span class="keyword">if</span> (!k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[n / gcd(n, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树状数组</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…&lt;/p&gt;
&lt;p&gt;于是就打算整理一下这六道题。感觉…还是有点东西的吧。&lt;/p&gt;
&lt;p&gt;题目难度按我自己心目中的升序排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】我说啊…</title>
    <link href="https://www.orchidany.cn/2020/04/21/%E6%88%91%E8%AF%B4%E5%95%8A/"/>
    <id>https://www.orchidany.cn/2020/04/21/我说啊/</id>
    <published>2020-04-21T10:05:06.000Z</published>
    <updated>2020-04-29T12:59:31.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。</p><p>我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。</p><p>我要学的还有很多。</p><p>我一直在路上。</p><a id="more"></a><h1 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h1><p>今天和我校生物奥赛同僚偶然突然提到了「支撑下去的信念」这个话题。自己其实一直很迷惑吧。从今年不知道什么时候开始，感觉自己就是在混日子，一天混过来再混一天。斯嘉丽的那句 _After all, Tomrrow is another day!_ 倒是和我的想法不谋而合——只不过是 _another new_ 和 _another numb_ 罢了。</p><p>于是我的回答自然是模棱两可，并且向他表达了自己的质疑「我就不明白了，为什么大家这么多人都在这里拼啊？都拿银牌以上不显然是不可能的吗？」</p><p>他想了想，说「我们教练说，竞赛锻炼的是一种能力，学竞赛的目的也应该是锻炼能力、锻炼一种可以让你学文化课时、办事时、将来学习时都有用的能力」。</p><p>我突然愣了愣。不是愣在这个观点的新颖，而是愣在我之前，再早、再早一些的时候，仿佛也用这句话劝说过别人。总之，我清楚地记得我说过、坚信过类似的内容…但…</p><p>但不知道什么时候，我仿佛已经忘记了自己的初心。一天天一天天，我一直在拿「我没有别人那么喜欢OI，所以不努力也可以理解」来搪塞自己、坚信 OI 是高智商对低智商的剥削，看到曾经自己的文字「不要功利地学 OI」时开始变得麻木、甚至有些纳闷——看着当时自己对这个世界的劝告，才发现「活成你最讨厌的人」与我仅有咫尺…我迷茫了。</p><p>他又问：「你的目标是什么？」</p><p>我：……</p><p>他：「没事的。目标就是要去寻找的嘛，人活着不就是去寻找活着的目标吗？就算找了很久找不到，这也是一种精彩的人生吧。」</p><p>我愣了愣。看着一旁洒进食堂的阳光，周围的嘈杂在那一刹那仿佛消失不见了；筷子掉到桌子上，发出悠长的回响，不绝于耳。</p><h1 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h1><p>总会因为奇奇怪怪的事情陷入东亚式情绪内卷…</p><p>感觉有很多事情都是自讨没趣。自己找来痛苦让自己承受。习惯痛苦之后，积极的生活态度反而让人感到陌生…</p><p>争取逐渐削弱这个内卷的过程吧。</p><h1 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h1><p>郁郁寡欢…不过山崎将义的「One more time, one more chance」里面倒是提过</p><blockquote><p>如果只是缓解寂寞，随便一个人就可以了吧。</p></blockquote><p>…我一直把这个当做信条。自己会经常期许很多不能得到的东西、不能传达的心意。如果这么想的话，可能自己会稍微好受一点吧。</p><p>感觉自己从未真正变得成熟过…</p><h1 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h1><p>我…很烦「浮躁」的感觉。如果每天不给我几分钟，让我去仔细思考一下人生，我就会感到难以入睡。</p><p>我才发现，虽然我很向往热烈，但是骨子里还是喜欢孤独一人的感觉。自由、不受约束。身上不需要承担那些若有若无的责任…我向往人与人之间的羁绊，但我同时也在一直回避这些。</p><h1 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h1><p>最近一直很忙，忙着把自己之前做过的题都复习一遍，不给自己的青春留下遗憾。</p><p>计数啦，刘汝佳的紫书/蓝书啦，李煜东的书啦…都是我未尽的回忆。</p><p>我就像一个小心翼翼的孩子，认真地找回失落的每一块拼图，笨笨地拼回原处…拼的东倒西歪，但算不上不满意。</p><p>就这样吧。尽我所能，把自己丢下的、落下的，一件一件拾起来。</p><p>但…我还没有看过远处的风景啊，现在就要准备沿途返回了吗？我不甘心的吧？</p><p>可能，有些人属于这里，有些人不属于这里。这有点宿命论的意味——虽然我是不信的，但你不得不说，有时候这东西似乎就是贯穿万事万物的那一条透明的线，引领着每个人走向自己的终章。</p><p>终章之后呢？是一片新的天地吧。</p><p>但…还是最好不要停下来吧。</p><h1 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h1><p>我被关在笼子里。</p><p>周围密布的…是黑色。</p><p>外面…似乎也套着笼子。这个机房是笼子，这栋综合楼是笼子，这个学校是笼子。</p><p>要继续说下去的话，这个城市，这个地区，这个世界都是笼子。似乎找不到任何一缕自由的风。</p><p>虽然我看不见——因为最靠近我的这个笼子已经将我的双眼层层蒙蔽。但我坚信。</p><p>其实我是被自己的心关起来的，我自己很清楚。</p><p>我不断地反复，跟自己博弈、决斗、撕扯、争吵…最终是赢了呢？还是输了呢？我只知道无论输赢，我都还是停留在这个笼子里。</p><p>所以，外界可能并不存在什么笼子，罩着我的只有一层笼子，其余的只是我内心积攒的恐惧而已。</p><p>但是…虽然自己提出了疑问，但是我依然相信外面是有笼子的、数不清的那种…</p><p>是的，这种寄托方式，是坚信。区分「坚信」和「迷信」的根据大概就是，坚信可以包容质疑，但是迷信从来不容置疑。</p><p>你看我为数不多的信念，也只能用在这种地方了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。&lt;/p&gt;
&lt;p&gt;我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。&lt;/p&gt;
&lt;p&gt;我要学的还有很多。&lt;/p&gt;
&lt;p&gt;我一直在路上。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】RE:从零开始的计数生活</title>
    <link href="https://www.orchidany.cn/2020/04/21/RE-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E6%95%B0%E7%94%9F%E6%B4%BB/"/>
    <id>https://www.orchidany.cn/2020/04/21/RE-从零开始的计数生活/</id>
    <published>2020-04-21T09:19:55.000Z</published>
    <updated>2020-04-29T12:35:43.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是整理一下自己做过的计数题？</p><p>感觉有很多题都很神(不)仙(会)。慢慢来吧…</p><p>感觉其实本质上考察的还是 dp 功底+组合技巧/能力。</p><p>总的来说，如果没有计数头脑(个人认为是可以练出来的)的人，遇到这种题一般要么是 <code>dfs</code>/子集枚举，要么是状压，大概是常见比赛里面 $3/5/7/10$ 这档最低的部分分…所以计数这东西如果不是天赐之才，其实是需要深入研究的吧。</p><p><del>等会儿，我扯这些干什么？扯这些能帮我学会计数吗？</del></p><a id="more"></a><p><del>咕咕咕咕咕，只写了题面，题解留给大家自行思考</del></p><h1 id="BJWC2018-最长上升子序列"><a href="#BJWC2018-最长上升子序列" class="headerlink" title="[BJWC2018]最长上升子序列"></a>[BJWC2018]最长上升子序列</h1><blockquote><p>现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。$n\leq 20$ 。</p></blockquote><p>其实是把数据范围改小了，原题是个打表题233</p><p>考虑观察最长上升子序列的性质。记 $h_i$ 为截止到前 $i$ 位中最长上升子序列的长度，同时设 $g_{i}=\max_{j=1}^i\{h_j\}$ ，那么可以知道</p><script type="math/tex; mode=display">g_{i}\leq g_{i+1}\leq g_{i}+1</script><p>发现这个序列差分之后正好是 $01$ 串，不妨设 $\{g_n\}$ 的一阶差分是 $\{d_n\}$，于是考虑对着这个东西 $dp$ 。即设 $f_{i,s}$ 表示以 $i$ 结尾的，差分序列是 $s$ 的排列数。考虑从小向大插入每个数。假设当前的 $x$ 插在原来的串的 $i$ 和 $i+1$ 之间，那么因为 $x$ 比之前任何一个数都大，那么可以知道 $h’_{i+1}=h_i+1$ ，同时假设存在某个 $k&gt;i$ 使得 $a_k$ 是第一个大于 $a_i$ 的数，那么可以知道根据差分，应该将 $d_k$ 置为 $0$ ，所以从大到小扫的时候不断更新即可。</p><p>于是最后复杂度 $O(2^n\cdot n^2)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> fac[N] ; </span><br><span class="line"><span class="keyword">int</span> size[M] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][M] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)_bit[i] = <span class="number">1</span> &lt;&lt; i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">size[i] = size[i -(i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//debug(_bit, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(size, 1, m) ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> ; </span><br><span class="line">fill(f[d ^ <span class="number">1</span>], f[d ^ <span class="number">1</span>] + t + <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span> ; s &lt;= t ; ++ s)&#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">2333</span> ; </span><br><span class="line">add(f[d ^ <span class="number">1</span>][s &lt;&lt; <span class="number">1</span>], f[d][s]) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &gt;= <span class="number">0</span> ; -- k)&#123;</span><br><span class="line"><span class="keyword">int</span> t = (s &gt;&gt; k) &lt;&lt; (k + <span class="number">1</span>) ; </span><br><span class="line">t  |= _bit[k], t |= (_bit[k] - <span class="number">1</span>) &amp; s ; </span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; s) pos = k ; </span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">2333</span>) t ^= _bit[pos + <span class="number">1</span>] ;</span><br><span class="line">add(f[d ^ <span class="number">1</span>][t], f[d][s]) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">d ^= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line"><span class="comment">//debug(fac, 1, n) ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">add(ans, (<span class="keyword">int</span>)(<span class="number">1l</span>l * f[(n - <span class="number">1</span>) &amp; <span class="number">1</span>][i] * (size[i] + <span class="number">1</span>) % P)) ;</span><br><span class="line">ans = (ll)ans * expow(fac[n], P - <span class="number">2</span>) % P ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AGC002-F-Left-Most-Ball"><a href="#AGC002-F-Left-Most-Ball" class="headerlink" title="[AGC002 F]Left Most Ball"></a>[AGC002 F]Left Most Ball</h1><blockquote><p>给你 $n$ 种颜色的球，每个球有 $k$ 个，把这 $n\times k$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色(初始球不包含白色)，求有多少种不同的颜色序列，答案对 $10^9+7$ 取模。</p><p>$1\leq n, k\leq 2000$。</p></blockquote><h1 id="CQOI2011-放棋子"><a href="#CQOI2011-放棋子" class="headerlink" title="[CQOI2011]放棋子"></a>[CQOI2011]放棋子</h1><blockquote><p>在一个 $m$ 行 $n$ 列的棋盘里放一些颜色在 $1\sim c$ 之间的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？</p><p>$1\le n,m\le 30$，$1\le c\le 10$，总棋子数 $\le \min(250,n\times m)$。</p></blockquote><h1 id="LuoguP5241-序列"><a href="#LuoguP5241-序列" class="headerlink" title="[LuoguP5241] 序列"></a>[LuoguP5241] 序列</h1><blockquote><p>构建一个 $n$ 个点的有向图 G，初始没有任何边。</p><p>接下来构建一个长度为 E 的边的序列 A，序列中每条边都是满足 $1≤s,t≤n$ 且 $s≠t$ 的有向边 $(s,t)$，且序列中的边互不相同。按照顺序把这些边加入到 G 中，每次加入后计算当前图的强连通分量个数并记录下来，得到一个新的长度为 E 的正整数序列 B。如果两个边的序列得到的 B 相同则称它们本质相同。</p><p>请问有多少种本质不同的边的序列，</p><p>$1\leq n\leq 400$ 。</p></blockquote><h1 id="SDOI2010-地精部落"><a href="#SDOI2010-地精部落" class="headerlink" title="[SDOI2010]地精部落"></a>[SDOI2010]地精部落</h1><blockquote><p>传说很久以前，大地上居住着一种神秘的生物：地精。地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 $N$ 的山脉 $H$ 可分为从左到右的 $N$ 段，每段有一个<strong>独一无二</strong>的高度 $H_i$ ，其中 $H_i$ 是 $1$ 到 $N$ 之间的正整数。</p><p>如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。</p><p>地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。</p><p>地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。</p><p>地精们希望这 $N$ 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。</p><p>现在你希望知道，长度为 $N$ 的可能有地精居住的山脉有多少种。两座山脉 $A$ 和 $B$ 不同当且仅当存在一个 $i$，使得 $A_i≠B_i$。由于这个数目可能很大，你只对它除以 $P$ 的余数感兴趣。</p><p>对于 $100\%$ 的数据，满足 $3≤N≤4200$，$P≤10^9$。</p></blockquote><h1 id="ARC074C-RGB-Sequence"><a href="#ARC074C-RGB-Sequence" class="headerlink" title="[ARC074C]RGB Sequence"></a>[ARC074C]RGB Sequence</h1><blockquote><p>有一个序列 $\left\{a_{n}\right\}$，要给序列中的每个元素一种颜色：红/绿/蓝。有 $m$ 条限制 $(l,r,x)$，表示格子 $l\sim r$ 中颜色的种类数要恰好为 $x$，问可行的方案数。</p><p>$ 1\leq n,m\leq 300 $ 。</p></blockquote><h1 id="ARC071D-Infinite-Sequence"><a href="#ARC071D-Infinite-Sequence" class="headerlink" title="[ARC071D] Infinite Sequence"></a>[ARC071D] Infinite Sequence</h1><blockquote><p>定义 $n-$可爱序列 指无限长的由 $\{1,2…,n\}$ 组成的序列。同时 $a_1,a_2…$满足以下条件:</p><p>1.第 $n$ 个及以后的元素是相同的，即若 $\forall i,j\geq n,a_i=a_j$ 。</p><p>2.对于每个位置 $i$，紧随第 $i$ 个元素后的 $a_i$ 个元素是相同的，即若 $\forall  i&lt;j&lt;k≤i+a_i,a_j=a_k$。</p><p>输入 $n$，请输出 $n-$可爱序列的数量 $\bmod 10^9+7$ 。</p><p>$n\leq{10^6}$。</p></blockquote><h1 id="Luogu-P5464-缩小社交圈"><a href="#Luogu-P5464-缩小社交圈" class="headerlink" title="[Luogu]P5464 缩小社交圈"></a>[Luogu]P5464 缩小社交圈</h1><blockquote><p>社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。</p><p>现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。</p><p>请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。</p><p>$1\leq n\leq 2000,1\leq l_i,r_i\leq 4000$ 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分大概是整理一下自己做过的计数题？&lt;/p&gt;
&lt;p&gt;感觉有很多题都很神(不)仙(会)。慢慢来吧…&lt;/p&gt;
&lt;p&gt;感觉其实本质上考察的还是 dp 功底+组合技巧/能力。&lt;/p&gt;
&lt;p&gt;总的来说，如果没有计数头脑(个人认为是可以练出来的)的人，遇到这种题一般要么是 &lt;code&gt;dfs&lt;/code&gt;/子集枚举，要么是状压，大概是常见比赛里面 $3/5/7/10$ 这档最低的部分分…所以计数这东西如果不是天赐之才，其实是需要深入研究的吧。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;等会儿，我扯这些干什么？扯这些能帮我学会计数吗？&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模型" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做·第二弹</title>
    <link href="https://www.orchidany.cn/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
    <id>https://www.orchidany.cn/2020/04/21/简单题选做·第二弹/</id>
    <published>2020-04-21T09:19:23.000Z</published>
    <updated>2020-04-27T06:38:01.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感觉自己真的是菜成一团…</p><p>感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？</p><p>可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？</p><p>人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。</p><p>Hide your skill from your clumsiness, make you fast in slowly.</p><p>本文共计 15 道题。</p><a id="more"></a><h1 id="UVA1407-Caves"><a href="#UVA1407-Caves" class="headerlink" title="UVA1407 Caves"></a><a href="https://uva.onlinejudge.org/external/14/p1407.pdf" target="_blank" rel="noopener">UVA1407 Caves</a></h1><blockquote><p>给定一棵 $n$ 个节点、边带权的树。$q$ 次询问，每次给定一个 $x$ ，询问从根出发走多少个点，满足走过的边权和 $&lt;x$ 且经过的点最多。点可以重复经过，但只会被计算一次。</p><p>$n\leq 500,q\leq 10^5,x\leq 5\cdot 10^8$ 。</p></blockquote><p>一个比较基础的思想是背包，但这时空显然不是背包能做的。这个地方考虑，点数只有 $500$，也就是至多只能走 $500$ 个点。于是就考虑把状态定义到点上，即 $f_{x,j}$ 表示以 $x$ 为根走了 $j$ 个不同的点的最小代价。注意到由于可以重复经过，所以多记一维 $0/1$ ，即 $f_{x,j,0/1}$ 表示以 $x$ 为根走了 $j$ 个不同的点，最终没回到/回到了 $i$ 的最小代价。考虑转移：</p><script type="math/tex; mode=display">\begin{aligned}f_{x,j,1}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,1}+w\times 2\} \\f_{x,j,0}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,0}+w,f_{x,k,0}+f_{y,j-k,1}+w\times 2\} \end{aligned}</script><p>其中第二个转移表达的是这条路径的终点是否在以 $y$ 为根的子树内。注意转移的时候要倒序枚举 $j$ ，保证当前转移不重复。</p><p>发现 $f_{root}$ 显然是单调的，于是回答询问时二分即可。复杂度 $O(n^2+q\log n)$ 。因为好像有证明，这种东西的复杂度是 $O(n^2)$ 的…</p><h1 id="BZOJ4160-Exclusive-Access-2"><a href="#BZOJ4160-Exclusive-Access-2" class="headerlink" title="BZOJ4160 Exclusive Access 2"></a><a href="https://darkbzoj.tk/problem/4160" target="_blank" rel="noopener">BZOJ4160 Exclusive Access 2</a></h1><blockquote><p>给出 $n$ 个点 $m$ 条边的无向图，定向得到有向无环图，使得最长路最短。</p><p>$1\leq n ≤ 15, 1\leq m ≤ 100$ .</p></blockquote><p>大概是 $\rm dilworth$ 定理的应用，考虑 $\rm dilworth$ 定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $m$ 是反链的最大长度。则 $X$ 可以被划分成 $m$ 个但不能再少的链。 即：链的最少划分数 $=$ 反链的最长长度.。</p></blockquote><p>同时也存在对偶定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $r$ 是其最长链的大小。则 $X$ 可以被划分成 $r$ 个但不能再少的反链。</p></blockquote><p>也就是：</p><blockquote><p><strong>偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong> 。</p></blockquote><p>其中「全序集」指的是这样的一个偏序集 $(Y,\leq )$ ，改偏序集内部所有元素两两<strong>均可比</strong>。反链则指的是这样一个偏序集 $(Z,\leq )$ ，改偏序集内部所有元素两两均<strong>不可比</strong>。</p><p>换言之，假设给原图定向，那么根据 dilworth 定理，最长链的长度就是最小的独立集的大小，其中「独立集」的定义为原无向图中距离大于 $1$ 的两个点可以组成一个独立集(不考虑连通性)，因为只要两者没有边相连，两者的关系就是「不可比」。</p><p>于是这东西就可以状压了。$f_{s}$ 表示 $s$ 集合中最少有多少个独立集。这东西就可以先预处理一下每个 $s$ 是否是独立集，然后 $3^n$  暴力 $dp$ 即可。</p><h1 id="POJ3735-Training-little-cats"><a href="#POJ3735-Training-little-cats" class="headerlink" title="POJ3735 Training little cats"></a><a href="http://poj.org/problem?id=3735" target="_blank" rel="noopener">POJ3735 Training little cats</a></h1><blockquote><p>现在给你一个长度为 $n$ 的序列，开始这个序列都是 0。对这个序列一共有三种操作：</p><p>操作 1：输入一个 $x$，把 $x$ 位置上的值 $+1$ 。</p><p>操作 2：输入一个 $x$ 一个 $y$，交换 $x$，$y$ 位置上的值。</p><p>操作 3：输入一个 $x$，把 $x$ 位置上的值变成 $0$ 。</p><p>我们接着对这个序列进行 $k$ 次操作。</p><p>我们把这 $k$ 次操作叫做一轮，现在这个 $k$ 个操作进行了 $m$ 轮。</p><p>输出最后的序列。</p><p>$1\leq n\leq 100,1\leq k\le 10^4,1\leq m\leq 10^9$ 。</p></blockquote><p>…矩阵快速幂神题 sto</p><p>考虑一开始把这个空的序列记作一个 $n+1$ 维向量 $A:[1,0,0\cdots,0]$ 。其中第一维留空赋值为 $1$ ，$2\sim n+1$ 分别代表序列的第 $1\sim n$ 号元素。</p><p>那么考虑由于 $m$ 比较大，但是每次操作都是一样的，于是启发要用矩阵快速幂。</p><p>考虑三个操作，以下默认右乘转移矩阵 $T$ 、位置 $p,q$ 都是原序列右移一位的位置。</p><p>1、位置 $p$ 的数 $+1$ 。</p><p>考虑对于 $n+1$ 阶单位矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&0&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>考虑如何使得乘上这个矩阵的某个变形之后，位置 $p$ 实现 $+1$ 。考虑矩阵运算的本质是 $c_{i,j}=\sum_{k}a_{i,k}\cdot b_{k,j}$ ，那么 $A’_{1,p}=\sum _{i=1}^{n+1}A_{1,i}\cdot T_{i,p}$ ，因为 $A_{1,1}$ 恒定为 $1$ ，所以可知应该让 $T_{1,p}=1$ 实现 $+1$ 的功能。比如 $p=2$ ：</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&1&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>2、交换位置 $p,q$ 的数。</p><p>还是考虑 $n+1$ 阶单位矩阵。观察矩阵乘法本质，$A’_{1,q}=\sum_{i=1}^{n+1}A_{1,i}T_{i,q}$ ，那么一方面要让之前 $q$ 位置的数消失，一方面又要让 $A’_{1,q}=A_{1,p}$ ，于是应该让 $T_{q,q}=0,T_{p,q}=1$ 。 即如果 $p=1,q=2$ ，则应该是：</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&0&\cdots &0\\ 0&0&1&\cdots&0 \\ 0&1&0&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>3、位置 $p$ 的数清零。</p><p>…$T_{p,p}=0$ 就好了。</p><p>注意到上面都是单独进行一个操作的情况。如果出现多个操作冗杂在一起，那么一方面可以建 $k$ 个转移矩阵，每次新的转移矩阵要乘上之前的矩阵，这样复杂度就是 $O(n^3k+n^3\log m)$ 。有点爆炸。</p><p>注意到可以把这 $k$ 次操作都放到一个转移矩阵里面，第 $2,3$ 操作就要相应发生改变，$2$ 操作就需要对换 $T$ 的 $p$ 列和 $q$ 列，$3$ 操作则需要把 $p$ 这一列全部清零。这样复杂度就是 $O(nk+n^3\log m)$ 了， 可以通过本题。</p><p>但其实 $n$ 可以出到 $2000$。注意到本题中最多只有 $O(n)$ 个不为零的位置。所以只需要对这些位置做矩阵乘法即可。复杂度变成了 $O(nk+n^2\log m)$ 。</p><p>哦，poj 上多组数据，那没事了（</p><h1 id="UVA1437-String-painter"><a href="#UVA1437-String-painter" class="headerlink" title="UVA1437 String painter"></a><a href="https://www.luogu.com.cn/problem/UVA1437" target="_blank" rel="noopener">UVA1437 String painter</a></h1><blockquote><p>给定一个串 $s$ 和一个目标串 $t$。每次可以将 $s$ 的连续一段刷成一个同一个字符。求最少多少次操作使得 $s$ 变成 $t$ 。</p><p>$1\leq |s|,|t|\leq 500$ 。</p></blockquote><p>一开始的错误思路：考虑如果两个对应位置的字符相同，那么就可以把这对字符删掉不需要管，剩下的 $s$ 就可以看做空串。对这个进行 $dp$ ，$f_{i,j}$ 表示刷好了区间 $[i,j]$ 内字符的最小代价，每次转移考虑如果 $i$ 和 $j$ 相同就从 $f_{i+1,j}$ 或者 $f_{i,j-1}$ 转移过来之类的…反正很乱很乱很乱…</p><p>写了一发之后发现挂了。理了理思路，发现首先有个错误的点，即不一定「删掉不管」是最优的，可能相同的字符会先被覆盖然后再涂上。所以这个思路本来就是错的。之后再考虑，以 $1$ 为步长转移本身没有道理，因为转移时枚举一个子状态，要枚举一个可能存在的确定量。</p><p>所以设 $f_{i,j}$ 表示一个空串的 $[l,r]$ 刷成 $t[l…r]$ 的最少代价。转移时考虑枚举一个和 $l$ 或 $r$ 同色的端点 $k\in[l,r]$ 分成两个子问题即可。之后考虑如何把 $s$ 刷成 $t$ 。设 $g_i$ 表示 $s[1…i]$ 刷成 $t[1…i]$ 的最小代价。考虑比起一个空串，$s$ 中可能存在某些与 $t$ 对应相等的位置。这时只要 <code>chkmax(g[i], g[i - 1])</code> 即可。为了保证转移全面，直接枚举断点转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt; n ; ++ len)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - len ; ++ i)&#123;</span><br><span class="line">j = i + len ; f[i][j] = f[i][j - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &lt;= j - <span class="number">1</span> ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (t[j] == t[k]) </span><br><span class="line">chkmin(f[i][j], f[k + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">g[i] = f[<span class="number">1</span>][i] ;</span><br><span class="line">chkmin(g[i], s[i] == t[i] ? g[i - <span class="number">1</span>] : P) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= i ; ++ k)</span><br><span class="line">chkmin(g[i], g[k - <span class="number">1</span>] + f[k][i]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为什么总是学不会？</span></span><br></pre></td></tr></table></figure><h1 id="UVA1427-Parade"><a href="#UVA1427-Parade" class="headerlink" title="UVA1427 Parade"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA1427 Parade</a></h1><blockquote><p>有一个由 $n+1$ 条横向路和 $m+1$ 条竖向路构成的网格图，每条横向路有一个高兴值和经过的时间。</p><p>现在想从网格的最下方走到最上方，求能得到的最大的高兴值是多少。</p><p>走路有限制：不能多次经过同样的路，也不会从下往上走。另外，在每条横向路上所花的时间不能超过 $k$ 。</p><p>$1\leq n\leq 100,1\leq m\le 10^4$ 。</p></blockquote><p>一开始想的是直接暴力 $dp$，枚举每一行的每个出发点(即从上一行转移过来的点)，考虑向左走一定是走一个包含当前点的最大子段和，向右也是。然后一开始觉得这个思路很有道理，但有点疑惑：我把 $n$ 和 $m$ 读反了，导致我以为这个做法是 $n^2m$ 没准可以卡过去的…后来发现是 $m^2n$ …虽然 $n^2m$ 也必定过不去就是了。</p><p>后来想了想，大概可以定义一个比较靠谱的状态。$f_{i,j}$ 表示到达了 $(i,j)$ 的最大高兴值。那么每次转移可以定向，从右边或者从左边。注意到由于存在 $k$ 的限制，决策区间具有单调性。所以可以用单调队列优化掉一个 $m$ 。</p><p>好像很简单的样子…但是不能一眼 A 就是罪过吧…</p><h1 id="UVA11795-Mega-Man’s-Mission"><a href="#UVA11795-Mega-Man’s-Mission" class="headerlink" title="UVA11795 Mega Man’s Mission"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA11795 Mega Man’s Mission</a></h1><blockquote><p>洛克人最初只有一种武器 “Mega Buster”（这种武器可以消灭特定的一些机器人），你需要按照一定的顺序消灭 n 个其他机器人。每消灭一个机器人你将会得到他的武器（也可能没有得到武器），而这些武器可以消灭特定的机器人。你的任务是计算出消灭所有机器人的<strong>顺序总数</strong>。注意：一个机器人的武器可能可以消灭自己，但这对最终答案没有影响，因为必须先消灭这个机器人才能够得到他的武器。</p><p>$1\leq n\leq 16$ 。</p></blockquote><p>其实是很水的题…只是记录一个坑点。遇到这种求顺序总数的时候，我大脑总会选择性宕机…准确来说，显然这题是要预处理一个 $g_s$ 表示杀死 $s$ 中的怪物后可以获得那些武器。然后考虑 $f_s$ 表示杀死 $s$ 中的怪兽的顺序总数。对于 $f$ 的转移，我一开始是想的是要首先枚举每个元素，再去枚举这个元素第几个出现合法，但是这就需要再记一个其他元素的顺序，然后就爆炸了。</p><p>这也反映了自己并没有理解认真理解 $dp$ 子问题重叠的本质。考虑如何简化子问题。发现无论以什么顺序转移，最后一个加进去的元素是固定的(感性理解)。或者换句话说我们并不关心某个元素 $x$ 在集合内第几个出现，这些状态都可以合并到集合较小时 $x$ 最后一个加入的状态。所以只需要枚举最后一个元素+判断合法性即可。</p><p>菜成一坨，GGGGGGGGG。</p><h1 id="UVA1625-Color-Length"><a href="#UVA1625-Color-Length" class="headerlink" title="UVA1625 Color Length"></a><a href="https://uva.onlinejudge.org/external/16/p1625.pdf" target="_blank" rel="noopener">UVA1625 Color Length</a></h1><blockquote><p>输入两个长度分别是 $n$ 和 $m$ 的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p><p>记 $L(c)$ 为关于颜色 $c$ 和合并之后的排列的一个函数，定义如下：</p><script type="math/tex; mode=display">L(c)=\max_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\} - \min_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\}</script><p>你的任务是找一种合并方式，使得所有 $L(c)$ 的总和最小。</p><p>$1\leq n,m\leq 5000$ 。</p></blockquote><p>考虑朴素的状态当然是 $f_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 的最小总和…等下，似乎这东西并不可以很好的转移，因为考虑对于每个前驱状态，并不是很好记录每个颜色第一出现的位置，同时也不好维护最后出现的位置，根本没法转移。</p><p>考虑一个 trick，提前计算贡献。即虽然其余的都很麻烦，但是可以比较方便地知道有哪些颜色一定没有合并完。所以可以每次转移时，计算还没有合并完的贡献。这样做本质上是把贡献分摊到每个元素上面。因为考虑这种转移，对于每个终止状态，并不关心前面代价转移的形式，只关心代价转移的结果。</p><p>于是就预处理一个 $g_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 时有多少个字母还没有闭合。剩下的 $nm$ 转移即可。</p><h1 id="UVA1218-Perfect-Service"><a href="#UVA1218-Perfect-Service" class="headerlink" title="UVA1218 Perfect Service"></a><a href="https://onlinejudge.org/external/12/p1218.pdf" target="_blank" rel="noopener">UVA1218 Perfect Service</a></h1><blockquote><p>一个网络中有 $n$ 个节点，由 $n-1$ 条边连通，每个节点是服务器或者客户端。如果节点 $u$ 是客户端，就意味着 $u$ 所连接的所有点中有且仅有一台服务器。求最少要多少台服务器才能满足要求。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>这题比较水，主要是整理一下，给自己提个醒。如果设 $f_{x,0/1}$ 表示 $x$ 当根不选/选自己的话，注意到会出现 $f_{son_x,0}$ 没法转移到 $f_{x,1}$ 这种情况，因为不知道 $son_{son_x}$ 选没选。这种定义状态的方式就过于模糊。</p><p>于是考虑因为难以记儿子，所以记父亲。$f_{x,0/1/2}$ 分别表示「$x$ 和 $fa_x$ 都没选」、「$x$ 选了 $fa_x$ 不管(因为选不选都不引起冲突)」、「$x$ 没选 $fa_x$ 选了」，于是就是：</p><script type="math/tex; mode=display">\begin{aligned}f_{x,0}&=\min_{y\in son(x)}\{f_{y,1}+\sum_{z\in son(x),z\not=y} f_{z,0}\}\\f_{x,1}&=1+\sum_{y\in son(x)} \min\{f_{y,1}+f_{y,2}\} \\f_{x,2}&=\sum_{y\in son(x)} f_{y,0} \end{aligned}</script><p>注意到，其中 $f_{x,1}$ 这个状态，本质上是两个状态的合并。可以考虑分裂成 $f_{x,3/4}$ 表示 $x$ 选了 $fa_x$ 选没选，发现被转移的时候，两者转移是一样的。所以就可以简并成一个状态。</p><h1 id="UVA12099-The-Bookcase"><a href="#UVA12099-The-Bookcase" class="headerlink" title="UVA12099 The Bookcase"></a><a href="https://uva.onlinejudge.org/external/120/p12099.pdf" target="_blank" rel="noopener">UVA12099 The Bookcase</a></h1><blockquote><p>有 $n$ 本书，每本书有一个高度 $h_i$ 和一个宽度 $w_i$。 现在要构建一个 $3$ 层的书架，你可以选择将 $n$ 本书放在书架的哪一层。设 $3$ 层高度(每层书的最大高度)之和为 $h$，书架总宽度为 $w$，要求 $h×w$ 尽量小。</p><p>$3\le n\leq 70,1\leq h_i\leq 300,1\leq w_i\le 30$ 。</p></blockquote><p>本质上是要最优化两样东西，宽度和高度。所以不妨让其中一个变得有序，所以考虑先按照 $h_i$ 把所有书降序排序。</p><p>考虑如何设计状态。发现如果某一层有最高的那本书，那么无论怎么放书，这一层的高度都不会再受影响；同时，把每一层的高度和宽度都记下来是没有必要的，于是可以记某一维为某个确切数值时另一维的最小值。具体的，$f_{i,j,k}$ 表示考虑了前 $i$ 本书，第二层的宽度为 $j$，第三层宽度为 $k$ 时，第二层、第三层的最小高度和。此处记宽度为状态是因为一方面高度和宽度是对称的，另一方面宽度的数据范围显然比高度要小。</p><p>考虑转移。首先应该定一个顺序，比如第二层高度应该大于第三层，那么此时转移有：</p><script type="math/tex; mode=display">f_{i,j,k}=\min\{f_{i-1,j,k}~,~f_{i-1,j-w_{i},k}+[j-w_i=0]\cdot h_i~,~f_{i-1,j,k-w_{i}}+[k-w_i=0]\cdot h_i\}</script><p>其中第三个决策当且仅当第二层已经有了一本书。</p><p>考虑这样 $dp$ 的复杂度，似乎是 $O(n\cdot \left(\sum w_i\right)^2)$ ，有点爆炸。考虑如何剪枝：</p><p>1、$j+k\leq \sum_{t=1}^iw_t$ 。</p><p>2、$\sum_{t=1}^iw_t-j-k+30\geq j,j+30\geq k$。</p><p>其中第一可行性个比较好理解，第二个最优性剪枝是在说，因为 $\max\{w_i\}\leq 30$，所以如果高层的宽度比低层的宽度 $+30$ 还要大，那么不妨将几本书放到低层，可知这样放一定不会使结果更劣。</p><p>这么一波剪枝之后似乎就跑的飞快了…似乎是要滚一下第一维的样子。</p><p>大概转移and初始赋值这些会有一点细节的样子吧。</p><h1 id="UVA10559-Blocks"><a href="#UVA10559-Blocks" class="headerlink" title="UVA10559 Blocks"></a><a href="https://uva.onlinejudge.org/external/105/p10559.pdf" target="_blank" rel="noopener">UVA10559 Blocks</a></h1><blockquote><p>有 $n$ 个带有颜色的方块，没消除一段长度为 $x$ 的连续的相同颜色的方块可以得到 $x^2$ 的分数，让你用一种最优的顺序消除所有方块使得得分最多。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>大概是比较神仙的 $dp$ 了吧…</p><p>第一感觉肯定就是 $f_{l,r}$ 嘛，但是这么做的话本质上就变成贪心了，因为可能转移时，$f_{l,k}$ 和 $f_{k,r}$ 是消掉中间一部分，再合并起来的模式。注意到，对于一段 $i,j$，假设 $i&lt;q&lt;j$ 满足 $q\sim j$ 同色，$i&lt;o&lt;p&lt;q$ 满足 $o\sim p$ 与 $q\sim j$ 同色，那么一种决策就是把这两段合并。但是注意到可能还会存在一个区间 $i&lt;s&lt;t&lt;o$ 满足 $s\sim t$ 和 $o\sim p$ 同色。</p><p>于是这就启发(个鬼，这怎么可能想得出来)要多记一维状态 $d$，即 $f_{l,r,d}$ 表示 $l\sim r$ 的这段区间内，区间右侧还有 $d$ 个元素和 $r$ 同颜色时的最大得分。这样每次就以「和右端点颜色相同的颜色段」为子决策进行转移。那么需要枚举每次有多少个块和右端点一起删掉，在这基础枚举一个和右端点同色的、靠左的点进行转移，表示右端点所在的同色段暂时先不删，加入继续向左延伸的长同色段的一部分。</p><p>复杂度的话，状态是 $O(n^3)$ 的，然后我这种写法好像很迷幻，<del>我觉得应该是 $n^5$ 但不知道为什么测出来极限数据(即所有颜色都相同)时运算量在 $n^4$ 量级</del>  …剪枝是要剪的，每次只关心和 $r$ 同色的元素就好了。</p><p>好的，我又重新写了一下测了一下，觉得应该把访问记忆化结果也算 $1$ 次运算。发现 $100$ 个相同的颜色放在一起，这么写的运算量大概是 $258712510\approx2.6\cdot 10^8$，大概 $1s$ 内是可以跑出来结果的(uoj custom test 900ms左右)。$200$ 个颜色相同的就已经是紫荆花之恋那题跑不出来的程度了(即 $14s$ 以内跑不出来，只能本地测试)，似乎足足要 $1\min+$，大概是 $8136350020\approx8\cdot 10^9$ 的运算量<del>中间可执行文件还一度被系统给 kill 掉了</del> 。</p><p>然后…然后我就加了一个好像很牛逼的剪枝，大概就是判断一下 $l\sim r$ 这一整段是不是同色，如果是的话就直接算完了返回即可。发现这样之后极端数据就应该是只有两种颜色然后左右交替这种，就可以在 $370\sim400ms$ 左右跑出来<del>但似乎应该还是过不了，因为极限可以有15组数据，每组都这个速度肯定跑不进3s鸭</del>。</p><p>然后发现这个某个区间是否同色可以预处理，然后就预处理了一下，发现一组快的话只需要 $320ms$ 左右了…</p><p>然后又改了一下，发现可以稍微贪一下，「枚举每次有多少个块和右端点一起转移走」显然是最大的那个快最好了。但这并没有快…</p><p>删了点重复计算和冗杂判断…发现大概是稳定在 $320ms$ 左右了…</p><p>…发现自己是个弟弟，如果要把右边和左边合并的话，那肯定是全都一起合并最优。所以现在大概是真正的 $O(n^4)$ 算法了？一组大概是 $200ms$ 左右了…人艰不拆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1 最大点 400ms</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r, j = lst[r] ; i &gt;= l ; j = lst[j], i = lst[i])</span><br><span class="line"><span class="keyword">if</span> (i != j + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ; </span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (check(l, r)) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;<span class="comment">//剪枝 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l &amp;&amp; base[i] == base[r] ; -- i)&#123;</span><br><span class="line">chkmax(f[l][r][t], solve(l, i - <span class="number">1</span>, <span class="number">0</span>) + (t + r - i + <span class="number">1</span>) * (t + r - i + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line"><span class="keyword">if</span> (base[j] == base[r]) </span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, r - i + <span class="number">1</span> + t)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2 最大点 320- ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (g[r] &lt;= l) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;</span><br><span class="line">chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= g[r] ; -- i)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> pq = t + r - i + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, pq)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ; Q = T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">n = qr() ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line"><span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line"><span class="built_in">memset</span>(lst, <span class="number">0</span>, <span class="keyword">sizeof</span>(lst)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, Q - T) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">lst[i] = buc[base[i] = qr()], buc[base[i]] = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line"><span class="keyword">if</span> (base[i] == base[j]) g[i] = j ; <span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>, n, <span class="number">0</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本3 200- ms 左右 此时根本不需要判整段是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//if (g[r] &lt;= l) return f[l][r][t] = (t + r - l + 1) * (t + r - l + 1) ;</span></span><br><span class="line">chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[g[r]] ; j &gt;= l ; j = lst[j])</span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, g[r] - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, (t + r - g[r] + <span class="number">1</span>) )) ;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA1380-A-Scheduling-Problem"><a href="#UVA1380-A-Scheduling-Problem" class="headerlink" title="UVA1380 A Scheduling Problem"></a><a href="https://onlinejudge.org/external/13/p1380.pdf" target="_blank" rel="noopener">UVA1380 A Scheduling Problem</a></h1><blockquote><p>给定一棵树，pks把其中某些边改成了有向边。现在要求把所有边都改成有向边，求最长链的长度最小值。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>考虑首先，对于这种带方向性的计算链长，在树上一般都是要分成两部分做。于是不妨令 $f_i$ 表示从 $i$ 开始，到 $i$ 子树中的某个点结束的最长链，令 $g_i$ 表示到 $i$ 结束，起点是子树内某个点的最长链。然后开始分类讨论，设当前点为 $x$ ：</p><p>1、如果对于某个 $x$ ，该点与所有儿子的连边均为有向边，那么：</p><p>那么就是比较朴素的转移。</p><script type="math/tex; mode=display">f_{x}=1+\max_{y\in son(x)}\{f_{y}\cdot [\exists(x,y),x\to y]\}\\g_{x}=1+\max_{y\in son(x)}\{g_{y}\cdot [\exists(y,x),y\to x]\}\\</script><p>2、如果存在某个 $y\in son(x)$ ，$(x,y)$ 是无向边，那么： </p><p>那自然是再分类讨论这条边重定向成 $x\to y$ 还是 $y\to x$ 。但…这样做毕竟是 $2^{\mathrm{count}(son(x))}$ 的，如果一棵树全都是无向边那人就没了。</p><p>考虑观察一点更深刻的性质。发现如果对于某个 $y$ ，被定向成了 $y\to x$ ，那么考虑对于其他 $g_z&lt;g_y$ 的 $(x,z)$ 未定向的 $z\in son(x)$ ，一定是要定向成 $z\to x$ 的。原因是，定向成 $z\to x$ 对当前没有任何贡献，因为边不带权，且 $y$ 转移过来一定更优；同时 $z\to x$ 对另一边的 $f$ 的转移没有任何贡献。综上，这样做一定不会使得结果更劣。</p><p>那么就可以考虑，一开始用 <code>vector&lt;int&gt;</code> 将所有无向边连接的儿子给 <code>push_back</code> 进来。对于 $f$ 和 $g$ 分别处理。这个地方需要注意到题目中有个定理：</p><blockquote><p>假如 $\rm G$ 是一棵树，那么需要的天数是 $k$ 或 $k+1$ 。$k$ 满足：$k$ 是 $\rm G$ 中所有链中一条链能包含的最多顶点数。</p><p>链的定义：在一条路径 $ P=(x_1, x_2, …, x_k)$中 ，对于任意的 $i=1,2,…,k-1$，总有一条从 $x_i$ 指向 $x_{i+1}$ 的有向边。</p></blockquote><p><del>但其实这个定理也可以没有用。因为只需要在外层套一个二分就好了。</del>·</p><p>这提示我们只关心最长链是否 $&gt;k$，而不关心是否真的被最小化了。也就是说，我们致力于保证 $f$ 和 $g$ 是最优的，但是不用考虑 $f$ 和 $g$ 怎么合并——因为这个地方，可能会出现最优化 $g$ 和 $f$ 的时候，对于一条无向边被用了两次。但这并不重要，因为可能存在这么一个局面， $f_x$ 此时没有被最优化，$g_x$ 也没有被最优化，但是 $f_x+g_x\leq k$ 并且两者的决策不相交——这就可以保证至少在 $x$ 这里 $k$ 是合法的。那么就考虑在排完序扫两遍的过程中记录贡献即可。</p><p>注意一个问题，由于这个状态记录的不是子树的最大值(当然也可以多记一个这个)，所以如果中有以某点为根，路径长度 $&gt;k$ 的，需要将这个信息向上传导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_in</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; <span class="keyword">char</span> w ;</span><br><span class="line">res = cnt = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; n = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; u)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ret ;</span><br><span class="line">        ret = <span class="number">1</span>, n = <span class="built_in">std</span> :: max(u, n) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%c"</span>, &amp;v, &amp;w) &amp;&amp; v)&#123;</span><br><span class="line">            fa[v] = u ; n = <span class="built_in">std</span> :: max(n, v) ;</span><br><span class="line">            <span class="keyword">if</span> (w == <span class="string">'d'</span>) add_e(u, v, <span class="number">2</span>), add_e(v, u, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w == <span class="string">'u'</span>) add_e(u, v, <span class="number">1</span>), add_e(v, u, <span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">else</span> add_e(u, v, <span class="number">0</span>), add_e(v, u, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">std</span> :: max(ans, len) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; val(k) == <span class="number">2</span>) dfs(to(k), x, len + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> f[x] &lt; f[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> g[x] &lt; g[y] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">    f[x] = g[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> F, G, df, dg ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!do_dp(to(k), x)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!val(k)) son[x].p_b(to(k)) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val(k) &gt; <span class="number">1</span>)</span><br><span class="line">                 f[x] = <span class="built_in">std</span> :: max(f[x], f[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> g[x] = <span class="built_in">std</span> :: max(g[x], g[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    F = f[x] ; G = g[x] ;</span><br><span class="line"><span class="keyword">if</span> (son[x].empty()) <span class="keyword">return</span> (<span class="keyword">bool</span>)(F + G &lt;= ans) ;</span><br><span class="line">    f[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_f) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], g[son[x][i]]) ;</span><br><span class="line"><span class="comment">//debug(suf, 0, n) ;</span></span><br><span class="line"><span class="keyword">if</span> (F + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) f[x] = F ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, f[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (df + dg &lt;= ans) f[x] = <span class="built_in">std</span> :: min(f[x], df) ;</span><br><span class="line">&#125;</span><br><span class="line">    g[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_g) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">-1</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], f[son[x][i]]) ;</span><br><span class="line"><span class="comment">//debug(suf, 0, n) ;</span></span><br><span class="line"><span class="keyword">if</span> (G + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) g[x] = G ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, g[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(df + dg &lt;= ans) g[x] = <span class="built_in">std</span> :: min(g[x], dg) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; F &lt;&lt; " " &lt;&lt; G &lt;&lt; " " &lt;&lt; f[x] &lt;&lt; " " &lt;&lt; g[x] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(f[x] &lt;= ans || g[x] &lt;= ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read_in())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa[i]) root = i ;</span><br><span class="line">dfs(i, <span class="number">0</span>, <span class="number">0</span>) ; son[i].clear() ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; to(i) &lt;&lt; " " &lt;&lt; val(i) &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res = do_dp(root, <span class="number">0</span>) ; <span class="comment">//return 0 ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//      for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">//if (f[i] + g[i] &gt; ans)&#123; res = 1 ; break ; &#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (res ? ans + <span class="number">1</span> : ans + <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA12170-Easy-Climb"><a href="#UVA12170-Easy-Climb" class="headerlink" title="UVA12170 Easy Climb"></a><a href="https://uva.onlinejudge.org/external/121/p12170.pdf" target="_blank" rel="noopener">UVA12170 Easy Climb</a></h1><blockquote><p>给出一堆山的高度 $h_i$ ，给定一个数 $d$ 。除了 $h_1,h_n$ 之外，可以任意修改山的高度，设改完之后山的高度是 $h’$，那么修改的代价是 $|h-h’|$ 。求使得任意两座相邻山峰的之间高度差得绝对值不超过 $d$ 的最小修改代价。</p><p>$1\leq n\leq 100,0\leq h_i\leq 10^9$ 。</p></blockquote><p><del>orz又是性质题，好烦啊怎么一直不会</del></p><p>考虑暴力怎么做。$f_{i,v}$ 表示把 $i$ 改成了 $v$ 后前 $i$ 座山彼此之间合法的最小代价和。你发现这个 $v$ 大概是没法直接转移的…</p><p>于是考虑一个深刻的性质。对于一个 $1&lt;i&lt;n$ ， $h_i$ 一定会被改成 $\max\{h_{i-1},h_{i+1}\}-d$ 或者 $\min\{h_{i-1},h_{i+1}\}+d$ 两者之一，如果一开始就满足性质就不用改，否则如果不满足就一定要去凑最近那个边界。类似的，考虑如果 $h_i ‘=h_{i+1}+d$ ，那么 $h_{i+1}’$ 就应该是关于 $h_{i}’$ 或者 $h_{i+2}$ 的一个带有常数个 $\mp d$ 的答案。那么这也就证明了，最终每座山都会变成某个 $h_p+q\cdot d$ 的形式，其中 $p\in [1,n]\cap\mathbb{Z_+}$，$q\in[-n,n]\cap\mathbb Z$ 。那么状态数就变成了 $O(n)\cdot O(n^2)=O(n^3)$ 个。考虑转移：</p><script type="math/tex; mode=display">f_{i,x}=|x-h_i|+\min\{f_{i-1,y}\} \quad (x-d\leq y\leq x+d)</script><p>发现可以对 $x$ 这一维用单调队列。于是复杂度 $O(n^3)$ 。如果实现不精细可能会多一个 $\log$ 。注意到可以一开始把所有可能的 $x$ 值排序后存起来，这样就可以避免 <code>map</code> 或者 <code>set</code> 的滥用。</p><h1 id="UVA1228-Integer-Transmisson"><a href="#UVA1228-Integer-Transmisson" class="headerlink" title="UVA1228 Integer Transmisson"></a><a href="https://uva.onlinejudge.org/external/12/p1228.pdf" target="_blank" rel="noopener">UVA1228 Integer Transmisson</a></h1><blockquote><p>在一个仿真网络中传输一个 $n$ 比特的非负整数 $k$。各比特从左到右传输，第 $i$ 个比特的发送时刻为 $i$ 。每个比特的网络延迟总是为 $0\sim d$ 之间的整数(因此从左到右第 $i$ 个比特的到达时刻为 $i\sim i+d$ 之间)。若同时有多个比特到达，实际收到的顺序任意。</p><p>求实际收到的整数有多少种 ，以及它们的最小值和最大值。</p><p>例如，$n=3$，$d=1$，$k=2$ (二进制为<code>010</code>)实际收到的整数的二进制可能是 <code>001</code>(1)，<code>010</code>(2) 和 <code>100</code>(4)。</p><p>$1\leq n\leq 64,0\leq d\leq n,0\leq k\leq 2^n $。</p></blockquote><p>最小值和最大值都显然可以贪心。考虑求方案数。比较直接的想法就是设 $f_{i,j}$ 表示考虑前 $i$ 个 $0$ 和前 $j$ 个 $1$ 后，组成整数的方案数。但是转移并不知道要怎么转移，因为可能上一个 $0/1$ 的出现时间不确定，导致无法判定当前在整个数最右边插入 $0/1$ 是否合法。</p><p>然后就需要洞见一个比较深刻的性质了。考虑如果希望凑出某个数 $w$ ，那么对于任意时刻，最右边那位(指被收到的最右边那一位)必然可以<strong>没有延迟</strong> 。因为即使延迟了，结果也不会更优（即也不会存在没延迟拼不出来，只有延迟才能拼出来的情况）。证明的话比较简单，因为「若同时有多个比特到达，实际收到的顺序任意」，所以如果某个比特延后至 $&gt;$ 最右边的数接收的时间，就可以调整成等于然后重排。</p><p>于是就可以知道，假设第 $i$ 位的发送时间是 $t_i$，那么考虑如何从 $f_{i,j}$ 转移到 $f_{i+1,j}$ 和 $f_{i,j+1}$ 。观察到本质上是要求插入一个新的 $1$ 或者新的 $0$ 。那么考虑假设第 $i+1$ 个 $0$ 的发送时间是 $t_0$ ，第 $j+1$ 个 $1$ 的发送时间是 $t_1$ ，那么如果为了让 $0$ 能够被尽早接收到，就需要满足 $t_0\leq t_1+d$ ，同理如果是想要 $1$ 能够尽量早到，就需要 $t_1\leq t_0+d$ 。于是转移时判断一下即可。复杂度 $O(n^2)$ 。</p><p><del>代码懒得写了</del></p><h1 id="UVA1628-Pizza-Delivery"><a href="#UVA1628-Pizza-Delivery" class="headerlink" title="UVA1628 Pizza Delivery"></a><a href="https://onlinejudge.org/external/16/p1628.pdf" target="_blank" rel="noopener">UVA1628 Pizza Delivery</a></h1><blockquote><p>你是一个披萨店的老板，有一天突然收到了 $n$ 个客户的订单。</p><p>你所在的小镇只有一条笔直的大街，其中位置 $0$ 是你的披萨店，第 $i$ 个客户所在的位置为 $p_i$，如果你选择给第 $i$ 个客户送餐，他将会支付你 $e_i-t_i$ 元。其中 $t_i$ 是你到达他家的时刻。</p><p>当然，如果你到的太晚，使得 $e_i-t_i&lt;0$ 。你可以路过他家但是不能进去给他送餐，免得他反过来找你要钱。</p><p>最大化收益。</p><p>$n \leq 100$ 。</p></blockquote><p>考虑对于这种每秒代价递增的问题，一般都是代价提前计算。但是这题也不是最朴素的这类问题，因为存在可以放弃某些位置的情况。</p><p>然后就是比(我)较(又)神(不)仙(会)的状态设计环节。首先是，根据题面可知不用全部送餐，所以要把「准备送餐给ta」的人数 $k$ 放到状态里面。同时如果定义「选了某个区间内的全部数」作为状态，显然是不合适的。于是设 $f_{i,j,k,0/1}$ 表示<strong>不考虑</strong>区间 $[i,j]\cap\mathbb {Z_+}$  内的元素，还要给 $k$ 个人送餐，当前位于 $i(0)$ 还是 $j(1)$  的最小代价。那么最后答案就是 </p><script type="math/tex; mode=display">\max_{k=0}^n\{\max_{i=1}^n\{f_{i,i,k-1,0/1}+(e_i-|p_i|)\times k\}\}</script><p>考虑转移。发现对于一个 $f_{i,j,k,0/1}$ 而言，必然是由一个包含 $[i,j]$ 的更大的区间 $[l,r]$ 通过切分得来的，同时为了每次只转移走一个子问题，需要 $r=j$ 或者 $l=i$ 的更大区间。于是考虑每次只转移一个点，故转移为：</p><script type="math/tex; mode=display">f_{i,j,k,0}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_i|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_i|)\}\\f_{i,j,k,1}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_j|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_j|)\}</script><p>然后就刷表就好了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = n - <span class="number">1</span> ; len ; -- len)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n - len ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i + len ; j &lt;= n ; ++ i, ++ j)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span> ; p &lt;= j ; ++ p)&#123;</span><br><span class="line">chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[p] - pos[i])) ;</span><br><span class="line">chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j - <span class="number">1</span> ; q &gt;= i ; -- q)&#123;</span><br><span class="line">chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[q])) ;</span><br><span class="line">chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这东西看似是 $n^4$ 的，实际上跑得很快（</p><h1 id="UVA12105-Bigger-is-Better"><a href="#UVA12105-Bigger-is-Better" class="headerlink" title="UVA12105 Bigger is Better"></a><a href="https://onlinejudge.org/external/121/p12105.pdf" target="_blank" rel="noopener">UVA12105 Bigger is Better</a></h1><blockquote><p>用不超过 $n$ 根火柴摆出一个尽量大的、能被 $m$ 整除的数。</p><p>$1\leq n\leq 100,1\leq m\leq 3000$ 。</p></blockquote><p>大概是个套路？遇到这种被 $m$ 整除余几的，大概需要在 $\bmod m$ 的余数之间来回转移。</p><p>然后可能是因为脑子抽了，一开始设计的状态是 $f_{i,j}$ 表示用了 $i$ 根火柴，模 $m$ 余 $j$ 时可以拼出来的最大的数，然后发现最多可以有 $50$ 位，但是 <code>__int128</code> 也只是大概 $36\cdot 10^{36}$ 多一点，不足以记下所有可行的的数字。</p><p>然后又尝试用 <code>string</code> ，写了一会儿才意识到 string 自定义的比较函数是按字典…<del>当然也可以写一个大整数类，似乎最多只会带一个 50 的常数</del>。</p><p>然后考虑这么设计不行，就只能去最小化贡献，然后手动构造了。考虑 $g_{i,j}$ 表示如果想要凑出从高到低的 $i$ 位，$\bmod m$ 余 $j$ 时最少需要用多少根火柴。转移和第一个转移…基本上差不多，刷就对了。然后考虑从第一位开始贪心地凑，注意判几次合法性就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, m ;</span></span><br><span class="line"><span class="comment">ll f[N][M], ans ;</span></span><br><span class="line"><span class="comment">int num[10] = &#123;6, 2, 5, 5, 5, 5, 6, 3, 7, 6&#125; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; n)&#123;</span></span><br><span class="line"><span class="comment">        if (!n) return 0 ; ans = -1 ;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; m ; memset(f, -1, sizeof(f)) ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt;= 9 ; ++ i) f[i % m][num[i]] = i ;</span></span><br><span class="line"><span class="comment">        for (int j = 2 ; j &lt;= n ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            for (int k = 0 ; k &lt;= 9 ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">                for (int i = 0 ; i &lt; m ; ++ i)</span></span><br><span class="line"><span class="comment">                    chkmax(f[((i * 10) + k) % m][j + num[k]], f[i][j] * 10 + k) ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 2 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">            chkmax(ans, f[0][i]) ; cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T ;</span><br><span class="line"><span class="keyword">int</span> pw[N], ans[N], f[N][M] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++ T), <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans)) ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">9</span> ; ++ k)</span><br><span class="line">                        chkmin(f[i + <span class="number">1</span>][(j * <span class="number">10</span> + k) % m], f[i][j] + num[k]) ;</span><br><span class="line"><span class="keyword">for</span> (res = n + <span class="number">1</span> ; f[res][<span class="number">0</span>] &gt; n ; -- res) ;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, cost = n ; pw[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= res ; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = j * pw[res - i + <span class="number">1</span>] % m ;</span><br><span class="line">                <span class="keyword">if</span> (num[j] + f[res - i][((m - p - t) % m + m) % m] &lt;= cost)&#123;</span><br><span class="line">                    cost -= num[j] ; (p += t) %= m ; ans[i] = j ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span> ; <span class="keyword">while</span> (!ans[q] &amp;&amp; q &lt; res) ++ q ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q ; i &lt;= res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意几个细节：</p><p>1、最后数字的位数不具有可二分性，所以还是枚举吧。</p><p>2、注意可能存在前导 $0$ ，需要删掉。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实学到了许多吧？自己基础一点也不好，所以其实是把别人很早之前付出的努力，再重新付出了一遍。很遗憾，这些题目里面还是有不少无不太会做的题目…</p><p>感谢兔队的教导可以让我安心学下去：藏巧于拙，寓快于慢。只要努力，就一定会比昨天的我更优秀吧？</p><p>不过，努力和选择同样重要。希望在接下来越来越紧张的时间里面，我可以想清楚自己到底要做些什么题、要学习一些什么知识吧。加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉自己真的是菜成一团…&lt;/p&gt;
&lt;p&gt;感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？&lt;/p&gt;
&lt;p&gt;可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？&lt;/p&gt;
&lt;p&gt;人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。&lt;/p&gt;
&lt;p&gt;Hide your skill from your clumsiness, make you fast in slowly.&lt;/p&gt;
&lt;p&gt;本文共计 15 道题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="图论/Dilworth定理" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-Dilworth%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做</title>
    <link href="https://www.orchidany.cn/2020/04/19/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A/"/>
    <id>https://www.orchidany.cn/2020/04/19/简单题选做/</id>
    <published>2020-04-19T01:07:23.000Z</published>
    <updated>2020-04-27T06:37:35.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是由于基础太差了，然后打算去做点题补一下基础和脑子…</p><p>这个故事告诉我们，永远不要偷懒，有些力气，早晚是要出的。</p><p>如果来看我 blog 的你有什么好题推荐，欢迎评论，其他博客也是可以评论的（疯狂暗示</p><p>对了，像我这种明明要准备省选却在刷简单题补基础的人，是不是应该发一个「年度最佳人才」奖？</p><p>争取一句话题解…先整理十道题吧…因为奇奇怪怪的事情浪费了不少时间。</p><a id="more"></a><h1 id="UVA10891-Game-of-Sum"><a href="#UVA10891-Game-of-Sum" class="headerlink" title="UVA10891 Game of Sum"></a><a href="https://www.luogu.com.cn/problem/UVA10891" target="_blank" rel="noopener">UVA10891 Game of Sum</a></h1><blockquote><p>有一个长度为 $n$ 的整数序列，两个游戏者 $A$ 和 $B$ 轮流取数，$A$ 先取。每次玩家只能从左端或者右端取任意数量的数，但不能两边都取。所有数都被取走视为游戏结束，然后统计每个人取走的数之和，作为各自的得分。两个人采取的策略都是让自己得分尽可能高，并且两个人都很机智，求 $A$ 得分 - $B$ 得分后的结果。</p></blockquote><p>自己一开始想的 $dp$ 是要 $f_{i,j,0/1}$ ，并且转移有点复杂，结果发现根本不需要…考虑在博弈树上 dp，每个 $max$ 局面接下来一定是一个 $min$ 局面，所以有</p><script type="math/tex; mode=display">f_{i,j}=sum(i,j)-\min\{\min_{k\in[i+1,j]}\{f_{k,j}\},\min_{k\in[i,j-1]}\{f_{i,k}\}\}</script><p>也就是找到与一端边界相邻，且最小的那个对方的决策（$min$ 局面）。发现前后缀 $min/max$ 维护一下就可以 $O(n^2)$ 了。</p><h1 id="CF493D-Vasya-and-Chess"><a href="#CF493D-Vasya-and-Chess" class="headerlink" title="CF493D Vasya and Chess"></a><a href="https://www.luogu.com.cn/problem/CF493D" target="_blank" rel="noopener">CF493D Vasya and Chess</a></h1><blockquote><p>有一个  $n\times n$  的国际象棋棋盘。将白后放在  $(1,1)$ ，黑后放在  $(1,n)$  ，其余位置全都是中立的卒。<br>双方交替移动。白方先手。 每次移动，后（Queen）可以朝八个方向（上下左右对角线）之一移动任意格，直到碰到另外一个棋子，然后吃掉这个棋子。注意，在本题中，每次移动必须吃掉一个棋子。<br>当你的皇后被吃了或者你没有棋子可以吃了，就输了。 给出棋盘大小，请问哪方会赢。</p></blockquote><p><del>发现这种对称位置决策的…一般后手都比较神必，拖，就硬拖。</del></p><p>考虑后手模仿先手的动作，那么如果两者之前相隔为奇数，后手可以模仿先手，发现这么做一定可以吃掉先手。如果相隔为偶数，那先手就要学聪明，移动到 $(1,2)$ ，然后成为上一种情况的后手…</p><h1 id="UVA1099-Sharing-Chocolate"><a href="#UVA1099-Sharing-Chocolate" class="headerlink" title="UVA1099 Sharing Chocolate"></a><a href="https://www.luogu.com.cn/problem/UVA1099" target="_blank" rel="noopener">UVA1099 Sharing Chocolate</a></h1><blockquote><p>给出一块长为 $x$, 宽为 $y$ 的矩形巧克力，每次操作可以沿一条直线把一块巧克力切割成两块长宽均为整数的巧克力（一次不能同时切割多块巧克力）。 </p><p>问：是否可以经过若干次操作得到 $n$ 块面积分别为 $a_1, a_2, …, a_n$ 的巧克力。</p><p>$n\leq 15,1\leq x,y\leq 100$ 。</p></blockquote><p>大力状压，$f_{s,x,y}$ 表示 $s$ 这个集合内的巧克力是否可以被 $x,y$ 给切出来。考虑这样转移存在问题。因为必须要枚举子集来转移，所以最后时间复杂度 $O(3^nxy)$，空间复杂度 $O(2^nxy)$ 。有点爆炸。</p><p>考虑化简状态。发现固定了巧克力集合 $s$ ，那么对于一个固定的 $x$ ，$y$ 要么不存在要么同样被固定。所以状态就可以简化成 $f_{s,\min\{x,y\}}$ 。转移时依旧要判断两个状态是否都可行。注意转移来的状态 $f_{s’,x’}$ 也需要保证信息是落在较短边上的。复杂度 $O(x3^n)$。</p><p>神必 uva 卡我常数。不过也需要记得，对于这种信息 $01$ 且求并的转移，一旦某个状态确定为 $1$ 了就可以 <code>break</code>。这个技巧确实要记住。</p><h1 id="LA4725-Airport"><a href="#LA4725-Airport" class="headerlink" title="LA4725 Airport"></a><a href="https://www.luogu.com.cn/problem/UVA1450" target="_blank" rel="noopener">LA4725 Airport</a></h1><blockquote><p>机场上有两个跑道，分别为 W 和 E，每个时刻 $i$，W和E都分别有 $a_i,b_i$ 架飞机进入跑道。每个跑道的飞机都按顺序从 0 开始排序，每个时刻都允许一架飞机起飞，现要求你安排起飞的飞机，使得任意时刻的飞机的最大编号最小。</p><p>$1\leq n\leq 5000$ 。</p></blockquote><p>这题能比较自然地想到要二分。但是问题在于二分了之后并不知道要怎么去 check。这个地方有个很妙的 idea。就是如果之前有机会要飞，可以不飞，等到什么时候攒到了 $mid$ 号再飞。这样就不需要再考虑这东西的后效性了。但是有一点需要注意，就是攒着一起飞的话，在第 $i$ 个时刻只能选择飞之前的，因为这个决策本质上等价于在 $i-1$ 时刻飞。所以也要分别统计 $W$ 和 $E$ 的可飞量。</p><h1 id="LA4094-Wonder-Team"><a href="#LA4094-Wonder-Team" class="headerlink" title="LA4094 Wonder Team"></a><a href="https://vjudge.net/problem/UVALive-4094" target="_blank" rel="noopener">LA4094 Wonder Team</a></h1><blockquote><p>There are $n$ football teams participating in the competitions, each team plays twice (home and away) against each other team. Each team receives three points for a win and one point for a draw. No point is awarded for a loss. </p><p>When the games are finished, teams are ranked by numbers from $1$ to $n$ according to the total points. The rank of each team $t$ having $p$ points is one plus the number of teams having more than $p$ points. It is possible that more than one team have the same ranks. In addition to the Champion (the first ranked team or teams), the <strong>Wonder Team</strong> is also awarded, if there exists one. The team that has absolutely <strong>the highest number of wins</strong> (absolutely means no other teams has the same number of wins), absolutely <strong>the highest number of goals scored</strong>, and absolutely <strong>the lowest number of goals </strong>conceded, is called the WonderTeam. (WonderTeam should have all these properties.)</p><p>Your task is to find out the worst possible rank for the <strong>Wonder Team</strong>.</p><p>$1\leq n\leq 50$ 。</p></blockquote><p>English problem, English solution!</p><p>First of all, I’d like to claim that the 2nd Constraint and 3rd Constraint is no-use, becauce we always can let WT won another team with $10^9:1$. </p><p>Let’s assume $a_1,b_1$ means the WonderTeam’s wins and draws, $a_2,b_2$ means an arbitrary team’s wins and draws, whose rank is higher than WT. After a series of easy inference, if one team has higher rank than WT,   the equation below should be satisfied:</p><script type="math/tex; mode=display">b_2-b_1>3(a_1-a_2)\qquad (1)</script><p><del>Then my train of thought ended up with this:(</del></p><p>Thinking more carefully, if we want to maxmize WT’s rank, we have to get other teams’ score as high as we can. So we can use a greedy way to construct it : Just let WT’s wins actually one more than others. At the same time let WT lose its other games. Also we let other teams won WT one time, and draw with each other. </p><p>Then we can find that $\forall a_2$ ，there is $a_1-a_2=1$, which means $(1)$ turned to be:</p><script type="math/tex; mode=display">b_2-b_1>3</script><p>And about $b_2$ , there will exists two teams who losed in the game with WT , which means the-two  has exactly $1$ win and $2n-4$ draws, while the rest teams has exactly $1$ win and $2n-3$ draws. </p><p>So we can cliam that when $n&gt;4$ , WT’s lowest rank can be $n$ ; when $n=4$, it can be $2$ ; otherwise it can only be $1$ 。 </p><h1 id="CCO-2017-Rainfall-Capture"><a href="#CCO-2017-Rainfall-Capture" class="headerlink" title="CCO 2017 Rainfall Capture"></a>CCO 2017 Rainfall Capture</h1><blockquote><p>Lucy 有 $n$ 个高度为 $h_1,h_2,…,h_n$ 的柱子。她想知道，在所有可能的摆放方案中，所有可能的雨滴量（以 $r$ 为单位）是多少。</p><p>柱子只能竖着摆。接雨滴的定义：满则溢。</p></blockquote><p>比较神仙的 dp，对着代码啃了很久…</p><p>考虑直接求雨滴量并不好求，因为要去考虑左右两边的柱子高度。考虑对于一个排布 $4,2,5$ ，那么中间 $=2$ 或者 $=1$ 时要分开考虑；但是我们发现无论怎样，中间在接完雨滴之后高度都会变成 $4$ ，所以考虑求<strong>所有可能的雨滴+柱子</strong>的体积和。由于每个柱子都要摆，所以最后只需要去 check 那些 $\sum h_i\sim max$ 的答案。</p><p>考虑定义 $f_{i,v}$ 表示用了 $i$ 个柱子之后能否凑出体积 $v$ 来。考虑一个比较常用的 trick，将所有 $h_i$ 从小到大排序之后，按顺序转移。这样就能保证每次加进来的柱子都是当前最高的(无中生有了一个很有用的性质)。考虑一个状态 $f_{i,v}$ ，他的转移应该为：</p><script type="math/tex; mode=display">f_{i,v}=\bigcup_{p_j\leq v} f_{i-1,v-p_j}</script><p>其中 $p_j$ 是每个柱子的高度，需要从小到大转移，且转移时需要严格按照先枚举 $p_j$ 再枚举 $1\sim i$ 的顺序。</p><p>考虑这个式子的意义。对于任何一个大小为  $i\in[1,n-1]\cap\mathbb{Z_+} $ 的柱子集合 $o$，按秩转移时每次加入一个 $\geq \max_{t\in o}p_t$ 的新柱子 $p’$，放在最左边（或者最右边），同时再加入一个按高度从小到大排序后，恰好排名比 $p’$ 大 $1$ 的柱子 $p’’$  放在 $p’$ 的同侧（即，如果 $p’$ 放在了整个序列的左边，$p’’$ 应该被放在 $p’$ 的左边）。那么此时考虑，每当加进来一个元素 $p_0$，集合大小从 $i-1$ 变成 $i$ ，$p’$ 就向右交换一个，这样新加进来的这个柱子上方水位高度一定会是 $p’$ 的高度（因为最左边有 $p’’$）， 所以体积的变化量是 $\Delta v=(p’-p_0)+p_0$，前一半是水，后一半是新的柱子，所以可以从 $i-1,v-p’$ 转移过来。</p><p>需要注意的是，这样转移一定是不包含最高那个柱子的，因为当最高的柱子为 $p’$ 不存在一个更高的 $p’’$ 。</p><p>于是最后复杂度 $O(n^2\sum h)$ ，当然可以用 bitset 优化成 $O(\frac{n^2\sum h}{w})$ 。但其实在注意到本题只关注可达性判断之后，就可以发现等高的柱子不用重复转移，就可以优化成 $O((\sum h)\cdot n\cdot \max\{h\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="comment">//bool f[N][M] ; </span></span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; f[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">base[i] = qr(), m = max(m, base[i]) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">s += base[i] ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">f[j] |= (f[j - <span class="number">1</span>] &lt;&lt; base[i]) ; </span><br><span class="line"><span class="comment">//for (int k = base[i] ; k &lt;= n * m ; ++ k)</span></span><br><span class="line"><span class="comment">//f[j][k] |= f[j - 1][k - base[i]] ; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s ; i &lt;= n * m ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[n - <span class="number">1</span>][i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - s) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA1073-Glenbow-Museum"><a href="#UVA1073-Glenbow-Museum" class="headerlink" title="UVA1073 Glenbow Museum"></a><a href="https://www.luogu.com.cn/problem/UVA1073" target="_blank" rel="noopener">UVA1073 Glenbow Museum</a></h1><blockquote><p>对于一个各边长度任意且都平行于坐标轴的多边形，我们可以用这样的方式描述它：考虑它的每一个内角，如果这个内角为 $90$ 度，那么用 $R$ 代表它；如果这个内角为 $270$ 度，那么用 $O$ 代表它。从某个点开始，按照逆时针的顺序读取 $R$ 和 $O$，最后得到一个由 $O,R$ 组成的字符串。</p><p>给定整数 $n$，问有多少个长度为 $n$ 的 $O,R$ 组成的字符串，使得有一个或以上与之对应的多边形，满足这个多边形内部有一点，可以看到这个多边形的所有内角（即，这个点与多边形所有内角顶点的连线都不与多边形的边相交）。</p></blockquote><p>显然最后一定是 $\frac{n}{2}-2$ 个 $O$ 和 $\frac{n}{2}+2$ 个 $R$。同时显然不会有相邻的 $O$，证明大概是需要拐回来之类的。那么问题就是给你固定数量的 R 和 O ，O 和 O 之间不相邻的方案数。</p><p>第一种 $dp$ 就是 $f_{k_1,k_2,l,r}$ 表示用了 $k_1$ 个 O 和 $k_2$ 个 R，最左端的字母是 $l$，最右端是 $r$ 的方案数。转移的时候考虑新加入一个 $R$ 还是 $O$ 即可。</p><p>第二种 $dp$ 则是一个改进，因为显然我们不关心 $O$ 的数量，因为最后是一定的；只关心如何排列。所以令 $f_{k_1,k_2,c}$ 表示有 $k_1$ 个 R ，$k_2$ 对相邻的 RR，第一个字母是 $c$ 的方案数。转移的时候考虑向后加一个 R​ 还是 OR 即可 。</p><p>然而显然这种 dp 是有组合意义的。所以我们分类讨论：</p><p>1、尾部不是 O 的方案数，显然就是前面 $\frac{n}{2}+2$ 个空填 $\frac{n}{2}-2$ 个O的方案数。</p><p>2、尾部是 O 的方案数，此时第一个位置不能放  O。类似的组合一下就完了。</p><p>于是就可以组合数做。处理的时候因为答案过大，所以可以考虑取对数<del>（学到许多）</del>。</p><h1 id="CF340E-Iahub-amp-Permutations"><a href="#CF340E-Iahub-amp-Permutations" class="headerlink" title="CF340E Iahub &amp; Permutations"></a><a href="https://www.luogu.com.cn/problem/CF340E" target="_blank" rel="noopener">CF340E Iahub &amp; Permutations</a></h1><blockquote><p>有一个长度为 $n$ 的排列 $a$，其中有一些位置被替换成了 <code>-1</code>。你需要尝试恢复这个排列，将 <code>-1</code> 替换回数字。<br>求多少种可行方案使得得到的是一个排列且不存在 $a_i=i$ 的位置。</p><p>$n\leq 5000$ 。</p></blockquote><p>orz 一个十分巧妙的转化，大概就是对于这种带有<strong>放置限制</strong>的排列问题，比如某个下标不能放置某个数，那么可以将这个排列对应到一个 $n$ 阶摆 $rook$ （即 $n\times n$ 的棋盘上放 $n$ 个互不攻击的车）问题上。这样一方面可以把「位置 x 不能放 y」约束展开，抽象成一个二维约束点 $(x,y)$ 上不能放车的约束；另一方面可以知道这个对应一定是完备的。</p><p>那么就转化成了，有些行和列已经放了车，整个棋盘对角线不能放车，有多少种本质不同的放车方案数。首先可以发现，如果某行某列有车，这一行一列就可以删掉；同时如果对于某个 $-1$ ，他所在的这个位置对应的行/列恰好被删了（同时存在位于下标 $k$ 的 $-1$ 和一个 $pos$ 使得 $a_{pos}=k$ ），那么对于这个 $-1$ 而言就没有限制了。</p><p>这样考虑 $dp$ 。$f_{i,j}$ 表示 $i\times i$ 的方格里考虑 $j$ 个限制的方案数。那么 $f_{i,0}=i!$。同时注意到 $f_{i,j-1}$ 到 $f_{i,j}$ 恰好多了一个限制，这个限制对应的应该是 $f_{i-1,j-1}$ 的方案数。所以有转移</p><script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}-f_{i-1,j-1}</script><p>复杂度 $n^2$ 。</p><h1 id="CF212D-Cutting-Fence"><a href="#CF212D-Cutting-Fence" class="headerlink" title="CF212D Cutting Fence"></a>CF212D Cutting Fence</h1><blockquote><p>给出 $a[1…n]$ 。<br>定义 $f$ ：</p><script type="math/tex; mode=display">f(i,k)=\min_{i\leq j\leq i+k-1}\{a[j]\}</script><p>之后有 $m$ 个询问，每个询问给出一个数 $k$，问所有 $f(j,k) (1\leq j\leq n-k+1)$ 的平均值。<br>$1\leq n,m\leq 10^6$.</p></blockquote><p>首先不难知道要求出每个 $a_i$ 对包含其区间的贡献，然后对于长度为 $1\sim n$ 的区间分别计算其和，最终除以 $n-k+1$ 即为答案。</p><p>考虑两遍单调栈求出每个元素 $x$ 左/右边第一个比他小的元素下标 $l,r$，可知 $x$ 的贡献区间即为 $[l+1,r-1]$。枚举 $x$ ，那么区间 $l+1,r-1$ 的所有跨过 $x$ 的子区间都会存在贡献。此处假设 $x-l&lt;r-x$，考虑分类讨论子区间长度 $L$ ： </p><p>1、 $1\leq L\leq x-l$ ，这种区间每个元素都可以是 $x$ ，所以贡献为 $L\cdot a_x$ 。</p><p>2、$x-l+1\leq L\leq r-x$ ，这种区间最多只能取到 $x-l$ 次 $x$ ，所以贡献为 $(x-l)\cdot a_x$ 。</p><p>3、$r-x+1\leq L\leq r-l-1$ ，这种区间最多只能取到 $r-l-L$ 次，故贡献为 $(r-l-L)\cdot a_x$ 。</p><p>然后观察这些修改，发现 $L\cdot a_x$ 这东西，对于一个区间是在加一个等差数列的形式，$(x-l)\cdot a_x$ 和 $(r-l)\cdot a_x$ 都是区间加一个常数的形式。于是可以维护二阶差分。复杂度线性。</p><h1 id="USACO12-Bovine-Alliance-G"><a href="#USACO12-Bovine-Alliance-G" class="headerlink" title="USACO12 Bovine Alliance G"></a><a href="https://www.luogu.com.cn/problem/P3043" target="_blank" rel="noopener">USACO12 Bovine Alliance G</a></h1><blockquote><p><del>给出 $n$ 个点 $m$ 条边的图，现把点和边分组，每条边只能和相邻两点之一分在一组，点可以单独一组，问分组方案数</del>.</p><p>以上是错误的题意，以下是正确的题意：</p><blockquote><p>题意是给每条边找一个配对的点，要求边 $(u,v)$ 配对的点是 $u$ 或 $v$ ，且每个点最多只能被一条边配对，求不同方案数。</p></blockquote><p>$1\leq m\leq n\leq 10^5$ 。</p></blockquote><p>对着错误的题意思考了半天也不会…觉得首先对于点分组可以直接跑一个第二类斯特林数，但是这样边就没法分配了，因为可能存在边的两个端点在同一个点集内，所以可能需要套一个容斥什么的。推容斥系数可能会很高妙<del>反正我不会</del>。</p><p>然后正确的题面的话，考虑问题可以转化成给每条边定向，使得最后整张图每个点的度数都 $\leq 1$ 的方案数。然后…然后就是考察对于图论模型的洞见性有多强了：</p><p>1、不难发现一个简单环的定向方式总共是 $2$ 。</p><p>2、考虑去计算一棵树的定向方式。发现随便找一个根，显然哪个点当根对于整棵树的方案数没有影响。考虑如果将所有边都向儿子定向，那么这样一定合法，这是第一种方案。同时，单独把某一条边取反，假设这条边连接的儿子是 $x$ ，那么同时需要把 $x\to fa_x,fa_x\to fa_{fa_x}, fa_{fa_x}\to fa_{fa_{fa_x}}$ 全部取反，那么最终会取反到根，根的入度会变成 $1$ ，这也就说明不能有 $&gt;1$ 条边同时取反。所以可以知道一棵树的定向方式为 $1+(n-1)=n$ 。</p><p>发现对于无向图，本质上就是树插环的形态。所以拿一个带权并查集维护即可。有一个坑点，就是如果两个点不在同一个即集合里，边数也要++。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是由于基础太差了，然后打算去做点题补一下基础和脑子…&lt;/p&gt;
&lt;p&gt;这个故事告诉我们，永远不要偷懒，有些力气，早晚是要出的。&lt;/p&gt;
&lt;p&gt;如果来看我 blog 的你有什么好题推荐，欢迎评论，其他博客也是可以评论的（疯狂暗示&lt;/p&gt;
&lt;p&gt;对了，像我这种明明要准备省选却在刷简单题补基础的人，是不是应该发一个「年度最佳人才」奖？&lt;/p&gt;
&lt;p&gt;争取一句话题解…先整理十道题吧…因为奇奇怪怪的事情浪费了不少时间。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="思维题/对应与转化" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AF%B9%E5%BA%94%E4%B8%8E%E8%BD%AC%E5%8C%96/"/>
    
      <category term="动态规划/状态合并" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="博弈论/对称博弈" scheme="https://www.orchidany.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E5%AF%B9%E7%A7%B0%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF671E] Organizing a Race</title>
    <link href="https://www.orchidany.cn/2020/04/17/CF671E/"/>
    <id>https://www.orchidany.cn/2020/04/17/CF671E/</id>
    <published>2020-04-17T08:24:56.000Z</published>
    <updated>2020-04-21T03:35:05.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>这题十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。</p><p>做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…</p><p>接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… </p><a id="more"></a><p>XXXXXXXXXXXX 正文 XXXXXXXXXXXX</p><p>首先考虑，对于一段区间而言，需要多少操作多少次，才能保证正着走完并且反着走完。那么也就是需要算出正着走和反着走都需要额外的多少代价。</p><p>这个地方有个贪心。考虑定「向右走」为正方向。那么假设从 $i$ 开始走，如果遇到某个 $j&gt;i$ 发现走不得，那么应该在何处加油？因为还要考虑反着走回来，所以必然是加在最靠右的地方最优，所以就会选择的在 $j-1$ 处加油。记 $i$ 向右走遇到的第一个这样的 $j$ 为 $stop_i$  。</p><p>于是根据这个贪心就可以求出 $need(i,j)$ ，表示从 $i$ 走到 $j$ 需要多少代价。但这样也是只是保证了正着可以走。不妨令 $p_{i}$ 表示从 $1$ 走到 $i$ 花费的油量，$q_i$ 表示从 $i$ 走到 $1$ 花费的油量。 那么可知有递推：</p><script type="math/tex; mode=display">\begin{aligned}p_i&=p_{i-1}+g_{i-1}-w_{i-1}\\q_i&=q_{i-1}+g_{i-1}-w_i\end{aligned}</script><p>那么可以知道，在走 $i\to j$ 这条路线时，同时也在进行对 </p><script type="math/tex; mode=display">g_{stop_i},g_{stop_{stop_i}},g_{stop_{stop_{stop_i}}}\cdots</script><p>这些位置进行单点加，那么对 $q$ 的影响就是一个后缀加。记后缀加完之后的 $\{q_n\}$ 为 $\{\tau_n\}$ 。则如果不能从 $j$ 回到 $i$ ，就意味着着存在一个 $i\leq k&lt;j$ ，使得 $q_{k}-q_{j}&lt;0$ 。怎么量化这个东西呢？考虑还是贪心，如果从 $j$ 到 $i$ 走不了，那么一定会要把贡献累加到 $j$ 上，那需要累加的量就是 $q_{j}-\min_{k=i}^{j-1}\{q_{k}\}$ 。这也就是如果想要 $[i,j]$ 这个区间变得合法的最小贡献。</p><p>考虑如何计算这个东西。比较暴力的解法那必然是枚举一个左端点，然后向右走更新右端点。这样是 $n^2$ 的。发现如果想要优化，只能选择加速寻找右端点这个过程。但是有个问题在于，对于固定的 $i$ ，和想要二分出的 $j’$，要经过不同的 $stop$ 集合，同时有着不同的 $q_{j’}-\min_{k=i}^{j’-1}\{q_{k}\}$ ，求一次是 $O(n)$ 的，反而把复杂度搞成了 $n^2\log n$ 。</p><p>分开考虑这两点。对于经过不同 $stop$ 集合这个问题，可以继续深入挖掘性质。发现对于一个 $j$，可能存在一个连续段 $[k_1,k_2]$ 满足 $\forall z\in[k_1,k_2]\cap\mathbb{Z_+}$ ，$stop_z=j$ 。这种一对多的逻辑结构不难想到要用森林去表征。那么这个问题比较好解决了。建出一棵森林 $T$ ，连边 $i\leftrightarrow stop_i$ 。再建立一个虚根 $root$ ，与所有 $stop_i$ 未定义的结点相连。这样只要从 $root$ 开始 dfs，用退栈的方式辅助二分即可快速修改。</p><p>对于第二点，考虑对于一个固定的 $i$ ，本质上是在维护这么一个式子：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=i}^{j'}\{\tau_k \}</script><p>首先变一下形：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=1}^{j'}\{\tau_k \}</script><p>这样做的正确性在于，只要每次将 $&lt;i$ 的那些 $k$ 的 $\tau_k$ 都置为 $+\infty$ 就可以了。</p><p>考虑到底要怎么维护这个东西。发现在查询的过程中，需要单点修改 $g_i$ ，那么也就是区间修改 $q_j$ 和 $\tau_k$ ，那么也就是说要支持：1、维护前缀最小值 2、区间加/减 3、查询出某个最小值的位置。那自然就是线段树了。</p><p>考虑后一半的前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $\tau_k$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{\tau_k\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $q_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{k=1}^{j’}\{\tau_k\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $\tau_k$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr firsr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-7</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Fni = -(<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * f ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = y ; val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll sp[N] ;</span><br><span class="line">ll ss[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)</span><br><span class="line"><span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(sa[rt] = sb[rt] = ss[l]) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">stk[++ top] = x ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, - sp[fa[x]] + sp[x]) ;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n)&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span>, r = top - <span class="number">1</span>, ans = <span class="number">1</span>, mid ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sp[stk[mid]] - sp[x] &gt; m)</span><br><span class="line">ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll tmp = Inf ; ans = stk[ans] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Inf) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Fni) ;</span><br><span class="line">res = max(res, query(<span class="number">1</span>, <span class="number">1</span>, n, tmp) - x + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Fni) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Inf) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">stk[top --] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, sp[fa[x]] - sp[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; w[n] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) w[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) g[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">sp[i] = sp[i - <span class="number">1</span>] - g[i - <span class="number">1</span>] + w[i - <span class="number">1</span>] ;</span><br><span class="line">ss[i] = ss[i - <span class="number">1</span>] - g[i] + w[i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = n + <span class="number">1</span> ;</span><br><span class="line">    sp[n + <span class="number">1</span>] = Inf ; fa[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">while</span> (top &amp;&amp; sp[stk[top]] &lt;= sp[i]) -- top ;</span><br><span class="line">fa[i] = stk[top] ; stk[++ top] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) add_e(fa[i], i) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; top = <span class="number">0</span> ; dfs(n + <span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。&lt;/p&gt;
&lt;p&gt;你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。&lt;/p&gt;
&lt;p&gt;你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。&lt;/p&gt;
&lt;p&gt;你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。&lt;/p&gt;
&lt;p&gt;做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…&lt;/p&gt;
&lt;p&gt;接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树模型" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】兔队线段树</title>
    <link href="https://www.orchidany.cn/2020/04/16/%E5%85%94%E9%98%9F%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/04/16/兔队线段树/</id>
    <published>2020-04-16T12:38:44.000Z</published>
    <updated>2020-04-29T01:00:00.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：<a href="https://www.luogu.com.cn/problem/U96354" target="_blank" rel="noopener">Luogu U96354</a> 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233</p><p>然后今天又看到了兔的博文：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html" target="_blank" rel="noopener">从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法</a>。 感觉很神仙，然后就打算把这三道题都整理一下。</p><p><del>所以就是类似于复刻了一下兔秒掉or推荐的题</del>。</p><p>分别是三道题：<code>LGU96354 魔能阵列</code>，<code>BZOJ2957 楼房重建</code> 和 <code>CF671E Organizing a Race</code> .</p><a id="more"></a><h1 id="LGU96354-魔能阵列"><a href="#LGU96354-魔能阵列" class="headerlink" title="LGU96354 魔能阵列"></a>LGU96354 魔能阵列</h1><blockquote><p>给定两个序列 $\{a_n\},\{b_n\}$，定义一段区间 $[l,r]$ 的权值为</p><script type="math/tex; mode=display">\sum_{i=l}^r[b_i>0]a_i</script><p>现在给定两种操作，对 $\{b_n\}$ 区间加 $x$ (可正可负) 和询问某个区间的权值。保证任何时刻 $b_i\geq 0$ 。</p><p>$1 \leq n,m\leq 2 \times 10^5$   </p></blockquote><p>一个比较自然的想法，是分别维护区间 $b_i=0$ 的和 and 区间 $b_i\not = 0$ 的和。但是这个东西维护起来复杂度并不对。所以考虑换一下，由于保证任意时刻 $b_i\geq 0$ ，所以维护区间最小值， 区间 $b_i$ 的值 = 最小值的权值 and 区间 $b_i$ 的值 $\not =$ 最小值的权值和。那么转移就分类讨论一下即可。回答询问的时候只需要再建立一个虚点，对询问区间进行合并，最后只需要判断该区间最小值是否是 $0$ 即可。</p><p>大概首先维护区间最小值是个 trick ，建一个虚点对 $\log n$ 个区间进行合并也是一个 trick 。但是这俩似乎我都不是很熟，导致我当时不太会做.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> cnt, _tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>], v[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], mnx[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ;  c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[x] == mnx[y])</span><br><span class="line">        s[x] = s[x] + s[y], v[x] = v[x] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[x] &lt; mnx[y]) s[x] = s[x] + s[y] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[x] = mnx[y], s[x] = s[x] + s[y] + v[x], v[x] = v[y] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> rt, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[ls] == mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs], v[rt] = v[ls] + v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[ls] &gt; mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[rs], s[rt] = s[ls] + s[rs] + v[ls], v[rt] = v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs] + v[rs], v[rt] = v[ls] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">pdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_tag[rt])&#123;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    _tag[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    mnx[rt] = Inf, s[rt] = <span class="number">0</span>, v[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(mnx[rt] += x, _tag[rt] += x) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; pdown(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, x) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, x) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) </span><br><span class="line"><span class="keyword">return</span> _merge(ans, rt), <span class="keyword">void</span>() ;</span><br><span class="line">    pdown(rt) ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, ans) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, ans) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, N) ; (cnt *= <span class="number">2</span>) += <span class="number">1</span> ; <span class="keyword">int</span> l, r, x, opt ;</span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        opt = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            l = qr(), r = qr(), x = qr(), update(<span class="number">1</span>, <span class="number">1</span>, N, l, r, x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++ cnt, l = qr(), r = qr() ;</span><br><span class="line">            init(cnt), query(<span class="number">1</span>, <span class="number">1</span>, N, l, r, cnt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mnx[cnt] ? s[cnt] + v[cnt] : s[cnt]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bzoj2957-楼房重建"><a href="#bzoj2957-楼房重建" class="headerlink" title="bzoj2957 楼房重建"></a>bzoj2957 楼房重建</h1><blockquote><p>单点修改，查询整个序列有多个前缀最大值。</p><p>$1\leq n,m\leq 10^5$</p></blockquote><p>sto 兔。</p><p>首先考虑这东西暴力做的话，就是在模拟一个单调栈的过程。带修的话就要考虑套一个 ds。考虑 ds 的作用，本质上是要在每次修改完 $x$ 之后，将 $[1,x-1]$ 和 $[x+1,n]$ 这两个区间的单调栈和 $x$ 放在一起合并。于是不难想到要用线段树。</p><p>但…线段树似乎也没法快速合并。考虑每次 <code>push_up</code> 暴力把右区间合并到左区间里面，这样做显然是单次 $O(n)$ 的。考虑发掘更深一些，每次合并左右区间时，左区间是不受影响的，只需要统计左区间最大值对右区间答案的贡献。考虑每次合并，左区间最大值对右区间的影响一定是一个右区间的一个前缀。所以只需要每次合并时，线段树上二分出这个前缀的位置来即可。</p><p>然后实现的时候需要注意，二分完前缀之后，前缀的贡献是 $1$ ，剩下的后缀贡献不是 $cnt_{rc}$ 而是 $cnt_{root}-cnt_{lc}$ 。因为此时需要加上的是<strong>合并之后</strong>右区间对整体有多少贡献。</p><p>这样线段树二分 $1$ 个 $\log $ ，本身 <code>update</code> 又是 $1$ 个 $\log $ 。复杂度 $m\log ^2 n$ 。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line">db base[N] ;</span><br><span class="line">db s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> cnt[N * <span class="number">3</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">s[rt] = <span class="number">0</span> ; </span><br><span class="line">cnt[rt] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ; </span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, db v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> (s[rt] &gt; v) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (s[ls] &gt; v) </span><br><span class="line"><span class="keyword">return</span> query(ls, l, mid, v) + cnt[rt] - cnt[ls] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(s[rt] = base[l]) ; </span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= p) </span><br><span class="line">update(ls, l, mid, p) ; </span><br><span class="line"><span class="keyword">else</span> update(rs, mid + <span class="number">1</span>, r, p) ; </span><br><span class="line">s[rt] = max(s[ls], s[rs]) ; </span><br><span class="line">cnt[rt] = cnt[ls] + query(rs, mid + <span class="number">1</span>, r, s[ls]) ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; <span class="keyword">int</span> x ; db y ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">x = qr(), y = qr(), base[x] = (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * x) ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, x) ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CF671E-Organizing-a-Race"><a href="#CF671E-Organizing-a-Race" class="headerlink" title="CF671E Organizing a Race"></a>CF671E Organizing a Race</h1><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。</p><p>第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。</p><p>车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。</p><p>问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>这个地方的转化会单独开一篇新的 $blog$，因为比较毒瘤。大概最后就是转化成了令</p><script type="math/tex; mode=display">t_i=suf_i-\min_{j=1}^i\{suf'_j\}</script><p>求最大的 $i$ 满足 $t_i\leq k$ 。然后要支持 $suf’_i$ 的区间加/减以及多次询问。</p><p>考虑后一半就是前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $suf’$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{suf_j’\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $a_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{j=1}^i\{suf’_j\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $suf’$ 。</p><p>这里就先只给出线段树部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &gt;= v)</span><br><span class="line">    <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">sa[rt] = ss[l] ; </span><br><span class="line">    sb[rt] = ss[l]</span><br><span class="line">    <span class="keyword">return</span>  ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：&lt;a href=&quot;https://www.luogu.com.cn/problem/U96354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu U96354&lt;/a&gt; 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233&lt;/p&gt;
&lt;p&gt;然后今天又看到了兔的博文：&lt;a href=&quot;https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法&lt;/a&gt;。 感觉很神仙，然后就打算把这三道题都整理一下。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所以就是类似于复刻了一下兔秒掉or推荐的题&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;分别是三道题：&lt;code&gt;LGU96354 魔能阵列&lt;/code&gt;，&lt;code&gt;BZOJ2957 楼房重建&lt;/code&gt; 和 &lt;code&gt;CF671E Organizing a Race&lt;/code&gt; .&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj2391 Cirno的忧郁</title>
    <link href="https://www.orchidany.cn/2020/04/15/Cirno-%E7%9A%84%E5%BF%A7%E9%83%81/"/>
    <id>https://www.orchidany.cn/2020/04/15/Cirno-的忧郁/</id>
    <published>2020-04-15T13:19:00.000Z</published>
    <updated>2020-04-16T01:34:32.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Cirno 闲着无事的时候喜欢冰冻青蛙。</p><p>雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。</p><p>Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。</p><p>因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。</p><p>对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&lt;v\leq 10^4$ 。</p></blockquote><p>不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。</p><p>紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。</p><a id="more"></a><p>大概考虑三角剖分本来是用于求多边形面积，方法是选择一个原点，按照逆时针或者顺时针的方式，把多边形顶点向量叉一圈的结果。形式化地讲，给定一个多边形 $A_1A_2A_3\ldots A_n$ ，那么这个多边形的面积就是</p><script type="math/tex; mode=display">\frac{\overrightarrow{O A_{n}}\times \overrightarrow{OA_1}}{2}+\sum_{i=1}^{n-1} \frac{\overrightarrow{O A_{i}}\times \overrightarrow{OA_{i+1}}}{2}</script><p>证明的话可能容斥可证，但我不会…我只知道两个向量的叉积是以这两个向量为临边的平行四边形的面积。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140847.png" alt="wjyyy的图"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140906.png" alt="wjyyy的图"></p><p>然后这里放了神仙 <code>wjyyy</code> 的图，看上去比较直观。</p><p>然后考虑这题怎么做。发现 $n+m$ 不大，于是考虑求一个 $f_{i,j}$ 表示向量 $\bf V_i$ 与 $\bf V_{j}$ 之间，$\bf V_{i}\to \bf V_{j}$ 需要逆时针旋转时，$i,j$ 之间的价值和。那么对于每一个询问 $\{s_n\}$ ，答案就是 $\sum f_{s_i,s_{i+1}}$ 。 </p><p>考虑如何预处理这个东西。首先对所有向量按照极角逆时针排序(相等则模长大者位次靠后)，枚举 $i$ ，之后就需要喜闻乐见的平衡树了。大概是这样：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>其中红色向量是题目所给的向量，蓝色向量是辅助线。因为一开始就已经是逆时针排序，所以只需要判断每个向量的中点是否落在向量 $\bf i,j,t_2$ 构成的三角形即可。观察落在三角形内部的向量 $\bf k$ 和落在外部的向量 $\bf p$ ，会发现有 </p><script type="math/tex; mode=display">\bf {\text{<}i,t_1\text{>} \geq \text{<}i,t_2\text{>}\geq \text{<}i,t_3\text{>}}</script><p>考虑向量夹角最大为 $\pi$ ，$y=\cos x$ 在 $[0,\pi]$ 上单调递减，于是可以知道要拿 $\cos x$ 作为键值，该向量的 $val$ 作为点值插入平衡树。其中 $\cos x$ 拿向量内积求即可。 </p><p>最终复杂度 $O(n^2\log n+ms)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pts</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; <span class="keyword">int</span> val ; db x, y ;</span><br><span class="line"><span class="function">il db <span class="title">mo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y) ; &#125;</span><br><span class="line">il <span class="keyword">friend</span> pts <span class="keyword">operator</span> - (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> (pts)&#123;<span class="number">0</span>, <span class="number">0</span>, p.x - q.x, p.y - q.y&#125; ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> * (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.y - p.y * q.x ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> + (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.x + p.y * q.y ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;v[N], org, calc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">cosi</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / (a.mo() * b.mo()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line">db ang = (a - org) * (b - org) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ang &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">if</span> (ang != eps) <span class="keyword">return</span> ang &gt; eps ;</span><br><span class="line"><span class="keyword">return</span> (a - org).mo() &lt; (b - org).mo() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _splay&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> val ;</span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> fa ;</span><br><span class="line"><span class="keyword">int</span> sz ;</span><br><span class="line">db key ;</span><br><span class="line">&#125;s[N] ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) s[x].sz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(x) s[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key(x) s[x].key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot(x) s[x].tot</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) s[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size ;</span><br><span class="line"><span class="keyword">int</span> root ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x == rc(fa(x))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size ; ++ i)&#123;</span><br><span class="line">sz(i) = lc(i) = rc(i) = fa(i) = <span class="number">0</span> ;</span><br><span class="line">tot(i) = val(i) = key(i) = sum(i) = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span> ; root = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz(x) = tot(x) ;</span><br><span class="line">sum(x) = val(x) ;</span><br><span class="line"><span class="keyword">if</span> (lc(x))&#123;</span><br><span class="line">sz(x) += sz(lc(x)) ;</span><br><span class="line">sum(x) += sum(lc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rc(x))&#123;</span><br><span class="line">sz(x) += sz(rc(x)) ;</span><br><span class="line">sum(x) += sum(rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = w(x) ;</span><br><span class="line"><span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line"><span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line"><span class="keyword">if</span> (!f2) root = x ;</span><br><span class="line"><span class="keyword">else</span> s[f2].son[w(f1)] = x ;</span><br><span class="line">fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">fa(s[x].son[c ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">s[f1].son[c] = s[x].son[c ^ <span class="number">1</span>] ;</span><br><span class="line">s[x].son[c ^ <span class="number">1</span>] = f1 ; upd(f1), upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (fa(x) != aim)&#123;</span><br><span class="line"><span class="keyword">if</span> (fa(fa(x)) != aim)</span><br><span class="line">rotate(w(x) == w(fa(x)) ? fa(x) : x) ;</span><br><span class="line">rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;x, db ky, <span class="keyword">int</span> v, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line">x = ++ size ;</span><br><span class="line">fa(x) = dad ;</span><br><span class="line">key(x) = ky ;</span><br><span class="line">val(x) = sum(x) = v ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ky &lt; key(x))</span><br><span class="line">Ins(lc(x), ky, v, x) ;</span><br><span class="line"><span class="keyword">else</span> Ins(rc(x), ky, v, x) ; upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> _splay ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">org.x = <span class="number">-100000</span> ;</span><br><span class="line">org.y = <span class="number">-100000</span> ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">db x, y, w ; <span class="keyword">int</span> z, h, r ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, v[++ cnt] = (pts)&#123;i, <span class="number">0</span>, x, y&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w, v[++ cnt] = (pts)&#123;i, w, x, y&#125; ;</span><br><span class="line">sort(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, comp) ; m = n ; n = cnt ; <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (v[i].id &gt; m) <span class="keyword">continue</span> ;</span><br><span class="line">clear() ; pts o = v[i] - org ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">pts z = v[j] - v[i] ; db ky = cosi(o, z) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; '\n' ;</span></span><br><span class="line">Ins(root, ky, v[j].val, <span class="number">0</span>) ; splay(size, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(v[j].id &lt;= m)&#123;</span><br><span class="line">            f[v[i].id][v[j].id] = sum(lc(root)) ;</span><br><span class="line">            f[v[j].id][v[i].id] = - sum(lc(root)) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n] ; */</span></span><br><span class="line"><span class="keyword">while</span> (q --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; L ; <span class="built_in">cin</span> &gt;&gt; h ; r = h ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; z, ans += f[h][z], h = z ;</span><br><span class="line">ans += f[h][r] ; <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(ans)) ; ans = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写了一遍 splay，发现是真的慢+维护的信息真的多…</p><p>并且发现递归式的 splay 插入是真的好写。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Cirno 闲着无事的时候喜欢冰冻青蛙。&lt;/p&gt;
&lt;p&gt;雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。&lt;/p&gt;
&lt;p&gt;Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。&lt;/p&gt;
&lt;p&gt;因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&amp;lt;v\leq 10^4$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。&lt;/p&gt;
&lt;p&gt;紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="计算几何/三角剖分" scheme="https://www.orchidany.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
    
      <category term="数据结构/平衡树/splay" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E6%A0%91-splay/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj3881[COCI2015] Divljak</title>
    <link href="https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/"/>
    <id>https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/</id>
    <published>2020-04-15T13:17:33.000Z</published>
    <updated>2020-04-29T13:12:21.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。</p><p>接下来会发生 $q$ 个操作，操作有两种形式：</p><ol><li><code>1 P</code> Bob 往自己的集合里添加了一个字符串 $\rm P$。</li><li><code>2 x</code> Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。</li></ol><p>对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。</p></blockquote><p>今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。</p><p>啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq</p><a id="more"></a><p>大概是考虑，反正是匹配问题——那么是对着 $\rm T$ 建自动机呢，还是对 $\rm \{S_n\}$ 建。 考虑 AC 自动机更适合做这种匹配题，于是大概想到要拿 AC 自动机做；考虑如果对着 $\rm T$ 建自动机，树的形态会变，$\rm S$ 的信息需要动态维护，并不很好做，于是考虑对 $\rm S$ 建自动机 $\rm AC_s$。</p><p>考虑这样做，就需要在已经建好的自动机上，对于每个新加进来的 $P$ 计算贡献。那么会被 $P$ 包含的字符串，一定是 $P$ 在 $\rm AC_s$ 里匹配的 $endpos$ 到根的路径上每个点，到根的链上的点集并。暴力是 $n^2$ 的，考虑如何快速计算这个贡献，发现能做到最快的，也就是通过维护 dfs 序的方式求出点集并。对于每一个这样的链的并打一个标记。询问的时候只需要回答一下子树内有多少个点被打了不同的标记。</p><p>发现「维护树链标记」+「子树求和」，最快速的方法是维护差分。同时由于是动态的，可以想到用线段树或者 BIT 快速维护。</p><p>考虑修改如何进行。发现为了保证 $\land$ 形态的链只会被计数一次，需要在 $lca$ 处差分。此处需要注意的是，要对 $dfs$ 序排序之后，再逐个差分，方法是 $(i,+1),(i+1,+1),(lca_{i,i+1},-1)$ 。</p><p>想了半天才大约明白为什么要按 dfs 序排一遍序。大概是如果不按 dfs 序的顺序枚举，可能会出现某个子树未被成功打上标记的情况。</p><p>最终复杂度是 $O(\rm |S|\log |S|)$ 的，跑的不是很快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigma 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2001010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> T, M, N, L[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], base[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> _ed[MAXN], dfn[MAXN], rgl[MAXN], rgr[MAXN], tp ;</span><br><span class="line"><span class="keyword">int</span> sz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN], val[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp,</span><br><span class="line">    dfn[u] = rgl[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">    rgr[u] = tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    val[rt] = val[rt &lt;&lt; <span class="number">1</span>] + val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= p)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; pr &gt;= r) <span class="keyword">return</span> val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, pl, pr) ;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pl, pr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> _size, fail[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L[n] ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trie[rt][x])</span><br><span class="line">                trie[rt][x] = ++ _size ;</span><br><span class="line">            rt = trie[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[n] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.front() ; add(fail[n], n), q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trie[n][i]) trie[n][i] = trie[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trie[n][i]] = trie[fail[n]][i], q.push(trie[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, rt = <span class="number">0</span> ; tp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            x = S[i] - <span class="string">'a'</span>, rt = trie[rt][x], base[++ tp] = rt ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + tp + <span class="number">1</span>, comp),</span><br><span class="line">        tp = unique(base + <span class="number">1</span>, base + tp + <span class="number">1</span>) - base - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tp ; ++ i)&#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[base[i]], <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[lca(base[i], base[i - <span class="number">1</span>])], <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">// freopen("1.ans", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> m, q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= T ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), L[i] = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.insert(S, i) ;</span><br><span class="line">    AC.build() ; <span class="built_in">cin</span> &gt;&gt; M ; dfs(<span class="number">0</span>), dfs2(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= T ; ++ i) cout &lt;&lt; rgl[i] &lt;&lt; " " &lt;&lt; rgr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        m = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.solve(S) ;</span><br><span class="line">        <span class="keyword">else</span> q = qr(),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgr[_ed[q]]) - query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgl[_ed[q]] - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。&lt;/p&gt;
&lt;p&gt;接下来会发生 $q$ 个操作，操作有两种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 P&lt;/code&gt; Bob 往自己的集合里添加了一个字符串 $\rm P$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x&lt;/code&gt; Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。&lt;/p&gt;
&lt;p&gt;啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="树上技巧/dfs序+树状数组" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串/AC自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
