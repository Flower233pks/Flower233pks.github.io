<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-QtLHMuKZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QtLHMuKZ"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-02-14T01:39:05.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ</p><p>如果可以的话，谢谢你喜欢我！</p><a id="more"></a><h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p><p>CSP-2019考的太菜，导致现在十分被动。</p><p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p><p>其实挺热爱算法的吧？</p><p>CF平时真的不是很常打，所以并不想给CF的ID。sorry啦。</p><p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p><p>QQ:2836531293</p><h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p><p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p><p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p><p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p><p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p><h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p><p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p><h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p><p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p><h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p><p>我一个人很无聊的说QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ&lt;/p&gt;
&lt;p&gt;如果可以的话，谢谢你喜欢我！&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>动态规划杂项</title>
    <link href="https://www.orchidany.cn/2020/02/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.orchidany.cn/2020/02/22/动态规划杂项/</id>
    <published>2020-02-22T00:09:33.000Z</published>
    <updated>2020-02-22T07:00:09.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是听课笔记。</p><a id="more"></a><h1 id="单调队列部分"><a href="#单调队列部分" class="headerlink" title="单调队列部分"></a>单调队列部分</h1><p>单调队列主要用来优化，对于状态 $\rm S$ 的某个后继状态 $\rm S’$，如果 $\rm S’$ 比 $\rm S$ 更优就可以舍弃掉 $\rm S$ 的转移。通常表现形式为会有限制，比如</p><script type="math/tex; mode=display">f_{i}=\max\{f_j\}+w_i \quad(j\in[L_i,i-1]\cap\mathbb Z)</script><p>其中 $\{L\}$ 是一个给定常数，且 $\forall i, L_i\geq L_{i-1}$ 。那么可知对于后续状态 $s_i$ ，他的可转移范围一定更大，至少比 $s_j$ 大，所以可以删除 $s_j$.</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知 $L_i$ 不降，于是就对每个 $d$ 用单调队列即可。</p><h1 id="斜率优化部分"><a href="#斜率优化部分" class="headerlink" title="斜率优化部分"></a>斜率优化部分</h1><p>这部分虽然简单但是不熟，所以可能需要多做点题。</p><h2 id="傻狗题"><a href="#傻狗题" class="headerlink" title="傻狗题"></a>傻狗题</h2><blockquote><p>把一个长为 $n$ 的正整数序列划分成若干段，每一段的代价是内部元素和的平方加上一个定值 $m$。求划分整个序列的最小代价。</p></blockquote><p>可知转移</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_i-s_j)^2\}+m</script><script type="math/tex; mode=display">f_j+s_j^2=2s_is_j+f_i-s_i^2-m</script><p>于是就变成了有一个以 $s_i$ 为斜率，$f_j+s_j^2$ 为纵坐标，$s_i$ 为横坐标的斜率优化。考虑横坐标和斜率都是单调的，就可以直接队尾删/队尾插入。</p><h2 id="USACO08MAR-Land-Acquisition"><a href="#USACO08MAR-Land-Acquisition" class="headerlink" title="[USACO08MAR]Land Acquisition"></a>[USACO08MAR]Land Acquisition</h2><blockquote><p>有 $n$ 块长方形的土地需要购买，你每次可以选择一组土地一起购买，价 格为这些土地中最大的长乘以最大的宽。求购买所有土地的最小费用。 </p><p>$n ≤ 50000$</p></blockquote><p>考虑先排序，然后考虑如果直接 $dp$，那么本身需要枚举 $i\sim j$ 之间的元素取 $\max$，这样显然复杂度就多了一维 $n$。仔细思考后发现，如果对于一组 $(i,j)$，满足 $w_i\geq w_j$ 且 $h_i\geq j_j$ ，那么就可以删掉 $j$ 。具体的，考虑按照 $h$ 排序之后，用一个单调栈来维护这个东西。</p><p>那么这样最后剩下的一定满足 $w$ 单调。所以就会得到类似</p><script type="math/tex; mode=display">f_i=\min\{f_{j}+h_{j+1}\cdot w_i\}\\f_j=-h_{j+1}\cdot w_i+f_i</script><p>那么令 $h_{j+1}$ 作为横坐标，横坐标单调；$w_i$ 作为斜率，斜率单调。于是就变成了最 <code>general</code> 的斜率优化问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">LL f[N] ;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grid</span>&#123;</span></span><br><span class="line">    LL x, y ;</span><br><span class="line">&#125;base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(grid a, grid b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &gt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!top || t[top].y &lt; base[i].y) t[++ top] = base[i] ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= 50 ; ++ i) cout &lt;&lt; t[i].x &lt;&lt; " " &lt;&lt; t[i].y &lt;&lt; endl ;</span></span><br><span class="line">    n = top ; q.push_back(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.front() ; q.pop_front() ; o = q.front() ;</span><br><span class="line">            <span class="keyword">if</span> (f[p] - f[o] &lt;= t[i].y * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_front(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         f[i] = f[q.front()] + t[q.front() + <span class="number">1</span>].x * t[i].y ;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.back() ; q.pop_back() ; o = q.back() ;</span><br><span class="line">            <span class="keyword">if</span> ((f[p] - f[o]) * (t[p + <span class="number">1</span>].x - t[i + <span class="number">1</span>].x) &lt;= (f[i] - f[p]) * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_back(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         q.push_back(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BTW，如何推凸包的维护方式，可以考虑是维护下凸壳还是上凸壳，但是似乎又一种方式更简便：</p><p>令 $0\leq k&lt;j&lt;i$ ，那么如果 $j$ 比 $k$ 好，那么需要满足</p><script type="math/tex; mode=display">\begin{aligned}f_{j}+w_{j+1} \times l_{i} & \leq f_{k}+w_{k+1} \times l_{i} \\f_{j}-f_{k} & \leq l_{i} \times\left(w_{k+1}-w_{j+1}\right)\\l_{i} &\geq \frac{f_{j}-f_{k}}{w_{k+1}-w_{j+1}}\end{aligned}</script><p>这么做就会比较直观？</p><p>值得注意的是，斜率优化的时候很可能会因为移项的时候符号变错了而GG。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实就是听课笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="泛学" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%AD%A6/"/>
    
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj1559 [JSOI2009]密码</title>
    <link href="https://www.orchidany.cn/2020/02/20/JSOI2009%E5%AF%86%E7%A0%81/"/>
    <id>https://www.orchidany.cn/2020/02/20/JSOI2009密码/</id>
    <published>2020-02-20T10:53:03.000Z</published>
    <updated>2020-02-21T01:47:20.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定长度 $L$ 个 $m$ 个子串，要求拼出一个长度为 $L$ 的长串使之包含所有的子串。</p><p>如果方案数 $\leq42$ 则输出全部方案，否则只输出方案数。</p><p>$L\leq 25,m\leq 10$。</p></blockquote><a id="more"></a><p>…这题大概也就是蓝~紫左右，这个黑实在太虚了。</p><p>但这不影响我还是不太会233</p><p>观察题意，由 <code>good+day=gooday</code> 可知应该放在 $\rm AC$ 自动机上做，因为存在重合。观察范围可知是状压。于是考虑在 $\rm$ AC 自动机上 $dp$。</p><p>记 $f_{i,j,s}$ 表示匹配到串的第 $i$ 位，走到了自动机上的第 $j$ 个节点，当前已经拼完了集合 $s$ 中的模式串的方案数。转移的话就考虑直接枚举当前状态的所有子状态，暴力转移即可（用来计数的状压 $dp$ 还能怎么转移啊喂）。值得提一句的的是，由于本身 $\rm AC$ 自动机存在路径压缩，所以是 <code>认子不认父</code> 的结构，只能刷表而不能填表。</p><p>之后考虑输出方案。发现如果直接搜 $\rm AC$ 自动机上的每个方案十分暴力，于是考虑加一个可行性剪枝。即由于很容易 $dfs$ 出每个状态 $(i,j,s)$ 是否可以转移到终点，所以不需要考虑 $42$ 的限制，预处理一个 $g_{i,j,s}$是否可以拼出最终状态，剪完枝直接输出即可。</p><p>同时，只要在 $\rm AC$ 自动机上保证每次走最小的字母，就一定是字典序最优的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> o ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line">LL f[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> g[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> v[N][W][Z] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> _ed[W] ;</span><br><span class="line">    <span class="keyword">int</span> fail[W] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> trans[W][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *t, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, len ;</span><br><span class="line">        len = <span class="built_in">strlen</span>(t + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span> ; i &lt;= len ; ++ i)&#123;</span><br><span class="line">            x = t[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trans[rt][x])</span><br><span class="line">                trans[rt][x] = ++ size ;</span><br><span class="line">            rt = trans[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[rt] |= (<span class="number">1</span> &lt;&lt; num) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">            q.pop() ; _ed[x] |= _ed[fail[x]] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[x][i]) trans[x][i] = trans[fail[x]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trans[x][i]] = trans[fail[x]][i], q.push(trans[x][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] = (<span class="keyword">bool</span>)(z == o) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> p = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v[x][y][z])</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] ;</span><br><span class="line">    <span class="keyword">else</span> v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        p |= search(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">    <span class="keyword">return</span> g[x][y][z] = p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g[x][y][z]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, t[i] + <span class="string">'a'</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        t[x + <span class="number">1</span>] = i, output(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; S.size = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), S.Ins(s, i - <span class="number">1</span>) ;</span><br><span class="line">    S.build() ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; o = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= S.size ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= o ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j][k])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; <span class="number">26</span> ; ++ l)</span><br><span class="line">                        f[i + <span class="number">1</span>][S.trans[j][l]][k | S._ed[S.trans[j][l]]] += f[i][j][k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= S.size ; ++ i) ans += f[n][i][o] ;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">42</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>, search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), output(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定长度 $L$ 个 $m$ 个子串，要求拼出一个长度为 $L$ 的长串使之包含所有的子串。&lt;/p&gt;
&lt;p&gt;如果方案数 $\leq42$ 则输出全部方案，否则只输出方案数。&lt;/p&gt;
&lt;p&gt;$L\leq 25,m\leq 10$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="字符串/AC自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj2555 Substring</title>
    <link href="https://www.orchidany.cn/2020/02/20/bzoj2555/"/>
    <id>https://www.orchidany.cn/2020/02/20/bzoj2555/</id>
    <published>2020-02-20T10:43:05.000Z</published>
    <updated>2020-02-21T01:47:27.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>要求实现两种操作：</p><p>(1): 在当前字符串的后面插入一个字符串</p><p>(2): 询问字符串 $s$ 在当前字符串中出现了几次？(作为连续子串)</p><p>你必须在线支持这些操作。</p><p>长度 $\leq 600000$，询问次数 $\leq 10000$，询问总长度 $\leq 3,000,000$。 </p></blockquote><a id="more"></a><p>一直听说有 $\rm LCT$ 维护 $parent$ 树的题，没想到真做到了233。</p><p>考虑字符串 $s$ 出现的次数，在SAM中，一个节点里面的某个子串的出现次数就是它的子树的出现次数和，因为长的后缀与短的后缀之间信息不共享，所以修改操作本质上是在进行 $parent$ 树上的链加。</p><p>考虑一种神奇的写法。每次对于新建的节点 $np$ ，他的贡献应该是 $parent$ 树上 $1\sim np$ 这条路径上的所有点。于是考虑先 <code>merge(1, np)</code> ，把 $np$ 给 <code>splay</code> 上去之后内部就变成了一棵以 $np$ 为根的一条链，这样就可以不用考虑链加，直接在 $np$ 处打标记即可。</p><p>似乎查询操作更为神奇。因为查询的时候只需要对于走到的一个点 $x$ ，直接把他 <code>splay</code> 掉就可以维护信息。看上去似乎不是很对，因为对 $x$ 产生贡献的是一颗子树而不是一条链。但这样做其实有他独特的正确性保证，即每个点都存在且仅存在于一棵 <code>splay</code> ，换 <code>splay</code> 的时候势必要 <code>access</code>，而 <code>access</code> 时本质上就已经把原来的标记给下放干净了，所以每次只有可能是当前的 <code>splay</code> 还有信息没有维护清楚。也就是每次只需要管一条链，剩下的链的标记已经清完了。这样就只需要 <code>splay</code> 一下即可。</p><p>写的时候，为了卡常发现了个更神奇的地方，就是在SAM里面抠点插子树/插点这两个操作，由于都保证了父亲不存在，所以 <code>Link</code> 这个操作，本质上是不需要 <code>make_root</code> 的，实测这样就会快很多很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(x) t[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tg(x) t[x].tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> tag ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[M] ;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">char</span> o[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span> ; swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tg(x))&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) vl(lc(x)) += tg(x), tg(lc(x)) += tg(x) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) vl(rc(x)) += tg(x), tg(rc(x)) += tg(x) ;</span><br><span class="line">        tg(x) = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (nroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x ;</span><br><span class="line">    stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(y))</span><br><span class="line">        stk[++ tp] = (y = fa(y)) ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (nroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    access(y) ; splay(y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    fa(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    merge(x, y) ;</span><br><span class="line">    fa(x) = t[y].son[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> mk)</span> </span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; len ; ++ j)</span><br><span class="line">        mk = (mk * <span class="number">131</span> + j) % len, swap(s[j], s[mk]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> last ;</span><br><span class="line">    <span class="keyword">int</span> len[M] ;</span><br><span class="line">    <span class="keyword">int</span> fal[M] ;</span><br><span class="line">    <span class="keyword">int</span> trans[M][<span class="number">2</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> q, nq, p = last ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fal[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)&#123;</span><br><span class="line">            fal[np] = <span class="number">1</span> ;</span><br><span class="line">            link(np, <span class="number">1</span>), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)&#123;</span><br><span class="line">            fal[np] = q ;</span><br><span class="line">            link(np, q), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        cut(fal[q], q) ;</span><br><span class="line">        fal[nq] = fal[q] ;</span><br><span class="line">        link (q, nq) ;</span><br><span class="line">        link (np, nq) ;</span><br><span class="line">        link (nq, fal[q]) ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        fal[q] = fal[np] = nq ;</span><br><span class="line">        splay(q) ; vl(nq) = vl(q) ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">8</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fal[p] ;</span><br><span class="line">        merge(<span class="number">1</span>, np), vl(np) ++, tg(np) ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ; S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) S.Ins(s[i] - <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, o + <span class="number">1</span>) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), Input(ans) ;</span><br><span class="line">        <span class="keyword">if</span> (o[<span class="number">1</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)</span><br><span class="line">                S.Ins(s[i] - <span class="string">'A'</span>) ; <span class="comment">//, cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rt = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)&#123;</span><br><span class="line">                rt = S.trans[rt][s[i] - <span class="string">'A'</span>] ;</span><br><span class="line">                <span class="keyword">if</span> (!rt) <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!rt) res = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">else</span> splay(rt), res = vl(rt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res) ; ans = ans ^ res ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要求实现两种操作：&lt;/p&gt;
&lt;p&gt;(1): 在当前字符串的后面插入一个字符串&lt;/p&gt;
&lt;p&gt;(2): 询问字符串 $s$ 在当前字符串中出现了几次？(作为连续子串)&lt;/p&gt;
&lt;p&gt;你必须在线支持这些操作。&lt;/p&gt;
&lt;p&gt;长度 $\leq 600000$，询问次数 $\leq 10000$，询问总长度 $\leq 3,000,000$。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="字符串/后缀自动机(SAM)" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    
      <category term="LCT" scheme="https://www.orchidany.cn/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#2059 [HEOI/TJOI2016]字符串</title>
    <link href="https://www.orchidany.cn/2020/02/20/HEOI-TJOI2016%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.orchidany.cn/2020/02/20/HEOI-TJOI2016字符串/</id>
    <published>2020-02-20T10:32:16.000Z</published>
    <updated>2020-02-22T10:30:17.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个串，每次给出区间 $[a,b]$ 和 $[c,d]$，询问 $[a,b]$ 中的子串与 $s[c…d]$ 的 $lcp$ 最大值。</p><p>要求做法 $n~\mathrm{poly}(\log)$，其中 $\deg(\mathrm{poly}(\log))\leq 3$ 。 </p></blockquote><a id="more"></a><p>考虑二分，那么就变成了一个判定性问题，即考虑 $s[c…c+mid-1]$ 在 $[a…b]$ 中是否出现过。那么考虑倍增，对于每个点可以倍增出 $s[1…c+mid-1]$ 的 $endpos$ 所在的那个节点，那么现在就是要求这个 $endpos$ 中是否存在某个元素 $\in$ $[a+mid-1,b]$ 。 那么这个东西就可以插入时维护每个点当前的 $endpos$，之后对当前的 $parent$ 树做一次线段树合并即可。</p><p>需要注意的是这种写法的线段树合并可能会炸空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> Id[N] ;</span><br><span class="line"><span class="keyword">char</span> t[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> dad[N][<span class="number">21</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> lc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rt[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> sum[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[rt] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= mid) Ins(lc[rt], l, mid, v) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(rc[rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[rt] ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res += query(lc[rt], l, mid, ql, qr) ;</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res += query(rc[rt], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = ++ size ;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> y ;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[p] = sum[x] + sum[y] ;</span><br><span class="line">        lc[p] = merge(lc[x], lc[y], l, mid) ;</span><br><span class="line">        rc[p] = merge(rc[x], rc[y], mid + <span class="number">1</span>, r) ;</span><br><span class="line">        <span class="keyword">return</span> p ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">20</span> ; ++ k)</span><br><span class="line">        dad[x][k] = dad[dad[x][k - <span class="number">1</span>]][k - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        dad[to(k)][<span class="number">0</span>] = x, dfs(to(k)) ;</span><br><span class="line">        T.rt[x] = T.merge(T.rt[x], T.rt[to(k)], <span class="number">1</span>, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N] ;</span><br><span class="line">    <span class="keyword">int</span> len[N] ;</span><br><span class="line">    <span class="keyword">int</span> last, size ;</span><br><span class="line">    <span class="keyword">int</span> trans[N][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, nq ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fa[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = <span class="number">1</span>, last ;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = q, last ;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        fa[nq] = fa[q] ;</span><br><span class="line">        fa[q] = fa[np] = nq ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">104</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">        <span class="keyword">return</span> last ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= size ; ++ i) add(fa[i], i) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("str5.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>), S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Id[i] = S.Ins(t[i] - <span class="string">'a'</span>) ;</span><br><span class="line">        T.Ins(T.rt[Id[i]], <span class="number">1</span>, n, i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    S.Add() ; dfs(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = min(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>), mid, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> x = Id[c + mid - <span class="number">1</span>] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; mid &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (dad[x][j] &amp;&amp; S.len[dad[x][j]] &gt;= mid)</span><br><span class="line">                    x = dad[x][j] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (T.query(T.rt[x], <span class="number">1</span>, n, a + mid - <span class="number">1</span>, b))</span><br><span class="line">                ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个串，每次给出区间 $[a,b]$ 和 $[c,d]$，询问 $[a,b]$ 中的子串与 $s[c…d]$ 的 $lcp$ 最大值。&lt;/p&gt;
&lt;p&gt;要求做法 $n~\mathrm{poly}(\log)$，其中 $\deg(\mathrm{poly}(\log))\leq 3$ 。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="字符串/后缀自动机(SAM)" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    
      <category term="数据结构/数据结构方法/线段树合并" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】矩阵加速转移</title>
    <link href="https://www.orchidany.cn/2020/02/20/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82dp%E6%B3%9B%E5%81%9A/"/>
    <id>https://www.orchidany.cn/2020/02/20/矩阵快速幂dp泛做/</id>
    <published>2020-02-20T08:58:33.000Z</published>
    <updated>2020-02-21T01:49:09.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是整理“[HNOI2008]GT考试”和“[SNOI2017]礼物”两道题。由于实在找不出什么共同点来，所以就随便找了个理由把两道题放在一起了233</p><p>从各个角度来看，都算是比较妙的设计方式了？</p><a id="more"></a><h1 id="HNOI2008-GT考试"><a href="#HNOI2008-GT考试" class="headerlink" title="[HNOI2008]GT考试"></a>[HNOI2008]GT考试</h1><blockquote><p>求 $n$ 位数字串不连续包括某个长度为 $m$ 的数字串的方案数。</p><p>$n\leq 10^9,m\leq 20$</p></blockquote><p>考虑直接 $dp$ 。个人认为这个地方还是有一点 trivial 的。首先就是考虑一种状态设计，记 $f_{i,j}$ 表示长串匹配到第 $i$ 位，短串匹配到第 $j$ 位的合法方案数。那么考虑可以转移：</p><script type="math/tex; mode=display">f_{i,j}=\sum_{k=0}^{9}f_{i-1,o}</script><p>其中 $o=0\sim j-1$，取决于怎么个失配法。这样转移似乎并不可以。于是考虑另一种方式转移</p><script type="math/tex; mode=display">f_{i,j}=\sum_{k=0}^{m-1}f_{i-1,k}\cdot g_{k,j}</script><p>其中 $g_{x,y}$ 表示现在已经匹配到了第 $x$ 位，有多少种方案使得在加了一个数字后变成匹配到 $y$ 位的方案数。</p><p>发现本质上这就是在做一个 KMP。于是可以用 KMP 预处理处这样的一张数表 $\{g\}$ 。同时，发现对于原来的式子，右边的 $g$ 不变，且转移方式就是矩阵的转移方式，于是考虑直接用矩阵优化掉。最终复杂度 $m^3\log n$。</p><p>btw，由于本质上转移已经写在那里了，所以不用费劲去构造一个矩阵了…wsdd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fail[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> M[N][N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b)&#123;</span><br><span class="line">        Matrix ans ; ans.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    (ans.M[i][j] += a.M[i][k] * b.M[k][j] % p) %= p ;</span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (Matrix a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        Matrix res ; res.reset() ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = res * a ;</span><br><span class="line">            a = a * a ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p ; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++ j ; fail[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; m ; j = ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="string">'0'</span> ; c &lt;= <span class="string">'9'</span> ; j = i, ++ c)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; (<span class="keyword">int</span>)s[j + <span class="number">1</span>] != c) j = fail[j] ;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)s[j + <span class="number">1</span>] == c) ++ j ; g.M[i][j] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    g = g ^ n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">        (ans += g.M[<span class="number">0</span>][i]) %= p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SNOI2017-礼物"><a href="#SNOI2017-礼物" class="headerlink" title="[SNOI2017]礼物"></a>[SNOI2017]礼物</h1><blockquote><p> 给定 $k$，设 $f_i$ 的递推式如下：</p><script type="math/tex; mode=display">f_{i}=i^k+\sum_{j=1}^{i-1}f_j</script><p>$k\leq 500,n\leq 10^{18}$</p></blockquote><p>当然这题有什么其余的大力多项式算法，复杂度是什么 $O(k+\log n)$ 的…要知道原原本本这题 $k$ 只有 $10$ 这么大啊/kk</p><p>考虑先设 $s_n=\sum_{i=1}^nf_i$ ，那么发现</p><script type="math/tex; mode=display">\begin{aligned}f_n&=s_{n-1}+n^k\\s_n&=s_{n-1}+f_n\\&=2\cdot s_{n-1}+n^k\end{aligned}</script><p>于是发现可以递推 $s_n$。那么发现这个地方有一个常系数 $n^k$，尝试依靠</p><script type="math/tex; mode=display">(m+1)^k=\sum_{i=1}^k\binom{k}{i}m^i</script><p>这个东西来得到，即</p><script type="math/tex; mode=display">\left[\begin{array}{cccccc}{2} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\{0} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\{0} & {0} & {\binom{k-1}{0}} & {\binom{k-1}{1}} & {\cdots} & {\binom{k-1}{k-1}} \\{0} & {0} & {0} & {\binom{k-2}{0}} & {\cdots} & {\binom{k-2}{k-1}} \\{\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} \\{0} & {0} & {0} & {0} & {0} & {\binom{0}{0}}\end{array}\right]\times\left[\begin{array}{c}{s_n} \\{n^{k}} \\{n^{k-1}} \\{n^{k-2}} \\{\vdots} \\{n^{0}}\end{array}\right]=\left[\begin{array}{c}{s_{n+1}} \\{(n+1)^{k}} \\{(n+1)^{k-2}} \\{\vdots} \\{(n+1)^{0}}\end{array}\right]</script><p>然后就可以愉快地矩乘了。</p><p>不过似乎有个性质值得注意，就是本身这个转移矩阵就是一个上三角的形式，所以可能会存在什么有趣的东西…不得而知不得而知…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAK 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">ll N, K, Ans, T, C[MAK][MAK]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ; x %= Mod ;  </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % Mod ; </span><br><span class="line">x = x * x % Mod, <span class="comment">/* pks */</span> y &gt;&gt;= <span class="number">1</span> ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">Ans = (T + expow(i, K)) % Mod, T = (T + Ans) % Mod ;</span><br><span class="line"><span class="keyword">return</span> Ans ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Ma&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> M[<span class="number">50</span>][<span class="number">50</span>] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; clear() ; <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= K + <span class="number">1</span> ; ++ i) M[i][i] = <span class="number">1</span> ; &#125;</span><br><span class="line">Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; <span class="keyword">int</span> P = K + <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= P ; ++ k)</span><br><span class="line">                    Ans.M[i][j] = (Ans.M[i][j] + <span class="number">1l</span>l * A.M[i][k] * B.M[k][j] % Mod ) % Mod ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">   Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">                    Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % Mod ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;P, Ans ; <span class="keyword">int</span> C[MAK][MAK] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.M[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) C[i][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">C[i][j] = (<span class="number">1l</span>l * C[i - <span class="number">1</span>][j] + <span class="number">1l</span>l * C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) P.M[<span class="number">1</span>][i + <span class="number">1</span>] = C[K][i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = i ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">P.M[i][j] = C[K + <span class="number">2</span> - i][j - i] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = K + <span class="number">2</span> ; i &gt;= <span class="number">1</span> ; -- i) Ans.M[i][<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">Matrix res ; res.reset() ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x ;</span><br><span class="line">x = x * x, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % Mod ;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % Mod, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.clear() ; Init() ; </span><br><span class="line">Matrix A1, A2, N1, N2 ;</span><br><span class="line">N1 = expow(P, N - <span class="number">2</span>), N2 = N1 * P ;  <span class="comment">/*</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= K + 2 ; ++ i, cout &lt;&lt; endl)</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt;= K + 2 ; ++ j)</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; P.M[i][j] &lt;&lt; " " ; */</span></span><br><span class="line"><span class="comment">//Matrix t = Ans * P ; </span></span><br><span class="line">A1 = N1 * Ans, A2 = N2 * Ans ; </span><br><span class="line"><span class="keyword">return</span> (A2.M[<span class="number">1</span>][<span class="number">1</span>] - A1.M[<span class="number">1</span>][<span class="number">1</span>] + Mod) % Mod ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; </span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">1000000</span>) <span class="built_in">cout</span> &lt;&lt; Solve1() ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (Ma :: Solve2()) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唉，比人会的我都不会，没有前途啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是整理“[HNOI2008]GT考试”和“[SNOI2017]礼物”两道题。由于实在找不出什么共同点来，所以就随便找了个理由把两道题放在一起了233&lt;/p&gt;
&lt;p&gt;从各个角度来看，都算是比较妙的设计方式了？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="字符串/KMP" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-KMP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】uoj#221 [NOI2016]循环之美</title>
    <link href="https://www.orchidany.cn/2020/02/18/NOI2016%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/"/>
    <id>https://www.orchidany.cn/2020/02/18/NOI2016循环之美/</id>
    <published>2020-02-18T02:51:45.000Z</published>
    <updated>2020-02-21T01:48:03.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n, m, k$，求有多少数值上互不相等的可以表示成 $\frac{x}{y}$ 的数， 满足 $1 ≤ x ≤ n$，$1 ≤ y ≤ m$，且其在 $k$ 进制下是纯循环小数。 </p><p>特别的，整数是纯循环小数。  $1 ≤ n, m ≤ 10^9,2 ≤ k ≤ 2000$ 。</p></blockquote><a id="more"></a><p>考虑本质上小数是如何产生的，发现就是当 $x/y$ 除到不能除时，$k$ 进制下，$x\times k$ 之后继续除下去。那么假设循环节长度为 $L$ ，那么会有 $x\bmod y=x\cdot k^L\bmod y$ 。也就是解得 $k^L\equiv1(\bmod y)$ 。那么由于逆元唯一，所以存在这样的一个 $L$，也就是存在逆元的充要条件就是 $k \perp y$ 。</p><p>并且由于不算重，还要求 $x\perp y$ 。所以最后本质上是要求：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]</script><p>随便反演一下</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]\\=&\sum_{i=1}^n\sum_{j=1}^m[j\perp k]\sum_{d|i\operatorname{and}d|j} \mu(d)\\=&\sum_{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor\cdot [d\perp k] \cdot \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} [j\perp k]\end{aligned}</script><p>考虑后面那个 $\sum$ 。若令</p><script type="math/tex; mode=display">f_n=\sum_{i=1}^n[i\perp k]</script><p>那么由于 $\gcd$ 的优秀性质 $\gcd(a,b)=\gcd(b,a\bmod b)$ 所以</p><script type="math/tex; mode=display">f_n=\lfloor\frac{n}{k}\rfloor\cdot f_{k}+f_{n\bmod k}</script><p>这个转移本质上是在做一个分块。</p><p>那么考虑前半部分这个 $\sum $ 。发现如果要数论分块的话，需要快速求</p><script type="math/tex; mode=display">s(n,k)=\sum_{i=1}^n\mu(i)\cdot [i\perp k]</script><p>这个东西。根据一个神奇的 $\mu$ 函数的性质 $\mu(ab)=[a\perp b]\mu(a)\mu(b)$，可以得到</p><script type="math/tex; mode=display">\begin{aligned}s(n,k)&=\sum_{i=1}^n\mu(i)\cdot [i\perp k]\\&=\sum_{i=1}^n\mu(i)\sum_{d|i\operatorname{and}d|k} \mu(d)\\&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d\cdot i) \\&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d)\cdot \mu(i)\cdot[i\perp d]\\&=\sum_{d|k} \mu^2(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)\cdot[i\perp d] \\&=\sum_{d|k} \mu^2(d) \cdot s(\lfloor\frac{n}{d}\rfloor,d) \end{aligned}</script><p>那么这东西显然可以用一个类杜教筛状物来做，大致就是当 $k=1$ 时本质上就是在做一个杜教筛，当 $k&gt;1$ 时只需要枚举 $x$ 的全部因子，这样转移最多有 $\sigma_0(k)$ 种，$k$ 也只会有 $\sigma_0(k)$ 个，递归做下去就好了。这样复杂度的上界是 $O(n^{\frac{2}{3}}+\sigma_0^2(k)\sqrt n)$ ，是一个极其松的上界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1001000</span> ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL G[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> mu[M] ;</span><br><span class="line"><span class="keyword">int</span> pr[M] ;</span><br><span class="line"><span class="keyword">int</span> smu[M] ;</span><br><span class="line"><span class="keyword">int</span> chk[M] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="built_in">map</span>&lt;pint, <span class="keyword">int</span>&gt; S ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!y) ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">F</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * ((n / k) * f[k] + f[n % k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; x) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">            mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n || (k == <span class="number">1</span> &amp;&amp; n &lt; M))</span><br><span class="line">        <span class="keyword">return</span> smu[n] ; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    pint t = mkp(n, k) ;</span><br><span class="line">    <span class="keyword">if</span> (S.count(t)) <span class="keyword">return</span> S[t] ;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">        ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = n / (n / l) ;</span><br><span class="line">            ans -= (r - l + <span class="number">1</span>) * s(n / r, k) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i * i &lt;= k ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mu[i]) ans += s(n / i, i) ;</span><br><span class="line">                <span class="keyword">if</span> (i * i != k &amp;&amp; mu[k / i])</span><br><span class="line">                    ans += s(n / (k / i), k / i) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S[t] = ans ; <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, last = <span class="number">0</span>, now ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ; now = s(r, k) ;</span><br><span class="line">        ans += (now - last) * (LL)(n / l) * F(m / l, k) ; last = now ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve(M - <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="keyword">bool</span>)(gcd(i, k) == <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve()) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n, m, k$，求有多少数值上互不相等的可以表示成 $\frac{x}{y}$ 的数， 满足 $1 ≤ x ≤ n$，$1 ≤ y ≤ m$，且其在 $k$ 进制下是纯循环小数。 &lt;/p&gt;
&lt;p&gt;特别的，整数是纯循环小数。  $1 ≤ n, m ≤ 10^9,2 ≤ k ≤ 2000$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/积性函数求和/杜教筛" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C-%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【泛学笔记】组合计数杂项</title>
    <link href="https://www.orchidany.cn/2020/02/17/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.orchidany.cn/2020/02/17/组合计数杂项/</id>
    <published>2020-02-17T09:34:17.000Z</published>
    <updated>2020-02-17T15:08:02.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是听课听来的组合计数相关.jpg</p><a id="more"></a><h2 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h2><p>$a\in \mathbb{R}$</p><script type="math/tex; mode=display">(x+y)^{a}=\sum_{k=0}^{\infty} \frac{a^{\underline k}}{k!} x^{k} y^{a-k}\\\</script><p>泰勒展开证明。</p><h2 id="抽屉原理一个比较有意思的表达"><a href="#抽屉原理一个比较有意思的表达" class="headerlink" title="抽屉原理一个比较有意思的表达"></a>抽屉原理一个比较有意思的表达</h2><p>把 $kx+b$ 个物品放进 $x$ 个盒子里 $(0&lt;b\leq k)$，必有 $1$ 个盒子里面至少有 $k+1$ 个物品。</p><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><script type="math/tex; mode=display">h_n=\binom{2n}{n}-\binom{2n}{n-1}</script><p>方格行走数。</p><p>瞎jb走，从$0,0$到$n,0$，共$2n$次决策，选$n$次向下。</p><p>减去走错了的，考虑我们第一次走到 $y=-1$ 这条直线上，关于这条直线把 $(n,0)$ 对称下来，然后就变成了从 $(0,0)$ 走到 $(n,-2)$ 的问题，即选择 $n-1$ 步向上，$n+1$ 步向下。</p><p>然后，我sd了，原因在于我思考了半天为什么减去的贡献不用 $\times 2$，因为这不对称，结果发现原来走到 $y=1$ 是合法的，艹，脑袋莫得了。</p><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>有符号的第一类斯特林数记作$\rm \mathrm{S}_s$，无符号记作$\rm \mathrm{S}_u$。</p><script type="math/tex; mode=display">\mathrm{S}_s(n,m)=(-1)^{n+m}\mathrm{S}_u(n,m)</script><p>圆排列方案数。</p><p>同时 $\rm \mathrm{S}_s$ 的生成函数是 $x^{\underline{n}}$，即固定 $n$ 不变时，$\rm \mathrm{S}_s$ 的 $m$ 在 $1\to \infty$ 时的生成函数是 $x$ 的 $n$ 次下降幂。</p><p>（$n$ 固定下来之后的某一行）</p><h2 id="第二类斯特林数："><a href="#第二类斯特林数：" class="headerlink" title="第二类斯特林数："></a>第二类斯特林数：</h2><script type="math/tex; mode=display">\begin{array}{l}{\mathrm{S}(n, m)=\mathrm{S}(n-1, m-1)+m * \mathrm{S}(n-1, m)} \\\ {\mathrm{S}(n, m)=\frac{1}{m !} \sum(-1)^{k}\left(\begin{array}{c}{m} \\ {k}\end{array}\right)(m-k)^{n}}\end{array}</script><p>贝尔数为第二类斯特林数之和，即把 $n$ 个数拆成 $k~(k\in \mathbb{N+})$ 集合的方案数之和。</p><p>ps：二斯都是不带标号的，似乎因为定义出来也没啥意义吧。</p><h2 id="拆分数的非OGF做法"><a href="#拆分数的非OGF做法" class="headerlink" title="拆分数的非OGF做法"></a>拆分数的非OGF做法</h2><p>第二类斯特林数实际上是<strong>$\boldsymbol{n}$带标号（n个不同物品），$\boldsymbol{m}$不带标号</strong>。</p><p>当$n,m$都无标号时，这个问题实际上就是<strong>拆分数</strong>问题，即$3=2+1$只代表一种情况，而如果有标号的话应该是三种情况（$C_3^2$）.</p><p>那么对于这个问题，考虑两种$dp$.</p><ul><li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：<script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}+f_{i-j,j}</script>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢到一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</li><li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：<script type="math/tex; mode=display">g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</li></ul><p>嗯，所以有时候状态的转移与设计存在“高阶状态对低阶状态有天然的累加效应”，换个不严谨的措辞就是<code>+</code>运算使得存在状态间的的相互归约。这是设计状态中需要考虑的一个新奇的东西。</p><p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p><h2 id="LOJ-6268-分拆数"><a href="#LOJ-6268-分拆数" class="headerlink" title="LOJ 6268 分拆数"></a>LOJ 6268 分拆数</h2><p>发现是 <code>#6</code> 的升级版。</p><p>考虑根号分治。先用 $f$ 求出来 $j\leq \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字，具体就是第一维把 $\sqrt n$ 当作步长转移即可。</p><p>之后考虑合并这两个转移。发现最后转移完做一个累加，统计出两个多项式来，分别代表凑出体积 $i$ 的方案数。那么两个多项式的合并就是一个卷积的形式，就直接 $\rm NTT$ 做就完了。</p><h2 id="连通图计数"><a href="#连通图计数" class="headerlink" title="连通图计数"></a>连通图计数</h2><p>定义连通图的 $\rm EGF$ 为 $F(x)$，任意图的 $\rm EGF$ 为 $G(x)$ 。</p><p>考虑</p><script type="math/tex; mode=display">G(x)=\sum_{n \geq 0} \frac{2^{n(n-1) / 2}}{n !} x^{n}</script><p>那么考虑一定有 $G(x)=e(F(x))$ ，即 $F(x)=\ln G(x)$ 。</p><p>这是因为任意图本身由任意个连通图构成，即考虑 $G$ 的另一种组成方式，从分成的连通块个数进行讨论。那么由 $n$ 个连通块构成的图，应该至少有 $F^n$ ，并且由于带标号且无序，所以 $F$ 应该用指数生成函数来刻画。</p><p>也就是从连通块的角度来考虑：</p><script type="math/tex; mode=display">G=\sum\frac{F^n}{n!}</script><p>然后就可以肥宅快乐 $\exp$ 了。</p><p>大概类似于变换组合对象构造恒等式这种操作。</p><h2 id="Best-Theorem"><a href="#Best-Theorem" class="headerlink" title="Best Theorem"></a>Best Theorem</h2><p>一个有向图G，欧拉回路的数量是</p><script type="math/tex; mode=display">t_{1}(G) * \prod_{i=1}^{n}(\operatorname{deg}(i)-1) !</script><p>其中 $t_1(G)$ 表示 $G$ 中以 $1$ 为根的生成树的数量。</p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote><p>给定一个 $n$ 个点 $m$ 条边的图，每条边有长度 $d_i$ 和价值 $v_i$。 随机选出一个长度和最小的生成树，求价值和的期望。 </p><p>$n, m ≤ 50$</p></blockquote><p>考虑如果长度都是 $1$（或者所有边长度均相同，本质是一样的），那么可以很方便地从每条边的贡献入手。大致就是考虑删掉一条边，用剩下的求一遍生成树计数，那么就可以算出这条边被选上的概率，这样就可以一条边一条边的计算贡献。复杂度 $mn^3$。</p><p>如果不是，那么考虑按照权值递增的顺序做如下过程：把当前最小的边拿出来，这样会是多个联通块。考虑在最后的生成树中，这样的边的权值一定会体现在其中，所以相当于每个联通块内选出一棵树，由于现在边权相等所以做法可以先用上一段里的方法。之后考虑把这个联通块缩成一个点，继续做下去，直到边满了为止。</p><p>似乎这样做不是很需要注意细节。因为本质上就是在重复一个贪心MST的过程。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>给定一张 $n$ 个点，$m$ 条边的无向图，每条边有红绿蓝三种颜色，要求绿边数量不超过 $g$, 蓝边不超过 $b$ 的生成树数量，答案对 $10^9 + 7$ 取模 </p><p>$n ≤ 40$</p></blockquote><p>考虑给每条绿边一个权值变量 $x$, 每条蓝边一个权值变量 $y$，根据扩展 MT 定理，最终只需要对着 $xy$ 的次数找系数即可。</p><p>而问题在于如何求这样一个行列式。考虑带入 $n^2$ 对点值给 $x$ 和 $y$，最终使用这些点值进行二维插值，恢复出本来的多项式。复杂度似乎是 $O(n^5)+O(n^4\sim n^6)$ 。</p><p><del>二维插值怎么可能会的嘛，所以复杂度不重要，反正我也不会去写。</del></p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><blockquote><p>给定一个带权无向图，定义一棵生成树的权值是边权和的 $k$ 次方，求所有生成树的权值和，答案对 $10^9 + 7$ 取模。 </p><p>$n, k ≤ 50$</p></blockquote><p>一步转化，考虑一堆数的 $k$ 次方等价于从这堆数里选出 $k$ 个可重复的数字的积 (考虑顺序)，再求和。 </p><p>那么可以将每条边的边权重新定义一个多项式 </p><script type="math/tex; mode=display">∑^k_{i=0}\frac{(vx)^i}{i!}</script><p>表示一条边所代表的权值具体被选了若干次的权值。对新的权值使用 <code>Matrix-tree</code>, 得到一个 $nk$ 次的多项式，$x_k$ 的系数乘上 $k!$ 就是答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是听课听来的组合计数相关.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="泛学" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%AD%A6/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="组合计数/斯特林数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part3</title>
    <link href="https://www.orchidany.cn/2020/02/15/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>https://www.orchidany.cn/2020/02/15/《母函数》学习笔记3/</id>
    <published>2020-02-15T12:11:00.000Z</published>
    <updated>2020-02-17T09:33:50.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是整理一下「伯努利数」吧…</p><p>其实还有一块关于切比雪夫不等式的内容，但是我觉得不是很有意思，决定不整理了.jpg</p><a id="more"></a><h1 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>考虑用母函数的方式定义。此处直接定义伯努利数的指数型母函数是：</p><script type="math/tex; mode=display">\mathbf B=\frac{x}{e(x)-1}</script><p>那么考虑如何展开。记伯努利数为 $\{B_n\}$。发现移一下项</p><script type="math/tex; mode=display">x=\left(B_0+B_1x+\frac{B_2}{2!}x^2\cdots\right) * \left(e(x)-1\right)</script><p>如果记右边卷出来的结果是 $\{a_n\}$，那么发现</p><script type="math/tex; mode=display">a_n=\sum_{k=0}^{n-1}\binom{n}{k}B_k</script><p>此处上界为 $n-1$ 的原因是 $\left(e(x)-1\right)_0=0$ ，其余项均为 $1$ 。 </p><p>比较同次项系数可知</p><script type="math/tex; mode=display">B_0=1\\\sum_{k=0}^{n-1}\binom{n}{k}B_k=0\qquad (n=2,3,4\cdots)</script><p>考虑用这个方程去递推每一项。大致思路是左右两边同时加上 $B_n$ 。</p><script type="math/tex; mode=display">\sum_{k=0}^{n}\binom{n}{k}B_k=B_n</script><p>然后就可以发现，比如拿 $n=2$ 举例：</p><script type="math/tex; mode=display">B_0+2B_1+B_2=B_2</script><p>就可以消掉 $B_2$ 求出 $B_1$。以此类推，每次用 $n$ 可以消出 $B_{n-1}$ 。</p><h2 id="一个小性质"><a href="#一个小性质" class="headerlink" title="一个小性质"></a>一个小性质</h2><p>考虑 $B_n$ 的性质，发现推出来的大概长这样：</p><script type="math/tex; mode=display">\begin{aligned}&B_0=1\\&B_1=-\frac{1}{2}\\&B_2=\frac{1}{6}\\&B_3=0\\&B_4=-\frac{1}{30}\\&B_5=0\\&B_6=\frac{1}{42}\\&B_7=0\\&B_8=-\frac{1}{30}\\&B_9=0\\&B_{10}=\frac{5}{66}\\&\cdots\end{aligned}</script><p>发现似乎，除了 $B_1$ 之外，其余 $n$ 为奇数的时候均为 $0$ 。证明考虑：</p><script type="math/tex; mode=display">\frac{x}{e(x)-1}=\sum \frac{B_n}{n!}x^n=1-\frac{x}{2}+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>那么如果令</p><script type="math/tex; mode=display">f(x)=\frac{x}{e(x)-1}+\frac{x}{2}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}f(-x)&=\frac{-x}{e(-x)-1}-\frac{x}{2}\\&=\frac{-x}{\frac{1}{e(x)}-1}-\frac{x}{2}\\&=\frac{-xe(x)}{1-e(x)}-\frac{x}{2}\\&=x-\frac{x}{1-e(x)}-\frac{x}{2}\\&=\frac{x}{e(x)-1}+\frac{x}{2}\\&=f(x)\end{aligned}</script><p>可知 $f(x)$ 是偶函数，那么也就是 </p><script type="math/tex; mode=display">1+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>是偶函数。考虑他是偶函数的条件，当且仅当所有奇次幂系数都为 $0$ 的时候，才会是偶函数。所以可以证明上面的结论。</p><h2 id="伯努利多项式"><a href="#伯努利多项式" class="headerlink" title="伯努利多项式"></a>伯努利多项式</h2><p>考虑观察下列两个EGF的卷积：</p><script type="math/tex; mode=display">\frac{x}{e(x)-1}*e(tx)</script><p>其中 $t$ 是任意常数。考虑记卷积结果为 $\beta(t)$ 。那么显然</p><script type="math/tex; mode=display">\beta_n(t)=\sum_{k=0}^n\binom{n}{k}B_kt^{n-k}</script><p>记这样的多项式为伯努利多项式。这个多项式有个很有用的性质：</p><script type="math/tex; mode=display">\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)\qquad(n=0,1,2,3\cdots)</script><p>考虑直接做差法证明。首先设出两个式子：</p><script type="math/tex; mode=display">\frac{xe(tx)}{e(x)-1}=\sum\frac{\beta_n(t)}{n!}x^n\qquad(1)\\\frac{xe((t+1)x)}{e(x)-1}=\sum\frac{\beta_n(t+1)}{n!}x^n\qquad(2)\\</script><p>$(2)-(1)$ 得到</p><script type="math/tex; mode=display">\frac{xe(tx)[e(x)-1]}{e(x)-1}=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>即</p><script type="math/tex; mode=display">xe(tx)=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>比较系数可知</p><script type="math/tex; mode=display">\frac{\beta_n(t+1)-\beta_n(t)}{n!}=\frac{t^{n-1}}{(n-1)!}</script><p>变一下形就可以得到：</p><script type="math/tex; mode=display">\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)</script><h2 id="用伯努利多项式求自然数的-k-次方和"><a href="#用伯努利多项式求自然数的-k-次方和" class="headerlink" title="用伯努利多项式求自然数的 $k$ 次方和"></a>用伯努利多项式求自然数的 $k$ 次方和</h2><p>考虑决定自然数 $k$ 次方的要素在于下标 $n$ 。于是考虑所有自然数的 $k$ 次方和就是这样：</p><script type="math/tex; mode=display">(k+1)\mathbf S^{(k)}=\sum_{i=1}^{\infty}\left(\beta_{k+1}(i+1)-\beta_{k+1}(i)\right)</script><p>展开之后</p><script type="math/tex; mode=display">\mathbf S_n^{(k)}=\frac{\left(\beta_{k+1}(n+1)-\beta_{k+1}(1)\right)}{k+1}</script><p>也就是</p><script type="math/tex; mode=display">\mathbf S_n^{(k)}=\frac{1}{k+1}\sum_{r=1}^{k+1}\binom{k+1}{r}B_{k+1-r}(n+1)^{r}</script><p>其中 $r=0$ 时减掉了 $\beta_{k+1}(1)$ 这一项。</p><p>发现本质上可以 $k\log k$ 用 $\exp$ 来预处理伯努利数，然后就可以 $O(k)$ 算不限制 $n$ 时的 $k$ 次方和了。</p><p>emmm似乎预处理也不用 $\rm exp$ ，$e(x)-1$ 直接写出来，然后直接多项式求逆就可以了？</p><p>但显然这个方法被线性插值给爆锤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是整理一下「伯努利数」吧…&lt;/p&gt;
&lt;p&gt;其实还有一块关于切比雪夫不等式的内容，但是我觉得不是很有意思，决定不整理了.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="数学/伯努利数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part2</title>
    <link href="https://www.orchidany.cn/2020/02/14/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://www.orchidany.cn/2020/02/14/《母函数》学习笔记2/</id>
    <published>2020-02-14T04:04:10.000Z</published>
    <updated>2020-02-17T09:33:43.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是从「特征多项式」整理到「指数型母函数及其应用」。</p><a id="more"></a><h1 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>考虑对于一个以 $\{c_i\}$ 为递推转移的 $k$ 阶线性循环数列 $\{a_i\}$ 的母函数，根据构造似乎可以被写成这样的形式：</p><script type="math/tex; mode=display">\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k}</script><p>$\{b_i\},m$ 都是根据实际情况会变的参数。</p><p>那么可以发现这样的恒等的关系：</p><script type="math/tex; mode=display">\begin{aligned}\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k}&=a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots\\b_0+b_1x+b_2x^2\cdots b_{m}x^{m}&=(a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots)\times(1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k)\\\end{aligned}</script><p>即</p><script type="math/tex; mode=display">\begin{aligned}&b_0=a_0,\\&b_1=a_1-c_1a_0,\\&b_2=a_2-c_1a_1-c_2a_0\\&\cdots,\\&b_{k-1}=a_{k-1}-\sum_{i=1}^{k-1}c_ia_{k-1-i},\\&\cdots,\\ &b_p=a_p-\sum_{i=1}^{k}c_i=0\quad \mathrm{if}~(p\geq k) \end{aligned}":</script><p>可以发现分子上的多项式至多有 $k-1$ 次.</p><p>像这种根据递推方式快速确定的一个线性循环数列母函数的方法，称为特征法。而多项式</p><script type="math/tex; mode=display">1-c_1x-c_2x^2-\cdots c_kx^k</script><p>则称为 $\{a_i\}$ 的特征多项式。</p><p>e.g.</p><blockquote><p>求</p><script type="math/tex; mode=display">a_n=a_{n-1}+9a_{n-2}-9a_{n-3},a_0=1,a_1=1,a_2=2</script><p>的通项。</p></blockquote><hr><p>首先分解因式</p><script type="math/tex; mode=display">(1-x-9x^2-9x^3)=(1-3x)(1+3x)(1-x)</script><p>并且观察到 $b_0=1,b_1=0,b_2=-8$。</p><p>那么不妨设</p><script type="math/tex; mode=display">\frac{a}{1-3x}+\frac{b}{1+3x}+\frac{c}{1-x}=\frac{1-8x^2}{1-x-9x^2-9x^3}</script><p>解得</p><script type="math/tex; mode=display">a=\frac{1}{12},b=\frac{1}{24},c=\frac{7}{8}</script><p>那么就可以知道 $\frac{1-8x^2}{1-x-9x^2-9x^3}$ 的展开是：</p><script type="math/tex; mode=display">\sum_{n=1}^{\infty}(\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8})x^n</script><p>那么通项就是</p><script type="math/tex; mode=display">a_n=\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8}</script><h2 id="非齐次"><a href="#非齐次" class="headerlink" title="非齐次"></a>非齐次</h2><p>非齐次的话，可以直接把常数构造在系数里，本质上没什么不同的。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>（1）用 $1,2,3$ 三个数来构造一个 $n$ 位数。不允许两个 $1$ 相邻，求方案数。</p></blockquote><p>发现如果第一位放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-1}$ 的方案；如果放 $1$，那么第二维只能放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-2}$ 的方案。所以有 $a_n=2a_{n-1}+2a_{n-2}$ 。</p><blockquote><p>（2）有一行方格，每个格子可以放黑色或者白色，白色不能相邻地放。求方案树。</p></blockquote><p>发现还是讨论第一个位置放的是不是白色。$f_n=f_{n-1}+f_{n-2}$ 。</p><h1 id="高阶差分"><a href="#高阶差分" class="headerlink" title="高阶差分"></a>高阶差分</h1><h2 id="一点定义"><a href="#一点定义" class="headerlink" title="一点定义"></a>一点定义</h2><p>定义 $\{a_i\}$ 的一阶差分 $\Delta^1\{a_i\}$ 是这样的数列 $\{a_1-a_0,a_2-a_1,\cdots,a_n-a_{n-1}\}$ 。</p><p>那么 $k$ 阶差分指的是 $\Delta^k\{a_i\}=\Delta\{\Delta^{k-1}\{a_i\}\}$ 。</p><p>假设一个数列 $\{a_i\}$ 在 $k$ 阶差分时不是全 $0$ 数列，在 $k+1$ 阶差分时是全 $0$ 数列，那么称这个数列为 $k$ 阶等差数列。</p><h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><blockquote><p> 如果记 $\Delta^k\{a_i\}:\{a_0^{(k)},a_1^{(k)},a_2^{(k)},\cdots,a_n^{(k)}\cdots \}$，那么有：</p><script type="math/tex; mode=display">\begin{aligned}a_n^{(k)}&=a_{n+k}-\binom{k}{1}a_{n+k-1}+\binom{k}{2}a_{n+k-2}-\cdots+(-1)^ka^n\\&=\sum_{i=0}^k(-1)^i\binom{k}{i}a_{n+k-i}\end{aligned}</script></blockquote><p>这个显然可以直接归纳。就懒得证了。</p><h2 id="k-阶等差数列-a-n-的前-n-项和。"><a href="#k-阶等差数列-a-n-的前-n-项和。" class="headerlink" title="$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。"></a>$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。</h2><p>考虑对于数列 $\{s_n\}$ ，满足 $s_i=\sum_{j=0}^ia_i$，那么发现可以直接让 $\{a_n\}*(\frac{1}{1-x})$ 得到 $\{s_n\}$</p><script type="math/tex; mode=display">\left(\sum a_nx^n\right)*\left(\sum x^n\right)=\sum_{n=0}^{\infty}\left(\sum_{j=0}^n a_j\right)x=\sum s_nx^n</script><p>所以假设 $\{a_n\}$ 的母函数是 $f(x)$，那么 $\{s_n\}$ 的母函数就是 $\frac{f(x)}{1-x}$。</p><p>那么考虑如何计算 $f(x)$ 。根据性质可知：</p><script type="math/tex; mode=display">a_n^{(k+1)}=a_{n+k+1}-\binom{k+1}{1}a_{n+k}+\binom{k+1}{2}a_{n+k-1}-\cdots+(-1)^{k+1}a^n</script><p>那么由于 $a_{n}^{(k+1)}=0$ ，所以可以得到：</p><script type="math/tex; mode=display">a_{n+k+1}=\binom{k+1}{1}a_{n+k}-\binom{k+1}{2}a_{n+k-1}+\cdots-(-1)^{k+1}a^n</script><p>发现本质上 $\binom{k+1}{x}$ 属于常数项。所以可以知道 $\{a_n\}$ 是一个 $k+1$ 个线性循环数列。所以可以用特征法直接求出。</p><p>但其实这种方法有时候比归纳要麻烦很多。这种方法主要用来解决一些比较妙的问题。</p><h2 id="一点应用"><a href="#一点应用" class="headerlink" title="一点应用"></a>一点应用</h2><p>e.g.</p><blockquote><p> 给定 $n$ ，求坐标系中 $|x|+|y|=m,(m=0,1,2,3\cdots n)$ 的 $(x,y)$ 点对数。</p></blockquote><p>考虑设 $\{a_i\}$ 表示 $i=m$ 时的方案数，$\{s_i\}$ 即为所求。那么可以知道 $a_i$ 的母函数为：</p><script type="math/tex; mode=display">f(x)=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2</script><p>看上去十分 $easy$，因为每个坐标有$+-$ 两种取值，所以加一个系数 $2$ 。</p><p>那么发现可以这么转化：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2\\&=(1+2x(1+x+x^2+\cdots+x^n+\cdots))^2\\&=(1+\frac{2x}{1-x})^2\\&=(\frac{1+x}{1-x})^2\end{aligned}</script><p>所以 $\{s_n\}$ 的母函数 $f_s(x)$ 为</p><script type="math/tex; mode=display">f_s(x)=\frac{f(x)}{1-x}=\frac{(x+1)^2}{(1-x)^3}</script><p>发现 $(1-x)$ 是它的 $3$ 重根，所以有：</p><script type="math/tex; mode=display">f_s(x)=\frac{4}{(1-x)^3}-\frac{4}{(1-x)^2}+\frac{1}{1-x}</script><p>那么可以展开得到：</p><script type="math/tex; mode=display">f_s(x)=\sum_{i=0}^{\infty}\left[4\binom{n+2}{2}-4(n+1)+1\right]x^n</script><p>于是可知 $s_n=2n^2+2n+1$ 。</p><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>首先发现卡特兰数的定义式就是</p><script type="math/tex; mode=display">a_n=\sum_{k=1}^{n}a_{n-k}a_{k}</script><p>那么这东西的母函数大概可以这么求（默认第 $0$ 为位是 $0$ 而不考虑）：</p><script type="math/tex; mode=display">\begin{aligned}f^2(x)&=\left(\sum a_ix^i\right)^2\\&= a_1^2x^2+(a_1a_2+a_2a_1)x^3+(a_1a_3+a_2a_2+a_3a_1)x^4\cdots+\left(\sum_{i=1}^{n}a_{i}a_{n-i}\right) x^n+\cdots\\&=f(x)-a_1x\end{aligned}</script><p>那么解一下方程可以得到俩根：</p><script type="math/tex; mode=display">f_1(x)=\frac{1-\sqrt{1-4x}}{2},f_2(x)=\frac{1+\sqrt{1-4x}}{2}</script><p>验一下发现应该取 $f_1$.</p><p>在不考虑牛顿迭代的情况下，不加证明地给出一个等式：</p><script type="math/tex; mode=display">\sqrt{1+x}=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1} x^{n}</script><p>那么代换一下可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{1-4 x} &=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1}(-4 x)^{n} \\&=1+\sum_{n=1}^{\infty} \frac{(-1)^{2 n-1}}{n 2^{2 n-1}} 4^{n} \binom{2(n-1)}{n-1} x^{n} \\&=1-\sum_{n=1}^{\infty} \frac{2}{n} \binom{2(n-1)}{n-1} x^{n}\end{aligned}</script><p>再带回去得到：</p><script type="math/tex; mode=display">f(x)=\sum_{n=1}^{\infty}\frac{\binom{2(n-1)}{n-1}}{n} x^n</script><p>那么可知卡特兰数第 $n$ 项 $\mathrm{Cat}_n=\frac{\binom{2(n-1)}{n-1}}{n}$。</p><p>当然一般情况下 $\rm Cat$ 的定义有从 $0$ 开始的，只是把这种方式向前平移了一项而已。</p><h1 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h1><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>出于需要，定义另一种生成函数，即指数型母函数 $(\mathbf{EGF})$ 。对于数列 $\{a\}$，他的 $\rm EGF$  是：</p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n</script><p>那么可以得出两个 $\rm EGF$ 卷积的结果是：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n&= \left(\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n\right)\cdot \left(\sum_{n=0}^{\infty}\frac{b_n}{n!}x^n\right)\\&= \sum_{n=0}^{\infty} x^n\sum_{i+j=n}\frac{a_ib_j}{i!j!}\\&= \sum_{n=0}^{\infty} \frac{1}{n!}x^n\sum_{i+j=n}\left(a_ib_j\cdot\frac{n!}{i!j!}\right)\\\end{aligned}</script><p>可以发现有</p><script type="math/tex; mode=display">c_n=\sum_{k=0}^n\binom{n}{k}a_kb_{n-k}</script><p>那么之所称之为指数型母函数，则依赖于下面的性质：</p><p>令</p><script type="math/tex; mode=display">e(x)=1+x+\frac{x^2}{2!}+\cdots +\frac{x^n}{n!}+\cdots</script><p>可以发现有</p><script type="math/tex; mode=display">e(x)e(y)=e(x+y)</script><p>证明大概是可以把 $e(y)$ 改写成</p><script type="math/tex; mode=display">e(y)=\sum \frac{1}{n!}(\frac{y}{x})^nx^n</script><p>然后</p><script type="math/tex; mode=display">\begin{aligned}e(x)e(y)&=\left(\sum \frac{1}{n!}x^n\right)\cdot \left[\sum \frac{1}{n!}(\frac{y}{x})^nx^n\right]\\&=\sum \frac{\sum_{k=0}^n\binom{n}{k}\cdot (\frac{y}{x})^k}{n!}x^n\\&=\sum \frac{(1+\frac{y}{x})^n}{n!}x^n\\&=\sum \frac{\frac{1}{x^n}(x+y)^n}{n!}x^n\\&=\sum \frac{(x+y)^n}{n!}\\&= e(x+y)\end{aligned}</script><p>发现这种性质类似于指数运算的性质，所以称之为指数型母函数。</p><p>同时可知，令 $y=-x$ 则有 $e(x)=\frac{1}{e(-x)}$ 。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><blockquote><p>设 $\{a_n\}$ 给定，且</p><script type="math/tex; mode=display">b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i</script><p>则必有</p><script type="math/tex; mode=display">a_n=\sum_{i=0}^n\binom{n}{i}(-1)^ib_i</script></blockquote><p>考虑让数列 $\{(-1)^na_n\}$ 的母函数卷上 $e(x)$ 得到：</p><script type="math/tex; mode=display">e(x)*\sum\frac{(-1)^na_n}{n!}x^n=\sum\frac{\sum_{k=0}^n\binom{n}{k}(-1)^ka_k}{n!}x^n=\sum\frac{b_n}{n!}x^n</script><p>也就是</p><script type="math/tex; mode=display">\sum\frac{(-1)^na_n}{n!}x^n=\frac{1}{e(x)}*\sum\frac{b_n}{n!}x^n</script><p>因为 $\frac{1}{e(x)}=e(-x)$ ，所以有：</p><script type="math/tex; mode=display">\sum\frac{(-1)^na_n}{n!}x^n=\sum(-1)^n\frac{\sum_{k=0}^n\binom{n}{k}(-1)^kb_k}{n!}x^n</script><p>对比第 $n$ 项即可得到</p><script type="math/tex; mode=display">a_n=\sum_{k=0}^n\binom{n}{k}(-1)^kb_k</script><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><script type="math/tex; mode=display">\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=-\frac{1}{n}</script><p>首先有一个比较 <code>general</code> 的结论：</p><script type="math/tex; mode=display">\sum_{k=0}^n\frac{(-1)^k}{k+1}\binom{n}{k}=\frac{1}{n+1}\qquad(1)</script><p>这是由于</p><script type="math/tex; mode=display">\binom{n+1}{k+1}=\frac{n+1}{k+1}\binom{n}{k}</script><p>那么稍微变一下形态：</p><script type="math/tex; mode=display">\sum_{k=0}^n(-1)^k\frac{n+1}{k+1}\binom{n}{k}=\sum_{k=1}^{n+1}(-1)^k\binom{n+1}{k}=1+(1-1)^n=1</script><p>移个项就完了。</p><p>那么根据这个可以再证明出一个更强一点的结论：</p><script type="math/tex; mode=display">\sum_{k=1}^n\frac{(-1)^{k-1}}{k}\binom{n}{k}=1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\qquad (2)</script><p>考虑直接归纳。不难验证 $n=1$ 成立。那么考虑 $n\to n+1$ 的过程</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\binom{n+1}{k}\\=&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\left(\binom{n}{k}+\binom{n}{k-1}\right)\\=&\sum_{k=1}^{n}\frac{(-1)^{k-1}}{k}\binom{n}{k}+\sum_{k=0}^{n}\frac{(-1)^{k+1}}{k}\binom{n}{k}\\=&\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)+\frac{1}{n+1}\end{aligned}</script><p>其中最后一步用的就是上面的 $(1)$。</p><p>那么回到本题，考虑设 $a_0=0, a_n=-\frac{1}{n}\quad (n=1,2,3\cdots )$ 。同时设 $b_0=0$，</p><script type="math/tex; mode=display">b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i=\sum_{i=0}^n\frac{(-1)^{i+1}}{i}\binom{n}{i}</script><p>那么根据 $(2)$ 和二项式反演可以得到</p><script type="math/tex; mode=display">b_n=\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)\\\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=\sum_{k=1}^n(-1)^kb_k=a_n=-\frac{1}{n}</script><h1 id="指数型母函数的应用"><a href="#指数型母函数的应用" class="headerlink" title="指数型母函数的应用"></a>指数型母函数的应用</h1><h2 id="有限制的可重排列问题"><a href="#有限制的可重排列问题" class="headerlink" title="有限制的可重排列问题"></a>有限制的可重排列问题</h2><blockquote><p>给定 $n$ 个物品，从中取 $r$ 个进行排列，第 $k~(k=1,2,3\cdots m)$ 种物品有 $n_k$ 个，求排列方案数。</p></blockquote><p>首先给出这东西的母函数：</p><script type="math/tex; mode=display">f_e(x)=\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_1}}{n_1!}\right)*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_2}}{n_2!}\right)*\cdots*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_m}}{n_m!}\right)</script><p>考虑这样表示的意义。对于 $f_e(x)$ 的第 $r+1$ 项，有：</p><script type="math/tex; mode=display">[x^r]f_e(x)=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}</script><p>其中 $\{d_m\}$ 可以看做是满足 $d_1+d_2+\cdots+d_m=r$ 的一组枚举量。</p><p>考虑这样做的可行性。首先变一下形</p><script type="math/tex; mode=display">\begin{aligned}&[x^r]f_e(x)\\&=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}\\&=\frac{r!}{\prod d_i!}\cdot\frac{x^r}{r!}\end{aligned}</script><p>发现第 $r+1$ 项的系数 $\frac{r!}{\prod d_i!}$，正好是从 $r$ 个物品中，共 $m$ 中，每种分别有 $d_i$ 个，取满 $r$ 个的方案数。所以正确性显然。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>用 $1,2,3,4$ 四个数字能组成多少五位数？要求 $1$ 只能出现 $2$ 或 $3$ 次，$2$ 出现 $0$ 或 $1$ 次，$3$ 没有限制， $4$ 出现偶数次。</p></blockquote><p>这个问题的母函数显然就是这个：</p><script type="math/tex; mode=display">f_e(x)=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot \left(1+x\right)\cdot e(x)\cdot \left[1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots\right]</script><p>考虑一个性质</p><script type="math/tex; mode=display">1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots=\frac{e(x)+\frac{1}{e(x)}}{2}</script><p>那么原式就变成了</p><script type="math/tex; mode=display">\begin{aligned}f_e(x)&=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\cdot e(x)\cdot \frac{1}{2}\left(e(x)+\frac{1}{e(x)}\right)\\&=\frac{e(2x)}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)+\frac{1}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\end{aligned}</script><p>发现本质上右边不存在 $x^5$ 这一项，所以忽略。</p><p>于是最后通过化简可知答案是 $140$ .</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分大概是从「特征多项式」整理到「指数型母函数及其应用」。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="数学/常系数齐次线性递推" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part1</title>
    <link href="https://www.orchidany.cn/2020/02/13/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/02/13/《母函数》学习笔记/</id>
    <published>2020-02-13T02:23:17.000Z</published>
    <updated>2020-02-21T13:17:52.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是好久之前的学习笔记？</p><p>边复习边发吧。其实MO再不做题的时候，拿来磨磨脑子也挺有意思的。</p><p>这一部分大概是从「基础组合计数」到「一般型母函数」，再到「线性循环数列」。</p><a id="more"></a><h1 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h1><h2 id="一点瞎扯"><a href="#一点瞎扯" class="headerlink" title="一点瞎扯"></a>一点瞎扯</h2><p>考虑二项式定理 $(x+y)^n=\sum\binom{n}{i}x^iy^{n-i}$，由于展开成了二元多项式的形式，所以存在卷积性质。利用此或可证明一些东西。</p><h2 id="一点有趣的证明题"><a href="#一点有趣的证明题" class="headerlink" title="一点有趣的证明题"></a>一点有趣的证明题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote><p>证明：</p><script type="math/tex; mode=display">\sum_{x=1}^n x\cdot\binom{n}{x}=n\cdot 2^{n-1}</script></blockquote><p>考虑一个式子：$\binom{n}{k}=\frac{n}{k}\binom{n-1}{k-1}$。那么对于原式的右边就可以化成</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{x=1}^n x\cdot\binom{n}{x}\\=&\sum_{x=1}^n n\cdot \binom{n-1}{x-1}\\=&n\cdot 2^{n-1}\end{aligned}</script><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>证明</p><script type="math/tex; mode=display">\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}</script></blockquote><p>考虑 $(1+x)^{n+1}$ 的两种展开方式：</p><script type="math/tex; mode=display">\begin{aligned}(1+x)^{n+1}=&\sum \binom{n+1}{i+1}x^{i+1}\\(1+x)^{n+1}=&(1+x)\sum \binom{n}{i}x^{i}\\=&\sum \binom{n}{i}\left(x^{i}+x^{i+1}\right)\\=&\sum \left(\binom{n}{i}+\binom{n}{i+1}\right)x^{i+1}\end{aligned}</script><p>比较两个多项式中 $i+1$ 项的系数，可知证毕。</p><h1 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h1><h2 id="关于-frac-1-1-x"><a href="#关于-frac-1-1-x" class="headerlink" title="关于 $\frac{1}{1-x}$"></a>关于 $\frac{1}{1-x}$</h2><p>设该商为 $\sum c_nx^n$。那么有</p><script type="math/tex; mode=display">1=(1-x)\sum c_ix^i\\1=c_0+\sum(c_i-c_{i-1})x^i\\</script><p>可知 $c_0=1,c_i=c_{i-1}$ 。所以每一项的系数都为 $1$ 。故有形式幂级数基本定理：</p><script type="math/tex; mode=display">1+x+x^2+x^3\cdots=\frac{1}{1-x}</script><h2 id="一系列求母函数例子"><a href="#一系列求母函数例子" class="headerlink" title="一系列求母函数例子"></a>一系列求母函数例子</h2><script type="math/tex; mode=display">\begin{aligned}\{C_n^{n},C_{n+1}^n,C_{n+2}^{n}\cdots\}&\to\sum \binom{n+i}{n}x^i=\frac{1}{(1-x)^{n+1}}\\\{1,5,25,125\cdots\}&\to\sum 5^ix^i=\sum{5x^i}=\frac{1}{(1-5x)}\\\{0,1\times 2,2\times 3,3\times 4\cdots\}&\to\sum (i+1)\cdot i\cdot x^i=\sum x^i\cdot 2\sum_{j=1}^ij=(\sum i\cdot x^i)*(\sum 2x^i)=\frac{2}{1-x}\cdot\frac{x}{(1-x)^2}\\\{0,0,0,-1,1,-1,1\cdots\} & \to \sum_{i=3}^{\infty}(-1)^ix^i=x^3\sum(-x)^i=\frac{x^3}{1+x}\\\end{aligned}</script><h1 id="部分分式"><a href="#部分分式" class="headerlink" title="部分分式"></a>部分分式</h1><p>这一章的作用在于把一个复杂的计数问题转化为许多个简单的 $\rm OGF$ 的形式。</p><h2 id="预备定理"><a href="#预备定理" class="headerlink" title="预备定理"></a>预备定理</h2><blockquote><p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，$a$ 是 $Q(x)$ 的一个 $k$ 重根，那么存在一个数列 $A_{1\sim k}$ 使得</p><script type="math/tex; mode=display">\frac{P(x)}{Q(x)}=\sum_{i=1}^k\frac{A_i}{(x-a)^i}+\frac{P'(x)}{Q'(x)}</script><p>其中 $\frac{P’(x)}{Q’(x)}$ 依旧是真分式。</p></blockquote><p>懒得证了。感性理解。</p><h2 id="部分分式定理"><a href="#部分分式定理" class="headerlink" title="部分分式定理"></a>部分分式定理</h2><blockquote><p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，如果 $a_1,a_2,\cdots a_m$ 分别是多项式 $Q(x)$ 的 $k_1,k_2,\cdots k_m$ 重根。那么存在一张数表 $\mathbf A$ ，使得</p><script type="math/tex; mode=display">\frac{P(x)}{Q(x)}=\sum_{i=1}^m\sum_{j=1}^{k_i}\frac{\mathbf A_{i,j}}{(x-a_i)}</script></blockquote><p>由预备定理可知显然。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h3><blockquote><p> 分解 $\frac{1}{x^3-x^2-x+1}$ 为部分分式。</p></blockquote><p>首先因式分解可以知道 $1$ 是他的二重根，$-1$ 是他的一重根。那么可以根据部分分式定理得到</p><script type="math/tex; mode=display">\frac{1}{x^3-x^2-x+1}=\frac{a}{(x-1)^2}+\frac{b}{x-1}+\frac{c}{x-1}</script><p>两边通分后发现是个恒等式，于是就可以对 $x$ 用特殊值法得到 </p><script type="math/tex; mode=display">a=\frac{1}{2},b=-\frac{1}{4},c=\frac{1}{4}</script><p>然后就没有然后了。</p><h3 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h3><blockquote><p>将分解 $\frac{6x^2+22x+18}{x^3+6x^2+11x+6}$ 为部分分式</p></blockquote><p>继续考虑将分母因式分解。即</p><script type="math/tex; mode=display">x^3+6x^2+11x+6=(x+1)\cdot (x+2)\cdot (x+3)</script><p>那么之后就变成sb题了，分解为 $\frac{1}{x+1}+\frac{2}{x+2}+\frac{3}{x+3}$。</p><h1 id="简单组合问题"><a href="#简单组合问题" class="headerlink" title="简单组合问题"></a>简单组合问题</h1><h2 id="一般组合问题"><a href="#一般组合问题" class="headerlink" title="一般组合问题"></a>一般组合问题</h2><blockquote><p> 设有 $n$ 种不同的物体，分别只能取 $a_1,a_2,a_3\cdots a_n$ 个，如果要取 $r$ 个，有多少种方案。</p></blockquote><p>形式幂级数大概就是</p><script type="math/tex; mode=display">\prod _{i=1}^n(1+x+x^2+\cdots+x^{a_i})</script><p>这样。或者考虑一个更特殊的问题，从 $n$ 个不同物品里可以重复地取出 $r$ 个的方案数：</p><script type="math/tex; mode=display">\prod_{i=1}^n(1+x+x^2+\cdots)=\frac{1}{(1-x)^n}</script><p>由上面的形式幂级数展开可以知道，这个东西的第 $r$ 项是 $\binom{n-1+r}{n-1}=\binom{n+r-1}{r}$，是个常见的结论。</p><h2 id="砝码模型"><a href="#砝码模型" class="headerlink" title="砝码模型"></a>砝码模型</h2><blockquote><p>设有 $n$ 种砝码，质量分别为 $c_1,c_2\cdots c_n$，分别有 $b_1,b_2\cdots b_n$ 枚，求一共可以称出多少种不同质量的物品。</p></blockquote><p>这个东西的形式幂级数大概是</p><script type="math/tex; mode=display">\prod_{i=1}^n (1+x^{c_i}+x^{2\cdot c_i}+x^{3\cdot c_i}+\cdots+x^{b_i\cdot c_i})</script><h2 id="不定方程相关"><a href="#不定方程相关" class="headerlink" title="不定方程相关"></a>不定方程相关</h2><blockquote><p>求</p><script type="math/tex; mode=display">p_1x_1+p_2x_2+\cdots+p_nx_n=r</script><p>的非负整数解个数。</p></blockquote><p>很显然是 </p><script type="math/tex; mode=display">\prod_{i=1}^n (1+x^{p_i}+x^{2\cdot p_i}+\cdots)</script><p>这里继续把 $1$ 当作一个物品，每个变量只能拿 $p_i$ 的倍数个就很好理解了。</p><p>那么这东西的母函数显然是</p><script type="math/tex; mode=display">\frac{1}{(1-x^{p_1})(1-x^{p_2})(1-x^{p_3})\cdots(1-x^{p_n})}</script><h2 id="有关分拆数的拓展"><a href="#有关分拆数的拓展" class="headerlink" title="有关分拆数的拓展"></a>有关分拆数的拓展</h2><p>在正整数 $r$ 的所有分拆中， 不超过 $n$ 的有几种？</p><p>发现本质上是在求这样一个不定方程</p><script type="math/tex; mode=display">1\cdot x_1+2\cdot x_2+3\cdot x_3+\cdots+n\cdot x_n=r</script><p>的非负整数解个数。</p><p>那么显然就是 $\frac{1}{(1-x)(1-x^2)\cdots(1-x)^n}$</p><h2 id="又一个拓展-OI中的应用"><a href="#又一个拓展-OI中的应用" class="headerlink" title="又一个拓展(OI中的应用)"></a>又一个拓展(OI中的应用)</h2><blockquote><p>给定 $n$ 和 $c_i(1\leq c_i\leq \rm m)$，求 $0\leq x_i\leq c_i$ 时，$\sum x_i=s$ 的解的数量。</p><p>对于前 $30\%$ 的数据，有 $n\leq 16,0\leq m,s\leq 10^9$  。</p><p>对于前 $70\%$ 的数据，有 $n\leq 35，0\leq m,s\leq 10^9$ 。</p><p>对于另外 $30\%$ 的数据，有 $1\leq n\leq 5\cdot 10^5,0\leq m,s\leq 100$。</p></blockquote><p>发现大概 $30\%$ 的可以直接大力容斥，最后 $30\%$ 的可以生成函数，中间 $40\%$ 的就需要神秘的 $\rm Meet~in~Middle$ 了。想了想大概就是分成两部分，枚举第二部分的时候顺便乘法原理一下第一部分的结果就完了。</p><h1 id="线性循环数列"><a href="#线性循环数列" class="headerlink" title="线性循环数列"></a>线性循环数列</h1><h2 id="斐波那契数列通项"><a href="#斐波那契数列通项" class="headerlink" title="斐波那契数列通项"></a>斐波那契数列通项</h2><p>考虑斐波那契数列 $\{a_n\}$ 的母函数可以这么得到：</p><script type="math/tex; mode=display">f(x)=a_0+a_1x+\cdots+a_nx^n+\cdots\\-xf(x)=-a_0x-a_1x^2-\cdots-a_nx^{n+1}\cdots\\-x^2f(x)=-a_0x^2-a_1x^3-\cdots-a_nx^{n+2}\cdots\\</script><p>考虑 ① + ② + ③ 得到：</p><script type="math/tex; mode=display">(1-x-x^2)f(x)=a_0+(a_1-a_0)x+(a_2-a_1-a_0)x^2\cdots</script><p>可知</p><script type="math/tex; mode=display">f(x)=\frac{1}{1-x-x^2}</script><p>那么考虑如何展开这个东西。令 $r_1,r_2$ 为方程 $1-x-x^2$ 的两个根。那么有</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{x-r_1}-\frac{1}{x-r_2}\right)</script><p>变一下形：</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{r_2\left(1-\frac{1}{r_2}x\right)}-\frac{1}{r_1\left(1-\frac{1}{r_1}x\right)}\right)</script><p>然后有一步很神仙的转化。由</p><script type="math/tex; mode=display">\frac{1}{1-\frac{1}{r_1}x}=\sum\left(\frac{1}{r_1}\right)^ix^i\\\frac{1}{1-\frac{1}{r_2}x}=\sum\left(\frac{1}{r_2}\right)^ix^i</script><p>得到</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\sum\left[\frac{1}{r_2-r_1}\left(\frac{1}{r_2^{i+1}}-\frac{1}{r_1^{i+1}}\right)\right]x^i</script><p>可知</p><script type="math/tex; mode=display">a_n=\frac{1}{\left(r_1r_2\right)^n}\cdot\frac{r_2^{n+1}-r_1^{n+1}}{r_1-r_2}</script><p>继而可以得到</p><script type="math/tex; mode=display">a_n=\frac{1}{\sqrt 5}\left[\left(\frac{1+\sqrt 5}{2}\right)^{n+1}-\left(\frac{1-\sqrt 5}{2}\right)^{n+1}\right]</script><h2 id="一般线性循环数列"><a href="#一般线性循环数列" class="headerlink" title="一般线性循环数列"></a>一般线性循环数列</h2><p>由上例可知，对于一个给定的 $k$ 阶线性循环数列，求母函数只需要构造出除了前 $k$ 项之外系数都为 $0$ 的幂级数即可。</p><p>比如给定数列 $\{a_n\}$ 满足：</p><script type="math/tex; mode=display">a_0=0,a_1=1,a_2=-1\\a_n=-a_{n-1}+16a_{n-2}-20a_{n-3}\quad(n=3,4,5\cdots)\\</script><p>那么考虑构造如下四个：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=a_0+a_1x+\cdots+a_nx^n+\cdots\\xf(x)&=a_0x+a_1x^2+\cdots + a_nx^{n+1}\cdots\\-16x^2f(x)&=-16a_0x^2-16a_1x^3-\cdots-16a_nx^{n+2}\cdots\\20x^3f(x)&=-20a_0x^3+20a_1x^4+\cdots+20a_nx^{n+3}\cdots\\\end{aligned}</script><p>还是 ① + ② + ③ + ④：</p><script type="math/tex; mode=display">(1+x-16x^2+20x^3)f(x)=x\\f(x)=\frac{x}{1+x-16x^2+20x^3}</script><p>就完了。</p><p>嗯，剩下的内容就留给下一篇了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是好久之前的学习笔记？&lt;/p&gt;
&lt;p&gt;边复习边发吧。其实MO再不做题的时候，拿来磨磨脑子也挺有意思的。&lt;/p&gt;
&lt;p&gt;这一部分大概是从「基础组合计数」到「一般型母函数」，再到「线性循环数列」。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="组合计数/二项式定理" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【练习记录】平日里口胡的题目系列1</title>
    <link href="https://www.orchidany.cn/2020/02/09/%E5%B9%B3%E6%97%A5%E9%87%8C%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%E7%B3%BB%E5%88%971/"/>
    <id>https://www.orchidany.cn/2020/02/09/平日里口胡的题目系列1/</id>
    <published>2020-02-09T14:25:43.000Z</published>
    <updated>2020-02-22T02:39:27.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是有些题实在不想写，就把这些题给嘴了。</p><p>由于同一篇文章太长会造成很差的观感。所以就分成很多 $parts$ 了。</p><p>对于个人认为比较妙的题，会打上 <code>*</code> 的图标。</p><a id="more"></a><h1 id="MdOI2020"><a href="#MdOI2020" class="headerlink" title="MdOI2020"></a>MdOI2020</h1><p>当成月赛打了。T1写了个诡异的算法结果因为特判时没输出换行拿了64，然后就没有打的兴趣了（</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>考虑对于一种拆分是最优的。即 $(a,b,c)=d$，$d$ 为所求，那么发现会有 $d\cdot (\frac{a}{d}+\frac{b}{d}+\frac{c}{d})=n$。发现当 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同时，一定可以转化成其中一个数 $=d$ 的构造方式。</p><p>所以考虑质因数分解之后枚举 $\frac{n}{d}$。发现当 $\frac{n}{d}\leq 5$ 的时候，当前枚举的 $d$ 不可以让 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同。所以判掉这些数据，剩下的取 $\rm max$ 即可。</p><p>发现现在要求的，就是从 $n$ 的所有分解里面，挑出一个最接近 $6$ 且 $\geq 6$ 的构造 $\frac{n}{d}$ 的方案。发现最多需要三个素因子才可以超过 $6\to (2,2,2)$，最少的话一个就足够了。所以考虑 $\log ^3n$ 三重循环枚举所有的质因子即可。</p><p>质因数分解完全可以 $\rm pollard-rho$。最后复杂度 $O(T\max(\log^3 n,n^\frac{1}{4}))$</p><p>(这个题写的长是因为直接把自己写的题解给粘过来了)</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>考虑一个性质，排好序后，最后不变的一定是一个连续区间。所以考虑枚举这个连续区间，尺取或者二分出右端点，检验一下就可以了。复杂度 $O(n)$。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>考虑一个性质。发现其实左上角的数定住之后，之后的数都确定了。所以可以随便用点差分 $trick$ 实现 $n^2$ .</p><h2 id="D"><a href="#D" class="headerlink" title="D*"></a>D*</h2><p>比较有趣的题。根据第二个子任务的提示可以发现，对于每个询问可以把当前点旋到根，然后求的就是一个区间内点的 $lca$ 的深度。发现这个东西有结合律，比较容易用线段树维护。</p><p>然而每次换根复杂度显然不对。考虑进一步分析性质，当询问点 $q$ 不在原树上的 $lca$ 的子树内时，换根不会影响距离，所以直接统计即可；当询问点 $q$ 不在 $lca$ 的子树内时，考虑换根之后的 $lca’$ 一定也是原树里 $p$ 的某个祖先。通过画图可以知道，只需要倍增找出 $p$ 的第一个包含 $[l,r]$ 内点的祖先即可。求交集可以用主席树来维护。复杂度 $(n\log^2n+q\log^2n)$。</p><h2 id="E"><a href="#E" class="headerlink" title="E*"></a>E*</h2><p>发现可以转化成枚举一个点 $x$ ，从 $x$ 的子树内外各选一对点使得 xor 值最大，发现直接拿Trie维护一个回滚莫队状物即可。复杂度 $n\sqrt n\log V$ 。</p><p>似乎可以用什么值域分块的黑科技优化一下。emmm但我还不会。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>是个推式子题，暂时不是很想推。</p><h1 id="EA的练习赛"><a href="#EA的练习赛" class="headerlink" title="EA的练习赛"></a>EA的练习赛</h1><p>发现自己被叫去验题结果啥都不会十分丢人.jpg</p><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><p>发现如果第一个字符和后面的任意一个字符相同，那么就一定不合法；反之一定合法。所以答案是 $26\times 25^{n-1}$ 。</p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B*"></a>B*</h2><p>根据期望的线性性，发现可以将每个点的答案转化一下：$E=\sum_{i=1}^{n-1}P(x\geq i)$ 。</p><p>考虑每个点什么时候被删除。发现只跟离他最近的前后两个比他大的数有关，每当有一个与 $x$ 相邻时 $x$ 就会挂。所以用容斥原理算一下，$P(x\geq i)=1-P(pre\sim x)-P(x\sim~nxt)+P(pre\sim nxt)$ 。发现这东西显然有组合意义，所以算一波组合数即可。复杂度 $O(n^2)$ 。</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>有意思的题。发现切割方式严格要求从左到右，那么对于两根弦，如果以 $u_j\geq u_i,v_j\leq v_i$ 的方式相交，那么就可以把 $j$ 这条弦给删掉。所以删掉之后重新排序，然后按弦 $dp$。$f_i$ 表示处理完前 $i$ 根弦的 $\min$ 。那么转移就枚举一下把哪个 $j\sim i$ 的连续区间给删掉。</p><p>那么转移大概是 $f_i=\min_{0\leq j&lt;i}(f_j+A_{u_{j+1}-1}\times B_{v_i+1})$ 。其中 $A,B$ 分别是 $a_i,b_i$ 的前后缀最小值。</p><p>发现稍微变一下形，就是 $f_j=-A_{u_{j+1}-1}\times B_{v_i+1}+f_i$。发现斜率 $B$ 单调，$x$ 坐标 $A$ 单调递减。所以就是在维护一个下凸壳，直接最裸的斜率优化就好了。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D**"></a>D**</h2><p>很有意思的组合题。发现对于每个点，如果在访问他之前访问了比他深度更小的叶子节点，他就不会被访问。所以考虑对于一个点 $x$ 的每个祖先 $anc_x$ ，设 $anc_x$ 有 $n’$ 个儿子，其中有 $m’$ 个子树内叶节点的最小深度小于 $x$ 的深度，那么这一层不会进入死亡分叉的方案数就是 $\binom{n’}{m’+1}\cdot (n’-m’-1)!\cdot (m’)!$ ，计数思路大概就是选出 $m’+1$ 个位置来，每次选都把这 $m’+1$ 位置中的第一个位置留给当前的 $x$ 所在子树放，剩下就是排列数。</p><p>然后考虑进入 $x$ 的概率就是很神奇的 $\prod \frac{1}{m_{anc_i}’+1}$。考虑这个东西怎么快速算。发现对于同一棵子树，$lca$ 上方的信息都是一样的，改变的只有子树内部的方案。那么考虑对于每个儿子，直接按照「子树内叶子的最小深度」排序，就可以顺序处理出结果。</p><p>类似于用栈来维护 $k$ 级祖先的过程，发现只需要一个可撤销的树状数组即可。复杂度 $n\log n$。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>似乎是一道神秘的插值题。鸽了鸽了。</p><h1 id="LG二月月赛-·-加油武汉"><a href="#LG二月月赛-·-加油武汉" class="headerlink" title="LG二月月赛 · 加油武汉"></a>LG二月月赛 · 加油武汉</h1><p>没参加的一场月赛，似乎被爆破了.jpg</p><h2 id="A-2"><a href="#A-2" class="headerlink" title="A**"></a>A**</h2><p>这题本来想枚举最后选的哪个数来做，但是发现根本不科学，自闭了半天。就是考虑钦定了一个数，如果不是最后一个取他，那么前 $k$ 个一定都放比他小的数，同时可以在他的位置和 $k$ 个之间也放一些比他小的数，但是这些方案对于不同的前 $k$ 个元素的最大值，方案是不同的，所以复杂度很假也很麻烦。</p><p>发现似乎直接枚举前 $k$ 个元素的最大值比较容易做。分成两类来讨论，一类情况是取到了某个 $x$，另一类情况是不得不取最后一个，发现当且仅当集合里的最大值在前 $k$ 个才会发生。</p><p>1、第一种情况。对于每个最大值 $x$，取到他的概率是 $\frac{\binom{x-1}{k-1}}{\binom{n}{k}}$，在取到最大值为 $x$ 的情况下，期望就再乘上一个 $\frac{\mathrm{S-S_{p_x}}}{n-p_x}$。其中 $\rm S$ 表示集合元素的总和，$\rm S_x$ 表前 $x$ 小的元素的和，$p_x$ 表示 $x$ 是第几小的。不难发现这样是对的。</p><p>2、第二种情况。不难发现概率是 $\frac{\binom{n-1}{k-1}}{\binom{n}{k}}=\frac{k}{n}$ 。那么期望的话，发现这种情况下最后一个数是谁情况相同。所以乘上一个 $\frac{\mathrm{S}-x_{\max}}{n-1}$ 就完了。</p><p>嗯。这个故事告诉我们有时候期望题并不可以直接大力去组合所有情况来算，还是需要一定技巧的。</p><p>啊…不会转换组合对象…我太弱了…</p><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><p>由于是完全图，那么每个点贡献的异色三角形个数就是 $(n-1-b)\cdot b$ 。</p><p>所以最后算一下补，答案就是 $\binom{n}{3}-\frac{1}{2}\sum_{i=1}^n(n-1-b_i)\cdot b_i$ 。做完才发现是一道做烂了的题.jpg</p><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>sb费用流。发现最大流的情况下，不会出现一个点覆盖了另一个强连通分量中的某个点。所以可以直接流。用一些贪心的 $trick$ 就可以边数消掉一个 $n$ 了 。</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D*"></a>D*</h2><p>很有意思一道题。首先发现原来 $min_25$ 筛并不可以过得去。之后发现 </p><script type="math/tex; mode=display">\begin{aligned}\sigma_0(n)&=\prod(e_i+1)\\\sigma_0(n^k)&= \prod(k\times e_i+1)\end{aligned}</script><p>于是可以发现，大概对于每个 $n$，他的 $\sigma_0$ 都是一个关于 $k$ 的 $\omega(n)$ 次多项式。于是就可以筛出多项式来，前缀和一下。然后就做完了。复杂度大概 $O(\max(\omega\cdot n, \omega\cdot q))$ 。</p><p>可能筛多项式需要一些诡秘的 $trick$ 吧。不过大概还是通过记录最小质因子来转移。</p><p>由于以前没见过这种题，于是写了个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    poly[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])&#123;</span><br><span class="line">            frm[i] = <span class="number">1</span> ;</span><br><span class="line">            chk[i] = <span class="number">1</span> ;</span><br><span class="line">            mind[i] = i ;</span><br><span class="line">            mindc[i] = <span class="number">1</span> ;</span><br><span class="line">            pr[++ cnt] = i ;</span><br><span class="line">            poly[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            poly[i][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m, j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            m = <span class="number">1l</span>l * pr[j] * i ; </span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) <span class="keyword">break</span> ; chk[m] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                mind[m] = pr[j] ;</span><br><span class="line">                mindc[m] = <span class="number">1</span>, frm[m] = i ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mindc[m] = mindc[i] + <span class="number">1</span> ;</span><br><span class="line">                mind[m] = mind[i] ; frm[m] = frm[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">8</span> ; ++ k)</span><br><span class="line">                poly[m][k] = poly[frm[m]][k] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">8</span> ; k &gt;= <span class="number">1</span> ; -- k)</span><br><span class="line">                (poly[m][k] += <span class="number">1l</span>l * mindc[m] * poly[m][k - <span class="number">1</span>] % P) %= P ;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">            poly[i][j] -= (poly[i][j] += poly[i - <span class="number">1</span>][j]) &gt;= P ? P : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有很长的题面以及红色的难度标签。于是决定跳过。</p><h2 id="F-1"><a href="#F-1" class="headerlink" title="F"></a>F</h2><p>辣鸡二分答案题。难点在于知道要去二分答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是有些题实在不想写，就把这些题给嘴了。&lt;/p&gt;
&lt;p&gt;由于同一篇文章太长会造成很差的观感。所以就分成很多 $parts$ 了。&lt;/p&gt;
&lt;p&gt;对于个人认为比较妙的题，会打上 &lt;code&gt;*&lt;/code&gt; 的图标。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="数学/素数/素数筛法" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%B4%A0%E6%95%B0-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="多项式的应用" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据结构/可持久化/可持久化线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【生活碎片4】生化危机Resident Evil</title>
    <link href="https://www.orchidany.cn/2020/02/08/Life4/"/>
    <id>https://www.orchidany.cn/2020/02/08/Life4/</id>
    <published>2020-02-08T07:59:51.000Z</published>
    <updated>2020-02-13T13:06:21.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里可是《生化危机》系列的死忠！</p><p>其实这里放的是高一下学期某次语文课演讲的演讲稿了啦。</p><a id="more"></a><div class="pdf" target="./Lecture.pdf" height></div><p>才发现原来强制用WPS进行ppt转word，动画效果是莫得的，所以有些图片只能拼一起了，sad。</p><p>如果pdf加载不出来，推荐 <code>firefox</code> 浏览器或者等上那么一二三四…五六十分钟（huaji</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里可是《生化危机》系列的死忠！&lt;/p&gt;
&lt;p&gt;其实这里放的是高一下学期某次语文课演讲的演讲稿了啦。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>「生活碎片」系列目录</title>
    <link href="https://www.orchidany.cn/2020/02/07/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.orchidany.cn/2020/02/07/生活碎片目录/</id>
    <published>2020-02-07T14:06:09.000Z</published>
    <updated>2020-02-08T09:13:09.514Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>出这个系列，原因是想瞎写点东西记录生活。有别于「随想」系列，这些文章的感情不是那么浓厚，大概是记录比较正常的生活点滴。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">「生活碎片0」CSP2019游记</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/">$Link$</a></td></tr><tr><td style="text-align:center">「生活碎片1」一个小开始</td><td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/15/Life1/">$Link$</a></td></tr><tr><td style="text-align:center">「生活碎片2」原来我还什么都不懂</td><td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/23/Life2/">$Link$</a></td></tr><tr><td style="text-align:center">「生活碎片3」Life is strange</td><td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/24/Life3/">$Link$</a></td></tr><tr><td style="text-align:center">「生活碎片4」生化危机Resident Evil</td><td style="text-align:center"><a href="https://www.orchidany.cn/2020/02/08/Life4/#more">$Link$</a></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出这个系列，原因是想瞎写点东西记录生活。有别于「随想」系列，这些文章的感情不是那么浓厚，大概是记录比较正常的生活点滴。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】杜教筛</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    <id>https://www.orchidany.cn/2020/01/24/杜教筛/</id>
    <published>2020-01-23T17:14:27.000Z</published>
    <updated>2020-02-17T14:56:07.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种比较快的筛法？</p><p>用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：</p><script type="math/tex; mode=display">\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>得出来的：</p><script type="math/tex; mode=display">\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。</p><a id="more"></a><p>似乎很简单？因为这种题的难点在于构造，构造完了就可以分块做了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll s = sum(<span class="number">1</span>, n, f * g) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>) </span><br><span class="line">    r = n / (n / l), s -= solve(n / l) * sum(<span class="number">1</span>, l, g) ;</span><br><span class="line"> <span class="keyword">return</span> (s /= g(<span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这么做的复杂度不对。考虑这样一个引理：</p><script type="math/tex; mode=display">\forall x,y,z\in\mathbb{Z},\quad \left\lfloor\frac{\left\lfloor\frac{z}{x}\right\rfloor}{y}\right\rfloor=\left\lfloor\frac{z}{x y}\right\rfloor</script><p>证明大概是把 $z$ 设成带余除法的标准形式，然后搞一下就可以了。此处略去。</p><p>于是发现，其实每次要计算的 $n’$ ，都是某个 $\lfloor \frac{n}{x}\rfloor$ ，因为假设这次是 $\lfloor \frac{n}{x}\rfloor$ ，下次是 $\lfloor \frac{\lfloor \frac{n}{x}\rfloor}{y}\rfloor=\lfloor \frac{n}{x\cdot y}\rfloor$ 。所以 $\sqrt n$ 为上界，可以直接通过 $\lfloor \frac{n}{x}\rfloor $ 记忆化所有的 $x$ 。</p><p>同时，发现对于 $x$ 的调用，都只会是 </p><script type="math/tex; mode=display">1,2,3\dots \sqrt n,\lfloor{\frac{n}{1}}\rfloor,\lfloor{\frac{n}{2}}\rfloor,\lfloor{\frac{n}{3}}\rfloor\dots\lfloor{\frac{n}{\sqrt n}}\rfloor</script><p>这些数，且每次计算 $\mathbf{S}$ 的复杂度都是 $\sqrt n$ 。所以最终复杂度是：</p><script type="math/tex; mode=display">O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{i}+\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\int_{1}^{\sqrt{n}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{\frac{3}{4}}\right)</script><p>其实就是两步近似。</p><p>然而可以做到更优，即发现对于一些很小的 $n’$ ，完全可以直接预处理出来。所以假设对于前 $p(0&lt;p&lt;1)$ 的 $\mathbf S$ 直接预处理，那么复杂度会变成：</p><script type="math/tex; mode=display">O\left(n^{p}+\sum_{i=1}^{n^{1-p}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(n^{p}+\int_{1}^{n^{1-p}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{p}+n^{1-\frac{1}{2} p}\right)</script><p>发现此时取 $p=\frac{2}{3}$ 为最优，所以复杂度 $O(n^{\frac{2}{3}})$。</p><p>草，据说这东西是 xudyh 在考场上构造出来的，这也太神了吧…</p><h1 id="1-例题"><a href="#1-例题" class="headerlink" title="$1$ 例题"></a>$1$ 例题</h1><h2 id="LG4213-【模板】杜教筛（Sum）"><a href="#LG4213-【模板】杜教筛（Sum）" class="headerlink" title="LG4213 【模板】杜教筛（Sum）"></a>LG4213 【模板】杜教筛（Sum）</h2><blockquote><p>求</p><script type="math/tex; mode=display">\begin{aligned}&a n s_{1}=\sum_{i=1}^{n} \varphi(i)\\&a n s_{2}=\sum_{i=1}^{n} \mu(i)\end{aligned}</script><p>$1\leq n\leq 2\times 10^9$</p></blockquote><p>考虑杜教筛。</p><p>考虑如何构造 $\varphi$ 的 $g$ 。发现有 $\sum_{d|n}\varphi(d)=n$，即 $\varphi <em> \mathbf{1}=\bf Id$，那么 $\bf f</em>g$ 就是 $\frac{n\cdot (n+1)}{2}$。</p><p>考虑如何构造 $\mu$ 的 $g$ 。发现有 $\sum_{d|n}\mu(d)=[n=1]$，即 $\mu <em> \bf 1 = ϵ$，那么 $\bf f</em>g$ 就是 $[n=1]$。</p><p>然后就没有然后了。去年 $6$ 月我写的是不带记忆化的，慢的很。今天重写加了记忆化，复杂度看起来还可以？但是不知道为啥被 <code>min_25</code> 吊着锤。(其实也就快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXS 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> T, N, S ; </span><br><span class="line"><span class="keyword">bool</span> chk[MAXN] ; </span><br><span class="line">LL phi[MAXN], Mu[MAXN] ; </span><br><span class="line">LL Smu[MAXS], Sphi[MAXS] ;</span><br><span class="line"><span class="keyword">int</span> pr[MAXN], t, i, j, x ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; MAXN ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!chk[i]) </span><br><span class="line">      pr[++ t] = i, Mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= t &amp;&amp; pr[j] * i &lt; MAXN ; ++ j)&#123;</span><br><span class="line">chk[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123; </span><br><span class="line">        phi[i * pr[j]] = phi[i] * pr[j] ; </span><br><span class="line">        <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">      Mu[i * pr[j]] = - Mu[i],</span><br><span class="line">        phi[i * pr[j]] = phi[i] * phi[pr[j]] ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; MAXN ; ++ i) Mu[i] = Mu[i - <span class="number">1</span>] + Mu[i], phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_Mu</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> Mu[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Smu[p]) <span class="keyword">return</span> Smu[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Smu[N / p]) <span class="keyword">return</span> Smu[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_Mu(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Smu[N / p] = ret) : (Smu[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> phi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Sphi[p]) <span class="keyword">return</span> Sphi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Sphi[N / p]) <span class="keyword">return</span> Sphi[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1l</span>l * (<span class="number">1</span> + p) * p / <span class="number">2L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_phi(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Sphi[N / p] = ret) : (Sphi[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T, init() ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N, S = <span class="built_in">sqrt</span>(N) ;</span><br><span class="line">        <span class="built_in">memset</span>(Smu, <span class="number">0</span>, <span class="keyword">sizeof</span>(Smu)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Sphi, <span class="number">0</span>, <span class="keyword">sizeof</span>(Sphi)) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get_phi(N) &lt;&lt; <span class="string">" "</span> &lt;&lt; get_Mu(N) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="$3$ 高级应用"></a>$3$ 高级应用</h1><p> 高级应用：我不是很会的应用（</p><blockquote><p>求</p><script type="math/tex; mode=display">\left(\sum_{i=1}^{n} \sum_{j=1}^{n} i \cdot j \cdot \operatorname{gcd}(i, j)\right) \bmod p</script><p>$p\in \mathbb{P},1\leq n\leq 10^{10}$ .</p></blockquote><p>首先是朴素反演：</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=1}^{n} i\cdot j\cdot \operatorname{gcd}(i, j)\\=&\sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot\sum_{d|i\operatorname{and}d|j} \varphi(d)\\=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}i\cdot j\\=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \left(\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\right)^2\\\end{aligned}</script><p>然后发现前面都是完全积性，后面那个平方里面还带着求和不是很好搞…</p><p>这个地方有个很牛的引理：</p><script type="math/tex; mode=display">\left(\sum_{i=1}^xi\right)^2=\sum_{i=1}^{x}i^3</script><p>这东西大概是能归纳出来的。似乎还没有什么比较有趣的证明<del>约等于只能选择背过</del></p><p>然后就是</p><script type="math/tex; mode=display">\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}p^3</script><p><del>发现都比较容易算，并且都积性，于是就可以直接杜教筛了。</del></p><p>上句话在扯 $p$。后面那一坨根本没法筛。于是考虑整除分块套一个杜教筛。这样复杂度还是 $n^{\frac{2}{3}}$ ！！这点很重要！！因为本质上我的整除分块还是在枚举某些 $\lfloor\frac{\lfloor\frac{n}{l}\rfloor}{x}\rfloor$。于是该记下来的不多不少，还是记下来了，复杂度不变。</p><p>代码实现有点细节，还需要多学习多积累。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; pq ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXNN], chk[MAXN] ;</span><br><span class="line">LL Inv6, Inv4, cnt, p[MAXNN] ;</span><br><span class="line">LL P ; LL N, Sp[MAXN], phi[MAXNN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL l, LL r)</span></span>&#123;</span><br><span class="line">    l -- ; l %= P, r %= P ;</span><br><span class="line">    LL r1 = r * (r + <span class="number">1</span>) % P * (<span class="number">2</span> * r + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    LL r2 = l * (l + <span class="number">1</span>) % P * (<span class="number">2</span> * l + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    <span class="keyword">return</span> ((r1 - r2) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calcc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans ; x %= P ;</span><br><span class="line">    ans = x * x % P ;</span><br><span class="line">    (ans *= Inv4) %= P ;</span><br><span class="line">    (ans *= (x + <span class="number">1</span>) % P * (x + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; MAXNN)</span><br><span class="line">        <span class="keyword">return</span> phi[x] ;</span><br><span class="line">    LL y = N / x ;</span><br><span class="line">    <span class="keyword">if</span> (chk[y]) <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">    chk[y] = <span class="number">1</span> ; LL &amp;ans = Sp[y] ;</span><br><span class="line">    ans = calcc(x) ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l),</span><br><span class="line">        (ans -= calc(l, r) * solve(x / l) % P) %= P ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += P ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l) ;</span><br><span class="line">        (res += (solve(r) - solve(l - <span class="number">1</span>)) * calcc(x / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; N ; phi[<span class="number">1</span>] = vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    Inv4 = expow(<span class="number">4</span>, P - <span class="number">2</span>), Inv6 = expow(<span class="number">6</span>, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXNN ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] * i &gt;= MAXNN) <span class="keyword">break</span> ;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * p[j]] = phi[i] * p[j] % P ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]] % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXNN ; ++ i) </span><br><span class="line">      (phi[i] = <span class="number">1l</span>l * i * i % P * phi[i] + phi[i - <span class="number">1</span>]) %= P ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; phi[8000000] &lt;&lt; endl ; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, work(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一种比较快的筛法？&lt;/p&gt;
&lt;p&gt;用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\
\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)&lt;/script&gt;&lt;p&gt;得出来的：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)&lt;/script&gt;&lt;p&gt;如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="杜教筛" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
    
      <category term="数学/积性函数求和/杜教筛" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C-%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#2353 [NOI2007]货币兑换</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/"/>
    <id>https://www.orchidany.cn/2020/01/24/货币兑换/</id>
    <published>2020-01-23T16:45:56.000Z</published>
    <updated>2020-02-22T02:39:16.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某CDQ好题.</p><p><del>没人看出上面这句话是有俩含义吗</del></p><a id="more"></a><p>小Y最近在一家金券交易所工作。该金券交易所只发行交易两种金券：$A$ 纪念券（以下简称 $A$ 券）和 $B$ 纪念券（以下简称 $B$ 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。</p><p>每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 $A$ 券和 $B$ 券的价值分别为 $A_K$ 和 $B_K$ （元/单位金券）。</p><p>为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。</p><p>比例交易法分为两个方面：</p><p>a) 卖出金券：顾客提供一个 $[0，100]$ 内的实数 $\rm OP$ 作为卖出比例，其意义为：将 $\rm OP\%$ 的 $A$ 券和 $\rm OP\%$ 的 $B$ 券以当时的价值兑换为人民币；</p><p>b) 买入金券：顾客支付 $\rm IP$ 元人民币，交易所将会兑换给用户总价值为 $\rm IP$ 的金券，并且，满足提供给顾客的 $A$ 券和 $B$ 券的比例在第 $K$ 天恰好为 $\rm Rate_K$ ；</p><p>小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $\rm N$ 天内的 $A$ 券和 $B$ 券的价值以及 $\rm Rate$。他还希望能够计算出来，如果开始时拥有 $\rm S$ 元钱，那么 $\rm N$ 天后最多能够获得多少元钱。</p><p>其中 $\rm N\leq 10^5$.</p><p>首先想到 $dp$ 。这个地方设计的 $dp$ 个人感觉还是比较 $\rm tricky$ 的。发现本质上最大化 $A$ 券或者 $B$ 券的数量和最大化手里拿到的rmb都是某些最优决策，所以不能一起维护。</p><p>发现通过券来维护rmb比较方便，于是考虑设 $f_i$ 表示在第 $i$ 天把rmb都花完能得到多少 $A$ 券。初值显然是</p><script type="math/tex; mode=display">m=f_1\cdot A_1+\frac{f_1\cdot B_1}{\rm Rate_1}\\f_1=\frac{m\cdot\mathrm{Rate_1}}{A_1\cdot \mathrm{Rate_1}+B_1}</script><p>那么考虑如何以此计算rmb。发现第 $i$ 天可能会保有 $1\sim i-1$ 天时的金券。于是令 $g_i$ 表示前 $i$ 天的最大获利，发现可以这么转移：</p><script type="math/tex; mode=display">g_i=\max_{1\leq j<i}(g_{i-1},f_j\cdot (A_i+\frac{B_i}{\rm Rate_j}))</script><p>转移的正确性在于，卖出的 $A$ 券和 $B$ 券的百分比必须一致，所以不会出现分多次卖的情况。于是喜提一个 $n^2$ 算法。</p><p>考虑优化。发现如果对于一个 $i$ 其转移点为 $j$，那么会有：</p><script type="math/tex; mode=display">\begin{aligned}g_i&=f_j\cdot A_i+f_j\cdot \frac{B_i}{\rm Rate_j}\\\frac{f_j}{\mathrm{Rate_j}}&=-\frac{A_i}{B_i}\cdot f_j+\frac{g_i}{B_i}\end{aligned}</script><p>发现可以令 $y_i=\frac{f_i}{\mathrm{Rate_i}},x_i=f_i$ 。那么这就是一个斜率优化的标准形式。</p><p>但问题在于，$f_j$ 很悲惨的由于每天的兑换量有不同，它并不单增，并且斜率也不单增，所以不能用删除末尾几个（即单调队列）来维护凸壳，必须要用某些神秘 $\rm splay$ 技巧来加速这个过程。</p><p>然而还有另一种 $\rm CDQ$ 写法。大概就是考虑为了保证横坐标是单调的，所以要排序，但是排序之后转移就会失秩，而这个过程显然可以 $\rm CDQ$ 来优化，于是就没了。</p><p>值得注意的是，朴素的 $\rm CDQ$ 由于不需要严格按秩，即二进制拆分顺序不限，所以可以瞎分治。但是维护 $dp$ 的时候由于转移顺序必须按秩，所以有严格的分治顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cash</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, k ;</span><br><span class="line">    <span class="keyword">double</span> A, B, R ; <span class="keyword">int</span> ID ;</span><br><span class="line">&#125;T[MAXN], Div[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">double</span> M ; <span class="keyword">double</span> dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">double</span> Ans, t ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Ans = M, dp[<span class="number">1</span>] = M * T[<span class="number">1</span>].R / (T[<span class="number">1</span>].A * T[<span class="number">1</span>].R + T[<span class="number">1</span>].B) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">                Ans = max(Ans, dp[j] * T[i].A + dp[j] / T[j].R * T[i].B) ;</span><br><span class="line">            dp[i] = Ans * T[i].R / (T[i].A * T[i].R + T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, Ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CDQ&#123;</span><br><span class="line">    <span class="keyword">int</span> stk[MAXN] ; <span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e9</span>, eps = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Cash &amp; A, <span class="keyword">const</span> Cash &amp; B)</span></span>&#123; <span class="keyword">return</span> A.k &lt; B.k ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(T[d].x - T[b].x) &lt;= eps) <span class="keyword">return</span> INF ;</span><br><span class="line">        <span class="keyword">return</span> (T[d].y - T[b]. y) / (T[d].x - T[b].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L, r = Mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= Mid &amp;&amp; (r &gt; R || T[l].x &lt; T[r].x))</span><br><span class="line">        Div[i] = T[l ++]; <span class="keyword">else</span> Div[i] = T[r ++] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dp_CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">            dp[L] = max(dp[L], dp[L - <span class="number">1</span>]) ;<span class="comment">//?</span></span><br><span class="line">            T[L].y = dp[L] / (T[L].A * T[L].R + T[L].B), T[L].x = T[L].y * T[L].R ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//y : f[j] / Rate[j], x : f[j]。此处应该以f[j]单增来排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l = L - <span class="number">1</span>, r = Mid ; <span class="keyword">int</span> top = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (T[i].ID &lt;= Mid) Div[++ l] = T[i] ; <span class="keyword">else</span> Div[++ r] = T[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ; dp_CDQ(L, Mid) ; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= Mid ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt; getr(stk[top], i)) -- top ;</span><br><span class="line">            stk[++ top] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = Mid + <span class="number">1</span> ; i &lt;= R ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt;= T[i].k) -- top ;</span><br><span class="line">            dp[T[i].ID] = max(dp[T[i].ID], T[stk[top]].x * T[i].A + T[stk[top]].y * T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        dp_CDQ(Mid + <span class="number">1</span>, R), Merge_sort(L, R, Mid) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = M ;</span><br><span class="line">          sort(T + <span class="number">1</span>, T + N + <span class="number">1</span>, Compare) ;</span><br><span class="line">          dp_CDQ(<span class="number">1</span>, N) ; <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, dp[N]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen("1492.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//     freopen("1492.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;T[i].A, &amp;T[i].B, &amp;T[i].R),</span><br><span class="line">      T[i].k = -T[i].A / T[i].B, T[i].ID = i ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>) DP :: Solve1() ;</span><br><span class="line">      <span class="keyword">else</span> CDQ :: Solve2() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某CDQ好题.&lt;/p&gt;
&lt;p&gt;&lt;del&gt;没人看出上面这句话是有俩含义吗&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】CDQ分治</title>
    <link href="https://www.orchidany.cn/2020/01/24/CDQ%E5%88%86%E6%B2%BB/"/>
    <id>https://www.orchidany.cn/2020/01/24/CDQ分治/</id>
    <published>2020-01-23T16:45:38.000Z</published>
    <updated>2020-02-01T16:14:35.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是对操作分治的算法，算是我最早学过的离线分治算法了？</p><p>大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。</p><p>那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 </p><a id="more"></a><h1 id="loj-112-模板-三维偏序"><a href="#loj-112-模板-三维偏序" class="headerlink" title="loj#112 [模板]三维偏序"></a>loj#112 [模板]三维偏序</h1><blockquote><p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$、$b_i$、$c_i$三个属性。</p><p>设 $f_i$ 表示满足 $a_j\leq a_i$ 且 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的 $j$ 的数量。</p><p>对于 $\forall i \in [0,n)$ ，求 $f_j=i$ 的 $j$ 的数量。</p></blockquote><p>这不是传统意义上的 $\rm CDQ$ 。考虑 $\rm CDQ$ 在维护本质上是在维护一系列权值，通过分治统计前面对后面的贡献，类似于通过分治对全局的询问做时间上的二进制拆分。所以其实具有类似拆分性质的统计都可以这么实现。</p><p>回到这题，发现本质上三维数点也可以直接通过 $\rm CDQ$ 解决。考虑在分治完后，需要统计本层左区间对右区间的贡献。这时直接bit+扫描线即可，即按照一维排序，另一维用bit维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, K, bit[MAXN], res[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span> <span class="keyword">int</span> x, y, z, ans ; &#125;base[MAXN], t[MAXN] ;</span><br><span class="line">il <span class="keyword">bool</span> <span class="keyword">operator</span> == (nodes a, nodes b)&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x == b.x) &amp; (a.y == b.y) &amp; (a.z == b.z) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; p ; p -= low(p)) ret += bit[p] ; </span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r ; </span><br><span class="line">cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R) ;  </span><br><span class="line">sort(base + L, base + Mid + <span class="number">1</span>, comp2), l = L ;</span><br><span class="line">sort(base + Mid + <span class="number">1</span>, base + R + <span class="number">1</span>, comp2), r = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].y &lt;= base[r].y) </span><br><span class="line">upd(base[l].z, <span class="number">1</span>), ++ l ; </span><br><span class="line">base[r].ans += qry(base[r].z), ++ r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt; l ; ++ i) upd(base[i].z, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, o ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base[i].x = qr(), base[i].y = qr(), base[i].z = qr() ; </span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; cdq(<span class="number">1</span>, N) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, j = o = <span class="number">0</span> ; i &lt;= N ; j = o = <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span> (base[i] == base[i - <span class="number">1</span>]) ++ i, ++ j ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) o = max(o, base[k].ans) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) base[k].ans = o ; <span class="keyword">if</span> (!j) ++ i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[base[i].ans] ++ ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Violet-天使玩偶-SYJ摆棋子"><a href="#Violet-天使玩偶-SYJ摆棋子" class="headerlink" title="[Violet] 天使玩偶/SYJ摆棋子"></a>[Violet] 天使玩偶/SYJ摆棋子</h1><blockquote><p>给定一张 $n\times m$ 的网格。</p><p>有两个操作，插入一个新的点或者询问离某个点欧几里得距离最近的点。</p><p>$n,m\leq 3\times10^5$ </p></blockquote><p>发现欧几里得距离即：</p><script type="math/tex; mode=display">|x_i-x_j|+|y_i-y_j|</script><p>通过分类讨论可以得到有这么四类情况：</p><script type="math/tex; mode=display">x_i-x_j+y_i-y_j\\x_i-x_j-y_i+y_j\\-x_i+x_j+y_i-y_j\\-x_i+x_j-y_i+y_j\\</script><p>发现，其中第二种情况就是第一种按照 $x$ 轴对称了一下的结果，后两种类似。于是可以通过坐标变换都转化到第一种问题。</p><p>对于第一个问题，发现询问可以分段处理，于是想到 $\rm CDQ$ 。考虑如何处理离自己最近的点：</p><script type="math/tex; mode=display">x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)</script><p>这样转化出来的两部分即具有差分性质（即可以拆），并且保证了只与时间轴有关（不再和网格图有关）。所以可以把 $x_i+y_i$ 插入进去，这样就可以用四遍 $\rm CDQ$ 做完这题了。</p><p>感觉还是很神仙的吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 192608170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, bit[MAXM], ans[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrys</span>&#123;</span> <span class="keyword">int</span> mk, id, x, y ; &#125;t[MAXN], q[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch_top 24000001</span></span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">7</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K &amp;&amp; bit[p] ; p += low(p)) bit[p] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] = max(bit[p], v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; p ; p -= low(p)) ret = max(ret, bit[p]) ; </span><br><span class="line"><span class="keyword">return</span> ret ? ret : -Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> ; </span><br><span class="line">rg <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r, o = L ; </span><br><span class="line">cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R), l = L, r = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].x &lt;= base[r].x)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[l].mk &lt; <span class="number">2</span>) </span><br><span class="line">upd(base[l].y, base[l].x + base[l].y) ; </span><br><span class="line">t[o ++] = base[l ++] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (base[r].mk &gt; <span class="number">1</span>) </span><br><span class="line">ans[base[r].id] = min(ans[base[r].id], </span><br><span class="line">  base[r].x + base[r].y - qry(base[r].y)) ; </span><br><span class="line">t[o ++] = base[r ++] ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt; l ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (base[i].mk &lt; <span class="number">2</span>) del(base[i].y) ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid) t[o ++] = base[l ++] ; </span><br><span class="line">  <span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) base[i] = t[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ox, <span class="keyword">const</span> <span class="keyword">int</span> &amp;oy)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">base[i] = q[i] ; </span><br><span class="line">base[i].x = ox ? q[i].x : K - q[i].x, </span><br><span class="line">base[i].y = oy ? q[i].y : K - q[i].y ;</span><br><span class="line">&#125;</span><br><span class="line">cdq(<span class="number">1</span>, N + M) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data1.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//freopen("data1.out", "w", stdout) ;</span></span><br><span class="line">fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">N = read(), M = read() ; <span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">q[i].mk = <span class="number">1</span>, q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) </span><br><span class="line">q[i].mk = read(), q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">solve(<span class="number">1</span>, <span class="number">0</span>), solve(<span class="number">0</span>, <span class="number">1</span>), solve(<span class="number">1</span>, <span class="number">1</span>), solve(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="keyword">if</span> (q[i].mk &gt; <span class="number">1</span>) write(ans[i]) ;</span><br><span class="line">fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不知道啥时候才能真正地灵活运用…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是对操作分治的算法，算是我最早学过的离线分治算法了？&lt;/p&gt;
&lt;p&gt;大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。&lt;/p&gt;
&lt;p&gt;那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 &lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CDQ分治" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CDQ%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="离线算法/CDQ分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【生活碎片3】· Life is strange</title>
    <link href="https://www.orchidany.cn/2020/01/24/Life3/"/>
    <id>https://www.orchidany.cn/2020/01/24/Life3/</id>
    <published>2020-01-23T16:42:37.000Z</published>
    <updated>2020-02-08T02:55:16.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Life is strange, no matter who u are.</p></blockquote><a id="more"></a><p>初逢「奇异人生」这款游戏，还是从C菌那里了解的。但是这次不同以往，发现这东西在Mac上完全带的起来，于是就决定自己在steam上买来玩儿。虽然没有汉化，但是基本上还是很流畅的（除了有时候由于不知道在说哪国英语而疯狂卡关）。最后从C菌那里也成功地看到了第二个结局。</p><p>至于「奇异人生二」，则完全是在看C菌的实况。从19年 $4$ 月的第三章等到 $8$ 月，接着等到 $12$ 月，这部被先入为主的粉丝批评「没有第一部好」的杰作，终于迎来了它的 $\rm Ending$。结局共 $4$ 个，都体现了很高的「讲故事」水平，个人来讲这可能是我能想到最好的结局。</p><p>会有三吗？可能会有吧。对我来说，这是个有温度的公司，制作的有温度的游戏。每一帧画面、每一首 $\rm bgm$ 都是在不紧不慢地叙事，交织成一条缓缓流淌的河，流过主人公的奇异人生，流向远方。</p><p>那其中或许昭示着，每一种不同的生命状态都有其存在的意义和价值。换句话说，不论你活成什么样，都值得继续活下去。因为人生的意义，就在于活着。</p><!--more--><h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>其实 「奇异人生1」的剧情已经在 「随想9」里面说了很多啦。大概就是讲的两个妹子之间无可撼动的友谊遇上了滥用会导致天灾的超能力，最后（我选择）把 $\rm Acadia~ Bay$ 整个牺牲了换妹子的故事。</p><p>其实 $1$ 里面的剧情也好、世界也好，都仅仅是局限在 $\rm Acadia~ Bay$ 的一角而已，比起「二」中的「竖跨美国」来讲十分的狭窄。所以如果说「二」的主题是「成长」与「勇气」，那么「一」的主题可能会是「成长」与 「赋予意义」。</p><p>$\rm Max$ 生活的城市其实并不很好，学校里的环境也不完美。然而从 $\rm Max$ 掌握了超能力开始，她似乎可以拯救周围的一切了——救下要自杀的同学、解决了人际关系的漏洞、数次救回了在死亡边缘疯狂试探的 $\rm Cloye$ 。但是无论怎么改，到最后都无法创造一个完美的结局——可以说，到最后，让 $\rm Cloye$ 活着才是她最希望且唯一希望的事。</p><p>但其实，似乎制作者钦定的结局是牺牲 $\rm Cloye$ 而不是 $\rm Acadia~Bay$。这或许就更好地揭示了「赋予意义」这层含义：生活其实本身就是那样地充满 “$\rm Obstacles$” ，也没有什么可以拯救一切的超能力（因为 $\rm Max$ 的超能力滥用会导致日食、双月、飓风等非自然现象），所以大家都只是平凡活着的平凡人，做着自己喜欢的平凡的事，人生是否「奇异」不在于自己获得了什么天助的能力，在于给自己的平凡生活赋予了什么不凡的意义。「碌碌无为」的牢笼需要自己走出，拥有再强的超能力也只是加速了自己原地打转的速度而已。所以，可能学会「赋予意义」才是让每天都可以「翩翩起舞」的最佳方案。</p><p>所以最后 $\rm Cloye$ 被剧情杀了。可能这也是在告诉 $\rm Max$ 和我们，一切美好的东西都会逝去，如何对接下来的生活更好地赋予意义，才是真正需要思考的问题。</p><p>「一」中最受好评的，可能是其最后两章的叙事手法，简直是神来之笔。一遍遍回溯、一遍遍寻找，交叠的空间与时间，$\rm Max$ 拯救 $\rm Cloye$ 的过程，让人十分动容。</p><h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>「奇异人生二」跟「一」不同。主角兄弟俩一开始过着平稳安逸的生活，被突如其来的冲突打乱、被视为通缉犯，决定南下去墨西哥开启新生活，并在途中经历了一系列波折。这其中没有「一」中奇诡的剧情，但是横跨了比「一」更大的时空。</p><p>其实呢，「二」遭人诟病，是因为剧情比起「一」来水了很多。「二」中的作画和配乐依旧优秀、细节处理依然到位，但是剧情很薄。比起「一」中 $\rm Max$ 和 $\rm Cloye$ 无比真挚的友谊，「二」中没有激烈的情感喷薄，只是在淡淡地叙事罢了。</p><p>但是，「二」的剧情似乎被最后的结局给救了回来。最后一共有四个结局：</p><ul><li>1：弟弟用超能力炸毁了边境大门，和哥哥一起去了墨西哥。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「冲」才可以达成。最后他们在墨西哥开了间修车厂，过上了黑帮的生活。个人感觉不是一个很好的结局，因为本身他俩都是受害者，经历劫难之后似乎根本没有走出阴影，也就是「成长」的味道比较浅。</li><li>2：哥哥选择投降，但是弟弟不投降，执意冲过边境线但导致哥哥被流弹击杀。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「不冲」才可以达成。最后弟弟一个人在墨西哥开启了新的「秧歌star」生活…我觉得应该是最烂的结局了233</li><li>3：哥哥选择投降，弟弟也选择投降。这需要选择「不冲」并且弟弟被玩家教育的很懂事才可以。最后当然是哥哥被关了 $20+$ 年，弟弟由于是未成年人并且自首啥事没有，出来已经是中年人了。也不是很好吧233</li><li>4：哥哥选择冲，弟弟选择帮他炸开边境但是自己留了下来、接受制裁。这是我认为最好的结局。哥哥路上经历的一切有了报偿，弟弟也不再一味索求，选择主动奉献。最后的结局很美。哥哥在墨西哥给弟弟写信，弟弟在美国的外公外婆家里读信。两人都成长了、收获了自己应有的生活。</li></ul><p>「二」中的剧情，是慢慢地讲述着的。无论是他们重逢了他们的母亲，还是路上遇到一切的艰难险阻，都如同一条均匀地洒满金箔的河流，慢慢地流淌，慢慢地把闪光点展露出来。</p><p>这是 $\rm B$ 站里面四个结局的 $\rm Link$：<a href="https://www.bilibili.com/video/av78032043?from=search&amp;seid=1274319984559483706" target="_blank" rel="noopener">戳我</a></p><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>「二」中也或多或少直径了第一部，于是会根据玩家第一部选择的是牺牲 $\rm Cloye$ 还是 $\rm Acadia~Bay$ 流了不同的彩蛋。</p><p>最后留个 $\rm Link$ 吧：<a href="https://www.bilibili.com/video/av78454677?from=search&amp;seid=2854200599543211488" target="_blank" rel="noopener">戳我</a> </p><p>你问我为什么不像以前一样写很长的篇末总结？</p><p>对于这种十分美好的东西，「让它淡淡的来，让他好好的去」才是最恰当的方案吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Life is strange, no matter who u are.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【探究】用LCT维护MST</title>
    <link href="https://www.orchidany.cn/2020/01/24/LCT3/"/>
    <id>https://www.orchidany.cn/2020/01/24/LCT3/</id>
    <published>2020-01-23T16:42:27.000Z</published>
    <updated>2020-01-31T13:06:22.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。</p><p>说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。</p><p>似乎很简单？就是很简单。</p><a id="more"></a><h1 id="LG3366-【模板】最小生成树"><a href="#LG3366-【模板】最小生成树" class="headerlink" title="LG3366 【模板】最小生成树"></a>LG3366 【模板】最小生成树</h1><p>就是贴个代码?</p><p>值得注意的是，需要把每一条边加入点，删除的话就只需要把与这条边相连的点之间的边断掉。</p><p>似乎没啥难的？LCT虽然说很长，但是似乎写起来很轻松诶。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(k) e[k].vl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vl ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> val[M] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span>, swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), access(v), splay(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), fa(u) = v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    split(u, v) ;</span><br><span class="line">    fa(u) = lc(v) = <span class="number">0</span> ;</span><br><span class="line">    update(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//access(to(x)) ; </span></span><br><span class="line">splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)),</span><br><span class="line">        qr(to(i)), qr(vl(i)) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; vl(i) &lt;&lt; endl ;</span></span><br><span class="line">        fr(i) += m, to(i) += m ;</span><br><span class="line">        make_root(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(fr(i)) != to(i))</span><br><span class="line">            ans += vl(i), link(fr(i), i), link(to(i), i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[fr(i)]))&#123;</span><br><span class="line">ans += vl(i) - vl(val[fr(i)]) ;</span><br><span class="line">        cut(val[fr(i)]), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WC2006-水管局长"><a href="#WC2006-水管局长" class="headerlink" title="[WC2006]水管局长"></a>[WC2006]水管局长</h1><blockquote><p>要求动态维护一张图。</p><p>只有删边操作、动态询问 $x$ 到 $y$ 间所有路径上最大边权的最小值。</p></blockquote><p>那显然是在最小生成树上跑。</p><p>既有加边也有删边的MST是没法做的。因为删边的时候可能有一堆候选集合，这是无法简单维护的。但是只有加边或者只有删边的MST很简单。由于只有删边，所以倒着做一遍就完了。</p><p>hiahiahia，快来欣赏一下我特别棒的码风：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> o, u, v ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; to(i))</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        Id[mk_p(fr(i), to(i))] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span> ; i &lt;= m + q ; ++ i)&#123;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) &lt;= <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">            swap(u, v),</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        o = Id[mk_p(u, v)] ;</span><br><span class="line">        vis[o] = <span class="number">1</span>, mem[i] = o ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        u = fr(i) ;</span><br><span class="line">        v = to(i) ;</span><br><span class="line">        make_root(v) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">            link(u, i) ;</span><br><span class="line">            link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[u]))&#123;</span><br><span class="line">            dcut(val[u]) ;</span><br><span class="line">            link(u, i) ; link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + q ; i &gt; m ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">int</span> j = mem[i] ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) == <span class="number">1</span>)&#123;</span><br><span class="line">            merge(u, v) ;</span><br><span class="line">            ans[i - m] = vl(val[v]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            u = fr(j) ;</span><br><span class="line">            v = to(j) ;</span><br><span class="line">            make_root(v) ;</span><br><span class="line">            ans[i - m] = <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">                link(u, j) ;</span><br><span class="line">                link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vl(j) &lt; vl(val[fr(j)]))&#123;</span><br><span class="line">                dcut(val[u]) ;</span><br><span class="line">                link(u, j) ; link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOI2014-魔法森林"><a href="#NOI2014-魔法森林" class="headerlink" title="[NOI2014]魔法森林"></a>[NOI2014]魔法森林</h1><blockquote><p>给出一个 $n$ 个点，$m$ 条边的无向图，每条边都有权值 $a_i,b_i$ 。</p><p>求一条从点 $1$ 到点 $n$ 的路径，使得这条路径上边的 $a_i,b_i$ 最大值之和最小。</p><p>$2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5$。</p></blockquote><p>发现可以先把边权按照第一维排个序，然后做普通的lct维护MST就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        merge(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            merge(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我在水博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。&lt;/p&gt;
&lt;p&gt;说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。&lt;/p&gt;
&lt;p&gt;似乎很简单？就是很简单。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="数据结构/LCT" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LCT/"/>
    
  </entry>
  
</feed>
