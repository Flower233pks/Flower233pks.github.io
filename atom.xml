<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-oLChszXO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oLChszXO"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-03-25T09:44:22.420Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？<del>虽然可能并没有人来逛QAQ</del></p><p>如果可以的话，谢谢你喜欢我！</p><p>2020.3.25 upd: 最近因为有新的东西想置顶，于是就把留言板换下来了，但是还是欢迎大家来留言：<a href="https://www.orchidany.cn/2019/08/09/留言板/#more">戳我</a> ！</p><a id="more"></a><h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p><p>CSP-2019考的太菜，导致现在十分被动。</p><p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p><p>其实挺热爱算法的吧？</p><p>CF平时真的不是很常打，所以并不想给CF的ID。sorry啦。</p><p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p><p>QQ:2836531293</p><h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p><p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p><p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p><p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p><p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p><p>3.22upd: 最近又把曾经连续记了好长一段时间、原来是置顶的「闲扯」给归档了：<a href="[https://www.orchidany.cn/2019/12/15/%E9%97%B2%E6%89%AF/](https://www.orchidany.cn/2019/12/15/闲扯/">戳</a>)</p><h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p><p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p><h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p><p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p><h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p><p>我一个人很无聊的说QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一个本blog的观光指南？&lt;del&gt;虽然可能并没有人来逛QAQ&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;如果可以的话，谢谢你喜欢我！&lt;/p&gt;
&lt;p&gt;2020.3.25 upd: 最近因为有新的东西想置顶，于是就把留言板换下来了，但是还是欢迎大家来留言：&lt;a href=&quot;https://www.orchidany.cn/2019/08/09/留言板/#more&quot;&gt;戳我&lt;/a&gt; ！&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[Ynoi2019]Yuno loves sqrt technology II</title>
    <link href="https://www.orchidany.cn/2020/04/12/Ynoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-II/"/>
    <id>https://www.orchidany.cn/2020/04/12/Ynoi2019模拟赛-Yuno-loves-sqrt-technology-II/</id>
    <published>2020-04-12T13:46:29.000Z</published>
    <updated>2020-04-12T14:40:47.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。</p><p>$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ ’</p></blockquote><p>这还是我第一次认真做了 lxl 的由乃 OI 题目，233.</p><a id="more"></a><p>还是考虑二次离线，那么需要预处理</p><script type="math/tex; mode=display">\sum_{i=1}^k (i,i)(1,i-1)\quad | \quad \sum_{i=1}^k (i,i)(1,i)</script><p>和</p><script type="math/tex; mode=display">\sum_{i=k+1}^n (i,i)(i+1,n)\quad | \quad \sum_{i=k+1}^n (i,i)(i,n)</script><p>这 $4$ 个信息，因为在计算逆序对的时候是有方向性的，$l$ 向左扩展/向右收缩对应的是 $(l+1,n)$ 之间的信息，$r$ 向右扩展/左收缩对应的是 $(1,r-1)$ 之间的信息。同时注意到由于 $(i,i)(1,i)=(i,i)(1,i-1)$ ，所以本质上是两个信息。这个可以 $O(n\log n)$ 预处理。</p><p>同理，对于不能预处理的区间，也是要分左边的贡献和右边的贡献来做。根据方向，可以方便地判断每种情况贡献应该怎么加，拿两种值域分块，分别维护前缀和&amp;后缀和就好了。</p><p>实现细节方面需要注意：</p><p>1、本题数据中存在 $a_i$ 相同的情况，这个地方会卡求逆序对时的边界，注意判一下即可。</p><p>2、值域分块需要注意，只需要修改整块的 <code>sum</code>，零散的点单独算贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ;</span><br><span class="line"><span class="keyword">int</span> V ;</span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll s1[N] ;</span><br><span class="line">ll s2[N] ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> sumb[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qrd</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qrd(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qrd;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ql[N], qr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= p &amp; -p) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= V ; p += p &amp; -p) _bit[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inssuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = blv[x] + <span class="number">1</span> ; i &lt;= blv[V] ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &lt;= V ; ++ i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Asksuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inspre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blv[x] - <span class="number">1</span> ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &gt;= <span class="number">1</span> ; -- i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Askpre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">qrd(n), qrd(m), B = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qrd(base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    L = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i] = lwb(tmp + <span class="number">1</span>, tmp + L + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">        V = max(base[i], V) ; bl[i] = i / B ;</span><br><span class="line">    &#125;</span><br><span class="line">    B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] + ask(base[i] - <span class="number">1</span>), add(base[i]) ;</span><br><span class="line">    fill(_bit, _bit + V + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + i - <span class="number">1</span> - ask(base[i]), add(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">qrd(q[i].l), qrd(q[i].r), q[i].id = i ;</span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l] + s1[r] ;<span class="comment">//l 的贡献变成了一个后缀，原来是 l'-(l-1),现在变成了 l-l'</span></span><br><span class="line">ans[i] += s2[newl] + s1[newr] ;<span class="comment">//l 和 r 要分开计算贡献</span></span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(newl, l - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(l, newl - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Inspre(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : ql[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Askpre(base[o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">memset</span>(sumb, <span class="number">0</span>, <span class="keyword">sizeof</span>(sumb)) ;</span><br><span class="line">    <span class="built_in">memset</span>(sump, <span class="number">0</span>, <span class="keyword">sizeof</span>(sump)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        Inssuf(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qr[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Asksuf(base[o] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line">qwa(res, n, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。&lt;/p&gt;
&lt;p&gt;$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ ’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这还是我第一次认真做了 lxl 的由乃 OI 题目，233.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】莫队二次离线</title>
    <link href="https://www.orchidany.cn/2020/04/11/%E8%8E%AB%E9%9A%8A%E4%BA%8C%E6%AC%A1%E9%9B%A2%E7%B7%9A/"/>
    <id>https://www.orchidany.cn/2020/04/11/莫隊二次離線/</id>
    <published>2020-04-11T03:47:01.000Z</published>
    <updated>2020-04-12T14:40:33.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。</p><p>另附 pks 词典：</p><blockquote><p>『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。</p><p>『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。</p><p>『 』(无评价) ：学会了。</p></blockquote><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。然后由于信息具有可减性(比如常见的「点对数」)，那么可以：</p><p>记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。 </p><p>1、如果 $[l,r]\to [l+t,r]$ ，那么可知 </p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l}^{l+t-1} (i,i)(i+1,r)=\sum_{i=l}^{l+t-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l,l+t-1)(1,r)-\sum_{i=l}^{l+t-1}(i,i)(1,i)</script><p>2、如果 $[l,r]\to [l-t,r]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l-t}^{l-1} (i,i)(i+1,r)=\sum_{i=l-t}^{l-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l-t,l-1)(1,r)-\sum_{i=l-t}^{l-1}(i,i)(1,i)</script><p>3、如果 $[l,r]\to [l,r+t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r+1}^{r+t}(i,i)(l,i-1)=\sum_{i=r+1}^{r+t}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r+1,r+t)+\sum_{i=r+1}^{r+t}(i,i)(1,i-1)</script><p>4、如果 $[l,r]\to [l,r-t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r-t+1}^{r}(i,i)(l,i-1)=\sum_{i=r-t+1}^{r}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r-t+1,r)+\sum_{i=r-t+1}^{r}(i,i)(1,i-1)</script><p>其中 $\sum$ 并不是真正的 $\sum$ ，不同情况下需要按顺序(即不再有交换律)，比如 $[l,r]\to [l,r-t]$ 时就需要从 $r-1$ 算到 $r-t$ 。</p><p>然后这样容斥之后，后面的 $\sum$ 就可以预处理了，前面的 $()()$ ，由于莫队的复杂度，可以知道至多有 $n\sqrt m$ 个不同的询问，这样就可以把每一组询问打标记，打到左端点是 $1$ 的那个询问上 (比如 $[l,r]\to [l,r-t]$ 就打到 $l-1$ 上)。最后扫一遍全部的 $i\in[1,n]\cap\mathbb{Z_+}$，这样最终复杂度 $O(n\sqrt m)$ 。可以看出比起普通的莫队，二次离线还有一个好处，就是只有 $O(n)$ 次插入，于是对于某些题就可以用值域分块的技巧做到 $O(n\sqrt m+n\sqrt n)$ 。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>LG 4887 第十四分块(前体)</p><p>珂朵莉给了你一个序列 $a$，每次查询给一个区间 $[l,r]$ </p><p>查询 $l \leq i&lt; j \leq r$ ,且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。</p></blockquote><p>似乎就是板子题，然后对于 $(i,i)(1,i-1)$ 和 $(i,i)(1,i)$ 这个东西的预处理可以拿一个桶来维护，$buc_x$ 表示有多少个数 $\oplus x$ 之后二进制位有 $k$ 个 $1$ ，剩下的就是比较典型的莫队二次离线了。</p><p>值得一提的是…$\binom{14}{7}=3432$ ，再乘上一个 $10^5$ ，时间根本承受不了…所以这就很神必…打算写完之后出个数据卡一卡，不知道能不能成功。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16385</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> cnt ;  </span><br><span class="line">ll s1[N] ; </span><br><span class="line">ll s2[N] ; </span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ; </span><br><span class="line"><span class="keyword">int</span> bu[N] ;</span><br><span class="line"><span class="keyword">int</span> len[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ; </span><br><span class="line"><span class="keyword">if</span> (!k) bu[++ cnt] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">len[i] = len[i - (i &amp; -i)] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (len[i] == k) bu[++ cnt] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bl[i] = i / B ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">s1[i] = s1[i - <span class="number">1</span>] + (ll)buc[base[i]] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">buc[base[i]  ^  bu[j]] += <span class="number">1</span> ; </span><br><span class="line">s2[i] = s2[i - <span class="number">1</span>] + (ll)buc[base[i]] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; s1[i] &lt;&lt; " " &lt;&lt; s2[i] &lt;&lt; '\n' ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="comment">//emplace_back </span></span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l - <span class="number">1</span>] + s1[r] ; </span><br><span class="line">ans[i] += s2[newl - <span class="number">1</span>] + s1[newr] ;</span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qs[newr].emplace_back(newl, l - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qs[newr].emplace_back(l, newl - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line">debug(ans, <span class="number">1</span>, m, <span class="string">'\n'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++ i) buc[i] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) </span><br><span class="line">buc[base[i] ^ bu[j]] += <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qs[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o) tmp += buc[base[o]] ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) ans[id * (<span class="number">-1</span>)] -= tmp ; <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便结束之后卡了一下，写了个觉得肯定可以卡的 gen：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16383</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">7</span> ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line"><span class="keyword">int</span> i = j ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = j ; (i - j) &lt; M &amp;&amp; p &lt;= n ; i ++, p += <span class="number">2</span>)</span><br><span class="line">base[p] = M - (i - j), base[p + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">j = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">srand(time(<span class="number">0</span>)) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="string">" "</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">gene_Array() ; <span class="keyword">int</span> B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, base[i], <span class="string">" \n"</span>[i == n]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; p) p += B ;</span><br><span class="line"><span class="keyword">int</span> l = p, r = n - p / <span class="number">2</span> ;</span><br><span class="line">        l %= n, r %= n ; <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += n ;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) swap(l, r) ;</span><br><span class="line">l += rand() % (r-l+<span class="number">1</span>) ;</span><br><span class="line">r += rand() % (n-r+<span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="233.jpeg" alt></p><p>其中第二行是我拿一个计数器，记了一下运算量。$7e8$ 能稳过 $1s$，这就很睿智，我果然跟时代脱节了。</p><h1 id="例题-amp-总结"><a href="#例题-amp-总结" class="headerlink" title="例题&amp;总结"></a>例题&amp;总结</h1><blockquote><p>由于个人感觉很有整理价值，于是决定新开一篇整理（</p></blockquote><p>之前一直觉得二次离线会很难，学了学觉得其实还可以。并且没准二次离线这个技巧可以利用到其它地方？或许吧。</p><p>莫队系列似乎是都学完了，爷的青春结束啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。&lt;/p&gt;
&lt;p&gt;另附 pks 词典：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。&lt;/p&gt;
&lt;p&gt;『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。&lt;/p&gt;
&lt;p&gt;『 』(无评价) ：学会了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj3730]震波</title>
    <link href="https://www.orchidany.cn/2020/04/09/%E9%9C%87%E6%B3%A2/"/>
    <id>https://www.orchidany.cn/2020/04/09/震波/</id>
    <published>2020-04-09T01:12:59.000Z</published>
    <updated>2020-04-09T15:46:31.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。</p><p>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。</p><p>接下来你需要在线处理 $m$ 次操作：</p><p><code>0 x k</code> 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</p><p><code>1 x y</code> 表示第 $x$ 个城市的价值变成了 $y$ 。</p><p>为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。</p></blockquote><p>這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…</p><p>不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。</p><p>upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。</p><a id="more"></a><p>大概就是如果沒有修改操作的話，就是比較裸的點分樹。於是先考慮沒有修改操作的情況。</p><p>考慮怎麼維護這個東西，自然是希望對每個點都記錄一個桶，但這樣顯然由於每個點的深度不可控，最終需要的空間代價是 $O(n^2)$ 的。於是考慮怎麼調整樹的高度使得最終總的空間複雜度可以接受，那自然就會想到點分治。注意到點分治時，每個點在分治過程中，『邏輯樹高』都只有 $\log n$ 。這大概就是為什麼用點分樹的原因。</p><p>所以就是建出點分樹來，每個點維護一個 <code>vector</code> 作為桶，維護點分樹上子樹內到當前點距離為 $k$ 的點權和。這樣對於詢問，每次只需要跳點分樹，然後對於每個 $fa$ 統計 $k-dis(fa,x)$ 的點對的數量就好了。但是還有一個問題，就是對於以當前 $fa$ 為根的那些子樹，在算下一個 $fa$ 的時候會被算重。於是就要再維護一個桶，表示 $x$ 子樹內的點，到點分樹上 $x$ 的父親的距離為 $k$ 的點權和。由於邊權都為 $1$ ，這個操作就會很方便。</p><p>考慮如果帶修改，那無非就是把桶換成樹狀數組即可。這樣複雜度就會是 $O(m\log ^2 n)$ 的了。可能我寫的比較醜？預處理是常數不小的 $O(n\log ^2 n)$ ，似乎比其他人都慢誒…</p><p>然後是 bug 集錦：</p><p>1、最開始的時候維護的是 <strong>點分樹</strong> 上距離為 $k$ 的點的點權和。</p><p>2、然後改了改，但是查詢的時候沒有維護兩個 BIT，只維護了一個，然後減去的是查詢 $x$ 的點分樹子樹內到 $x$ 距離 $\leq k-2\times dis(fa_x,x)$ 的點權和。看上去有點東西，但問題在於到 $x$ 距離和到 $fa_x$ 距離沒有本質上的關係…比如可以在樹的對側。</p><p>3、最後還是寫了兩個 BIT，但是調了很久，原因是向上跳遇到 $dis(fa_x,x)&gt;k$ 應該 <code>continue</code> 而不是 <code>break</code> ，因為這距離並是實際距離，在點分樹上沒有單調性。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> d[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> mx_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sub[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; buc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> findCG ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">buc[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = buc[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) buc[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= buc[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)buc[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">sub[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = sub[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) sub[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= sub[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)sub[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += sub[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">Id[root][x] = dep[x] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa)</span><br><span class="line">calc(to(i), x, root), size[x] += size[to(i)] ;</span><br><span class="line">mx_dep = max(dep[x], mx_dep) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root, <span class="keyword">int</span> frt)</span></span>&#123;</span><br><span class="line">add(root, dep[x], base[x]) ;</span><br><span class="line"><span class="keyword">if</span> (frt) add2(root, Id[frt][x], base[x]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa) calc2(to(i), x, root, frt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx ; vis[x] = <span class="number">1</span> ; mx_dep = <span class="number">0</span> ; </span><br><span class="line">calc(x, <span class="number">0</span>, x), init(x, mx_dep) ; </span><br><span class="line">init2(x, h) ; mx = mx_dep ; </span><br><span class="line">calc2(x, <span class="number">0</span>, x, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">num = size[to(k)] ; reset() ;</span><br><span class="line">dfs(to(k), x) ; f[grt] = x ;</span><br><span class="line">find_tree(grt, x, mx) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">char</span> c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> r ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">a = qr(), b = qr(), add(a, b), add(b, a) ;</span><br><span class="line">reset() ; num = n ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; find_tree(grt, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">a = qr() ; </span><br><span class="line">b = qr() ^ lans ; </span><br><span class="line">c = qr() ^ lans ;</span><br><span class="line"><span class="keyword">if</span> (!a)&#123;</span><br><span class="line"><span class="keyword">int</span> fb = f[b] ;</span><br><span class="line"><span class="keyword">int</span> ob, lb = b, df ;</span><br><span class="line">ans += ask(lb, c + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (fb)&#123;</span><br><span class="line">df = Id[fb][b] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (c - df &lt; <span class="number">0</span>)&#123;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ans += ask(fb, c - df + <span class="number">1</span>) ;</span><br><span class="line">ans -= ask2(lb, c - df + <span class="number">1</span>) ;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (lans = ans)) ; </span><br><span class="line">ans = <span class="number">0</span> ; <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ob = b ;</span><br><span class="line">add(b, <span class="number">1</span>, -base[b] + c) ;</span><br><span class="line"><span class="keyword">while</span> (f[b])&#123;</span><br><span class="line"><span class="keyword">int</span> df = Id[f[b]][ob] ;</span><br><span class="line">add(f[b], df, -base[ob] + c) ;</span><br><span class="line">add2(b, df, -base[ob] + c) ; b = f[b] ;</span><br><span class="line">&#125;</span><br><span class="line">base[ob] = c ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。&lt;/p&gt;
&lt;p&gt;不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。&lt;/p&gt;
&lt;p&gt;接下来你需要在线处理 $m$ 次操作：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0 x k&lt;/code&gt; 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 x y&lt;/code&gt; 表示第 $x$ 个城市的价值变成了 $y$ 。&lt;/p&gt;
&lt;p&gt;为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…&lt;/p&gt;
&lt;p&gt;不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。&lt;/p&gt;
&lt;p&gt;upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。&lt;/p&gt;
    
    </summary>
    
      <category term="題解" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/"/>
    
      <category term="BOZJ" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/BOZJ/"/>
    
    
      <category term="数据结构/点分树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj4182] Shopping</title>
    <link href="https://www.orchidany.cn/2020/04/09/shopping/"/>
    <id>https://www.orchidany.cn/2020/04/09/shopping/</id>
    <published>2020-04-09T01:01:10.000Z</published>
    <updated>2020-04-09T13:04:42.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。</p><p>第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。</p><p>这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？</p><p>对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。</p></blockquote><a id="more"></a><p>然後大概是整理過的題目，但個人感覺還是有必要再整理一遍的。</p><p>題意大概是說，在樹上做背包，但是不允許選不連通的點。据说是经典套路题，但我不是很会…</p><p>先考慮比較簡單的 $01$ 背包。考慮一般這種情況需要記錄一下每個點用沒用，所以比較直接的想法是枚舉每個點當根，然後求一個以該點為根時的連通塊出來。但問題就在於合併子樹的複雜度是 $O(V^2)$ （個人覺得存在某種方式的 $V\log V$ 合併，畢竟形式上十分的NTT）。但這樣就是 $n^2V^2$ 的了，所以考慮一個比較經典的優化，在 $dfs$ 序上做，記錄一下每個點子樹內 $dfs$ 序的最大值 $r_i$ 。定義 $f_{i,v}$ 表示 $i\sim n$ 都被考慮完了，代價為 $v$ 時的結果。轉移的話，如果選 $i$ 就從 $i+1$ 來轉移，不選 $i$ 那麼整棵子樹都不能選，從 $r_i+1$ 轉移。 </p><p>然後如果是多重背包的話，套一個單調隊列就可以做到 $n^2V$ 了，但是實際上這題很水，直接 $O(nV\max\{c_i\})$ 的多重背包也沒有問題。然後就是在寫多重背包的時候，發現了很弱智的一點，就是『物品個數』和『體積』哪一個先枚舉的問題…</p><p>顯然的是應該先枚舉體積，否則同一層的狀態會互相嵌套。所以應該這麼寫：</p><p><img src="1.png" alt></p><p>但是還有另一種寫法，用到了『狀態堆疊』這個 trick，雖然複雜度不變但是看起來更帥一點</p><p><img src="2.jpg" alt></p><p>然後考慮如何消掉一個 $n$ ，發現這個 $dp$ 很符合點分治的特點，每次將分治中心作為根，那麼選了根就是經過分治中心，不經過跟就是沒經過分治中心。於是最後的複雜度是 $nV\max\{c_i\}\log n $ 。</p><p>然後就是單調隊列優化多重背包，感覺這個東西很玄妙，十分深刻<del>（被 uoj 群友提醒之後發現似乎不是很深刻，只是自己做題少）</del>：</p><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知對於一個相同的 $i$，不同的 $j$ ，轉移區間的左端點是不降的，于是就对每个 $d$ 用单调队列即可。</p><p>仔細想了想，大概是這麼一個思考過程：觀察上面那個式子可以知道，每次枚舉的會是一些 $w_i$ 的倍數，那麼對於任意一個 $j$ ，轉移路徑裡最初的轉移點就一定在 $0\sim w_i-1$ 中進行，注意到這一點之後自然考慮對於每一個 $d$ 分別做。那麼可以發現，對於每個 $d$ 而言，$d+k<em>w$ 的轉移點都是固定的，比如 $d+7</em>w$ 就只能從 $d+w,d+2\cdot w,\cdots ,d+6*w$ 來轉移，同時由於數量 $c_i$ 的限制，可以知道對於每個 $j$ 只能從 $\geq \lfloor\frac{j}{w_i}\rfloor-c_i$ 的其它 $j$ 來轉移，就變成了一個區間彼此不包含的轉移問題，顯然可以用單調隊列來優化。</p><p>然後最後複雜度就變成了 $O(nV\log n )$ 。</p><p>感覺這個單調隊列的實現有億點細節，可能需要再琢磨一下。</p><hr><p>思考了一下，順便去問了 zay，發現這個轉移有點東西：</p><p>1、由於轉移時是要從 $i-1$ 的狀態轉移，一開始初始賦值完畢之後 $i$ 就是 $i-1$ 的狀態了。那麼每次入隊的時候要保證把 $i-1,j$ 入隊而不是 $i,j$ 。所以入隊的時候要是轉移前的結果。</p><p>2、注意到單調隊列有個問題，就是兩個端點『左閉右閉』和『左閉右開』。左閉右閉的時候需要注意判斷 <code>while (h &lt;= t)</code>，因為當 $h=t$ 的時候還會有元素在隊伍當中。</p><p>3、很 sb 的一點，就是手寫隊列，如果不能保證每次 $dp$ 前隊列都是空的，那麼轉移的時候就需要判斷是否為空，不然會從不合法的狀態點轉移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[t] &lt;= o) q[t --] = <span class="number">0</span> ; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">if</span> (h &lt;= t) dp[j * w[x] + d] = q[h] + v[x] * j ;<span class="comment">//3 </span></span><br><span class="line">q[++ t] = o ; q2[t] = j ; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感覺自己真的沒怎麼寫過單調隊列，同時也對單調隊列理解的不是很好的樣子。</p><p>總代碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> u[N] ;</span><br><span class="line"><span class="keyword">int</span> v[N] ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> q[V] ;</span><br><span class="line"><span class="keyword">int</span> q2[V] ;</span><br><span class="line"><span class="keyword">int</span> rg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][V] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">findCG :: size[x] = <span class="number">1</span> ;</span><br><span class="line">dfn[x] = ++ id ; rev[id] = x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">dfs(to(k), x), findCG :: size[x] += findCG :: size[to(k)] ;</span><br><span class="line">rg[x] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; q[t - <span class="number">1</span>] &lt;= o) q[t --] = <span class="number">0</span> ;</span><br><span class="line">q[t] = o ; q2[t ++] = j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;</span><br><span class="line">dp[j * w[x] + d] = max(dp[j * w[x] + d], q[h] + v[x] * j) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span> ;</span><br><span class="line">id = <span class="number">0</span> ; dfs(x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= id + <span class="number">1</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j) f[i][j] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = id ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">int</span> ii = rev[i] ;</span><br><span class="line"><span class="comment">//if(x == 2) cout &lt;&lt; w[ii] &lt;&lt; " " &lt;&lt; v[ii] &lt;&lt; " " &lt;&lt; ii &lt;&lt; " " &lt;&lt; rg[ii] + 1 &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= w[ii] ; -- j) f[i][j] = f[i + <span class="number">1</span>][j - w[ii]] + v[ii] ;</span><br><span class="line">calc(f[i], ii) ; <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j) f[i][j] = max(f[i][j], f[rg[ii] + <span class="number">1</span>][j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; f[1][m] &lt;&lt; endl ;</span></span><br><span class="line">ans = max(f[<span class="number">1</span>][m], ans) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">findCG :: reset() ;</span><br><span class="line">findCG :: num = findCG :: size[to(k)] ;</span><br><span class="line">findCG :: dfs(to(k), <span class="number">0</span>) ; solve(findCG :: grt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> a, b ; findCG :: num = n ;</span><br><span class="line">fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">fill(head, head + n + <span class="number">1</span>, ans = cnt = <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; w[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; u[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b, add(a, b), add(b, a) ;</span><br><span class="line">findCG :: reset() ; findCG :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">solve(findCG :: grt) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最終被 zay 的二進制分組吊著錘，感覺很不爽 QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。&lt;/p&gt;
&lt;p&gt;第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。&lt;/p&gt;
&lt;p&gt;这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？&lt;/p&gt;
&lt;p&gt;对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/数据结构方法/点分治" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】分块&amp;莫队</title>
    <link href="https://www.orchidany.cn/2020/04/08/%E5%88%86%E5%9D%97%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/04/08/分块听课笔记/</id>
    <published>2020-04-08T03:49:07.000Z</published>
    <updated>2020-04-12T14:40:41.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…</p><p>话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…</p><p>日常不想写数据结构(1/1) 。</p><p>然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭</p><a id="more"></a><p>不做說明的話，全部數據的 $n,m$ 都是 $10^5$ 的。块大小记作 $B$ .</p><h1 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>维护一个序列，支持</p><p>1.区间加。</p><p>2.查询区间小于 $x$ 的数个数。</p></blockquote><p>对于询问操作而言，可以发现区间加不影响块内部的顺序，所以考虑对于每个块维护块内元素排完序之后的结果，存在一个容器里，记为 $ov_x$ 。</p><p>对于修改操作，整块就直接打一个 $tag_x$ ，零散块由于至多有两块受影响，于是考虑暴力重构。暴力重构的方法大概是按顺序将 $ov_x$ 里那些要被加的元素取出，可以知道这样 $ov_x$ 和被取出的那些元素就都是有序的了，可以归并排序做到线性。所以修改复杂度是 $O(B)+O(\frac{n}{B})$ 的。</p><p>查询操作，零散块当然是暴力 $for$ ，整块的话可以考虑二分，那么查询复杂度就变成了 $O(B)+O(\frac{n}{B}\log B)$ 。发现如果令 $B = \sqrt{n\log B}$ ，那么总复杂度会变成 $O(m\sqrt{n\log B})$ ，可能会更优。</p><p>同时也可以把询问对于每一块都离线下来，对于每个块，在每次重构之前可以回答上一次重构之后的问题，用基数排序把这些询问排序之后，和块内元素一起归并可以做到线性。于是就可以离线 $O(m\sqrt n)$ 了。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>维护一个序列，支持查询</p><p>1.区间加</p><p>2.查询区间k小</p></blockquote><p>考虑和上一道题一样的做法，每次外层套一个二分，那么就是查询每个块内 $&lt;x$ 的数的个数，这样还需要再二分，询问复杂度变成了 $O(\frac{n}{B}\log B\log V)$ ，平衡之后就是 $O(\sqrt{n\log B}\log V)$。</p><p>……然而 lxl 出的 YNOI 把这个 Sol 给卡了。</p><p>考虑一个 $trick$ ，就是调整块的大小。令 $B=\sqrt n \log n$ ，那么每次修改显然还是 $O(B)&gt;O(\frac{n}{B})$ 的，查询还是用二分，但是由于整块的数量下降到了 $O(\frac{n}{\sqrt n \log n})=O(\frac{\sqrt n}{\log n})$ ，那么这部分复杂度就变成了 $O(\sqrt n\log n)$ 。看上去很不错？但是零散块查询的时候，由于有 $O(\sqrt  n\log n)$ 的零散点，所以如果暴力二分就又变成俩 $\log $ 了。不过显然这些零散点是可以归并的，于是这部分的复杂度就变成了 $O(\sqrt n\log n+\log n)$ 。</p><p>最终总复杂度 $O(m\sqrt n\log n)$ 。</p><h1 id="根号平衡"><a href="#根号平衡" class="headerlink" title="根号平衡"></a>根号平衡</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><blockquote><p>维护序列，要求 $O(1)$ 修改， $O(\sqrt n)$ 求区间和。</p></blockquote><p>似乎就是最水的分块题。考虑分块维护块内和，修改的时候 $O(1)$ 修改点值和块值，询问就是朴素询问即可。</p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><blockquote><p> 维护序列，要求 $O(\sqrt n)$  修改， $O(1)$ 求区间和。</p></blockquote><p>这个比较有意思。发现要求 $O(1)$ 求区间和，那自然就是要维护前缀和。于是就分别维护块的前缀和 and 块内部的前缀和，每次修改就是要修改之后的块的前缀和 and 散点所在块内部的前缀和，查询作差即可。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>维护序列，要求 $O(\sqrt n)$ 区间加，$O(1)$ 询问单点。</p></blockquote><p>改成维护差分就变成 B 的内容了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>维护序列，要求 $O(1)$ 区间加，$O(\sqrt n)$ 询问单点。</p></blockquote><p>维护差分，就变成 A 了…这一波，这一波整理顺序没有决策单调性（雾）。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>维护一个集合，支持 $O(1)$ 插入一个数，$O(\sqrt n)$ 查询 $k$ 小。</p></blockquote><p>大概就是考虑值域分块。考虑把所有数字离散化之后是 $1\sim m$ ，然后按照值域分块，对于每个块记录一下这段值域出现了多少个数，每个位置出现了多少个数。插入就是在对应位置 $+1$，这个块 $+1$，询问就是 forforfor。</p><p>似乎有个小问题，就是如果值域 $1e9$ 可能要多一个二分的 log。如果不强制在线可以把询问一起离散化，但是如果强制在线可能就必须要二分了。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>维护一个集合，支持 $O(\sqrt n)$ 插入一个数，$O(1)$ 查询 $k$ 小。</p></blockquote><p>还是按值域分块。同时维护每个块的 $ov$。</p><p>那么如果要插入一个数，那么那个块本身需要重构，然后对于这之后的所有数都需要后移一位，相当于每次每个块头部删一个元素，尾部加入一个元素。查询的时候直接定位到那个块即可。</p><p>实现方面，每个块的 $ov$ 拿一个支持双端删插的容器即可。这题的关键点就在于要保证前 $k$ 个块的大小可以快速查询，那么令每个块的大小相同就是不错的选择。</p><h2 id="CodeChef-Chef-and-Churu"><a href="#CodeChef-Chef-and-Churu" class="headerlink" title="[CodeChef] Chef and Churu"></a>[CodeChef] Chef and Churu</h2><blockquote><p>给 $n$ 个数，给定 $m$ 个函数，每个函数为序列中第 $l_i$ 到第 $r_i$ 个数的和。有 $q$ 个询问，两种类型的操作：</p><p><code>1 x y</code> 把序列中的第 $x$ 个数改为 $y$ 。</p><p><code>2 x y</code> 求第 $x$ 个函数到第 $y$ 个函数的和。</p></blockquote><p>一眼感觉是什么 CDQ 🐂🍺题.jpg</p><p>草，知道正解的我眼淚掉下來，感覺好神仙啊。大概就是考虑这些函数都是静态的，所以可以对函数分块，然后维护前 $i$ 个函数里面，序列上每个元素要被算多少次，并且维护前缀函数的答案和。那么每次修改只需要 $\frac{n}{B}$ 地修改每个前缀和即可。询问的时候，整块就是直接拿前缀和作差，对于散点而言，考虑至多是 $O(B)$ 次查询，每次查询本质上是对序列上一个区间的查询。所以用那个 $O(\sqrt n)$ 单点修改 $O(1)$ 查询区间和的方式，即 B 中的技巧就好了。</p><p>最终复杂度 $O(m\sqrt n)$ 。 </p><h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h2 id="AHOI2013-作业"><a href="#AHOI2013-作业" class="headerlink" title="[AHOI2013]作业"></a>[AHOI2013]作业</h2><blockquote><p>查询区间 $[l,r]$ 中值在 $[a,b]$ 内的不同数个数</p><p>$n \leq 10^5 , m \leq 10^5$</p></blockquote><p>考虑直接莫队的话，需要支持查询某个值域中的数，需要上树状数组，但这样带 $\log$ 。</p><p>于是考虑一下莫队的本质，即莫队的复杂度分析，本质上分析的是 $l,r$ 移动的复杂度，也就是修改的复杂度。所以莫队可以本质上看成一个 $O(n\sqrt m)$ 修改，$O(m)$ 询问的数据结构，也就是可以用一个可以快速修改，低速查询的 ds 来维护值域，那这自然就是值域分块，最终复杂度 $O(n\sqrt m+m\sqrt n)$ 。</p><p>然后本题需要分别维护出现次数和是否出现，分别维护即可。</p><p>不过话说回来，这东西本质上等价于查询 $pre_x&lt;l,pos_x\in[l,r],x\in[a,b]$ 的这样的 $x$ 的个数。那么这就是一个三维数点，CDQ 套树状数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> sumr[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; </span><br><span class="line"><span class="keyword">int</span> l, r ; </span><br><span class="line"><span class="keyword">int</span> a, b ; </span><br><span class="line">&#125;q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] -- ; </span><br><span class="line">sumr[blv[base[p]]] -- ;</span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">0</span>) -- sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] ++ ; </span><br><span class="line">sumr[blv[base[p]]] ++ ; </span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">1</span>) ++ sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += (<span class="keyword">bool</span>)sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sum[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_res</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sumr[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), V = max(V, base[i]), bl[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].a, &amp;q[i].b), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> a = q[i].a, b = q[i].b ; </span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">res[q[i].id] = get_res(a, b) ;</span><br><span class="line">ans[q[i].id] = get_ans(a, b) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h2><blockquote><p>給定序列，定义 $v_x$ 为 $x$ 在区间 $[l,r]$ 中的出现次数，查询一个区间中最大的 $x\times v_x$ 。</p></blockquote><p>發現就是莫隊，然後要求查詢某個數的出現次數，跟上面『作業』那個題一樣，直接對值域分塊就好了。</p><p>預處理起來似乎也不是很難的樣子，對每個 $k\times x~(k=1,2,3,\cdots,cnt_x)$ 放到一起離散化就好了。 </p><h2 id="SNOI2017-一个简单的询问"><a href="#SNOI2017-一个简单的询问" class="headerlink" title="[SNOI2017] 一个简单的询问"></a>[SNOI2017] 一个简单的询问</h2><blockquote><p>给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出</p><script type="math/tex; mode=display">\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)</script><p>$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。</p></blockquote><p>首先可以發現這東西就是在求 $\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]$ 。由於是 $\sum $ 的形式，那麼自然可以拆成四個詢問，即詢問</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]\\=&\sum_{i=1}^{r_1}\sum_{j=1}^{r_2}[a_i=a_j]-\sum_{i=1}^{r_1}\sum_{j=1}^{l_2-1}[a_i=a_j]-\sum_{i=1}^{l_1-1}\sum_{j=1}^{r_2}[a_i=a_j]+\sum_{i=1}^{l_1-1}\sum_{j=1}^{l_2-1}[a_i=a_j]\end{aligned}</script><p>那麼就變成了四個雙端點詢問的問題了。注意到每多一個元素 $x$，就會多 $buc_x$ 個 <code>pair</code>，莫隊即可。</p><h2 id="Ynoi2016-这是我自己的发明"><a href="#Ynoi2016-这是我自己的发明" class="headerlink" title="[Ynoi2016]这是我自己的发明"></a>[Ynoi2016]这是我自己的发明</h2><blockquote><p>给一个树，$n$ 个点，有点权，初始根是 $1$ 。$m$ 个操作，每次操作：</p><ol><li>将树根换为 $x$ 。</li><li>给出两个点 $x$，$y$，从 $x$ 的子树中选一个点，$y$ 的子树中选一个点，如果两个点点权相等，<code>ans++</code>，求 ans。</li></ol><p>$n\leq 10^5,m\leq 5\times 10^5$。</p></blockquote><p>發現…似乎本質上就是上面那個題。因為換根這個地方，對於某個點至多有兩種可能，就是子樹內的點為根、子樹外的點為根和自己為根。然後就可以一開始先按照操作，把所有詢問轉化成以 $1$ 為根，$dfs$ 序上的操作。然後大概就和上一道題一樣了。</p><p>需要注意的是，如果是遇到子樹內的點作為根，那麼本身就要兩個詢問，一個詢問全局的，一個減去這個子樹的，注意到詢問全局的並不需要拆，所以一個詢問最多會被拆分成 $(2+1)\times (2+1)=9$ 個詢問，最後 $m$ 可以到 $5\times 10^6$ 左右。雖然莫隊的複雜度可以接受 $m$ 比較大，但是一開始排序的 $m\log m$ 就會很慢。所以可以用基數排序來實現這個過程。</p><h2 id="BZOJ3920-Yunna-的禮物"><a href="#BZOJ3920-Yunna-的禮物" class="headerlink" title="[BZOJ3920] Yunna 的禮物"></a>[BZOJ3920] Yunna 的禮物</h2><blockquote><p>給定序列，每次查询区间中出现次数 $k_1$ 小的数里面的 $k_2$ 小的数。</p></blockquote><p>靠，一開始沒看見『區間』這個限制，還很好奇為什麼要上莫隊…老了老了。</p><p>看了半天題解才大概看明白，似乎是個什麼分塊套分塊的操作。大概就是對於『出現次數』的出現次數開一個桶，然後拿值域分塊來維護這個東西，但是對於每個『次數』還是需要查詢第 $k_2$ 小的數，於是就對於這個塊內的每個『次數』，外面再套一層值域分塊來維護一個固定次數處的數的排序。</p><p>這樣插入就是 $O(1)+O(1)$ ，查詢就是 $O(\sqrt n) +O(\sqrt n)$ 。看上去很棒，但是空間上會被卡…</p><p>這個地方我就很不理解…不知道為啥會被卡…不過那個什麼『分段離散化』的 trick 大概是预处理出对于某一种出现次数，所有可能的数，再将其离散化，对于离散化后的数再來值域分塊维护。這樣複雜度就是線性了。大概是什麼 vector 保存某個數出現 $k$ 次之後的新權值？大概過程就和其他博客講的，如果某個數的總出現次數 $cnt_x&gt;i$ ，那麼就要用 $x$ 預處理 $i$ ，這是顯然的。</p><p>似乎空間被卡的原因是值域分塊的 size 要預先確定，所以不二次離散化，複雜度就會是 $n^2$ 的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…&lt;/p&gt;
&lt;p&gt;话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…&lt;/p&gt;
&lt;p&gt;日常不想写数据结构(1/1) 。&lt;/p&gt;
&lt;p&gt;然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="值域分块" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%80%BC%E5%9F%9F%E5%88%86%E5%9D%97/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
      <category term="数据结构/数据结构方法/分块" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】点分治/点分树相关</title>
    <link href="https://www.orchidany.cn/2020/04/03/%E5%88%86%E6%B2%BB%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://www.orchidany.cn/2020/04/03/分治听课笔记-1/</id>
    <published>2020-04-03T02:50:31.000Z</published>
    <updated>2020-04-09T01:42:55.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>似乎主要是点分治的相关内容？</p><a id="more"></a><h1 id="简单的前言"><a href="#简单的前言" class="headerlink" title="简单的前言"></a>简单的前言</h1><p>首先对于树的点分治所要解决的问题和普通分治一样，只需要统计经过分治中心的信息，假设对于 $k$ 个点而言，统计经过分治中心的信息复杂度是 $O(\gamma(k))$ 的，那么最后的总复杂度就是 $\gamma(n)\log n $ 。</p><p>对于树的边分治而言，遇到菊花就会崩掉。于是考虑对每个点进行<strong>三度化</strong> ，意即建立虚点使得每个点的度数都不超过 $3$ （二度化之后要么是链要么是环）。这样最终的 $size=k$ 的一层至多会分成一个  $size=\frac{1}{3}k$ 的和一个 $size=\frac{2}{3}k$ 的，可以知道如果度数 $\leq 3$ ，这就是能做到的最佳上界。于是最后的复杂度大概是 $\gamma(k)\log _{\frac{3}{2}}k$ 。</p><p>嗯，可能边分治就只用来分析个复杂度，好像几乎没人用的样子。不过也有个好处吧，就是不用考虑可能存在的分治中心的边界问题。</p><h1 id="常见点分治"><a href="#常见点分治" class="headerlink" title="常见点分治"></a>常见点分治</h1><h2 id="比较常见的数据结构"><a href="#比较常见的数据结构" class="headerlink" title="比较常见的数据结构"></a>比较常见的数据结构</h2><p>一般这个东西都比较显然…就题论题吧。</p><h2 id="如果信息可以容斥"><a href="#如果信息可以容斥" class="headerlink" title="如果信息可以容斥"></a>如果信息可以容斥</h2><p>这一类比较常见的是统计满足某个有可减性的点对数，比如统计路径长度/点权和 $&lt;k$ 的路径。常规的容斥做法是考虑对于每一层，计算出所有可能的点对，并且减去那些 <code>belong(x)=belong(y)</code> 的点对 $(x,y)$ 。</p><h2 id="类哈夫曼树合并"><a href="#类哈夫曼树合并" class="headerlink" title="类哈夫曼树合并"></a>类哈夫曼树合并</h2><p>每次选择两个size最小的子树进行合并，这样最后合并的总复杂度摊下来也是 $n \log n$ 的。这个主要用于那些不容易插入删除但是容易合并/重构的信息统计。注意到必须是从小合并到大，这样每次已合并的两个集合 $size$ 至少是较小的那个的两倍，所以每个点至多合并 $\log n$ 次……</p><p>以上复杂度分析似乎很有问题。我也不知道该怎么去定量分析这个问题。</p><p>不过uoj群给了一种很妙的证法。就是考虑每次选两个最小的合并一定可以达到复杂度的下界，因为对于一个合并顺序 $a&lt;b&lt;c$，<code>merge(a,b)</code> 再 <code>merge(b,c)</code> 的复杂度是 $O(2(a+b)+c)$ ，改变合并顺序，<code>merge(a,c)</code> 再 <code>merge(b,c)</code>的 复杂度是 $O(2(a+c)+b)$，也就是改变这个顺序至少不会更优。所以如果想要证明这种合并方式优于某个复杂度，那么只需要随便构造一个这种复杂度的合并方式即可。</p><p>那么问题转化到了如何构造一种 $n\log n$ 的合并。发现如果每次分成差不多大小的两堆，那么复杂度的递推式就是</p><script type="math/tex; mode=display">T(n)=T(pn)+T(qn) + O(n)\quad (p+q=1,0<p,q<1)</script><p>但是这种分析的方式存在一定的问题，就是单纯这么写很容易构造出 $O(n)$ 层，但是 $O(n)$ 层是不符合「每次分成差不多两堆递归」这种情况的。</p><p>然后 uoj (没错我啥都不会只能到处问)里的神仙定量分析了一波，感觉十分有道理。大概就是考虑如果存在某个物品的大小 $\geq \frac{1}{3}$，那么直接把这个物品单独拿出来分成一部分，剩下的分成一部分；否则如果全部的物品的 $size$ 都 $&lt;\frac{1}{3}$ ，那么必定可以分出一堆 $\frac{n}{3}\leq size&lt;\frac{2n}{3}$ 的物品，原因在于这种情况下至少有 $&gt;3$ 种物品，那么如果物品再多的话，只能是类似于把之前的某个物品拆分(总体积不变且每个物品至多大小为 $\frac{1}{3}$)。而在三个物品的时候，是一定可以划分出 $\frac{n}{3}$ 来的，并且物品数如果增多，那么由于体积减小一定可以让划分更平均。所以上界是</p><script type="math/tex; mode=display">T(n)=T(\frac{1}{3}n)+T(\frac{2}{3}n)+O(n)</script><p>算出来复杂度就是 $O(n\log_{\frac{3}{2}} n)$ 。</p><p>嗯，但是这样似乎并不能证明随机选两堆合并的复杂度…那就期望 log 吧！</p><h1 id="一堆题"><a href="#一堆题" class="headerlink" title="一堆题"></a>一堆题</h1><h2 id="限制距离的点对数"><a href="#限制距离的点对数" class="headerlink" title="限制距离的点对数"></a>限制距离的点对数</h2><blockquote><p>求距离不超过 $k$ 的点对数。</p></blockquote><p>注意到可以用点分治，分治的时候只需要考虑经过分治中心的路径，这就显然是枚举每棵子树，套一个树状数组就做完了。直接合并似乎不是很简单。所以还是一个点一个点地插入写起来比较简单一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = g[x] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">make_root(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">chkmax(g[x], num - g[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[rt]) rt = x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (fa == rt)</span><br><span class="line">son[++ cnt] = x, lst[x] = v ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])</span><br><span class="line">dfs(to(k), x, val(k)), size[x] += size[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; (-x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt;= k ; x += low(x)) buc[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; k) <span class="keyword">return</span> ; d[++ tot] = dx ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span> ;</span><br><span class="line">vis[root] = <span class="number">1</span> ; tot = <span class="number">0</span> ;</span><br><span class="line">rt = root ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; '\n' ; debug(son, 1, cnt, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> otot = tot ; calc(son[i], <span class="number">0</span>, lst[son[i]]) ;</span><br><span class="line"><span class="comment">//for (int j = otot + 1 ; j &lt;= tot ; ++ j) cout &lt;&lt; d[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) ans += (ll)ask(k - d[j]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) add(d[j], <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">ans += ask(k) ; <span class="comment">// cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) add(d[i], <span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)]) num = size[to(k)], make_root(to(k), rt), solve(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; g[<span class="number">0</span>] = n ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w ;</span><br><span class="line">add(u, v, w), add(v, u, w) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k ; num = n ;</span><br><span class="line">make_root(<span class="number">1</span>, <span class="number">0</span>) ; solve(rt) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没写了，感觉写起来还可以。</p><h2 id="括号序列问题"><a href="#括号序列问题" class="headerlink" title="括号序列问题"></a>括号序列问题</h2><blockquote><p> 树上每条边有一个括号，统计有多少合法的括号序列路径。</p></blockquote><p>还是直接点分，之后将从 $root$ 延伸出的链中，左括号未匹配的和右括号未匹配的个数相同的可以配对。于是就记一下当前分治中心到各个子树内每个点路径上的匹配值( <code>(</code> 贡献为1, <code>)</code> 为 -1)。然后拿个桶维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">d[++ tot] = dx ; q[tot] = x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) </span><br><span class="line">calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">vis[root] = <span class="number">1</span> ; </span><br><span class="line">tot = <span class="number">0</span> ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[root] ; i ; i = next(i))&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(i)]) <span class="keyword">continue</span> ; </span><br><span class="line"><span class="keyword">int</span> ot = tot ; calc(to(i), root, val(i)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">ans += (ll)buc[- d[j] + M / <span class="number">2</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">buc[d[j] + M / <span class="number">2</span>] ++ ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//cout &lt;&lt; d[i] &lt;&lt; " " &lt;&lt; q[i] &lt;&lt; " &amp; " &lt;&lt; endl, </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) buc[d[i] + M / <span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">num = size[to(k)] ; rt = <span class="number">0</span> ;</span><br><span class="line">make_root(to(k), rt) ; solve(rt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径数量问题"><a href="#路径数量问题" class="headerlink" title="路径数量问题"></a>路径数量问题</h2><blockquote><p>给定一棵树，求长度分别为 $1,2,3\ldots n$ 的路径数量。</p></blockquote><p>发现可以对每个子树记一下 $buc_i$ 表示深度为 $i$ 的点的数量，发现两棵子树的 $buc$ 对答案的贡献是一个卷积的形式。那么考虑直接枚举每棵子树，计算贡献时对当前桶和前缀桶用 $\rm NTT$ 来合并即可。</p><p>值得注意的是，这东西必须要从小到大枚举每个子树进行合并，复杂度才是对的（证明就是上面那个类哈夫曼树合并的证明）</p><p>最终复杂度 $n\log ^2 n$ 。代码就不写了，就是死亡二合一罢了。</p><h2 id="树上背包问题"><a href="#树上背包问题" class="headerlink" title="树上背包问题"></a>树上背包问题</h2><blockquote><p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>连通子树</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p><p>$n\leq 5000,V\leq 3000$ </p></blockquote><p>据说是经典套路题，但我不会…</p><p>考虑强制选根怎么做。考虑直接树形dp，合并两个子树的背包复杂度是 $V^2$ 的。于是考虑换一种可以不去合并子树的 $dp$ 方式。考虑在 dfs 序上对这个东西进行dp，设一个点 $u$ 子树的范围是 $p_u\sim r_{u}$ ，那么就可以设 $f_{i,v}$ 表示考虑了 $i\sim n$ 的物品，根必选且容积为 $v$ 的最大价值。考虑转移，对于一个 $i$ 而言，如果选了他，就可以从 $i+1$ 转移，否则由于根必须被选，$i$ 不选，整棵子树都不能选，所以只能从 $r_i+1$ 转移过来。于是这样的复杂度就是 $O(nv)$ 的了。 </p><p>暴力做是 $O(n^2v)$ 的，复杂度瓶颈在于枚举根。考虑一个性质，就是如果点 $v$ 不在答案中，那么与其相邻的连通块不会互相通达，因为树上路径唯一。于是就可以考虑点分，经过/不经过根分别对应分治下去和跨过分治中心两种情况。最终复杂度 $nv\log n$ 。</p><p>在合并的时候可能有亿点细节需要去写…233</p><h1 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于点分树，有一个很优秀的性质，就是树高不超过 $\log n$ ，对于一些题目可以用这个性质进行转化。</p><blockquote><p>给定一棵无权树，单点修改，求距离 $x$ 不超过 $r$ 的点权和。</p></blockquote><p>考虑如果没有修改操作时，直接求也是不太好求的。于是考虑点分治，对于每个分治中心，预处理记录一下子树中距离 $\leq k\quad (k=1,2,3\cdots )$ 的点权和。 注意到这最多需要 $n \log n$ 的空间，拿 <code>vector</code> 实现即可。</p><p>那么对于询问而言，直接从点分树上暴跳，每跳到一个点分中心 $p$，就可以加上这个点记录的 $\leq r-(dep_p-dep_x)$ 的点权和，并且减去上一个点分中心子树内部 $\leq r-(dep_p-dep_x)$ 的点权和。由于点分树树高的限制，这个过程是 $\log n$ 的。</p><p>考虑如何修改，发现本质上修改+询问是一个单点修改，前缀查询的过程，于是就可以换用树状数组来维护，修改时只需要暴力跳即可，这样最终复杂度就是 $m\log ^2 n$ 的了。</p><h2 id="树上背包问题2"><a href="#树上背包问题2" class="headerlink" title="树上背包问题2"></a>树上背包问题2</h2><blockquote><p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>独立集</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p><p>$n\leq 100,V\leq 30000$ </p></blockquote><p>考虑一个比较 <code>general</code> 的 $dp$ ，还是跟上个题一样，直接合并背包是 $V^2$ 的，所以考虑把这棵树的 $dfs$ 序写下来，然后 $f_{i,j,s}$ 表示考虑了前 $i$ 个点，容量为 $j$ ，每个点选不选表示为集合 $s$ ，最终复杂度就是 $nv2^n$ 。</p><p>考虑如何少记一点东西，似乎需要把这个 $2^n$ 给降下来。于是考虑点分治。发现点分治的每一层，子树之间都是互不影响的，所以只需要把点分树找出来，对点分树进行树形 $dp$ ，记 $s$ 时只需要记每一层的点分中心的状态即可。这样由于点分树高是 $O(\log n)$ 的，所以最终复杂度是 $O(nv2^{\log n})=O(n^2v)$ 。</p><h2 id="ZJOI-2007-捉迷藏"><a href="#ZJOI-2007-捉迷藏" class="headerlink" title="ZJOI 2007 捉迷藏"></a>ZJOI 2007 捉迷藏</h2><blockquote><p>修改⼀个点的⿊白，求最远⿊点之间距离。</p></blockquote><p>考虑大致思路和「引入」中差不多，但是需要注意的是由于是统计最长的点对间距离，所以用边分治会好做一些。那么分治的时候还是需要按是否经过分治中心来分类。之后拿一个 multiset 来维护就好了。</p><p>嗯，除了边分不会写之外，没啥可说的。</p><p>据说还有 $1$ 个 $\log $ 的做法，那必然是鸽了。</p><h1 id="补充题目"><a href="#补充题目" class="headerlink" title="补充题目"></a>补充题目</h1><h2 id="某不知名CF题"><a href="#某不知名CF题" class="headerlink" title="某不知名CF题"></a>某不知名CF题</h2><blockquote><p>给一棵树，点、边均有权，求点 $x$，最小化 $\sum_{i=1}^{n} a_{i} \cdot \operatorname{dis}^{1.5}(i, x)$ 。  $n \leq 10^{5}$ 。</p></blockquote><p>事实上是 CF566C (雾</p><p>首先对于 $1.5$ 次方的 $\sum $，由于相加之后二阶导依旧 $&gt;0$ ，所以相加之后依旧是凸函数。那么也就是说，假设 $x$ 可以在边上随便取，那么对于一条固定的路径 $x\in(u,v)$ ， $\mathrm{dis}(x,u)^{1.5}$ 必定是一个下凸函数。</p><p>考虑在链上必然是二分，那么调整到树上就可以进行点分。考虑对于每个点分中心，都应该找可以使答案变小的那个儿子所在子树点作为下一个进行点分的连通块。考虑如何去实现判断这个过程。如果答案变小，那么一定是导数减小，于是可以求出子树中每个点对应值的导数 $df_x$，那么总体的导数就是 $\sum df_x-2\cdot df_v&lt;0$ ，$v$ 是下一个要进行点分的子树，原因是通过计算偏移量，剩余的点的 $f$ 都会变大，当前点会变小。这个求导的过程本质上是在模拟，我向每条边移动一个 $\epsilon$ 之后的结果。</p><p>于是就点分进行这个过程即可，点分是为了加速计算每个子树的 $df$ ，保证最终这一部分的计算量是 $n\log n$ 的。</p><h2 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h2><blockquote><p>给定一个有向图，每次加入一条边 $(u,v)$，或者询问有多少点对两两可达。</p></blockquote><p>考虑一个<del>深刻的</del>单调性，如果在某一时刻出现了一个SCC，把它缩起来，那么之后它也会一直被缩起来。</p><p>于是考虑整体二分，<code>solve(l,r,E)</code> 表示 $E$ 中的边会在时刻 $l\sim r$ 中被缩起来。于是每次把 $[l,mid]$ 这些边跑一个强连通分量，那么被缩起来的边递归到 <code>solve(l,mid,E1)</code> 里面，没被缩起来的边递归到 <code>solve(mid+1,r,E2)</code> 里面。同时为了让分治的复杂度是对的，每次点集大小不能跟 $n$ 有关，于是就需要每次在 <code>solve(l,mid,E1)</code> 之后把 E1里的点拿并查集给缩起来，这样才能保证 <code>solve(mid+1,r,E2)</code> 的复杂度只跟边数有关。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态点分治是不可能的，这辈子都不可能的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似乎主要是点分治的相关内容？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构/点分树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/点分治" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】从剩余类到欧拉定理</title>
    <link href="https://www.orchidany.cn/2020/04/02/%E5%89%A9%E4%BD%99%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>https://www.orchidany.cn/2020/04/02/剩余类相关内容/</id>
    <published>2020-04-02T14:17:44.000Z</published>
    <updated>2020-04-02T16:49:26.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「重学4-6」系列的最后一篇文章。</p><p>感觉剩余类这部分内容，以纯数论的眼光去看待，是十分优美的。</p><p>嗯，将来自己抽代真正入门之后，可能就会多一点别的角度了吧。</p><a id="more"></a><h1 id="剩余类相关定义"><a href="#剩余类相关定义" class="headerlink" title="剩余类相关定义"></a>剩余类相关定义</h1><h2 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h2><p>定义 1.1</p><blockquote><p>记在模 $m$ 意义下，全部对 $m$ 同余的整数组成的集合，叫做 $m$ 的一个剩余类。</p></blockquote><p>那么显然对于一个固定的模 $m$，有 $m$ 个剩余类，分别同余 $0,1,2\cdots m-1$，分别记作 $\mathrm{ Z}_{m,0},\mathrm{ Z}_{m,1},\mathrm{ Z}_{m,2}\cdots,\mathrm{ Z}_{m,m-1}$ 。记所以剩余类组成的集合是 $\mathrm{ Z}_{m}$ 。</p><p>考虑定义剩余类之间的运算 $+$ 和 $\times $ ：</p><script type="math/tex; mode=display">\mathrm{ Z}_{m,a}+\mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a+b}\\\mathrm{ Z}_{m,a}\times \mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a\times b}</script><p>其中 $a+b$ 和 $a\times b$ 是在模 $m$ 意义下的数加和数乘。并且可以知道，对于全体模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m}$ 而言，$&lt;\mathrm{ Z}_{m},+,\times&gt;$ 本身是一个环。考虑如下：</p><p>1、首先 $(\mathrm{ Z}_{m},+)$ 显然是一个阿贝尔群。</p><p>2、其次 $(\mathrm{ Z}_{m},\times )$ 显然具有结合律，但是如果对于某个剩余类 $\mathrm{ Z}_{m,p}$ $(p,m)&gt;1$ ，就说明了 $\mathrm{ Z}_{m,p}$ 本身不存在逆元 ，所以可知道 $(\mathrm{ Z}_{m},\times )$ 是一个半群。</p><p>3、同时可知在 $(\mathrm{ Z}_{m},\times )$ 中，高优先级运算 $\times $ 对低优先级运算 $+$ 有分配律。</p><p>综上，$(\mathrm{ Z}_{m},+,\times )$ 是一个环。并且不难知道 $\mathrm{ Z}_{m,0}$ 就是这个环中的零元。</p><p>但是这个环并不是正则环。考虑我们熟知的正则环 $&lt;\mathbb Z,+,\times&gt;$ 和 $&lt;\mathbb R,+,\times &gt;$ 内都不存在零因子 $a,b$ 使得 $a\not =0,b\not = 0$ 且 $a\times b=0$ 。但是在模运算下这是可能成立的，比如可以设 $m=pq$ ，其中 $p\not \equiv q\pmod m$，那么就有 $\mathrm{ Z}_{m,p} \times \mathrm{ Z}_{m,q}=\mathrm{ Z}_{m,0}$ ，此时 $p,q$ 就均为 $\mathrm{ Z}_{m}$ 的零因子。所以可知剩余类环并不是正则的。</p><h2 id="互素剩余类"><a href="#互素剩余类" class="headerlink" title="互素剩余类"></a>互素剩余类</h2><h3 id="定义1-2"><a href="#定义1-2" class="headerlink" title="定义1.2"></a>定义1.2</h3><blockquote><p>若对于一个模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m,k}$ 满足 $(m,k)=1$ ，那么称 $\mathrm{ Z}_{m,k}$ 为模 $m$ 的一个互素剩余类。</p></blockquote><p>为了方便起见，记某个互素剩余类 $\mathrm{ Z}_{m,k}$ 为 $\mathrm{\zeta}_{m,k}$ 。同时可知这样的 $\mathrm{\zeta}_{m,k}$ 共有 $\varphi(m)$ 个。</p><h1 id="剩余系"><a href="#剩余系" class="headerlink" title="剩余系"></a>剩余系</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义2-1"><a href="#定义2-1" class="headerlink" title="定义2.1"></a>定义2.1</h3><blockquote><p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p><script type="math/tex; mode=display">i\in\mathrm{ Z}_{m,p}, j \in \mathrm{ Z}_{m,q}, \mathrm{ Z}_{m,p}\not=\mathrm{ Z}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个完全剩余系。</p></blockquote><h3 id="定义2-2"><a href="#定义2-2" class="headerlink" title="定义2.2"></a>定义2.2</h3><blockquote><p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p><script type="math/tex; mode=display">i\in\mathrm{ \zeta}_{m,p}, j \in \mathrm{ \zeta}_{m,q}, \mathrm{ \zeta}_{m,p}\not=\mathrm{ \zeta}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个简化剩余系。</p></blockquote><p>可知模 $m$ 的一个完全剩余系的大小是 $m$ ，一个简化剩余系的大小是 $\varphi(m)$ 。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2.1"></a>定理2.1</h3><blockquote><p>设 $m\in \mathbb Z_+$，$k,p\in \mathbb Z$ 且 $(k,m)=1$ ，则</p><p>（1）当 $x$ 遍历模 $m$ 的一个完全剩余系 $\mathrm{S}$ 时，$kx+p$ 也遍历模 $m$ 的一个完全剩余系 $\mathrm{S’}$ 。</p><p>（2）当 $x$ 遍历模 $m$ 的一个简化剩余系 $\mathrm{T}$ 时，$kx$ 也遍历模 $m$ 的一个简化剩余系 $\mathrm{T’}$ 。</p></blockquote><p>证：</p><p>（1）考虑只需要证对于任意两个模 $m$ 下不同余的 $x_i,x_j$ ， $kx_i+p,kx_j+p$ 也是不同余的，那么就可以得证。</p><p>考虑反证法。若 $kx_i+p\equiv kx_j+p\pmod m$，则有</p><script type="math/tex; mode=display">kx_i\equiv kx_j\pmod m</script><p>那么由于 $(k,m)=1$ 且根据定理</p><blockquote><p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p></blockquote><p>可知 $x_i\equiv x_j\pmod m$ 。矛盾。</p><p>（2）由（1）可以知道 $kx_i$ 彼此之间不同余，且因为 $(k,x_i)=(k,m)=1$ ，所以可知遍历的是一个简化剩余系。</p><h3 id="定理2-2"><a href="#定理2-2" class="headerlink" title="定理2.2"></a>定理2.2</h3><blockquote><p>设 $(m_1,m_2)=1$ ，则：</p><p>（1）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个完全剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个完全剩余系。</p><p>（2）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个简化剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个简化剩余系。</p></blockquote><p>证：</p><p>（1）</p><p>还是从证明互不同余这方面来考虑。如果存在 $x_1,x_2,y_1,y_2$ 使得</p><script type="math/tex; mode=display">m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1} m_{2}}</script><p>那么首先有</p><script type="math/tex; mode=display">m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1}}</script><p>即</p><script type="math/tex; mode=display">m_{2} x_{1} \equiv m_{2} x_{2}\pmod {m_{1}}</script><p>那么因为 $(m_1,m_2)=1$ ，所以有</p><script type="math/tex; mode=display">x_{1} \equiv x_{2}\pmod {m_{1}}</script><p>同理可知</p><script type="math/tex; mode=display">y_{1} \equiv y_{2}\pmod {m_{1}}</script><p>那么就可以知道，当 $x_1,x_2$ 不同余，$y_1,y_2$ 不同余的时候，$m_2x+m_1y$ 也是不同余的。</p><p>（2）</p><p>首先由于 $(x,m_1)=(y,m_2)=1$ ，所以 $(m_2x+m_1y,m_1)=1$ 且 $(m_2x+m_1y,m_2)=1$，所以可知 $m_2x+m_1y$ 一定会属于 $m_1m_2$ 的简化剩余系。同时由（1）中的结论可知这 $\varphi(n)\varphi(m)$ 个结果是两两不同余的。于是就只需要证明 $m_1m_2$ 的简化剩余系中，均属于这 $\varphi(n)\varphi(m)$ 个元素组成的集合即可。</p><p>对于任意一个与 $m_1m_2$ 互质的元素 $q$，由（1）可知必定存在一组 $(s,t)$ 使得</p><script type="math/tex; mode=display">q\equiv m_2s+m_1t\pmod {m_1m_2}</script><p>考虑若 $(s,m_1)&gt;1$ ，则有某个$d&gt;1,d|s$ 满足 $d|m_1\Longrightarrow d|m_1m_2$ 的同时 $d|q$ ，那么 $(m_1m_2,q)\geq d$ ，不符合互质的假设。故可知 $(s,m_1)=1$ ，同理 $(t,m_2)=1$ ，故证毕。</p><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>由定理 2.2(2) 可知，分别遍历模 $m_1$ 和 $m_2$ 的简化剩余系的 $x$ 和 $y$ ，在 $(m_1,m_2)=1$ 时，$m_1y+m_2x$ 遍历模 $m_1m_2$ 的一个简化剩余系。 根据乘法原理，可以得到 $\varphi(m_1)\cdot \varphi(m_2)=\varphi(m_1m_2)$ 。</p><p>这也就证明了欧拉函数 $\varphi(x)$ 是积性函数。</p><h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><blockquote><p>若 $(a,m)=1$ ，则有 $a^{\varphi(m)}\equiv 1\pmod m$ .</p></blockquote><p>若设 $(x_1,x_2,x_3\cdots x_{\varphi(m)})$ 是模 $m$ 的一个简化剩余系，那么由定理2.1(2)可知 $(ax_1,ax_2,ax_3\cdots ax_{\varphi(m)})$ 也是模 $m$ 的一个简化剩余系。所以有</p><script type="math/tex; mode=display">\prod_{i=1}^{\varphi(m)} x_i\equiv \prod_{i=1}^{\varphi(m)} ax_i\pmod m</script><p>那么由于 $\forall i,(x_i,m)=1$，所以 $(\prod x_i,m)=1$ 。于是消一下可以得到</p><script type="math/tex; mode=display">1\equiv a^{\varphi(m)}\pmod m</script><p>证毕。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人感觉剩余类这部分是很有趣的，虽然以上内容大部分都是4-6里面提炼出来的。对于欧拉定理，用群论知识证明同样十分简洁。</p><p>总之，完结啦，撒花花。</p><p>数论4-6，也算是我的一场持续了三年的春花旧梦了吧。</p><p>不知道啥时候能和EI和rqy一样有对数学知识的深刻认识。慢慢来吧。只有站在越高处，才能看到越广的风景，不是吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「重学4-6」系列的最后一篇文章。&lt;/p&gt;
&lt;p&gt;感觉剩余类这部分内容，以纯数论的眼光去看待，是十分优美的。&lt;/p&gt;
&lt;p&gt;嗯，将来自己抽代真正入门之后，可能就会多一点别的角度了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/抽象代数/环论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E7%8E%AF%E8%AE%BA/"/>
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[湖北省队互测2014week1 B] 一个人的数论</title>
    <link href="https://www.orchidany.cn/2020/04/01/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%95%B0%E8%AE%BA/"/>
    <id>https://www.orchidany.cn/2020/04/01/一个人的数论/</id>
    <published>2020-04-01T14:26:51.000Z</published>
    <updated>2020-04-02T17:38:01.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n$ 的质因数分解 $n= \prod _{i=1}^kp^{a_{i}}$，求所有小于 $n$ 且与 $n$ 互质的正整数的 $m$ 次方之和模 $10^9 +7$ 的值。其中 $p_i$ 为质数且不超过 $10^9$ 。</p><p>$a_i ≤ 10^9,k ≤ 1000,m ≤ 100$。</p></blockquote><a id="more"></a><p>写出式子来</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^n[(i,n)=1]i^m\\=&\sum_{i=1}^ni^m\sum_{d|i,d|n}\mu(d)\\=&\sum_{d|n}d^m\mu(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}  i^m\end{aligned}</script><p>然后发现这东西好像不是容易提前预处理。根据伯努利数的推论，可以知道 $\sum i^m$ 这东西是一个关于上界 $n$ 的 $m+1$ 次多项式。发现 $m$ 并不大于是可以 $O(m^2)$ 插出来。 若记这个多项式是 $f$ ，那么原式就等价于</p><script type="math/tex; mode=display">\sum_{d|n}d^m\mu(d)\sum_{i=1}^{m+1} f_i\left(\lfloor\frac{n}{d}\rfloor\right) ^ i</script><p>稍微化一下就是</p><script type="math/tex; mode=display">=\sum_{i=0}^{m+1} f_{i} \sum_{d | n} d^{m} \mu(d)\left(\frac{n}{d}\right)^{i}</script><p>发现对于后面的 $\sum $ 只需要求出每个 $p_i^{a_i}$ 处的值，然后每次 $O(k)$ 暴力合并，似乎也没啥问题。考虑对于每个 $p_i^{a_{i}}$ 怎么求。这个地方大概需要涨个经验，就是 $\mu(d)$ 这东西只有当 $d=1$ 和 $d=p_i$ 的时候才有值(无平方因子,剩下的因子都是 $p_i$ 的某个次数 $&gt;2$ 的幂)，所以每个只需要算两次，是 $O(1)$ 的。于是最后的复杂度 $O(m(m+k))$ 。</p><p>好神啊好神啊。</p><p>哈哈哈哈哈草这个题居然允许用高斯消元来代替插值。毕竟 $m$ 只有 $100$ 。</p><p>然后关于拉插，感觉很gg，因为一共有三个版本的拉插，求值和求系数，求值的又分为 $x$ 连续/不连续的。于是今天就把三个版本都写了一遍……</p><p>不过有一说一，求系数的拉插感觉就是在模拟。然后我还对着多项式除法(整除以一个形如 $(x+t)$ 的多项式)摸了好久，一直感觉很迷乱，后来用了用大除法，发现就是在模拟大除法的过程罢了。</p><p>然后一开始我还憨憨的写了个线性筛，然后发现 $\mu(d)$ 的 $d$ 是 $1e9$ 的，就懵圈了，然后又发现 $\mu(d)$ 只会是 $1/-1$ 并且很好判断，于是感觉自己是个sb。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Interpolation&#123;</span><br><span class="line"><span class="keyword">int</span> ans ; </span><br><span class="line"><span class="keyword">int</span> now ; </span><br><span class="line"><span class="keyword">int</span> x[N] ;</span><br><span class="line"><span class="keyword">int</span> y[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ; </span><br><span class="line"><span class="keyword">int</span> inv[N] ; </span><br><span class="line"><span class="keyword">int</span> pres[N] ; </span><br><span class="line"><span class="keyword">int</span> sufs[N] ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">a = (a % P + P) % P ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">res = (ll)res * a % P ; </span><br><span class="line">a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fz[N] ;</span><br><span class="line"><span class="keyword">int</span> fm[N] ; </span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a += b ;</span><br><span class="line"><span class="keyword">if</span> (a &gt; P) a -= P ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">(a -= b) %= P ;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmul</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = deg + <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">tmp[i] = t[i], t[i] = t[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg + <span class="number">1</span> ; ++ i)</span><br><span class="line">add(t[i], (ll)opt * tmp[i] % P) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdiv</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> *ret, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg ; ++ i) tmp[i] = t[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = deg - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">ret[i] = tmp[i + <span class="number">1</span>], dec(tmp[i], (ll)tmp[i + <span class="number">1</span>] * opt % P) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_xs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">fz[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">fmul(fz, i, (-x[i] + P) % P) ;</span><br><span class="line"><span class="comment">//debug(fz, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> fenmu = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) fenmu = (ll)fenmu * (x[i] - x[j] + P) % P ;</span><br><span class="line">fdiv(fz, fm, n + <span class="number">1</span>, -x[i]) ; </span><br><span class="line">fenmu = (ll)y[i] * expow(fenmu, P - <span class="number">2</span>) % P ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; fenmu &lt;&lt; endl ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">add(res[j], (ll)fenmu * fm[j] % P) ;</span><br><span class="line"><span class="comment">//debug(res, 1, n, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">inv[U] = expow(fac[U], P - <span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = (ll)inv[i] * i % P ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evenmark</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dnx</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m)&#123;</span><br><span class="line">pre_do(n) ;</span><br><span class="line">pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line">now = (ll)now * expow((ll)fac[i - <span class="number">1</span>] * fac[n - i] % P, P - <span class="number">2</span>) % P ;</span><br><span class="line">now = (ll)evenmark(n - i) * y[i] % P * now % P ; ans = (ll)(ans + now) % P ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> inow = <span class="number">1</span> ;</span><br><span class="line">pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">inow = <span class="number">1</span>, now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) inow = (ll)inow * ((x[i] - x[j]) % P + P) % P ; </span><br><span class="line">ans = (ans + (ll)now * expow(inow, P - <span class="number">2</span>) % P * y[i] % P) % P ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">namespace Linear_sieve&#123;</span></span><br><span class="line"><span class="comment">int cnt ;</span></span><br><span class="line"><span class="comment">int pr[N] ; </span></span><br><span class="line"><span class="comment">int mu[N] ;</span></span><br><span class="line"><span class="comment">int vis[N] ;</span></span><br><span class="line"><span class="comment">void sieve(int U)&#123;</span></span><br><span class="line"><span class="comment">mu[1] = 1 ;</span></span><br><span class="line"><span class="comment">for (int i = 2 ; i &lt;= U ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">if (!vis[i]) mu[i] = -1, pr[++ cnt] = i ; </span></span><br><span class="line"><span class="comment">for (int j = 1 ; j &lt;= cnt ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">if (i * pr[j] &gt; U) break ; </span></span><br><span class="line"><span class="comment">vis[i * pr[j]] = 1 ; </span></span><br><span class="line"><span class="comment">if (i % pr[j] == 0) break ; </span></span><br><span class="line"><span class="comment">mu[i * pr[j]] = -mu[i] ; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">int</span> d, w, num ;</span><br><span class="line"><span class="keyword">int</span> base[N], cs[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d &gt;&gt; w ; n = d + <span class="number">2</span> ; </span><br><span class="line"><span class="comment">//using namespace Linear_sieve ; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Interpolation ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">x[i] = i, y[i] = (y[i - <span class="number">1</span>] + expow(x[i], d)) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= w ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i] &gt;&gt; cs[i] ; get_xs(n) ; </span><br><span class="line"><span class="comment">//debug(y, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(res, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">now = <span class="number">0</span>, num = <span class="number">1</span> ;   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= w ; ++ j)&#123;</span><br><span class="line">now = expow(expow(base[j], cs[j] - <span class="number">1</span>), i - <span class="number">1</span>) ;</span><br><span class="line">now = ((<span class="number">-1l</span>l * now * expow(base[j], d) % P) + P) % P ; </span><br><span class="line">now = (now + expow(expow(base[j], cs[j]), i - <span class="number">1</span>)) % P ; </span><br><span class="line">num = <span class="number">1l</span>l * num * now % P ; </span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + (ll)num * res[i] % P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n$ 的质因数分解 $n= \prod _{i=1}^kp^{a_{i}}$，求所有小于 $n$ 且与 $n$ 互质的正整数的 $m$ 次方之和模 $10^9 +7$ 的值。其中 $p_i$ 为质数且不超过 $10^9$ 。&lt;/p&gt;
&lt;p&gt;$a_i ≤ 10^9,k ≤ 1000,m ≤ 100$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="多项式的应用" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[bzoj3853] GCD Array</title>
    <link href="https://www.orchidany.cn/2020/03/31/GCD-Array/"/>
    <id>https://www.orchidany.cn/2020/03/31/GCD-Array/</id>
    <published>2020-03-31T14:18:24.000Z</published>
    <updated>2020-04-02T16:52:53.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>维护一个序列，支持以下操作：</p><p>1、给定 $n,d,v$ ，对每个 $(x,n)=d$ 的 $a_x\text{+=}v$ 。</p><p>2、询问 $\sum _{i=1}^k a_i$</p><p>$n\leq 10^5$</p></blockquote><p>很有意思的题目，解法也很简洁。</p><a id="more"></a><hr><p>妙妙题，建立一个辅助数组 $f$，让 $a_i=\sum _{d|i}f_d$ 。</p><p>考虑每次加的操作，对于每个 $i$ 实际上是加上这个东西：</p><script type="math/tex; mode=display">\begin{align*}&[(n,i)=d]v\\= &[(\frac{n}{d},\frac{n}{i})=1]v\\= &\sum_{k|\frac{n}{d},k|\frac{n}{i}}\mu(k)v\end{align*}</script><p>考虑对 $f$ 反演:</p><script type="math/tex; mode=display">f_d=\sum_{k|d}\mu(k)a_{\frac{d}{k}}</script><p>那么可以看出，其实每次操作就是对所有的 $k | \frac{n}{d}$ 的 $f_{kd}$ 加上了 $\mu(k)\cdot v$ .</p><p>考虑询问操作就是在询问</p><script type="math/tex; mode=display">\sum_{i=1}^x\sum_{d|i}f_d=\sum_{d=1}^{x}\left[\frac{x}{d}\right] f_d</script><p>这个可以 $\sqrt n$ 分块来做。于是最后修改复杂度 $\sqrt[3] n\log n$，询问复杂度 $\sqrt n\log n$ 。 注意到可以调整块的大小，对于所有 $&lt;\sqrt {x\log x}$ 的位置暴力加，对于所有 $&gt;\sqrt {x\log x}$ 的位置，至多有 $\sqrt \frac{x}{\log x}$ 个。所以可以把 $\log $ 放到里面去。</p><p>当然我肯定是写 $\sqrt n\log n$ 的啦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200110</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> L_s&#123;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ; </span><br><span class="line"><span class="keyword">int</span> mu[N] ;</span><br><span class="line"><span class="keyword">int</span> smu[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ; </span><br><span class="line">vis[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">mu[i * pr[j]] = -mu[i] ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">smu[i] = smu[i - <span class="number">1</span>] + mu[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">fc[i * j].push_back(i) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ; </span><br><span class="line">ll _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; (-x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt;= n ; x += low(x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += (ll)_bit[x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, d, v ; </span><br><span class="line">L_s :: sieve(N - <span class="number">10</span>) ; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ++ T ;</span><br><span class="line"><span class="keyword">if</span> (!(m + n)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; T &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">fill(_bit + <span class="number">1</span>, _bit + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x) ; </span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;d, &amp;v) ; <span class="keyword">if</span> (x % d != <span class="number">0</span>) <span class="keyword">continue</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L_s :: fc[x / d].size() ; ++ i)</span><br><span class="line">add(L_s :: fc[x / d][i] * d, L_s :: mu[L_s :: fc[x / d][i]] * v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)</span><br><span class="line">r = x / (x / l), ans += (ask(r) - ask(l - <span class="number">1</span>)) * (ll)(x / l) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;维护一个序列，支持以下操作：&lt;/p&gt;
&lt;p&gt;1、给定 $n,d,v$ ，对每个 $(x,n)=d$ 的 $a_x\text{+=}v$ 。&lt;/p&gt;
&lt;p&gt;2、询问 $\sum _{i=1}^k a_i$&lt;/p&gt;
&lt;p&gt;$n\leq 10^5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很有意思的题目，解法也很简洁。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="分治" scheme="https://www.orchidany.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[UR#5 C]怎样跑的更快</title>
    <link href="https://www.orchidany.cn/2020/03/31/UR5-%E6%80%8E%E6%A0%B7%E8%B7%91%E7%9A%84%E6%9B%B4%E5%BF%AB/"/>
    <id>https://www.orchidany.cn/2020/03/31/UR5-怎样跑的更快/</id>
    <published>2020-03-31T14:14:34.000Z</published>
    <updated>2020-04-02T16:53:03.859Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n ≤ 10^5;c,d ≤ 10^9$ 。</p><p>现有长度为 $n$ 的序列 $b$ 满足 $b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c}  \mathrm{lcm}(i, j)^{d} z_{j}(\bmod 998244353)$ 。</p><p>求 $\{z_n\}$ 。</p></blockquote><p>草，这真是一道神仙题。钛钛钛钛有趣辣！sto vfk .</p><a id="more"></a><p>先转化一下：</p><script type="math/tex; mode=display">b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c-d}\cdot i^d\cdot j^d\cdot  z_{j}(\bmod 998244353)</script><p>考虑形如 $\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j$ 等于某个值的东西，大概都是可做的。考虑先构造一个 $f’$ 满足</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}f'(d)</script><p>那么就可以化一下</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{j=1}^n\sum_{d}[d|i]\cdot [d|j]\cdot f'(d)\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot g(i)\cdot h(j)\cdot z_j\end{aligned}</script><p>那么就相当于要验证</p><script type="math/tex; mode=display">\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j =\frac{b_i}{g(i)}</script><p>如果能快速算 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 的话，那么有</p><script type="math/tex; mode=display">\sum_{d|i}f'(d)\zeta(d)=\frac{b_i}{g(i)}</script><p>考虑对于一个二元关系</p><script type="math/tex; mode=display">\sum_{d|n} p(d)=q(n)</script><p>这东西，知道 $q$ 之后是可以很容易地容斥出 $p$ 的。那么也就是说可以很容易地得到 $f’(k)\zeta(k)$ 。那么同时由于知道了 $f(k)=k^{c-d}$ ，是很容易直接容斥出 $f’(k)$ 的。也就是现在 $\zeta$ 变成了已知。</p><p>考虑如何从 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 反推出 $z_j$ 来，发现本质上是这样的：</p><script type="math/tex; mode=display">\zeta(d)=\sum_{d|j} h(j)z_j</script><p>根据莫比乌斯反演的另一种形式</p><script type="math/tex; mode=display">F(n)=\sum_{n | d} f(d)\Longrightarrow f(n)=\sum_{n | d} \mu\left(\frac{d}{n}\right) F(d)</script><p>反演一下变成</p><script type="math/tex; mode=display">h(d)z_d=\sum_{d|j} \mu(\frac{j}{d})\zeta_j</script><p>然后就可以直接做了。</p><p>注意到以上每个推完的式子，求的时候都是 $nH(n)$ 的复杂度，$O(n\ln n)$ 。</p><p>神题神题，可能这是我接触过的最像莫比乌斯反演的莫比乌斯题。并且把反演的容斥作用很好地诠释了出来。</p><p>还有注意无解的情况，由于 $0$ 不存在逆元，所以在求逆元的时候需要判一下是否存在「求了0的逆元」这种情况，有就输出无解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> hz[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, c, d ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> zeta[N] ;</span><br><span class="line"><span class="keyword">int</span> fzeta[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a += b ;</span><br><span class="line"><span class="keyword">if</span> (a &gt; P) a -= P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">(a -= b) %= P ;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b += (P - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Linear_s&#123;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ;</span><br><span class="line"><span class="keyword">int</span> mu[N] ;</span><br><span class="line"><span class="keyword">int</span> smu[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ;</span><br><span class="line">vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">fc[i * j].push_back(i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Linear_s ; </span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d &gt;&gt; q ; sieve(n + <span class="number">10</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        g[i] = expow(i, d), f[i] = expow(i, c - d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">            dec(f[i * j], f[i]) ;</span><br><span class="line"><span class="keyword">while</span> (q --)&#123;</span><br><span class="line"><span class="keyword">int</span> hasans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i], hz[i] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">base[i] = (ll)expow(g[i], P - <span class="number">2</span>) * b[i] % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fzeta[i] = base[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">dec(fzeta[i * j], fzeta[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!f[i] &amp;&amp; fzeta[i]) &#123; hasans = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span> (!hasans) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line"><span class="comment">//debug(fzeta, 1, n, '\n') ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            zeta[i] = (ll)fzeta[i] * expow(f[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">                add(hz[i], (mu[j] * zeta[i * j] % P + P) % P) ;</span><br><span class="line"><span class="comment">//debug(zeta, 1, n, '\n') ; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans[i] = (ll)hz[i] * expow(g[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n] ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n ≤ 10^5;c,d ≤ 10^9$ 。&lt;/p&gt;
&lt;p&gt;现有长度为 $n$ 的序列 $b$ 满足 $b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c}  \mathrm{lcm}(i, j)^{d} z_{j}(\bmod 998244353)$ 。&lt;/p&gt;
&lt;p&gt;求 $\{z_n\}$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;草，这真是一道神仙题。钛钛钛钛有趣辣！sto vfk .&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】Mobiüs反演听课笔记</title>
    <link href="https://www.orchidany.cn/2020/03/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/30/莫比乌斯反演听课笔记/</id>
    <published>2020-03-30T10:44:57.000Z</published>
    <updated>2020-04-01T14:37:18.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是莫比乌斯反演这一块的听课笔记，由于记录的太长了<del>(不会的太多了)</del> 所以就分了一下。</p><p>反演好啊，有趣啊，不会啊！</p><a id="more"></a><h1 id="关于-mu-的有趣证明"><a href="#关于-mu-的有趣证明" class="headerlink" title="关于 $\mu$ 的有趣证明"></a>关于 $\mu$ 的有趣证明</h1><p>思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p><p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{d|n}\mu(d)\\ = &\sum_{d|n'}\mu(d)\\= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\= & ~(1+(-1))^k\\= & ~[k=0]\end{aligned}</script><h1 id="瞎反演记录"><a href="#瞎反演记录" class="headerlink" title="瞎反演记录"></a>瞎反演记录</h1><p>那大概使用来热身的。</p><ul><li>反演1</li></ul><script type="math/tex; mode=display">\begin{aligned}&\sum _{i=1}^n\sum_{j=1}^m[i,j]\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) \\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j\end{aligned}</script><ul><li>反演2</li></ul><script type="math/tex; mode=display">\sum [n,i]\\= \sum \frac{n\cdot i}{(n,i)}\\= \sum_{d=1}^n\sum\frac{n\cdot i}{d}\cdot [(n,i)=d]\\= \sum_{d=1}^n n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} i \sum \mu(k)\\= \sum_{d=1}^nn\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\cdot k\cdot \sum_{i=1}^{\lfloor\frac{n}{dk}\rfloor} i</script><h1 id="各种题"><a href="#各种题" class="headerlink" title="各种题"></a>各种题</h1><h2 id="SPOJ-LCMSUM"><a href="#SPOJ-LCMSUM" class="headerlink" title="SPOJ LCMSUM"></a>SPOJ LCMSUM</h2><blockquote><p>求 $\sum _{i=1}^n \mathrm{lcm}(n,i)$ .</p><p>$n\leq 10^6,T\leq 10^5$ </p></blockquote><p>草，这真是个神仙题。考虑 $\rm lcm$ 自然是要转化成</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \operatorname{lcm}(i, n)=\sum_{i=1}^{n} \frac{i\cdot n}{\operatorname{gcd}(i, n)}</script><p>那么考虑快速计算这个东西。一个自然的想法考虑能不能筛，筛就要求必须要是狄利克雷卷积的形似。想要转化过去的话必须是对 $n$ 的因子求和，于是想到要按照 $\gcd $ 分类，那么 $\gcd(n,i)=d$ 的 $i$ 总共有 $\varphi(\frac{n}{d})$ 个。</p><p>但是注意到分类之后，由于每一项都带有 $i$ 所以无法快速计算。考虑一个性质，$\gcd(n,k)=\gcd(n,n- k)$ 。那么就是：</p><script type="math/tex; mode=display">n\sum_{i=1}^n\frac{i}{\gcd(i,n)}=n\cdot \frac{1}{2}\left(\sum_{i=1}^n\frac{i}{\gcd(i,n)}+\sum_{i=1}^n\frac{n-i}{\gcd(n-i,n)}\right)=\frac{n}{2}\left(\sum_{i=1}^n\frac{i+(n-i)}{\gcd(i,n)}\right)=\frac{n^2}{2}\left(\sum_{i=1}^n\frac{1}{\gcd(i,n)}\right)</script><p>发现后面那一项就可以快速求和了：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \frac{1}{\operatorname{gcd}(i, n)}=\sum_{d|n} \frac{\varphi(\frac{n}{d})}{d}</script><p>那么答案就是</p><script type="math/tex; mode=display">\frac{n}{2}\left(\sum_{d|n} \frac{n\cdot\varphi(\frac{n}{d})}{d}\right)=\frac{n}{2}\left(\sum_{d|n} d\cdot\varphi(d)\right)</script><p>就可以快速筛出来了。复杂度 $O(n)-O(1)$ 。</p><h2 id="HDU-4944"><a href="#HDU-4944" class="headerlink" title="HDU 4944"></a>HDU 4944</h2><blockquote><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}</script><p>$n,T\leq 5\times 10^5$</p></blockquote><p>首先看到 $d$ 知道要提出来</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}\\=&\sum_{i=1}^{n} \sum_{j=i}^{n} \mathrm{lcm}(i,j)\sum_{d|i,d|j}d\\=&\sum_{d=1}^{n}d^2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=i}^{\lfloor\frac{n}{d}\rfloor} \mathrm{lcm}(i,j)\end{aligned}</script><p>发现对于 $f(n)=\sum_{i=1}^n\sum_{j=i}^n \mathrm{lcm}(i,j)$ 可以转化成</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^i \mathrm{lcm}(i,j)</script><p> 也就是上面LCMSUM里面求得的东西。于是就可以整除分块做了。复杂度 $O(n+T\sqrt n)$ 。</p><p>注意到，预处理的时候还可以计算每个 $d$ 对于每个 $n$ 的贡献。具体一点，考虑本质上对于每个 $n$，$d$ 的贡献都是 $d^{2} f\left(\left\lfloor\frac{n}{d}\right\rfloor\right)$ ，至多有 $\left\lfloor\frac{n}{d}\right\rfloor$ 种不同的取值，且每个取值对应的 $n$ 的区间是连续的。于是就用一些差分技巧差分一下这个修改。注意到这个的复杂度是调和级数的，所以总复杂度 $O(n\ln n)-O(1)$ 。</p><p>其实这里还有一点题，但是因为觉得很有趣就单拿出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是莫比乌斯反演这一块的听课笔记，由于记录的太长了&lt;del&gt;(不会的太多了)&lt;/del&gt; 所以就分了一下。&lt;/p&gt;
&lt;p&gt;反演好啊，有趣啊，不会啊！&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】同余</title>
    <link href="https://www.orchidany.cn/2020/03/29/%E6%95%B0%E8%AE%BA%E5%90%8C%E4%BD%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/29/数论同余学习笔记/</id>
    <published>2020-03-29T02:09:56.000Z</published>
    <updated>2020-04-02T14:17:02.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发现当年学数论，4-6那本书第二三章基本上就是没学会，于是今天打算重学一遍。</p><p>发现还是很有意思的。并且发现读过的MO📚越多，这种东西就越好理解。</p><p>嗯，寓快于慢，藏巧于拙。</p><a id="more"></a><p>先定义一下解的「本质相同」：通常认为在模 $m$ 意义下的同余方程中 $x$ 和 $x+km(k\in\mathbb{Z_+})$ 是本质相同的。 </p><h1 id="同余的基本性质"><a href="#同余的基本性质" class="headerlink" title="同余的基本性质"></a>同余的基本性质</h1><p>1.</p><blockquote><p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p></blockquote><script type="math/tex; mode=display">ac\equiv bc\pmod m\Longrightarrow m|c(a-b)\Longrightarrow \frac{m}{d}|\frac{c}{d}(a-b)</script><p>因为 $(\frac{m}{d},\frac{c}{d})=1$ ，所以 $\frac{m}{d}|(a-b)$ 。</p><p>2、</p><blockquote><p>若给定 $m_i(i=1,2,3\cdots)$ ，且 $\forall i$ 有 $a\equiv b\pmod {m_i}$，则有</p><script type="math/tex; mode=display">a\equiv b\pmod {[m_1,m_2,m_3\cdots ]}</script></blockquote><p>由 $\forall i,m_i|(a-b)$ 可知 $(a-b)$ 是 $m_1,m_2,m_3\cdots$ 的一个公倍数。所以 ${[m_1,m_2,m_3\cdots ]} |(a-b)$ 。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、证明</p><blockquote><p> $11$ 整除 $a$ 的充分必要条件是 $a$ 写成十进制表示后，从低位到高位，奇数位数字和减去偶数位数字和内被 $11$ 整除。</p></blockquote><p>我也不知道有啥好方法，编了一会儿觉得似乎 $100$ 进制的证法比较简单。就是考虑写成百进制的话会是这样：</p><script type="math/tex; mode=display">\sum _{i=1}^ka_{i}100^{k-1}\equiv 0\pmod {11}</script><p>发现 $100 \bmod 11$ 是 $1$ ，就很快乐：</p><script type="math/tex; mode=display">\sum_{i=1}^ka_i\equiv 0\pmod {11}</script><p>然后考虑百进制转10进制，发现有</p><script type="math/tex; mode=display">a_{i}=b^{2i-1}+10\cdot b^{2i}</script><p>那么考虑 $10$ 在 $\pmod {11}$ 时等价于 $-1$ ，于是就可以知道</p><script type="math/tex; mode=display">\sum_{i=1}^ka_i=\sum_{i=1}^k(b^{2i-1}- b^{2i})\equiv 0 \pmod {11}</script><p>于是得证。</p><p>2、证明</p><blockquote><p>$7/11/13$ 整除 $a$ 的充分必要条件是，最后三位数字与删去最后三位以后组成的数，所作之差被 $7/11/13$ 整除。</p></blockquote><p>证明方法差不多？设后三位组成的数是 $b$ ，删去最后三位以后组成的数是 $c$ ，那么有</p><script type="math/tex; mode=display">a=b+c\times 1000</script><p>若</p><script type="math/tex; mode=display">a\equiv 0\pmod k</script><p>那么一定有</p><script type="math/tex; mode=display">b+c\times (1000\bmod k)\equiv 0\pmod k</script><p>考虑 $1001=7\times 11\times 13$ ，所以可以知道 $1000 \bmod k\equiv -1 \pmod k$ 。于是得证。</p><h1 id="剩余类相关理论"><a href="#剩余类相关理论" class="headerlink" title="剩余类相关理论"></a>剩余类相关理论</h1><p>草，我是真觉得抽代入完门再来学这个比较合适。</p><p>于是因为内容太多了我就另开了一篇，想不到了吧？<del>机智如我</del></p><h1 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h1><blockquote><p>形如</p><script type="math/tex; mode=display">ax\equiv b\pmod m\qquad (1)</script><p>的方程。</p></blockquote><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote><p>若 $(a,m)=1$ ，则该式只有 $1$ 解。</p></blockquote><p>这是不难理解的。因为可以知道 $(1,2,3,\cdots m)$ 构成了模 $m$ 的一个完全剩余系，同时 $(a,2\cdot a,3\cdot a\cdots m\cdot a)$ 同样构成了模 $m$ 的一个完全剩余系。那么显然恰好一个整数使得 $aq\equiv b\pmod m$ . 所以解唯一。</p><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote><p>(2.1) 若记 $(a,m)=d$ ，且 $d|b$ ，那么(1)式存在解。</p><p>(2.2) 在(2.1)的假设下，若(1)式存在解，那么解的个数为 $d$ 个。</p></blockquote><p>首先不难知道(1)等价于 $ax+my=b$ 这个不定方程。那么(2.1)是显然的。</p><p>对于(2.2)，考虑将(1)转化成</p><script type="math/tex; mode=display">\begin{aligned}\frac{a}{d}x+\frac{m}{d}y&=\frac{b}{d}\\\frac{a}{d}x&\equiv\frac{b}{d}\pmod {\frac{m}{d}}\qquad (2)\\\end{aligned}</script><p>可知(1)和(2)的解是相同的。由定理1，且 $(\frac{a}{(a,m)},\frac{m}{(a,m)})=1$ 可知(2)的解是唯一的，设为 $t_0$</p><script type="math/tex; mode=display">x_0\equiv t_0\pmod{\frac{m}{d}}</script><p>可知一定有 $0\leq t_0&lt;\frac{m}{d}$ 。</p><p>因此(1)的全部解一定都是 $t_0+k\frac{m}{d} (k\in \mathbb{Z_+})$ 的形式。考虑 $k=0,1,2\cdots d-1$ 的时候，有</p><script type="math/tex; mode=display">t_0+k\frac{m}{d}<\frac{m}{d}</script><p>且由于其单调性可知这几个解互异。因此这 $d$ 个数在模 $m$ 下不同余。（证明了解至少有 $d$ 个）</p><p>另一方面，对(1)的任意一解 $t_0+k_0\frac{m}{d}$ ，令 $k_0=qd+r,0\leq r&lt;d$ 代入得：</p><script type="math/tex; mode=display">t_0+k_0\frac{m}{d}\equiv t_0+(qd+r)\frac{m}{d}\equiv t_0+r\frac{m}{d} \pmod m</script><p>可知对于每个 $k_0$，均与某个 $0\leq k&lt;d$ 时的解本质相同。（证明了解至多有 $d$ 个）。</p><p>因此，该式共有恰好 $d$ 个解。</p><h2 id="一般解法技巧"><a href="#一般解法技巧" class="headerlink" title="一般解法技巧"></a>一般解法技巧</h2><p>有两种常用的技巧，都是基于将 $ax\equiv b\pmod m$ 转化为形式分式 $x\equiv \frac{b}{a}\pmod m$ 的基础上： </p><blockquote><p>1、分子分母同乘一个与 $m$ 互质的数。</p><p>2、当 $(a,m)=1$ 时，分子可以加上 $m$ 的倍数。</p></blockquote><p>注意到，限制「与 $m$ 互质」的目的是为了保证形式分式有意义，即只有 $(a,m)=1$，$a$ 在模 $m$ 意义下的逆元才有意义。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一道毒瘤题</p><blockquote><p> 设 $p$ 为奇素数，$1&lt;a&lt;p$，则 $ax\equiv b\pmod p$ 的解为</p><script type="math/tex; mode=display">x\equiv b (-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\pmod p</script></blockquote><p>考虑把 $(-1)^{a-1}$ 乘到上面的括号里去</p><script type="math/tex; mode=display">\begin{aligned}&(-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\\ \equiv&\frac{(1-p)(2-p)\cdots (a-1-p)}{a!}\\\equiv&\frac{(1)\cdot (2)\cdots (a-1)}{a!} \equiv\frac{1}{a}\pmod p\end{aligned}</script><p>然后就证完了。毒瘤就毒瘤在…我太不会…/dk</p><p>个人认为写成这样帅一点</p><script type="math/tex; mode=display">x\equiv b (-1)^{a-1} \binom{p}{a}\pmod p</script><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><blockquote><p>若 $m_1,m_2\cdots m_k$ 为两两互素的正整数，记 $M=\prod m$ ，$r_i=\frac{M}{m_i}$ ，则一次同余方程</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}x \equiv a_{1} & \left(\bmod m_{1}\right) \\x \equiv a_{2} & \left(\bmod m_{2}\right) \\\vdots \\x \equiv a_{k} & \left(\bmod m_{k}\right)\end{array}\right.</script><p>有唯一解 $x\equiv t$ ，且</p><script type="math/tex; mode=display">t\equiv\sum _{i=1}^ka_ir_iq_i\pmod M</script><p>其中 $q_i=\frac{1}{r_i}\pmod {m_i}$ 。</p></blockquote><p><del>好难背啊</del></p><p>不过构造方式是很有趣的。大概就是考虑类似拉格朗日插值的构造方法，要找一堆 $\zeta_i$ 满足：</p><script type="math/tex; mode=display">\zeta_i\equiv\left\{\begin{array}{cc}1\pmod {m_j},\qquad j=i\\0\pmod {m_j},\qquad j\not=i\\\end{array}\right.</script><p>则可取</p><script type="math/tex; mode=display">x_0=\sum_{i=1}^k\zeta_ia_i</script><p>作为一组解。那么显然据此构造的方案满足这个条件。</p><p>另一方面，对于另一个解 $x_1$ 有</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}x_0 \equiv x_{1} & \left(\bmod m_{1}\right) \\x_0 \equiv x_{1} & \left(\bmod m_{2}\right) \\\vdots \\x_0 \equiv x_{1} & \left(\bmod m_{k}\right)\end{array}\right.</script><p>由于 $m_1,m_2\cdots m_k$ 两两互素，可知 $x_1\equiv x_0\pmod M$。即全部的解都可以表示成</p><script type="math/tex; mode=display">x\equiv x_0\pmod M</script><p>​                                                                              </p><h1 id="exCRT"><a href="#exCRT" class="headerlink" title="exCRT"></a>exCRT</h1><blockquote><p>大概就是给出的 $m_i$ 不再互质的情况。</p></blockquote><p>考虑此时普通的crt会出现什么问题。在 $m_i$ 彼此互质的情况下，可以知道 $r_i=\frac{M}{m_i}$ 保证 $(m_i,r_i)=1$，那也就保证了 $r_i$ 在模 $m_i$ 意义下存在逆元。但是当 $(m_i,r_i)&gt;1$ 时，$q_i$ 就没有意义了。</p><p>考虑增量法。一开始有两个方程</p><script type="math/tex; mode=display">x\equiv a\pmod b\\x\equiv c\pmod d \\</script><p>那么有 $bt+a≡c \pmod d$ 用 exgcd 解出 $t≡t_0 \pmod{\frac{d}{(b,d)}}$</p><p>代回得 $x ≡ x_0 \pmod{[b, d]} $。这样迭代做下去就好了。感觉写这种代码还是要把变量分清，尽量写的清楚、松散一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll A[N] ;</span><br><span class="line">ll m[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">    ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">    x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(res += a) %= mod ;</span><br><span class="line">(a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res, mod ;</span><br><span class="line">    ll a, b, c, d, M ;</span><br><span class="line">    ll x, y, t0, t, g, z ;</span><br><span class="line">    res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        a = res, b = mod ;</span><br><span class="line">        c = A[i], d = m[i] ;</span><br><span class="line">        g = exgcd(x, y, b, d) ;</span><br><span class="line">z = ((c - a) % d + d) % d ;</span><br><span class="line">M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">        res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; m[i] &gt;&gt; A[i] ;</span><br><span class="line">    ll op = excrt() ; <span class="keyword">if</span> (op &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"hahaha"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; op ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="神奇的例题"><a href="#神奇的例题" class="headerlink" title="神奇的例题"></a>神奇的例题</h1><h2 id="CF338D"><a href="#CF338D" class="headerlink" title="CF338D"></a>CF338D</h2><blockquote><p>给出一个 $n × m$ 的数表, 其中第 $i$ 行第 $j$ 个数是 $\gcd(i, j)$，再给定一个长度为 $k$ 的数列 $\{a_n\}$, 判断其是否在数表的某一行出现过。</p><p>$n,m ≤ 10^{12},k ≤ 10^4$</p></blockquote><p>一道有意思的题。考虑由于是要去寻找一行，所以行号是固定的。那么必须要有 $\mathrm{lcm}(a_1,a_2\cdots a_k)|x$ 。</p><p>考虑是否可以选用 $x=\mathrm{lcm}(a_1,a_2\cdots a_k)$ 做答案。注意到如果 $x=p\cdot \mathrm{lcm}(a_1,a_2\cdots a_k)$ 可行，那么一定有</p><script type="math/tex; mode=display">\gcd(p,y) = 1</script><p>那么发现，对于 $p$ 的任意一个因子，都满足该性质。所以取 $p=1$ 完全没有问题。</p><p>之后考虑去检验 $y$ 的合法性。令第一个元素之前的那个元素(跟答案没关系的)为 $(x,y)$ 。发现 $y$ 需要满足</p><script type="math/tex; mode=display">\gcd(y+1,x)=a_1,\gcd(y+2,x)=a_2,\gcd(y+3,x)=a_3\cdots</script><p>注意到 $x$ 是所有 $a_i$ 的 $\rm lcm$ 。那么可以知道 $y+i$ 一定需要是 $a_i$ 的倍数，也就是</p><script type="math/tex; mode=display">\left\{\begin{array}{l}y+1\equiv 0\left(\bmod a_{1}\right) \\y+2\equiv 0\left(\bmod a_{2}\right) \\\vdots \\y+k\equiv 0\left(\bmod a_{k}\right)\end{array}\right.</script><p>那么用 excrt 求出这个 $y$ 来即可。需要注意的是，这样并不代表 $y$ 合法，因为 $y+i$ 是 $a_i$ 的倍数等价于 $\gcd(y+i,x)=a_i\cdot q$ 。 所以为了验证是否合法，需要再从头判一遍。</p><p>注意到如果此时不存在答案，那么也一定不存在其他的答案。这一点是比较显然的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N] ;</span><br><span class="line">    ll m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">    (res += a) %= mod ;</span><br><span class="line">    (a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">    z = ((c - a) % d + d) % d ;</span><br><span class="line">    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Sunzi ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k ; ll t = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), m[i] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) A[i] = -i ; lcm = m[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">t = m[i] * lcm, lcm = __gcd(lcm, m[i]), lcm = t / lcm  ;</span><br><span class="line"><span class="keyword">if</span> (lcm &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; lcm &lt;&lt; " " &lt;&lt; t &lt;&lt; endl ; </span></span><br><span class="line">    t = excrt() ; <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = t + <span class="number">1</span> ; i &lt;= t + k ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (__gcd(i, lcm) != base[i - t]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t + k &lt;= p) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>), <span class="number">0</span> ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现当年学数论，4-6那本书第二三章基本上就是没学会，于是今天打算重学一遍。&lt;/p&gt;
&lt;p&gt;发现还是很有意思的。并且发现读过的MO📚越多，这种东西就越好理解。&lt;/p&gt;
&lt;p&gt;嗯，寓快于慢，藏巧于拙。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】数论听课笔记</title>
    <link href="https://www.orchidany.cn/2020/03/28/%E6%95%B0%E8%AE%BA%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/28/数论听课笔记/</id>
    <published>2020-03-28T14:29:00.000Z</published>
    <updated>2020-03-30T13:24:17.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听斯给普讲的有趣的数论问题，感觉海星？</p><p>顺便加上了一点自己之前随便整理的东西。</p><a id="more"></a><h1 id="瞎整理系列"><a href="#瞎整理系列" class="headerlink" title="瞎整理系列"></a>瞎整理系列</h1><h2 id="gcd-的实现"><a href="#gcd-的实现" class="headerlink" title="gcd 的实现"></a>gcd 的实现</h2><h3 id="一个必要的式子"><a href="#一个必要的式子" class="headerlink" title="一个必要的式子"></a>一个必要的式子</h3><blockquote><p> $a\geq b\to (a,b)=(b,a \bmod ~b)$</p></blockquote><p>令$a=bp+q~(0\leq 1&lt;b)$ 。若 $\exists d|a,d|b$，则有 $da’=db’p+q$，移项得 $q=d(a’-b’p)$，故$d|q\Longrightarrow d|(a\bmod~b)$。</p><p>考虑最后，$b’=0$，此时有$a’=q$，又因为 $\forall d$ 满足 $d|a,d|b$, $\exists d|q\to d|a’$，即此时$a’$是所有因子的倍数，故 $a’$ 为最大公因数。</p><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>考虑分类讨论，不妨令 $a&gt;b$.</p><ul><li>当 $\frac{a}{2}&gt;b$ 时，有 $a\bmod b&lt;b&lt;\frac{a}{2}$</li><li>当 $\frac{a}{2}\leq b$ 时，有 $a\bmod ~b=a-b&lt;\frac{a}{2}$</li></ul><p>所以复杂度是 $\log(\max(a,b))$ 的。</p><h2 id="exgcd-的实现"><a href="#exgcd-的实现" class="headerlink" title="exgcd 的实现"></a>exgcd 的实现</h2><p>考虑丢番图方程 $ax+by=(a,b)$ 。</p><p>发现迭代到 $x=1,y=0$ 时，上式依旧成立。</p><p>同时，有 $bx+y\cdot (a\bmod ~b)=(a,b)$ ，化简：</p><script type="math/tex; mode=display">\begin{aligned}bx+y\cdot (a-b\cdot \lfloor \frac{a}{b}\rfloor)&= (a,b)\\ay+b(x-y\cdot \lfloor \frac{a}{b}\rfloor) &=(a,b)\end{aligned}</script><p>按照这种形式向上递归后，就会少一层$\bmod$ 然后就没有然后了。 </p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><blockquote><p>使得</p><script type="math/tex; mode=display">a^x\equiv 1(\bmod p)</script><p>的最小的 $x$ 称为 $a$ 关于 $p$ 的<strong>阶</strong>。</p></blockquote><p>那么有结论 $x|\varphi(p)$ 。</p><p>考虑反证法。因为</p><script type="math/tex; mode=display">a^x\equiv 1(\bmod p)\\a^{\varphi(p)} \equiv 1(\bmod p)</script><p>且 $x$ 最小，又因为假设 $x$ 不是 $\varphi(p)$ 的约数，故 $x&lt;\varphi(p)$ 。</p><p>那么会有不妨令 $\varphi(p)\equiv kx+q(0\leq q&lt;x)$ ，则有</p><script type="math/tex; mode=display">\begin{aligned}\frac{a^{\varphi(p)}}{(a^{x})^k}& \equiv a^q\\&\equiv 1(\bmod p)\end{aligned}</script><p>但这显然不合理，因为 $x&gt;q$ 但根据定义 $x$ 应该是最小的满足 $a^o\equiv 1(\bmod p)$ 的数，QED。</p><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><blockquote><p>对于素数 $p$，有</p><script type="math/tex; mode=display">(p-1)!\equiv -1 (\bmod p)</script></blockquote><p>证明大概就是考虑，在$2,3,…,n-3,n-2$中，每个数有且仅有一个逆元，不会 $\geq p$ 且唯一，所以会互相抵消。</p><h1 id="exgcd的应用"><a href="#exgcd的应用" class="headerlink" title="exgcd的应用"></a>exgcd的应用</h1><h2 id="类欧几里得问题"><a href="#类欧几里得问题" class="headerlink" title="类欧几里得问题"></a>类欧几里得问题</h2><script type="math/tex; mode=display">\sum_{x=1}^{n}\lfloor \frac{ax+b}{c}\rfloor</script><p>发现其实本质上求的是一条直线在 $x$ 正半轴和 $y$ 的正半轴的整点数量。那么考虑对于矩形区域可以随便求，对于三角形区域，可以让 $a$ 对 $c$ 取模之后依旧不影响结果，所以考虑沿着 $y=x$ 对称，那么会使得 $\frac{a}{c}$ 变成 $\frac{c}{a}$ ，这样就可以达到一个辗转相除的效果，复杂度 $\log n$ 。</p><h2 id="杂题1"><a href="#杂题1" class="headerlink" title="杂题1"></a>杂题1</h2><p>已知 $a_x=a_{x-1}+a_{x-2}$ ，给定 $a_1$, 求有多少个 $a_2\in[l,r]$ 使得 $a_k=b~(\bmod p)$. $k,p=O(10^9)$ 。</p><p>发现最后的 $a_k$ 一定可以写成 $ca_1+da_2=a_k=b(\mod p)$ ，然后就转化成一个瞎 $exgcd$ 问题了。</p><h1 id="多项式复合"><a href="#多项式复合" class="headerlink" title="多项式复合"></a>多项式复合</h1><blockquote><p> 已知 $f(x), g(x)$，求 $f(g(x))\mod x^n$ ，$1\leq n,m\leq 4000$。</p></blockquote><p>因为</p><script type="math/tex; mode=display">f(g(x))=\sum_{i=0}^{n} f_{i} g(x)^{i}</script><p>于是考虑预处理 $g(x),g^2(x)\cdots g^p(x)$ ，和 $g^{2p}(x),g^{3p}(x)\cdots$ 这样，每块先对 $f_{i+kp}g(x)^i$ 求和再做多项式乘法。</p><p>最后复杂度就是 $O(nm+\sqrt mn\log n)$</p><h1 id="Stern-brocot-Tree"><a href="#Stern-brocot-Tree" class="headerlink" title="Stern-brocot Tree"></a>Stern-brocot Tree</h1><p>大概是把 $\frac{0}{1}$ 和 $\frac{1}{0}$ 当做两个虚根。然后每次在两个点 $\frac{n}{m}$ 和 $\frac{n’}{m’}$ 中间插入一个 $\frac{n’+n}{m’+m}$ 。之后大概是这样的：</p><p><img src="1.png" alt></p><blockquote><p>bzoj 2852</p><p>给两个有理数 $a,b$，求最小的正整数 $k$, 使得 $(ak,bk)$ 里有整数。</p><p>$a$, $b$ 整数部分不超过 $2^{31}$ , 小数位数不超过 $300$ 位。</p></blockquote><p>发现 $(a,b)$ 的答案和 $(a-1,b-1)$ 的答案一样。所以考虑将 $(ak,bk)$ 移动到 $[0,1)$ 这个区间。此时如果 $b\geq 1$ 或者 $a=0$ 那么就可以找 $0/1$ 。否则就变成了解这样一个不等式：</p><script type="math/tex; mode=display">a \times k \leq t \leq b \times k</script><p>也就是</p><script type="math/tex; mode=display">a \leq \frac{t}{k} \leq b</script><p>那么就是找一个分母最小的夹在 $a,b$ 之间的分数。并且由于 $b&lt;1$ 所以一定是个真分数。那么就可以在stern-brocot Tree树上找LCA即可。</p><p>这个地方似乎是不用真的建出来树，因为存在某种神秘的树上二分方式，十分高妙。</p><h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><script type="math/tex; mode=display">\left(\begin{array}{l}n \\m\end{array}\right) \equiv\left(\begin{array}{l}n \bmod p \\m \bmod p\end{array}\right) \times\left(\begin{array}{l}\left\lfloor\frac{n}{p}\right\rfloor \\\left\lfloor\frac{m}{p}\right\rfloor\end{array}\right) \quad(\bmod p)</script><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>今天重学了一遍，发现证明好简单？</p><p>对于 $p$ 是质数而言，根据费马小定理一定有</p><script type="math/tex; mode=display">(1+x)^p\equiv (1+x) \pmod p</script><p>和</p><script type="math/tex; mode=display">x\equiv x^p  \pmod p</script><p>所以有</p><script type="math/tex; mode=display">(1+x)^p\equiv 1+x^p \pmod p</script><p>如果设 $n=sp+t,~0\leq t&lt;p$ 。那么就有</p><script type="math/tex; mode=display">\begin{aligned}(1+x)^n\equiv &(1+x)^{sp+t}\\\equiv &(1+x)^{sp}\cdot (1+x)^t\\\equiv &(1+x^p)^s\cdot (1+x)^t\\\equiv &(1+x^p)^{\left\lfloor\frac{n}{p}\right\rfloor}\cdot (1+x)^{x\bmod p}\end{aligned}\pmod p</script><p>考虑两边都暴力二项式展开</p><script type="math/tex; mode=display">\sum_{i=0}^n\binom{n}{i}x^i=\left(\sum_{j=0}^{\left\lfloor\frac{n}{p}\right\rfloor}\binom{n}{j}x^{j\cdot p}\right)\times \left(\sum_{k=0}^{n\bmod p}\binom{n}{k}x^{k}\right)\pmod p</script><p>观察右边。发现因为后面那个括号里 $x$ 的次数 $&lt;p$，前面一个括号内 $x$ 的次数一定是 $p$ 的倍数 。所以对于每个 $i$ ，都有唯一的 $j\cdot p+k=i$ （带余除法的唯一性）。所以可知</p><script type="math/tex; mode=display">\left(\begin{array}{l}n\\m\end{array}\right) \equiv\left(\begin{array}{l}n \bmod p \\m \bmod p\end{array}\right) \times\left(\begin{array}{l}\left\lfloor\frac{n}{p}\right\rfloor \\\left\lfloor\frac{m}{p}\right\rfloor\end{array}\right) \quad(\bmod p)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line">ll ans, tn, tm, tp, fac[N], inv[N] ;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= a) %= mod ;</span><br><span class="line">(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">tn = x ; tm = y ; tp = z ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ; </span><br><span class="line"><span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lucas</span><span class="params">()</span></span>&#123;</span><br><span class="line">my_assign(n + m, n, p) ; </span><br><span class="line">pre_do(tp - <span class="number">1</span>) ; ans = do_do(tn, tm) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道的是，Lucas定理还有另一种表示方式。如果把 $m,n$ 都看作 $p$ 进制数的话，即</p><script type="math/tex; mode=display">m=(\overline{m_1m_2\cdots m_k})_p\\n=(\overline{n_1n_2n_3\cdots n_k})_p</script><p>那么有</p><script type="math/tex; mode=display">\binom{n}{m}\equiv\prod _{i=1}^k \binom{n_i}{m_i} \pmod p</script><p>其实不难理解，可以联想十进制数拆分出每一位的过程，也是 $\bmod 10$ 之后再除以 $10$ 。</p><h2 id="例题：古代猪文"><a href="#例题：古代猪文" class="headerlink" title="例题：古代猪文"></a>例题：古代猪文</h2><blockquote><p>求 $g^\sum\textstyle_{d|n}\binom{n}{d}\bmod 999911659$ 。</p></blockquote><p>发现 $999911658=2\times 3\times 4679\times 35617$ ，然后分别做 Lucas 再拿crt合并起来就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">999911659</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000110</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line">ll ans ;</span><br><span class="line">    ll tp, tn, tm ;</span><br><span class="line">    ll fac[N], inv[N] ;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= a) %= mod ;</span><br><span class="line">(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">tn = x ; tm = y ; tp = z ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ;</span><br><span class="line"><span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">        my_assign(x, y, z) ;</span><br><span class="line">        ans = do_do(tn, tm) ; <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N], m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">    (res += a) %= mod ;</span><br><span class="line">    (a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> pn)</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= pn ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">    z = ((c - a) % d + d) % d ;</span><br><span class="line">    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll n, g ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line">ll p[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; g ;</span><br><span class="line">    <span class="keyword">if</span> (g % P == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="built_in">sqrt</span>(n) ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) base[++ cnt] = i ;</span><br><span class="line">    <span class="keyword">int</span> t = cnt ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n / base[i] &gt; <span class="built_in">sqrt</span>(n))</span><br><span class="line">            base[++ cnt] = n / base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)&#123;</span><br><span class="line">        Lucas_T :: tp = p[i] ;</span><br><span class="line">Lucas_T :: pre_do(p[i] - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">            (res[i] += Lucas_T :: Lucas(n, base[j], p[i])) %= (P - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)</span><br><span class="line">        Sunzi :: A[i + <span class="number">1</span>] = res[i], Sunzi :: m[i + <span class="number">1</span>] = p[i] ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Lucas_T :: expow(g, Sunzi :: excrt(<span class="number">4</span>), P) &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：组合数问题"><a href="#例题：组合数问题" class="headerlink" title="例题：组合数问题"></a>例题：组合数问题</h2><blockquote><p>求 $0≤j≤i≤n$ 且 $j≤m$ 的数对 $(i,j)$ 里有多少满足 $\binom{i}{j}≡0 \pmod p$</p><p>$T ≤ 100,n,m ≤ 10^{18},p ≤ 100$ 且是一个质数.</p></blockquote><p>根据上面那个性质，只要 $p$ 进制下 $i$ 的任何一位 $&lt;j$ 就 $\equiv 0$ 。然后就直接数位dp就完了。</p><h2 id="小-Q-的集合"><a href="#小-Q-的集合" class="headerlink" title="小 Q 的集合"></a>小 Q 的集合</h2><blockquote><p>求从 $n$ 元集合 $\rm S$ 中随机选择一个子集 $\rm T$ 。求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的方差。</p><p>$n≤10^{10^6},k≤10$，答案对质数 $m≤10^6$ 取模。</p></blockquote><p>嗯，学习了一下方差的定义。记这个东西的期望是 $E(x)$ ，那么方差就是 $E([x-E(x)]^2)=E(x^2)-E^2(x)$。</p><p>嗯，得出结论，概率论这一套是学不懂的。</p><p>说做法吧。根据期望的线性性，可以得到这个东西的期望是</p><script type="math/tex; mode=display">E(|\mathrm{S−T}|^k −|\mathrm{T}|^k)= E(|\mathrm{S−T}|^k)-E(|\mathrm{T}|^k)</script><p>那么显然这两项是对称的，所以这个东西的期望就是 $0$ 。所以就只需要求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的平方的期望就可以了。那么答案也就是</p><script type="math/tex; mode=display">\frac{\sum\limits_{i=0}^{n}\binom{n}{i}\left(i^{k}-(n-i)^{k}\right)^{2}}{2^n}</script><p>emmm然而并不可以直接做。然后有个很神仙的点就是考虑拿Lucas定理来展开一层得到：</p><script type="math/tex; mode=display">\sum_{i=0}^{\lfloor \frac{n}{m}\rfloor}\left(\begin{array}{c}\left\lfloor\frac{n}{m}\right\rfloor \\i\end{array}\right) \sum_{j=0}^{n \bmod m}\left(\begin{array}{c}n \bmod m \\j\end{array}\right)\left(j^{k}-(n-j)^{k}\right)^{2}</script><p>这么做是对的就在于每个 $\binom{n}{j}$ 都被分解成了唯一的 $\binom{\lfloor \frac{n}{m}\rfloor}{i}\cdot \binom{n\bmod m}{j}$ ，那么这两部分就可以<strong>分别算了</strong>。第一部分很显然就是 $2^n$ ，第二部分直接做就可以了。</p><p>嗯，这题真是十分高妙。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数论有意思！</p><p>exLucas是不可能学的…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听斯给普讲的有趣的数论问题，感觉海星？&lt;/p&gt;
&lt;p&gt;顺便加上了一点自己之前随便整理的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/扩展欧几里德" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/阶与原根" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%98%B6%E4%B8%8E%E5%8E%9F%E6%A0%B9/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】带权二分(wqs二分)</title>
    <link href="https://www.orchidany.cn/2020/03/25/%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
    <id>https://www.orchidany.cn/2020/03/25/带权二分/</id>
    <published>2020-03-25T13:13:27.000Z</published>
    <updated>2020-04-08T03:13:56.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个东西大概好早就想学了，但是一直没学。这次就认真学一下吧。</p><a id="more"></a><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>当题目给了一个选物品的限制条件，要求刚好选 $m$ 个，要求最大化/最小化权值，然后其特点就是当选的物品越多的时候权值越大(越小)。</p><p><del>然后大概这个凸性一般都是靠猜的</del></p><p>考虑去二分一个 $w$，表示选一个满足限制的物品时附加的权值，如果 $w$ 越大，那么选的物品个数就会越多/越少，权值越大/小。考虑当这个函数是凸的时候，于是当选的物品个数大于 $m$ 时，减小 $w$，否则增大 $w$，最后计算答案的时候去掉 $w$ 值的影响即可。</p><p>考虑这么做的原理。如果设 $f(x)$ 表示选了 $x$ 个满足限制的物品时的最优解。那么根据凸性，$f(x)$ 随着 $x$ 的增大，斜率单调，所以一定会是一个下凸壳或者上凸壳。但问题就在于唯一知道的信息只是其凸性，无法求出 $f(m)$ 的准确值。</p><p>考虑凸壳的一个特点。假设这个凸壳是光滑的，那么对于每个斜率 $k$ ，凸壳上一定存在一点与某条该斜率的直线相切。同时假设斜率为 $k$ 但不限制截距的直线 $l$ 与该凸壳有交时，截距的极值一定是取到 $l$ 与凸壳相切的时候。</p><p>记截距为 $b$ 。可知有 $b=f(x) - kx$ 。考虑构造这个式子中 $b$ 的含义，发现本质上等价于每选一个物品，$f(x)$ 就要减掉 $k$ ，最终选了 $x$ 个物品，总答案就要减小 $kx$ 。 所以考虑如果把所有物品的权值一开始就减掉 $k$，那么当 $f(x)$ 最大时，$b$ 也一定最大。所以此时对于某个斜率 $k$，都可以线性或者低次 $poly(\log)$ 求出 $\min\{f(x)\}$ 并且求出决策点 $x$。</p><p>考虑如何加速这个过程。发现在凸的时候，斜率 $k$ 和 $x$ 同时单调，于是考虑二分这个斜率。例如在某个斜率 $k’$ 下选择的物品 $&gt;m$ ，那么就需要让 $x$ 变小，根据 $k$ 和 $x$ 的相对单调关系调整即可。</p><h1 id="12年集训队胡策-Tree-I"><a href="#12年集训队胡策-Tree-I" class="headerlink" title="12年集训队胡策 Tree I"></a>12年集训队胡策 Tree I</h1><blockquote><p>给你⼀个⽆向带权连通图，每条边是⿊⾊或⽩⾊。让你求⼀棵最⼩权的恰好有 $need$ 条⽩⾊边的⽣成树。</p><p>$1\leq n\leq 50000,1\leq m\leq 100000$ 。</p></blockquote><p>发现就是 $wqs$ 二分的裸题。那么考虑直接去二分每条白边加上的权值 $w$ 即可。注意到白边无论 $w$ 是多少，选取时的单调性不变。所以可以利用这个将复杂度从 $m(\log m+\log n) \log V$ 优化到 $m\log n\log v+m\log m $。注意到并查集的 $\log $ 是极小的。</p><p>但值得注意的是，这题构造方案的话并不存在一个很简单的方法。</p><p>还有一点细节需要注意。就是假设存在某几条黑边与加权之后的白边权值相同的话，不能随便选。本质上，优先选黑边和优先选白边都一样。也就是需要规定优先选白边或者优先选黑边，但是两者的处理方式是不同的。如果优先选黑边的话，那么判的时候就要判 $\leq$ ，优先选白边则需要判 $\geq$ 。</p><p>亲测似乎优先选白边会快一点。下面是优先选黑边的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fr ;</span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> clr ;</span><br><span class="line"><span class="keyword">int</span> val ; </span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ; </span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> head[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">to(++ cnt) = y ;  </span><br><span class="line">nxt(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">fr(cnt) = x ; val(cnt) = w ; clr(cnt) = c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge a, Edge b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val == b.val ? a.clr &gt; b.clr : a.val &lt; b.val ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mst</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> re = <span class="number">0</span>, ret = <span class="number">0</span>, y = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!clr(i)) val(i) += x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = find(fr(i)) ;</span><br><span class="line"><span class="keyword">int</span> f2 = find(to(i)) ;</span><br><span class="line"><span class="keyword">if</span> (f1 == f2) <span class="keyword">continue</span> ; </span><br><span class="line">ret += val(i) ; fa[f1] = f2 ;  </span><br><span class="line">re += (clr(i) ^ <span class="number">1</span>) ; ++ y ; </span><br><span class="line"><span class="keyword">if</span> (y == n - <span class="number">1</span>) <span class="keyword">break</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!clr(i)) val(i) -= x ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; re &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">if</span> (re &lt;= k)&#123;</span><br><span class="line">ans = ret - k * x ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w, c ;</span><br><span class="line">ios:: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c, add(++ u, ++ v, w, c) ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>, mid, res ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">if</span> (mst(mid)) r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl ; mst(res) ;</span></span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IOI2000-邮局"><a href="#IOI2000-邮局" class="headerlink" title="IOI2000 邮局"></a>IOI2000 邮局</h1><blockquote><p>⼀条路有 $n$ 个村庄，你要建 $k$ 个邮局，每个村庄到最近邮局距离最小。</p><p>$k\leq 300,n\leq 3000$ 。</p></blockquote><p>这个东西，就显然是 $f_{i,j}$ 记一下，然后放 $k\to i$ 的中点就好了。这样复杂度是 $n^2k$ 的。然后编一下发现有决策单调性，就可以 $O(nk\log n)$ 甚至 $O(nk)$ 了。</p><p>然而这个地方打算记录一下怎么 $wqs$ 做。考虑去优化一下上面那种解法，发现 $k$ 这个限制可以通过wqs二分给消掉，就变成了如果建一次邮局需要额外支付 $mid$ 的代价，但是不限制建的次数时的最短距离和。这个东西就变成了一个1D/1D的 $dp$ ，并且也具有决策单调性。这一部分就可以继续单调栈+二分做到 $n\log V\log n$ </p><p>似乎有什么很优秀的单调队列做法可以做到线性。不过写了写发现似乎二分的常数还是很小的，$n=5\times 10^5$ 也只需要谷 $2.7s$ 、uoj $2s$ 左右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define int long long </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line">ll res ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll sum[N] ;</span><br><span class="line"><span class="keyword">int</span> lrg[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qr(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qr;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="function">il ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    ll h = (l + r + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">    ll ret = sum[r] - sum[h] ;</span><br><span class="line">    ll d1 = <span class="number">1l</span>l * (h - l) * base[h] ;</span><br><span class="line">    ll d2 = <span class="number">1l</span>l * (r - h) * base[h] ;</span><br><span class="line">    <span class="keyword">return</span> ret - d2 + d1 - sum[h] + sum[l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">trans</span><span class="params">(ll p, ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[p] + calc(p, x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    stk[tp = <span class="number">0</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span> ; lrg[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; tp &amp;&amp; lrg[h] &lt; i)</span><br><span class="line">            ++ h ; <span class="keyword">if</span> (lrg[h] &gt; i) -- h ;</span><br><span class="line">        f[i] = trans(stk[h], i) + x, cnt[i] = cnt[stk[h]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; trans(stk[tp], lrg[tp]) &gt;= trans(i, lrg[tp]))</span><br><span class="line">            stk[tp] = <span class="number">0</span>, lrg[tp] = n + <span class="number">1</span>, -- tp ;</span><br><span class="line">        <span class="keyword">int</span> l = lrg[tp], r = n, mid, ans = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (trans(stk[tp], mid) &gt;= trans(i, mid))</span><br><span class="line">                ans = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= n) stk[++ tp] = i, lrg[tp] = ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    res = f[n] - x * m ; <span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n] &lt; m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ; qr(m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qr(base[i]), sum[i] = sum[i - <span class="number">1</span>] + (ll)base[i] ;  </span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, ans ; </span><br><span class="line">    lrg[<span class="number">0</span>] = <span class="number">1</span> ; sum[n + <span class="number">1</span>] = sum[n] ; </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">else</span> ans = mid, l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    check(ans) ; qw(res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IOI2000-邮局-环版本"><a href="#IOI2000-邮局-环版本" class="headerlink" title="IOI2000 邮局(环版本)"></a>IOI2000 邮局(环版本)</h1><blockquote><p>改成环上建 $k$ 个邮局了。数据范围还是不变的。</p></blockquote><p>考虑破环为链的问题在于，$n\to 1$ 那边可能存在没有考虑到的问题，同时由于限制了邮局数量而不能在后面接成 $2n$ 的链。于是比较暴力的方法自然是随机化，随机第一个邮局的位置，那么显然需要随机 $&gt;\frac{n}{k}$ 次，比如 $\frac{n}{k}\log n$ ，这样暴力做的复杂度就变成了  $O(nk\log n)\cdot O(\frac{n}{k}\log n)=O(n^2\log n)$ 。</p><p>考虑更好一点的做法。由于无论是在环上还是在链上，这个模型都满足四边形不等式，所以可以知道，任意两条不同起点的转移路径，一定要么重合，要么有 $k$ 个交点。所以可以随便选一个起点，跑一次dp，构造出转移路径来，假设是 $u_1\to u_2\to u_3\cdots\to u_k$ ，那么随便选择两个端点，比如 $u_p\to u_{p+1}$ ，可知最优解一定有一个转移点在 $u_p\to u_{p+1}$ 之间，那么只需要找到一组间隔最小的作为起点即可（环上的转移路径起点任意）。由于两点之间距离上界是 $O(\frac{n}{k})$ ，所以如果套用链里的 $O(n\log n\log V)$ 的做法，最终复杂度就是 $O(\frac{n^2}{k}\log n\log w)$ ，在 $k$ 很小的时候是不优的。</p><p>…思考了一下，似乎不知道当 $k$ 很小的时候有什么比较精妙的做法，因为无论怎么化，最后复杂度的大头都落在 $n$ 上emmm</p><p>好的吧，直接正解吧。考虑上面说的那个性质，假设最优解的转移路径为 $v_1\to v_2\to v_3\cdots v_k$ ，那么一定有 </p><script type="math/tex; mode=display">u_1\leq v_1<u_2\\u_2\leq v_2 < u_3\\ \cdots \\u_k\leq v_k<u_1+n</script><p>类似这样。那么可以知道类似于每一层找一个决策点，同时也由于决策单调性，只会同时出现在 $mid$ 的同一边，那么最终的决策数是 $\frac{n}{k}\cdot k\cdot \log n=n\log n$ ，再套一层分治，最终复杂度 $O(n\log ^2 n+n\log n\log V) 。$ 。</p><p>一个小细节，就是第一层需要 $&lt;\frac{n}{k}$，这样才能保证决策数。</p><h1 id="LG4983忘情"><a href="#LG4983忘情" class="headerlink" title="LG4983忘情"></a>LG4983忘情</h1><blockquote><p>将一个长为 $n$ 的序列划分成 $m$ 段，每段 $[l,r]$ 的代价是</p><script type="math/tex; mode=display">\frac{\left(\left(\sum_\limits{i=l}^{r} x_{i} \times \bar{x}\right)+\bar{x}\right)^{2}}{\bar{x}^{2}}</script><p>最小化这个代价。</p><p>$1\leq n\leq 10^5$ 。</p></blockquote><p>首先提一下平方化一下式子得到代价本质上是</p><script type="math/tex; mode=display">\left(1+\sum_{i=l}^rx_i\right)^2</script><p>然后发现，这显然就是分的段越多越好，理想情况下(代价最小)就是分 $n$ 段。那么这个东西就显然是凸的，虽然是半凸壳但至少也是凸的。于是就去二分每分一段应该支付多少代价即可，似乎转移难度比上一道题还简单不少？</p><p>注意到二分内部写决策单调性是带 $\log$ 的，虽然我总觉得应该可以线性(但据dls说那种线性做法常数很大)，于是复杂度就是 $n\log n\log V$ 的。不开 <code>-O2</code> 在谷的表现并不好，开了之后性能有了超大的飞跃。</p><p>代码没啥可贴的，我就是copy了上道题的代码然后改了改转移（</p><h1 id="CF958E2"><a href="#CF958E2" class="headerlink" title="CF958E2"></a>CF958E2</h1><blockquote><p>给定 $n$ 个时间点。每个区间都以某两个时间点为左右端点，且每个区间的「代价」定义端点的时间之差。你要选择 $k$ 个连续的区间，保证这个 $k$ 个连续的区间没有交集，且代价总和最小。</p><p>$1\leq n\leq 500000,1\leq k\leq 5000$</p></blockquote><p>考虑一般 $dp$ 的话就是 $f_{i,j}$ ，这个地方由于不限制一定要取满，所以就可以有如下转移：</p><script type="math/tex; mode=display">f_{i,j}=\min\{f_{i-1,j},f_{i-2,j-1}+len(i-1,i)\}</script><p>似乎常数小一点，暴力 $O(nk)$ 也是可以过的。于是就直接wqs二分一下，注意到由于此时最优的决策一定是少选，所以每选一次就需要减去 $mid$ 来维护这个限制。于是最后复杂度 $n\log V$ 。</p><p>需要注意的是，由于用了 $cnt_i$ 记录转移到 $i$ 这个状态至少要分成多少段，所以这个地方还是牵扯到一个，如果我可以有 $6/7/8$ 三种划分方式转移到最优解，那么到底应该用哪个。很显然的是要么用 $max$ 要么用 $min$，这取决于二分的方式。如果是取 $max$ 的话，那么可能 $cnt_n&gt;m$ ；取 $min$ 的话则会 $\leq m$ 。所以根据这个调整代码细节就好了。</p><p>┮﹏┭这个地方真的是坑了我好久。<del>画外音: 你Tree I那题白做了？？</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ll res ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line"><span class="keyword">int</span> df[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">x *= <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>] &lt; f[i - <span class="number">2</span>] + df[i] + x)</span><br><span class="line">f[i] = f[i - <span class="number">1</span>], cnt[i] = cnt[i - <span class="number">1</span>] ; </span><br><span class="line"><span class="keyword">else</span> f[i] = f[i - <span class="number">2</span>] + (ll)df[i] + (ll)x, cnt[i] = cnt[i - <span class="number">2</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>] == f[i - <span class="number">2</span>] + df[i] + x) cnt[i] = max(cnt[i - <span class="number">1</span>], cnt[i - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">res = f[n] - (ll)x * m ; <span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">df[i] = base[i] - base[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, ans ; </span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ; </span></span><br><span class="line"><span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">check(ans) ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="国家集训队-种树"><a href="#国家集训队-种树" class="headerlink" title="[国家集训队]种树"></a>[国家集训队]种树</h1><blockquote><p>就是那个围着坑种树. 要求必须种 K 棵。</p></blockquote><p>首先由于 $m$ 的限制，加上权值会有负数所以多选和少选都有可能导致结果不优，所以很容易想到要去wqs二分。二分之后就变成了求解没有 $m$ 的限制的最大值问题。自然的想法是考虑 $f_i$ 表示前 $i$ 个坑种树的最大收益，那么转移就是考虑第 $i$ 个坑种不种，即 $f_i=\max\{f_{i-1},f_{i-2}+val_i\} $ 。</p><p>但是这个地方存在一个问题，就是第 $n$ 个和第 $1$ 个之间可能存在不合法。于是就理所应当地再记一维 $0/1$ 表示第 $1$ 个坑到底种不种树，转移到 $n$ 的时候特判一下。 这样就可以解决了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ll res ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line"><span class="keyword">int</span> df[N] ;</span><br><span class="line">ll f[N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ; cnt[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = base[<span class="number">1</span>] + x, cnt[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>] &gt; f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i])</span><br><span class="line">f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i][<span class="number">0</span>] = cnt[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>] &lt; f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i]) </span><br><span class="line">f[i][<span class="number">0</span>] = f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i], cnt[i][<span class="number">0</span>] = cnt[i - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i][<span class="number">0</span>] = max(cnt[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>] &gt; f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i])</span><br><span class="line">f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i][<span class="number">1</span>] = cnt[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>] &lt; f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i]) </span><br><span class="line">f[i][<span class="number">1</span>] = f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i], cnt[i][<span class="number">1</span>] = cnt[i - <span class="number">2</span>][<span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i][<span class="number">1</span>] = max(cnt[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i - <span class="number">2</span>][<span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">f[n][<span class="number">1</span>] = f[n - <span class="number">1</span>][<span class="number">1</span>] ; </span><br><span class="line">cnt[n][<span class="number">1</span>] = cnt[n - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] &gt; f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n])</span><br><span class="line">f[n][<span class="number">0</span>] = f[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n][<span class="number">0</span>] = cnt[n - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] &lt; f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n]) </span><br><span class="line">f[n][<span class="number">0</span>] = f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n], cnt[n][<span class="number">0</span>] = cnt[n - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[n][<span class="number">0</span>] = f[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n][<span class="number">0</span>] = max(cnt[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (f[n][<span class="number">0</span>] &gt; f[n][<span class="number">1</span>])&#123;</span><br><span class="line">res = f[n][<span class="number">0</span>] - (ll)x * m ; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n][<span class="number">0</span>] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res = f[n][<span class="number">1</span>] - (ll)x * m ; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n][<span class="number">1</span>] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="keyword">if</span> (m &gt; n / <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Error!"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">-2e9</span>, r = <span class="number">2e9</span>, mid, ans ; </span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ; </span></span><br><span class="line"><span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">check(ans) ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，然后就没有然后了，感觉wqs二分还是偏套路的。</p><p>btw，我才发现原来LG上种树这题的两个版本不是同一道题，那个蓝色要求至多k个，所以不可以wqs随便搞.jpg</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个东西大概好早就想学了，但是一直没学。这次就认真学一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="wqs二分" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wqs%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="动态规划/决策单调性" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="wqs二分" scheme="https://www.orchidany.cn/tags/wqs%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】决策单调性</title>
    <link href="https://www.orchidany.cn/2020/03/25/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7and%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/25/决策单调性and带权二分听课笔记/</id>
    <published>2020-03-25T06:31:30.000Z</published>
    <updated>2020-03-26T16:32:40.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>决策单调性是老朋友了，这次稍微系统地重学了一次，顺便做了做之前没做的题。</p><a id="more"></a><h1 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h1><p>如果是最小值问题，那大概长这样：</p><script type="math/tex; mode=display">a\leq b<c\leq d\\w(a,c)+w(b,d)\le w(a,d)+w(b,c)</script><p>那么如果满足这个，就说明其满足最小值时的决策单调性。证明起来很简单，因为 $a\to d,b\to c$ 的转移的值要更大些，所以 $a\to c,b\to d$ 的转移会更优，据此可得 $f$ 有决策单调性。</p><p>除此之外，该不等式存在一个变形。考虑对于 $a&lt;b$ 的如下 $4$ 个量 $a,a+1,b,b+1$ ，如果满足下式：</p><script type="math/tex; mode=display">w(a,b)+w(a+1,b+1)\le w(a,b+1)+w(a+1,b)</script><p>那么也说明是满足四边形不等式的。证明的话可以考虑暴力归纳也好、换元消元也好，反正挺显然的。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CF321E"><a href="#CF321E" class="headerlink" title="CF321E"></a>CF321E</h2><blockquote><p>你有⼀个 $n\times n$ 的对称矩阵表示不熟悉程度。</p><p>你要将它 $1\sim n$ 按顺序分成 $k$ 组，每组的代价为两两之间不熟悉程度的和。最小化这个东西。</p><p> $n \le 4000,k \le 800$</p></blockquote><p>考虑拿四边形不等式来证明。对于 $a\leq b&lt;c\leq d$ 而言，记 $s(a,c)$ 表示矩阵中左上角为 $(a,a)$ 右下角为 $(c,c)$ 的这么一个矩阵中元素的和，那么 </p><script type="math/tex; mode=display">w(a,c)+w(b,d)=\frac{s(a,c)+s(b,d)}{2}\\w(a,d)+w(b,c)=\frac{s(a,d)+s(b,c)}{2}</script><p>注意到</p><script type="math/tex; mode=display">s(a,d) = s(a,c)+s(b,d)-s(b,c)+s(a,b)+s(c,d)</script><p>那么就显然</p><script type="math/tex; mode=display">w(a,c)+w(b,d)\le w(a,d)+w(b,c)</script><p>十分满足决策单调性（其实画出图来更显然，就是多了两块矩阵）。</p><p>这个东西可以用分治来做。因为每一层决策与本层无关，即 $k-1\to k$ 。于是就可以 <code>solve(l,r,ql,qr)</code> 表示 $l\sim r$ 是从区间 $(ql\sim qr)$ 转移过来的。那么每次取 $mid=\frac{l+r}{2}$，然后找出 $f_{mid}$ 对应的最优决策所在位置，这样就可以分治了。复杂度 $O(nk\log n)$ 。</p><p>这题居然卡cin，气死我了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> s[N][N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][K] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> c = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) </span><br><span class="line">(res *= <span class="number">10</span>) += c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (s[r][r] + s[l - <span class="number">1</span>][l - <span class="number">1</span>] - s[r][l - <span class="number">1</span>] - s[l - <span class="number">1</span>][r]) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, pos = ql ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ql ; i &lt;= qr &amp;&amp; i &lt;= mid ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[i][g - <span class="number">1</span>] + do_do(i + <span class="number">1</span>, mid) &lt; f[mid][g])</span><br><span class="line">f[mid][g] = f[i][g - <span class="number">1</span>] + do_do(i + <span class="number">1</span>, mid), pos = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; mid &lt;&lt; " " &lt;&lt; pos &lt;&lt; " " &lt;&lt; g &lt;&lt; endl ; </span></span><br><span class="line">solve(l, mid - <span class="number">1</span>, ql, pos, g) ; </span><br><span class="line">solve(mid + <span class="number">1</span>, r, pos, qr, g) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">s[i][j] = qr() ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) solve(<span class="number">1</span>, n, <span class="number">0</span>, n, i) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[n][k] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF321E-的-O-n-2-做法"><a href="#CF321E-的-O-n-2-做法" class="headerlink" title="CF321E 的 $O(n^2)$ 做法"></a>CF321E 的 $O(n^2)$ 做法</h2><p>考虑记录一下每个点的决策范围。发现设状态 $(n,k)$ 最优决策位置记作 $opt(n,k)$ 的话，一定有</p><script type="math/tex; mode=display">opt(n,k-1)\leq opt(n,k)\leq opt(n+1,k)</script><p>那么可以这么写：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j : <span class="number">1</span> to k</span><br><span class="line">  <span class="keyword">for</span> i : n to <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> p : opt(i, j - <span class="number">1</span>) <span class="function">to <span class="title">opt</span><span class="params">(i + <span class="number">1</span>, j)</span></span></span><br><span class="line">      if [f(p, j - 1) &lt; f(i, j)] opt(i, j) = p, f(i, j) := f(p, j - 1) ;</span><br></pre></td></tr></table></figure><p>考虑这么做的时间复杂度。</p><p>发现对于这个决策矩阵的每一条穿过 $opt(i,j)$  和 $opt(i+1,j+1)$ 的斜线，每条斜线的代价是 $O(n)$ 的，原因是考虑斜线 $opt(i,j),opt(i+1,j+1)$ 这条斜线的决策来自于 $opt(i,j-1),opt(i+1,j)$ 这条斜线。那么也就是说，每个斜线的转移都是 $O(n)$ 的，共有 $O(n+k)$ 条斜线，所以复杂度 $O(n^2)$ 。</p><h2 id="NOI2009-诗人小G"><a href="#NOI2009-诗人小G" class="headerlink" title="[NOI2009]诗人小G"></a>[NOI2009]诗人小G</h2><blockquote><p>有N个诗句需要被排版为若⼲⾏，顺序不能改变。⼀⾏内可以有若⼲个诗句，相邻诗句之间有⼀个空格。</p><p>定义⾏标准⻓度L，每⾏的不协调度为|实际⻓度-L|^P，整⾸诗的不协调度就是每⾏不协调度之和。</p><p>任务是安排⼀种排版⽅案，使得整⾸诗的不协调度最⼩。</p><p>$n\leq 10^5$ 。</p></blockquote><p>考虑还是 $dp$ 嘛。以下分析暂不考虑什么 $\pm1$ 的常数问题。</p><p>$f_{i} $ 表示考虑了前 $i$ 个句子的最小不协调度。那么就有 $f_{i}=\min\{f_{j-1}+|s(i,j)-L|^P\}$。</p><hr><p>考虑这个东西的性质。还是设 $a\leq b&lt;c\leq d$ ，那么可知 $|s(a,c)-L|^P+|s(b,d)-L|^P$  </p><script type="math/tex; mode=display">|s(a,d)-L|^P+|s(b,c)-L|^P=|s(a,c)+s(c,d)-L|^P+|s(b,d)-s(c,d)-L|^P</script><p><del>草为什么我想直接打个表走人</del> 来让我瞎编一下。令 $x=s(a,c)-L,y=s(b,d)-L$。那么要证明</p><script type="math/tex; mode=display">|x+s(c,d)|^P+|y-s(c,d)|^P\geq |x|^P+|y|^P</script><p>考虑当 $|P|$ 为偶数的时候……</p><hr><p>好的，上面的证明崩掉了。考虑另一种证明方法。考虑对于 $a&lt;b$ 的如下 $4$ 个量 $a,a+1,b,b+1$ ，考虑去证明 </p><script type="math/tex; mode=display">|s(a,b)-L|^P+|s(a+1,b+1)-L|^P\le |s(a,b+1)-L|^P+|s(a+1,b)-L|^P</script><p>发现令 $p = len_a,q=len_b,x=s(a,b)$本质上就是在证明</p><script type="math/tex; mode=display">|x|^P+|x-p+q|^P\le |x+q|^P+|x-p|^P</script><p>即</p><script type="math/tex; mode=display">|x|^P-|x-p|^P\le|x+q|^P-|x+q-p|^P</script><p>那么也就是要证明 $f(x)=|x|^z-|x-p|^z$ 这个函数是单调不降的。可知一定有 $s(a,b)&gt;p+q$ ，所以可知括号内均 $&gt;0$，换言之 $f(x)=x^z-(x-p)^z$ ，这显然是单调不降的。于是证毕。</p><p>但是这个地方存在一个问题，就是转移有着严格的顺序，不能像上一道题一样来分治，因为 $l$ 必须要先于 $mid$ 来转移。<del>于是这显然就需要CDQ分治了</del> 然而CDQ分治是 $\log ^2$ 的并不可以过得去(并且显然没人会这么写)。</p><p>所以此处就需要用二分+单调栈的方式来维护。这两个过程严格意义上是分开的。大概就是考虑对于每个转移完的 $i$ ，我们用这个去更新后面的点的决策区间，更新方法是：1、先不断比较当前的决策区间和之前每个数的决策区间哪个更优，维护一个从底部到顶部单调递减的栈，依次弹掉这些不优的；2、之后考虑二分栈顶的这一段，确定新一个决策点的左区间。</p><p>然后是实现细节方面。注意需要在维护单调栈的时候顺便维护每个元素的决策左区间，并且还要维护一个指针，用来寻找当前点的决策点。</p><p>然后还有十分神必的一点，就是要记得不将那些无有效决策区间的决策点入栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> kts[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, p, k ;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">40</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret *= a ;</span><br><span class="line">        a *= a ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expow(mabs(sum[r] - sum[l - <span class="number">1</span>] - k), p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">trans</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(p + <span class="number">1</span>, x) + f[p] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p ;</span><br><span class="line">        stk[top = <span class="number">0</span>] = <span class="number">0</span> ; ++ k ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            pos[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>) ;</span><br><span class="line">            base[i] = <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>) ;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i] += i ;</span><br><span class="line">        <span class="comment">//debug(sum, 1, n, '\n') ;</span></span><br><span class="line">        kts[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> h = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (h &lt; top &amp;&amp; kts[h] &lt; i) ++ h ;</span><br><span class="line">            <span class="keyword">if</span> (kts[h] &gt; i) -- h ;</span><br><span class="line">            f[i] = trans(stk[h], i) ; pos[i] = stk[h] ;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; trans(stk[top], kts[top]) &gt;= trans(i, kts[top]))</span><br><span class="line">                stk[top] = <span class="number">0</span>, kts[top] = n + <span class="number">1</span>, -- top ;</span><br><span class="line">            <span class="keyword">int</span> l = kts[top], r = n + <span class="number">1</span>, mid, ans = n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (trans(stk[top], mid) &gt;= trans(i, mid))</span><br><span class="line">                    ans = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans &lt;&lt; " * " &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= n) stk[++ top] = i, kts[top] = ans ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">            <span class="comment">//debug(stk, 1, top, '\n') ;</span></span><br><span class="line">            <span class="comment">//debug(kts, 1, top, '\n') ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug(pos, 1, n, '\n') ;</span></span><br><span class="line">        <span class="keyword">if</span>(f[n] &gt; <span class="number">1e18</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Too hard to arrange"</span>) ;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"--------------------"</span>) ; <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>)f[n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="keyword">int</span> t ; stk[top = <span class="number">0</span>] = t = n ;</span><br><span class="line">        <span class="keyword">while</span> (t) stk[++ top] = t = pos[t] ;</span><br><span class="line">        <span class="keyword">while</span> (top)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = stk[top] + <span class="number">1</span> ; i &lt; stk[top - <span class="number">1</span>] ; ++ i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s "</span>, s[i] + <span class="number">1</span>) ; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s[stk[top - <span class="number">1</span>]] + <span class="number">1</span>) ; -- top ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"--------------------"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之呢，单调栈+二分这个做法是比较普适的，但是有时候也可以写分治，因为分治比较好写。</p><h2 id="IOI2013-wombats"><a href="#IOI2013-wombats" class="headerlink" title="IOI2013 wombats"></a>IOI2013 wombats</h2><blockquote><p>题意⼤概是，有 $r\times c$ 的⽹格图，每次只能朝左右下三个⽅向。</p><p>操作包括修改⼀条边的边权，然后查询某两点之间最短路。</p><p>$r\leq 5000,c\leq 200,q\leq 200000,m\leq 500$ 其中 $m$ 是修改次数，$q$ 是询问次数。</p></blockquote><p>草，这题真是从一开始就不会qaq</p><p>大概就是考虑以列为标号建线段树，然后每个区间维护最左边的点到最右边的所有点的最短距离。然后合并显然就是 $c^3$ 的，总复杂度 $O(rc^3+q\log r+mc^3\log r)$ 。(好像杜爷写的是 $O(rc^3+q+mc^3\log r)$</p><p>然后考虑这东西由于只能向右和向下走，所以是有单调性的，也就是对于右侧的两个点 $(x,y)$ 和 $(x,y+1)$ ，他俩的决策路线一定是不相交的。这个好像还是比较显然的？然后就可以暴力 $O(rc^3+q+mc^2\log c\log r)$ 做了。</p><p>不过显然根据上面那个 trick ，二维的决策单调性是可以消掉 $\log $ 的，还是上面那种做法。仔细想了想，其实 $nk$ 应该算是两维的决策单调性，所以或许这确实是二维决策单调性的通用解决方法吧。 </p><p>嗯，代码是不想写了，就这样吧。</p><h2 id="IOI2014-Holiday"><a href="#IOI2014-Holiday" class="headerlink" title="IOI2014 Holiday"></a>IOI2014 Holiday</h2><blockquote><p>有 n 个城市，每个城市有⼀个权值，起点在 s 。 每⼀天你可以往左或者往右⾛⼀步，或者选择游览这个城市。问 d 天能获得的最⼤权值和是多少？</p></blockquote><p>发现一共至多有四种走法，就是一直向右走、一直向左走、向左走折回起点然后向右走、向右走折回起点然后向左走。前两种就显然是枚举走了 $k$ 个城市，然后找其中的前 $d-k$ 大的城市游览即可。 </p><p>考虑另外两种的做法。先给出结论，假设我向右走到了点 $i$ ，再向左走到点 $j$ ，那么随着 $i$ 增大，$j$ 是不降的。</p><p>但这个地方很迷，迷在网上很多题解写的是决策单调性不是这东西单调，是前两种那个走法单调，我寻思这不是显然…</p><p>哦，想了想，发现本质是一样的。就是向右走 $0$ 再向左右显然也有单调性。那么现在唯一的问题就在于这个单调性似乎不是那么显然…</p><p>好的，那看起来是，随着 $l$ 不断向右，$r$ 不会向左(鬼知道我刚才怎么理解的)。这样就非常合理了。于是就可以分治去做了。复杂度 $m \log n$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决策单调性是老朋友了，这次稍微系统地重学了一次，顺便做了做之前没做的题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="决策单调性" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
    
      <category term="动态规划/决策单调性" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces [Gym 102354B] Yet Another Convolution</title>
    <link href="https://www.orchidany.cn/2020/03/25/gym102354B/"/>
    <id>https://www.orchidany.cn/2020/03/25/gym102354B/</id>
    <published>2020-03-25T01:57:24.000Z</published>
    <updated>2020-03-25T04:39:10.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给出两个长为 $n$ 的序列 $\{a_n\}$ 和 $\{b_n\}$ 。对于所有的 $k\in[1,n]\cap\mathbb Z_{+}$ ，求这样的 $c_k$：</p><script type="math/tex; mode=display">c_k=\max_{\gcd(i,j)=k}\{a_i-b_j\}</script><p>$1\leq n\leq 10^5$</p></blockquote><p>题目来源于 2018-2019 Summer Petrozavodsk Camp, Oleksandr Kulkov Contest 2 。</p><p>发现这题居然还是那一场通过人数最多的题目之一…深深地感觉到了自己的弱小。</p><a id="more"></a><p>然后正片部分。考虑这个式子可以怎么化，发现对于一个给定的 $k$ ，要找的 $a_i$ 和 $b_i$ 应该至少是这样的：</p><script type="math/tex; mode=display">a_k,a_{2k},a_{3k}\cdots a_{pk}</script><script type="math/tex; mode=display">b_k,b_{2k},b_{3k}\cdots b_{pk}</script><p>于是直接把这些拿出来重编号为 $1,2,3\cdots p$。那么为了保证 $\gcd(i,j)=k$，就需要满足取出的一个 <code>pair</code> 满足 $\gcd(i,j)=1$ 。也就是现在转化成了这么一个问题：</p><script type="math/tex; mode=display">\max_{i=1}^p\{(a_i-b_j)[(i,j)=1]\}</script><p>也就是</p><script type="math/tex; mode=display">\max_{i=1}^p\{a_i-\min_{j=1}^p\{b_j\cdot[(i,j)=1]\}\}</script><p>然后似乎就没法做了。发现本题要求 $poly(\log)$ 的做法，但是本质上对于每个 $k$ ，都有 $O(\frac{n}{k})$ 组询问，这个询问量是十分巨大的。于是考虑有没有什么可以一起处理全部询问的方法。发现似乎整体二分可行。</p><p>首先把里面的 $\min$ 通过将 $b$ 全部取反变成 $\max$：</p><script type="math/tex; mode=display">\max_{i=1}^p\{a_i+\min_{j=1}^p\{-b_j\cdot[(i,j)=1]\}\}</script><p>之后考虑整体二分。具体的来讲，先考虑一组询问（即一个固定的 $i$）怎么二分。对于一个 $\min_{j=1}^p\{b_j\cdot[(i,j)=1]\}$ ，将其转化成判定性问题。假设当前二分到的值是 $ans$ ，那么考虑，如果 $\sum_{j=1}^p[ans<b_j][(i,j)=1]>0$，那就代表存在一个值比 $ans$ 大，符合二分性质。</b_j][(i,j)=1]></p><p>那么对于这个 $\sum$ 而言，就可以变一下形了：</p><script type="math/tex; mode=display">\sum_{j=1}^p[ans<b_j]\sum_{d|i\operatorname{and}d|j} \mu(d)>0</script><p>反演一下也就是</p><script type="math/tex; mode=display">\sum_{d|i} \mu(d)\sum_{d|j}^p[ans<b_j]>0</script><p>那么考虑整体二分的时候，对于每一层都可以把 $<vmid$ 的位置赋为 $1$ ，或者反过来，本质都一样。之后就只需要查询某个 $i$ 的上式值。发现这东西需要维护每个值的倍数处的值（后一个 $\sum$），并且不是很好清空。于是考虑一个有趣的做法。假设以把 $>vmid$ 的位置都赋值为 $1$ 做例子。每次手动将一个指针移动 $vmid+1$ 处，然后对于途径的所有 $b_j$，如果 $&gt;vmid$ 的话就 $+1$ ，否则 $-1$ 。这样做之后，<strong>直接把自己的标记下传给所有自己的约数</strong>。这样最后去 $check(i)$ 的时候就可以直接枚举所有约数而不需要再去枚举约数的倍数。发现移动指针每层都是 $O(r-l)$ 的。</vmid$></p><p>于是最后考虑算一下复杂度。大概是：</p><script type="math/tex; mode=display">\sum _{i=1}^n(\frac{n}{i} \log \frac{n}{i} d(\frac{n}{i}))</script><p>的复杂度。emmm，这大概是个什么复杂度呢…考虑 $d(n)&lt;O(\sqrt[3]n)$ ，所以最后应该不会超过 $(n\log n)^{\frac{4}{3}}\log n$</p><p>后面一个 $\log$ 是因为：</p><script type="math/tex; mode=display">\int \frac{n}{x} \log \left(\frac{n}{x}\right) \mathrm{dx}=-\frac{n(\log x)^{2}-2 n \log n \log x+n(\log n)^{2}}{2}</script><p>似乎是因为 $\log (\frac{n}{x})&lt;0$ 的问题，所以需要忽略掉符号。最后大概也就是 $n\log^2 n$ 的级别。</p><p>然而实际积分出来也差不多？</p><script type="math/tex; mode=display">\int \frac{n^{\frac{4}{3}} \log \left(\frac{n}{x}\right)}{x^{\frac{4}{3}}} \mathrm{d x}=\frac{n^{\frac{1}{3}}(3 n \log x-3 n \log n+9 n)}{x^{\frac{1}{3}}}</script><p>看上去就是 $(n\log n)^{\frac{4}{3}}\log n$ 的亚子。不过话说回来 $d(n)=O(\sqrt[3] n)$ 的近似误差有、大，所以还是 $O($能过$)$ 比较靠谱.jpg 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;<span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> xq ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> q[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> lq[N] ;</span><br><span class="line"><span class="keyword">int</span> rq[N] ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ;</span><br><span class="line"><span class="keyword">int</span> ta[N] ;</span><br><span class="line"><span class="keyword">int</span> tb[N] ;</span><br><span class="line"><span class="keyword">int</span> Mu[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; d[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = d[x].size() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; ++ i)</span><br><span class="line">        sum[d[x][i]] += y ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (xq &gt; x) add(base[-- xq], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; xq) add(base[xq ++], <span class="number">-1</span>) ;</span><br><span class="line"><span class="comment">//debug(sum, 1, 50, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = d[x].size() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; ++ i)</span><br><span class="line">        ret += Mu[d[x][i]] * sum[d[x][i]] ;</span><br><span class="line">  <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_it</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> vl, <span class="keyword">int</span> vr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            ans[q[i]] = vl ; <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">int</span> tl = <span class="number">0</span>, tr = <span class="number">0</span> ; upd(vmid + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (calc(q[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">            lq[++ tl] = q[i] ;</span><br><span class="line">        <span class="keyword">else</span> rq[++ tr] = q[i] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; tl &lt;&lt; " " &lt;&lt; tr &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tr ; ++ i) q[l + tl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    do_it(l, l + tl - <span class="number">1</span>, vl, vmid) ; do_it(l + tl, r, vmid + <span class="number">1</span>, vr) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        tmp[q[i] = i] = tb[i], sum[i] = <span class="number">0</span> ; </span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + k + <span class="number">1</span>) ; <span class="keyword">int</span> x ; xq = k + <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">          x = upb(tmp + <span class="number">1</span>, tmp + k + <span class="number">1</span>, tb[i]) - tmp ;</span><br><span class="line">          x -- ; base[x] = i ; tmp[x] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-2333333</span> ; do_it(<span class="number">1</span>, k, <span class="number">1</span>, k) ; <span class="comment">//debug(q, 1, k, '\n') ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        ret = max(ret, ta[i] + tmp[ans[i]] - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">            ta[j] = A[i * j], tb[j] = B[i * j] ;</span><br><span class="line">        res[i] = max(res[i], do_do(n / i)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = Mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">pr[++ cnt] = i, Mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt; k) <span class="keyword">break</span> ;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">            Mu[i * pr[j]] = - Mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= k ; ++ j)</span><br><span class="line">            d[i * j].p_b(i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve(N - <span class="number">10</span>) ;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; A[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; B[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) B[i] = -B[i] ;</span><br><span class="line">    solve() ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; res[i] &lt;&lt; " \n"[i == n] ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        A[i] = -A[i], B[i] = -B[i] ;</span><br><span class="line">    solve() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">" \n"</span>[i == n] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给出两个长为 $n$ 的序列 $\{a_n\}$ 和 $\{b_n\}$ 。对于所有的 $k\in[1,n]\cap\mathbb Z_{+}$ ，求这样的 $c_k$：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
c_k=\max_{\gcd(i,j)=k}\{a_i-b_j\}&lt;/script&gt;&lt;p&gt;$1\leq n\leq 10^5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目来源于 2018-2019 Summer Petrozavodsk Camp, Oleksandr Kulkov Contest 2 。&lt;/p&gt;
&lt;p&gt;发现这题居然还是那一场通过人数最多的题目之一…深深地感觉到了自己的弱小。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
      <category term="gym" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/gym/"/>
    
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="离线算法/整体二分" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】离线分治选整</title>
    <link href="https://www.orchidany.cn/2020/03/24/%E5%88%86%E6%B2%BB%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/24/分治听课笔记/</id>
    <published>2020-03-24T15:40:29.000Z</published>
    <updated>2020-04-03T05:53:17.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是一些听dls讲课的笔记。感觉好神仙啊<del>，这我怎么可能会。</del></p><a id="more"></a><h1 id="Part1-神奇的暴力"><a href="#Part1-神奇的暴力" class="headerlink" title="Part1 神奇的暴力"></a>Part1 神奇的暴力</h1><h2 id="bitset做-K-维数点"><a href="#bitset做-K-维数点" class="headerlink" title="bitset做 $K$ 维数点"></a>bitset做 $K$ 维数点</h2><p>令  $f(k,w)=\{i|x_{i,k}&lt; w\}$.</p><p>即第 $k$ 维小于 $w$ 的集合。</p><p>然后查询的话，对于第 $p$ 个点，就求一下 </p><script type="math/tex; mode=display">\operatorname{and}_{i=1}^Kf_{i,x_{p,i}}</script><p>这东西即可。</p><p>预处理的话，考虑先 $O(Kn)$ 让每个 $x_{i,k}$ 都赋值到 $f_{k,x_{i,k}+1}$ 上，然后从头到尾 $or$ 下来，就变成了 $K\frac{n^2}{w}$ 的复杂度。查询复杂度就是 $O(K\frac{n}{w})$ 。</p><p>思考空间复杂度，大概是 $O(K\frac{n^2}{w})$ 。发现似乎有点卡空间。于是考虑设置一个阈值 $T$，换设一个 $f_{k,iT}$ 用来只记录 $T$ 的倍数的情况，这样空间复杂度就会降为 $\frac{Kn^2}{Tw}$ ；查询的时候就可以查询离 $x_{p,i}$ 最近的块，然后把后面的下脚料暴力加进去，时间复杂度变成了 $O(Kn(\frac{n}{w}+T))$ 。 </p><h1 id="Part2-CDQ分治"><a href="#Part2-CDQ分治" class="headerlink" title="Part2 CDQ分治"></a>Part2 CDQ分治</h1><h1 id="动态凸壳"><a href="#动态凸壳" class="headerlink" title="动态凸壳"></a>动态凸壳</h1><blockquote><p>给出一个平面，支持加点 $(x,y)$ ，给出 $(a,b)$ 查询最大的 $ax+by$ 。</p></blockquote><p>发现本质上是在求某个方向上最大的点积，本质上就是在动态维护凸壳。于是有两种做法：</p><p>（1）直接 <code>set&lt;point&gt;</code> 维护，支持按 $x$ 查询和按斜率查询。插入的时候按 $x$ 排序，询问按斜率排序。可以在 <code>cmp</code> 里记用个全局变量来判断当前按什么排序(神奇的是这样复杂度是对的)。反正就是维护凸壳就对了。</p><p>这个地方很迷的就是，如果每次查询的是 $kx+y$ 这种形式，那么斜率可以下取整。</p><p>（2）CDQ分治，变成了静态维护凸包。发现两边都排完序之后，中间就可以直接大力归并了，所以是可以做到 $n\log n$ 的。</p><h2 id="CF-848C"><a href="#CF-848C" class="headerlink" title="CF 848C"></a>CF 848C</h2><blockquote><p>给⼀个数列，定义⼀段的权值为每个不同的数值最后⼀次出现的位置减去第⼀次出现的位置和。</p><p>要求单点修改/求某⼀段的权值和。</p></blockquote><p>神仙找性质题。考虑令每个 $i$ 的贡献是 $i-\mathrm{pre}_{a_i}$，那么就是在二维数点： $\sum_{l \leq \text { pre}_{a_{i}}&lt;i\leq r} i-\text {pre}_{a_i}$ 。于是可以直接CDQ分治。</p><h2 id="UOJ-50-链式反应"><a href="#UOJ-50-链式反应" class="headerlink" title="UOJ#50 链式反应"></a>UOJ#50 链式反应</h2><blockquote><p>求解微分方程</p><script type="math/tex; mode=display">f'(x)=f^2(x)p(x)+1</script><p>的前 $m$ 项。</p></blockquote><p>化一下式子</p><script type="math/tex; mode=display">\begin{aligned}\sum nf_{n}x^{n-1}&=\sum \sum_{0\leq i+j<n}f_{i}\cdot f_j\cdot p_{n-1-i-j}\\f_{n}&=\frac{1}{n} \sum_{0 \leq i+j \leq n-1} f_{i} \cdot f_{j} \cdot p_{n-1-i-j}\end{aligned}</script><p>然后考虑大概是一个分治FFT形式。于是考虑CDQ分治。然后考虑怎么看左边系数对右边的贡献。</p><p>考虑如果 $l=0$ 。那么本质上就是 $f_{0\sim mid}^2* p_{0\sim r-1}$ 卷起来，然后把 $&gt;mid$ 的那些贡献全部累加。</p><p>否则一定有 $2l&gt;r$ 。发现 $i\in [l,mid]$ 或  $j\in [l,mid]$ ，因为对于任意 $i\in [l,mid]$，均有 $r-1-i&lt;l$ 。所以最后就变成了 $f_{0\sim r-1-l},p_{0\sim r-1-l}$ 和 $f_{l\sim mid}$ 的卷积。</p><p>复杂度 $m\log ^2 m$ 。</p><h1 id="Part3-线段树分治"><a href="#Part3-线段树分治" class="headerlink" title="Part3 线段树分治"></a>Part3 线段树分治</h1><h2 id="动态图连通性"><a href="#动态图连通性" class="headerlink" title="动态图连通性"></a>动态图连通性</h2><blockquote><p>回溯的时候仍然需要删除某些边，但是发现删边的顺序等于加边的顺序的倒序。即，我们将无序的删除转化为了操作栈的压入和弹出。此时只需维护一个可回退并查集即可。注意此处的并查集需要按秩合并，因为路径压缩的复杂度是均摊的，无法保证回退时的复杂度。</p></blockquote><h2 id="不包含某个物品的背包"><a href="#不包含某个物品的背包" class="headerlink" title="不包含某个物品的背包"></a>不包含某个物品的背包</h2><p>普通的背包加入是 $O(m)$，合并是 $O(m^2)$，删除是 $O(nm)$ 的。</p><p>考虑线段树分治。一个物品的存活时间是 $[1,k-1]$ 和 $[k+1,n]$ 。令 <code>solve(l,r,f)</code> 表示把 $[l,r]$ 之外的物品加入背包时得到的是 $f$ 。于是就考虑分治下去，对于 <code>solve(l,mid,g)</code> 而言，<code>g</code> 是 <code>f</code> 和 $mid+1\sim r$ 之间信息的合并；反之 <code>solve(mid + 1,r,h)</code> 中 <code>h</code> 需要时 <code>f</code> 和 $l\sim mid$ 的信息的合并。分治下去即可。</p><p>最终复杂度 $O(nm\log n)$ .</p><h2 id="不经过某个点的最短路-方案数"><a href="#不经过某个点的最短路-方案数" class="headerlink" title="不经过某个点的最短路/方案数"></a>不经过某个点的最短路/方案数</h2><p>跟上个题本质一样？ 直接做显然是 $n^4$ 的嘛，所以就线段树分治一下就好了。</p><h2 id="HNOI城市建设"><a href="#HNOI城市建设" class="headerlink" title="HNOI城市建设"></a>HNOI城市建设</h2><blockquote><p>支持修改边权和查询MST。</p></blockquote><p>还是考虑线段树分治嘛，但是 LCT 做就显然复杂度不是那么靠谱。</p><p>考虑一种不用 LCT 的做法。发现假设要修改 $1$ 条边，那么这个修改至多会影响一条边，也就是对于 <code>solve(l,r)</code> 最多会影响 $O(r-l)$ 条边。发现这个变化量并不大，正好满足分治的复杂度。于是考虑图和把每一层的操作数都降到 $O(r-l)$ 。</p><p>考虑对于不在当前区间的边集的边进行分类，一类是一定不会在MST中的，一类是一定会在MST中的。具体的，对于分治的每一层，设当前层需要修改的边集为 $E$，那么首先把 $E$ 中的边权均设为 $-\infty$ 跑一次MST，这样MST中 $\not \in E$ 以外的边就是必选边；再设为 $+\infty$ ，这样MST中 $\not \in E$ 的就是必不选边。</p><p>注意到，如果每次将必选边连成的连通块缩起来，这样分治下去每层的点数就是 $O(r-l)$ 的；如果每次将所有必不选边删掉，那么由于至多是生成树上那些边，跟点数同阶，也是 $O(r-l)$ 的，再加上本层的 $O(r-l)$ 的边，最终边集也是 $O(r-l)$ 的。这样复杂度就对了。最终复杂度为 $n\log^2 n$ ，其中另一个 $\log$ 是可回退并查集的。</p><p>改天写一下这题吧quq</p><h2 id="嫖来的笔记"><a href="#嫖来的笔记" class="headerlink" title="嫖来的笔记"></a>嫖来的笔记</h2><p>山东队长swk写的吼哇！</p><p><img src="236.png" alt></p><h2 id="UOJ-191-Unknown"><a href="#UOJ-191-Unknown" class="headerlink" title="UOJ#191 Unknown"></a>UOJ#191 Unknown</h2><blockquote><p>维护向量序列，支持末尾插入/删除元素，询问区间与输入的向量点积最大值。</p></blockquote><p>发现只有末尾插入和区间查询的话大概可以 <code>2048</code> 着做。这个 <code>2048</code> 大概是指每插入一个元素，都合并到最小的那一堆里，然后将这一堆二进制拆分，如果合并后存在和他一样大小的一堆就继续合并。查询的时候就每一堆分别查询，总查询复杂度会多一个 $\log $。从这个地方也可看出，由于只需要重构，所以不需要插入删除十分优秀。</p><p>考虑重构复杂度。重构的复杂度分析时大多都是均摊分析：每个元素最多被重构 $\log n$ 次，所以最多是 $n\log n$ 的。</p><p>由于线段树的合并操作有着较优的复杂度，于是考虑用线段树来维护。这样大概是 $O(n\log^2 n)$ 的复杂度。</p><p>接下来考虑带删除操作的问题。</p><p>如果是离线，由于只有末尾的插入和删除，可以用版本树的思想来做，大概是随着序列递增，建出一棵深度递增的树，对于 $i$ 号结点后面的 <code>Ins</code>, <code>Del</code> , <code>Ins</code>, <code>Ins</code> , <code>Del</code>, <code>Del</code>, <code>Ins</code> 而言，代表着该结点的三个分支(儿子)，然后每次算大概就是树剖一下，这样就是 $\log ^ 3n$ 的复杂度了：线段树里面两个 $\log $，凸包二分再要一个 $\log$ 。（这个地方复杂度还是不很会算，好像是如果将询问排序就可以少一个 $\log$ 所以最后是 $3$ 个 $\log$，好像很nb的样子）。</p><p>考虑在线如何用二进制分组来做。如果直接暴力做，就不能保证每个元素都被合并 $\log n$ 次，所以在某个块末尾反复插入删除就会人没了。</p><p>于是考虑两种方法解决这个问题。</p><p>第一种是类似 $\rm Treap$ 的随机化，插入每个元素时随机一个权值，并作为独立一组。若最后一组的最小权值小于前一组的最小权值，则将两组合并。删除时暴力将最后一块拆散，并按照插入的规则重构即可。可以证明期望复杂度仍是 $O(n\log^2n)$。</p><p>第二种是打标记。考虑对于每个被建出来的块，因为被删除的元素不会出现在区间询问内。问题出现在被删除的位置重新被填满时，此时对这个块打一个「坏」标记。查询的时候，如果这个块是坏的就向两边的儿子递归查。考虑如何让这个结构不退化，我们约定每一层至多有一个坏的块，并且要最靠右。否则就大力重构其中的另一个块。</p><p>这样就保证每一层只向一侧递归，询问的复杂度是对的。插入、删除都是在序列末尾进行，因此被打标记的节点也只存在于序列末尾。因此，要达到长度为 $len$ 的区间的重构标准，至少需要进行 $O(len)$ 次操作，重构的均摊复杂度为 $O(1)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是一些听dls讲课的笔记。感觉好神仙啊&lt;del&gt;，这我怎么可能会。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="离线算法/CDQ分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-CDQ%E5%88%86%E6%B2%BB/"/>
    
      <category term="离线算法/线段树分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces [Global Round 7F] Wise Men</title>
    <link href="https://www.orchidany.cn/2020/03/22/GlobalRound7F/"/>
    <id>https://www.orchidany.cn/2020/03/22/GlobalRound7F/</id>
    <published>2020-03-22T03:46:24.000Z</published>
    <updated>2020-03-22T04:15:41.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个人。给出 $n$ 个人的「认识情况」(双向且保证合法)。</p><p>定义 <code>bool</code> 值函数 $K(i,j)$ 表示两个人是否认识。考虑一个 $n$ 个人编号的排列 $p$ ，定义其生成的 $01$ 串 $\{s_{n-1}\}$ 为 $\forall i\in[1,n-1]\cap\mathbb{Z_+},s_i=K(p_{i},p_{i+1})$。</p><p>统计对于 $2^{n-1}$ 种不同的 $01$ 串，有多少种排列可以生成它。</p><p>F1: $2\leq n\leq 14$ 。</p><p>F2 : $2\leq n\leq 18$ 。</p></blockquote><p>神仙计数题，再一次深深地明白了自己的弱小。</p><a id="more"></a><p>首先考虑，对于一个串 $s$ 而言，直接统计比较麻烦，麻烦在难以体现「不认识」这个限制上。所以考虑如何忽略这个限制。考虑忽略限制后，就变成了统计 $ans(s)$ 表示<strong>至少</strong>含有集合 $s$ 的排列数。</p><p>那么对于 $ans(s)$ 存在一个性质：如果 $s$ 和 $s’$ 中，连通分量状态相同，那么两个集合的 $ans$ 是等价的。此处连通分量指的是连续一段互相认识的人，状态相同指的是 $s$ 和 $s’$ 的这些段大小相同，排布可以不同。（比如 $0100111\Longleftrightarrow0011101\Longleftrightarrow1000111$） 。</p><p>证明很简单，因为对于生成 $01$ 的串而言，其方案数只在于有多少排列可以凑出这些 $1$ 的连续段而已。换言之就是由于是全排列，所以对称。</p><p>值得注意的是，对于一个长度为 $k$ 的 $1$ 连续段，其包含 $k+1$ 个互相认识的人，也就是该连通块大小为 $k+1$ 。</p><p>考虑如何求 $ans(s)$ 。注意到现在已经转化成了统计每一种对 $n$ 的拆分方式，有多少种排列数。那么一个比较自然的想法就是求下式</p><script type="math/tex; mode=display">\sum_{\begin{aligned}&t_1,t_2,t_3\cdots t_p\\ &\forall i,j,t_i\cap t_j=\empty \\&|t_1|+|t_2|+\cdots +|t_p|=n\end{aligned}} \prod_{k=1}^p f(t_k,|s_k|)</script><p>其中 $t_i$ 表示枚举的第 $i$ 个点集，$s_i$ 表示组成 $s$ 这个 $01$ 串的第 $i$ 个连通块(链形态的点集) ，$f_{i,j}$ 表示从 $size(i)=j$ 的集合 $i$ 里面选出一个大小为 $j$ 的<strong>链</strong>的方案数。不难知道这些限制的意义：划分必须恰好划分掉 $n$ 个点，且点集之间不存在交集(否则需要合并)。</p><p>上式的意义在于，对于 $s$ 的一个划分，每个连通块都需要从某个点集中选出，而点集之间是互不相交的，所以 $size$ 必须恰好是链长。于是可以从这个角度入手来求排列数。同时需要注意，由于我们是硬生生划定了 $p$ 个集合，并不关心集合之间是否有连边，也就代表了其中有些单点(也就是 $s$ 中的 $0$ 位置)可能是与其他连通块是一体的，这也就符合了我们对 $ans(s)$ 的定义：<strong>至少</strong>含有集合 $s$ 的排列数。</p><p>注意到 $f$ 是比较容易求得的。考虑 $g_{i,j}$ 表示集合 $i$ 以 $j$ 结尾的链的方案数，那么就是 $n^2$ 转移，保证每次都用最后一个点转移就可以使得形态是一条链。$f$ 就是对 $g$ 的一个累加。这一部分复杂度 $O(n^22^n)$ 。</p><p>考虑求出 $f$ 之后如何计算这个式子。一个比较直接的想法是暴力枚举子集的子集来转移，由于 $\Pi$ 对 $\Sigma$ 有分配律，可知转移是不难的。复杂度 $P(n)3^n$，其中 $P(n)$ 是本质不同的划分数。可以过掉 $n=14$ 的 $\rm F1$ 。</p><p>对于 $\rm F2$ ，考虑这么一个问题：如何保证一组相加起来 $size$ 等于全集的子集互不相交？很显然是如果他们的<strong>并</strong>就是全集，那么彼此之间一定不会有交。于是可以知道用 FMT 来优化这个过程。具体的，根据分配律，可以对每个 $s_i$ 分开计算其贡献，进行 $p$ 次 FMT 之后，答案就是第 $2^n-1$ 项系数。</p><p>那么就做完了。最后只需对于每个 $01$ 串，求出他的划分即可。注意到一开始 $ans$ 的定义，需要我们做一次子集差变换。大概类似于FMT处理and的逆过程。最终复杂度 $O(2^n(P(n)+n+n^2))$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_p pop_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1200000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line">ll I[M] ;</span><br><span class="line">ll t[M] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line">ll f[M][N] ;</span><br><span class="line">ll g[N][M] ;</span><br><span class="line">ll res[N * N] ;</span><br><span class="line"><span class="keyword">int</span> know[N][N] ;</span><br><span class="line"><span class="built_in">map</span>&lt;vint, <span class="keyword">int</span>&gt; Id ;</span><br><span class="line">vint part[N * N], now ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(ll *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = f[j] + (ll)g * f[j ^ (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_part</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> big)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st == n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(part[Id[now] = ++ tot] = now) ;</span><br><span class="line">    <span class="keyword">if</span> (n - st + <span class="number">1</span> &gt;= big)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = big ; i &lt;= n - st + <span class="number">1</span> ; ++ i)</span><br><span class="line">            now.p_b(i), dfs_part(st + i, i), now.p_p() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; ~i) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!know[j][k]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) <span class="keyword">continue</span> ;</span><br><span class="line">                f[i | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k] += f[i][j] ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ len ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i) g[len][i] += f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, I, <span class="keyword">sizeof</span>(I)) ;</span><br><span class="line">        <span class="keyword">int</span> o = (<span class="keyword">int</span>)part[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; o ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                t[k] *= g[part[i][j]][k] ;</span><br><span class="line">        fmt_or(t, <span class="number">-1</span>) ; res[i] = t[m] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        now.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r ; l &lt; n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = l ;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &amp; i &amp;&amp; r &lt; n)</span><br><span class="line">                ++ r ; now.p_b(r - l + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(now.begin(), now.end()) ;</span><br><span class="line">        ans[i] = res[Id[now]] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    I[<span class="number">0</span>] = <span class="number">1</span> ; fmt_or(I, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;know[i][j]) ; dp1() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fmt_or(g[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; g[i][j] &lt;&lt; " \n"[j == m] ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dfs_part(<span class="number">1</span>, <span class="number">1</span>) ; dp2() ; revalue() ;</span><br><span class="line">    <span class="comment">//for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; I[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    ((m += <span class="number">1</span>) &gt;&gt;= <span class="number">1</span>) -= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans[j] = ans[j] - ans[j | (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == m] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撒花撒花！！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个人。给出 $n$ 个人的「认识情况」(双向且保证合法)。&lt;/p&gt;
&lt;p&gt;定义 &lt;code&gt;bool&lt;/code&gt; 值函数 $K(i,j)$ 表示两个人是否认识。考虑一个 $n$ 个人编号的排列 $p$ ，定义其生成的 $01$ 串 $\{s_{n-1}\}$ 为 $\forall i\in[1,n-1]\cap\mathbb{Z_+},s_i=K(p_{i},p_{i+1})$。&lt;/p&gt;
&lt;p&gt;统计对于 $2^{n-1}$ 种不同的 $01$ 串，有多少种排列可以生成它。&lt;/p&gt;
&lt;p&gt;F1: $2\leq n\leq 14$ 。&lt;/p&gt;
&lt;p&gt;F2 : $2\leq n\leq 18$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神仙计数题，再一次深深地明白了自己的弱小。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="快速莫比乌斯变换(FMT)" scheme="https://www.orchidany.cn/tags/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2-FMT/"/>
    
      <category term="快速沃尔什变换(FWT)" scheme="https://www.orchidany.cn/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
  </entry>
  
</feed>
