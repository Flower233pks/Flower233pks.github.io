<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>Love is a touch but yet not a touch</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-06T03:11:05.399Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>群论入门</title>
    <link href="http://yoursite.com/2019/02/06/%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/06/群论入门/</id>
    <published>2019-02-06T01:55:55.000Z</published>
    <updated>2019-02-06T03:11:05.399Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。</p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="1-群的定义"><a href="#1-群的定义" class="headerlink" title="$1~)~$群的定义"></a>$1~)~$群的定义</h2><p>比较简单的来讲，所谓<strong>群$(\rm{group})$</strong>指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质：</p><p>我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算：</p><h4 id="Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G"><a href="#Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G" class="headerlink" title="$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$"></a>$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$</h4><h4 id="Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c"><a href="#Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c" class="headerlink" title="$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$"></a>$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$</h4><h4 id="Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a"><a href="#Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a" class="headerlink" title="$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$"></a>$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$</h4><h4 id="Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e"><a href="#Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e" class="headerlink" title="$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$"></a>$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$</h4><p>那么也就是说的直白点吧，对所有的元素，做完该群所带有的<strong>带有结合律的运算</strong>之后，所得结果<strong>仍然属于该群</strong>且一定存在单位元，对于每个元素存在运算逆元。</p><p>那我们不妨定义一些其他的：</p><ul><li><h3 id="阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。"><a href="#阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。" class="headerlink" title="阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。"></a>阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。</h3></li><li><h3 id="半群：满足封闭性和结合律的群。"><a href="#半群：满足封闭性和结合律的群。" class="headerlink" title="半群：满足封闭性和结合律的群。"></a>半群：满足封闭性和结合律的群。</h3></li><li><h3 id="有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶"><a href="#有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶" class="headerlink" title="有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶"></a>有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶</h3></li></ul><p>结合几个例子来解释一下：</p><p>比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)$$, $$(R\setminus{0}~, ~\cdot)$$,$$ (C\setminus{0}~,~\cdot)$$</p><p>他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。</p><p>或者一个好玩儿的乘法群$$({1,-1}~~, ~~\cdot)​$$或者是所有<strong>非奇异的$n​$阶矩阵</strong>也可以组成一个乘法群。</p><p>或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断<strong>是否成群</strong>,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。</p><hr><p>$Extra \ \ Things :$</p><p>以下是两种复合抽代数据结构（名字自己起的$233$）：</p><h3 id="环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群"><a href="#环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群" class="headerlink" title="环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群"></a>环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群</h3><p>举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。</p><h3 id="域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群"><a href="#域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群" class="headerlink" title="域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群"></a>域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群</h3><p>举例子 ：$Q,R,C$即有理数域、实数域和复数域。</p><hr><p>好的，那我们尝试证明两个命题：</p><h3 id="Proposition1-一个群中的单位元唯一"><a href="#Proposition1-一个群中的单位元唯一" class="headerlink" title="$Proposition1~~~~$一个群中的单位元唯一"></a>$Proposition1~~~~$一个群中的单位元唯一</h3><p>设有两个单位元$e_1,e_2$</p><p>那么$e_1=e_1e_2=e_2$，其实是一个$233$</p><h3 id="Proposition2-群中元素的逆元唯一"><a href="#Proposition2-群中元素的逆元唯一" class="headerlink" title="$Proposition2~~~~$群中元素的逆元唯一"></a>$Proposition2~~~~$群中元素的逆元唯一</h3><p>以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$</p><p>显然也是同一个。</p><p>那么此时我打算整理一个群的共性特征：<br>$$(ab)^{-1}=b^{-1}a^{-1}$$</p><p>很显然，证明如下：<br>$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$</p><p>提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心</p><p>那么之后我们讨论<strong>周期</strong></p><p>对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$</p><p>$o(a)$表示最小正整数，使得$a^{o(a)}=e$</p><hr><h2 id="2-子群及衍生"><a href="#2-子群及衍生" class="headerlink" title="$2~)~$子群及衍生"></a>$2~)~$子群及衍生</h2><p>本节所指<strong>“群”</strong>没有特别说明便均为<strong>有限群</strong></p><p>不妨先给出子群的浅显版定义：</p><h3 id="如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示"><a href="#如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示" class="headerlink" title="如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示"></a>如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示</h3><p>那么从而我们可以定义<strong>生成子群</strong>这个东西：</p><p><strong>生成子群：若$S \subseteq G​$， 并且对于运算$C​$而言，$(G,C)​$也是一个群，那么就称$G​$为集合$S​$在运算$C​$下的生成子群。集合$S​$的生成子群用$&lt;​$$S​$$&gt;​$表示</strong></p><p>这之后我们就可以定义<strong>陪集</strong>这个概念</p><p>陪集一般上包含<strong>左陪集</strong>和<strong>右陪集</strong>。</p><h3 id="左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。"><a href="#左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。" class="headerlink" title="左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。"></a>左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。</h3><h3 id="右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。"><a href="#右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。" class="headerlink" title="右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。"></a>右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。</h3><p>$233$也可以叫做<strong>傍集</strong>或者<strong>旁系</strong>之类的~</p><p>那么我们这个地方先只研究右陪集$233$</p><h4 id="Lemma1"><a href="#Lemma1" class="headerlink" title="$Lemma1:$"></a>$Lemma1:$</h4><p>我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的<strong>群中元素数量</strong>。 </p><p>这个其实比较显然，因为事实上群都是定义在<strong>非可重集</strong>上面的。</p><p>较为严谨的证明如下：</p><hr><p>$Proof.$</p><p>对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$</p><p>反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾</p><p>对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$</p><hr><h4 id="Lemma2"><a href="#Lemma2" class="headerlink" title="$Lemma2:$"></a>$Lemma2:$</h4><p>之后我们再证明一些好玩儿的：</p><p>命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ </p><p>看起来好像不是那么好玩……</p><hr><p>$Proof.$</p><p>若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$</p><p>若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$</p><p>$hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$</p><p>因此$H_a=H_b$</p><hr><p>那么我们还可以有一个推论：</p><p>若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$</p><hr><p>$Proof.$</p><p>假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾</p><hr><p>从而还可以有个定理（$Lagrange$定理）：</p><p>由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么</p><p>$$|G|=|H|\cdot [G:H]$$</p><p>也就是说$|H|$是$|G|$的约数。</p><p>这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。</p><p>但是其实这是个很伟大的定理$233$ </p><hr><p>好的，那么从而就会有一些神奇的推论：</p><p><strong>推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | G$ </strong></p><p><strong>$Proof.$</strong> 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | G$ </p><p><strong>推论二：对任意的$a \in G,a ^{|G|} = e$</strong></p><p>$Proof.$ 比较显然，由推论一可知。</p><p><strong>推论三：若$|G|$为素数，则$G$是循环群</strong></p><p>$Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。</p><p>接下来我们真的要去做些好玩的了~</p><hr><h3 id="定理-1-·-Fermat-小定理"><a href="#定理-1-·-Fermat-小定理" class="headerlink" title="定理$1$·$Fermat$小定理"></a>定理$1$·$Fermat$小定理</h3><p>如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $</p><h3 id="Proof"><a href="#Proof" class="headerlink" title="$Proof. $"></a>$Proof. $</h3><p>考虑质数$p$，考虑群$G={1,2,\dots,p-1}$，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知：</p><p>$$\forall a\in G, a^{p-1}=1(\mod p)$$ </p><h3 id="定理2·-Euler-定理"><a href="#定理2·-Euler-定理" class="headerlink" title="定理2·$Euler$定理"></a>定理2·$Euler$定理</h3><p>$a^{\phi(n)}=1 (\mod n)$</p><p>###$Proof.$</p><p>考虑$n\in N^{+}$，考虑群$G={1\leq x\leq n~|~gcd(x,n)=1}$,群的运算定义为对$n$取模的乘法</p><p>那么会有$|G|=\phi(n)$，从而有：</p><p>$$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$</p><hr><p>没错，证明十分的简洁美观。</p><p>作者被这种神奇的证明给折服了$stO$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。&lt;/p&gt;
&lt;h1 id=&quot;群&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="抽象代数-群论" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E7%BE%A4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>$\rm{BSGS-Junior}$</title>
    <link href="http://yoursite.com/2019/02/06/BSGS-junior/"/>
    <id>http://yoursite.com/2019/02/06/BSGS-junior/</id>
    <published>2019-02-05T23:48:17.000Z</published>
    <updated>2019-02-06T02:12:03.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rm-0x01-mathcal-Preface"><a href="#rm-0x01-mathcal-Preface" class="headerlink" title="$\rm{0x01}$  $\mathcal{Preface}$"></a>$\rm{0x01}$  $\mathcal{Preface}$</h1><p><strong>$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法</strong>。当然也会被叫做<strong>拔山盖世</strong>、<strong>北上广深</strong>算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : </p><p>给定质数$p​$, 整数$a, b​$, $(a, p)=1​$.求最小的非负整数$x​$, 使得$$a^x≡ b~(\mod p)​$$</p><p>而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)​$，并且我们还知道$a^0=1≡1  ~(\mod p)​$，所以我们可以得出一个断言：</p><p><strong>如果方程$a^x≡ b~(\mod p)$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))$中</strong> $\qquad \qquad(1)$</p><p>我们尝试给出一个比较形式化的证明，大概需要用到一些抽代的知识：</p><p>$Proof.$</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rm-0x01-mathcal-Preface&quot;&gt;&lt;a href=&quot;#rm-0x01-mathcal-Preface&quot; class=&quot;headerlink&quot; title=&quot;$\rm{0x01}$  $\mathcal{Preface}$&quot;&gt;&lt;/a&gt;$\rm{0x0
      
    
    </summary>
    
    
      <category term="BSGS" scheme="http://yoursite.com/tags/BSGS/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>$LCT&#39;s ~Junior ~Intro$</title>
    <link href="http://yoursite.com/2019/02/04/LCT-s-Junior-Intro/"/>
    <id>http://yoursite.com/2019/02/04/LCT-s-Junior-Intro/</id>
    <published>2019-02-04T15:18:58.000Z</published>
    <updated>2019-02-05T23:45:56.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rm-0x01-闲话-·-LCT-的用途以及具体思路"><a href="#rm-0x01-闲话-·-LCT-的用途以及具体思路" class="headerlink" title="$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路"></a>$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路</h1><p>咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护<strong>森林连通性</strong>的。</p><p>嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。</p><p>但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为<strong>辅助树</strong>，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">$Luogu3391$</a>，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。</p><p>也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。</p><h1 id="rm-0x02-闲话-·-关于-rm-splay"><a href="#rm-0x02-闲话-·-关于-rm-splay" class="headerlink" title="$\rm{0x02}$ 闲话 · 关于$\rm{splay}$"></a>$\rm{0x02}$ 闲话 · 关于$\rm{splay}$</h1><p>道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？<del>后宫佳丽三千我该翻谁的牌子呢</del></p><p>历史的重任最后落到了$\rm{splay}​$的身上。然后$\rm{splay}​$他居然：</p><p><img src="t1.jpg" alt=""></p><p>他甚至还：</p><p><img src="t2.png" alt=""></p><p>……</p><p>好吧，由于某些<del>rqy也不知道的</del>原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$</p><h1 id="rm-0x03-LCT-的思路和基础操作"><a href="#rm-0x03-LCT-的思路和基础操作" class="headerlink" title="$\rm{0x03}$   $LCT$的思路和基础操作"></a>$\rm{0x03}$   $LCT$的思路和基础操作</h1><h2 id="一-主要思路"><a href="#一-主要思路" class="headerlink" title="一 主要思路"></a>一 主要思路</h2><p>主要思路嘛……大概是基于<strong>实链剖分</strong>的操作。</p><p><strong>朴素的树剖是重链剖分</strong>，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。</p><p>而实链剖分大体上就是把边分为<strong>虚边</strong>和<strong>实边</strong>。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。</p><p>实链剖分的好处呢？在于<strong>实链剖分是一种动态剖分</strong>，他可以<strong>随意改变边的虚实属性</strong>。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。</p><p>那么接下来我们来看一个$LCT​$是如何定义的:</p><ul><li>首先，一棵$LCT​$管控的是一对分散的点，点以几棵分散的$splay​$的形式聚集。起初整棵$LCT​$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access​$、$makeroot​$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT​$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。</li><li>实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。<strong>但是两种边都没有用到显式存储</strong>，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别：</li><li>虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。</li><li>实边是完整的双向存储。</li><li>$\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。</li><li>如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱.</li></ul><h2 id="二-基础操作"><a href="#二-基础操作" class="headerlink" title="二 基础操作"></a>二 基础操作</h2><p>$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作，我们这个地方先把点$n$所在联通块儿内的树的根记作$root(n) $，把与$n$以实边相连的儿子记作实儿子。</p><ul><li><h2 id="rm-1-Access"><a href="#rm-1-Access" class="headerlink" title="$\rm{1}$  $Access$"></a>$\rm{1}$  $Access$</h2></li></ul><p>这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是<strong>$Access(n)$表示从$root(n)$向$n$打通一条实链，并以$n$点为最深度最大的点、$root(n)$为深度最小的点形成一棵$\rm{splay}$</strong>。</p><p>不难看出，这个操作其实跟是一种<strong>逻辑层面的自我调控，没有改变原树的结构。</strong></p><p>我们思考，如果此时我们$Access​$完点$n​$之后，理论上来讲，$n​$点应该不再有实儿子了——显然，如果有实儿子的话，$splay​$中是应该包含这个实儿子的——而这就不符合$n​$是$\rm{splay}​$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}​$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}​$连上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">splay(x), rc = qwq, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这就是$Access​$了。</p><ul><li><h2 id="2-Make-Root"><a href="#2-Make-Root" class="headerlink" title="$2 ~~Make~ Root~$"></a>$2 ~~Make~ Root~$</h2></li></ul><p>$make_root​$先从原来的根向$n​$打通一条路径，然后$splay​$上去，最后$reverse​$一下。此处由于一开始$n​$的深度最大，$splay​$之后深度依旧最大，但此时$n​$是$splay​$的根，所以$reverse(n)​$就相当于翻转了整条树上的链，那么翻转之后，$n​$的深度就变成了最小，于是就是这个联通块儿的根节点了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line"><span class="keyword">while</span>(check(x))&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处$splay$中由于要下放标记，保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。</p><ul><li><h2 id="3-Merge"><a href="#3-Merge" class="headerlink" title="$3 ~Merge~$"></a>$3 ~Merge~$</h2></li></ul><p>此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="4-Link-amp-Cut"><a href="#4-Link-amp-Cut" class="headerlink" title="$4~~Link~\&amp;~Cut$"></a>$4~~Link~\&amp;~Cut$</h2></li></ul><p>如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ;  T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Merge(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br></pre></td></tr></table></figure><p>此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。        </p><p>但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作……</p><ul><li>$New-Link$ </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br></pre></td></tr></table></figure><p>此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233</p><p>但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。</p><p>多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根</p><ul><li>$New-Cut$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">Rooten(x) ; </span><br><span class="line"><span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; </span><br><span class="line">T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。</p><p>之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$Depth(x) &lt; Depth(y\text{的左儿子们})  &lt; Depth(y)$，其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。</p><p>剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。</p><ul><li><h2 id="5-Rotate-中的坑点"><a href="#5-Rotate-中的坑点" class="headerlink" title="5 $~Rotate$中的坑点"></a>5 $~Rotate$中的坑点</h2></li></ul><p>呃……其实就一处而已。就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g_fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$</p><p>剩下的……大概就没了吧……</p><p>于是——</p><h1 id="color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$"></a>$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk ;</span><br><span class="line"><span class="keyword">int</span> base[MAXN], N, M, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line"><span class="keyword">while</span>(check(x))&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) &#123;</span><br><span class="line">        rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">rep(i, <span class="number">1</span>, N) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">rep(i, <span class="number">1</span>, M)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C) ;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">0</span>) split(B, C), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[C].S) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="number">1</span>) Link(B, C) ; <span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="number">2</span>) Cut(B, C) ; <span class="keyword">else</span> splay(B), base[B] = C ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x00-后记和参考"><a href="#rm-0x00-后记和参考" class="headerlink" title="$\rm{0x00}$   后记和参考"></a>$\rm{0x00}$   后记和参考</h1><p>可写完了……嗝……<del>打个肥宅嗝犒劳犒劳自己</del></p><p>怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨……</p><p>写博客真是一个陶冶情操的过程啊……<del>包括做表情包</del></p><p>加油吧，$pks$！</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$Flash_Hu$的$blog$ <a href="http://www.cnblogs.com/flashhu/p/8324551.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :某篇论文，结合食用效果显著 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb.html" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></li></ul><h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rm-0x01-闲话-·-LCT-的用途以及具体思路&quot;&gt;&lt;a href=&quot;#rm-0x01-闲话-·-LCT-的用途以及具体思路&quot; class=&quot;headerlink&quot; title=&quot;$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路&quot;&gt;&lt;/a&gt;$\r
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LCT-Link Cut Tree" scheme="http://yoursite.com/tags/LCT-Link-Cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>$Intro$</title>
    <link href="http://yoursite.com/2019/02/04/Intro-1/"/>
    <id>http://yoursite.com/2019/02/04/Intro-1/</id>
    <published>2019-02-04T15:13:49.000Z</published>
    <updated>2019-02-05T12:39:14.350Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, here is <strong>Orchidany</strong>, a high-school student from S.D., China.</p><p>Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is <strong>Olympiad in Informatics</strong>，shorthanded for <strong>OI</strong>.  And this blog is mainly gonna to record my Learning Steps. </p><p>Although I’m a bit week by now, but I shall catch the glimmer and keep getting stronger!</p><p>See you soon in my articles !</p><p><em>Somthing Special</em></p><p>Errr…About this ID <em>Orchidany</em>, there is a theory about that:</p><p>My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) :</p><blockquote><h4 id="鹃住落英满，柳拂溪畔沙。"><a href="#鹃住落英满，柳拂溪畔沙。" class="headerlink" title="鹃住落英满，柳拂溪畔沙。"></a>鹃住落英满，柳拂溪畔沙。</h4><h4 id="南城略炊烟，浣女徐归家。"><a href="#南城略炊烟，浣女徐归家。" class="headerlink" title="南城略炊烟，浣女徐归家。"></a>南城略炊烟，浣女徐归家。</h4><h4 id="故人今安否，欲歌口偏哑。"><a href="#故人今安否，欲歌口偏哑。" class="headerlink" title="故人今安否，欲歌口偏哑。"></a>故人今安否，欲歌口偏哑。</h4><h4 id="笔寒下梅去，皎月半洒花"><a href="#笔寒下梅去，皎月半洒花" class="headerlink" title="笔寒下梅去，皎月半洒花"></a>笔寒下梅去，皎月半洒花</h4></blockquote><p>So……I’ m glad to encounter you!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello, here is &lt;strong&gt;Orchidany&lt;/strong&gt;, a high-school student from S.D., China.&lt;/p&gt;
&lt;p&gt;Algorithms, astrophysics, technology, that’s wh
      
    
    </summary>
    
    
      <category term="笔尖生花" scheme="http://yoursite.com/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
</feed>
