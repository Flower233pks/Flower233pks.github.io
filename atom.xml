<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-01-19T15:55:40.817Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-01-19T15:55:40.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-CsROvLyb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CsROvLyb"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/07/18/Nine/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center">咕</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2020/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2020/02/05/【公告】博客使用指南/</id>
    <published>2020-02-05T09:51:27.000Z</published>
    <updated>2020-02-06T12:39:15.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hey</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hey&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】杜教筛</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    <id>https://www.orchidany.cn/2020/01/24/杜教筛/</id>
    <published>2020-01-23T17:14:27.000Z</published>
    <updated>2020-01-30T14:42:04.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种比较快的筛法？</p><p>用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：</p><script type="math/tex; mode=display">\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>得出来的：</p><script type="math/tex; mode=display">\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。</p><a id="more"></a><p>似乎很简单？因为这种题的难点在于构造，构造完了就可以分块做了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">ll s = sum(<span class="number">1</span>, n, f * g) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>) </span><br><span class="line">    r = n / (n / l), s -= solve(n / l) * sum(<span class="number">1</span>, l, g) ;</span><br><span class="line"> <span class="keyword">return</span> (s /= g(<span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这么做的复杂度不对。考虑这样一个引理：</p><script type="math/tex; mode=display">\forall x,y,z\in\mathbb{Z},\quad \left\lfloor\frac{\left\lfloor\frac{z}{x}\right\rfloor}{y}\right\rfloor=\left\lfloor\frac{z}{x y}\right\rfloor</script><p>证明大概是把 $z$ 设成带余除法的标准形式，然后搞一下就可以了。此处略去。</p><p>于是发现，其实每次要计算的 $n’$ ，都是某个 $\lfloor \frac{n}{x}\rfloor$ ，因为假设这次是 $\lfloor \frac{n}{x}\rfloor$ ，下次是 $\lfloor \frac{\lfloor \frac{n}{x}\rfloor}{y}\rfloor=\lfloor \frac{n}{x\cdot y}\rfloor$ 。所以 $\sqrt n$ 为上界，可以直接通过 $\lfloor \frac{n}{x}\rfloor $ 记忆化所有的 $x$ 。</p><p>同时，发现对于 $x$ 的调用，都只会是 </p><script type="math/tex; mode=display">1,2,3\dots \sqrt n,\lfloor{\frac{n}{1}}\rfloor,\lfloor{\frac{n}{2}}\rfloor,\lfloor{\frac{n}{3}}\rfloor\dots\lfloor{\frac{n}{\sqrt n}}\rfloor</script><p>这些数，且每次计算 $\mathbf{S}$ 的复杂度都是 $\sqrt n$ 。所以最终复杂度是：</p><script type="math/tex; mode=display">O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{i}+\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\int_{1}^{\sqrt{n}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{\frac{3}{4}}\right)</script><p>其实就是两步近似。</p><p>然而可以做到更优，即发现对于一些很小的 $n’$ ，完全可以直接预处理出来。所以假设对于前 $p(0&lt;p&lt;1)$ 的 $\mathbf S$ 直接预处理，那么复杂度会变成：</p><script type="math/tex; mode=display">O\left(n^{p}+\sum_{i=1}^{n^{1-p}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(n^{p}+\int_{1}^{n^{1-p}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{p}+n^{1-\frac{1}{2} p}\right)</script><p>发现此时取 $p=\frac{2}{3}$ 为最优，所以复杂度 $O(n^{\frac{2}{3}})$。</p><p>草，据说这东西是 xudyh 在考场上构造出来的，这也太神了吧…</p><h1 id="1-例题"><a href="#1-例题" class="headerlink" title="$1$ 例题"></a>$1$ 例题</h1><h2 id="LG4213-【模板】杜教筛（Sum）"><a href="#LG4213-【模板】杜教筛（Sum）" class="headerlink" title="LG4213 【模板】杜教筛（Sum）"></a>LG4213 【模板】杜教筛（Sum）</h2><blockquote><p>求</p><script type="math/tex; mode=display">\begin{aligned}&a n s_{1}=\sum_{i=1}^{n} \varphi(i)\\&a n s_{2}=\sum_{i=1}^{n} \mu(i)\end{aligned}</script><p>$1\leq n\leq 2\times 10^9$</p></blockquote><p>考虑杜教筛。</p><p>考虑如何构造 $\varphi$ 的 $g$ 。发现有 $\sum_{d|n}\varphi(d)=n$，即 $\varphi <em> \mathbf{1}=\bf Id$，那么 $\bf f</em>g$ 就是 $\frac{n\cdot (n+1)}{2}$。</p><p>考虑如何构造 $\mu$ 的 $g$ 。发现有 $\sum_{d|n}\mu(d)=[n=1]$，即 $\mu <em> \bf 1 = ϵ$，那么 $\bf f</em>g$ 就是 $[n=1]$。</p><p>然后就没有然后了。去年 $6$ 月我写的是不带记忆化的，慢的很。今天重写加了记忆化，复杂度看起来还可以？但是不知道为啥被 <code>min_25</code> 吊着锤。(其实也就快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXS 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> T, N, S ; </span><br><span class="line"><span class="keyword">bool</span> chk[MAXN] ; </span><br><span class="line">LL phi[MAXN], Mu[MAXN] ; </span><br><span class="line">LL Smu[MAXS], Sphi[MAXS] ;</span><br><span class="line"><span class="keyword">int</span> pr[MAXN], t, i, j, x ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">Mu[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; MAXN ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!chk[i]) </span><br><span class="line">      pr[++ t] = i, Mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= t &amp;&amp; pr[j] * i &lt; MAXN ; ++ j)&#123;</span><br><span class="line">chk[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123; </span><br><span class="line">        phi[i * pr[j]] = phi[i] * pr[j] ; </span><br><span class="line">        <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">      Mu[i * pr[j]] = - Mu[i],</span><br><span class="line">        phi[i * pr[j]] = phi[i] * phi[pr[j]] ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; MAXN ; ++ i) Mu[i] = Mu[i - <span class="number">1</span>] + Mu[i], phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_Mu</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> Mu[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Smu[p]) <span class="keyword">return</span> Smu[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Smu[N / p]) <span class="keyword">return</span> Smu[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_Mu(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Smu[N / p] = ret) : (Smu[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> phi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Sphi[p]) <span class="keyword">return</span> Sphi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Sphi[N / p]) <span class="keyword">return</span> Sphi[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1l</span>l * (<span class="number">1</span> + p) * p / <span class="number">2L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_phi(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Sphi[N / p] = ret) : (Sphi[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T, init() ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N, S = <span class="built_in">sqrt</span>(N) ;</span><br><span class="line">        <span class="built_in">memset</span>(Smu, <span class="number">0</span>, <span class="keyword">sizeof</span>(Smu)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Sphi, <span class="number">0</span>, <span class="keyword">sizeof</span>(Sphi)) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get_phi(N) &lt;&lt; <span class="string">" "</span> &lt;&lt; get_Mu(N) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="$3$ 高级应用"></a>$3$ 高级应用</h1><p> 高级应用：我不是很会的应用（</p><blockquote><p>求</p><script type="math/tex; mode=display">\left(\sum_{i=1}^{n} \sum_{j=1}^{n} i \cdot j \cdot \operatorname{gcd}(i, j)\right) \bmod p</script><p>$p\in \mathbb{P},1\leq n\leq 10^{10}$ .</p></blockquote><p>首先是朴素反演：</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=1}^{n} i\cdot j\cdot \operatorname{gcd}(i, j)\\=&\sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot\sum_{d|i\operatorname{and}d|j} \varphi(d)\\=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}i\cdot j\\=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \left(\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\right)^2\\\end{aligned}</script><p>然后发现前面都是完全积性，后面那个平方里面还带着求和不是很好搞…</p><p>这个地方有个很牛的引理：</p><script type="math/tex; mode=display">\left(\sum_{i=1}^xi\right)^2=\sum_{i=1}^{x}i^3</script><p>这东西大概是能归纳出来的。似乎还没有什么比较有趣的证明<del>约等于只能选择背过</del></p><p>然后就是</p><script type="math/tex; mode=display">\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}p^3</script><p><del>发现都比较容易算，并且都积性，于是就可以直接杜教筛了。</del></p><p>上句话在扯 $p$。后面那一坨根本没法筛。于是考虑整除分块套一个杜教筛。这样复杂度还是 $n^{\frac{2}{3}}$ ！！这点很重要！！因为本质上我的整除分块还是在枚举某些 $\lfloor\frac{\lfloor\frac{n}{l}\rfloor}{x}\rfloor$。于是该记下来的不多不少，还是记下来了，复杂度不变。</p><p>代码实现有点细节，还需要多学习多积累。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; pq ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXNN], chk[MAXN] ;</span><br><span class="line">LL Inv6, Inv4, cnt, p[MAXNN] ;</span><br><span class="line">LL P ; LL N, Sp[MAXN], phi[MAXNN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL l, LL r)</span></span>&#123;</span><br><span class="line">    l -- ; l %= P, r %= P ;</span><br><span class="line">    LL r1 = r * (r + <span class="number">1</span>) % P * (<span class="number">2</span> * r + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    LL r2 = l * (l + <span class="number">1</span>) % P * (<span class="number">2</span> * l + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    <span class="keyword">return</span> ((r1 - r2) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calcc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans ; x %= P ;</span><br><span class="line">    ans = x * x % P ;</span><br><span class="line">    (ans *= Inv4) %= P ;</span><br><span class="line">    (ans *= (x + <span class="number">1</span>) % P * (x + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; MAXNN)</span><br><span class="line">        <span class="keyword">return</span> phi[x] ;</span><br><span class="line">    LL y = N / x ;</span><br><span class="line">    <span class="keyword">if</span> (chk[y]) <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">    chk[y] = <span class="number">1</span> ; LL &amp;ans = Sp[y] ;</span><br><span class="line">    ans = calcc(x) ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l),</span><br><span class="line">        (ans -= calc(l, r) * solve(x / l) % P) %= P ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += P ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l) ;</span><br><span class="line">        (res += (solve(r) - solve(l - <span class="number">1</span>)) * calcc(x / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; N ; phi[<span class="number">1</span>] = vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    Inv4 = expow(<span class="number">4</span>, P - <span class="number">2</span>), Inv6 = expow(<span class="number">6</span>, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXNN ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] * i &gt;= MAXNN) <span class="keyword">break</span> ;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * p[j]] = phi[i] * p[j] % P ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]] % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXNN ; ++ i) </span><br><span class="line">      (phi[i] = <span class="number">1l</span>l * i * i % P * phi[i] + phi[i - <span class="number">1</span>]) %= P ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; phi[8000000] &lt;&lt; endl ; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, work(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一种比较快的筛法？&lt;/p&gt;
&lt;p&gt;用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\
\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)&lt;/script&gt;&lt;p&gt;得出来的：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)&lt;/script&gt;&lt;p&gt;如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="杜教筛" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/积性函数求和/杜教筛" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C-%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#2353 [NOI2007]货币兑换</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/"/>
    <id>https://www.orchidany.cn/2020/01/24/货币兑换/</id>
    <published>2020-01-23T16:45:56.000Z</published>
    <updated>2020-02-05T02:48:40.677Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某CDQ好题.</p><p><del>没人看出上面这句话是有俩含义吗</del></p><a id="more"></a><p>小Y最近在一家金券交易所工作。该金券交易所只发行交易两种金券：$A$ 纪念券（以下简称 $A$ 券）和 $B$ 纪念券（以下简称 $B$ 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。</p><p>每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 $A$ 券和 $B$ 券的价值分别为 $A_K$ 和 $B_K$ （元/单位金券）。</p><p>为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。</p><p>比例交易法分为两个方面：</p><p>a) 卖出金券：顾客提供一个 $[0，100]$ 内的实数 $\rm OP$ 作为卖出比例，其意义为：将 $\rm OP\%$ 的 $A$ 券和 $\rm OP\%$ 的 $B$ 券以当时的价值兑换为人民币；</p><p>b) 买入金券：顾客支付 $\rm IP$ 元人民币，交易所将会兑换给用户总价值为 $\rm IP$ 的金券，并且，满足提供给顾客的 $A$ 券和 $B$ 券的比例在第 $K$ 天恰好为 $\rm Rate_K$ ；</p><p>小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $\rm N$ 天内的 $A$ 券和 $B$ 券的价值以及 $\rm Rate$。他还希望能够计算出来，如果开始时拥有 $\rm S$ 元钱，那么 $\rm N$ 天后最多能够获得多少元钱。</p><p>其中 $\rm N\leq 10^5$.</p><p>首先想到 $dp$ 。这个地方设计的 $dp$ 个人感觉还是比较 $\rm tricky$ 的。发现本质上最大化 $A$ 券或者 $B$ 券的数量和最大化手里拿到的rmb都是某些最优决策，所以不能一起维护。</p><p>发现通过券来维护rmb比较方便，于是考虑设 $f_i$ 表示在第 $i$ 天把rmb都花完能得到多少 $A$ 券。初值显然是</p><script type="math/tex; mode=display">m=f_1\cdot A_1+\frac{f_1\cdot B_1}{\rm Rate_1}\\f_1=\frac{m\cdot\mathrm{Rate_1}}{A_1\cdot \mathrm{Rate_1}+B_1}</script><p>那么考虑如何以此计算rmb。发现第 $i$ 天可能会保有 $1\sim i-1$ 天时的金券。于是令 $g_i$ 表示前 $i$ 天的最大获利，发现可以这么转移：</p><script type="math/tex; mode=display">g_i=\max_{1\leq j<i}(g_{i-1},f_j\cdot (A_i+\frac{B_i}{\rm Rate_j}))</script><p>转移的正确性在于，卖出的 $A$ 券和 $B$ 券的百分比必须一致，所以不会出现分多次卖的情况。于是喜提一个 $n^2$ 算法。</p><p>考虑优化。发现如果对于一个 $i$ 其转移点为 $j$，那么会有：</p><script type="math/tex; mode=display">\begin{aligned}g_i&=f_j\cdot A_i+f_j\cdot \frac{B_i}{\rm Rate_j}\\\frac{f_j}{\mathrm{Rate_j}}&=-\frac{A_i}{B_i}\cdot f_j+\frac{g_i}{B_i}\end{aligned}</script><p>发现可以令 $y_i=\frac{f_i}{\mathrm{Rate_i}},x_i=f_i$ 。那么这就是一个斜率优化的标准形式。</p><p>但问题在于，$f_j$ 很悲惨的由于每天的兑换量有不同，它并不单增，并且斜率也不单增，所以不能用删除末尾几个（即单调队列）来维护凸壳，必须要用某些神秘 $\rm splay$ 技巧来加速这个过程。</p><p>然而还有另一种 $\rm CDQ$ 写法。大概就是考虑为了保证横坐标是单调的，所以要排序，但是排序之后转移就会失秩，而这个过程显然可以 $\rm CDQ$ 来优化，于是就没了。</p><p>值得注意的是，朴素的 $\rm CDQ$ 由于不需要严格按秩，即二进制拆分顺序不限，所以可以瞎分治。但是维护 $dp$ 的时候由于转移顺序必须按秩，所以有严格的分治顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cash</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, k ;</span><br><span class="line">    <span class="keyword">double</span> A, B, R ; <span class="keyword">int</span> ID ;</span><br><span class="line">&#125;T[MAXN], Div[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">double</span> M ; <span class="keyword">double</span> dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">double</span> Ans, t ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Ans = M, dp[<span class="number">1</span>] = M * T[<span class="number">1</span>].R / (T[<span class="number">1</span>].A * T[<span class="number">1</span>].R + T[<span class="number">1</span>].B) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">                Ans = max(Ans, dp[j] * T[i].A + dp[j] / T[j].R * T[i].B) ;</span><br><span class="line">            dp[i] = Ans * T[i].R / (T[i].A * T[i].R + T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, Ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CDQ&#123;</span><br><span class="line">    <span class="keyword">int</span> stk[MAXN] ; <span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e9</span>, eps = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Cash &amp; A, <span class="keyword">const</span> Cash &amp; B)</span></span>&#123; <span class="keyword">return</span> A.k &lt; B.k ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(T[d].x - T[b].x) &lt;= eps) <span class="keyword">return</span> INF ;</span><br><span class="line">        <span class="keyword">return</span> (T[d].y - T[b]. y) / (T[d].x - T[b].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L, r = Mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= Mid &amp;&amp; (r &gt; R || T[l].x &lt; T[r].x))</span><br><span class="line">        Div[i] = T[l ++]; <span class="keyword">else</span> Div[i] = T[r ++] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dp_CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">            dp[L] = max(dp[L], dp[L - <span class="number">1</span>]) ;<span class="comment">//?</span></span><br><span class="line">            T[L].y = dp[L] / (T[L].A * T[L].R + T[L].B), T[L].x = T[L].y * T[L].R ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//y : f[j] / Rate[j], x : f[j]。此处应该以f[j]单增来排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l = L - <span class="number">1</span>, r = Mid ; <span class="keyword">int</span> top = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (T[i].ID &lt;= Mid) Div[++ l] = T[i] ; <span class="keyword">else</span> Div[++ r] = T[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ; dp_CDQ(L, Mid) ; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= Mid ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt; getr(stk[top], i)) -- top ;</span><br><span class="line">            stk[++ top] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = Mid + <span class="number">1</span> ; i &lt;= R ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt;= T[i].k) -- top ;</span><br><span class="line">            dp[T[i].ID] = max(dp[T[i].ID], T[stk[top]].x * T[i].A + T[stk[top]].y * T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        dp_CDQ(Mid + <span class="number">1</span>, R), Merge_sort(L, R, Mid) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = M ;</span><br><span class="line">          sort(T + <span class="number">1</span>, T + N + <span class="number">1</span>, Compare) ;</span><br><span class="line">          dp_CDQ(<span class="number">1</span>, N) ; <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, dp[N]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen("1492.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//     freopen("1492.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;T[i].A, &amp;T[i].B, &amp;T[i].R),</span><br><span class="line">      T[i].k = -T[i].A / T[i].B, T[i].ID = i ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>) DP :: Solve1() ;</span><br><span class="line">      <span class="keyword">else</span> CDQ :: Solve2() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某CDQ好题.&lt;/p&gt;
&lt;p&gt;&lt;del&gt;没人看出上面这句话是有俩含义吗&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】CDQ分治</title>
    <link href="https://www.orchidany.cn/2020/01/24/CDQ%E5%88%86%E6%B2%BB/"/>
    <id>https://www.orchidany.cn/2020/01/24/CDQ分治/</id>
    <published>2020-01-23T16:45:38.000Z</published>
    <updated>2020-02-01T16:14:35.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是对操作分治的算法，算是我最早学过的离线分治算法了？</p><p>大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。</p><p>那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 </p><a id="more"></a><h1 id="loj-112-模板-三维偏序"><a href="#loj-112-模板-三维偏序" class="headerlink" title="loj#112 [模板]三维偏序"></a>loj#112 [模板]三维偏序</h1><blockquote><p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$、$b_i$、$c_i$三个属性。</p><p>设 $f_i$ 表示满足 $a_j\leq a_i$ 且 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的 $j$ 的数量。</p><p>对于 $\forall i \in [0,n)$ ，求 $f_j=i$ 的 $j$ 的数量。</p></blockquote><p>这不是传统意义上的 $\rm CDQ$ 。考虑 $\rm CDQ$ 在维护本质上是在维护一系列权值，通过分治统计前面对后面的贡献，类似于通过分治对全局的询问做时间上的二进制拆分。所以其实具有类似拆分性质的统计都可以这么实现。</p><p>回到这题，发现本质上三维数点也可以直接通过 $\rm CDQ$ 解决。考虑在分治完后，需要统计本层左区间对右区间的贡献。这时直接bit+扫描线即可，即按照一维排序，另一维用bit维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, K, bit[MAXN], res[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span> <span class="keyword">int</span> x, y, z, ans ; &#125;base[MAXN], t[MAXN] ;</span><br><span class="line">il <span class="keyword">bool</span> <span class="keyword">operator</span> == (nodes a, nodes b)&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x == b.x) &amp; (a.y == b.y) &amp; (a.z == b.z) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; p ; p -= low(p)) ret += bit[p] ; </span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r ; </span><br><span class="line">cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R) ;  </span><br><span class="line">sort(base + L, base + Mid + <span class="number">1</span>, comp2), l = L ;</span><br><span class="line">sort(base + Mid + <span class="number">1</span>, base + R + <span class="number">1</span>, comp2), r = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].y &lt;= base[r].y) </span><br><span class="line">upd(base[l].z, <span class="number">1</span>), ++ l ; </span><br><span class="line">base[r].ans += qry(base[r].z), ++ r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt; l ; ++ i) upd(base[i].z, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, o ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base[i].x = qr(), base[i].y = qr(), base[i].z = qr() ; </span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; cdq(<span class="number">1</span>, N) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, j = o = <span class="number">0</span> ; i &lt;= N ; j = o = <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span> (base[i] == base[i - <span class="number">1</span>]) ++ i, ++ j ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) o = max(o, base[k].ans) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) base[k].ans = o ; <span class="keyword">if</span> (!j) ++ i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[base[i].ans] ++ ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Violet-天使玩偶-SYJ摆棋子"><a href="#Violet-天使玩偶-SYJ摆棋子" class="headerlink" title="[Violet] 天使玩偶/SYJ摆棋子"></a>[Violet] 天使玩偶/SYJ摆棋子</h1><blockquote><p>给定一张 $n\times m$ 的网格。</p><p>有两个操作，插入一个新的点或者询问离某个点欧几里得距离最近的点。</p><p>$n,m\leq 3\times10^5$ </p></blockquote><p>发现欧几里得距离即：</p><script type="math/tex; mode=display">|x_i-x_j|+|y_i-y_j|</script><p>通过分类讨论可以得到有这么四类情况：</p><script type="math/tex; mode=display">x_i-x_j+y_i-y_j\\x_i-x_j-y_i+y_j\\-x_i+x_j+y_i-y_j\\-x_i+x_j-y_i+y_j\\</script><p>发现，其中第二种情况就是第一种按照 $x$ 轴对称了一下的结果，后两种类似。于是可以通过坐标变换都转化到第一种问题。</p><p>对于第一个问题，发现询问可以分段处理，于是想到 $\rm CDQ$ 。考虑如何处理离自己最近的点：</p><script type="math/tex; mode=display">x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)</script><p>这样转化出来的两部分即具有差分性质（即可以拆），并且保证了只与时间轴有关（不再和网格图有关）。所以可以把 $x_i+y_i$ 插入进去，这样就可以用四遍 $\rm CDQ$ 做完这题了。</p><p>感觉还是很神仙的吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 192608170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, bit[MAXM], ans[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrys</span>&#123;</span> <span class="keyword">int</span> mk, id, x, y ; &#125;t[MAXN], q[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch_top 24000001</span></span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">7</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K &amp;&amp; bit[p] ; p += low(p)) bit[p] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] = max(bit[p], v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; p ; p -= low(p)) ret = max(ret, bit[p]) ; </span><br><span class="line"><span class="keyword">return</span> ret ? ret : -Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> ; </span><br><span class="line">rg <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r, o = L ; </span><br><span class="line">cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R), l = L, r = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].x &lt;= base[r].x)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[l].mk &lt; <span class="number">2</span>) </span><br><span class="line">upd(base[l].y, base[l].x + base[l].y) ; </span><br><span class="line">t[o ++] = base[l ++] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (base[r].mk &gt; <span class="number">1</span>) </span><br><span class="line">ans[base[r].id] = min(ans[base[r].id], </span><br><span class="line">  base[r].x + base[r].y - qry(base[r].y)) ; </span><br><span class="line">t[o ++] = base[r ++] ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt; l ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (base[i].mk &lt; <span class="number">2</span>) del(base[i].y) ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= Mid) t[o ++] = base[l ++] ; </span><br><span class="line">  <span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) base[i] = t[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ox, <span class="keyword">const</span> <span class="keyword">int</span> &amp;oy)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">base[i] = q[i] ; </span><br><span class="line">base[i].x = ox ? q[i].x : K - q[i].x, </span><br><span class="line">base[i].y = oy ? q[i].y : K - q[i].y ;</span><br><span class="line">&#125;</span><br><span class="line">cdq(<span class="number">1</span>, N + M) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data1.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//freopen("data1.out", "w", stdout) ;</span></span><br><span class="line">fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">N = read(), M = read() ; <span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">q[i].mk = <span class="number">1</span>, q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) </span><br><span class="line">q[i].mk = read(), q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">solve(<span class="number">1</span>, <span class="number">0</span>), solve(<span class="number">0</span>, <span class="number">1</span>), solve(<span class="number">1</span>, <span class="number">1</span>), solve(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="keyword">if</span> (q[i].mk &gt; <span class="number">1</span>) write(ans[i]) ;</span><br><span class="line">fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不知道啥时候才能真正地灵活运用…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是对操作分治的算法，算是我最早学过的离线分治算法了？&lt;/p&gt;
&lt;p&gt;大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。&lt;/p&gt;
&lt;p&gt;那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 &lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CDQ分治" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CDQ%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="离线算法/CDQ分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【生活碎片3】· Life is strange</title>
    <link href="https://www.orchidany.cn/2020/01/24/Life3/"/>
    <id>https://www.orchidany.cn/2020/01/24/Life3/</id>
    <published>2020-01-23T16:42:37.000Z</published>
    <updated>2020-02-03T15:33:06.663Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Life is strange, no matter who u are.</p></blockquote><a id="more"></a><p>初逢「奇异人生」这款游戏，还是从C菌那里了解的。但是这次不同以往，发现这东西在Mac上完全带的起来，于是就决定自己在steam上买来玩儿。虽然没有汉化，但是基本上还是很流畅的（除了有时候由于不知道在说哪国英语而疯狂卡关）。最后从C菌那里也成功地看到了第二个结局。</p><p>至于「奇异人生二」，则完全是在看C菌的实况。从19年 $4$ 月的第三章等到 $8$ 月，接着等到 $12$ 月，这部被先入为主的粉丝批评「没有第一部好」的杰作，终于迎来了它的 $\rm Ending$。结局共 $4$ 个，都体现了很高的「讲故事」水平，个人来讲这可能是我能想到最好的结局。</p><p>会有三吗？可能会有吧。对我来说，这是个有温度的公司，制作的有温度的游戏。每一帧画面、每一首 $\rm bgm$ 都是在不紧不慢地叙事，交织成一条缓缓流淌的河，流过主人公的奇异人生，流向远方。</p><p>那其中或许昭示着，每一种不同的生命状态都有其存在的意义和价值。换句话说，不论你活成什么样，都值得继续活下去。因为人生的意义，就在于活着。</p><!--more--><h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>其实 「奇异人生1」的剧情已经在 「随想9」里面说了很多啦。大概就是讲的两个妹子之间无可撼动的友谊遇上了滥用会导致天灾的超能力，最后（我选择）把 $\rm Acadia~ Bay$ 整个牺牲了换妹子的故事。</p><p>其实 $1$ 里面的剧情也好、世界也好，都仅仅是局限在 $\rm Acadia~ Bay$ 的一角而已，比起「二」中的「竖跨美国」来讲十分的狭窄。所以如果说「二」的主题是「成长」与「勇气」，那么「一」的主题可能会是「成长」与 「赋予意义」。</p><p>$\rm Max$ 生活的城市其实并不很好，学校里的环境也不完美。然而从 $\rm Max$ 掌握了超能力开始，她似乎可以拯救周围的一切了——救下要自杀的同学、解决了人际关系的漏洞、数次救回了在死亡边缘疯狂试探的 $\rm Cloye$ 。但是无论怎么改，到最后都无法创造一个完美的结局——可以说，到最后，让 $\rm Cloye$ 活着才是她最希望且唯一希望的事。</p><p>但其实，似乎制作者钦定的结局是牺牲 $\rm Cloye$ 而不是 $\rm Acadia~Bay$。这或许就更好地揭示了「赋予意义」这层含义：生活其实本身就是那样地充满 “$\rm Obstacles$” ，也没有什么可以拯救一切的超能力（因为 $\rm Max$ 的超能力滥用会导致日食、双月、飓风等非自然现象），所以大家都只是平凡活着的平凡人，做着自己喜欢的平凡的事，人生是否「奇异」不在于自己获得了什么天助的能力，在于给自己的平凡生活赋予了什么不凡的意义。「碌碌无为」的牢笼需要自己走出，拥有再强的超能力也只是加速了自己原地打转的速度而已。所以，可能学会「赋予意义」才是让每天都可以「翩翩起舞」的最佳方案。</p><p>所以最后 $\rm Cloye$ 被剧情杀了。可能这也是在告诉 $\rm Max$ 和我们，一切美好的东西都会逝去，如何对接下来的生活更好地赋予意义，才是真正需要思考的问题。</p><p>「一」中最受好评的，可能是其最后两章的叙事手法，简直是神来之笔。一遍遍回溯、一遍遍寻找，交叠的空间与时间，$\rm Max$ 拯救 $\rm Cloye$ 的过程，让人十分动容。</p><h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>「奇异人生二」跟「一」不同。主角兄弟俩一开始过着平稳安逸的生活，被突如其来的冲突打乱、被视为通缉犯，决定南下去墨西哥开启新生活，并在途中经历了一系列波折。这其中没有「一」中奇诡的剧情，但是横跨了比「一」更大的时空。</p><p>其实呢，「二」遭人诟病，是因为剧情比起「一」来水了很多。「二」中的作画和配乐依旧优秀、细节处理依然到位，但是剧情很薄。比起「一」中 $\rm Max$ 和 $\rm Cloye$ 无比真挚的友谊，「二」中没有激烈的情感喷薄，只是在淡淡地叙事罢了。</p><p>但是，「二」的剧情似乎被最后的结局给救了回来。最后一共有四个结局：</p><ul><li>1：弟弟用超能力炸毁了边境大门，和哥哥一起去了墨西哥。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「冲」才可以达成。最后他们在墨西哥开了间修车厂，过上了黑帮的生活。个人感觉不是一个很好的结局，因为本身他俩都是受害者，经历劫难之后似乎根本没有走出阴影，也就是「成长」的味道比较浅。</li><li>2：哥哥选择投降，但是弟弟不投降，执意冲过边境线但导致哥哥被流弹击杀。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「不冲」才可以达成。最后弟弟一个人在墨西哥开启了新的「秧歌star」生活…我觉得应该是最烂的结局了233</li><li>3：哥哥选择投降，弟弟也选择投降。这需要选择「不冲」并且弟弟被玩家教育的很懂事才可以。最后当然是哥哥被关了 $20+$ 年，弟弟由于是未成年人并且自首啥事没有，出来已经是中年人了。也不是很好吧233</li><li>4：哥哥选择冲，弟弟选择帮他炸开边境但是自己留了下来、接受制裁。这是我认为最好的结局。哥哥路上经历的一切有了报偿，弟弟也不再一味索求，选择主动奉献。最后的结局很美。哥哥在墨西哥给弟弟写信，弟弟在美国的外公外婆家里读信。两人都成长了、收获了自己应有的生活。</li></ul><p>「二」中的剧情，是慢慢地讲述着的。无论是他们重逢了他们的母亲，还是路上遇到一切的艰难险阻，都如同一条均匀地洒满金箔的河流，慢慢地流淌，慢慢地把闪光点展露出来。</p><p>这是 $\rm B$ 站里面四个结局的 $\rm Link$：<a href="https://www.bilibili.com/video/av78032043?from=search&amp;seid=1274319984559483706" target="_blank" rel="noopener">戳我</a></p><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>「二」中也或多或少直径了第一部，于是会根据玩家第一部选择的是牺牲 $\rm Cloye$ 还是 $\rm Acadia~Bay$ 流了不同的彩蛋。</p><p>最后留个 $\rm Link$ 吧：<a href="https://www.bilibili.com/video/av78454677?from=search&amp;seid=2854200599543211488" target="_blank" rel="noopener">戳我</a> </p><p>你问我为什么不像以前一样写很长的篇末总结？</p><p>对于这种十分美好的东西，「让它淡淡的来，让他好好的去」才是最恰当的方案吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Life is strange, no matter who u are.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【探究】用LCT维护MST</title>
    <link href="https://www.orchidany.cn/2020/01/24/LCT3/"/>
    <id>https://www.orchidany.cn/2020/01/24/LCT3/</id>
    <published>2020-01-23T16:42:27.000Z</published>
    <updated>2020-01-31T13:06:22.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。</p><p>说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。</p><p>似乎很简单？就是很简单。</p><a id="more"></a><h1 id="LG3366-【模板】最小生成树"><a href="#LG3366-【模板】最小生成树" class="headerlink" title="LG3366 【模板】最小生成树"></a>LG3366 【模板】最小生成树</h1><p>就是贴个代码?</p><p>值得注意的是，需要把每一条边加入点，删除的话就只需要把与这条边相连的点之间的边断掉。</p><p>似乎没啥难的？LCT虽然说很长，但是似乎写起来很轻松诶。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(k) e[k].vl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vl ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> val[M] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span>, swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), access(v), splay(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), fa(u) = v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    split(u, v) ;</span><br><span class="line">    fa(u) = lc(v) = <span class="number">0</span> ;</span><br><span class="line">    update(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//access(to(x)) ; </span></span><br><span class="line">splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)),</span><br><span class="line">        qr(to(i)), qr(vl(i)) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; vl(i) &lt;&lt; endl ;</span></span><br><span class="line">        fr(i) += m, to(i) += m ;</span><br><span class="line">        make_root(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(fr(i)) != to(i))</span><br><span class="line">            ans += vl(i), link(fr(i), i), link(to(i), i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[fr(i)]))&#123;</span><br><span class="line">ans += vl(i) - vl(val[fr(i)]) ;</span><br><span class="line">        cut(val[fr(i)]), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WC2006-水管局长"><a href="#WC2006-水管局长" class="headerlink" title="[WC2006]水管局长"></a>[WC2006]水管局长</h1><blockquote><p>要求动态维护一张图。</p><p>只有删边操作、动态询问 $x$ 到 $y$ 间所有路径上最大边权的最小值。</p></blockquote><p>那显然是在最小生成树上跑。</p><p>既有加边也有删边的MST是没法做的。因为删边的时候可能有一堆候选集合，这是无法简单维护的。但是只有加边或者只有删边的MST很简单。由于只有删边，所以倒着做一遍就完了。</p><p>hiahiahia，快来欣赏一下我特别棒的码风：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> o, u, v ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; to(i))</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        Id[mk_p(fr(i), to(i))] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span> ; i &lt;= m + q ; ++ i)&#123;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) &lt;= <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">            swap(u, v),</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        o = Id[mk_p(u, v)] ;</span><br><span class="line">        vis[o] = <span class="number">1</span>, mem[i] = o ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        u = fr(i) ;</span><br><span class="line">        v = to(i) ;</span><br><span class="line">        make_root(v) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">            link(u, i) ;</span><br><span class="line">            link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[u]))&#123;</span><br><span class="line">            dcut(val[u]) ;</span><br><span class="line">            link(u, i) ; link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + q ; i &gt; m ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">int</span> j = mem[i] ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) == <span class="number">1</span>)&#123;</span><br><span class="line">            merge(u, v) ;</span><br><span class="line">            ans[i - m] = vl(val[v]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            u = fr(j) ;</span><br><span class="line">            v = to(j) ;</span><br><span class="line">            make_root(v) ;</span><br><span class="line">            ans[i - m] = <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">                link(u, j) ;</span><br><span class="line">                link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vl(j) &lt; vl(val[fr(j)]))&#123;</span><br><span class="line">                dcut(val[u]) ;</span><br><span class="line">                link(u, j) ; link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOI2014-魔法森林"><a href="#NOI2014-魔法森林" class="headerlink" title="[NOI2014]魔法森林"></a>[NOI2014]魔法森林</h1><blockquote><p>给出一个 $n$ 个点，$m$ 条边的无向图，每条边都有权值 $a_i,b_i$ 。</p><p>求一条从点 $1$ 到点 $n$ 的路径，使得这条路径上边的 $a_i,b_i$ 最大值之和最小。</p><p>$2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5$。</p></blockquote><p>发现可以先把边权按照第一维排个序，然后做普通的lct维护MST就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        merge(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            merge(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我在水博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。&lt;/p&gt;
&lt;p&gt;说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。&lt;/p&gt;
&lt;p&gt;似乎很简单？就是很简单。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="数据结构/LCT" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LCT/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】LCT简单题选做</title>
    <link href="https://www.orchidany.cn/2020/01/24/LCT2/"/>
    <id>https://www.orchidany.cn/2020/01/24/LCT2/</id>
    <published>2020-01-23T16:42:14.000Z</published>
    <updated>2020-01-31T14:09:09.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是重学了一遍 $\rm LCT$。然后整理一下之前做过的题？大多数都比较套路。</p><a id="more"></a><h1 id="SDOI2008-洞穴勘测"><a href="#SDOI2008-洞穴勘测" class="headerlink" title="[SDOI2008]洞穴勘测"></a>[SDOI2008]洞穴勘测</h1><blockquote><p>动态维护图的连通性。</p><p>保证任意时刻图的边数不超过 $n-1$ 条。</p></blockquote><p>发现是个sb线段树分治，然后随便写个lct就过了（</p><h1 id="COCI-2009-OTOCI-极地旅行社"><a href="#COCI-2009-OTOCI-极地旅行社" class="headerlink" title="[COCI 2009] OTOCI / 极地旅行社"></a>[COCI 2009] OTOCI / 极地旅行社</h1><blockquote><p>给出一张空图</p><ul><li><p><code>bridge u v</code>：询问结点 u与结点 $v$ 是否连通。如果是则输出 <code>no</code>；否则输出 <code>yes</code>，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。</p></li><li><p><code>penguins u x</code>：将结点 $u$ 对应的权值$ w_u$ 修改为 $x$。</p></li><li><p><code>excursion u v</code>：如果结点 $u$ 和结点 $v$ 不连通，则输出 <code>impossible</code>。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。</p></li></ul><p>保证两点存在至多一条路径。</p></blockquote><p>发现是个弱智题，随便维护一下就可以。</p><h1 id="BJOI2014-大融合"><a href="#BJOI2014-大融合" class="headerlink" title="[BJOI2014]大融合"></a>[BJOI2014]大融合</h1><blockquote><p>给出一张空图</p><ul><li><code>A x y</code> ：若 $x$ 和 $y$不连通则连边.</li><li><code>Q x y</code> ：询问 $a$ 和 $b$ 在边 $(x,y)$ 两端的 $(a,b)$ 点对数。 </li></ul></blockquote><p>考虑实儿子和虚儿子数量分别维护。发现只有 <code>access</code> 和 <code>link</code> 需要修改。于是魔改一下就做完了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">splay(x), npn[x] += size[rc] - size[qwq], rc = qwq, push_up(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Access(x), splay(x), reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    Rooten(x), Access(y), splay(y) ;</span><br><span class="line">    T[x].F = y, npn[y] += size[x], push_up(y) ;</span><br><span class="line">&#125;<span class="comment">//npn维护虚儿子</span></span><br></pre></td></tr></table></figure><h1 id="国家集训队-Tree-II"><a href="#国家集训队-Tree-II" class="headerlink" title="[国家集训队]Tree II"></a>[国家集训队]Tree II</h1><blockquote><p>一棵 $n$ 个点的树，每个点的初始权值为 $1$。</p><p>对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：</p><ul><li><code>+ u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都加上自然数 $c$ ；</li><li><code>- u1 v1 u2 v2</code>：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树 ；</li><li><code>* u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都乘上自然数 $c$ ；</li><li><code>/ u v</code>：询问 $u$ 到 $v$ 的路径上的点的权值和，将答案对 $51061$ 取模。</li></ul></blockquote><p>发现就是很板的 $\rm LCT$ ？splay维护一下加法和乘法 <code>tag</code> 就好了。</p><p>主要是记录一下代码…</p><p>好久之前做的题了，当时给函数瞎起了一个 <code>split</code> 的名字，并且码风奇差，感觉自己很弟弟。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> O[<span class="number">3</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> R ; <span class="keyword">long</span> <span class="keyword">long</span> tagv, tags ; </span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], sz ; <span class="keyword">long</span> <span class="keyword">long</span> s, v  ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> stk[MAXN], base[MAXN], N, M, A, B, C, i ;</span><br><span class="line">                                                       </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;     </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;                        </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s += y * size) %= Mod, (T[x].v += y) %= Mod, (T[x].tags += y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; T[x].s = (T[lc].s + T[rc].s + T[x].v) % Mod ; T[x].sz = T[lc].sz + T[rc].sz + <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s *= y) %= Mod, (T[x].v *= y) %= Mod, (T[x].tagv *= y) %= Mod ; (T[x].tags *= y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">    T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> qwq = x, t = <span class="number">1</span> ; stk[<span class="number">1</span>] = x ;</span><br><span class="line"><span class="keyword">while</span>(check(qwq)) stk[++ t] = (qwq = T[qwq].F) ;</span><br><span class="line"><span class="keyword">while</span>(t) push_down(stk[t --]) ;</span><br><span class="line"><span class="keyword">while</span>(check(x))&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> res = <span class="number">0</span>, k = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) k = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ;  T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; split(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (T[x].tagv != <span class="number">1</span>) Mul(lc, T[x].tagv), Mul(rc, T[x].tagv), T[x].tagv = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (T[x].tags)    Add(lc, T[x].tags), Add(rc, T[x].tags), T[x].tags = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (T[x].R) &#123; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">rep(i, <span class="number">1</span>, N) T[i].v = T[i].tagv = T[i].sz = <span class="number">1</span> ;</span><br><span class="line">rep(i ,<span class="number">1</span>, N - <span class="number">1</span>) A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">rep(i, <span class="number">1</span>, M)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;O) ;</span><br><span class="line"><span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'+'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Add(B, C) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'*'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Mul(B, C) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'/'</span>) A = qr(), B = qr(), split(A, B), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, T[B].s) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'-'</span>) A = qr(), B = qr(), Cut(A, B), A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是重学了一遍 $\rm LCT$。然后整理一下之前做过的题？大多数都比较套路。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构/LCT" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LCT/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Cf938G Shortest Path Queries</title>
    <link href="https://www.orchidany.cn/2020/01/24/Cf938G/"/>
    <id>https://www.orchidany.cn/2020/01/24/Cf938G/</id>
    <published>2020-01-23T16:42:04.000Z</published>
    <updated>2020-01-31T10:44:18.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给出一个连通带权无向图,边有边权,要求支持 $q$ 个操作:</p><p><code>1 x y d</code> 在原图中加入一条 $x$ 到 $y$ 权值为 $b$ 的边。</p><p><code>2 x y</code> 把图中 $x$ 到 $y$ 的边删掉。</p><p><code>3 x y</code> 表示询问 $x$ 到 $y$ 的异或最短路。</p><p>保证任意操作后原图连通无重边自环且操作均合法。</p><p>$1\leq n,m,q\leq 200000$</p><a id="more"></a><p>这题和 [HAOI2017] 的那个不是很相同。那题比较弱智，每次询问的只是包括 $1$ 的圈，但是这题需要维护连通性，并且没有初始边。所以就需要维护一个可撤销的 $dsu$ 来配合操作。</p><p>嗯，又写了一遍发现这个可撤销并查集的实现可能需要再领悟一下。</p><p>感觉代码实现方面还有很多需要熟悉的啊…尤其是线性基维护生成树、直接用 <code>query(x) &amp; query(y)</code> 就可以直接求出询问，感觉很神奇。慢慢学、慢慢来吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">30</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">800010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> tot, cntq ;</span><br><span class="line"><span class="keyword">int</span> fa[N], sz[N] ;</span><br><span class="line"><span class="built_in">map</span> &lt;pint, <span class="keyword">int</span>&gt; sch ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxj</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base[<span class="number">50</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = B ; ~k ; -- k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; k &amp; x)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[k]) x ^= base[k] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[k] = x, <span class="keyword">void</span>() ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">            ret = min(ret, ret ^ base[i]) ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F ;</span><br><span class="line"><span class="comment">//using namespace xxj ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &gt; ur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dofa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doxor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= f[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, xxj now)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;edge&gt; O ; <span class="comment">//O.clear() ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> w = S[rt][i].val ;</span><br><span class="line">        <span class="keyword">int</span> f1 = dofa(u), f2 = dofa(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; w &lt;&lt; endl ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; " " &lt;&lt; sz[f1] &lt;&lt; " " &lt;&lt; sz[f2] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edge)&#123;f1, f2, sz[f2]&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1],</span><br><span class="line">            f[f1] = doxor(u) ^ doxor(v) ^ w ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now.Insert(doxor(u) ^ doxor(v) ^ w) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        ans[l] = now.Query(doxor(qs[l].u) ^ doxor(qs[l].v)) ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid, now),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, now) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        fa[O[i].u] = O[i].u, sz[O[i].v] = O[i].l, f[O[i].u] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, mk ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(u), qr(v), qr(w) ;</span><br><span class="line">        e[++ tot] = (edge)&#123;u, v, <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        sch[mkp(u, v)] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        qr(mk), qr(u), qr(v) ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) swap(u, v) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            qr(w), ++ tot,</span><br><span class="line">            sch[mkp(u, v)] = tot,</span><br><span class="line">            e[tot] = (edge)&#123;u, v, cntq + <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            e[sch[mkp(u,v)]].r = cntq ;</span><br><span class="line">        <span class="keyword">else</span> qs[++ cntq] = (qss)&#123;u, v&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (e[i].r &lt; <span class="number">0</span>) e[i].r = cntq ;</span><br><span class="line">   <span class="comment">// for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].r &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, cntq, e[i].l, e[i].r, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">1</span>, cntq, F) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个连通带权无向图,边有边权,要求支持 $q$ 个操作:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 x y d&lt;/code&gt; 在原图中加入一条 $x$ 到 $y$ 权值为 $b$ 的边。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2 x y&lt;/code&gt; 把图中 $x$ 到 $y$ 的边删掉。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3 x y&lt;/code&gt; 表示询问 $x$ 到 $y$ 的异或最短路。&lt;/p&gt;
&lt;p&gt;保证任意操作后原图连通无重边自环且操作均合法。&lt;/p&gt;
&lt;p&gt;$1\leq n,m,q\leq 200000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="离线算法/线段树分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="线性代数/线性空间/线性基" scheme="https://www.orchidany.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4-%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#2312 [HAOI2017]八纵八横</title>
    <link href="https://www.orchidany.cn/2020/01/24/HAOI2017%E5%85%AB%E7%BA%B5%E5%85%AB%E6%A8%AA/"/>
    <id>https://www.orchidany.cn/2020/01/24/HAOI2017八纵八横/</id>
    <published>2020-01-23T16:41:46.000Z</published>
    <updated>2020-02-03T15:30:13.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实不是什么难题，只是因为「写起来很麻烦」+「单独拿出来方便记忆」所以单独开一篇。</p><a id="more"></a><p>Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市)，保证任意两个城市都可以通过高速公路互达。</p><p>Anihc 国正在筹划「八纵八横」的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在「八纵八横」计划建成之后，将「一带一路」扩展为「一带一路一环」，增加「内陆城市经济环」即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令「内陆城市经济环」的 $\rm GDP$ 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。</p><p>现在 Anihc 在会议上讨论「八纵八横」的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的「八纵八横」的建设计划的方案「内陆城市经济环」的最大是多少。</p><p>初始时，八纵八横计划中不包含任何—条高铁，有以下三种操作：</p><p><code>Add x y z</code>  在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 <code>Add</code> 操作，则将这条高铁命名为 $k$ 号高铁。</p><p><code>Cancel k</code>  将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。</p><p><code>Change k z</code>  表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在.</p><h2 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm Sol$"></a>$\rm Sol$</h2><p>不得不说这题有点恶心…因为他需要 <code>bitset</code>，于是各种操作就很不优美。</p><p>大概就是考虑用线段树分治去维护边的存在性。那么接下来就是一开始随便 $dfs$ 出一个生成树来，然后每次询问时，发现对于每个合法的方案都是从 $1$ 开始的一个环。 那么考虑最后一定是一些环套起来，所以可以直接在线性基里面查询。</p><p>做这题时发现，这么做的正确性在于，可以随便生成一棵树。同时生成出来的环也具有「生成子集」的性质，也就是说可以据此生成所有 <strong>剩下未被统计的环</strong>。要证明其实也不难。</p><p>所以可能这种「线性基+生成树+环生成子集」的结合是“完洽”的，即彼此有着共同的性质，这种搭配似乎不是很常见？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">char</span> s[L] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; f[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; ans[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, tot, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xxj&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; base[L] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="built_in">bitset</span>&lt;L&gt; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (x[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][i]) x ^= base[i] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; Query()&#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;L&gt; res ; res.reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res[i] ^ base[i][i]) res ^= base[i] ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xxj ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">(<span class="built_in">bitset</span> &lt;L&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (!x[i])</span><br><span class="line">            &#123;<span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'1'</span>), flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>&lt;L&gt; get_bit()&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; ret ; ret.reset() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ret.<span class="built_in">set</span>(len - i) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">bitset</span>&lt;L&gt; w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; O ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> d = Insert(S[rt][i].val ^ f[u] ^ f[v]) ;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) O.p_b(d) ; <span class="comment">//,cout &lt;&lt;d&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) ans[l] = Query() ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; O.size() ; ++ i) base[O[i]].reset() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            Insert(f[u] ^ f[to(k)] ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> f[to(k)] = f[u] ^ val(k), dfs(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(u), qr(v), add(u, v, get_bit()) ;</span><br><span class="line">    dfs(<span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i].count() &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'A'</span>)</span><br><span class="line">            ++ tot, qr(e[tot].u), qr(e[tot].v),</span><br><span class="line">            e[tot].val = get_bit(), e[tot].l = i, e[tot].r = q ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'a'</span>)</span><br><span class="line">            qr(u),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]), e[u].l = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">else</span> qr(u), update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]),</span><br><span class="line">             e[u].l = i, e[u].val = get_bit(), e[u].r = q ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val.count() &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~e[i].l) update(<span class="number">1</span>, <span class="number">0</span>, q, e[i].l, q, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">0</span>, q) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= q ; ++ i) out_put(ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实不是什么难题，只是因为「写起来很麻烦」+「单独拿出来方便记忆」所以单独开一篇。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="离线算法/线段树分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="线性代数/线性空间/线性基" scheme="https://www.orchidany.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4-%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】线段树分治</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    <id>https://www.orchidany.cn/2020/01/24/线段树分治/</id>
    <published>2020-01-23T16:40:39.000Z</published>
    <updated>2020-02-01T07:18:10.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线段树分治用于离线处理一些带有时间属性的操作。最常见的是对于给定的每个操作都只在某个时间区间内存在效力，换言之即每个操作都需要可撤销。</p><p>嗯，废话说完了。做法大概就是拿线段树 $+$ <code>vector</code> 维护一下操作区间的所有操作，然后直接在询问里按时间跑分治，顺便在线段树内维护合法修改即可。</p><a id="more"></a><h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><p>以下是 $bzoj4025$ :</p><blockquote><p>神犇有一个 $n$ 个节点的图。</p><p>因为神犇是神犇，所以在 $\rm T$ 时间内一些边会出现后消失。神犇要求出每一时间段内这个图是否是二分图。这么简单的问题神犇当然会做了，于是他想考考你。</p><p>$1\leq n,m,\rm T\leq 10^6$。</p></blockquote><p>大概就是通过线段树+vector维护每个区间加了哪些边，然后通过可撤销的并查集来维护当前图内是否有奇环。判断过程大概就是如果可以有边加进去就加边，否则判断两者到根的实际距离是否奇偶性相同，如果相同那么添上这条边一定会使得出现一个奇环。</p><p>然后这题由于有奇环可以把答案记为 $0$，那么就可以不再递归下去。也算是一个剪枝？</p><p>哦对，由于要支持撤销，所以就换成了按 $\rm size$ 合并的并查集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, ans[T] ;</span><br><span class="line"><span class="keyword">int</span> dis[N], fa[N], sz[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span> <span class="keyword">int</span> u, v ; &#125; ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edges&gt; S[N * <span class="number">3</span>], O ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= dis[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> fr, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b((edges)&#123;fr, to&#125;), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, fr, to) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, fr, to) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; <span class="built_in">vector</span>&lt;edges&gt;O ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edges)&#123;f1, f2&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            dis[f1] = dis[u] ^ dis[v] ^ <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dist(u) == dist(v)) &#123; ret = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">if</span> (l == r) ans[l] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> do_do(rt &lt;&lt; <span class="number">1</span>, l, mid), do_do(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        sz[O[i].v] -= sz[O[i].u], dis[O[i].u] = <span class="number">0</span>, fa[O[i].u] = O[i].u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) update(<span class="number">1</span>, <span class="number">1</span>, k, l + <span class="number">1</span>, r, u, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ; do_do(<span class="number">1</span>, <span class="number">1</span>, k) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        ans[i] ? <span class="built_in">puts</span>(<span class="string">"Yes"</span>) : <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，然后就没了…</p><h1 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h1><h2 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h2><blockquote><p>求不包含元素 $1\sim n$ 的 $01$ 背包。</p><p>$1\leq n,m\leq 2000$</p></blockquote><p>直接线段树分治做，第 $i$ 个物品的存在时间是 $1\sim i-1$ 和 $i+1 \sim n$ .</p><p>但有个问题就在于每次计算的复杂度都是 $nw$ 的。所以最后复杂度就是 $nw\log n$ 。</p><h2 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h2><blockquote><p>给定一张图，对所有的 $i,j,k$ 求 $i$ 到 $j$ 不经过 $k$ 的⽅案数。</p></blockquote><p>发现朴素地做是 $n^4$ 的。可以通过和上面那题差不多的方法，用线段树分治优化到 $n^3\log n$ 。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实我关于离线三姐妹的学习顺序是CDQ-&gt;整体二分-&gt;线段树分治。最后学线段树分治是因为第一次看这个算法感觉很懵…尤其是所有题解都在繁复叨叨那几句话QAQ</p><p>总之，句号也是一个新的开始，不是吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树分治用于离线处理一些带有时间属性的操作。最常见的是对于给定的每个操作都只在某个时间区间内存在效力，换言之即每个操作都需要可撤销。&lt;/p&gt;
&lt;p&gt;嗯，废话说完了。做法大概就是拿线段树 $+$ &lt;code&gt;vector&lt;/code&gt; 维护一下操作区间的所有操作，然后直接在询问里按时间跑分治，顺便在线段树内维护合法修改即可。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线段树分治" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="离线算法/线段树分治" scheme="https://www.orchidany.cn/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="图论/二分图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】线性基</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>https://www.orchidany.cn/2020/01/24/线性基/</id>
    <published>2020-01-23T16:40:24.000Z</published>
    <updated>2020-01-31T09:09:23.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>真正线性基的定义需要扯到线代那一部分。因为心情不好，所以鸽了。</p><p>此处主要讨论的线性基定义在异或运算上。即考虑给出一系列整数，称其中某个可以通过异或运算表出全部元素的子集为一组<strong>生成子集</strong>，称一组彼此都不能被表出元素为<strong>线性无关集</strong>。那么<strong>线性基</strong>就是一组<strong>线性无关生成子集</strong>。</p><p>如果把每个数看成一个 $01$ 向量。可以如是做的原因是位运算时位位独立，就如同系数矩阵在做初等变换时行、列分别独立一样。所以这个线性空间内基的个数就是这个 $01$ 矩阵的秩。换句话说，求这个的过程完全可以通过高斯消元来实现。</p><a id="more"></a> <h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="$1$ 基本操作"></a>$1$ 基本操作</h1><h2 id="（1）插入"><a href="#（1）插入" class="headerlink" title="（1）插入"></a>（1）插入</h2><p>普通的插入顺便消了消元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ;</span><br><span class="line">                ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概消成的就是一个倒三角矩阵。显然最后 $x_i$ 有值的位数就是这个矩阵的秩。</p><p>虽然这样插入没错，但有一种更精妙的插入方式。这样插入之后可以保证线性基内至多存在 $1$ 个 $b_i$ 位为 $1$ 的数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               <span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样消出来的就可以保证是一个部分对角的矩阵，比上三角矩阵有着更优秀的性质。</p><h2 id="（2）-询问"><a href="#（2）-询问" class="headerlink" title="（2） 询问"></a>（2） 询问</h2><p>询问操作常(我)见(会)的，首先是求最大值/最小值，这东西显然贪心一遍即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">    ans = max/min(ans, ans ^ x[i]) ;</span><br></pre></td></tr></table></figure><p>这种感觉。从大到小枚举不是因为贪心顺序，是因为这样可以保证消元消出来没有后效性。</p><p>然后是询问第 $k$ 小/大。这东西的话，考虑对于这个线性空间，一共可以张成 $2^n$ 个值。特判掉 $0$ 之后，发现对 $k$ 二进制拆分实际上就是在对角矩阵里面选数。所以如果一开始选择消成对角矩阵，那么就可以直接做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">63</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> haha ; LL z ;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt ; LL ans ;</span><br><span class="line">LL base[N], x[M + <span class="number">1</span>], rst[M + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               <span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL k)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!haha) -- k ;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1l</span>l &lt;&lt; cnt)) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; (<span class="number">1l</span>l &lt;&lt; i)) res ^= rst[i] ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; haha = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], haha &amp;= ins(base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; <span class="comment">//cout &lt;&lt; haha &lt;&lt; endl ;</span></span><br><span class="line">    cnt = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x[i]) rst[cnt ++] = x[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;z), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(z)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目是 <code>loj#114 k大异或和</code> 。</p><h2 id="（3）删除"><a href="#（3）删除" class="headerlink" title="（3）删除"></a>（3）删除</h2><p>这部分我很迷啊…</p><p>首先如果可以离线就可以线段树分治，剩下的先鸽着。</p><p>大概就是考虑如果删除了一个不在线性基内的数，那就无所谓了。如果在其中，那么</p><h1 id="2-经典应用"><a href="#2-经典应用" class="headerlink" title="$2$ 经典应用"></a>$2$ 经典应用</h1><blockquote><p>[WC2011]最大XOR和路径</p><p>考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 $\operatorname{XOR}$ 和最大。</p><p>$1\leq n,m\leq 10^6$</p></blockquote><p>一道很经典的题。大概是维护异或生成树。</p><p>考虑这题先随便生成一条 $1\sim n$ 的路径，这样就是钦定了一颗生成树，那么剩下的会是一些圈。考虑从这条路径走出去，走完剩下的圈再走回来是一个来回，中间的桥边（装作）会被经过两次，所以不需要考虑。</p><p>所以 <code>dfs</code> 一遍就行。遇到环就丢到线性基里面，否则记录一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~ i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; x)&#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i]) x ^= base[i] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, <span class="keyword">void</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL basic)</span></span>&#123;</span><br><span class="line">    LL ret = basic ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">        ret = max(ret, ret ^ base[i]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, LL res)</span></span>&#123;</span><br><span class="line">    f[u] = res, vis[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)]) </span><br><span class="line">          dfs(to(k), res ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(res ^ val(k) ^ f[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v ; LL w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w, add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Query(f[n])) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真正线性基的定义需要扯到线代那一部分。因为心情不好，所以鸽了。&lt;/p&gt;
&lt;p&gt;此处主要讨论的线性基定义在异或运算上。即考虑给出一系列整数，称其中某个可以通过异或运算表出全部元素的子集为一组&lt;strong&gt;生成子集&lt;/strong&gt;，称一组彼此都不能被表出元素为&lt;strong&gt;线性无关集&lt;/strong&gt;。那么&lt;strong&gt;线性基&lt;/strong&gt;就是一组&lt;strong&gt;线性无关生成子集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果把每个数看成一个 $01$ 向量。可以如是做的原因是位运算时位位独立，就如同系数矩阵在做初等变换时行、列分别独立一样。所以这个线性空间内基的个数就是这个 $01$ 矩阵的秩。换句话说，求这个的过程完全可以通过高斯消元来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线性基" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
    
      <category term="线性代数/线性空间/线性基" scheme="https://www.orchidany.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4-%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Kruskal重构树</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/01/24/克鲁斯卡尔重构树/</id>
    <published>2020-01-23T16:40:07.000Z</published>
    <updated>2020-01-31T14:53:19.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是模拟 <code>Kruskal</code> 加边的过程，重构成一棵树。</p><p>过程大概是把原图中所有的点作为重构树的叶子，边按一定的秩排序，合并两个集合时把连接两个集合的边权作为公共父亲的点权。</p><p>这样的建树有一定性质。比如基于最小生成树的重构，两个点的 $lca$ 点权一定是「两点之间所有路径上最大值的最小值」。</p><a id="more"></a><h1 id="NOI2018-归程"><a href="#NOI2018-归程" class="headerlink" title="[NOI2018] 归程"></a>[NOI2018] 归程</h1><blockquote><p>给定一张图，每条路有一个长度一个海拔。</p><p>每次询问，询问从点 $x$ 出发，第一段只走海拔 $&gt;h$ 的边，走到某个点，然后无限制地走第二段到达 $1$ 号点，第二段路程的最小长度。</p><p>强制在线。</p></blockquote><p>发现Kruskal重构树具有堆性质，于是如果基于最大生成树重构，那么对于一个点能够经过大于 $v$ 的边到达的点应该在某个子树内。所以可以按照这个方式倍增。之前预处理一下子树内到 $1$ 的 $\rm mindist$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cost(k) E[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, c ;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, cost ;</span><br><span class="line">    <span class="keyword">int</span> fr, to, next ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, n ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp; neww) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; neww.dis ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> ff[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> lastans ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q, s ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> dis[N], vis[N] ;</span><br><span class="line">priority_queue&lt;Node&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].fr = u ;</span><br><span class="line">    E[cnt].val = w, E[cnt].cost = c ;</span><br><span class="line">    E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">127</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    Q.push((Node)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node qwq = Q.top() ; Q.pop() ;</span><br><span class="line">        <span class="keyword">int</span> x1 = qwq.n, x2 = qwq.dis ;</span><br><span class="line">        <span class="keyword">if</span>(vis[x1]) <span class="keyword">continue</span> ; vis[x1] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = head[x1]; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = min(dis[E[k].to], x2 + cost(k)) ;</span><br><span class="line">               Q.push((Node)&#123;dis[to(k)], to(k)&#125;) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(edges u, edges v)</span></span>&#123; <span class="keyword">return</span> u.w &gt; v.w ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ff[x] ? x : ff[x] = find(ff[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ffff)</span></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = ffff ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">19</span> ; ++ j)</span><br><span class="line">        fa[x][j] = fa[fa[x][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        dfs(to(k), x), dis[x] = min(dis[x], dis[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("return.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("return.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> tot ;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c, k, l, now, ok ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].c &gt;&gt; e[i].w,</span><br><span class="line">             add(e[i].u, e[i].v, e[i].w, e[i].c), add(e[i].v, e[i].u, e[i].w, e[i].c) ;</span><br><span class="line">        dijkstra() ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; k &gt;&gt; s ; tot = n ; ok = <span class="number">0</span> ;</span><br><span class="line">        sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, comp) ; <span class="comment">//cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">        fill(head, head + <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n + <span class="number">1</span> ; ++ i) ff[i] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = find(e[i].u) ;</span><br><span class="line">            <span class="keyword">int</span> f2 = find(e[i].v) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ++ ok ;</span><br><span class="line">                now = ++ tot ;</span><br><span class="line">                base[now] = e[i].w ;</span><br><span class="line">                ff[f1] = now, ff[f2] = now ;</span><br><span class="line">                add(now, f1, <span class="number">0</span>, <span class="number">0</span>), add(now, f2, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(now, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">            u = qr(), l = qr() ; <span class="keyword">int</span> x = u ;</span><br><span class="line">            l = (l + <span class="number">1l</span>l * k * lastans) % (s + <span class="number">1</span>) ;</span><br><span class="line">            x = (x + <span class="number">1l</span>l * k * lastans - <span class="number">1</span>) % n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (fa[x][j] &amp;&amp; base[fa[x][j]] &gt; l) x = fa[x][j] ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = dis[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">        <span class="built_in">memset</span>(base, <span class="number">0</span>, <span class="keyword">sizeof</span>(base)) ;</span><br><span class="line">        fill(vis + <span class="number">1</span>, vis + tot + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        fill(head + <span class="number">1</span>, head + tot + <span class="number">1</span>, <span class="number">0</span>), lastans = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="神秘的题目"><a href="#神秘的题目" class="headerlink" title="神秘的题目"></a>神秘的题目</h1><blockquote><p>给出一棵 $n$ 个点的树，树边上有边权。 </p><p>定义一个点的权值为其到其他所有节点的路径上最小边权之和，求权值最大的点。 </p></blockquote><p>建一棵基于最大生成树的重构树，然后发现每条边作为 $(u,v)$ 最小边权当且仅当 $u,v$ 在重构树上的 $lca$ 是这条边。</p><p>所以可以直接离线统计每条边的贡献，<code>dfs</code> 时将左右子树中的叶子结点个数加权互加一下就完了。可以直接在 <code>dfn</code> 上维护一个差分，这样就是排序外线性了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是模拟 &lt;code&gt;Kruskal&lt;/code&gt; 加边的过程，重构成一棵树。&lt;/p&gt;
&lt;p&gt;过程大概是把原图中所有的点作为重构树的叶子，边按一定的秩排序，合并两个集合时把连接两个集合的边权作为公共父亲的点权。&lt;/p&gt;
&lt;p&gt;这样的建树有一定性质。比如基于最小生成树的重构，两个点的 $lca$ 点权一定是「两点之间所有路径上最大值的最小值」。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kruskal重构树" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    
    
      <category term="图论/Kruskal重构树" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj#3545 Peaks</title>
    <link href="https://www.orchidany.cn/2020/01/24/Peaks/"/>
    <id>https://www.orchidany.cn/2020/01/24/Peaks/</id>
    <published>2020-01-23T16:40:07.000Z</published>
    <updated>2020-01-31T14:59:11.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有 $n$ 座山峰，每座山峰有他的高度 $h_i$。</p><p>有山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值。</p><p>现在有 $q$ 组询问，询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。</p><a id="more"></a><p>发现可以倍增，因为 $\leq x$ 的权在重构树上是一个子树。</p><p>倍增完了就可以直接套主席树了。主席树可以比较简单的按照叶子的标号建，每个边结点维护一个 $\rm leftrange$ 和 $\rm rightrange$ 即可。</p><p>等会儿，我就整理这么点儿东西为啥要新开这一篇blog啊？太浪费资源了吧QAQ。</p><p><del>那看上去就只能用代码来占空间了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">    <span class="keyword">int</span> next, val ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> dad[N] ;</span><br><span class="line"><span class="keyword">int</span> wth[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> rg[N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[V], res, sz ;</span><br><span class="line"><span class="keyword">int</span> rt[V], lc[V], rc[V] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lc[now] = build(l, mid) ;</span><br><span class="line">    rc[now] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    lc[now] = lc[last] ;</span><br><span class="line">    rc[now] = rc[last] ;</span><br><span class="line">    sum[now] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">        lc[now] = update(lc[last], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> rc[now] = update(rc[last], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rtl, <span class="keyword">int</span> rtr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> delta = sum[rc[rtr]] - sum[rc[rtl]] ;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; delta)</span><br><span class="line">        <span class="keyword">return</span> query(lc[rtl], lc[rtr], l, mid, v - delta) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rc[rtl], rc[rtr], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = w, fr(cnt) = u ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == dad[x] ? x : dad[x] = find(dad[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge A, Edge B)</span></span>&#123; <span class="keyword">return</span> A.val &lt; B.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">    rg[u][<span class="number">0</span>] = res ;</span><br><span class="line">    <span class="keyword">if</span> (!head[u])</span><br><span class="line">        rg[u][<span class="number">0</span>] = ++ res,</span><br><span class="line">        rt[res] = update(rt[res - <span class="number">1</span>], <span class="number">1</span>, len, base[u]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">    rg[u][<span class="number">1</span>] = res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, now, k, tot, op ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + len + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w), add(v, u, w) ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n ; ++ i) dad[i] = i ;</span><br><span class="line">    fill(head + <span class="number">1</span>, head + n + <span class="number">1</span>, <span class="number">0</span>), op = cnt, tot = n, cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= op ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(fr(i)) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = find(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            now = ++ tot ;</span><br><span class="line">            wth[now] = val(i) ;</span><br><span class="line">            dad[f1] = dad[f2] = now ;</span><br><span class="line">            fa[f1][<span class="number">0</span>] = fa[f2][<span class="number">0</span>] = now ;</span><br><span class="line">            add(now, f1, <span class="number">0</span>),add(now, f2, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; fa[i][0] &lt;&lt; endl ;</span></span><br><span class="line">    rt[<span class="number">0</span>] = build(<span class="number">1</span>, len) ; dfs(now) ; <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;w, &amp;k) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (fa[u][j] &amp;&amp; wth[fa[u][j]] &lt;= w) u = fa[u][j] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (rg[u][<span class="number">1</span>] - rg[u][<span class="number">0</span>] &lt; k) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; rg[u][0] &lt;&lt; " " &lt;&lt; rg[u][1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[query(rt[rg[u][<span class="number">0</span>]], rt[rg[u][<span class="number">1</span>]], <span class="number">1</span>, len, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有 $n$ 座山峰，每座山峰有他的高度 $h_i$。&lt;/p&gt;
&lt;p&gt;有山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值。&lt;/p&gt;
&lt;p&gt;现在有 $q$ 组询问，询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="图论/Kruskal重构树" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【探究】欧拉反演</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    <id>https://www.orchidany.cn/2020/01/24/欧拉反演/</id>
    <published>2020-01-23T16:38:15.000Z</published>
    <updated>2020-02-05T09:36:29.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是对于 $\varphi$ 函数性质的一点应用？比起 $\mu$ 其实不是那么的复杂，实用性也不是很高。</p><p>考虑 $\varphi$ 的这么一个性质：</p><script type="math/tex; mode=display">\sum _{d|n}\varphi(d)=n</script><p>这大概就是这篇文章的主角。</p><a id="more"></a><hr><p>这东西大概可以用莫比乌斯反演定理来证？</p><p>令 $f(x)=\varphi(x)$，$g(x)=\boldsymbol{\rm Id}(x)$ ，则根据狄利克雷卷积的某些常识有</p><script type="math/tex; mode=display">\sum_{d|n}g(d)\mu(\frac{n}{d})=f(n)\\</script><p>反演一下</p><script type="math/tex; mode=display">g(n)=\sum_{d|n}f(d)</script><p>即</p><script type="math/tex; mode=display">\sum_{d|n}\varphi(d)=\boldsymbol{\rm Id}(n)=n</script><p>当然也可以通过浅显的数论知识来证明：</p><p>设 $f(n)=\sum_{d|n}\varphi(d)$ ，则容易证明 $f$ 也是积性函数。（易证=懒得证XD）</p><p>考虑 $n$ 的标准分解式：</p><script type="math/tex; mode=display">n=\sum p_i^{e_i}</script><p>并且考虑当 $p\in\mathbb{P}$ 时 </p><script type="math/tex; mode=display">\varphi(p^k)=p^k-p^{k-1}=p(p^{k-1}-p^{k-2})</script><p>证明很简单，在不越界的情况下， $p^k$ 由于只有 $p$ 一个质因子，所以与 $p\times1,p\times2\cdots p\times p^{k-1}$ 都不互质，所以是 $p^k-p^{k-1}$ 。</p><p>那么有</p><script type="math/tex; mode=display">f\left(p_{i}^{e_{i}}\right)=1+p-1+p(p-1)+p^{2}(p-1) \ldots+p^{e_{i}-1}(p-1)</script><p>通过几何级数的求和公式可以得到：</p><script type="math/tex; mode=display">f(p_i^{e_i})=p_i^{e_i}</script><p>根据积性可以得到</p><script type="math/tex; mode=display">f(n)=n</script><p>是不是比上一个证明清真了很多！</p><p>以下默认 $[i,j]$ 表示 $i,j$ 的 $\rm lcm$ 。 </p><h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote><p>求 </p><script type="math/tex; mode=display">\sum _{i=1}^n\sum_{j=1}^m(i,j)</script><p>$1\leq n,m\leq 10^6,q\leq 10^5$</p></blockquote><p>随便做啦</p><script type="math/tex; mode=display">\begin{aligned}&\sum _{i=1}^n\sum_{j=1}^m(i,j)\\=&\sum _{i=1}^n\sum_{j=1}^m\sum_{d|n}\varphi(d)\\=&\sum _{d=1}^n\varphi(d)\cdot \lfloor\frac{n}{d} \rfloor \cdot \lfloor\frac{m}{d} \rfloor\end{aligned}</script><hr><p>接下来是一道翻车题：</p><h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote><p>[国家集训队]Crash的数字表格 </p><p>求</p><script type="math/tex; mode=display">\sum _{i=1}^n\sum_{j=1}^m[i,j]</script><p>$1\leq n,m\leq 10^7$。</p></blockquote><p>根据以往套路变形</p><script type="math/tex; mode=display">\begin{aligned}&\sum _{i=1}^n\sum_{j=1}^m[i,j]\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{(i,j)}\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\sum\limits_{d|i~\mathrm{and}~d|j}\varphi(d)}\\=&\sum _{d=1}^n\frac{1}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor} j\end{aligned}</script><p>看上去很真？但是并不对。原因是 <strong>和的倒数不等于倒数的和</strong>，也就是中间 $\sum \varphi(d)$ 不能直接提出来。</p><p>所以遇到这种情况就只能用莫比乌斯反演。考虑如此：</p><script type="math/tex; mode=display">\begin{aligned}&\sum _{i=1}^n\sum_{j=1}^m[i,j]\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) \\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j\end{aligned}</script><p>然后这东西就可以两个数论分块套一起来解决，复杂度 $O(\sqrt n)\cdot O(\sqrt n)=O(n)$。</p><p>然而似乎有一只 $\sqrt{n}$ 的做法？有空再学吧233</p><p>代码似乎有不少细节？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, pr[N], o ;</span><br><span class="line">LL F[N], mu[N], ans ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">do_do</span><span class="params">(LL u, LL v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u * (u + <span class="number">1</span>) / <span class="number">2</span> % P) * (v * (v + <span class="number">1</span>) / <span class="number">2</span> % P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x, y) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; endl ;</span></span><br><span class="line">        r = min(x / (x / l), y / (y / l)) ;</span><br><span class="line">        <span class="comment">// if (y == 1) cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ret += ((F[r] - F[l - <span class="number">1</span>]) % P + P) % P * do_do(x / l, y / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ o] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= o ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[pr[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * pr[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[pr[j] * i] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        F[i] = ((F[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * i * mu[i] % P) % P + P) % P ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ans += (<span class="number">1l</span>l * (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % P) * (solve(n / l, m / l) % P) % P) %= P ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((ans % P + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote><p>LG4917天守阁的地板/LG5221Product</p><p>简化题意：</p><p>求</p><script type="math/tex; mode=display">\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}</script><p>$1\leq n\leq 10^6$</p></blockquote><p>大概就是转化</p><script type="math/tex; mode=display">\begin{aligned}&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}\\=&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{i\times j}{\operatorname{gcd}^2(i, j)}\\\end{aligned}</script><p>然后观察到 $\prod$ 对于除法有结合律，即可以分别算分母和分子。同时指数上的 $2$ 也可以最后再算。</p><p>于是考虑下半部分：</p><script type="math/tex; mode=display">\begin{aligned}&\prod_{i=1}^{n} \prod_{j=1}^{n} \operatorname{gcd}(i, j)\\=&\prod_{d=1}^n\prod_{i=1}^{n} \prod_{j=1}^{n} d\cdot [\operatorname{gcd}(i, j)=d]\\=&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\\end{aligned}</script><p>其中第二步到第三步的原因是根据结合律 $\prod$ 要升级为乘方（就像 $\sum$ 会升级为 $\times $ 一样</p><p>发现似乎后面那个是老朋友了，所以可以直接反演成 $\mu$ 形式或者 $\varphi$ 形式。</p><p>其中 $\varphi$ 形式的证明大概是考虑每个数的数的贡献，同时由于是有序数对所以是 $\times 2-1$ 。</p><p>嗯，然后就会反演成这个样子：</p><script type="math/tex; mode=display">\begin{aligned}&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\=&\prod_{d=1}^n{d^{-1+2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)}}\end{aligned}</script><p>发现后面的可以数论分块于是这就可以 $\sqrt n$ 做了。</p><p>对于分子，发现就是：</p><script type="math/tex; mode=display">\prod_{i=1}^n\prod_{j=1}^n i\cdot j=\prod_{i=1}^n(i^n\cdot n!)=(n!)^n\cdot (n!)^n=(n!)^{2n}</script><p>然后就没有然后了233。</p><p>不过 <code>LG5221</code> 卡了空间，于是最后是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000001</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">104857601</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, pr[<span class="number">80001</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> ans1, ans2, phi[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1l</span>l * res * a % P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> fac = <span class="number">1</span> ;</span><br><span class="line">    pr[<span class="number">0</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>, ans2 = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j] ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * pr[j]] = phi[i] * (pr[j] - <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; l - 1 &lt;&lt; " " ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            fac = <span class="number">1l</span>l * fac * i % P ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; pr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] &gt; P - <span class="number">1</span>) phi[i] -= P - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1 = expow(pr[cnt], <span class="number">2</span> * n + <span class="number">2</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ; <span class="keyword">int</span> t = ++ cnt ; ++ cnt ;</span><br><span class="line">        ans2 = <span class="number">1l</span>l * ans2 * expow(<span class="number">1l</span>l * pr[cnt] * expow(pr[t], P - <span class="number">2</span>) % P, phi[n / l]) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * expow(ans2, P - <span class="number">5</span>) * ans1 % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是对于 $\varphi$ 函数性质的一点应用？比起 $\mu$ 其实不是那么的复杂，实用性也不是很高。&lt;/p&gt;
&lt;p&gt;考虑 $\varphi$ 的这么一个性质：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\sum _{d|n}\varphi(d)=n&lt;/script&gt;&lt;p&gt;这大概就是这篇文章的主角。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫比乌斯反演" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】$\mu$ 函数的性质</title>
    <link href="https://www.orchidany.cn/2020/01/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>https://www.orchidany.cn/2020/01/24/莫比乌斯反演/</id>
    <published>2020-01-23T16:38:00.000Z</published>
    <updated>2020-02-05T12:01:24.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知 $\mu$ 函数具有如下性质：</p><script type="math/tex; mode=display">\sum_{d|n} \mu(d)=[n=1]</script><p>大部分有关于 $\gcd$ 、带有艾佛森括号的反演题目都可以用这个性质解决。</p><a id="more"></a><p>证明方式有很多，此处采用狄利克雷卷积的方式来比较简洁地证明。</p><p>根据 $\mu$ 的定义，$\mu*\boldsymbol{1}=\boldsymbol{I}$，那么有 </p><script type="math/tex; mode=display">\sum _{d|n}\mu(d)=\mu * \boldsymbol{1}=\boldsymbol{I}=[n=1]</script><p>当然，其实还有更优美的证法。思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p><p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{d|n}\mu(d)\\ = &\sum_{d|n'}\mu(d)\\= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\= & ~(1+(-1))^k\\= & ~[k=0]\end{aligned}</script><p>所以到最后 $[k=0]$ 就意味着 $[n=1]$ 。$\mathcal{Q.E.D.}$</p><p>默认 $(a,b)$ 代表 $a$ 与 $b$ 的最大公约数，$|$ 表示整除。</p><h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote><p>求</p><script type="math/tex; mode=display">\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p></blockquote><p>其实就是代换：</p><script type="math/tex; mode=display">\begin{aligned}\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|(i,j)}\mu(d)\\&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|i~\text{and}~d|j}\mu(d)\\&=\sum _{d=1}^n\mu(d) \sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]\\&=\sum _{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor \cdot \lfloor\frac{m}{d}\rfloor\end{aligned}</script><p>然后就可以 $O(n)+O(q\sqrt n)$ 来做了。</p><p>但其实本质上，$n$ 可以出到 $10^9$ ？但是总感觉杜教筛套上一层数论分块复杂度就不是很对了。此处可能还需要思考思考。</p><h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote><p>[POI2007]ZAP-Queries/LG4450双亲数</p><p>求</p><script type="math/tex; mode=display">\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p></blockquote><p>其实本质上是一样的。</p><script type="math/tex; mode=display">\begin{aligned}\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|(i,j)}\mu(d)\\&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|i~\text{and}~d|j}\mu(d)\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d) \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[d|i]\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[d|j]\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{dk}\rfloor \cdot \lfloor\frac{m}{dk}\rfloor\end{aligned}</script><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote><p>$\forall p\in\mathbb{P}$，求</p><script type="math/tex; mode=display">\sum _{i=1}^n\sum_{j=1}^m[(i,j)=p]</script><p>$1\leq n\leq m\leq 10^7,q\leq 10000$</p></blockquote><p>发现到最后变成了这样：</p><script type="math/tex; mode=display">\sum_{k=1}^{cntp}\sum _{d=1}^{\lfloor\frac{n}{p_k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{p_kd}\rfloor \cdot \lfloor\frac{m}{p_kd}\rfloor</script><p>考虑继续换元，令 $q=p_kd$，枚举 $q$:</p><script type="math/tex; mode=display">\sum_{q=1}^{n}\lfloor\frac{n}{q}\rfloor \cdot \lfloor\frac{m}{q}\rfloor\cdot \left(\sum _{k=1}^{cntp}[p_k~|~q]\cdot \mu(\frac{q}{p_k})\right)</script><p>然后发现前半部分可以数论分块，后半部分可以直接在筛素数的时候 $dp$ 出来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; Pr[i] * j &lt;= MAXN - <span class="number">15</span> ; ++ j)</span><br><span class="line">f[j * Pr[i]] += Mu[j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= MAXN - <span class="number">15</span> ; ++ i) S[i] = S[i - <span class="number">1</span>] + f[i] ;</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><blockquote><p>题目来自神仙李思杰的 $blog$：</p><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \sum_{j=1}^{m} i\cdot j\cdot [(i, j)=k] \quad(n<m)</script><p>$1\leq n,m\leq 10^6$</p></blockquote><p>发现可以这么做：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^{n} \sum_{j=1}^{m} i \cdot j\cdot[(i, j)=k] &=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot[(i, j)=1] \\&=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot\sum_{d|i~\mathrm{and}~d|j} \mu(d)\\&=k^2\cdot \sum_{d=1}^n\mu(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor} i\cdot \sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor} j\\\end{aligned}</script><p>发现后面是个简单的二阶求和形式，故至此已经可以分快了。</p><h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><blockquote><p>[SDOI2015]约数个数和</p><p>求 </p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)</script><p>$1\leq n,m\leq 10^6,1\leq q\leq 10^5$</p></blockquote><p>首先考虑一步<del>几乎想不出来的</del>转化：</p><script type="math/tex; mode=display">\sigma_0(i \cdot j)=\sum_{x | i} \sum_{y | j}[(x, y)=1]</script><p>可以类似线性筛那样感性理解。</p><p>然后就可以直接做了：</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)\\=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}[(x, y)=1]\\=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}\sum_{d|x\operatorname{and} d|y} \mu(d)\\=&\sum_{x = 1}^n \sum_{y = 1}^m\lfloor\frac{n}{x}\rfloor\cdot \lfloor\frac{m}{y}\rfloor\cdot \sum_{d|x\operatorname{and} d|y} \mu(d)\\=&\sum_{d = 1}^n \mu(d) \sum_{x = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\cdot \lfloor\frac{m}{dy}\rfloor\\\end{aligned}</script><p>发现后面这东西可以很简单地</p><p>预处理，所以复杂度 $O(q\cdot\sqrt n)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 $\mu$ 函数具有如下性质：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\sum_{d|n} \mu(d)=[n=1]&lt;/script&gt;&lt;p&gt;大部分有关于 $\gcd$ 、带有艾佛森括号的反演题目都可以用这个性质解决。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫比乌斯反演" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】回滚莫队</title>
    <link href="https://www.orchidany.cn/2020/01/23/%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F/"/>
    <id>https://www.orchidany.cn/2020/01/23/回滚莫队/</id>
    <published>2020-01-23T13:05:46.000Z</published>
    <updated>2020-02-04T10:36:21.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种离线算法，用于巧妙维护没有删除操作的离线序列问题。一般情况下都可以转化成普通的莫队带一个 ds 的 $\log$ 做法，可以比较简单地去维护某些不能差分的操作（即 <code>del</code> 比较难以实现，比如 $\max$）。</p><a id="more"></a><p>考虑不同于普通莫队的另一种做法。</p><p>首先还是将所有询问排序。考虑一种根号分治的做法：</p><ul><li><p>对于两个端点在同一个块内的直接跑暴力，总复杂度是 $O(qB)$；</p></li><li><p>两个端点不在一个块内的，考虑把连个指针都指针移到下一个块的开头，途中对每个点只撤销贡献而不删除贡献，之后 $r$ 单调向右移，$l$ 向左移，添加过程中计算贡献——其中控制 $r$ 单增的原因是 $r$ 的移动步长是 $O(n)$ 的，但每次 $l$ 的移动步长是 $O(B)$ 的。</p></li></ul><p>这样的话，复杂度就是 $O(qB+\frac{n^2}{B})$ 。简单地均值一下发现还是 $O(n\sqrt q)$ 的。</p><p>那看上去除了复杂度分析很莫队，本质上就是个根号分治啊。</p><h1 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h1><blockquote><p>给定一堆事件：</p><ol><li>选择日记中连续的一些天作为分析的时间段</li><li>事件种类 $t$ 的重要度为 $t$  $\times$ (这段时间内种类为 $t$ 的事件数)。</li><li>计算出所有事件种类的重要度，输出其中的最大值 现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值.</li></ol></blockquote><p>发现插入很简单，但是由于求的是 $\max$，所以朴素地删除会让答案难以统计。于是考虑直接上回滚莫队。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line">LL res ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line">LL ans[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"><span class="keyword">int</span> n, w, m, b, bnum ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs p1,qs p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[p1.l] ^ blg[p2.l] )</span><br><span class="line">        <span class="keyword">return</span> blg[p1.l] &lt; blg[p2.l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p1.r &lt; p2.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, LL &amp; ret)</span></span>&#123;</span><br><span class="line">    buc[base[p]] ++ ;</span><br><span class="line">    ret = max(ret, <span class="number">1l</span>l * buc[base[p]] * g[p]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bucc[N] ;</span><br><span class="line"><span class="function">LL <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    LL ret ; ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        ret = max(ret, <span class="number">1l</span>l * bucc[base[i]] * g[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] -- ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, lb ;</span><br><span class="line">    b = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n) ; bnum = n / b + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i]), t[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        L[i] = (i - <span class="number">1</span>) * b + <span class="number">1</span>, R[i] = i * b ;</span><br><span class="line">    R[bnum] = min(R[bnum], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i] ; j &lt;= R[i] ; ++ j)</span><br><span class="line">            blg[j] = i ; sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    w = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + w + <span class="number">1</span>, g[i]) - t ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; base[i] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp), l = <span class="number">1</span>, r = <span class="number">0</span>, lb = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; q[i].l &lt;&lt; " " &lt;&lt; q[i].r &lt;&lt; endl ;</span></span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] ^ lb)&#123;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; R[blg[q[i].l]]) del(r --) ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; R[blg[q[i].l]] + <span class="number">1</span>) del(l ++) ;</span><br><span class="line">            res = <span class="number">0</span> ; lb = blg[q[i].l] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ul = l ; LL anss = res ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">        anss = res ; <span class="keyword">while</span> (ul &gt; q[i].l) add(-- ul, anss) ;</span><br><span class="line">        <span class="keyword">while</span> (ul &lt; l) del(ul ++) ; ans[q[i].id] = anss ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LG-5906-回滚莫队"><a href="#LG-5906-回滚莫队" class="headerlink" title="LG 5906 回滚莫队"></a>LG 5906 回滚莫队</h1><blockquote><p>给定一个序列，多次询问一段区间 $[l,r]$，求区间中<strong>相同的数的最远间隔距离</strong>。</p><p>序列中两个元素的<strong>间隔距离</strong>指的是<strong>两个元素下标差的绝对值</strong>。</p><p>$1\leq n,m\leq 2\cdot 10^5$</p></blockquote><p>本质上第一次见这题是某次校内胡策 <a href="https://www.luogu.com.cn/problem/U96381" target="_blank" rel="noopener">戳我</a>。之后发现原来是 <code>codechef</code> 上的题，然后就自己出了数据放到了谷上……然而数据十分的水……虽然我觉得我是精心构造了…233</p><p>然后这题其实是道好题…原因就是上一道题是不完全版的回滚莫队：上一道题的左端点 <code>add</code> 和右端 <code>add</code> 可以一样，因为第二层信息 <code>buc</code> 可以差分，即如果现减成 $-1$ 后来是可以加回来的；但是这道题的话，如果记录上一个和下一个相同的数字的位置会有很麻烦的边界，大部分做法都是赋值为 $0$ 或 $n$ ，但这样就会丢失信息，也就是左端点的 <code>add</code> 和右端点的 <code>add</code> 要分开处理。</p><p>所以如果铁憨憨地拿头写就会由很多边界，所以比较好的处理方式：</p><h2 id="询问分块处理"><a href="#询问分块处理" class="headerlink" title="询问分块处理"></a>询问分块处理</h2><p>大概就是每个块清零一次，直接让两个指针回归。这样做不容易错，但复杂度是满的 $\frac{n^2}{\sqrt m}$ （因为每个块都是 $\Theta(n)$ 的清零）。所以大概可以改下块大小来微调？但其实这题我出的所有 $n,m$ 差不超过 $5$ …233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, x, y ;</span><br><span class="line"><span class="keyword">int</span> val[N], base[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N], tmp[N], suf[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> qs &amp;a, <span class="keyword">const</span> qs &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) tmp[base[i]] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[base[i]] = Min(tmp[base[i]], i), ret = Max(ret, i - tmp[base[i]]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    suf[base[p]] = Max(suf[base[p]], p) ;</span><br><span class="line">    pre[base[p]] = Min(pre[base[p]], p) ;</span><br><span class="line">    res = Max(res, suf[base[p]] - pre[base[p]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> bnum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s, L = Min(n, bnum * b) ;</span><br><span class="line">    <span class="keyword">int</span> l = L + <span class="number">1</span>, r = L ; res = <span class="number">0</span> ;</span><br><span class="line">    fill(pre + <span class="number">1</span>, pre + len + <span class="number">1</span>, n) ;</span><br><span class="line">    fill(suf + <span class="number">1</span>, suf + len + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span>( ; blg[q[i].l] == bnum ; ++ i )&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> anss = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tmp[base[j]] = n ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">            tmp[base[j]] = Min(tmp[base[j]], j) ;</span><br><span class="line">            anss = max(anss, Max(j - tmp[base[j]], suf[base[j]] - j)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id] = max(anss, res) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr(), val[i] = base[i] ;</span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>) ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    len = unique(val + <span class="number">1</span>, val + n + <span class="number">1</span>) - val - <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(val + <span class="number">1</span>, val + len + <span class="number">1</span>, base[i]) - val ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        q[i].l = qr(), q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = (i - <span class="number">1</span>) / b + <span class="number">1</span> ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; <span class="keyword">int</span> L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blg[n] ; ++ i) &#123;</span><br><span class="line">        L = solve(L, i) ; <span class="keyword">if</span> (L &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有函数展开"><a href="#把所有函数展开" class="headerlink" title="把所有函数展开"></a>把所有函数展开</h2><p>没写过，因为个人认为会搞乱码风。</p><hr><h2 id="瞎写"><a href="#瞎写" class="headerlink" title="瞎写"></a>瞎写</h2><p>于是个人最初的写法是这样的，十分吊诡：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400100</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> buf[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[M] ;</span><br><span class="line"><span class="keyword">int</span> tbuc[N] ;</span><br><span class="line"><span class="keyword">int</span> bucp[N] ;</span><br><span class="line"><span class="keyword">int</span> bucs[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[a.l] ^ blg[b.l])</span><br><span class="line">        <span class="keyword">return</span> blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buf[base[i]]) buf[base[i]] = i ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = max(ret, i - buf[base[i]]) ;</span><br><span class="line">            buf[base[i]] = min(i, buf[base[i]]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buf[base[i]]) buf[base[i]] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    bucp[base[x]] = N ;</span><br><span class="line">    bucs[base[x]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">    bucs[base[x]] = max(x, bucs[base[x]]) ;</span><br><span class="line">    bucp[base[x]] = min(x, bucp[base[x]]) ;</span><br><span class="line">    val = max(val, bucs[base[x]] - bucp[base[x]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = i / b ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bucs[i] = <span class="number">0</span>, bucp[i] = N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (blg[q[i].l] &gt; k)&#123;</span><br><span class="line">                <span class="keyword">while</span> (blg[r] &lt;= blg[q[i].l]) del(r ++)  ;</span><br><span class="line">                <span class="keyword">while</span> (blg[r] &gt; blg[q[i].l]) del(r --) ;</span><br><span class="line">                <span class="keyword">while</span> (blg[l] &lt;= blg[q[i].l]) del(l ++) ;</span><br><span class="line">                add(++ r, res) ; res = <span class="number">0</span> ; k = blg[q[i].l] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t, fl = l, ress = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tbuc[base[j]] = N ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">                t = base[j] ;</span><br><span class="line">                tbuc[t] = min(j, tbuc[t]) ;</span><br><span class="line">                ress = max(ress, max(j - tbuc[t], bucs[t] - j)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[q[i].id] = max(ress, res) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界很烦人…很烦人…当然个人实力菜占主要原因…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一种离线算法，用于巧妙维护没有删除操作的离线序列问题。一般情况下都可以转化成普通的莫队带一个 ds 的 $\log$ 做法，可以比较简单地去维护某些不能差分的操作（即 &lt;code&gt;del&lt;/code&gt; 比较难以实现，比如 $\max$）。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上莫队</title>
    <link href="https://www.orchidany.cn/2020/01/23/%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F/"/>
    <id>https://www.orchidany.cn/2020/01/23/树上莫队/</id>
    <published>2020-01-23T13:05:32.000Z</published>
    <updated>2020-01-31T14:32:35.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯…好…序列数据结构就是用来上树的嘛/kk</p><p>发现首先树上分块很好处理，比较麻烦的一点在于，如何从 $(ou,ov)$ 这条路径移动到 $(nu,nv)$。</p><p>发现莫队的精髓在于排完序之后左右端点的移动是独立的，所以考虑如何转化成 $(ou,nu)$ 和 $(ov,nv)$。</p><a id="more"></a><h1 id="1-瞎构造"><a href="#1-瞎构造" class="headerlink" title="$1$ 瞎构造"></a>$1$ 瞎构造</h1><p><del>蜜汁more.jpg</del></p><p>有一个很常见的定理，就是「树上两条路径如果有交点，那么一定是在其中一条路径两端点的 $lca$   」。</p><p>证明暂时不知道（但是我有在思考）什么比较优美的证明。但遇到这种情况总是可以分类讨论的…略了略了</p><p>于是为了不处理本来就有交点的情况，莫队上树选择维护 $p(u,v)=(u,v)\setminus\{lca(u,v)\}$ 。发现这东西有很好的性质，即 </p><script type="math/tex; mode=display">p(u,v)~\mathrm{xor}~ p(x,y)=p(x, u) \text { xor } p(v, y)</script><p>其中 $~\mathrm{xor}~$ 定义在集合上。</p><p>证明大概是考虑令 $r(x)$ 表示 $x$ 到根节点的路径的点集。那么就可以这么化式子：</p><script type="math/tex; mode=display">\begin{aligned}p(u,v)~\mathrm{xor}~ p(x,y)&=p(x, u) \text { xor } p(v, y)\\(r(u) ~\mathrm{xor}~ r(v))~\mathrm{xor}~(r(x) ~\mathrm{xor}~ r(y))&=(r(u) ~\mathrm{xor}~ r(x))~\mathrm{xor}~(r(v) ~\mathrm{xor}~ r(y))\\\end{aligned}</script><p>然后接下来懒得写了，发现就是个交换律+结合律的套路。</p><p>于是考虑每次把 $p(ou,nu)$ 和 $p(ov, nv)$ 内的点全部取反，单独处理一下 $lca$ 就好了。</p><h1 id="2-如何分块"><a href="#2-如何分块" class="headerlink" title="$2$ 如何分块"></a>$2$ 如何分块</h1><p>发现就是 <code>loj#2151王室联邦</code> 这题的分块方式。似乎这东西证明的话可以直接归纳出来？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = tp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u]; k; k = next(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to(k), u);</span><br><span class="line">        <span class="keyword">if</span> (tp - base &gt;= S) &#123;</span><br><span class="line">            cap[++Id] = u;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; base) </span><br><span class="line">              blg[s[tp--]] = Id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[++tp] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i, u, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[s[tp--]] = Id;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">cout</span> &lt;&lt; blg[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Id; ++i) <span class="built_in">cout</span> &lt;&lt; cap[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-例题"><a href="#3-例题" class="headerlink" title="$3$ 例题"></a>$3$ 例题</h1><h2 id="1-SP10707-Count-On-a-Tree-2"><a href="#1-SP10707-Count-On-a-Tree-2" class="headerlink" title="$1$ SP10707 Count On a Tree 2"></a>$1$ SP10707 Count On a Tree 2</h2><blockquote><p>给定一个 $n$ 个节点的树，每个节点表示一个整数。</p><p>$q$ 组询问，询问 $u$ 到 $v$ 的路径上有多少个不同的整数。</p></blockquote><p>套路题？不禁思考我都做了些什么浪费时间的题啊…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[M] ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> son[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> n, q, len ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> top[N], sz[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; u &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">int</span> old = tp ; sz[u] = <span class="number">1</span> ;</span><br><span class="line">    fa[u] = f, dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f)&#123;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line"><span class="keyword">if</span> (tp - old &gt;= b)&#123;</span><br><span class="line">            ++ bnum ;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; old)</span><br><span class="line">   blg[stk[tp --]] = bnum ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f &amp;&amp; to(k) != son[u]) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qss a, qss b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.u] == blg[b.u] ? blg[a.v] &lt; blg[b.v] : blg[a.u] &lt; blg[b.u] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v) ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[x])</span><br><span class="line">        res += !buc[base[x]] ++ ;</span><br><span class="line">    <span class="keyword">else</span> res -= !-- buc[base[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) rev(u), u = fa[u] ;</span><br><span class="line">    <span class="keyword">while</span> (u != v) rev(u), rev(v), u = fa[u], v = fa[v] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ; </span><br><span class="line"><span class="keyword">int</span> u, v, f ; b = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + n + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; bnum ++ ;</span><br><span class="line"><span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ; </span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qs[i].u, &amp;qs[i].v), qs[i].id = i ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; lca(5, 8) &lt;&lt; " " &lt;&lt; lca(2, 7) &lt;&lt; " " &lt;&lt; lca(3, 7) &lt;&lt; endl ; </span></span><br><span class="line">    sort(qs + <span class="number">1</span>, qs + q + <span class="number">1</span>, comp) ; u = v = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        movemove(u, qs[i].u) ; u = qs[i].u ;</span><br><span class="line">        movemove(v, qs[i].v) ; v = qs[i].v ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qs[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>btw，感觉自己码风好多了？</p><h2 id="2-uoj-53-WC2013-糖果公园"><a href="#2-uoj-53-WC2013-糖果公园" class="headerlink" title="$2$ uoj#53 [WC2013]糖果公园"></a>$2$ uoj#53 [WC2013]糖果公园</h2><blockquote><p>给出一棵 $n$ 个点的树，每个节点有一个颜色。</p><p>每次或者询问你一条路径求 $\sum_{c}val_c\sum_{i=1}^{cnt_c}w_i$，或者更改一个点的颜色。</p><p>其中 $val$ 表示该颜色的价值, $cnt$ 表示其出现的次数, $w_i$ 表示第 $i$ 次出现的价值。</p><p>可以离线。</p></blockquote><p>发现就是树上莫队套了一个带修？</p><p>写起来没什么感觉…就是很长…很长…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, c ;</span><br><span class="line">&#125;us[Q] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">int</span> t, id ;</span><br><span class="line">&#125;qy[Q] ;</span><br><span class="line">LL res ;</span><br><span class="line">LL ans[Q] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> cntu, cntq ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> sz[N], son[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N], vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], top[N] ;</span><br><span class="line"><span class="keyword">int</span> val[M], wth[M], clr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u] = f ; <span class="keyword">int</span> t = tp ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), u) ; sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">        <span class="keyword">if</span> (tp - t &gt;= b)&#123;</span><br><span class="line">            ++ bnum ;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; t)</span><br><span class="line">                blg[stk[tp --]] = bnum ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != f) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            u ^= v ^= u ^= v ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.u] == blg[c.u]) ?</span><br><span class="line">           ((blg[a.v] == blg[c.v]) ? a.t &lt; c.t : blg[a.v] &lt; blg[c.v]) : (blg[a.u] &lt; blg[c.u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])</span><br><span class="line">        res -= <span class="number">1l</span>l * wth[buc[clr[x]] --] * val[clr[x]] ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res += <span class="number">1l</span>l * wth[++ buc[clr[x]]] * val[clr[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[x] &gt; dep[y]) rev(x), x = fa[x] ;</span><br><span class="line">    <span class="keyword">while</span> (x != y) rev(x), rev(y), x = fa[x], y = fa[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, l, r, mk, t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wth[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;clr[i]) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; endl ;</span></span><br><span class="line">    b = <span class="built_in">pow</span>(<span class="number">1.0</span> * n, <span class="number">0.6667</span>) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; ++ bnum ;</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ;dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) ;</span><br><span class="line">    u = <span class="number">1</span>, v = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; lca(1, 3) &lt;&lt; " " &lt;&lt; lca(2,4) &lt;&lt; " " &lt;&lt; lca(1, 4) &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " "  ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;mk, &amp;l, &amp;r) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)</span><br><span class="line">            qy[++ cntq].u = l, qy[cntq].v = r,</span><br><span class="line">            qy[cntq].t = cntu, qy[cntq].id = cntq ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            us[++ cntu].p = l, us[cntu].c = r ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(qy + <span class="number">1</span>, qy + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)&#123;</span><br><span class="line">        movemove(u, qy[i].u) ;</span><br><span class="line">        movemove(v, qy[i].v) ;</span><br><span class="line">        u = qy[i].u, v = qy[i].v ;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; qy[i].t)&#123;</span><br><span class="line">            ++ t ;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; qy[i].t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">            t -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qy[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯…好…序列数据结构就是用来上树的嘛/kk&lt;/p&gt;
&lt;p&gt;发现首先树上分块很好处理，比较麻烦的一点在于，如何从 $(ou,ov)$ 这条路径移动到 $(nu,nv)$。&lt;/p&gt;
&lt;p&gt;发现莫队的精髓在于排完序之后左右端点的移动是独立的，所以考虑如何转化成 $(ou,nu)$ 和 $(ov,nv)$。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】简单莫队瞎吹</title>
    <link href="https://www.orchidany.cn/2020/01/23/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E4%B8%8E%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F/"/>
    <id>https://www.orchidany.cn/2020/01/23/普通莫队与带修莫队/</id>
    <published>2020-01-23T13:05:18.000Z</published>
    <updated>2020-02-03T14:54:36.470Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>…感觉这东西似乎也没啥好说的啊</p><a id="more"></a><h1 id="1-理论瞎吹"><a href="#1-理论瞎吹" class="headerlink" title="$1$ 理论瞎吹"></a>$1$ 理论瞎吹</h1><p>大概就是个分块？但是是对询问分块的。莫队的精髓在于排序，排序时如果 <code>belong[l]</code> 相同复杂度就按照右端点排序，这样似乎是有保证的？</p><p>令 $m$ 为操作数，$B$ 为块大小。考虑对于一个块内的 $l$，其 $r$ 是单增的，于是考虑如下：</p><ul><li>左端点，在块内可能会一前一后这样设置，这样复杂度被卡到最满，为 $O(m\cdot B)$ ；</li><li>右端点，考虑各块内的询问显然都可以做到单块 $O(n)$，所以不需要考虑 $m$ 的贡献，即右端点移动的复杂度就是 $\frac{n}{B}\cdot n=\frac{n^2}{B}$。</li></ul><p>均值一下发现 $m\cdot B+\frac{n^2}{B}\geq 2\sqrt{n^2m}=O(n\sqrt m)$ ，此时有 $m\cdot B=\frac{n^2}{B}$，解得 $B=\frac{n}{\sqrt m}$ .</p><p>所以取块大小为 $\frac{n}{\sqrt m}$ 时达到理论最优，复杂度为 $O(n\sqrt m)$ 。</p><p>…当然这东西可能不准，毕竟常数稍微优一点可能就可以瞎分块了233</p><p>然后考虑如何带修改(当然只能离线做)。发现单纯地平移询问区间不对，于是考虑加一维时间轴，在平移完询问之后平移修改操作。排序时把「离当前询问最近的前一个修改操作是第几次修改」作为第三关键字，第二关键字换成「右端点所在块的编号」。</p><p>令 $c$ 为修改个数， $q$ 为询问个数，$B$ 依旧为块大小。那么考虑三维指针是怎么移动的：</p><ul><li>左端点和右端点依次还是 $qB+\frac{n^2}{B}$ ；</li><li>时间端点，考虑时间端点实际上每次至多移动 $c$，但是时间端点之外此时套了一层按 <code>belong[r]</code> 分的块，所以这一部分的复杂度为 $O(c\times\frac{n^2}{B^2})$ .</li></ul><p>于是总复杂度为 $O(\frac{n^2c}{B^2}+qB+\frac{n^2}{B})$。</p><p>这个东西他怎么求 $\min$ 呢…</p><p><del>嗯，你看这个式子这么可爱，求导总是可以求出来的吧，于是就不详细写了</del>~</p><p>直接上结论，$B=O(n^{\frac{2}{3}})$ 时最优，此时复杂度为 $O(n^{\frac{2}{3}}c+n^{\frac{2}{3}}q+n^\frac{4}{3})=O(n^{\frac{2}{3}}m)$。</p><p>发现这东西很好的一点就是，这么分块，复杂度不会受操作类型影响，因为 $q+c=m$ 是根据已知推出来，不是放缩放掉的。所以是个很满分的复杂度。</p><h1 id="2-水题瞎做"><a href="#2-水题瞎做" class="headerlink" title="$2$ 水题瞎做"></a>$2$ 水题瞎做</h1><h2 id="1-LG2709-小B的询问"><a href="#1-LG2709-小B的询问" class="headerlink" title="$1$ LG2709 小B的询问"></a>$1$ LG2709 小B的询问</h2><blockquote><p>给出长度为 $n$ 的序列，$q$ 组询问，每次询问区间 $[l,r]$ 内的 $\sum e_i^2$ 。其中 $e_i$ 表示数 $i$ 的出现次数。</p></blockquote><p>似乎是憨憨题？就是道普通的莫队。</p><p>不过学了一招，就是奇偶块的 $r$ 坐标反向排序。这样似乎理论应该带一个下界为 $\frac{1}{2}$ 的常数。但实际应用可能并不明显。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> blg[a.l] == blg[b.l] ? ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans -= (<span class="number">2l</span>l * buc[base[p]] - <span class="number">1l</span>l), buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans += (<span class="number">2l</span>l * buc[base[p]] + <span class="number">1l</span>l), buc[base[p]] ++ ; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-LG1494-小Z的袜子"><a href="#2-LG1494-小Z的袜子" class="headerlink" title="$2$ LG1494 小Z的袜子"></a>$2$ LG1494 小Z的袜子</h2><blockquote><p>给出一个长为 $n$ 的序列，每次询问 $[l,r]$ 内，随机取两个数取到相同的数的概率。</p></blockquote><p>大概也是个憨憨题…发现最后结果就是 $\frac{\mathrm{cnt(same_pair)}}{\binom{r-l+1}{2}}$。</p><h2 id="3-LG3709-大爷的字符串题"><a href="#3-LG3709-大爷的字符串题" class="headerlink" title="$3$ LG3709 大爷的字符串题"></a>$3$ LG3709 大爷的字符串题</h2><p>这题nmd是道语文题…</p><blockquote><p>原题面：</p><p>给你一个字符串 $a$，每次询问一段区间的贡献</p><p>贡献定义：</p><p>每次从这个区间中拿出一个字符 $x$，然后把 $x$ 从这个区间中删除，你要维护一个集合 $\rm S$：如果 $\rm S$ 为空，你 $rp$ 减 $1$ ; 如果 $\rm S$ 中有一个元素不小于 $x$，则你 $rp$  减 $1$，清空 $\rm S$；之后将 $x$ 插入 $\rm S$ 。</p><p>由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 $rp$ ？$rp$ 初始为 $0$，询问之间不互相影响。</p></blockquote><p>发现大概是在说，每次给定一个区间，要从中取出最少数量的严格上升子序列使得覆盖所有的数。发现其实就是「区间内出现次数最多的数」出现的次数。</p><p>这东西也比较容易维护，再拿另一个 $bucbuc$ 来维护 $buc$ 就解决了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">rg <span class="keyword">int</span> t = ++ buc[base[p]] ; </span><br><span class="line">bucbuc[t] ++, bucbuc[t - <span class="number">1</span>] --, ans += (t &gt; ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">rg <span class="keyword">int</span> t = -- buc[base[p]] ;</span><br><span class="line">bucbuc[t] ++, bucbuc[t + <span class="number">1</span>] --, ans -= !bucbuc[ans] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是离散化之后的，复杂度就是比较稳的 $m \sqrt n$ 了。</p><p>但是还有一个不费脑子的方法，就是第一个 $buc$ 直接用 <code>std:: unordered_map</code> 来实现。但这东西首先复杂度是个谜，你说他是 $O(1)$ 的，但是确实很慢；你说他是 $\log$ 的，但毕竟只是个 $Hash$ 表，实在没理由是 $\log$ 的。</p><p>嗯，具体实现可能是什么 「亚 $\log$」 的Hash表吧。</p><h2 id="4-LG1903-国家集训队-数颜色"><a href="#4-LG1903-国家集训队-数颜色" class="headerlink" title="$4$  LG1903 [国家集训队]数颜色"></a>$4$  LG1903 [国家集训队]数颜色</h2><blockquote><p>询问区间内不同的数的个数+带修。</p></blockquote><p>这有啥好说的啊？</p><p>不过有一点需要注意：由于时间轴左右横跳要消除贡献，所以需要记录一下每个位置修改之前的值。这个地方直接 <code>std:swap</code> 做就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> blg[a.l] == blg[b.l] ? </span><br><span class="line">  (blg[a.r] == blg[b.r] ? a.t &lt; b.t : blg[a.r] &lt; blg[b.r]) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!-- buc[base[p]]) -- ans ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!buc[base[p]] ++) ++ ans ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> l, r, v, p, i, j ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (In[<span class="number">1</span>] == <span class="string">'Q'</span>)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r), q[++ cntq].t = cntm, </span><br><span class="line">q[cntq].l = l, q[cntq].r = r, q[cntq].id = cntq ;  </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v), m[++ cntm].p = p, m[cntm].c = v ;</span><br><span class="line">&#125;</span><br><span class="line">B = <span class="built_in">pow</span>((<span class="keyword">double</span>)N, <span class="number">0.677</span>), </span><br><span class="line">Bnum = <span class="built_in">ceil</span>((<span class="keyword">double</span>)N / (<span class="keyword">double</span>)B) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Bnum ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = B * i + <span class="number">1</span> ; j &lt;= B * (i + <span class="number">1</span>) ; ++ j) blg[j] = i + <span class="number">1</span> ;</span><br><span class="line">l = <span class="number">1</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>, T = <span class="number">0</span> ;</span><br><span class="line">sort(q + <span class="number">1</span>, q + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ;</span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ; </span><br><span class="line"><span class="keyword">while</span> (q[i].t &gt; T)&#123;</span><br><span class="line">++ T ;</span><br><span class="line"><span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line"><span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line"><span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">&#125;</span><br><span class="line">swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q[i].t &lt; T)&#123;</span><br><span class="line"><span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line"><span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line"><span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">&#125;</span><br><span class="line">swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">-- T ;</span><br><span class="line">&#125;</span><br><span class="line">res[q[i].id] = ans ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cntq ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎选的都是很水的…剩下的题需要脑子，我莫得脑子，所以就先这样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;…感觉这东西似乎也没啥好说的啊&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记&amp;题解】线段树优化建图</title>
    <link href="https://www.orchidany.cn/2020/01/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/"/>
    <id>https://www.orchidany.cn/2020/01/23/线段树优化建图/</id>
    <published>2020-01-23T13:04:32.000Z</published>
    <updated>2020-01-26T13:38:21.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是把边数从 $n^2$ 优化到 $n\log n$ 的一个操作？还是挺简单的吧。</p><a id="more"></a><h1 id="0-瞎扯"><a href="#0-瞎扯" class="headerlink" title="$0$ 瞎扯"></a>$0$ 瞎扯</h1><p>考虑三个场景：从 $[l_1,r_1]$ 连向 $x$, 从 $x$ 连向 $[l_2,r_2]$，从 $[l_1,r_1]$ 连向 $[l_2,r_2]$ 。</p><p>发现可以用两棵线段树来模拟这个东西，一棵线段树从 $rt$ 向 $lc,rc$ 连边，一棵从 $lc,rc$ 向 $rt$ 连边。只要把叶子节点设置为 $1\sim n$ ，这样最终点数就是 $O(n\log n)$ 的。稳得很。</p><p>然后就没有然后了。</p><h1 id="1-CF786B-Legacy"><a href="#1-CF786B-Legacy" class="headerlink" title="$1$ CF786B Legacy"></a>$1$ CF786B Legacy</h1><blockquote><p>给定一张 $n$ 个点的图，有 $m$ 个下列操作：</p><ul><li><p>1.进行单点与单点连有向边 </p></li><li><p>2.进行单点与区间连有向边 </p></li><li><p>3.进行区间与单点连有向边。</p></li></ul><p>求最短路。</p></blockquote><p>发现就是个板子？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[NN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">LL dis[NN] ;</span><br><span class="line"><span class="keyword">int</span> n, m, s ;</span><br><span class="line"><span class="keyword">bool</span> vis[NN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="keyword">int</span> Id, head[NN], cnt ;</span><br><span class="line"><span class="keyword">int</span> rt1, rt2, lc[NN], rc[NN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = val,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid, p) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">    <span class="keyword">if</span> (!p) add(rt, lc[rt], <span class="number">0</span>), add(rt, rc[rt], <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">else</span> add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        p ? add(rt, u, w) : add(u, rt, w) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w, p) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    Id = n, <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; s ;</span><br><span class="line">    build(rt1, <span class="number">1</span>, n, <span class="number">0</span>) ;</span><br><span class="line">    build(rt2, <span class="number">1</span>, n, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> mk, u, v, w, l, r ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt1, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt2, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; " " &lt;&lt; E[i].val &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    fill(dis, dis + Id + <span class="number">1</span>, Inf) ;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        vis[n] = <span class="number">0</span>, q.pop() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[n] + val(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[n] + val(k) ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, dis[i] == Inf ? <span class="number">-1</span> : dis[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-LG3588-POI2015-PUS"><a href="#2-LG3588-POI2015-PUS" class="headerlink" title="$2$ LG3588 [POI2015]PUS"></a>$2$ LG3588 [POI2015]PUS</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $a$ ,每个数都在 $1$ 到 $10^9$ 范围内,告诉你其中 $s$ 个数.</p><p>给出 $m$ 条信息,每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数,表示 $a_l..a_{l+1}…a_{r-1}..a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大 (严格大于，即没有等号)</p><p>构造一组合法解或者输出 $-1$ </p></blockquote><p>似乎就是一个差分约束？发现每次需要从每个 $k_{i,j}$ 连向剩下的子区间。如果用线段树优化建图，这样就是 $\sum k_i^2\log k_i$ 的边数，炸的很惨。</p><p>这个地方有个很妙的 $\rm Idea$ ，即对每个操作建立一个新点 $p_i$，让每个 $k_{i,j}$ 连向 $p_i$，再让 $p_i$ 连向每个分割开的子区间。这样就成功地只需要 $\sum O(k_i\log k_i)$ 的空间，很稳。</p><p><del>话说这还是自己第一次真正去写差分约束</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = val, deg[v] ++ ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) <span class="keyword">return</span> add(rt, u, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; m ;</span><br><span class="line">    Id = n ; build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), base[u] = dis[u] = v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k) ;</span><br><span class="line">        Id ++, last = l - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v) ; add(Id, v, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (last + <span class="number">1</span> &lt; v)</span><br><span class="line">update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, v - <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            last = v ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last &lt; r)</span><br><span class="line">            update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, r, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dis[i]) dis[i] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        u = q.front() ; q.pop() ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = max(dis[to(k)], dis[u] + val(k)) ;</span><br><span class="line">            <span class="keyword">if</span> (base[to(k)] &amp;&amp; dis[to(k)] &gt; base[to(k)])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i] || dis[i] &gt; Inf) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"TAK"</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dis[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-SNOI2017-炸弹"><a href="#3-SNOI2017-炸弹" class="headerlink" title="$3$ [SNOI2017]炸弹"></a>$3$ [SNOI2017]炸弹</h1><blockquote><p>在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $x_i$，爆炸半径是 $r_i$。</p><p>当一个炸弹爆炸时，如果另一个炸弹所在位置 $x_j$ 满足： $|x_j-x_i| \le r_i$ ，那么，该炸弹也会被引爆。计算先把第 $i$ 个炸弹引爆，将引爆多少个炸弹。</p><p>答案对 $10^9+7$ 取模。保证 $x_i$ 随着 $i$ 单增。</p></blockquote><p>发现可以先二分出每个点要连的左右端点。然后考虑缩点。由于是 $\rm DAG$ 就可以直接求出每个点能到达的点的编号的 $\min,\max$ ，这东西可以一遍 $\rm topsort$ 求出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">8000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N], tp ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">LL x[N], r[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> SCC, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> n, Id, root ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">3</span>][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N] ;</span><br><span class="line"><span class="keyword">int</span> lc[N * <span class="number">3</span>], rc[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, fr(cnt) = u,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        rt = l ;</span><br><span class="line">        val[l][<span class="number">0</span>] = l ;</span><br><span class="line">        val[l][<span class="number">1</span>] = l ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(rt, lc[rt]) ; add(rt, rc[rt]) ;</span><br><span class="line">    val[rt][<span class="number">0</span>] = val[lc[rt]][<span class="number">0</span>] ;</span><br><span class="line">    val[rt][<span class="number">1</span>] = val[rc[rt]][<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul ,<span class="keyword">int</span> ur, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> f == rt ? <span class="keyword">void</span>() : add(f, rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, ul, ur, f) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, ul, ur, f) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++ tp] = x, vis[x] = <span class="number">1</span> ;</span><br><span class="line">    dfn[x] = low[x] = ++ tot ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to(k)])</span><br><span class="line">            tarjan(to(k)),</span><br><span class="line">            low[x] = min(low[x], low[to(k)]) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            low[x] = min(low[x], dfn[to(k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> now ;</span><br><span class="line">        L[++ SCC] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (tp)&#123;</span><br><span class="line">            now = s[tp --] ;</span><br><span class="line">            L[SCC] = min(L[SCC], val[now][<span class="number">0</span>]) ;</span><br><span class="line">            R[SCC] = max(R[SCC], val[now][<span class="number">1</span>]) ;</span><br><span class="line">            vis[now] = <span class="number">0</span>, blg[now] = SCC ;</span><br><span class="line">            <span class="keyword">if</span> (now == x) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> lq, rq ; LL xx, oo ;</span><br><span class="line">    Id = n, build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; fr(i) &lt;&lt; " " &lt;&lt; to(i) &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x[i], &amp;r[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        xx = x[i], oo = r[i] ;</span><br><span class="line">        lq = lower_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx - oo) - x ;</span><br><span class="line">        rq = upper_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx + oo) - x ;</span><br><span class="line">        rq -- ; <span class="keyword">if</span> (lq &lt;= rq) update(root, <span class="number">1</span>, n, lq, rq, i) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; lq &lt;&lt; " " &lt;&lt; rq &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; root &lt;&lt; endl ;</span></span><br><span class="line">    tarjan(root) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; " " &lt;&lt; SCC &lt;&lt; endl ;</span></span><br><span class="line">    tot = cnt, cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (blg[fr(i)] != blg[to(i)])</span><br><span class="line">            add(blg[to(i)], blg[fr(i)]), deg[blg[fr(i)]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= SCC ; ++ i) <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        oo = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[oo] ; k ; k = next(k))&#123;</span><br><span class="line">            L[to(k)] = min(L[to(k)], L[oo]) ;</span><br><span class="line">            R[to(k)] = max(R[to(k)], R[oo]) ;</span><br><span class="line">            <span class="keyword">if</span> (!-- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        (ans += <span class="number">1l</span>l * i * (R[blg[i]] - L[blg[i]] + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; L[blg[i]] &lt;&lt; " " &lt;&lt; R[blg[i]] &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是把边数从 $n^2$ 优化到 $n\log n$ 的一个操作？还是挺简单的吧。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="图论/普通建图技巧" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E6%99%AE%E9%80%9A%E5%BB%BA%E5%9B%BE%E6%8A%80%E5%B7%A7/"/>
    
      <category term="图论/线段树优化建图" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/"/>
    
  </entry>
  
</feed>
