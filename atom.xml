<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-xDowxKop" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xDowxKop"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-03-22T01:15:37.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ</p><p>如果可以的话，谢谢你喜欢我！</p><a id="more"></a><h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p><p>CSP-2019考的太菜，导致现在十分被动。</p><p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p><p>其实挺热爱算法的吧？</p><p>CF平时真的不是很常打，所以并不想给CF的ID。sorry啦。</p><p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p><p>QQ:2836531293</p><h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p><p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p><p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p><p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p><p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p><p>3.22upd: 最近又把曾经连续记了好长一段时间、原来是置顶的「闲扯」给归档了：<a href="[https://www.orchidany.cn/2019/12/15/%E9%97%B2%E6%89%AF/](https://www.orchidany.cn/2019/12/15/闲扯/">戳</a>)</p><h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p><p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p><h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p><p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p><h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p><p>我一个人很无聊的说QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ&lt;/p&gt;
&lt;p&gt;如果可以的话，谢谢你喜欢我！&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces [Global Round 7F] Wise Men</title>
    <link href="https://www.orchidany.cn/2020/03/22/GlobalRound7F/"/>
    <id>https://www.orchidany.cn/2020/03/22/GlobalRound7F/</id>
    <published>2020-03-22T03:46:24.000Z</published>
    <updated>2020-03-22T04:15:41.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个人。给出 $n$ 个人的「认识情况」(双向且保证合法)。</p><p>定义 <code>bool</code> 值函数 $K(i,j)$ 表示两个人是否认识。考虑一个 $n$ 个人编号的排列 $p$ ，定义其生成的 $01$ 串 $\{s_{n-1}\}$ 为 $\forall i\in[1,n-1]\cap\mathbb{Z_+},s_i=K(p_{i},p_{i+1})$。</p><p>统计对于 $2^{n-1}$ 种不同的 $01$ 串，有多少种排列可以生成它。</p><p>F1: $2\leq n\leq 14$ 。</p><p>F2 : $2\leq n\leq 18$ 。</p></blockquote><p>神仙计数题，再一次深深地明白了自己的弱小。</p><a id="more"></a><p>首先考虑，对于一个串 $s$ 而言，直接统计比较麻烦，麻烦在难以体现「不认识」这个限制上。所以考虑如何忽略这个限制。考虑忽略限制后，就变成了统计 $ans(s)$ 表示<strong>至少</strong>含有集合 $s$ 的排列数。</p><p>那么对于 $ans(s)$ 存在一个性质：如果 $s$ 和 $s’$ 中，连通分量状态相同，那么两个集合的 $ans$ 是等价的。此处连通分量指的是连续一段互相认识的人，状态相同指的是 $s$ 和 $s’$ 的这些段大小相同，排布可以不同。（比如 $0100111\Longleftrightarrow0011101\Longleftrightarrow1000111$） 。</p><p>证明很简单，因为对于生成 $01$ 的串而言，其方案数只在于有多少排列可以凑出这些 $1$ 的连续段而已。换言之就是由于是全排列，所以对称。</p><p>值得注意的是，对于一个长度为 $k$ 的 $1$ 连续段，其包含 $k+1$ 个互相认识的人，也就是该连通块大小为 $k+1$ 。</p><p>考虑如何求 $ans(s)$ 。注意到现在已经转化成了统计每一种对 $n$ 的拆分方式，有多少种排列数。那么一个比较自然的想法就是求下式</p><script type="math/tex; mode=display">\sum_{\begin{aligned}&t_1,t_2,t_3\cdots t_p\\ &\forall i,j,t_i\cap t_j=\empty \\&|t_1|+|t_2|+\cdots +|t_p|=n\end{aligned}} \prod_{k=1}^p f(t_k,|s_k|)</script><p>其中 $t_i$ 表示枚举的第 $i$ 个点集，$s_i$ 表示组成 $s$ 这个 $01$ 串的第 $i$ 个连通块(链形态的点集) ，$f_{i,j}$ 表示从 $size(i)=j$ 的集合 $i$ 里面选出一个大小为 $j$ 的<strong>链</strong>的方案数。不难知道这些限制的意义：划分必须恰好划分掉 $n$ 个点，且点集之间不存在交集(否则需要合并)。</p><p>上式的意义在于，对于 $s$ 的一个划分，每个连通块都需要从某个点集中选出，而点集之间是互不相交的，所以 $size$ 必须恰好是链长。于是可以从这个角度入手来求排列数。同时需要注意，由于我们是硬生生划定了 $p$ 个集合，并不关心集合之间是否有连边，也就代表了其中有些单点(也就是 $s$ 中的 $0$ 位置)可能是与其他连通块是一体的，这也就符合了我们对 $ans(s)$ 的定义：<strong>至少</strong>含有集合 $s$ 的排列数。</p><p>注意到 $f$ 是比较容易求得的。考虑 $g_{i,j}$ 表示集合 $i$ 以 $j$ 结尾的链的方案数，那么就是 $n^2$ 转移，保证每次都用最后一个点转移就可以使得形态是一条链。$f$ 就是对 $g$ 的一个累加。这一部分复杂度 $O(n^22^n)$ 。</p><p>考虑求出 $f$ 之后如何计算这个式子。一个比较直接的想法是暴力枚举子集的子集来转移，由于 $\Pi$ 对 $\Sigma$ 有分配律，可知转移是不难的。复杂度 $P(n)3^n$，其中 $P(n)$ 是本质不同的划分数。可以过掉 $n=14$ 的 $\rm F1$ 。</p><p>对于 $\rm F2$ ，考虑这么一个问题：如何保证一组相加起来 $size$ 等于全集的子集互不相交？很显然是如果他们的<strong>并</strong>就是全集，那么彼此之间一定不会有交。于是可以知道用 FMT 来优化这个过程。具体的，根据分配律，可以对每个 $s_i$ 分开计算其贡献，进行 $p$ 次 FMT 之后，答案就是第 $2^n-1$ 项系数。</p><p>那么就做完了。最后只需对于每个 $01$ 串，求出他的划分即可。注意到一开始 $ans$ 的定义，需要我们做一次子集差变换。大概类似于FMT处理and的逆过程。最终复杂度 $O(2^n(P(n)+n+n^2))$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_p pop_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1200000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line">ll I[M] ;</span><br><span class="line">ll t[M] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line">ll f[M][N] ;</span><br><span class="line">ll g[N][M] ;</span><br><span class="line">ll res[N * N] ;</span><br><span class="line"><span class="keyword">int</span> know[N][N] ;</span><br><span class="line"><span class="built_in">map</span>&lt;vint, <span class="keyword">int</span>&gt; Id ;</span><br><span class="line">vint part[N * N], now ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(ll *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = f[j] + (ll)g * f[j ^ (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_part</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> big)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st == n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(part[Id[now] = ++ tot] = now) ;</span><br><span class="line">    <span class="keyword">if</span> (n - st + <span class="number">1</span> &gt;= big)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = big ; i &lt;= n - st + <span class="number">1</span> ; ++ i)</span><br><span class="line">            now.p_b(i), dfs_part(st + i, i), now.p_p() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; ~i) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!know[j][k]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) <span class="keyword">continue</span> ;</span><br><span class="line">                f[i | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k] += f[i][j] ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ len ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i) g[len][i] += f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, I, <span class="keyword">sizeof</span>(I)) ;</span><br><span class="line">        <span class="keyword">int</span> o = (<span class="keyword">int</span>)part[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; o ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                t[k] *= g[part[i][j]][k] ;</span><br><span class="line">        fmt_or(t, <span class="number">-1</span>) ; res[i] = t[m] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        now.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r ; l &lt; n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = l ;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &amp; i &amp;&amp; r &lt; n)</span><br><span class="line">                ++ r ; now.p_b(r - l + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(now.begin(), now.end()) ;</span><br><span class="line">        ans[i] = res[Id[now]] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    I[<span class="number">0</span>] = <span class="number">1</span> ; fmt_or(I, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;know[i][j]) ; dp1() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fmt_or(g[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; g[i][j] &lt;&lt; " \n"[j == m] ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dfs_part(<span class="number">1</span>, <span class="number">1</span>) ; dp2() ; revalue() ;</span><br><span class="line">    <span class="comment">//for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; I[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    ((m += <span class="number">1</span>) &gt;&gt;= <span class="number">1</span>) -= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans[j] = ans[j] - ans[j | (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == m] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撒花撒花！！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个人。给出 $n$ 个人的「认识情况」(双向且保证合法)。&lt;/p&gt;
&lt;p&gt;定义 &lt;code&gt;bool&lt;/code&gt; 值函数 $K(i,j)$ 表示两个人是否认识。考虑一个 $n$ 个人编号的排列 $p$ ，定义其生成的 $01$ 串 $\{s_{n-1}\}$ 为 $\forall i\in[1,n-1]\cap\mathbb{Z_+},s_i=K(p_{i},p_{i+1})$。&lt;/p&gt;
&lt;p&gt;统计对于 $2^{n-1}$ 种不同的 $01$ 串，有多少种排列可以生成它。&lt;/p&gt;
&lt;p&gt;F1: $2\leq n\leq 14$ 。&lt;/p&gt;
&lt;p&gt;F2 : $2\leq n\leq 18$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神仙计数题，再一次深深地明白了自己的弱小。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="快速莫比乌斯变换(FMT)" scheme="https://www.orchidany.cn/tags/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2-FMT/"/>
    
      <category term="快速沃尔什变换(FWT)" scheme="https://www.orchidany.cn/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】Codeforces[Global Round 7] $\rm A\to E$</title>
    <link href="https://www.orchidany.cn/2020/03/20/CFGlobalRound7/"/>
    <id>https://www.orchidany.cn/2020/03/20/CFGlobalRound7/</id>
    <published>2020-03-20T15:14:05.000Z</published>
    <updated>2020-03-22T04:11:33.863Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一场相对来说还是比较简单的，至少 $A\to E$ 都是比较传统的题目。</p><p>因为F对我来说不是很general，于是单开了一篇文章整理F了。</p><p>不知道为什么，感觉所有Global Round里面，最喜欢的还是第一场。</p><p>唉，过去的事情，也就只能让它过去了吧。</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>构造一个 $n$ 位十进制数，保证不被该数的任意一位整除。</p><p>$1\leq n\leq 100000$</p></blockquote><p>感觉就是一个考反应能力的？？大概就是瞎构造。正确性似乎不是那么显然？唯一的不确定性就是这种做法可能出现末尾接上 $ 3\sim 9$ 都不合法的情况，然而似乎数据卡不了这一点。</p><p>仔细想一想的话，需要满足以下的条件：</p><script type="math/tex; mode=display">\begin{aligned}(n-1)*7+3 \equiv0\pmod 3\\\cdots\end{aligned}</script><p>好的，我刚刚写完关于 $3$ 的就发现了，只要是 $77777…7774$ 就一定合法。我太弟弟了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - <span class="number">1</span> ; ++ i)<span class="built_in">printf</span>(<span class="string">"7"</span>) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>对于一个序列 $\{a_n\}$，定义序列 $\{c_n\}$ ：$c_i=\max\{0,a_1,\cdots,a_{i-1}\}$ 。同时定义序列 $\{b_n\} :b_i=a_i-c_i$ 。</p><p>给定 $\{b_n\}$ ，求 $\{a_n\}$ 。</p><p>$1\leq n\leq 200,000$</p></blockquote><p>谔谔，完全就是一道模拟题，不知道这种题是怎么当B的，一点技术含量也没有啊？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">500010</span>] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base[<span class="number">500010</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ; </span><br><span class="line">ans[<span class="number">1</span>] = base[<span class="number">1</span>] ; m = ans[<span class="number">1</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">ans[i] = base[i] + m, m = max(ans[i], m) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一个长度为 $n$ 的<strong>排列</strong> $\{a_n\}$。要求将这个序列分成互不相交的 $k$ 段。记第 $p$ 段的左端点和右端点分别为 $l_p,r_p$ 。要求最大化 </p><script type="math/tex; mode=display">\sum_{i=1}^k\max_{j=l_i}^{r_i}\{a_j\}</script><p>同时输出最大化该值的方案数。对 $998,244,353$ 取模。</p></blockquote><p>发现显然 $n-k+1\sim n$ 这几个数是一定能取到的。乘法原理算一算区间怎么拆即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ; res = <span class="number">1l</span>l ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">ans += (ll)(n - i + <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (base[i] &gt; n - k)&#123; </span><br><span class="line"><span class="keyword">if</span> (lst) </span><br><span class="line">(res *= (ll)(i - lst)) %= P ; </span><br><span class="line">lst = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><blockquote><p>给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。</p><p>多组数据。保证 $\sum n\leq 5000$ 。</p></blockquote><p>草，我做这题的时候就是nm离谱。感觉自己完全没带脑子。一开始读错题了，以为是个构造题，只要构造一个用了非空前缀和非空后缀拼出来回文串就好了，然后写完之后看完样例就蒙了。思考了半天才发现是最优化问题。然后此时还有大概2h左右，我就觉得大概不用仔细思考可以瞎写写。于是我就成功地用KMP很麻烦地求了这个串「最长的、拼在一起可以回文的前缀和后缀」，然后发现就是个Manacher板子题，然后又很麻烦地去判边界(不得不说这个manacher判边界的麻烦程度也是一绝)。</p><p>然后在我WA了好几发之后才发现「最长的、拼在一起可以回文的前缀和后缀」只要枚举一下就好了…惨惨…</p><p>然后就没有然后了。不过好在还是抢救回来了。中间很无奈D1写了个暴力，不过还是最后绝杀了D2…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">char</span> I[N] ;</span><br><span class="line"><span class="keyword">int</span> Len[N] ;</span><br><span class="line"><span class="keyword">int</span> len[N], st ; </span><br><span class="line"><span class="keyword">int</span> T, L, n, res ; </span><br><span class="line"><span class="keyword">int</span> ns[N], base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; </span><br><span class="line">n = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; </span><br><span class="line">res = <span class="number">0</span> ; st = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (S[i] != S[n - i + <span class="number">1</span>]) <span class="keyword">break</span> ; <span class="keyword">else</span> st = i ;</span><br><span class="line"><span class="keyword">int</span> p = n - st ; <span class="keyword">int</span> db = <span class="number">0</span> ; <span class="keyword">int</span> q = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span> ; i &lt;= p ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = st + <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">I[j - st] = S[j] ; <span class="keyword">int</span> k = i - st ;</span><br><span class="line">reverse(I + <span class="number">1</span>, I + k + <span class="number">1</span>) ; <span class="keyword">bool</span> fg = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (I[j] != S[j + st]) &#123; fg = <span class="number">1</span> ; <span class="keyword">break</span> ;&#125;</span><br><span class="line"><span class="keyword">if</span> (!fg &amp;&amp; k &gt; res) res = i - st, db = <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &gt;= st + <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= p ; ++ j)</span><br><span class="line">I[j - i + <span class="number">1</span>] = S[j] ; <span class="keyword">int</span> k = p - i + <span class="number">1</span> ;</span><br><span class="line">reverse(I + <span class="number">1</span>, I + k + <span class="number">1</span>) ; <span class="keyword">bool</span> fg = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (I[j] != S[j + i - <span class="number">1</span>]) &#123; fg = <span class="number">1</span> ; <span class="keyword">break</span> ;&#125;</span><br><span class="line"><span class="keyword">if</span> (!fg &amp;&amp; k &gt; res) res = k, db = <span class="number">2</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!db)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (S + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">continue</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (db == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st + res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - st + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (db == <span class="number">2</span>)&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - st - res + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><blockquote><p>给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。</p><p>多组数据。保证 $\sum n\leq 10^6$ 。</p></blockquote><p>嗯，jiangly确实是神仙。代码写的又快又整洁又有条理，比我高到不知道哪里去了…</p><p>感觉还是很难在做题的时候让自己保持清醒的头脑。还需要多加练习。</p><p>哦对，有个小细节需要说一下。就是用Manacher枚举每个位置，判断左界和右界能不能拼起来的时候，是需要取 $min$ 的。这也属于细节吧？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">int</span> ns[N], base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, L, n, res, st ; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id, fars, i ; </span><br><span class="line">id = <span class="number">0</span>, fars = <span class="number">0</span> ; L = <span class="number">-1</span> ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line"><span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">ns[++ L] = (<span class="keyword">int</span>)s[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> <span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> op = T ; </span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; </span><br><span class="line">n = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; res = st = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (S[i] != S[n - i + <span class="number">1</span>]) <span class="keyword">break</span> ; <span class="keyword">else</span> st = i ;</span><br><span class="line"><span class="keyword">int</span> p = n - st ; <span class="keyword">int</span> db = <span class="number">0</span> ; </span><br><span class="line">Manacher(S) ; <span class="comment">//cout &lt;&lt; st &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> l = i / <span class="number">2</span> - base[i] / <span class="number">2</span> + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> r = i / <span class="number">2</span> + base[i] / <span class="number">2</span> - <span class="number">1</span> + (<span class="keyword">bool</span>)(ns[i] == <span class="string">'#'</span>) ;</span><br><span class="line"><span class="keyword">int</span> p = base[i] - <span class="number">1</span>, q = base[i] - <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; base[i] &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">if</span> (l &lt;= st) p -= <span class="number">2</span> * (st - l + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= n - st + <span class="number">1</span>) p = min(p, q -= <span class="number">2</span> * (r - n + st)) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; base[i] &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">l = i / <span class="number">2</span> - (p + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span> ; </span><br><span class="line">r = i / <span class="number">2</span> + (p + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span> + (<span class="keyword">bool</span>)(ns[i] == <span class="string">'#'</span>) ;</span><br><span class="line"><span class="keyword">if</span> (p &gt; res &amp;&amp; l &lt;= st + <span class="number">1</span>) db = <span class="number">1</span>, res = p ; </span><br><span class="line"><span class="keyword">if</span> (p &gt; res &amp;&amp; r &gt;= n - st) db = <span class="number">2</span>, res = p ;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; db &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L + <span class="number">2</span> ; ++ i) </span><br><span class="line">ns[i] = <span class="number">0</span>, base[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (!db)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (S + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">continue</span> ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl ; </span></span><br><span class="line"><span class="keyword">if</span> (db == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st + res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - st + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (db == <span class="number">2</span>)&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - st - res + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给定两个长度均为 $n$ 的排列 $p,q$ 。对一个初始为空的集合 $s$ 进行如下操作：对于每个 $i$ ，将 $p_i$ 放入集合；如果 $i$ 被<strong>标记</strong>了，则此时再将集合中最大的数删除。求 $n$ 次操作后集合中最大的数。</p><p>排列 $q$ 的意义是，对于每个 $i$ ，询问将 $q_1,q_2\cdots q_{i-1}$ 都标记之后的上述操作的结果。</p><p>$1\leq n\leq 300,000$。</p></blockquote><p>这是个神题。其实也不算严格意义上的神，只是我没注意到很多性质导致gg。</p><p>首先考虑答案最后一定是单调的。于是根据这个性质考虑何时应当把答案 $-1$ 。发现如果对于当前的一个答案 $x$ ，所有 $&gt;x$ 的数右边均有一个炸弹，那么答案就需要 $-1$ 。所以拆分下来的话，每次只需要考虑 $x$ 的右边是否存才一个未被占的炸弹即可。</p><p>考虑如何实现这个过程。对于每个 $i$ 记录包括 $i $ 在内的右边有多少 $&gt;x$ 的数，且有多少炸弹。如果前者减后者对于所有 $i$ 而言均 $\leq 0$ ，$ans$ 就 $-1$  。</p><p>于是可知这就变成了一个区间加+全局最大值的问题。线段树维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span> ; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ; </span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> tg[N * <span class="number">3</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">s[x] = max(s[x &lt;&lt; <span class="number">1</span>], s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line"><span class="keyword">if</span> (tg[x])&#123;</span><br><span class="line">s[x &lt;&lt; <span class="number">1</span>] += tg[x] ; </span><br><span class="line">s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[x] ;</span><br><span class="line">tg[x &lt;&lt; <span class="number">1</span>] += tg[x] ;</span><br><span class="line">tg[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[x] ;</span><br><span class="line">tg[x] = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line"><span class="keyword">return</span> s[rt] += v, tg[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> q ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), pos[base[i]] = i ; </span><br><span class="line">ans = n ; update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[ans], <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span> ; <span class="built_in">cin</span> &gt;&gt; q ; </span><br><span class="line"><span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span> ; update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, q, <span class="number">-1</span>) ; </span><br><span class="line"><span class="keyword">for</span> ( ; s[<span class="number">1</span>] &lt;= <span class="number">0</span> ; ) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[-- ans], <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一场相对来说还是比较简单的，至少 $A\to E$ 都是比较传统的题目。&lt;/p&gt;
&lt;p&gt;因为F对我来说不是很general，于是单开了一篇文章整理F了。&lt;/p&gt;
&lt;p&gt;不知道为什么，感觉所有Global Round里面，最喜欢的还是第一场。&lt;/p&gt;
&lt;p&gt;唉，过去的事情，也就只能让它过去了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="字符串/Manacher" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[ARC103] C~F</title>
    <link href="https://www.orchidany.cn/2020/03/18/ARC103/"/>
    <id>https://www.orchidany.cn/2020/03/18/ARC103/</id>
    <published>2020-03-18T14:43:00.000Z</published>
    <updated>2020-03-20T03:39:58.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做之前不知道这套题怎么样。做到一半发现后面三道都是构造题…都是构造…构造沙我.jpg</p><p>这好像就是ARC正式赛的最后一场了。可惜我一场ARC都没现场打过。</p><p>难度大概是 $\rm B&gt;C&gt;D&gt;A$ ？</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给定一个偶数长度的序列 $\{a_n\}$，定义「合法」表示 $\forall i&lt;n-1,a_{i}=a_{i+2}$ 且整个序列共有两种数字。</p><p>定义操作：每次选择一个数替换掉某个位置。</p><p>求最少需要操作多少次使得序列合法。</p><p>$1\leq n\leq 100000,1\leq a_i\leq 100000$。</p></blockquote><p>比较常规的最优化题目。不难发现如果某个数出现次数很多，就要用这个去替换别的数而不是被换掉。所以不难想到分别拿桶记录奇偶位置的出现次数，然后两个都选最多的即可。</p><p>然而显然这个做法是不对的。因为限制了必须有两种数字，所以奇偶位置的取值必须不同。定一找二即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N] ;</span><br><span class="line"><span class="keyword">int</span> _odd[N] ;</span><br><span class="line"><span class="keyword">int</span> _eve[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _odd[x] &gt; _odd[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _eve[x] &gt; _eve[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; res = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) _odd[base[i]] ++ ;</span><br><span class="line">        <span class="keyword">else</span> _eve[base[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i) s[i] = t[i] = i ;</span><br><span class="line">    sort(s + <span class="number">1</span>, s + N, compo) ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + N, compe) ;</span><br><span class="line">    ans = n / <span class="number">2</span> - _odd[s[<span class="number">1</span>]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (t[i] != s[<span class="number">1</span>])&#123; ans += n / <span class="number">2</span> - _eve[t[i]] ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    res = min(res, ans) ;</span><br><span class="line">    ans = n / <span class="number">2</span> - _eve[t[<span class="number">1</span>]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[<span class="number">1</span>])&#123; ans += n / <span class="number">2</span> - _odd[s[i]] ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    res = min(res, ans) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>给定 $n$ 组坐标。构造长度为 $m$ 的序列 $\{c_n\}$ 和 $n$ 组包含 <code>LRUD</code> 的路径，满足对于每一组坐标：</p><ul><li>$c_i$ 表示第 $i$ 步「步长」。</li><li>对于每个坐标，从 $(0,0)$ 开始走，共走 $m$ 步。第 $i$ 步可以让 $(x,y)$ 变成 $(x±c_i,y)$ 或 $(x,y±c_i)$ 。</li><li>走完 $m$ 次之后，恰好走到这组坐标。</li><li>要求 $m\leq 40,c_i\leq 10^{12}$ 。</li></ul><p>$1\leq n\leq 1000$</p></blockquote><p>不会啊…感觉可能是对这种套路不是很熟啊。</p><p>首先无解很容易判断。因为多走一步和少走一步之间的差值总是 $2\times$步长 ，所以如果 $x_i+y_i$ 的奇偶性不同的话，就不能同时满足条件。</p><p>后来就不会了x</p><p>发现这个题的本质是拆分问题。那么大概可以引导到「二进制拆分」这种泛式的拆分方式上。不妨考虑对于一组 $\{1,2,4\cdots 2^k\}$ 可以拼出哪些坐标。那么考虑对于一组坐标 $(x,y)$ ，他可以被通达，那么可以知道如果想要减小某一维坐标，比如 $x\to x’$，那有两种情况：</p><p>1、只是单纯地拿掉几个元素。比如 $16\to11$ 就是简单地拆出 $4$ 和 $1$ 。</p><p>2、拿出几个元素并且换进去几个元素。比如 $12\to11$ 就是拆出 $2$ 和 $1$ 放进一个 $4$ 。</p><p>可以看出，这是可以相互通达的。</p><p>更详细一点。因为对于四个象限，情况都是等价的。所以只考虑第一象限。发现对于 $\{1,2,4\cdots 2^k\}$ ，它可以维护到的位置至少是所有 $|x+y|=\sum _{i=0}^k 2^i=2^{k+1}-1$。但是不仅限于此。发现如果将将其中某个元素的贡献取负，那么就可以访问到所有 $|x+y| - \sum 2^p$ 的格子。换句话说，这个方式可以访问到所有与 $2^{k+1}-1$ 奇偶性相同的格子。</p><p>到这一步就已经很完美了，但是依然存在问题。如果 $|x+y|$ 都是偶数，这就挂了。所以此时可以随便向 $x$ 轴或者 $y$ 轴偏移 $1$ ，比如把 $(1,0)$ 变换成原点，就解决了。</p><p>实现方面，发现最合法区域后是个内部镂空的菱形。找出来之后，对于一组坐标 $(x,y)$ ，考虑对称着找。反向从大到小枚举每一个步长，如果新的点的 $|x|+|y|$ 之和严格小于当前的步长，就是可以拼出来的。不难知道这样做是对的。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> _eve ;</span><br><span class="line">ll nx, ny ;</span><br><span class="line"><span class="keyword">int</span> bc[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l ;</span><br><span class="line">    <span class="keyword">int</span> r ;</span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">&#125;base[N] ; <span class="comment">//D  R  U  L</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>] = &#123;<span class="string">'U'</span>, <span class="string">'L'</span>, <span class="string">'D'</span>, <span class="string">'R'</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    bc[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i].l &gt;&gt; base[i].r ;</span><br><span class="line">        base[i].t = <span class="built_in">abs</span>(base[i].l + base[i].r) &amp; <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (base[i].t != base[<span class="number">1</span>].t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">30</span> ; ++ i) bc[++ cnt] = <span class="number">1</span> &lt;&lt; i ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt + <span class="number">1</span> + (<span class="keyword">bool</span>)(!(base[<span class="number">1</span>].t &amp; <span class="number">1</span>)) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!(base[<span class="number">1</span>].t &amp; <span class="number">1</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt ; ~i ; -- i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, bc[i], <span class="string">" \n"</span>[!i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        nx = base[i].l ;</span><br><span class="line">        ny = base[i].r ;</span><br><span class="line">        <span class="keyword">if</span> (!(base[i].t &amp; <span class="number">1</span>))</span><br><span class="line">            ny -= <span class="number">1</span>, <span class="built_in">putchar</span>(<span class="string">'U'</span>) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = cnt ; ~j ; -- j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">                ll kx = nx + (ll)dx[k] * bc[j] ;</span><br><span class="line">                ll ky = ny + (ll)dy[k] * bc[j] ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(kx) + <span class="built_in">abs</span>(ky) &lt; bc[j])&#123;</span><br><span class="line">                    nx = kx ; ny = ky ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl ;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[k]) ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一个长度为 $n$ 的 $01$ 序列 $\{s_n\}$。尝试构造一棵具有如下性质的 $n$ 个结点的树：</p><p>$\forall i\in[1,n]\cap\mathbb{Z_+}$，$s_i$ 若为 $1$ ，则一定存在大小为 $i$ 的连通块；$s_i$ 若为 $0$ ，则一定不存在大小为 $i$ 的连通块。</p><p>$1\leq n\leq10^5$ 。</p></blockquote><p>神仙构造orz。</p><p>首先显然的是 $s_n=0$，$s_1=1$ ，否则无解。并且这东西是有对称性的，割掉一个大小为 $k$ 的连通块一定也会割出一个大小为 $n-k$ 的连通块。所以可以如此判断是否存在解。</p><p>这种构造，如果强行定义的话，可能存在某种套路。思考这一种比较自然的构造方式：找到最大的连通块，让其成为 $1$ 的一棵子树，这样迭代做下去，最后再拿散点连上去，看上去有点合理，因为 $1$ 的连通块必然存在。但仔细思考就会发现这样做会使得很多不应该存在的大小的连通块出现。</p><p>但是至少发现，连散点是个比较好的方式，而上一个方法欠缺的就是难以准确构造连通块。这就可以把思路引到「菊花」上。发现对于一个 $k$ 阶菊花，只会产生大小为 $k-1$ 和 $1$ 的连通块。那么可以知道大概可以如此设计思路：枚举连通块大小 $p$ ，如果 $s_p=0$ ，那么就应该把 $p+2$ 号点也连在之前的某个菊花上 ，这样就不会出现 $size=p$ 的连通块；否则把 $p+2$ 连向单独拿出来作为一个新的新的菊花的重心连向 $p+1$ ，这样就会有 $size=p$ 的连通块了。</p><p>形式化地讲，考虑设 $1&lt;q_1&lt;q_2&lt;\cdots &lt;q_m&lt;n$ 表示 $\{s_n\}$ 中那些值为 $1$ 的位置。那么构造出来的只需要是一个链套菊花，每个菊花大小是 $q_k-q_{k-1}$ 即可（差分）。</p><p>显然这种构造方式能凑出所有 $s_p=1$ 的 $p$ 来。接下来只需要考虑这样做为什么也可以保证 $s_p=0$ 的位置不构造出来。发现如果砍掉的边是菊花边而不是链边，那么只会有 $n-1$ 和 $1$ 这两种连通块；如果是链边，那么只会是某个 $q_k$ 和 $n-q_k$ ，由于之前已经判过了对称性，所以不难证明这样做是对的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (s[n] == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[n - i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt; n ; ++ i)</span></span><br><span class="line"><span class="comment">        if (s[i] == '1') stk[++ top] = i ;</span></span><br><span class="line"><span class="comment">    stk[++ top] = n ; int k ; cnt = 0 ;</span></span><br><span class="line"><span class="comment">    while (top) sz[++ cnt] = stk[top --] ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt; cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        printf("%d %d\n", i, i + 1), sz[i] -= sz[i + 1] ;</span></span><br><span class="line"><span class="comment">    k = cnt ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= sz[i] ; ++ j)</span></span><br><span class="line"><span class="comment">            printf("%d %d\n", i, ++ cnt) ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    m = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) m = i + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>给定一棵树上每个点到其他点的距离和。保证均不相同。构造这样的一棵树。</p><p>$1\leq n\leq 200,000$ </p></blockquote><p>嗯。其实树上如果是考虑距离的话，也就那么点事儿。</p><p>首先要知道的是，一个经典的 $dp$ 。根据 $f_u$ 推出 $f_v$ ，此处假设 $fa_v=u$ 。那么有：</p><script type="math/tex; mode=display">f_u=f_v+size_v-(n-size_v)=f_v-n+2\cdot size_v</script><p>并且考虑一个很自然的思路。对于树而言，其最特殊的节点就是根和叶子。</p><p>发现 $f$ 值最小的那个是重心。那么如果令重心当根，那么随深度增大，$f$ 是单增的。同时可以知道，如果根是重心的话，一定不会存在某棵子树的 $size&gt;\lfloor \frac{n}{2}\rfloor$ ，这就可以作为判断无解的依据。</p><p>于是就从底向上不断删叶子就可以了。合法随便判一判即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck_it_up return !puts(<span class="meta-string">"-1"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll minx ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line">ll dis[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    ll val ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="built_in">map</span> &lt;ll, <span class="keyword">int</span>&gt; s ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(tree a, tree b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt; b.val ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        dis[to(k)] = dis[x] + n - <span class="number">2</span> * sz[to(k)], dfs(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sz[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i].val) ;</span><br><span class="line">        s[base[i].val] = base[i].id = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = base[i].id ;</span><br><span class="line">        ll y = base[i].val ;</span><br><span class="line">        <span class="keyword">int</span> delta = n - <span class="number">2</span> * sz[x] ;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt;= <span class="number">0</span>) fuck_it_up ;</span><br><span class="line">        <span class="keyword">if</span> (!s.count(y - delta)) fuck_it_up ;</span><br><span class="line">        fa[x] = s[y - delta] ; minx += sz[x] ;</span><br><span class="line">        sz[fa[x]] += sz[x] ; add(fa[x], x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cout</span> &lt;&lt; fa[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    dis[base[n].id] = minx ; dfs(base[n].id) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[base[i].id] != base[i].val) fuck_it_up ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; base[i].id &lt;&lt; <span class="string">" "</span> &lt;&lt; fa[base[i].id] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做之前不知道这套题怎么样。做到一半发现后面三道都是构造题…都是构造…构造沙我.jpg&lt;/p&gt;
&lt;p&gt;这好像就是ARC正式赛的最后一场了。可惜我一场ARC都没现场打过。&lt;/p&gt;
&lt;p&gt;难度大概是 $\rm B&amp;gt;C&amp;gt;D&amp;gt;A$ ？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】6 · 有趣的费用流</title>
    <link href="https://www.orchidany.cn/2020/03/15/%E8%B4%B9%E7%94%A8%E6%B5%81Hard/"/>
    <id>https://www.orchidany.cn/2020/03/15/费用流Hard/</id>
    <published>2020-03-15T09:55:41.000Z</published>
    <updated>2020-03-18T04:55:03.414Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>24题中比较新颖有趣的费用流题目：</p><p>分别是 <code>loj#6014</code> 最长可重区间集、<code>loj#6227</code> 最长可重线段集问题 和  <code>loj#6008</code> 餐巾计划。</p><p>啊，24道题里面，1道假题，还有两道状压bfs，因为与网络流无瓜就忽略了。</p><p>总之呢，总算是做完了啊。</p><a id="more"></a><h1 id="最长-k-可重区间集"><a href="#最长-k-可重区间集" class="headerlink" title="最长 k 可重区间集"></a>最长 k 可重区间集</h1><blockquote><p>给定实直线 $ L $ 上 $ n $ 个开区间组成的集合 $ I $，和一个正整数 $ k $，试设计一个算法，从开区间集合 $ I $ 中选取出开区间集合 $ S \subseteq I $，使得在实直线 $ L $ 的任何一点 $ x $，$ S $ 中包含点 $ x $ 的开区间个数不超过 $ k $。且 $ \sum\limits_{z \in S} | z | $ 达到最大。这样的集合 $ S $ 称为开区间集合 $ I $ 的最长 $ k $ 可重区间集。$ \sum\limits_{z \in S} | z | $ 称为最长 $ k $ 可重区间集的长度。</p><p>对于给定的开区间集合 $ I $ 和整数 $ k $，计算开区间集合 $ I $ 的最长 $ k $ 可重区间集的长度。</p><p>$ 1 \leq n \leq 500, 1 \leq k \leq 3 $</p></blockquote><p>首先一拿出来，这不就是匹配问题嘛？一个点最多匹配 $k$ 个区间。于是每个位置建一个点，然后连向覆盖自己的点，然后…好像不太对？其一他没给下标的取值范围，其二一个线段覆盖多个点，要么都覆盖要么都不覆盖，这个限制很难表示…</p><p>于是好像不知道从何处入手了。发现一个这样的性质，就是永远不会选择 $k$ 个以上交于 $1$ 点的区间。也就是说，如果两个区间彼此之间没有交，就可以同时选；否则能不能同时选，看情况。这像极了「限制」，也就是如果两个区间之间没有交，那两者不存在限制；否则存在 $k$ 的限制。</p><p>根据一开始的匹配，可以猜到大致上用网络流是可行的。并且似乎网络流很适合用流量来表征限制。那么考虑，如果两个区间不存在限制，那么应该怎么办——网络流类似电流，所以此时如果串联的话，就代表着可以同时选；那么如果存在限制，就意味着不能串联。根据这一点，考虑如何串联。发现本质上是将两个不交的区间中间连 $f=\infty,c=0$ 的边。</p><p>这一点就引申出两个建图方法，其本质是相同的：</p><p>1、建立一个超级源 $\rm S$ 和一个源 $\rm S’$ ，中间连 $f=k,c=0$ 的边，目的是提供初始流量。$\rm S’$ 向每个区间的左端点连一条 $f=1,c=-1$ 边。然后区间左端点向右端点连边 $f=1,c=-len$ 表示贡献，每个右端点再向 $\rm T $ 连边即可。如果两个区间不交，就由一个区间的 $r$ 连向另一个区间的 $l$ （当然要按秩啦）。思考这样做的合理性，对于相交的区间，一定是并联；否则的话就是串联（其实叫做混连，但是问题不大）。</p><p>2、建立一个源 $\rm S$ 连向数轴上的 $0$ 位置，$f=k,c=0$。然后数轴上每个 $i&gt;0$ 向 $i+1$ 连边 $f=k,c=0$。最后 $maxright$ 向 $\rm T$ 连边。对于一个区间，连法跟1相同。</p><p>注意：</p><p>1、为什么要拆点？此处拆点的作用值得注意。对于一个区间，本质上应该抽象成一个点。但是在流图里是不存在「点权」这个概念的。所以需要把点权转边权，拆点的作用便在于此。</p><p>2、其实上面两个方法，可以通过初中物理里面什么「判断两个电路图是否等价」的知识来解决的233</p><p>3、由于本题保证了「开区间」，所以可以直接 $l\to r,len=r-l$ 。当然如果是闭区间，只需要改成 $l\to r+1$ 即可。</p><p>4、上面的第二个方案，发现最终可能存在很多数轴上的点 $i$ 只与 $i-1,i+1$ 连了 $f=k,c=0$ 的边，所以是没用的，离散化掉就好了。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ct(k) e[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> cost ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _s ;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> _last[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    fw(cnt) = f ; ct(cnt) = c ;</span><br><span class="line">    fr(cnt) = u ; head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(g, g + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(dis, dis + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(_s) ; vis[_s] = <span class="number">1</span> ; dis[_s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">        q.pop() ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[x] + ct(k) &amp;&amp; fw(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[x] + ct(k) ;</span><br><span class="line">                g[to(k)] = min(fw(k), g[x]) ;</span><br><span class="line">                pre[to(k)] = x ; _last[to(k)] = k ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">                    q.push(to(k)) ;</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>] &lt; I) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (spfa())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">_t</span> ;</span><br><span class="line">        res += g[<span class="keyword">_t</span>] ;</span><br><span class="line">        ans += g[<span class="keyword">_t</span>] * dis[<span class="keyword">_t</span>] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; g[_t] &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (x != _s)&#123;</span><br><span class="line">            fw(_last[x]) -= g[<span class="keyword">_t</span>] ;</span><br><span class="line">            fw(_last[x] ^ <span class="number">1</span>) += g[<span class="keyword">_t</span>] ;</span><br><span class="line">            x = pre[x] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N] ;</span><br><span class="line">pint base[N] ;</span><br><span class="line"><span class="keyword">int</span> _n, _k, tot ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id, buc ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; :: iterator t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _k ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i].ft &gt;&gt; base[i].sc ;</span><br><span class="line">        len[i] = base[i].sc - base[i].ft ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">1</span>, _k, <span class="number">0</span>) ; add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (t = buc.begin() ; t != buc.end() ; ++ t)</span><br><span class="line">        Id[t-&gt;ft] = ++ tot ; _s = <span class="number">0</span> ; <span class="keyword">_t</span> = tot + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        add(i, i + <span class="number">1</span>, I, <span class="number">0</span>), add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Id[base[i].ft] &lt;&lt; " " &lt;&lt; Id[base[i].sc] &lt;&lt; endl ;</span></span><br><span class="line">        add(Id[base[i].ft], Id[base[i].sc], <span class="number">1</span>, -len[i]) ;</span><br><span class="line">        add(Id[base[i].sc], Id[base[i].ft], <span class="number">0</span>, len[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长-k-可重线段集问题"><a href="#最长-k-可重线段集问题" class="headerlink" title="最长 k 可重线段集问题"></a>最长 k 可重线段集问题</h1><blockquote><p>给定平面 $\text{x-o-y}$上 $n$ 个开线段组成的集合 $\text{I}$，和一个正整数 $\rm k$ 从开线段集合 $\text{I}$ 中选取出开线段集合 $\text{S}\in \text{I}$, 使得在 x 轴上的任何一点 $\text{p}$ ， $\text{S}$ 中与直线 $\text{x}=\text{p}$ 相交的开线段个数不超过 $\text{k}$ ，且 $\sum_{\text{z} \in \text{S}}|z|$ 达到最大。这样的集合 $\text{S}$ 称为开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。</p><p>对于任何开线段 $\text{z}$，设其端点坐标为 $( x_0 , y_0 )$ 和 $( x_1 , y_1 )$，则开线段 $\text{z}$ 的长度 $|\text{z}|$ 定义为： $|z| = \lfloor \sqrt{ ( x_1 - x_0 ) ^ 2 + ( y_1 - y_0 )^2 } \rfloor$。对于给定的开线段集合 $\text{I}$ 和正整数 $\text{k}$ ，计算开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。</p><p>$1\leq n\leq500,$ $1 \leq k \leq 13$.</p></blockquote><p>发现和「区间集」那题没啥区别，只用关心 $x$ 轴，换一下长度的求法…好像有点不对？因为如果存在两条线段均垂直于 $x$ 轴，且两条线的左右端点分别都是 $x_i$ ，这样的话，建出图来这俩线段是串在一起不交的，但是本质上应该交。</p><p>于是自然想到，要换种表示方法在 $x$ 轴上表示一个线段。那么如果是在数轴上，比较简单的方式就是扩域。每个线段 $i$ 的左右端点 $(l_i,r_i)$ 变换成 $(2\times l_i,2\times r_i)$——听上去很不错，这样的话就相当于每个下标多了一个空间。那么对于一个左右端点相同的区间 $(x,x)$ ，就可以连边成 $(2\cdot x,2\cdot x + 1)$。这样的话，原本左右端点不用的区间也要改——由于那些相同的区间右端点加了 $1$，所以如果存在这样两个线段 $(p,p)$ 、 $(p,q)$ ，那么原本不交的两个区间，在扩域之后变成了相交的 $(2p,2p+1)$、$(2p,2q)$ 。</p><p>处理方式很简单，对于一个 $p\not=q$ 的区间 $(p,q)$，连边 $(2p+1,2q)$ 即可。思考这么做为啥是对的。对于原本存在的两个均不垂直 $x$ 轴的线段，他们如果相交，那么交的那一端，$r_1-l_2\geq 1$ ；如果不交，那么有 $l_2-r_1\geq 1$ 。扩域之后就变成了 $\geq 2$ 。所以如果只是左端点增加 $1$ ，根本不影响判定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len[N] ;</span><br><span class="line">pint base[N] ;</span><br><span class="line"><span class="keyword">int</span> _n, _k, tot ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id, buc ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; :: iterator t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((ll)(a - c) * (a - c) + (ll)(b - d) * (b - d)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _k ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d ;</span><br><span class="line">        len[i] = calc(a, b, c, d) ;</span><br><span class="line">        base[i].ft = a &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">        base[i].sc = c &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (a == c)</span><br><span class="line">            ++ base[i].sc ;</span><br><span class="line">        <span class="keyword">else</span> ++ base[i].ft ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">1</span>, _k, <span class="number">0</span>) ; add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (t = buc.begin() ; t != buc.end() ; ++ t)</span><br><span class="line">        Id[t -&gt; ft] = ++ tot ; _s = <span class="number">0</span> ; <span class="keyword">_t</span> = tot + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        add(i, i + <span class="number">1</span>, I, <span class="number">0</span>), add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Id[base[i].ft] &lt;&lt; " " &lt;&lt; Id[base[i].sc] &lt;&lt; endl ;</span></span><br><span class="line">        add(Id[base[i].ft], Id[base[i].sc], <span class="number">1</span>, -len[i]) ;</span><br><span class="line">        add(Id[base[i].sc], Id[base[i].ft], <span class="number">0</span>, len[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="餐巾计划"><a href="#餐巾计划" class="headerlink" title="餐巾计划"></a>餐巾计划</h1><blockquote><p>一个餐厅在相继的 $ n $ 天里，每天需用的餐巾数不尽相同。假设第 $ i $ 天需要 $ r_i $ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 $ P $ 分；或者把旧餐巾送到快洗部，洗一块需 $ M $ 天，其费用为 $ F $ 分；或者送到慢洗部，洗一块需 $ N $ 天，其费用为 $ S $ 分（$ S &lt; F $）。</p><p>每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。</p><p>试设计一个算法为餐厅合理地安排好 $ n $ 天中餐巾使用计划,使总的花费最小。</p><p>$ 1 \leq n \leq 1000 $</p></blockquote><p>一道有趣的题。</p><p>嗯，本来想整理一下自己错的那几版是怎么错的，然后发现我忘了…</p><p>然后最近错的一版我是这么建的边：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">int</span> p, m, f, n, s ; </span><br><span class="line">S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">Add(S, i, Inf, <span class="number">0</span>), Add(i + N, T, base[i], <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">Add(i, i + N, base[i], p) ;</span><br><span class="line"><span class="comment">//Add(S, i + N, base[i], p) ;</span></span><br><span class="line"><span class="keyword">if</span> (i + m &lt;= N) Add(i, i + m + N, base[i], f) ; </span><br><span class="line"><span class="keyword">if</span> (i + n &lt;= N) Add(i, i + n + N, base[i], s) ;</span><br><span class="line">&#125;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/pengkunshuo/Desktop/pks/blogggg/source/_posts/233.png" alt></p><p>那么实质上这个题应该怎么做呢？zay鸽鸽教育我：</p><p><img src="/Users/pengkunshuo/Desktop/pks/blogggg/source/_posts/233.jpg" alt></p><p>大概就是 $\rm S$ 到晚上的边实际上是当天餐巾用完之后要提供 $r_i$ 块脏的餐巾——这个思路，是逆常识的，单纯是为了让每个点到 $T$ 的边满流才这么做。</p><p>于是最后就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">int</span> p, m, f, n, s ; </span><br><span class="line">S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">Add(S, i + N, base[i], <span class="number">0</span>), Add(i, T, base[i], <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i + N, i + N + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="comment">//Add(i, i + N, base[i], p) ;</span></span><br><span class="line">Add(S, i, base[i], p) ;</span><br><span class="line"><span class="keyword">if</span> (i + m &lt;= N) Add(i + N, i + m, Inf, f) ; </span><br><span class="line"><span class="keyword">if</span> (i + n &lt;= N) Add(i + N, i + n, Inf, s) ;</span><br><span class="line">&#125;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唉，青春不再，纪念一下好久之前写过的代码，也为这篇文章画上个句号吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ;<span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span>, x ;</span><br><span class="line"><span class="keyword">int</span> Ans, S, T, N, base[MAXN], i, j, k, dist[MAXN], F[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now) <span class="keyword">const</span>&#123; <span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125; ; priority_queue &lt;state&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> H[MAXN], Pre[MAXN], Last[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijks</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) </span><br><span class="line">        dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">    dist[S] = <span class="number">0</span> ; q.push((state)&#123;dist[S], S&#125;) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        state now = q.top() ; q.pop() ; </span><br><span class="line">        <span class="keyword">int</span> num = now.num, dis = now.dist ;</span><br><span class="line">        <span class="keyword">if</span> (vis[num]) <span class="keyword">continue</span> ; vis[num] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (k = head[num] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = dis + H[num] - H[to(k)] + E[k].c ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f)&#123;</span><br><span class="line">                dist[to(k)] = qwq, F[to(k)] = min(F[num], E[k].f), </span><br><span class="line">                q.push((state)&#123;dist[to(k)], to(k)&#125;), Pre[to(k)] = num, Last[to(k)] = k ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> dist[T] &lt; Inf ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].c = c ;</span><br><span class="line">    E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].c = -c ;</span><br><span class="line">    E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (dijks())&#123;</span><br><span class="line">        <span class="keyword">int</span> Ed = T ; Ans += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">        <span class="keyword">while</span> (Ed) E[Last[Ed]].f -= F[T], E[Last[Ed] ^ <span class="number">1</span>].f += F[T], Ed = Pre[Ed] ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] = dist[i] ; <span class="comment">/*cout &lt;&lt; dist[T] &lt;&lt; endl ; */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p, m, f, n, s ; <span class="built_in">cin</span> &gt;&gt; N ; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s), i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="comment">//for (scanf("%d%d%d%d%d", &amp;p, &amp;m, &amp;f, &amp;n, &amp;s), i = 1 ; i &lt;= N ; ++ i) Add(S, i, base[i], 0), Add(i + N, T, base[i], 0) ; </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, base[i], <span class="number">0</span>),  Add(i + N, T, base[i], <span class="number">0</span>) ; <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) &#123;Add(S, i + N, Inf, p), Add(i, i + N, Inf, p) ; <span class="keyword">if</span> (i + m &lt;= N) Add(i, i + m + N, Inf, f) ; <span class="keyword">if</span> (i + n &lt;= N) Add(i, i + n + N, Inf, s) ;&#125;</span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt; N ; ++ i) Add(i, i + 1, Inf, 0) ; //1</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= N ; ++ i) &#123;Add(S, i + N, Inf, p), Add(i, i + N, base[i], p) ; if (i + m &lt;= N) Add(i, i + m + N, Inf, f) ; if (i + n &lt;= N) Add(i, i + n + N, Inf, s) ;&#125;</span></span><br><span class="line"><span class="comment">*/</span>MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;24题中比较新颖有趣的费用流题目：&lt;/p&gt;
&lt;p&gt;分别是 &lt;code&gt;loj#6014&lt;/code&gt; 最长可重区间集、&lt;code&gt;loj#6227&lt;/code&gt; 最长可重线段集问题 和  &lt;code&gt;loj#6008&lt;/code&gt; 餐巾计划。&lt;/p&gt;
&lt;p&gt;啊，24道题里面，1道假题，还有两道状压bfs，因为与网络流无瓜就忽略了。&lt;/p&gt;
&lt;p&gt;总之呢，总算是做完了啊。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/费用流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】5 · 费用流进阶</title>
    <link href="https://www.orchidany.cn/2020/03/15/%E8%B4%B9%E7%94%A8%E6%B5%81%E8%BF%9B%E9%98%B6/"/>
    <id>https://www.orchidany.cn/2020/03/15/费用流进阶/</id>
    <published>2020-03-15T09:55:19.000Z</published>
    <updated>2020-03-18T04:32:47.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>似乎是比较进阶的费用流问题。</p><p>分别是 <code>loj#6013</code> 负载平衡、<code>loj#6122</code> 航空路线 、 <code>loj#6010</code> 数字梯形 和 <code>loj#6223</code> 汽车加油行驶问题。</p><a id="more"></a><h1 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h1><blockquote><p>G 公司有 $ n $ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $ n $ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。</p><p>$n\leq 100$。</p></blockquote><p>一道个人感觉有点东西的建图题。首先不难发现这是个均分纸牌问题。这个贪心说实话我理解的还不够深入。于是考虑怎么建图。</p><p>首先不难想到，由于每个点最后都要回到平均值，即一部分点需要将值给出去，一部分需要接受，那么就应该是一个类二分图的样子。但问题在于，怎么添加流量和(可能有的)费用呢？一开始想的是两个点之间差值为 $k$ 的话就连 $f=k,c=1$ 的边，然后超级源和超级汇都连 $+\infty,0$ 的边。但是这样根本无法限制每个点的流量。</p><p>现在考虑思路化地去思考这道题。</p><p>首先考虑流量之于这一题是什么存在——流量即限制，那么此题的限制就在于每个点最多只要增/减 $|\overline{a}-a_i|$ 的值；费用就显然是 $1$ 了。</p><p>那么考虑怎么连边。注意到点之间怎么流，是没有限制的，也就是说限制流图的中部是错的。于是考虑限制流图的前部和后部，发现只需要让 $\rm S$ 连向每个 $a_i&gt;\overline{a}$ 的点 $i$ ，容量为 $a_i-\overline{a}$ ；让每个 $a_j\leq \overline{a}$ 的点 $j$ 连向 $\rm T$ ，容量为 $\overline{a}-a_j$ 。中部的连法需要考虑实际意义，由于只要是相邻就可传递，所以直接向每个与自己相邻的点连边即可。</p><p>嗯，尤其需要注意的是，每个点都需要有一个替身(也就是需要拆点)。此处拆点的目的不再是限制了(因为自身和自身之间不连边)，而是题目意义(每个点可以作为中介接受比自己小的点的转运)。</p><p>然后这里放一下新版的 MCMF 的板子吧。上面的都是好久之前写的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ct(k) e[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> cost ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _s ;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> _last[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    fw(cnt) = f ; ct(cnt) = c ;</span><br><span class="line">    fr(cnt) = u ; head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(g, g + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(dis, dis + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(_s) ; vis[_s] = <span class="number">1</span> ; dis[_s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">        q.pop() ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[x] + ct(k) &amp;&amp; fw(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[x] + ct(k) ;</span><br><span class="line">                g[to(k)] = min(fw(k), g[x]) ;</span><br><span class="line">                pre[to(k)] = x ; _last[to(k)] = k ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">                    q.push(to(k)) ;</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>] &lt; I) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (spfa())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">_t</span> ;</span><br><span class="line">        res += g[<span class="keyword">_t</span>] ;</span><br><span class="line">        ans += g[<span class="keyword">_t</span>] * dis[<span class="keyword">_t</span>] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; g[_t] &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (x != _s)&#123;</span><br><span class="line">            fw(_last[x]) -= g[<span class="keyword">_t</span>] ;</span><br><span class="line">            fw(_last[x] ^ <span class="number">1</span>) += g[<span class="keyword">_t</span>] ;</span><br><span class="line">            x = pre[x] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _n ;</span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> bbar ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], sum += base[i] ;</span><br><span class="line">    bbar = sum / _n ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">2</span> * _n + <span class="number">1</span> ;</span><br><span class="line">    add(<span class="number">1</span>, _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span> * _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">2</span> * _n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, _n, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span> + _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">1</span> + _n, _n, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            add(i, i - <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">            add(i, i + _n - <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + _n - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; _n)&#123;</span><br><span class="line">            add(i, i + <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">            add(i, i + _n + <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + _n + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base[i] &gt; bbar)&#123;</span><br><span class="line">            add(i, _s, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            add(_s, i, base[i] - bbar, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            add(<span class="keyword">_t</span>, i + _n, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            add(i + _n, <span class="keyword">_t</span>, - base[i] + bbar, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int k = 0 ; k &lt;= cnt ; ++ k)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; fr(k) &lt;&lt; " " &lt;&lt; to(k) &lt;&lt; " " &lt;&lt; fw(k) &lt;&lt; " " &lt;&lt; ct(k) &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="航空路线问题"><a href="#航空路线问题" class="headerlink" title="航空路线问题"></a>航空路线问题</h1><blockquote><p>给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。  </p><ol><li>从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。  </li><li>除起点城市外，任何城市只能访问一次。</li></ol><p>对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。</p><p>对于所有数据，$n &lt; 100$</p></blockquote><p>其实这题不是很难。但是好像很多题解不是很负责任，于是自己写了一下Sol表示想要d其他题解（雾</p><p>感觉是个很妙(感觉自己应该会，但是就是想不起来)的转化，就是如果让找一条从 $1$ 出发经过 $n$ 回到 $1$ 的无重复点回路，那本质就是在找两条 $1$ 到 $n$ 的不相交路径。</p><hr><p>说一点实现上的小细节吧。主要内容是「跟其他题解不一样的东西」。</p><p>发现大家在做这个题的时候，都是特判的「是否存在一条直接连通 $1$ 和 $n$」 的路径，然后直接输出。首先这么做，较为麻烦(虽然也就只多了一两二三行)，其次正确性有待考究。</p><p>这个地方就需要思考，为什么大家的实现需要特判这个细节？原因是假设只有 $1\leftrightarrow n$ 这一条边，那么这条路需要走两次。但是连边 $(u,v)$ 的时候大家都是写的 <code>add(u&#39;,v,1,0)</code>，导致只能走一次。个人认为，由于这是个基础题，所以每个细节都需要写的十分合理，但这个地方显然就不合理。</p><p>网络流题讲究对着限制找<code>flow</code>，对着代价找<code>cost</code>。这个题目里显然只限制了一个点至多走一次，但是没限制一条边至多走一次——虽然本质上，没啥很大区别，因为点至多一次决定了边至多一次——但是这从某种程度上决定了对这个题建模的理解程度。所以我认为，为了更好地实现「网络流24题」的网络流教学任务，应该在连边 $(u,v)$ 时如是写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(u',v,Inf,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这样有两个好处：</p><p>1、只需要特判无解，根本不需要那些无聊的判来判去判流量多少，影响代码的美观和简练。</p><p>2、体现了这个题建模的本质意义。因为已经有拆点保证了题目中的要求的限制，如果再硬生生加上一个「边也至多走一次」，就是在无中生有、暗度陈仓(雾)。而精准的建模是网络流学习阶段所必须掌握的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _m ;</span><br><span class="line">    x = _n * <span class="number">2</span> ; y = <span class="number">1</span> + _n ;</span><br><span class="line">    _s = <span class="number">0</span> ; <span class="keyword">_t</span> = _n + _n + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    add(_s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) ; add(x, <span class="keyword">_t</span>, <span class="number">2</span>, <span class="number">0</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, y, <span class="number">2</span>, <span class="number">-1</span>) ; add(_n, x, <span class="number">2</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s, rt[t[s] = i] = s ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        add(i, i + _n, <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; ss ;</span><br><span class="line">        <span class="keyword">int</span> p = t[s] ;</span><br><span class="line">        <span class="keyword">int</span> q = t[ss] ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; q) swap(p, q) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">        add(p + _n, q, I, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    buc[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -res - <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    dfs(<span class="number">1</span>, l) ; <span class="built_in">cout</span> &lt;&lt; rt[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rt[ans[i]] &lt;&lt; <span class="string">'\n'</span> ; l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ct(i) == <span class="number">-1</span> &amp;&amp; !fw(i) &amp;&amp; !buc[fr(i)])</span><br><span class="line">            ans[++ l] = fr(i) ;</span><br><span class="line">    sort(ans + <span class="number">1</span>, ans + l + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= l ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rt[ans[i]] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; rt[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>btw，其实只需要dfs一遍即可。由于访问过程一定是单调的，所以将走完一遍后那些没走过的节点排序输出即可。</p><hr><p>然后需要注意的是，由于本身 $1$ 和 $n$ 都可以经过多次，所以和自己的替身连边要连 $f=2$ 的。</p><p>哦，对了，这题其实跟「双调巡游(bitonic tour)」差不多，唯独就是找的不是哈密顿回路且不保证是完全图。多加一维枚举和 $i,j$ 连通的点即可。</p><h1 id="数字梯形问题"><a href="#数字梯形问题" class="headerlink" title="数字梯形问题"></a>数字梯形问题</h1><blockquote><p>给定一个 $n$ 行的数字梯形，从第一行到最后一行分别有 $2,3,\cdots,n+1$ 个数字。每个数字可以向左下或者右下第一个数字的地方移动。求：</p><p>1、$m$ 条互不相交路径的数值最大总和；</p><p>2、$m$ 条可以存在点相交时的路径数值最大总和；</p><p>3、$m$ 条可以存在点相交或者边相交时的路径数值最大总和；</p></blockquote><h2 id="第一问-·-完全不相交的路径"><a href="#第一问-·-完全不相交的路径" class="headerlink" title="第一问 · 完全不相交的路径"></a>第一问 · 完全不相交的路径</h2><p>发现本质上，就是最小权路径覆盖问题。那么常规做法是，限制选的次数要通过限制流量来模拟，但是一个单点不存在流量，所以需要拆点。</p><p>大概就是每个点拆成两个点，然后对于某个点和它的副本连一条 $f=1,c=-base[x]$ 的边表示选了，毕竟是求最大值。然后 $\rm S$ 和最顶上的连 $f=1,c=0$ 的边，$\rm T$ 和最下面一层连 $f=1,c=0$，原图中点 $i,j$ 相连用 $i’\to j$ 刻画即可。 </p><h2 id="第二问-·-边不相交的路径"><a href="#第二问-·-边不相交的路径" class="headerlink" title="第二问 · 边不相交的路径"></a>第二问 · 边不相交的路径</h2><p>我们考虑此时其实是删除了每个点被选取次数的限制。那么我们就将每个点和自己的副本之间的边容量改成$+ \infty$，并把 $\rm T$ 与最底下的所有点的容量扩为 $+ \infty$ 即可。注意后半部分的扩容，<strong>其目的在于防止中间节点的扩容被限制</strong>。</p><h2 id="第三问-·-随便的路径"><a href="#第三问-·-随便的路径" class="headerlink" title="第三问 · 随便的路径"></a>第三问 · 随便的路径</h2><p>既然都随便了，就直接把所有的边都设置成$+ \infty$，但是显然的是我们不能扩 $\rm S$ 连出去的边。这样就永远保证了，从 $\rm S$ 走出来一定是一系列链，而不是一个类树形图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> L1, R1, L ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N ; S = <span class="number">0</span>, T = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = (tot += <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) Add(S, Id[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>) ; L = cnt + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (L1 = cnt + <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N + M ; ++ i) Add(Id[N][i] + <span class="number">1</span>, T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">Add(Id[i][j], Id[i][j] + <span class="number">1</span>, <span class="number">1</span>, -base[i][j]) ; R1 = cnt ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i &lt; N) Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>), Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 ; i &lt; R1 ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 + <span class="number">1</span> ; i &lt;= R1 ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = L ; i &lt; cnt ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L + <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ; </span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/*  以下是错误的建边 </span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= M ; ++ i) </span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ;</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt; N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt;= M + i ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ;</span></span><br><span class="line"><span class="comment">for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, + Inf, -base[tot]) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line"><span class="comment">/*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="汽车加油行驶问题"><a href="#汽车加油行驶问题" class="headerlink" title="汽车加油行驶问题"></a>汽车加油行驶问题</h1><blockquote><p>给定一个 $\text{N}\times \text{N}$ 的方形网格，设其左上角为起点◎，坐标为  $\text{(1,1)} $ ，$\text{X}$ 轴向右为正， $\text{Y}$ 轴向下为正，每个方格边长为 <code>1</code> ，如图所示。</p><p>一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(\text{N},\text{N})$ 。</p><p>在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则:</p><ul><li>汽车只能沿网格边行驶，装满油后能行驶 $\text{K}$ 条网格边。</li><li>出发时汽车已装满油，在起点与终点处不设油库。</li><li>汽车经过一条网格边时，若其 $\text{X}$ 坐标或 $\text{Y}$ 坐标减小，则应付费用 $\text{B}$ ，否则免付费用。</li><li>汽车在行驶过程中遇油库则应加满油并付加油费用 $\text{A} $。</li><li>在需要时可在网格点处增设油库，并付增设油库费用 $\text{C} $ (不含加油费用 $\text{A} $ )。</li><li>$\rm N , K , A , B , C$ 均为正整数， 且满足约束: $2\leq \text{N} \leq 100, 2 \leq \text{K} \leq 10$。</li></ul><p>设计一个算法，求出汽车从起点出发到达终点的一条所付费用最少的行驶路线。</p><p><img src="https://www.oj.swust.edu.cn/upload/image/problem/1750.png" alt="233"></p></blockquote><p>这题第一眼看上去条件很多。考虑状态的设计。发现对于每个状态 $(i,j)$ ，当前的油量 $k$ 都决定了每一步的决策，所以不难看出应该把 $k$ 也放到状态里形成分层图。那么就直接模拟一下走的过程，按分层图建图，流一下即可。</p><p>然而此题就是考了个分层图。因为本身所有边流量都是 $1$，所以费用流就是在做最短路233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cnt = <span class="number">-1</span> ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; A &gt;&gt; B &gt;&gt; C ;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head))  ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Ma[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= K ; ++ k) Id[i][j][k] = ++ tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (Ma[i][j]) </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; K ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; N) Add(Id[i][j][k], Id[i + <span class="number">1</span>][j][K - <span class="number">1</span>], <span class="number">1</span>, A) ;</span><br><span class="line"><span class="keyword">if</span> (j &lt; N) Add(Id[i][j][k], Id[i][j + <span class="number">1</span>][K - <span class="number">1</span>], <span class="number">1</span>, A) ;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i - <span class="number">1</span>][j][K - <span class="number">1</span>], <span class="number">1</span>, A + B) ;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i][j - <span class="number">1</span>][K - <span class="number">1</span>], <span class="number">1</span>, A + B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; K ; ++ k) Add(Id[i][j][k], Id[i][j][K], <span class="number">1</span>, A + C) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= K ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; N) Add(Id[i][j][k], Id[i + <span class="number">1</span>][j][k - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (j &lt; N) Add(Id[i][j][k], Id[i][j + <span class="number">1</span>][k - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i - <span class="number">1</span>][j][k - <span class="number">1</span>], <span class="number">1</span>, B) ;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i][j - <span class="number">1</span>][k - <span class="number">1</span>], <span class="number">1</span>, B) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">S = <span class="number">0</span>, T = tot + <span class="number">1</span>, Add(S, Id[<span class="number">1</span>][<span class="number">1</span>][K], <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Add(Id[N][N][i], T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">MFMC() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似乎是比较进阶的费用流问题。&lt;/p&gt;
&lt;p&gt;分别是 &lt;code&gt;loj#6013&lt;/code&gt; 负载平衡、&lt;code&gt;loj#6122&lt;/code&gt; 航空路线 、 &lt;code&gt;loj#6010&lt;/code&gt; 数字梯形 和 &lt;code&gt;loj#6223&lt;/code&gt; 汽车加油行驶问题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/费用流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[ARC100]C~E</title>
    <link href="https://www.orchidany.cn/2020/03/09/arc100c-e/"/>
    <id>https://www.orchidany.cn/2020/03/09/arc100c-e/</id>
    <published>2020-03-09T01:57:35.000Z</published>
    <updated>2020-03-09T03:12:13.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>整理 ARC100 的 C~E。F题由于太神仙被我拿出去单列了一篇。</p><p>写完才发现，这仨题也太水了吧？一点意思都没有啊？<del>不管了，能水一篇是一篇。</del></p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一个长为 $n$ 的序列 $\{A\}$，找一个 $b$ 使得下式最小：</p><script type="math/tex; mode=display">a b s\left(A_{1}-(b+1)\right)+a b s\left(A_{2}-(b+2)\right)+\ldots+a b s\left(A_{N}-(b+N)\right)</script></blockquote><p>根据小学生结论，一条数轴上离每个点距离和最小的那个点就是这些点最中间那个点。证明的话用微扰法就可以发现这是个下凸函数。</p><p>nmd，一开始记成了平均数WA了两次，实际上应该是中位数啦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), k[i] = base[i] - i ;</span><br><span class="line">    sort(k + <span class="number">1</span>, k + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) p = k[n / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">else</span> p = (k[n / <span class="number">2</span>] + k[n / <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans += <span class="number">1l</span>l * <span class="built_in">abs</span>(base[i] - p - i) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>给定一个序列。要求把这个序列分成连续的四份，记这四份内数字和分别为 $a,b,c,d$ ，最小化 $a,b,c,d$ 的极差。</p></blockquote><p>znm，长得一脸可三分的样子然而并不可三分，因为很容易知道在这种多峰函数三分本质上和爬山没啥区别。可能会有什么神必的退火或者遗传做法。但是个人感觉这个数据范围似乎不是很允许。</p><p>考虑暴力怎么做。尝试去枚举中间的第二段的右端点，这样再去枚举 $a,c,d$ ，复杂度是 $O(n^3)$ 的。</p><p>观察题目所给的性质。发现所有数都 $&gt;0$。于是考虑枚举第二段的时候，对于一个与自己极差最小的第一段，由于第二段数一直在增多，所以第一段的右端点下标必然是不降的；对于第三、四段，这个性质同样成立。</p><p>于是可以想到枚举第二段，第一段和第三段都变成了 $O(1)$ 。最终复杂度 $O(n)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll S[<span class="number">4</span>] ;</span><br><span class="line">ll minx ;</span><br><span class="line">ll maxx ;</span><br><span class="line">ll sum[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">gt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    minx = x &gt;= minx ? minx : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    maxx = x &gt;= maxx ? x : maxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = (<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">4</span> ;</span><br><span class="line">    S[<span class="number">0</span>] = base[<span class="number">1</span>] ; S[<span class="number">2</span>] = base[<span class="number">3</span>] ;</span><br><span class="line">    S[<span class="number">1</span>] = base[<span class="number">2</span>] ; S[<span class="number">3</span>] = sum[n] - sum[<span class="number">3</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; i &amp;&amp; gt(S[<span class="number">0</span>] - S[<span class="number">1</span>]) &gt; gt(S[<span class="number">0</span>] + base[l] - S[<span class="number">1</span>] + base[l]))&#123;</span><br><span class="line">            S[<span class="number">0</span>] += base[l], S[<span class="number">1</span>] -= base[l], ++ l ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; gt(S[<span class="number">3</span>] - S[<span class="number">2</span>]) &gt; gt(S[<span class="number">2</span>] + base[r] - S[<span class="number">3</span>] + base[r]))&#123;</span><br><span class="line">            S[<span class="number">2</span>] += base[r], S[<span class="number">3</span>] -= base[r], ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line">        minx = (<span class="number">1l</span>l &lt;&lt; <span class="number">61</span>) ; maxx = -(<span class="number">1l</span>l &lt;&lt; <span class="number">61</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">3</span> ; ++ j) chkmin(S[j]), chkmax(S[j]) ;</span><br><span class="line">        ans = min(ans, maxx - minx) ; S[<span class="number">1</span>] += base[i] ; S[<span class="number">2</span>] -= base[i] ;</span><br><span class="line">        <span class="comment">//for (int j = 0 ; j &lt;= 3 ; ++ j) cout &lt;&lt; S[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给定一个长度为 $2^k-1$ 的序列 $\{a_n\}$。对于每个 $1\leq p\leq 2^k-1$ ，求</p><script type="math/tex; mode=display">\max_{i \operatorname{or} j\operatorname{\leq} p}\{a_i+a_j\}</script><p>$k\leq 18$</p></blockquote><p>发现似乎是在做一个FMT，但是直接转移最大值需要 $k ^2$ 甚至更高的代价。所以考虑对于每个集合 $s$ 记一下这个集合中的最最大数和次大数，不难发现这样转移是方便的。复杂度 $2^kk$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line">pint f[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[x] &gt; base[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; n = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">        f[i] = make_pair(i, n + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    base[n + <span class="number">1</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; j) &amp; i))&#123;</span><br><span class="line">                <span class="keyword">int</span> k = (<span class="number">1</span> &lt;&lt; j) | i ;</span><br><span class="line">                <span class="keyword">int</span> t[<span class="number">4</span>] = &#123;fr(i), sc(i), fr(k), sc(k)&#125; ;</span><br><span class="line">                sort(t, t + <span class="number">4</span>, comp) ; unique(t, t + <span class="number">4</span>) ;</span><br><span class="line">                f[k] = make_pair(t[<span class="number">0</span>], t[<span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans = max(ans, base[fr(i)] + base[sc(i)]) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理 ARC100 的 C~E。F题由于太神仙被我拿出去单列了一篇。&lt;/p&gt;
&lt;p&gt;写完才发现，这仨题也太水了吧？一点意思都没有啊？&lt;del&gt;不管了，能水一篇是一篇。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
  </entry>
  
  <entry>
    <title>【题解】[ARC100F]Colorful Sequences</title>
    <link href="https://www.orchidany.cn/2020/03/08/ARC100F/"/>
    <id>https://www.orchidany.cn/2020/03/08/ARC100F/</id>
    <published>2020-03-08T15:12:59.000Z</published>
    <updated>2020-03-09T01:56:58.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个长为 $m$ 的序列，保证每个数都 $\leq k$。同时定义，如果一个全部元素均 $\leq x$ 的序列中存在一个长度为 $x$ 子序列，恰好是 $1\sim x$ 的排列，那么称这个序列为 「$x-$好序列」。</p><p>给定长度 $n$ 。求所有长度为 $n$ 的 $k-$好序列共包含了多少个长度为 $m$ 的子序列。</p><p>$1\leq n\leq 25000,1\leq k\leq 400$ 。</p></blockquote><p>神仙计数题，考察了许多很(我)有(不)趣(熟)的技术技巧。</p><a id="more"></a><p>记这个给定的序列为 $s$ .</p><p>首先发现，如果暴力计数统计的话似乎不是很简单，可能只允许状压。所以正难则反( <code>trick1</code>) ，考虑不加 「好序列」的限制，答案就是平凡的 $k^{n-m}(n - m + 1)$，$n-m+1$ 用来确定 $s$ 放在哪个位置。</p><p>接下来需要分类讨论：</p><p>1、$s$ 本身就是一个 $k-$好序列。</p><p>那么所有包含 $s$ 的序列，一定包含 $k$ 。此时所有情况都是合法的。</p><p>2、$s$ 中含有一对重复元素。</p><p>此时需要注意的是，绝对不会有跨过 $s$ 的 $k-$连续段。所以想到在左右两边分别计算有多少个序列使得与 $s$ 拼接之后，不存在 $k-$连续段。</p><p>具体一点。考虑记 $f_{i,j}$ 表示已经考虑了 $i$ 个数，末尾存在一个 $j$ 连续段的序列排列数。发现一共两种转移：</p><script type="math/tex; mode=display">\begin{align*}(k-j)\cdot f_{i,j}\to f_{i+1,j+1}\\f_{i,j}\to f_{i+1,p}\quad (p\leq j)\end{align*}</script><p>第一个转移显然是找一个新的元素放进来，第二个转移则表示永远可以选一个 $k-$连续段中的数字来调整长度。朴素的 $dp$ 是 $nk^2$ 的，考虑如何快速计算第二个转移。发现对于 $i$ 下的一个第二维 $j$，根据第二个转移需要加上所有 $i-1$ 且 $q\geq i$ 的 $f_{i-1,q}$ 的和，是一个后缀和的形式。</p><p>考虑如何在刷表的时候维护后缀和(<code>trick2</code>)：假设当前状态 $(i,j)$ 要转移到 $(i+1,j+1)$ ，转移了 $v$ 。那么考虑再从 $(i,j)$ 转移到 $(i+1,j+2)$，转移 $-v$ 。这样对于每个状态 $(i,j)$，其真实值都是一个 $1\to j$ 的累加过程，可以前缀和，也就是把第一个转移给前缀和化；对于第二个转移，考虑向 $(i+1,1)$ 这个状态转移 $\sum _jf_{i,j}$ ，然后在每个 $(i+1,j)$ 处减掉 $(i,j-1)$ 。原因是根据第二个转移，对于 $i$ 而言，只有 $\geq j$  的 $f_{i,p}$ 才能产生贡献，所以相当于提前减掉了这一部分。  </p><p>转移的时候保证不让 $j=k$ 参与进来，那么就可以保证合法。</p><p>扯回正题。发现计算这个东西，如果一开始在 $s$ 中确定了 $f_0$ 的哪个状态合法，就应当对其设初值。具体的，以左半边为例，找出左半边最长的连续段长度为 $l$，那么 $f_{0,l}$ 初值便应该为 $1$ 。整个计算过程相当于从 $s_1$ 向左延伸和从 $s_m$ 向右延伸。最后的合并显然是一个卷积的形式。</p><p>3、$s$ 中不含有重复元素。</p><p>一个很神仙的点。考虑不含重复元素，可以转化成随便一个长度为 $n$ 的<strong>非</strong> $k-$好序列，含有多少 $m-$好序列的方案数，除以 $A_{k}^m$。因为显然每个序列都是等价的，所以可以如是转化。这个东西的 $dp$ 过程和 <code>2、</code> 中的差不多，也是「记 $f_{i,j}$ 表示已经考虑了 $i$ 个数，末尾存在一个 $j$ 连续段的序列排列数」——不同点在于这个 $dp$ 记录的是个数，那么再拿一个数组，和 $f$ 一样转移，但是每次都需要加上 $f$ 对应的方案数，表示计算多次。</p><p>然后就没有然后了。注意可能存在 $k&gt;n$ 的sb情况，判掉即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">410</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll X[N] ;</span><br><span class="line">ll Y[N] ;</span><br><span class="line">ll I[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll g[N][K] ;</span><br><span class="line">ll f[N][K] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span></span>&#123;</span><br><span class="line">    (x += y) %= P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(ll &amp;x, ll y)</span></span>&#123;</span><br><span class="line">    (x -= y) %= P ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, j = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buc[base[i]]) now ++ ; buc[base[i]] ++ ;</span><br><span class="line">        <span class="keyword">while</span> (buc[base[j]] &gt; <span class="number">1</span>) -- buc[base[j ++]] ;</span><br><span class="line">        <span class="keyword">if</span> (i - j + <span class="number">1</span> == k &amp;&amp; now == k) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">else</span> ++ buc[base[i]] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p, q, j = <span class="number">0</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            p = f[i][j] * (k - j) % P ;</span><br><span class="line">            q = g[i][j] * (k - j) % P ;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; k)&#123;</span><br><span class="line">                add(f[i + <span class="number">1</span>][j + <span class="number">1</span>], p) ;</span><br><span class="line">                add(g[i + <span class="number">1</span>][j + <span class="number">1</span>], q) ;</span><br><span class="line">                dec(f[i + <span class="number">1</span>][j + <span class="number">2</span>], p) ;</span><br><span class="line">                dec(g[i + <span class="number">1</span>][j + <span class="number">2</span>], q) ;</span><br><span class="line">            &#125;</span><br><span class="line">            add(f[i + <span class="number">1</span>][<span class="number">1</span>], f[i][j]) ;</span><br><span class="line">            add(g[i + <span class="number">1</span>][<span class="number">1</span>], g[i][j]) ;</span><br><span class="line">            dec(f[i + <span class="number">1</span>][j + <span class="number">1</span>], f[i][j]) ;</span><br><span class="line">            dec(g[i + <span class="number">1</span>][j + <span class="number">1</span>], g[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            add(g[i + <span class="number">1</span>][j], g[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">            add(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &lt; k ; ++ j)</span><br><span class="line">            add(f[i + <span class="number">1</span>][j], g[i + <span class="number">1</span>][j]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; k ; ++ i) add(ret, f[n][i]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">(ll res[N], ll s[N][K], <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">if</span> (!mk)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!buc[base[i]]) buc[base[i]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> &#123; s[<span class="number">0</span>][i - <span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (!buc[base[i]]) buc[base[i]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> &#123; s[<span class="number">0</span>][m - i] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t, j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            t = s[i][j] * (k - j) % P ;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; k)&#123;</span><br><span class="line">                add(s[i + <span class="number">1</span>][j + <span class="number">1</span>], t) ;</span><br><span class="line">                dec(s[i + <span class="number">1</span>][j + <span class="number">2</span>], t) ;</span><br><span class="line">            &#125;</span><br><span class="line">            add(s[i + <span class="number">1</span>][<span class="number">1</span>], s[i][j]) ;</span><br><span class="line">            dec(s[i + <span class="number">1</span>][j + <span class="number">1</span>], s[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            add(s[i + <span class="number">1</span>][j], s[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">            add(res[i + <span class="number">1</span>], s[i + <span class="number">1</span>][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = I[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> mx = max(n, max(k, m)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mx + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * (ll)i % P ;</span><br><span class="line">    I[mx + <span class="number">1</span>] = expow(fac[mx + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        I[i] = (ll)(i + <span class="number">1</span>)* I[i + <span class="number">1</span>] % P ;</span><br><span class="line">    ans = expow(k, n - m) * (ll)(n - m + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (check()) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (check2())&#123; <span class="comment">//there is a same pair of number</span></span><br><span class="line">        X[<span class="number">0</span>] = Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        dp2(X, f, <span class="number">0</span>) ; dp2(Y, g, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n - m ; ++ i)</span><br><span class="line">            dec(ans, X[i] * Y[n - m - i] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dec(ans, dp1() * I[k] % P * fac[k - m] % P) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个长为 $m$ 的序列，保证每个数都 $\leq k$。同时定义，如果一个全部元素均 $\leq x$ 的序列中存在一个长度为 $x$ 子序列，恰好是 $1\sim x$ 的排列，那么称这个序列为 「$x-$好序列」。&lt;/p&gt;
&lt;p&gt;给定长度 $n$ 。求所有长度为 $n$ 的 $k-$好序列共包含了多少个长度为 $m$ 的子序列。&lt;/p&gt;
&lt;p&gt;$1\leq n\leq 25000,1\leq k\leq 400$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神仙计数题，考察了许多很(我)有(不)趣(熟)的技术技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】CF OTC2020 A~F Sol</title>
    <link href="https://www.orchidany.cn/2020/03/05/Ozon-Tech-Challenge-2020/"/>
    <id>https://www.orchidany.cn/2020/03/05/Ozon-Tech-Challenge-2020/</id>
    <published>2020-03-05T14:21:39.000Z</published>
    <updated>2020-03-09T03:43:52.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>碍于自身实力，只能整理到 $\rm F$ 了233.</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给定两个均不含相同数字的序列，分别重排之后使得 $\forall i,a_i+b_i$ 均不同。</p></blockquote><p>排序。排序的正确性在于令 $c_i=a_i+b_i$，$\forall i&gt;1,c_i&gt;c_{i-1}$ 保证了不同。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>给定一个括号序列，求至少删除多少次使得原序列中不存在「好子序列」并输出删除方案，如果本身就没有「好子序列」则输出 $0$。</p><p>「好子序列」的定义是长度为 $2k$ 且 $1\sim k$ 都为 <code>(</code> ，$k+1\sim 2k$ 都是 <code>)</code> 的子序列。删除操作规定每次只能选择原序列中的一个「好子序列」并删除其中的全部元素。</p><p>$n\leq 5000$</p></blockquote><p>发现显然至少删除一次即可。那么只需要记录每个左括号和右括号的位置，找一个位置 $p$ 使得前面的左括号和右面的右括号一样多且最大。$0$ 的情况是存在某个 $p$ 使得 $p$ 前缀都是 <code>)</code> 并且 $p+1$ 后缀都是 <code>(</code> 。判断一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) l[++ l[<span class="number">0</span>]] = i, sum[i] = sum[i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) r[++ r[<span class="number">0</span>]] = i, sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i] == i &amp;&amp; sum[i] == sum[n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = r[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l[L] &gt; r[R]) <span class="keyword">break</span> ; ++ ans;</span><br><span class="line">        stk[++ tp] = l[L], stk[++ tp] = r[R] ;</span><br><span class="line">        L ++ ; R -- ; <span class="keyword">if</span> (L &gt; l[<span class="number">0</span>] || !R) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stk + <span class="number">1</span>, stk + tp + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= ans * <span class="number">2</span> ; ++ i) <span class="built_in">cout</span> &lt;&lt; stk[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定序列 $a_i$，求 $\prod _{1\leq i&lt;j\leq n}|a_i-a_j|\bmod m$ 。</p><p>$1\leq n\leq 10^5,m\leq 1000$ 。</p></blockquote><p>妙妙题。发现直接做不容易并且 $m$ 很小，于是选择观察性质。考虑鸽笼原理，当 $n&gt;m$ 时，必有两项 $a_i,a_j$ 模 $m$ 同余。所以如果 $n&gt;m$ 答案就是 $0$，否则暴力即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            (ans *= (LL)<span class="built_in">abs</span>(base[i] - base[j])) %= m ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>交互题。给定一个树，每次可以随便询问两个点 $p,q$ 的 $lca$ 。在询问至多 $\frac{n}{2}$ 次后找出树的根。</p><p>$1\leq n\leq 1000$</p></blockquote><p>考虑从何处入手。发现对于一棵无根树，最容易辨别的就是叶子。那么只需要每次找出两个当前 $\deg$ 为 $1$ 的点，询问 $lca$ 并删除即可。这样次数一定是 $\lfloor\frac{n}{2}\rfloor$。如果 $p,q$ 有一个点为根，那么存在一个是两一个的祖先，这时输出即可。</p><p><del>这还是第一次在CF写交互题233</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt, n ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ; ++ deg[v] ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v) ;</span><br><span class="line">        add(u, v) ; add(v, u) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (deg[i] == <span class="number">1</span>) q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">int</span> y = q.front() ; q.pop() ; <span class="keyword">int</span> w ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="comment">//cout.flush() ;</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w ;</span><br><span class="line">        <span class="keyword">if</span> (w == x || w == y)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">            <span class="built_in">cout</span>.flush() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line">            <span class="keyword">if</span> ((-- deg[to(i)]) == <span class="number">1</span>) q.push(to(i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[y] ; i ; i = next(i))</span><br><span class="line">            <span class="keyword">if</span> ((-- deg[to(i)]) == <span class="number">1</span>) q.push(to(i)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span> ;<span class="comment">// cout.flush() ; return 0 ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>构造一个序列 $a$ 满足如下：</p><p>1、长度为 $n$ 。</p><p>2、$\forall i, 1\leq a_i\leq 10^9$ 。</p><p>3、$\forall i&gt;1,a_i&gt;a_{i-1}$。</p><p>4、满足 $i&lt;j&lt;k$ 且 $a_i+a_j=a_k$ 的三元组 $(i,j,k)$ 数量恰好为 $m$。</p><p>$n\leq 5000,m\leq 10^9$ 。</p></blockquote><p>比较自然的想法是从头开始填 $1,2,3\cdots$，因为这样容易填且满足条件。同时可以发现，这种构造方式是使得每个位置作为 $k$ 时，贡献三元组最多的方式：由于序列满足单调性，所以一定不存在前面的 $i,j$ 彼此有交。那么对于一个 $a_k=k$ 他可以贡献 $\lfloor \frac{k-1}{2}\rfloor$ 的答案。</p><p>考虑如果超出 $m$ 如何处理。假设当前答案超出了 $x$ 。对于一个 $k$ ，按照上述方式能够贡献 $\lfloor \frac{k-1}{2}\rfloor$ 的答案，那么如果想要只贡献 $\lfloor \frac{k-1}{2}\rfloor-x$ 的答案，就需要让其中的 $x$ 对 $(i,j)$ 无效。具体的，考虑令当前的 $k$ 变为 $k+2x$ ，那么考虑前 $k-1$ 个数里面最大的是 $k-1$ ，只能去匹配 $2x+1$，这样就会少掉 $2x$ 个可以用的数，答案变成了 $\lfloor\frac{k-1-2x}{2}\rfloor=\lfloor \frac{k-1}{2}\rfloor-x$ 。</p><p>那么补齐 $n$ 个数也很简单。只需要考虑如果当前填了的最大的数是 $j$ ，从 $10^9$ 向下按照 $2\cdot j$ 的步长递减即可。不难证明这样做是对的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans[i] = i ; cnt += (i - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">1000000000</span> ;</span><br><span class="line">            ans[i] += <span class="number">2</span> * (cnt - m) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n ; j &gt; i ; -- j)</span><br><span class="line">                ans[j] = (s -= (ans[i] + <span class="number">1</span>)) ;</span><br><span class="line">            gf = <span class="number">1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gf)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote><p>给定 $n$ 个数。每次可以选择将一个数 $+1$ 或 $-1$ 。求至少多少次使得整个序列的 $\gcd&gt;1$ 。</p><p>$n\leq 10^5,a_i\leq 10^{12}$ 。</p></blockquote><p>首先有一个结论，就是至多需要 $O(\frac{n}{2})$ 次操作就可以使得整个序列的 $\gcd&gt;1$，因为永远可以把 $2$ 当做因子。那么就可以得出一个结论，至多只会有 $\frac{n}{2}$ 个数会被改掉，那么也就说明如果随机一个数的话，有 $\frac{1}{2}$ 的概率不会被改。所以可以将整个序列 <code>shuffle</code> 一下取前几十个check一下即可。</p><p>还有，cf的评测系统是windows，<code>rand()</code> 做种子的时候只能打乱前 $32767$ 项。所以需要 <code>mt19937</code> 做种子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000100</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[M] ;</span><br><span class="line">LL base[N] ;</span><br><span class="line"><span class="keyword">bool</span> chk[M] ;</span><br><span class="line"><span class="built_in">set</span> &lt;LL&gt; facs ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i]) pr[++ cnt] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt;= M) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x % pr[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            facs.insert(pr[i]) ;</span><br><span class="line">            <span class="keyword">while</span> (!(x % pr[i])) x /= pr[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) facs.insert(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ret += base[i] &gt;= x ? min(base[i] % x, - (base[i] % x) + x) : x - base[i] ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    sieve() ; ans = n ;</span><br><span class="line">    random_device seed ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="function">mt19937 <span class="title">gg</span><span class="params">(seed())</span></span>; shuffle(base + <span class="number">1</span>, base + n + <span class="number">1</span>, gg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">30</span> &amp;&amp; i &lt;= n ; ++ i)</span><br><span class="line">        Ins(base[i]), Ins(base[i] + <span class="number">1</span>), Ins(base[i] - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (LL res : facs) ans = min(ans, calc(res)) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;碍于自身实力，只能整理到 $\rm F$ 了233.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>【赛题整理】ARC099 Sol</title>
    <link href="https://www.orchidany.cn/2020/03/04/ARC099/"/>
    <id>https://www.orchidany.cn/2020/03/04/ARC099/</id>
    <published>2020-03-04T10:12:23.000Z</published>
    <updated>2020-03-22T01:11:59.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从atcoder某天virtual的一场比赛。发现比起之前做过的场次，似乎 $\rm A$ 还是有点弱菜，$\rm B$ 还是有点奇怪，$\rm C$ 还是比较中规中矩<del>比较不会</del> ，$\rm D$ 还是不很会…</p><p>问题不大.jpg</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给定 $n,k$ ，一个 $1\sim n$ 的排列 $\{a_n\}$。每次选择一个长度为 $k$ 的区间 $[l,r]$，向下推平为 $\min_{i=l}^r\{a_i\}$ 。求最少多少次操作可以使得所有值相同。</p><p>$n\leq 100,000$ </p></blockquote><p>很多人写的比较麻烦。要去扫整个 $\{a_n\}$ 。然而这题 $n$ 是可以开到 $1e18$ 的。</p><p>考虑由于所有数不相同，所以最优决策一定是从最小的那个位置开始拓展。之后每次选择区间，必然是选择一个最多与之前那个区间相交为 $1$ 个元素的区间开始。所以最后答案就是 $1+\lceil\frac{n-k}{k-1}\rceil$。跟 $\{a_n\}$ 无关。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>定义函数 $\rm S(x)$ 表示 $x$ 各个位上数字之和。求前 $k$ 个这样的 $n$：</p><script type="math/tex; mode=display">\forall m>n,\frac{n}{\mathrm{S}(n)}\leq \frac{m}{\mathrm{S}(m)}</script><p>$k$ 的范围…$\geq 1$。</p></blockquote><p>首先这个是可以猜出一部分结论的，大概就是考虑如果数字里面 $9$ 比较多的话肯定会比较符合，因为这样 $\rm S$ 值就会显然更大。其次也是可以打表的。</p><p>但是这个题本质上不存在规律。所以以上两种方式可能会挂的很惨。</p><p>考虑一种可行的构造方式。首先知道，$1$ 一定是可行的。对于每个当前的 $x$ ，选择那个使得 $y&gt;x$ 且 $\frac{y}{\rm S(y)}$ 最小的 $y$ 来替代当前的 $x$ 。不难理解这样做是可行的。</p><p>那大概考虑如何去证明第一个性质，或者稍微形式化一点：</p><blockquote><p>假设 $y$ 是 $&gt;x$ 且 $\frac{y}{\rm S(y)}$ 最小的那个 $y$，且假设从高位到低位，$x$ 和 $y$ 第一次出现不同的地方是<strong>从低到高的</strong> 第 $p$ 位，那么会有 $y$ 的从低到高 $1\sim p$ 位均为 $9$ 。 </p></blockquote><p>证明时考虑如下：</p><p>1、对于 $1\sim p-1$ 位的证明是不难的。考虑假设 $y$ 不符合上述规则，那么设出一个 $y’$ ，其中 $1\sim p-1$ 均是 $9$ ，且 $y’$ 的第 $p$ 位是 $y$ 的第 $p$ 位 $-1$ 的数值。那么可以知道 $x\leq y’&lt;y$ 且 $\mathrm{S}(y’)\geq \mathrm S(y)$ 。这样的话 $\frac{y}{\mathrm S(y)}&gt;\frac{y’}{\mathrm S(y’)}$ 与 $y$ 的定义矛盾。所以 $1\sim p-1$ 均为 $9$。</p><p>2、再考虑第 $p$ 位。设 $y$ 的第 $p$ 位值为 $s$，设 $y’=y-10^{p-1}\cdot s$ ，那么有</p><script type="math/tex; mode=display">\frac{y}{\mathrm S(y)}=\frac{y'+10^{p-1}s}{\mathrm S(y')+s}</script><p>那么考虑此时 $y’$ 不变，等式右边是一个凹函数(先不考虑怎么凹)，在 $s=9$ 或者 $s=0$ 时取得最值。根据定义可知此处应该选择 $s=9$ （因为 $y$ 的第 $p$ 位至少要比 $x$ 的第 $p$ 位大 $1$）</p><hr><p>综上，可知后缀必然是某些 $999…999$ 的形式。从个位数向上推就好了。复杂度在 $\Omega(n)\sim O(n\log n)$ 左右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">s</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ; <span class="keyword">long</span> <span class="keyword">long</span> y = x ;</span><br><span class="line">    <span class="keyword">while</span> (x) ret += (x % <span class="number">10l</span>l), x /= <span class="number">10l</span>l ;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * ret) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s(ans + base) &gt; s(ans + base * <span class="number">10l</span>l))</span><br><span class="line">                base *= <span class="number">10l</span>l ; <span class="keyword">else</span> <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += base ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一张图。求将这张图分成两个完全子图后，最少会有多少条边的端点属于同一个完全子图。</p><p>$n\leq 700$</p></blockquote><p>一道比较妙的题。首先考虑建出补图来，那么发现，如果有两个点连通，就说明不能分在一个子图里面，恰好是二分图染色的流程。</p><p>之后考虑按补图的连通块 $dp$。注意到如果补图中连通块 $A$ 和 $B$ 不连通，说明原图中所有点都连通。所以根本不需要考虑连通块之间的连边。具体的，设状态 $f_{i,j}$ 表示考虑了前 $i$ 个连通块，是否存在二分图集合的某一部（左部or右部）大小是 $j$ 。根据前面的性质这就是个背包。所以 <code>bitset</code> 优化转移一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> nienie ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> clr[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">bool</span> A[N][N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N * N&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    to(++ ctn) = y ;</span><br><span class="line">    next(ctn) = head[x] ;</span><br><span class="line">    head[x] = ctn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span> ; clr[x] = c ; cnt[c] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), c ^ <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clr[to(k)] == c) <span class="keyword">return</span> nienie = <span class="number">1</span>, <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (x - <span class="number">1</span>) + (n - x) * (n - x - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> u, v ; res = <span class="number">1000000000</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v) ;</span><br><span class="line">        A[u][v] = A[v][u] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!A[i][j] &amp;&amp; (i ^ j)) add(i, j) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span> ; dfs(i, <span class="number">0</span>) ;</span><br><span class="line">            ans = (ans &lt;&lt; cnt[<span class="number">0</span>]) | (ans &lt;&lt; cnt[<span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nienie) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) res = min(res, calc(i)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; res / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>给定一个下标范围在 $[-\infty,\infty]$ 的数组。一开始指针在 $0$ 处。给定一段操作序列。求有多少个子序列的操作结果等价于整个序列的操作结果。操作有四种，左移/右移/某个位置$+1$/某个位置$-1$ 。</p><p>$1\leq n\leq 250,000$</p></blockquote><p>一拿到题首先考虑 $dp$ ，发现 $dp$ 不是很可做…</p><p>于是就发现，类似这种题目可以使用哈希。四种操作分别对应 $\times base^{-1}$、$\times base$、$+base$、$-base$ 。</p><p>考虑这样做如何去求某一段的哈希值。普通的求法原理如下：</p><p>对于每个 $p$ ，截止到 $p$ 的哈希值，如果将 $x$ 看做 $base$ 的一个等价，那么就是是</p><script type="math/tex; mode=display">\sum_{i=1}^ps_ix^{p-i}</script><p>考虑将上式记作 $o(p)$ 。则片段 $[l,r]$ 的哈希值可以如此得到：</p><script type="math/tex; mode=display">\begin{aligned}&o(r)-o(l-1)\times x^{r-l+1}\\=&\sum_{i=1}^rs_ix^{r-i}-x^{r-l+1}\sum_{i=1}^{l-1}s_ix^{l-i-1}\\=&\sum_{i=1}^rs_ix^{r-i}-\sum_{i=1}^{l-1}s_ix^{r-i}\\=&\sum_{i=1}^rs_ix^{r-i}-\sum_{i=1}^{l-1}s_ix^{r-i}\\=&\sum_{i=l}^rs_ix^{r-i}\\=&\sum_{i=1}^{t}s_ix^{t-i}\quad (t=r-l+1)\end{aligned}</script><p>考虑如果整个串的哈希值为 $q$，那么需要统计的是 $o(r)-o(l-1)\cdot x^{r-l+1}=q$ 。考虑从前至后用 $map$ 完成这个过程。由于不知道右端点的信息，需要对原式进行变形，即：</p><script type="math/tex; mode=display">\frac{q+o(r)}{x^r}=\frac{o(l-1)}{x^{l-1}}</script><p>这样就可以做到 $l,r$ 无关了。随便选前缀或者后缀统计就好了。</p><p>但是注意到本题有个额外限制，最后只需要结果相同而不需要指针位置相同。所以需要稍微处理一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;LL, LL&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL B1 = <span class="number">237l</span>l ;</span><br><span class="line"><span class="keyword">const</span> LL B2 = <span class="number">637l</span>l ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL P1 = <span class="number">998244353</span> ;</span><br><span class="line"><span class="keyword">const</span> LL P2 = <span class="number">1004535809</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line">LL I1, I2 ;</span><br><span class="line">LL g[N][<span class="number">2</span>] ;</span><br><span class="line">LL S[N], T[N] ;</span><br><span class="line"><span class="built_in">map</span> &lt;pll, LL&gt; buc ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (ret *= a) %= p ;</span><br><span class="line">        (a *= a) %= p ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1l</span>l ;</span><br><span class="line">    I1 = expow(B1, P1 - <span class="number">2</span>, P1) ;</span><br><span class="line">    I2 = expow(B2, P2 - <span class="number">2</span>, P2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">            S[i] = (S[i - <span class="number">1</span>] - g[i][<span class="number">0</span>] + P1) % P1 ;</span><br><span class="line">            T[i] = (T[i - <span class="number">1</span>] - g[i][<span class="number">1</span>] + P2) % P2 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">            S[i] = (S[i - <span class="number">1</span>] + g[i][<span class="number">0</span>]) % P1 ;</span><br><span class="line">            T[i] = (T[i - <span class="number">1</span>] + g[i][<span class="number">1</span>]) % P2 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] * I1 % P1 ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] * I2 % P2 ;</span><br><span class="line">            S[i] = S[i - <span class="number">1</span>] ; T[i] = T[i - <span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] * B1 % P1 ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] * B2 % P2 ;</span><br><span class="line">            S[i] = S[i - <span class="number">1</span>] ; T[i] = T[i - <span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ buc[mkp(S[i], T[i])] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ++ buc[mkp(<span class="number">0</span>, <span class="number">0</span>)] ; LL x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        buc[mkp(S[i] , T[i])] -- ;</span><br><span class="line">        x = (S[i] + S[n] * g[i][<span class="number">0</span>] % P1) % P1 ;</span><br><span class="line">        y = (T[i] + T[n] * g[i][<span class="number">1</span>] % P2) % P2 ;</span><br><span class="line">        ans += buc[mkp(x, y)] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从atcoder某天virtual的一场比赛。发现比起之前做过的场次，似乎 $\rm A$ 还是有点弱菜，$\rm B$ 还是有点奇怪，$\rm C$ 还是比较中规中矩&lt;del&gt;比较不会&lt;/del&gt; ，$\rm D$ 还是不很会…&lt;/p&gt;
&lt;p&gt;问题不大.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="字符串/哈希" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%93%88%E5%B8%8C/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】CodeForces Round#625</title>
    <link href="https://www.orchidany.cn/2020/03/02/CFround625/"/>
    <id>https://www.orchidany.cn/2020/03/02/CFround625/</id>
    <published>2020-03-02T12:19:18.000Z</published>
    <updated>2020-03-05T14:02:15.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是赛时整理？但是赛时发挥的一点也不好…第二天早上一起来就A掉了赛时没A的两个题…</p><p>总结：还是太菜。</p><p>没整理1E和1F。顺序按照Div2的顺序写的——</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给定两个 $01$ 串。设给每个位置一个正整数权 $p_i$ ，权被算到贡献里当且仅当对应位置为 <code>true</code> 。要求第一个串的权和要严格大于第二串。构造这样的 $p_i$ ，求 $\min\{\max_{i=1}^n\{p_i\}\}$ ，或者输出不可能。</p></blockquote><p>签到题。感觉可能直接放代码比嘴巴更好用？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; b[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; c[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; b[i]) ++ t1 ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i] &lt; b[i]) ++ t2 ;</span><br><span class="line">    <span class="keyword">if</span> (!t2 || t1 == n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    t1 ++ ; <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * t1 / (<span class="number">1.0</span> * t2)) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote><p>给定一个序列 $\{a_n\}$ ，要求选出来一个下标序列 $\{s_m\} ~ s.t. \forall i &lt; n,s_{i+1}-s_{i}=a_{s_{i+1}}-a_{s_i}$。</p><p>最大化选出来的 $a_i$ 的数值和。</p><p>$\{a_n\}&gt;0$</p></blockquote><p>大概是和差分那种题差不多的思路。令 $b_i=a_i-i$ ，那么发现 $b_i$ 同样的位置产生同一组贡献。由于每个位置的 $a_i$ 都 $&gt;0$ ，所以拿一个桶记一下即可。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>给定一个小写字母串 $s$，对于一个位置 $c$，如果相邻位置有音序掐好比它小 $1$ 的字母就可以删。问最多删多少个。</p><p>$1\leq |s|\leq 100$</p></blockquote><p>nmd，这题真是十分sb。给了个 $|s|=100$ 的范围这是在坑鬼？于是我就写了个 <code>while(1)</code> 无限删除，感觉这个复杂度应该很对。但是一直 <code>WA on 11</code> ，期间编了编感觉很对…冷静了一会儿发现，<code>dcbcd</code> 这种就可以卡掉，只有从大到小删才是好的。所以就是个贪心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> a[N] ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">int</span> pd[N] ;</span><br><span class="line"><span class="keyword">int</span> sd[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="comment">//int f[N][N][27][27] ;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        a[i] = S[i] - <span class="string">'a'</span> ; nxt[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">23333333</span> ; nxt[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="string">'z'</span> ; c &gt;= <span class="string">'a'</span> ; -- c)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            flag = <span class="number">0</span> ;<span class="comment">// cout &lt;&lt; nxt[1] &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nxt[<span class="number">0</span>] ; i ; i = nxt[i])</span><br><span class="line">                <span class="keyword">if</span> (a[i] == c - <span class="string">'a'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[pre[i]] + <span class="number">1</span> == a[i] || a[nxt[i]] + <span class="number">1</span> == a[i])</span><br><span class="line">                        ans ++, flag = <span class="number">1</span>, pre[nxt[i]] = pre[i], nxt[pre[i]] = nxt[i] ;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">/*for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">                if (!vis[i])&#123;</span></span><br><span class="line"><span class="comment">                    pd[i] = a[i] - a[pre[i]] ;</span></span><br><span class="line"><span class="comment">                    sd[i] = a[i] - a[nxt[i]] ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                else pd[i] = sd[i] = -1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            int ret = 0 ;</span></span><br><span class="line"><span class="comment">            for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">                //for (in i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; pre[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">                if (vis[i]) continue ;</span></span><br><span class="line"><span class="comment">                if (a[nxt[i]] != a[i])&#123;</span></span><br><span class="line"><span class="comment">                    for (int j = nxt[i] ; j ; j = nxt[j])</span></span><br><span class="line"><span class="comment">                        if (j &amp;&amp; pd[j] &lt;= 1 &amp;&amp; pd[j] &gt;= 0)</span></span><br><span class="line"><span class="comment">                            ++ ret, pre[nxt[j]] = pre[j], nxt[pre[j]] = nxt[j], vis[j] = 1 ; else break ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans += ret ; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">                if (ret) flag = 1 ; ret = 0 ;</span></span><br><span class="line"><span class="comment">                if (a[pre[i]] != a[i])&#123;</span></span><br><span class="line"><span class="comment">                    for (int j = pre[i] ; j ; j = pre[j])</span></span><br><span class="line"><span class="comment">                        if (j &amp;&amp; sd[j] &lt;= 1 &amp;&amp; sd[j] &gt;= 0)</span></span><br><span class="line"><span class="comment">                            ++ ret, pre[nxt[j]] = pre[j], nxt[pre[j]] = nxt[j], vis[j] = 1 ; else break ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans += ret ; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">                if (ret) flag = 1 ; ret = 0 ;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>弱智题。是真的没有一点意思的弱智题。甚至比不上A。</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给定一系列有代价的装备，第一种提供 $x$ 值，第二种提供 $y$ 值。给出一些怪兽，如果怪兽的 $x_i$ 和 $y_i$ 都小于选定的 $x$ 和 $y$ ，那么会有 $z_i$ 的奖励。最大化收益。</p><p>$1\leq n\leq 2\times 10^5$ 。</p></blockquote><p>一个比较自然的想法是排序之后枚举一维坐标，然后去算另一维。然而另一维并不具备单调性。考虑对于一个确切的 $x$ ，如何选择一个最优的 $y$ 取到最大值。考虑快速查找一个 $y$ 的最优值，需要快速计算当前 $y$ 可以提供击败哪些怪兽的贡献。</p><p>考虑将询问按照 $x$ 排序，就转化和成了一个二维扫描线问题。考虑用线段树维护每个 $y$ 值处的最大值。枚举第一种装备，每次用双指针扫到当前的 $x_i$，提前用线段树进行 $y$ 坐标的后缀加计算贡献。最后答案就是所有 $y$ 的最大值减去使用当前 $x$ 的代价。</p><p>感觉现在语言越来越苍白无力，还是代码比较容易说明道理。</p><p>感觉自己没做过太多这种类似的题，可能见多了就是套路了吧233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uppb upper_bound</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1000000101</span> ;</span><br><span class="line"> </span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arm</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x ;</span><br><span class="line">    <span class="keyword">int</span> c ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> arm &amp; t)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.x == x ? t.c &gt; c : t.x &gt; x ; &#125;</span><br><span class="line">&#125;a[N], b[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monster</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, v ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> monster &amp; t)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.y == y ? t.x &gt; x : t.y &gt; y ; &#125;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line">LL s[N * <span class="number">3</span>] ;</span><br><span class="line">LL tag[N * <span class="number">3</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    s[x] = max(s[x &lt;&lt; <span class="number">1</span>], s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x])&#123;</span><br><span class="line">        s[x &lt;&lt; <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(LL&amp; a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a = b &gt; a ? b : a ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) </span><br><span class="line"><span class="keyword">return</span> chkmax(s[rt], v) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, v, p) ;</span><br><span class="line">    <span class="keyword">else</span> update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        <span class="keyword">return</span> s[rt] += v, tag[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, v, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v, ul, ur) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">-63</span>, <span class="keyword">sizeof</span>(s)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].c) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b[i].x, &amp;b[i].c) ;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + m + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;base[i].x, &amp;base[i].y, &amp;base[i].v) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + k + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) tmp[i] = a[i].x ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ; </span><br><span class="line">    len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - (tmp + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        base[i].x = uppb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i].x) - tmp ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        a[i].x = lowb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, a[i].x) - tmp ;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, len, - a[i].c, a[i].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;s[1]&lt;&lt;endl;//, cout &lt;&lt; base[i].y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span> ; ans = - (S + S) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; b[i].x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (now &lt;= k &amp;&amp; base[now].y &lt; b[i].x)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, len, base[now].v, base[now].x, len), ++ now ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; now &lt;&lt; endl, cout &lt;&lt; s[1] &lt;&lt; " ---------- " &lt;&lt; endl ;</span></span><br><span class="line">        ans = max(ans, s[<span class="number">1</span>] - b[i].c) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote><p>给定一个 $01$ 串。每次询问两个等长的子串，询问是否可以从一个变换到另一个。变换操作的定义是每次选定一个子段，让 $110\to 011$ 或者 $011\to110$ 。</p><p>$n,q\leq 2\times 10^5$</p></blockquote><p>很有趣的一道观察性质题。考虑对于一次变换之后，位于 $p$ 位置的 $0$ 会变到 $p-2$ 或者 $p+2$ ，也就是 <strong>前缀 $1$ 的奇偶性没有发生改变</strong>。所以实质上每次是在查询，对于两个串，是否有相同数量的 $0$ ，且对应位置的 $0$ 之前 $1$ 的数量的奇偶性是否相同。这一部分可以用哈希实现。哈希时按奇偶性分类哈希，即可保证区间哈希的正确性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> a[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line">LL base[N] ;</span><br><span class="line">LL S[N], T[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL Base = <span class="number">217l</span>l ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a - b) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p0 = p + L - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> q0 = q + L - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> e1 = p0 - sum[p0] ;</span><br><span class="line">    <span class="keyword">int</span> e2 = q0 - sum[q0] ;</span><br><span class="line">    <span class="keyword">int</span> s1 = p - <span class="number">1</span> - sum[p - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> s2 = q - <span class="number">1</span> - sum[q - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (sum[p0] - sum[p - <span class="number">1</span>] != sum[q0] - sum[q - <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> ((sum[p - <span class="number">1</span>] &amp; <span class="number">1</span>) ^ (sum[q - <span class="number">1</span>] &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">bool</span>)(sub(T[e1], T[s1] * base[e1 - s1] % P) == sub(S[e2], S[s2] * base[e2 - s2] % P)) ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">bool</span>)(sub(S[e1], S[s1] * base[e1 - s1] % P) == sub(S[e2], S[s2] * base[e2 - s2] % P)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> x, y, l ; base[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])&#123;</span><br><span class="line">            ++ len ; base[len] = (base[len - <span class="number">1</span>] * Base) % P ;</span><br><span class="line">            S[len] = (S[len - <span class="number">1</span>] * Base % P + (sum[i] &amp; <span class="number">1</span>)) % P ;</span><br><span class="line">            T[len] = (T[len - <span class="number">1</span>] * Base % P + ((sum[i] &amp; <span class="number">1</span>) ^ <span class="number">1</span>)) % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;l) ;</span><br><span class="line">        <span class="keyword">if</span> (check(x, y, l)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉这场CF办的就跟闹着玩一样.jpg</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是赛时整理？但是赛时发挥的一点也不好…第二天早上一起来就A掉了赛时没A的两个题…&lt;/p&gt;
&lt;p&gt;总结：还是太菜。&lt;/p&gt;
&lt;p&gt;没整理1E和1F。顺序按照Div2的顺序写的——&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="字符串/哈希" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%93%88%E5%B8%8C/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】4 · 最大流模型进阶</title>
    <link href="https://www.orchidany.cn/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
    <id>https://www.orchidany.cn/2020/02/29/网络流24题·最大流模型进阶/</id>
    <published>2020-02-29T02:16:07.000Z</published>
    <updated>2020-03-01T23:17:27.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下稍微进阶一点的、可以用最大流解决的问题：</p><p><code>loj#6003 魔术球</code> 、 <code>loj#6005 最长递增子序列</code> 和 <code>loj#6015 星际转移</code>.</p><a id="more"></a><h1 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h1><blockquote><p>假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1, 2,3, . . .$ 的球。</p><p>(1) 每次只能在某根柱子的最上面放球。</p><p>(2) 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。</p><p>试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球.</p><p>$n\leq 55$</p></blockquote><p>考虑对于一组 $(i,j)$ ，如果 $i+j$ 是完全平方数，就由较小的那个向较大的那个连一条边。之后考虑本质上每根柱子上就是一个路径覆盖，所以持续加边，一直加到最小路径覆盖数 $&gt; $ 柱子数为止。</p><p>有一个很有意思的性质，就是网络流可以在线加边并且不用考虑之前的决策。</p><p>这题真nm是写到吐血。板子也改了一下如果不完全连通时的写法，需要特判每个点是否连通。这题神烦的是需要一遍一遍地清空，然后边的编号很容易就写错。</p><p>最后zay教育我只需要二分就可以了，这样每次就可以把全部的边都加进去，这样就可以瞎清空。我太dd了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[_s] = <span class="number">100000000</span> ; h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ;</span><br><span class="line">    <span class="keyword">if</span> (h[_s] &gt;= <span class="number">10000000</span>) <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ; <span class="keyword">else</span> h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span> &amp;&amp; h[to(k)] &lt;= n)</span><br><span class="line">            vis[to(k)] = <span class="number">1</span>, p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; p.pop() ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (h[x] == <span class="number">100000000</span>) <span class="keyword">break</span> ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x] &amp;&amp; minh&lt;=n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        h[i] = n + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ; <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[p] ; ~k ; k = e[k].next)</span><br><span class="line">        <span class="keyword">if</span> (!fw(k) &amp;&amp; to(k) != <span class="number">2</span> &amp;&amp; !(to(k) &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, (to(k) - <span class="number">2</span>) / <span class="number">2</span>), output(to(k) - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n = <span class="number">2</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>, h[<span class="number">2</span>] = <span class="number">0</span>, head[<span class="number">1</span>] = head[<span class="number">2</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">1</span> ; ; ++ res)&#123;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(<span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(n, <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span>, n, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; res ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sqrt</span>(res + j) == (<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(res + j)))</span><br><span class="line">                add(<span class="number">2</span> * j + <span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">2</span> * j + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            h[i] = <span class="number">100000000</span>, vis[i] = gap[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> ans = HLPP() ; <span class="keyword">if</span> (res - ans &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "--------------------" &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res -- ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; <span class="number">1</span> &amp;&amp; (fr(i) &amp; <span class="number">1</span>) &amp;&amp; !(to(i) &amp; <span class="number">1</span>)  &amp;&amp; to(i) != <span class="number">2</span> &amp;&amp; !fw(i))</span><br><span class="line">            fa[find((to(i) - <span class="number">2</span>) / <span class="number">2</span>)] = find(fa[(fr(i) - <span class="number">1</span>) / <span class="number">2</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), output(i * <span class="number">2</span> + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><blockquote><p>给定正整数序列 $x_1 \ldots, x_n$。</p><p>1、计算其最长不下降子序列的长度 $s$。</p><p>2、如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</p><p>3、如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个<strong>不同的</strong>长度为 $s$ 的不下降子序列。</p><p>$n\leq 500$</p></blockquote><p>考虑第一问可以直接拿来跑一个 $n^2$ 的 $dp$ 。对于第二问，考虑网络流。对于每个数，有限制只能用 $1$ 次，且必须要保证每个 LIS 长度都为 $s$ 。所以如果单纯地拿每个 $i$ 与起点和终点连边，对于一组 $i&lt;j$ 且 $a_i&lt;a_j$ 且 $f_j=f_{i}+1$ 的 $(i,j)$ ，中间连流量为 $1$ 的边。</p><p>这样建图就很有问题：</p><p>1、考虑这样建图，加谁一个点的入度为 $d_1$，出度为 $d_2$ ，那么实质上它会被使用 $\min\{d_1,d_2\}$ 次。为了防止这种情况出现，所以把一个点拆成两个点，一个点用来接收入度，一个点用来接收出度，$i\to i’$ 连流量为 $1$ 的边。</p><p>2、同时，由于并不能很容易地确定一条流经过多少条边，所以不是很容易得到长度为 $s$ 的 LIS。所以考虑换一种建图方式。即只让 $f_i=s$ 的每个 $i$ 与 $\rm T$ 连边。这样就保证走出来的只会是长度为 $s$ 的 LIS。</p><p>那么第三问，考虑再加上 $s\stackrel{f = +\infty}{\longrightarrow}1,1\stackrel{f = +\infty}{\longrightarrow}1’$ 这种边。如果 $f_n=s$ 的话也类似处理即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    _s = <span class="number">2</span> * n + <span class="number">1</span>, <span class="keyword">_t</span> = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], f[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[j] &lt;= base[i])</span><br><span class="line">                f[i] = max(f[i], f[j] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) res = max(res, f[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(i, i + n, <span class="number">1</span>), add(i + n, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == <span class="number">1</span>) add(<span class="number">2</span> * n + <span class="number">1</span>, i, <span class="number">1</span>), add(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == res) add(i + n, <span class="number">2</span> * n + <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span> * n + <span class="number">2</span>, i + n, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i] &lt;= base[j] &amp;&amp; f[i] + <span class="number">1</span> == f[j])</span><br><span class="line">                add(i + n, j, <span class="number">1</span>), add(j, i + n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">if</span> (f[t] == res)&#123;</span><br><span class="line">        add(t, <span class="keyword">_t</span>, <span class="number">100000000</span>), add(<span class="keyword">_t</span>, t, <span class="number">0</span>) ;</span><br><span class="line">        add(t, t + t, <span class="number">100000000</span>), add(t + t, t, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(_s, <span class="number">1</span>, <span class="number">100000000</span>), add(<span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, t + <span class="number">1</span>, <span class="number">100000000</span>), add(t + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="星际转移"><a href="#星际转移" class="headerlink" title="星际转移"></a>星际转移</h1><blockquote><p>现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船 $i$ 只可容纳 $p_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如：$\{1,3,4\}$ 表示该太空船将周期性地停靠太空站 134134134 …</p><p>每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站（或月球、地球）时上、下船。</p><p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p><p>$n,m\leq 50$ 。</p></blockquote><p>很神奇的分层图建图。考虑本身似乎是路径规划问题，但是具有以下性质：1、边的限制跟网络流图的限制几乎相同；2、每条边的代价都是 $1$  ; 3、数据范围 $n,m\leq 50$ ，可以知道如果有解，最多就是在 $0\to -1$ 路径上的每个点都停一遍，考虑每次停最多停 $n$ 个市场，那么最终答案的上界就是 $O(n^2)$ 。</p><p>根据以上性质，可以发现似乎枚举答案复杂度不高，可以转化为判定性问题。而网络流恰好可以解决判定性问题。所以考虑现在要做的就是如何建一个流图，使得跑出来的最大流就是当前能够运输的最多的人数。</p><p>发现决策对时间负责，那么每个时间，一个点可以走出去或者原地傻愣。根据状态最原始的表示方式，可知如果将每个时刻的每个点都单列一个状态，恰好可以转移。</p><p>所以建一个超级 $\rm S$ 连向每个 $t$ 的 $0$ ，建一个超级 $\rm T $ 让每个 $t$ 的 $-1$ 连向它，剩下的就按照转移来建就好了。</p><p>最后写了个 dinic…还是dinic好…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> cur[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        dis[i] = <span class="number">0</span>, cur[i] = head[i] ; dis[<span class="keyword">_t</span>] = <span class="number">0</span> ;</span><br><span class="line">    dis[_s] = <span class="number">1</span> ; q.push(_s) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (!dis[to(k)] &amp;&amp; fw(k) &gt; <span class="number">0</span>)</span><br><span class="line">                dis[to(k)] = dis[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, minf ;</span><br><span class="line">    <span class="keyword">if</span> (x == aim || !f) <span class="keyword">return</span> f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;k = cur[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[to(k)] != dis[x] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (( minf = dfs(to(k), aim, min(f, fw(k))) ) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ret += minf, fw(k) -= minf, fw(k ^ <span class="number">1</span>) += minf ;</span><br><span class="line">            f -= minf ; <span class="keyword">if</span> (f &lt;= <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> rn[N] ;</span><br><span class="line"><span class="keyword">int</span> ctn[N] ;</span><br><span class="line"><span class="keyword">int</span> ways[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    _s = <span class="number">0</span> ; <span class="keyword">_t</span> = <span class="number">50000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm &gt;&gt; s ; n = nn + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rn[i] &gt;&gt; ctn[i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; ctn[i] ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ways[i][j] ; ways[i][j] += <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) fa[find(ways[i][j])] = find(ways[i][j - <span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">2</span>) != find(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; <span class="keyword">else</span> nn += <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">0</span> ; ; ++ res)&#123;</span><br><span class="line">        add(<span class="keyword">_t</span>, res * nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">2</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">1</span>, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        add(_s, res * nn + <span class="number">2</span>, <span class="number">100000000</span>) ;</span><br><span class="line"><span class="keyword">if</span> (res)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">            add(res * nn + i, (res - <span class="number">1</span>) * nn + i, <span class="number">0</span>) ;</span><br><span class="line">            add((res - <span class="number">1</span>) * nn + i, res * nn + i, <span class="number">100000000</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = ctn[i] ;</span><br><span class="line">            <span class="keyword">int</span> x = ways[i][res % r] ;</span><br><span class="line">            <span class="keyword">int</span> y = ways[i][(res - <span class="number">1</span>) % r] ;</span><br><span class="line">            x += nn * res, y += nn * (res - <span class="number">1</span>) ;</span><br><span class="line">            add(y, x, rn[i]), add(x, y, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        n = <span class="number">1</span> + (res + <span class="number">1</span>) * nn ;</span><br><span class="line"><span class="keyword">while</span> (bfs()) ans += dfs(_s, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= s) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括以下稍微进阶一点的、可以用最大流解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loj#6003 魔术球&lt;/code&gt; 、 &lt;code&gt;loj#6005 最长递增子序列&lt;/code&gt; 和 &lt;code&gt;loj#6015 星际转移&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】3 · 最小割模型</title>
    <link href="https://www.orchidany.cn/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.orchidany.cn/2020/02/29/网络流24题·最小割模型/</id>
    <published>2020-02-29T01:39:39.000Z</published>
    <updated>2020-03-01T10:53:32.767Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是比较神奇的最小割模型。</p><p>涉及的题目有 <code>loj#6007 方格取数</code> 、 <code>loj#6001 太空飞行计划</code> 和 <code>loj#6226 骑士共存问题</code>。 </p><a id="more"></a><h1 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h1><blockquote><p>有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</p></blockquote><p>考虑对于方格中，取格子要求“没有公共边”，那么需要想到就是在进行一个黑白染色，不能选与之四连通的格子。所以最后本质上就是一个二分图，不能选有边相连的点，也就是对于每一条边 $\rm e$， 两个端点至多选一个。</p><p>然后就是很神奇的建图方式。考虑为了模拟出这个过程，建一个 $\rm S$ 连向所有黑点，流量即为点权；建一个 $\rm T$ 让所有白点连向它，流量同样是点权。中间根据连通性来连流量为 $+\infty$ 的边。这样建模之后，考虑最小割的本质含义。对于一条边 $(u,v)$ ，$\mathrm S\to u$ 和 $v\to\rm T$ 必定有一个需要被割，满足「两个端点至多选一个」的限制。那么如果用最小割的话，就可以将挑出来的边作为删去的点从总权中减去即为答案。</p><p>那么大概最小割的建模技巧，就是考虑用连通性这个东西来操作。比如什么「A和B至多选一个使得最终权值最大/小」，就可以用类似的技巧来建模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; tot = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[++ tot]), Ans += base[tot],</span><br><span class="line">            (i + j &amp; <span class="number">1</span>) ? white[++ w] = tot : black[++ b] = tot, <span class="built_in">map</span>[i][j] = tot ;</span><br><span class="line">    S = <span class="number">1</span>, T = tot + <span class="number">1</span> ; <span class="comment">/*cout &lt;&lt; tot &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) Add(S, white[i], base[white[i]])  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">ceil</span>((<span class="keyword">double</span>)(white[i] - <span class="number">1</span>) / M) ;</span><br><span class="line">        <span class="keyword">int</span> y = (white[i] - <span class="number">1</span>) - (x - <span class="number">1</span>) * M ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = x + dx[j], ky = y + dy[j] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= <span class="number">0</span> || ky &lt;= <span class="number">0</span> || ky &gt; M || kx &gt; N) <span class="keyword">continue</span> ;</span><br><span class="line">            Add(white[i], <span class="built_in">map</span>[kx][ky], INF) ;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= b ; ++ i) </span><br><span class="line">      Add(black[i], T, base[black[i]]) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans - HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="太空飞行计划"><a href="#太空飞行计划" class="headerlink" title="太空飞行计划"></a>太空飞行计划</h1><blockquote><p>现已确定了一个可供选择的实验集合 $E = \{ E_1, E_2, \cdots, E_m \}$，和进行这些实验需要使用的全部仪器的集合$ I = \{ I_1, I_2, \cdots, I_n \}$。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \subseteq I$。</p><p>配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。</p><p>对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。</p></blockquote><p>这个题的模型似乎是什么「最大权闭合子图」，大概就是如果选了某个点 $v$ ，那么 $v$ 指向的所有点都必须要选，最大化点权和。</p><p>考虑以这么一种方式建图。$\rm S$ 连向所有正权点，流量为该点的点权；所有负权点连向 $\rm T$ ，流量为该点的绝对值；原本图中的点按照原来的方式连上去，流量为 。跑一个最小割，然后正权点和-最小割就是最终的答案。</p><p>考虑这么做的正确性。对于最小割而言，既然是割，那么要么会去割一个正权点，代表正权点连接点集都不选；或者选择割掉与之相连的所有负权点，代表选了这个点集。那么这样两种决策的本质上都是在倒扣代价。所以是成立的。</p><p>这题还要憨憨地输出方案。这个地方有个神奇的输出方式，就是判断每个点是否与 $\rm S$ 相连，如果一个点指向的某个点不与 $\rm S$ 连通，那么他就它俩之间的边就是一条割边。</p><p>首先不难知道，这些边都是满流的。考虑之所以这些满流的边就是被割的边，原因是他们恰好是 $\rm S$ 到 $\rm T$ 每条路径的瓶颈边，所以他们的流量加起来就是最大流(因为即使有更多也不能流了)，那么也就是最小割。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> newline ;</span><br><span class="line"><span class="keyword">int</span> E[M * <span class="number">2</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="number">48</span> , ch = getchar() ;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\n'</span>) newline = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">100000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">        x = read() ;</span><br><span class="line">        sum += x ; newline = <span class="number">0</span> ;</span><br><span class="line">        add(_s, i, x) ; add(i, _s, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (!newline)&#123;</span><br><span class="line">            y = read() ;</span><br><span class="line">            add(y + nn, i, <span class="number">0</span>) ;</span><br><span class="line">            add(i, y + nn, <span class="number">100000000</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y, add(i + nn, <span class="keyword">_t</span>, y), add(<span class="keyword">_t</span>, i + nn, <span class="number">0</span>) ;</span><br><span class="line">    n = nn + mm ; res = sum - dinic() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i) ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nn + <span class="number">1</span> ; i &lt;= mm + nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - nn) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="骑士共存"><a href="#骑士共存" class="headerlink" title="骑士共存"></a>骑士共存</h1><blockquote><p>给定 $n^2$ 个方格的国际象棋棋盘和障碍标志，有障碍的不能放，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。</p><p>$n\leq 200$ </p></blockquote><p>大概这种题一开始被我当作一般图最大独立集做了…然后不会…</p><p>感觉在网格图搞事情，还是需要有种观察性质的直觉的。比如就会发现，骑士跳的每两步，都不会是同一个颜色。那么这就会转化成一个二分图问题，同种颜色之间没有边相连，有两种颜色，符合二分图的限制。所以最后只需要求一发二分图最大独立集即可。</p><p>考虑把原二分图转为流图，中间的边流量为 inf ，其余为 1 。这个网络的最小割满足，对于中间每一条边，两端的点必定选择了一个，否则 S 与 T 仍连通。故最小割对应最小点覆盖。而最小点覆盖与最大独立集互为对偶问题，所以算一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> x, y, kx, ky ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">60001</span>, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, mark[x][y] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span> ; x &lt;= n ; ++ x)</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">1</span> ; y &lt;= n ; ++ y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[x][y]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> ((x + y) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">7</span> ; ++ k)&#123;</span><br><span class="line">                    kx = x + dx[k] ;</span><br><span class="line">                    ky = y + dy[k] ;</span><br><span class="line">                    <span class="keyword">if</span> (mark[kx][ky]) <span class="keyword">continue</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || ky &gt; n || kx &gt; n) <span class="keyword">continue</span> ;</span><br><span class="line">                    add(kx * (n + <span class="number">1</span>) + ky, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                    add(x * (n + <span class="number">1</span>) + y, kx * (n + <span class="number">1</span>) + ky, <span class="number">100000000</span>) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, _s, <span class="number">0</span>) ;</span><br><span class="line">                add(_s, x * (n + <span class="number">1</span>) + y, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(<span class="keyword">_t</span>, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, <span class="keyword">_t</span>, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = (n + <span class="number">1</span>) * (n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t * t - m - dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方大概需要注意，两个点之间不要连双向的边。这样最小割就会错，因为最大流的意义不对了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是比较神奇的最小割模型。&lt;/p&gt;
&lt;p&gt;涉及的题目有 &lt;code&gt;loj#6007 方格取数&lt;/code&gt; 、 &lt;code&gt;loj#6001 太空飞行计划&lt;/code&gt; 和 &lt;code&gt;loj#6226 骑士共存问题&lt;/code&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="网络流/最小割" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】2 · 较简单的最大流</title>
    <link href="https://www.orchidany.cn/2020/02/28/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%982%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <id>https://www.orchidany.cn/2020/02/28/网络流24题2·简单的最大流问题/</id>
    <published>2020-02-28T03:29:15.000Z</published>
    <updated>2020-03-01T00:07:47.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下较为简单的可以用最大流解决的问题：</p><p><code>loj#6000 搭配飞行员</code>、<code>loj#6006 试题库</code>、 <code>loj#6004 圆桌聚餐</code> 和 <code>loj#6002 最小路径覆盖</code> 。</p><a id="more"></a><h1 id="搭配飞行员"><a href="#搭配飞行员" class="headerlink" title="搭配飞行员"></a>搭配飞行员</h1><blockquote><p>飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员，需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。</p><p>因为驾驶工作分工严格，两个正驾驶员或两个副驾驶员都不能同机飞行。</p></blockquote><p>这显而易见的就是一个二分图匹配的问题。考虑 $\rm S$ 向左部每个点连 $f=1$ 的边，右部的向 $\rm T$ 连 $f=1$ 的边。考虑一组匹配会贡献 $1$ 的流量，且每个点只有 $1$ 的原始流保证了只可使用一次，所以不难证明是但俺就是最大流。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;  </span><br><span class="line">fill(head, head + N + <span class="number">30</span>, <span class="number">-1</span>); S = <span class="number">0</span>, T = N + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B)  add(A, B, <span class="number">23333</span>), add(B, A, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M ; i ++) add(S, i, <span class="number">1</span>), add(i, S, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = M + <span class="number">1</span>; i &lt;= N ; i ++) add(i, T, <span class="number">1</span>), add(T, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题库"><a href="#试题库" class="headerlink" title="试题库"></a>试题库</h1><blockquote><p>假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。</p></blockquote><p>很水的建模，$\rm S$ 向每个题连 $f=1$ 的边表示只能用一次，每个题向对应的类型连边，每个类型向 $\rm T$ 连 $f=need_x$ 的边。然后输出方案就只需要看一下每个类型连的边有谁 $f$ 被流成 $0$ 了即可。</p><p>很久之前的 Dinic 代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N, T = N + K + <span class="number">1</span> ;</span><br><span class="line">cnt = <span class="number">-1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>) ; L1 = cnt + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + K ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), w1 += x, Add(i, T, x) ; </span><br><span class="line">R1 = cnt ; L2 = R1 + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x) ; </span><br><span class="line"><span class="keyword">while</span> (x --) <span class="built_in">cin</span> &gt;&gt; y, Add(i, N + y, <span class="number">1</span>) ; </span><br><span class="line">&#125; R2 = cnt ;</span><br><span class="line"><span class="keyword">while</span>(BFS())&#123; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ;</span><br><span class="line">w += dfs(S, T, Inf) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (w != w1) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = L2 ; i &lt; R2 ; i += <span class="number">2</span>) </span><br><span class="line">    <span class="keyword">if</span> (!E[i].f) Ans[to(i) - N].push_back(E[i].fr) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i, <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>) </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>, j = <span class="number">0</span> ; j &lt; Ans[i].size() ; ++ j) <span class="built_in">cout</span> &lt;&lt; Ans[i][j] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="圆桌聚餐"><a href="#圆桌聚餐" class="headerlink" title="圆桌聚餐"></a>圆桌聚餐</h1><blockquote><p>假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。</p><p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。</p></blockquote><p>发现是一个特殊的匹配问题，考虑从 $\rm S$ 到每个单位连 $f=r_i$ 的边，每个桌子向 $\rm T$ 连一条 $f=c_i$ 的边，同时每个单位和每张桌子之间连 $f=1$ 的边。这样就可以控制每个单位至多一个在某个餐桌。同样，如果限制同一张餐桌不能做超过 $k$ 个同一单位的人，只需要把 $f$ 从 $1$ 改成 $k$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> A[M][M] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ; fw(cnt) = c ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">    <span class="keyword">return</span> cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ; h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span>) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">            p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; h[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; vis[x] = <span class="number">0</span> ; p.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        gap[h[i]] --, h[i] = n + <span class="number">1</span>, gap[h[i]] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        head[i] = <span class="number">-1</span>, h[i] = <span class="number">1000000000</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    n = nn + mm + <span class="number">2</span> ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n ; Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, res += w,</span><br><span class="line">        add(_s, i + <span class="number">1</span>, w), add(i + <span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, add(i + nn + <span class="number">1</span>, <span class="keyword">_t</span>, w), add(<span class="keyword">_t</span>, i + nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">            A[i][j] = add(i + <span class="number">1</span>, j + nn + <span class="number">1</span>, <span class="number">1</span>), add(j + nn + <span class="number">1</span>, i + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (HLPP() &lt; res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (fw(A[i][j]) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小路径覆盖问题"><a href="#最小路径覆盖问题" class="headerlink" title="最小路径覆盖问题"></a>最小路径覆盖问题</h1><blockquote><p>给定有向图 $\rm G=\{V,E\}$。设 $\rm P$ 是 $\rm G$ 的一个简单路（顶点不相交）的集合。如果 $\rm V$ 中每个顶点恰好在 $\rm P$ 的一条路上，则称 $\rm P$ 是 $\rm G$ 的一个路径覆盖。 $\rm P$ 中路径可以从 $\rm V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 $0$。 的最小路径覆盖是 $\rm G$ 的所含路径条数最少的路径覆盖。</p></blockquote><p>嗯，这道题大概是教了一下怎么拆点。考虑对于每个点 $v$，新建一个替身点 $v’$ 。原图中的路径 $(u,v)$ 变换为 $(u,v’)$ ，然后 $\rm S$ 向所有 $v$ 连边，所有 $v’$ 向 $\rm T$ 连边。思考这么做本质上是在求一个匹配，最后没有匹配的到左部的一个有部点可以看做是一条路径的结尾。那么考虑这样跑完一组匹配之后，所有没有匹配上的点都是一条路径的结尾，也就是路径的数量。所以跑一个最大流，就可以得到最少的路径数量，也就是最小路径匹配。</p><p>这代码还是上古时期拿 dinic 写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, S = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    Add(S, i, <span class="number">1</span>), Add(i + N, T, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B + N, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (BFS()) &#123; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ; </span><br><span class="line">    Ans += dfs(S, T, Inf) ; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = i ; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (fr(i) &gt;= <span class="number">1</span> &amp;&amp; fr(i) &lt;= N &amp;&amp; to(i) &lt; T &amp;&amp; to(i) &gt; N &amp;&amp; !E[i].f) </span><br><span class="line">fa[find(to(i) - N)] = find(fa[fr(i)]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) begin_output(i), <span class="built_in">puts</span>(<span class="string">""</span>) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; N - Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么不难看出建虚点这个操作的目的，就是限制每个点的经过次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括以下较为简单的可以用最大流解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loj#6000 搭配飞行员&lt;/code&gt;、&lt;code&gt;loj#6006 试题库&lt;/code&gt;、 &lt;code&gt;loj#6004 圆桌聚餐&lt;/code&gt; 和 &lt;code&gt;loj#6002 最小路径覆盖&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[ARC066]C/D/E Sol</title>
    <link href="https://www.orchidany.cn/2020/02/26/ARC066C-E/"/>
    <id>https://www.orchidany.cn/2020/02/26/ARC066C-E/</id>
    <published>2020-02-26T08:52:52.000Z</published>
    <updated>2020-03-01T23:18:50.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是正好做到了这一场的F，就顺便把前三个题给做了。</p><p>嗯，感觉思维能力还是很重要的。所以不能再这么沉沦了啊。</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>有编号为 $1\sim N$ 号的 $N$ 个人，给你第 $i$ 个人的「自己的左排列的人数和自己的右排列的人数的差的绝对值」$A_i$。 请根据他们的报告，求出原来的排列方法有几种。对 $10^9+7$ 取模 。</p><p>$A_i\leq 10^9,N\leq 10^5$</p></blockquote><p>或许可以根据样例猜出来，大概是一点性质吧，比如什么数值必须对称分布。那么想到这一点，再深入想一下就可以发现对于每个 $n$ 而言，他们的 $A_i$ 是固定的。所以直接生成这个标准答案序列，然后把给出的 $A$ 排一遍序，比较是否相同即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        yes[<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = <span class="number">2</span> * (++ cnt) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        yes[<span class="number">1</span>] = yes[<span class="number">2</span>] = ++ cnt ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = (cnt += <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, expow(<span class="number">2</span>, n / <span class="number">2</span>)), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>求出整数对 $u$ 和 $v$ $(0≤u,v≤N)$ 的数目，使得存在两个非负整数 $a$ 和 $b$ 满足 $a xor b = u$ 和 $a + b= v$.</p><p>要求对答案取模 $10^9 + 7$ 。$N\leq 10^{18}$。</p></blockquote><p>这个题好像有一堆十分有趣的做法…但是碍于智商并不是很想去学qaq，就放个链接吧 <a href="https://qiita.com/259_Momone/items/86e90d17e4efe3b22433" target="_blank" rel="noopener">戳</a> 。</p><p>然后自己就对着一个神奇的做法编了一下原理。<del>发现自己果然是马后炮选手</del> 。</p><p>考虑 </p><script type="math/tex; mode=display">a+b=((a~\mathrm{and}~b)<<1)+(a~\mathrm{xor}~b)</script><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到 $a+b\geq  a~\mathrm{xor}~b$ 这样的结论。</p><p>那么如果由于 $u\leq v$，所以如果 $v$ 不越界那么 $u$ 一定不越界。于是考虑按 $v$ 进行 $dp$。具体的，考虑状态 $f_{i,j}$ 表示考虑了 $a$ 和 $b$ 二进制下的前 $i$ 位，当前 $v=a+b=j$ 的方案数。</p><p>考虑如何转移。对于 $a$ 和 $b$ 而言，第 $i$ 位有三种情况，$(0,0),(0,1),(1,1)$ 。那么也就是假设原来的和为 $j’$，和当前的和 $j$ 可能有以下关系：</p><p>1、$2\cdot (j’+1)=j$，对应着都补一位 $1$。</p><p>2、$2\cdot j’=j$，对应着都补一位 $0$ 。</p><p>3、$j’+ (j’ + 1)=j$，对应着一个补 $1$ 一个补 $0$ 。</p><p>那么也就是</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,\lfloor\frac{j}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-2)}{2}\rfloor}</script><p>发现本质上，第一维状态随着第二维递减，且都是 $\Delta(\log)$ 级别，并且每次计算，必定存在三项中有两项是相等的，所以可知最后状态数一定介于 $\Omega(2\log N)\sim O(\log N)$ 之间，可以通过本题。</p><p>然后第一维就可以直接压掉了。</p><p>不过话说回来，关于这个状态数，我还是不知道该怎么算，最终还是打表打出来的这么一个界，大概是在 $2^k-1$ 时达到下界，$2^k$ 时达到上界。想了想这么分布似乎很合理，但是还是不知道为啥。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(<span class="keyword">int</span> p, LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.count(x)) <span class="keyword">return</span> m[x] ; <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> m[x] = <span class="number">1</span> ; <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> m[x] = <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">return</span> m[x] = ((f(p - <span class="number">1</span>, x / <span class="number">2</span>) + f(p - <span class="number">1</span>, (x - <span class="number">1</span>) / <span class="number">2</span>)) % P + f(p - <span class="number">1</span>, (x - <span class="number">2</span>) / <span class="number">2</span>)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(log2(n) + <span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给你一个只包含 $’+’$ 、$’-‘$、正整数的式子，你需要在式子中添加一些括号，使运算结果最大，输出最大的结果。</p><p>$n\leq 10^5,a_i\leq 10^9$ 。 </p></blockquote><p>大概是个观察性质题。首先可以知道，加号后面不会右括号，或者说可以被忽略掉；其次，最多有两层括号嵌套，多了没有意义，因为比如 $-((a-b)-(a-(a-b)-b))$ 这个就可以写成 $-((a-b)-(a-a)-(b-b))$ 的形式。</p><p>考虑 $dp$ 实现，状态大概设计为 $f_{i,j}$ 表示考虑了前 $i$ 个数，一共有 $j$ 个左括号没有闭合的最大结果。可以知道第二维只会是 $0,1,2$ 。思考如何转移，大概就是分类讨论左括号数量。一开始带符号地读入 $x$ ，那么可知可以先赋初值： $f_{i,0}=x,f_{i,1}=-x,f_{i,2}=x$ 这样。然后考虑转移。发现我们可以通过加一个右括号使得未匹配的左括号数量减少，那么也就是 $f_{i,0}$ 可以加上 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，$f_{i,1}$ 可以加上 $\max\{f_{i-1,1},f_{i-1,2}\}$ ， $f_{i,2}$ 就只能原地转移。然后就是考虑，如果当前的 $x &lt;0$ ，也就是读进来一个符号，那么可以考虑放一个左括号，所以需要 <code>chkmax</code> 一下 <code>(f[i][2],f[i][1]),(f[i][1],f[i][0])</code> 。 </p><p>注意最后要输出 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，原因是根据状态的定义，我们没有考虑在第 $n$ 个数最后添上右括号的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; LL x ;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">2</span>] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">52</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        x = qr() ;</span><br><span class="line">        f[i][<span class="number">0</span>] = x ;</span><br><span class="line">        f[i][<span class="number">2</span>] = x ;</span><br><span class="line">        f[i][<span class="number">1</span>] = -x ;</span><br><span class="line">        f[i][<span class="number">2</span>] += f[i - <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line">        f[i][<span class="number">1</span>] += max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]) ;</span><br><span class="line">        f[i][<span class="number">0</span>] += max(f[i - <span class="number">1</span>][<span class="number">0</span>], max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>])) ;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i][<span class="number">2</span>], f[i][<span class="number">1</span>]) ;</span><br><span class="line">            f[i][<span class="number">1</span>] = max(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(f[n][<span class="number">1</span>], max(f[n][<span class="number">0</span>], f[n][<span class="number">2</span>])) &lt;&lt; <span class="built_in">endl</span>  ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>思路题还是要自己先认真想，不然真的做了效果不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是正好做到了这一场的F，就顺便把前三个题给做了。&lt;/p&gt;
&lt;p&gt;嗯，感觉思维能力还是很重要的。所以不能再这么沉沦了啊。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
  </entry>
  
  <entry>
    <title>【题解】[AGC012E]Camel and Oases</title>
    <link href="https://www.orchidany.cn/2020/02/25/AGC012E/"/>
    <id>https://www.orchidany.cn/2020/02/25/AGC012E/</id>
    <published>2020-02-25T13:35:02.000Z</published>
    <updated>2020-02-26T01:03:32.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，保证 $-10^{9}\le x_1&lt;x_2…&lt;x_n\le 10^9$</p><p>现在有一个人在沙漠中进行旅行，他初始的背包的水容积为 $V$ 升，同时他初始拥有 $V$ 升水，每次到达一个绿洲时，他拥有的水的量将自动重置为容积上限。他现在可以选择两个操作来进行旅行：</p><ol><li><p>走路，行走距离为 $d$ 时，需要消耗 $d$ 升水。清注意，任意时刻你拥有的水的数量不能为负数。</p></li><li><p>跳跃，令 $v$ 为你当前拥有的水量，若 $v&gt;0$，则你可以跳跃至任意一个绿洲，然后重置容积上界和所拥有的水量为 $v/2$ （四舍五入取整）。</p></li></ol><p>对于每一个 $i$ 满足 $1\le i\le n$，你需要求当你在第 $i$ 个绿洲作为起点时，你能否依次遍历其他所有绿洲。如果可以，输出 <code>Possible</code>，否则输出 <code>Impossible</code>。</p><p>$1\leq n,v\leq 2\times10^5$。</p></blockquote><p>神仙状态设计题orz</p><a id="more"></a><p>定义 $G$ 为全集，具体定义后文详谈。</p><p>首先考虑一点，就是本质上最多有 $\log V$ 种容积，可以把这个看做 $\log V$ 层，每层都有 $n$ 个点。定义层与层之间的方向「从上至下」代表容积不断变小，同上从上至下给每一层一个递增的编号。考虑对于每一层，可以把所有能够互相到达的连通块缩成几条线段，这样每层就是几条线段了。那么题目要求的就是，在限制第一层选某个线段时，每层至多选一个线段，是否可以讲整个 $[1,n]$ 覆盖。</p><p>考虑首先预处理出来 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ ，分别表示在第 $s$ 层内，某个点所在线段的左端点和右端点。然后考虑预处理出这么两个状态：$expanL_t$ 和 $expanR_t$ ，表示只考虑集合 $t$ 内的那几层，最多从 $1$ 向右扩展至什么地方和最多从 $n$ 向左扩展到什么地方。考虑先把所有包含第一层的集合忽略，那么存在转移：</p><script type="math/tex; mode=display">expanL_t=\max_{s\in t}\{R[t][expanL_{t-\{s\}} +1] \}\\expanR_t=\min_{s\in t}\{L[t][expanR_{t-\{s\}} -1] \}\\</script><p>这个转移十分神奇。以 $expanL$ 的转移为例，本质上对于一个集合 $t-\{s\}$，为了求出连续块，应该去枚举第  $s$ 层内第一个不包含在 $expanL_{t-\{s\}}$ 内的线段，然后用这个线段是右端点来更新，所以或许需要一个二分。但是其实根本不需要，直接可以用上面推出来的 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ 进行转移，还是很巧妙的。</p><p>最后就可以枚举每条线段，去找是否存在一个不包含第一层的状态 $t$ ， $expanL_t$ 覆盖了 $1\sim l_t$ ，同时 $expanR_{G-t}$ 覆盖了 $r_{G-t}\sim n$ ，那么如果这个线段的左右端点 $l,r$ 分别满足 $l-1\leq l_t$ 和 $r+1\geq r_{G-t}$，那么这个线段内部的点都是合法的。</p><p>最终复杂度 $O(\max\{(n+v)\log v, n\log n\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">40</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1001000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep ;</span><br><span class="line"><span class="keyword">int</span> maxn ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> L[M][N] ;</span><br><span class="line"><span class="keyword">int</span> R[M][N] ;</span><br><span class="line"><span class="keyword">int</span> farfrl[N] ;</span><br><span class="line"><span class="keyword">int</span> farfrr[N] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rg[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; j &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        R[++ dep][n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            L[dep][i] = (base[i] - base[i - <span class="number">1</span>] &gt; j) ? i : L[dep][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            R[dep][i] = (base[i + <span class="number">1</span>] - base[i] &gt; j) ? i : R[dep][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Auxiliary_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= dep ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] + <span class="number">1</span>]) ;</span><br><span class="line">                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    base[<span class="number">0</span>] = -MAX ;</span><br><span class="line">    base[n + <span class="number">1</span>] = MAX ; k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; Init_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        rg[i].l = L[<span class="number">1</span>][i], rg[i].r = R[<span class="number">1</span>][i] ;</span><br><span class="line">    sort(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) ; maxn = (<span class="number">1</span> &lt;&lt; dep) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; ++ i) farfrr[i] = n + <span class="number">1</span> ;</span><br><span class="line">    k += unique(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) - rg ; Auxiliary_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= maxn ; j += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (farfrl[j] + <span class="number">1</span> &gt;= rg[i].l &amp;&amp; farfrr[(maxn ^ j) ^ <span class="number">1</span>] - <span class="number">1</span> &lt;= rg[i].r)</span><br><span class="line">                &#123; <span class="keyword">for</span> (<span class="keyword">int</span> o = rg[i].l ; o &lt;= rg[i].r ; ++ o) ans[o] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">puts</span>(ans[i] ? <span class="string">"Possible"</span> : <span class="string">"Impossible"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，保证 $-10^{9}\le x_1&amp;lt;x_2…&amp;lt;x_n\le 10^9$&lt;/p&gt;
&lt;p&gt;现在有一个人在沙漠中进行旅行，他初始的背包的水容积为 $V$ 升，同时他初始拥有 $V$ 升水，每次到达一个绿洲时，他拥有的水的量将自动重置为容积上限。他现在可以选择两个操作来进行旅行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;走路，行走距离为 $d$ 时，需要消耗 $d$ 升水。清注意，任意时刻你拥有的水的数量不能为负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;跳跃，令 $v$ 为你当前拥有的水量，若 $v&amp;gt;0$，则你可以跳跃至任意一个绿洲，然后重置容积上界和所拥有的水量为 $v/2$ （四舍五入取整）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于每一个 $i$ 满足 $1\le i\le n$，你需要求当你在第 $i$ 个绿洲作为起点时，你能否依次遍历其他所有绿洲。如果可以，输出 &lt;code&gt;Possible&lt;/code&gt;，否则输出 &lt;code&gt;Impossible&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;$1\leq n,v\leq 2\times10^5$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神仙状态设计题orz&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#6433 [PKUSC2018]最大前缀和</title>
    <link href="https://www.orchidany.cn/2020/02/25/PKUSC2018%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://www.orchidany.cn/2020/02/25/PKUSC2018最大前缀和/</id>
    <published>2020-02-25T13:12:00.000Z</published>
    <updated>2020-02-26T01:03:43.238Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个长为 $n$ 的序列 $a_n$，求这个序列随机打乱后最大前缀和的期望值。</p><p> $n ≤ 20, |a_i | ≤ 10^9$</p></blockquote><p>一道让人更透彻地理解动态规划的好题orz</p><a id="more"></a><p>这是个神仙题…</p><p>考虑从这个 $dp$ 的本质入手。以下记 $\{a_m\}$ 表示长度为 $m$ 的序列 $a_1,a_2,\cdots a_m$ 。</p><p>首先，对于一个最大前缀和 $(p,\{s_n\})$ 表示的是 $s_1,s_2\cdots s_p$ 构成这个序列的最大前缀和，那么有两个性质：</p><p>1、对于 $\{s_n\}$ 的任意 $k&gt;p$ 的 $k\sim n$ 后缀，都有 $sum(k\sim n) \leq 0$ 。</p><p>2、对于 $\{s_p\}$ （即 $\{s_n\}$ 的 $1\sim p$ 前缀）的任意 $k&gt;1$ 的 $k\sim p$ 后缀，有 $sum(k\sim p)\geq 0$ 。</p><p>那么考虑枚举集合 $t$，表示这个集合的全部元素都用来贡献最大前缀和，记 $f_t$ 为满足条件2的排列方案数，$g_t$ 为满足条件1的方案数，那么考虑如何按秩转移。对于已经有的一个排列，考虑在序列最前端加一个数or在序列最后端加一个数，这样我们保证了按秩的同时，可以比较方便地讨论：</p><p>1、如果 $sum_t&lt;0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $g_{t\cup\{k\}}$ 贡献 $g_t$ 的方案数，也就是向序列后方添一个数。</p><p>2、如果 $sum_t\geq 0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $f_{t\cup\{k\}}$ 贡献 $f_{t}$ 的方案数，也就是向序列前端添一个数。</p><p>但是这个地方有个问题，就是如果最大的前缀和为负，他依然有贡献，但是没有统计。考虑一个贪心的性质如果最大前缀和为负，那么肯定最大前缀和只有第一个元素。所以一开始把所有只有一个元素的 $f$ 都置为 $1$ 即可。</p><p>这个地方有个很需要学习的地方，就是 <strong>刷表法在此处由于和dp的推法一致，也就是在模拟加入一个数的过程，所以刷表会比较自然，而朴素地填表就会出错</strong>。</p><p>嗯，拿小本本记下来了/kel</p><p>于是最后答案就是： </p><script type="math/tex; mode=display">\sum_{t⊆ m} sum_{\mathrm{t}}\cdot f_{\mathrm{t}}\cdot g_{\mathrm{m}-\mathrm{t}}</script><p>以下是向srz学习的dp方式，本质上也是在枚举 $&gt;0$ 后缀：</p><p>考虑另一种推 $f$ 的方式，考虑本质上 $f_t$ 计算的是有多少种方案使得 $sum_t$ 成为最大前缀和，那么就可以这么转移：</p><script type="math/tex; mode=display">f_t=|t|!-\sum_{s⊆t}f_s\cdot g_{t-s}</script><p>也就是枚举有多少种不合法的方案，通过子集转移。裸的转移是 $3^n$ 的，但观察到本质上是在做一个集合的对称差，于是可以用 $\rm FWT$ 优化到 $2^nn^2$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line">LL ans ;</span><br><span class="line">LL f[M] ;</span><br><span class="line">LL g[M] ;</span><br><span class="line">LL sum[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; g[<span class="number">0</span>] = <span class="number">1l</span>l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], sum[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sum[i] = (sum[low(i)] + sum[i ^ low(i)]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; j) &amp; i)) (f[i | (<span class="number">1</span> &lt;&lt; j)] += f[i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; i) (g[i] += g[(<span class="number">1</span> &lt;&lt; j) ^ i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        (ans += sum[i] * f[i] % P * g[m ^ i] % P) %= P ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (((ans % P) + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个长为 $n$ 的序列 $a_n$，求这个序列随机打乱后最大前缀和的期望值。&lt;/p&gt;
&lt;p&gt; $n ≤ 20, |a_i | ≤ 10^9$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道让人更透彻地理解动态规划的好题orz&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[ARC066F]Contest with Drinks(Hard)</title>
    <link href="https://www.orchidany.cn/2020/02/23/ARC066F/"/>
    <id>https://www.orchidany.cn/2020/02/23/ARC066F/</id>
    <published>2020-02-23T05:39:21.000Z</published>
    <updated>2020-02-26T00:35:13.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个点，选择第 $i$ 个点有 $a_i$ 的代价。如果一个极大的、长度为 $L$ 的区间内的点都被选了，这个区间会带来$\frac{L^2+L}{2}$ 的收益。</p><p>询问共 $q$ 组，为对 $a_i$ 的单点修改。 询问彼此独立。</p><p>形式化地讲，给定 $\{t_n\}$ ，求一组 $\{x_n\},\forall i \in[1, n], x_{i} \in[0,1]$ 使可以得到：</p><script type="math/tex; mode=display">\max \left\{\sum_{i=1}^{n} \sum_{j=i}^{n}\left(\prod_{k=i}^{j} x_{k}\right)-\sum_{i=1}^{n} x_{i} t_{i}\right\}</script><p>$n, q ≤ 3 × 10^5$</p></blockquote><p>一道神题…本质上虽然不是很难，但是碍于个人对斜率优化这个东西掌握的实在十分差劲，所以几乎把所有能踩的坑全踩了一遍。</p><a id="more"></a><h1 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm Sol$"></a>$\rm Sol$</h1><p>首先考虑对于每个询问，主要思想是维护一个前缀的 $f_i$ 表示不选 $i$ ，前 $i-1$ 个元素的最优解；$g_i$ 则是用来维护一个后缀，表示不选 $i$，$i+1\sim n$ 中元素的最优解。同时，再维护一个 $h_i$ 表示选了 $i$ 的全局最优解。那么这样就可以如此回答询问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是考虑这三个东西应该怎么转移。先考虑 $f$ :</p><script type="math/tex; mode=display">\begin{aligned}f_i&=\max\{f_j+\frac{(i-j)(i-j-1)}{2}-(s_i-s_j)\}\\f_i&=\max\{f_i,f_{i-1}\}\end{aligned}</script><p>枚举的是 $[j,i-1]$ 这段区间。</p><p>变形可得</p><script type="math/tex; mode=display">f_j+s_j+\frac{j^2+j}{2}=i\cdot j+f_i+s_i- \frac{i^2-i}{2}</script><p>于是就发现，这是一个以 $f_j+s_j+\frac{j^2+j}{2}$ 为纵坐标，$i$ 为斜率的斜率优化。观察可知，横坐标 $j$ 单增，同时斜率 $i$ 也单增。所以对于这种类型的 $dp$ 只能用<strong>单调栈</strong>来维护。</p><p>同时，关于 $g$，只需要倒着做一遍 $f$ 的 $dp$ 即可。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line"><span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>考虑关于于 $h$ 的转移，朴素的转移是 $O(n^3)$ 的，类似这样：</p><script type="math/tex; mode=display">h_i=\max_{x\leq i\leq y}\{f_x+\frac{(y-x+1)(y-x+2)}{2}-s_y+s_x+g_y\}</script><p>发现并不可以过。发现转移是一个区间的形式，于是考虑分治。但是这个分治有个 $bug$ ，就是不是很容易维护跨过 $mid$ 的信息。</p><p>但发现一个性质，对于 $[mid+1,r]$ 之间的所有 $h$ 值，左边的所有点仅仅是帮助其成为最优解，也就是左边对右边的点满足单调性。那么我们就可以用单调栈来维护上一个不选的（即维护 $x$）同时枚举最后选的（枚举 $y$），即用 $[l,mid]$ 的值去更新 $[mid+1,r]$；同理对于右半边我们也可以这么做。</p><p>具体的，以用 $[l,mid]$ 的值去更新 $[mid+1,r]$ 为例，在算左半边的决策集合的时候，不需要考虑 $g_y$ 的贡献，所以就是一个裸的斜率优化；之后转移就只需要弹栈转移即可。</p><p>发现在转移 $h$ 的时候，由于固定了其中一个端点，依然满足斜率优化，于是复杂度为 $\max\{n\log n, Q\}$。</p><p>以下是坑点：</p><p>1、注意如果按照上述方式来转移，两个转移常数有些微不同（但是这些不同很致命</p><p>2、注意因为一开始 $\{g_n\}$ 这个东西是按照 <code>reverse</code> 的前缀和来转移的，所以在分治的时候需要重新计算前缀和。</p><p>3、在分治的时候，斜率啊什么的变换频繁，所以如果想要推明白，可以在维护上凸壳的时候偷懒这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define tranl(b,a) g[a + 1] - s[a] + S[b] + F[b] + 1ll * ((a - b)*(a - b + 1)/ 2ll)</span><br><span class="line">#define tranr(b,a) f[a - 1] - s[a] + S[b] + G[b] + 1ll * ((b - a)*(b - a + 1)/ 2ll)</span><br></pre></td></tr></table></figure><p>然后每次比较就不需要斜率了，只需要 <code>while (top &gt; 1 &amp;&amp; tranl(stk[top], i) &lt;= tranr(stk[top - 1], i)) -- top</code> ;  虽然显然本质上没什么不同，但这样或许会简单很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL g[N] ;</span><br><span class="line">LL o[N] ;</span><br><span class="line">LL s[N] ;</span><br><span class="line">LL tmp[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y + <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y2(x) - <span class="number">1.0</span> * Y2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY2(x) - <span class="number">1.0</span> * YY2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> o[l] = max(o[l], f[l - <span class="number">1</span>] + g[r + <span class="number">1</span>] + <span class="number">1</span> - base[l]), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL ans ;</span><br><span class="line">    solve(l, mid) ; solve(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[l - <span class="number">1</span>] = s[r + <span class="number">1</span>] = <span class="number">0</span> ; t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[i] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>), s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span> ; i &lt;= mid ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = f[stk[t]] + calc(i, stk[t]) - s[i] + s[stk[t]] + g[i + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= mid + <span class="number">1</span> ; -- i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">    t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l ; -- i) s[i] = s[i + <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span> ; i &gt; mid ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid ; i &gt;= l ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = g[stk[t]] + calc(stk[t], i) - s[i] + s[stk[t]] + f[i - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= mid ; ++ i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"2.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"1.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    t = <span class="number">0</span> ; <span class="keyword">int</span> p, x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]),</span><br><span class="line">        o[i] = - (<span class="number">1l</span>l  &lt;&lt;  <span class="number">62</span>),</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br><span class="line">    g[<span class="number">0</span>] = g[n + <span class="number">1</span>], g[n + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; g[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    solve(<span class="number">1</span>, n) ; <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; o[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这题我从 <code>2020.2.22</code> 的晚上7点开始写，<del>中间看了两个小时C菌直播行尸走肉并且睡了一个小时</del>，本来写的很顺，后来发现一堆细节没考虑就开始自闭了，<del>感觉就是行尸走肉太带劲了思路断了</del>，$1$ 点垂死梦中惊坐起之后在黑黑的房间里 <code>debug</code> 到了早上4点，睡了3.5h之后起来发现只剩一个「 $g$ 当时是倒着求的」这么一个问题了，但不幸走了很多弯路，不过最终还是AC了…</p><p>其实有时候根本不知道自己为啥要这么做，这么做的意义似乎也不是很大，中途破坏了自己本来想早睡早起的计划、浪费了一场300iq出的比赛外加和老妈吵了一架。</p><p>但可能人生中没意义的事情还多的多，并且一件更比一件没意义，所以可能也不需要这么伤心。</p><p>安啦安啦，还要继续走下去啊。</p><p><img src="1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个点，选择第 $i$ 个点有 $a_i$ 的代价。如果一个极大的、长度为 $L$ 的区间内的点都被选了，这个区间会带来$\frac{L^2+L}{2}$ 的收益。&lt;/p&gt;
&lt;p&gt;询问共 $q$ 组，为对 $a_i$ 的单点修改。 询问彼此独立。&lt;/p&gt;
&lt;p&gt;形式化地讲，给定 $\{t_n\}$ ，求一组 $\{x_n\},\forall i \in[1, n], x_{i} \in[0,1]$ 使可以得到：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\max \left\{\sum_{i=1}^{n} \sum_{j=i}^{n}\left(\prod_{k=i}^{j} x_{k}\right)-\sum_{i=1}^{n} x_{i} t_{i}\right\}&lt;/script&gt;&lt;p&gt;$n, q ≤ 3 × 10^5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道神题…本质上虽然不是很难，但是碍于个人对斜率优化这个东西掌握的实在十分差劲，所以几乎把所有能踩的坑全踩了一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
      <category term="分治" scheme="https://www.orchidany.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【泛学笔记】动态规划杂项</title>
    <link href="https://www.orchidany.cn/2020/02/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.orchidany.cn/2020/02/22/动态规划杂项/</id>
    <published>2020-02-22T00:09:33.000Z</published>
    <updated>2020-03-01T23:14:43.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是听课笔记，但后来发现没啥可听的就变成了做题笔记(?)</p><a id="more"></a><h1 id="单调队列部分"><a href="#单调队列部分" class="headerlink" title="单调队列部分"></a>单调队列部分</h1><p>单调队列主要用来优化，对于状态 $\rm S$ 的某个后继状态 $\rm S’$，如果 $\rm S’$ 比 $\rm S$ 更优就可以舍弃掉 $\rm S$ 的转移。通常表现形式为会有限制，比如</p><script type="math/tex; mode=display">f_{i}=\max\{f_j\}+w_i \quad(j\in[L_i,i-1]\cap\mathbb Z)</script><p>其中 $\{L\}$ 是一个给定常数，且 $\forall i, L_i\geq L_{i-1}$ 。那么可知对于后续状态 $s_i$ ，他的可转移范围一定更大，至少比 $s_j$ 大，所以可以删除 $s_j$.</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知 $L_i$ 不降，于是就对每个 $d$ 用单调队列即可。</p><h1 id="斜率优化部分"><a href="#斜率优化部分" class="headerlink" title="斜率优化部分"></a>斜率优化部分</h1><p>这部分虽然简单但是不熟，所以可能需要多做点题。</p><h2 id="傻狗题"><a href="#傻狗题" class="headerlink" title="傻狗题"></a>傻狗题</h2><blockquote><p>把一个长为 $n$ 的正整数序列划分成若干段，每一段的代价是内部元素和的平方加上一个定值 $m$。求划分整个序列的最小代价。</p></blockquote><p>可知转移</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_i-s_j)^2\}+m</script><script type="math/tex; mode=display">f_j+s_j^2=2s_is_j+f_i-s_i^2-m</script><p>于是就变成了有一个以 $s_i$ 为斜率，$f_j+s_j^2$ 为纵坐标，$s_i$ 为横坐标的斜率优化。考虑横坐标和斜率都是单调的，就可以直接队尾删/队尾插入。</p><h2 id="USACO08MAR-Land-Acquisition"><a href="#USACO08MAR-Land-Acquisition" class="headerlink" title="[USACO08MAR]Land Acquisition"></a>[USACO08MAR]Land Acquisition</h2><blockquote><p>有 $n$ 块长方形的土地需要购买，你每次可以选择一组土地一起购买，价 格为这些土地中最大的长乘以最大的宽。求购买所有土地的最小费用。 </p><p>$n ≤ 50000$</p></blockquote><p>考虑先排序，然后考虑如果直接 $dp$，那么本身需要枚举 $i\sim j$ 之间的元素取 $\max$，这样显然复杂度就多了一维 $n$。仔细思考后发现，如果对于一组 $(i,j)$，满足 $w_i\geq w_j$ 且 $h_i\geq j_j$ ，那么就可以删掉 $j$ 。具体的，考虑按照 $h$ 排序之后，用一个单调栈来维护这个东西。</p><p>那么这样最后剩下的一定满足 $w$ 单调。所以就会得到类似</p><script type="math/tex; mode=display">f_i=\min\{f_{j}+h_{j+1}\cdot w_i\}\\f_j=-h_{j+1}\cdot w_i+f_i</script><p>那么令 $h_{j+1}$ 作为横坐标，横坐标单调；$w_i$ 作为斜率，斜率单调。于是就变成了最 <code>general</code> 的斜率优化问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">LL f[N] ;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grid</span>&#123;</span></span><br><span class="line">    LL x, y ;</span><br><span class="line">&#125;base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(grid a, grid b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &gt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!top || t[top].y &lt; base[i].y) t[++ top] = base[i] ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= 50 ; ++ i) cout &lt;&lt; t[i].x &lt;&lt; " " &lt;&lt; t[i].y &lt;&lt; endl ;</span></span><br><span class="line">    n = top ; q.push_back(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.front() ; q.pop_front() ; o = q.front() ;</span><br><span class="line">            <span class="keyword">if</span> (f[p] - f[o] &lt;= t[i].y * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_front(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         f[i] = f[q.front()] + t[q.front() + <span class="number">1</span>].x * t[i].y ;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.back() ; q.pop_back() ; o = q.back() ;</span><br><span class="line">            <span class="keyword">if</span> ((f[p] - f[o]) * (t[p + <span class="number">1</span>].x - t[i + <span class="number">1</span>].x) &lt;= (f[i] - f[p]) * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_back(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         q.push_back(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BTW，如何推凸包的维护方式，可以考虑是维护下凸壳还是上凸壳，但是似乎又一种方式更简便：</p><p>令 $0\leq k&lt;j&lt;i$ ，那么如果 $j$ 比 $k$ 好，那么需要满足</p><script type="math/tex; mode=display">\begin{aligned}f_{j}+w_{j+1} \times l_{i} & \leq f_{k}+w_{k+1} \times l_{i} \\f_{j}-f_{k} & \leq l_{i} \times\left(w_{k+1}-w_{j+1}\right)\\l_{i} &\geq \frac{f_{j}-f_{k}}{w_{k+1}-w_{j+1}}\end{aligned}</script><p>这么做就会比较直观？</p><p>值得注意的是，斜率优化的时候很可能会因为移项的时候符号变错了而GG。</p><p>还有，似乎如果斜率和横坐标的单调方式相同，那么就可以用单调栈替换掉单调队列。虽然…没啥用233</p><h1 id="期望相关"><a href="#期望相关" class="headerlink" title="期望相关"></a>期望相关</h1><h2 id="Red-is-Good"><a href="#Red-is-Good" class="headerlink" title="Red is Good"></a>Red is Good</h2><blockquote><p>$n$ 张红牌，$m$ 张黑牌随机打乱顺序放在桌面上，你可以翻牌，翻到红色则得到 $1$ 元，黑色则失去 $1$ 元。求在最优策略下平均能得到多少钱。</p><p>$n,m\leq 5000$</p></blockquote><p>考虑如何设状态为 “已经xxx了”，不是很容易转移。于是考虑令 $f_{i,j}$ 为剩下 $i$ 张红的，$j$ 张黑的时的最大值。注意到由于是最优决策，所以有</p><script type="math/tex; mode=display">f_{i,j}=\max\{0,\frac{i}{i+j}(f_{i-1,j}+1)+\frac{j}{i+j}(f_{i,j-1}-1)\}</script><h2 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="[HNOI2015]亚瑟王"></a>[HNOI2015]亚瑟王</h2><blockquote><p>有 $n$ 张卡牌，玩 $r$ 轮游戏。每轮游戏从左向右轮流考虑每张没有发动过的卡牌，考虑到第 $i$ 张卡时，它有 $p_i$ 的概率发动并产生 $d_i$ 的贡献， 然后本轮立即结束并进入下一轮。若没有卡牌发动则直接进入下一轮。 $T$ 组数据，求期望贡献。</p><p>$T\leq 500, n\leq 300,r\leq 200$</p></blockquote><p>考虑分别计算出每张卡牌的发动概率，然后分别乘上每张卡牌的权值得到答案。</p><p>具体的，令 $f_{i,j}$ 表示当前只在考虑第 $i$ 张牌，还剩 $j$ 次游戏没有开始的概率。考虑转移：</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j+1}\cdot(1-(1-p_{i-1})^{j+1})+f_{i-1,j}\cdot(1-p_{i-1})^j</script><p>其实就是在计算牌 $i-1$ 是否被发动了，前半部分计算了第 $i$ 张牌在之后的 $j$ 次以及当前这一次中任意一次发动成功的概率，所以是 $1-一次也没发动成功的概率$；后半部分以此类推。注意，此处忽略了题目中「直接结束本轮」的约束。本质上，$f$ 保证了还有 $j$ 轮时，前 $i$ 张卡牌不会被选。</p><p>那么考虑如何计算第 $i$ 张牌是否发动了的概率：</p><script type="math/tex; mode=display">P_i=\sum_{j=1}^rf_{i,j}\cdot (1-(1-p_i)^j)</script><p>之后用线性性算一下就好了。复杂度 $O(nTr)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n, r ;</span><br><span class="line"><span class="keyword">double</span> ans ;</span><br><span class="line"><span class="keyword">double</span> d[N] ;</span><br><span class="line"><span class="keyword">double</span> p[N] ;</span><br><span class="line"><span class="keyword">double</span> f[N][N] ;</span><br><span class="line"><span class="keyword">double</span> xs[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r ; <span class="keyword">double</span> res ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;d[i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = xs[i][j] = <span class="number">0</span> ;</span><br><span class="line">        f[<span class="number">0</span>][r] = <span class="number">1</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            res = <span class="number">1.0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                xs[i][j] = res, res *= (<span class="number">1.0</span> - p[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = r ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (<span class="number">1.0</span> - xs[i - <span class="number">1</span>][j + <span class="number">1</span>]) + f[i - <span class="number">1</span>][j] * xs[i - <span class="number">1</span>][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                ans += d[i] * f[i][j] * (<span class="number">1.0</span> - xs[i][j]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实就是听课笔记，但后来发现没啥可听的就变成了做题笔记(?)&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
