<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>Love is a touch but yet not a touch</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orchidany.cf/"/>
  <updated>2019-03-20T08:36:32.000Z</updated>
  <id>http://www.orchidany.cf/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想·目次表</title>
    <link href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>http://www.orchidany.cf/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-03-20T08:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><p>换了新的博客，把之前博客园里的三篇搬了下来。</p><p>每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。</p><p>时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。</p><p>读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。</p><p>读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。</p><p>是的，我是花，一个不理智的$Oier$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-xdpxyweF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xdpxyweF"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 杨柳岸晓风残月</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人今安否？</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/01/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/">$Link$</a></td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">$\rm{empty}$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$\rm{empty}$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$\rm{empty}$</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>主席树上的不靠谱解法</title>
    <link href="http://www.orchidany.cf/2019/04/05/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E4%B8%8A%E4%BA%8C%E5%88%86/"/>
    <id>http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/</id>
    <published>2019-04-05T12:56:38.000Z</published>
    <updated>2019-04-05T13:38:25.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x00-Preface"><a href="#rm-0x00-Preface" class="headerlink" title="$\rm{0x00~}Preface$"></a>$\rm{0x00~}Preface$</h1><p>某天机房里，<del>公认的ezi</del> lwy跟wxl随口说了一道luogu上的题，wxl来了兴趣，被pks听见了，于是pks就瞅了一眼这题，然后说了一句”这不就是sb主席树上二分吗？随便一个$\Theta(n \log^2n)$就可以过啊”</p><p>然后pks那一整个晚上都在搞这个假算法，$\rm{QAQ}$</p><p>于是就有了本文，整理了两道主席树的正确（？）应用。</p><h1 id="rm-0x01-faebdc的烦恼"><a href="#rm-0x01-faebdc的烦恼" class="headerlink" title="$\rm{0x01~}$faebdc的烦恼"></a>$\rm{0x01~}$faebdc的烦恼</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P1997" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1997</a></p><p>呃，其实这不是一道很难的题。因为本来就保证了数列不降，所以我们直接记录一下每个数出现区间的左右端点，瞎搞就好。但是既然我说了要主席树上二分，就一定要写写看吧qaq</p><p>我们考虑在我的<a href="">这篇博客</a>里面曾经介绍过的$T3$中的算法，我们直接去查询左右儿子值域区间内中数的个数，看看哪个可行，然后暴力找就好。</p><p>但是…他TLE了两个点，因为我是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; </span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (sum[Right] - sum[Left] &lt; k) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>),Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>), </span><br><span class="line">  T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++) </span><br><span class="line">      pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, </span><br><span class="line">  T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid) &gt; <span class="number">0</span>) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像很正常？但是，这个复杂度是完全错误的。最大的时候甚至可以到达单次$m \log n$的复杂度——注意是单次。因为我们每次询问的时候，如果查询了左区间不合法，那么不代表右区间合法——毕竟是二分里的<code>check</code>环节。而上一个类似方法的题，可以保证我们如果左区间的数的出现次数不超过$\frac{1}{2}$，那么右区间一定满足——但显然的是，本题不具有这个性质。</p><p>所以，总结一下，主席树上不可以二分。</p><p>但是如果我们加一点剪枝呢？</p><p>我们考虑，对于主席树上的每一个点维护一个$maxx$一个$minx$，记录区间内<strong>单个数值出现的最大次数和最小次数</strong>，那么我们在$check$的时候就可以直接用这种方式判——如果$r$版本的主席树内出现的最大次数减去$l-1$版本内出现的数的最小次数$k&lt;q$（$q$是二分出的$val$），那么一定不满足。</p><p>比较显然的是，这不是一种最优性剪枝，而是一种可行性剪枝。但是对付这道题却有着不错的效果，跑的奇快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD 393216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100073</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> a, b, c, pos, N, base[MAXN], mx[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], mn[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], aft[MAXN], M, i ;</span><br><span class="line"><span class="keyword">int</span> cnt, Len, T[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], L[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], R[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], sum[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ; &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;last, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> rt = ++ cnt, mid ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span>, R[rt] = R[last], L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">    mx[rt] = mn[rt] = sum[rt] ; </span><br><span class="line">        <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">    <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    mn[rt] = min(mn[L[rt]], mn[R[rt]]), mx[rt] = max(mx[L[rt]], mx[R[rt]]) ;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">1</span> ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (mx[L[Right]] - mn[L[Left]] &gt;= k &amp;&amp; query(L[Left], L[Right], l, mid, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mx[R[Right]] - mn[R[Left]] &gt;= k &amp;&amp; query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M; <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>), Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        a = qr(), b = qr() ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, mid, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid)) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-0x02-CF840D-Destiny"><a href="#rm-0x02-CF840D-Destiny" class="headerlink" title="$\rm{0x02~}CF840D~Destiny$"></a>$\rm{0x02~}CF840D~Destiny$</h2><p>传送门：<a href="http://codeforces.com/problemset/problem/840/D" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/840/D</a></p><p>简化版题意：每次给出三个参数$l,r,k$，询问区间$[l,r]$内是否存在出现次数严格大于$\frac{r-l+1}{k}$的数。如果存在就输出最小的那个$ans$，否则输出$-1$.</p><p>这个东西……就直接查询就好了啊……由于不用二分，所以复杂度相对来说稳定了一些。于是我就没有加上文中提到过的那个诡异的优化。我们每次先查左半边，就可以保证在值域上最小，也就是说每次我们都可以求出最小的合法$ans$了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        L[rt] = build(l, mid) ;</span><br><span class="line">        R[rt] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    R[rt] = R[last] ;</span><br><span class="line">    L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">        <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; <span class="keyword">int</span> qwq ;</span><br><span class="line">    <span class="comment">// if (sum[Right] - sum[Left] &lt;= k) return -1 ;</span></span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) </span><br><span class="line"><span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; k) </span><br><span class="line"><span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) base[i] = qr(), aft[i] = base[i] ;</span><br><span class="line">    sort(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) ;</span><br><span class="line">    Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ; </span><br><span class="line">    T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft;</span><br><span class="line">        T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c) ; <span class="keyword">int</span> k = (b - a + <span class="number">1</span>) / c ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, k) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，加上那优化之后，总用时大约$27000ms$，而我这个不加优化的版本足足跑了$56677ms$……真丢人啊</p>]]></content>
    
    <summary type="html">
    
      yy出来的假复杂度做法，但是据说有一个很强的剪枝？
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="可持久化/可持久化线段树" scheme="http://www.orchidany.cf/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>可持久化数据结构1·主席树杂谈</title>
    <link href="http://www.orchidany.cf/2019/04/05/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%9D%82%E8%B0%88/"/>
    <id>http://www.orchidany.cf/2019/04/05/可持久化数据结构·主席树杂谈/</id>
    <published>2019-04-05T12:04:07.000Z</published>
    <updated>2019-04-05T12:55:36.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x01-主席树"><a href="#rm-0x01-主席树" class="headerlink" title="$\rm{0x01}$ 主席树"></a>$\rm{0x01}$ 主席树</h1><p>好久之前学的了……最近拿出来发现当时的理解最多算是一个”浅尝辄止”，于是决定重新整理一遍。</p><p>其实主席树的真名叫做<strong>函数式线段树</strong>，其实我更喜欢叫他<strong>“前缀和式线段树”</strong>，通过两个历史版本的”相减”来实现查询中间过程的线段树。</p><p>其思想大概就是，假设我每次要对一段区间$[l,r]$查询一些不可以快速维护的东西，那么我们可以考虑对于每个节点维护一棵线段树，每次用前缀和一样的方式减出中间的区间，然后对那些节点进行一些操作。</p><p>看上去我们需要$n^2$的空间开销，但事实上我们每多一个节点，最多会在权值线段树上多出树高个节点，即$\log N$个节点。所以我们每次就只需要多新建$\log N$个节点就好，最终的空间开销$M \log N$可以接受。</p><p>emmm怎么说呢，这个地方需要注意的是我们不能被模板题误导，或者说，我们要记住主席树的真正作用(可能有些狭隘)是”扣区间”而不只是某谷模板里的”找第K大”。怎么说呢，似乎水平高的选手不会被误导，但是我当时被这个误导了好久……phhh</p><p>那么首先就是某谷上的模板了，当做复习省选知识点的题，便重写了一遍原来的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;  <span class="keyword">int</span> pos, tot ;</span><br><span class="line"><span class="keyword">int</span> N, M, Len, i, l, r, k, base[MAXN], t[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> T[MAXN], Cnt[MAXN &lt;&lt; <span class="number">4</span>], L[MAXN &lt;&lt; <span class="number">4</span>], R[MAXN &lt;&lt; <span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> bl, <span class="keyword">int</span> br)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ tot, mid = (bl + br) &gt;&gt; <span class="number">1</span> ; <span class="keyword">if</span> (bl == br) <span class="keyword">return</span> now ; </span><br><span class="line">    L[now] = build(bl, mid), R[now] = build(mid + <span class="number">1</span>, br) ; <span class="keyword">return</span> now ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> Last, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ tot, mid = (il + ir) &gt;&gt; <span class="number">1</span> ; Cnt[now] = Cnt[Last] + <span class="number">1</span>, L[now] = L[Last], R[now] = R[Last] ;</span><br><span class="line">    <span class="keyword">if</span> (il == ir) <span class="keyword">return</span> now ; <span class="keyword">if</span> (p &lt;= mid) L[now] = Insert(L[Last], il, mid, p) ; <span class="keyword">else</span> R[now] = Insert(R[Last], mid + <span class="number">1</span>, ir, p) ;</span><br><span class="line">    <span class="keyword">return</span> now ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Last, <span class="keyword">int</span> Now, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> rk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql == qr) <span class="keyword">return</span> ql ; <span class="keyword">int</span> mid = (ql + qr) &gt;&gt; <span class="number">1</span>, now_cnt = Cnt[L[Now]] - Cnt[L[Last]] ;</span><br><span class="line">    <span class="keyword">if</span> (rk &lt;= now_cnt) <span class="keyword">return</span> query(L[Last], L[Now], ql, mid, rk) ; <span class="keyword">else</span> <span class="keyword">return</span> query(R[Last], R[Now], mid + <span class="number">1</span>, qr, rk - now_cnt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Len &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Len ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + Len + <span class="number">1</span>) ; N = unique(t + <span class="number">1</span>, t + Len + <span class="number">1</span>) - t - <span class="number">1</span>, T[<span class="number">0</span>] = build(<span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Len ; ++ i) pos = lower_bound(t + <span class="number">1</span>, t + N + <span class="number">1</span>, base[i]) - t, T[i] = Insert(T[i - <span class="number">1</span>], <span class="number">1</span>, N, pos) ;</span><br><span class="line">    <span class="keyword">while</span> (M -- ) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[query(T[l - <span class="number">1</span>], T[r], <span class="number">1</span>, N, k)] ) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢，总感觉自己学习模板的时候思想僵化，十分的木头……唉……</p><p>注意几点吧：</p><ul><li>询问的时候，两个细节：1. 平衡树板板里的查询rk可以说是很经典了，注意下即可。2.注意我们的<code>now_cnt</code>是用来找子树的，所以应该是选左儿子的信息。</li><li>最后输出结果的时候输出$t$，因为我们的$t$是个有序数组，且我们的主席树是建立在<strong>名次树</strong>上的。</li></ul><h1 id="rm-0x02-一些小应用"><a href="#rm-0x02-一些小应用" class="headerlink" title="$\rm{0x02}$ 一些小应用"></a>$\rm{0x02}$ 一些小应用</h1><h2 id="1-可持久化数组"><a href="#1-可持久化数组" class="headerlink" title="$1.~$ 可持久化数组"></a>$1.~$ 可持久化数组</h2><p>其实吧，这个玩意儿似乎不属于”主席树”？大概是只有建立在权值上的线段树，可持久化之后才被叫做“主席树”吧。$However$，我依旧把这个归到了这俩玩意儿里面。</p><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3919" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3919</a></p><p>我做这个题的时候，思维极其呆滞，甚至不知道该怎么去搞普通序列上的线段树了……</p><p>首先，这个题对于权值的要求没有到一定的高度，即不用去确定权值间的大小关系，所以权值线段树会显得很蹩脚。于是我们考虑直接对这个序列建线段树，细节注意处理一下就好了……对了，我感觉这似乎就是一个优雅的暴力啊qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> MK, a, b, c, pos, N, base[MAXN], aft[MAXN], M, i ;</span><br><span class="line"><span class="keyword">int</span> cnt, Len, T[MAXN], L[MAXN &lt;&lt; <span class="number">4</span>], R[MAXN &lt;&lt; <span class="number">4</span>], sum[MAXN &lt;&lt; <span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;  &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt, mid ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123; sum[rt] = base[l] ; <span class="keyword">return</span> rt ; &#125;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span>, L[rt] = build(l, mid), R[rt] = build(mid + <span class="number">1</span>, r) ; <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt, mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    sum[rt] = sum[last], R[rt] = R[last], L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) L[rt] = update(L[last], l, mid, p, x) ;</span><br><span class="line">        <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, p, x) ;</span><br><span class="line">    <span class="keyword">else</span> sum[rt] = x ;  <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> sum[u] ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= k) <span class="keyword">return</span> query(L[u], l, mid, k) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(R[u], mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line">T[<span class="number">0</span>] = build(<span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    a = qr(), MK = qr() ;</span><br><span class="line">    <span class="keyword">if</span> (MK &gt;= <span class="number">2</span>) b = qr(), T[i] = T[a], <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(T[a], <span class="number">1</span>, N, b)) ;</span><br><span class="line">    <span class="keyword">else</span> b = qr(), c = qr(), T[i] = update(T[a], <span class="number">1</span>, N, b, c) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-POI2014-KUR-Couriers"><a href="#2-POI2014-KUR-Couriers" class="headerlink" title="$2.~$[POI2014]KUR-Couriers"></a>$2.~$[POI2014]KUR-Couriers</h2><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3567" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3567</a></p><p>也是好久之前写的题了，今天拿出来重写一下233。一句话题意：给一个数列，每次询问一个区间内有没有一个数出现次数超过一半 。</p><p>那我们考虑主席树。主席树本质上是一棵权值线段树，每个节点记录值域区间内数出现的次数。那我们只需要建一棵主席树，然后对于每次询问，不断查找左右子树的数的出现次数，舍弃掉区间内所有数的个数加起来不足一半的，然后继续递归即可。</p><p>那么只需要改一改<code>query</code>函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> ((x &lt;&lt; <span class="number">1</span>) &gt; k) <span class="keyword">return</span> query(L[Left], L[Right], l, mid, k) ;</span><br><span class="line">    <span class="keyword">if</span>((y &lt;&lt; <span class="number">1</span>) &gt; k) <span class="keyword">return</span> query(R[Left], R[Right], mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      主要是记录一下主席树的应用
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="可持久化/可持久化线段树" scheme="http://www.orchidany.cf/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>防守战线[ZJOI2013] &amp; 志愿者招募[NOI2008]</title>
    <link href="http://www.orchidany.cf/2019/04/05/fszx-and-zyzzm/"/>
    <id>http://www.orchidany.cf/2019/04/05/fszx-and-zyzzm/</id>
    <published>2019-04-05T09:28:46.000Z</published>
    <updated>2019-04-05T10:35:09.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x01-ZJOI2013-防守阵线"><a href="#rm-0x01-ZJOI2013-防守阵线" class="headerlink" title="$\rm{0x01}$ [ZJOI2013]防守阵线"></a>$\rm{0x01}$ [ZJOI2013]防守阵线</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3337" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3337</a></p><p>首先就是要明白怎么建模，大概就是：</p><p>$$<br>\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots n)\\\<br>\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} x_{j} \geq d_i \quad (i = 1,2,3\cdots m)<br>$$</p><p>其中$x_j$表示$j$这个地方有几座塔。</p><p>那我们首先把它对偶过去，就会得到：<br>$$<br>\text{最大化} \quad \sum d_iy_i \quad(i = 1, 2,3 \cdots m) \\\<br>\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} y_{j} \leq c_i\quad (i = 1,2,3\cdots n)<br>$$<br>然后我们考虑，似乎价值不能带小数啊，毕竟题目中规定了价值都为整数<del>(事实上并没有规定但是数据是这样给的)</del>，换句话说我们不能存在建某座塔的一部分(比如只建一半)。</p><p>那么这就是<strong>整数线性规划问题</strong>，换句话说就是<strong>自变量取值范围是$\Z$的线性规划</strong>。</p><p>呃，这问题已经被证明是$\rm{NP-Hard}$的问题了…但是，有一种矩阵叫做<strong>全幺模矩阵</strong>，即<strong>元素只会是$\boldsymbol{0,1,-1}$的矩阵</strong>，被证明肯定至少有一组最优解保证整数线性规划与实数线性规划的方案一致。</p><p><del>啥，你说啥？你要关于全幺模矩阵这个性质的争鸣？是百家争鸣那个争鸣吗？学OI呢别瞎讨论历史</del> </p><p>然后就可以一发单纯形给艹过去啦~开心心~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e9</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">double</span> A[MAXN][MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M, B, E, i, j, k, p ; <span class="keyword">double</span> res, t, cost[MAXM], _need[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">cost[l] /= A[l][e], t = A[l][e], A[l][e] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) A[l][i] /= t ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i != l &amp;&amp; <span class="built_in">abs</span>(A[i][e]) &gt; eps)&#123;</span><br><span class="line">cost[i] -= A[i][e] * cost[l] ;  </span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">1</span> ; p &lt;= M ; ++ p) <span class="keyword">if</span> (p != e) A[i][p] -= A[i][e] * A[l][p] ;</span><br><span class="line">A[i][e] = - A[i][e] * A[l][e] ;</span><br><span class="line">&#125; </span><br><span class="line">res += _need[e] * cost[l] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) _need[i] -= _need[e] * A[l][i] ;</span><br><span class="line">_need[e] = - _need[e] * A[l][e] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> MINX = INF ; j = <span class="number">0</span>, k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="keyword">if</span> (j &gt; M) <span class="keyword">return</span> res ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MINX &gt; cost[i] / A[i][j]) k = i, MINX = cost[i] / A[i][j] ;</span><br><span class="line"><span class="keyword">if</span> (MINX &gt;= INF) <span class="keyword">return</span> INF ;  Pivot(j, k) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cost[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;B, &amp;E, &amp;_need[i]) ; <span class="comment">//约束 </span></span><br><span class="line"><span class="keyword">for</span> (j = B ; j &lt;= E ; ++ j) A[j][i] = <span class="number">1.0</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex() + <span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢，似乎单纯形有好多地方的写法都比较灵活<del>让我不知道背什么样的板子会更好</del></p><h1 id="rm-0x02-NOI2008-志愿者招募"><a href="#rm-0x02-NOI2008-志愿者招募" class="headerlink" title="$\rm{0x02}$ [NOI2008] 志愿者招募"></a>$\rm{0x02}$ [NOI2008] 志愿者招募</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3980</a></p><p><del>什么鬼啊这不是上面的那道题吗</del></p><p>还是：<br>$$<br>\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots m)\\\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \geq A_i \quad (i = 1,2,3\cdots n)<br>$$<br>其中$x_j$表示选择的第$j$类志愿者的个数，$w_{i,j}$表示在第$i$天，第$j$类志愿者能否选择。那么还是老样子，对偶过去就可以得到：<br>$$<br>\text{最大化} \quad \sum A_ix_i \quad(i = 1,2,3\cdots n)\\\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \leq c_i \quad (i = 1,2,3\cdots m)<br>$$<br>怎么说呢……这个一开始的建模比上一个题还是有难度的，因为上一个题的$L_i,R_i$跟约束有关，而这次的$L_i,R_i$则是跟目标函数有关——或许不应该这么说，但是看上去确实不如上面那题跟约束有关系就对了<del>(我在BB一堆什么啊)</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span> ; <span class="keyword">double</span> res ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> b[MAXM], e[MAXM] ; </span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k ; <span class="keyword">double</span> C[MAXM], _need[MAXM], A[MAXM][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> posN, <span class="keyword">int</span> posC)</span></span>&#123;</span><br><span class="line">C[posC] /= A[posC][posN] ; <span class="comment">// constraint divided by A_&#123;l,e&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) A[posC][p] /= A[posC][posN] ;<span class="comment">//this line Booom</span></span><br><span class="line">A[posC][posN] = <span class="number">1</span> ;</span><br><span class="line"><span class="comment">// Pivot is above, taking it back is below</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= M ; ++ p)<span class="comment">//taking back to constraints </span></span><br><span class="line"><span class="keyword">if</span> (p != posC &amp;&amp; <span class="built_in">fabs</span>(A[p][posN]) &gt; eps)&#123;</span><br><span class="line">C[p] -= A[p][posN] * C[posC] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (i != posN) A[p][i] -= A[p][posN] * A[posC][i] ;</span><br><span class="line">A[p][posN] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">res += _need[posN] * C[posC] ;<span class="comment">//this time results in a better INIT-Sol</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) _need[p] -= _need[posN] * A[posC][p] ;</span><br><span class="line">_need[posN] = - _need[posN] * A[posC][posN] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">j = <span class="number">0</span>, k = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="comment">/*1*/</span> <span class="keyword">if</span> (j &gt; N) <span class="keyword">return</span> res ; <span class="comment">//make-it-sure if go on</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MAX &gt; C[i] / A[i][j]) MAX = C[i] / A[i][j], k = i ; <span class="comment">//find the min_val constraint</span></span><br><span class="line"><span class="keyword">if</span> (MAX &gt;= INF) <span class="keyword">return</span> INF ; <span class="comment">/* this task is unbounded */</span> Pivot(j, k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; _need[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;b[i], &amp;e[i], &amp;C[i]) ;</span><br><span class="line"><span class="keyword">for</span> (j = b[i] ; j &lt;= e[i] ; ++ j) A[i][j] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex()+<span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$Candy?$的$blog$ <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul>]]></content>
    
    <summary type="html">
    
      【[ZJOI2013]防守阵线】：战线可以看作一个长度为$n$的序列，现在需要在这个序列上建塔来防守敌兵，在序列第$i$号位置上建一座塔有$C_i$的花费，且一个位置可以建任意多的塔，费用累加计算。有$m$个区间$[L1,R1],[L2,R2],\cdots,[L_m,R_m]$，在第$i$个区间的范围内要建至少$D_i$座塔。求最少花费。
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线性规划/单纯形法" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划/对偶定理" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nw flow 24(1)</title>
    <link href="http://www.orchidany.cf/2019/03/29/nw-flow-24-1/"/>
    <id>http://www.orchidany.cf/2019/03/29/nw-flow-24-1/</id>
    <published>2019-03-29T13:43:58.000Z</published>
    <updated>2019-04-05T14:48:09.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-Preface"><a href="#rm-Preface" class="headerlink" title="$\rm{Preface}~$"></a>$\rm{Preface}~$</h1><p>关于网络流，一直是我的一个阴影……因为去年暑假，大家都会而网络流，我因为觉得这个算法没意思就没学，结果rqy来给我们考试网络流那题被全场打爆了——除了我qaq。</p><p>于是决定开始做这些题，每道题都会标注我看题解程度多少，如果太高的话会被自己嫌弃的qaq……希望自己能争气一点。</p><h1 id="rm-0x01-运输问题"><a href="#rm-0x01-运输问题" class="headerlink" title="$\rm{0x01}$ 运输问题"></a>$\rm{0x01}$ 运输问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4015" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4015</a></p><p>看了，程度大概80%……呃我知道这个题不难，但是毕竟我上次写费用流可是几百年之前了啊……qaq</p><p>其实就是<br>$$<br>S\stackrel{f = a_i,c = 0}{\longrightarrow}i \stackrel{f = Inf,c = c_{i,j}}{\longrightarrow}j \stackrel{f = b_j,c=0}{\longrightarrow}T<br>$$</p><p>其中$i$代表仓库的编号，$j$代表商店的编号，建完图跑费用流即可。</p><p>由于SPFA死了，所以就一直用$dijk$做费用流，只不过难背一点……然后第二问的话就把权值取负重新做一下费用流就好。</p><p>总结一下，这个题似乎是比较裸的费用流的题了？一般费用流大概都是用来求解最优化问题的吧qwq……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> S, T, N, M, dist[MAXN], i, j, k, t[MAXN], x ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> dist, num ;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> Last[MAXN], F[MAXN], H[MAXN], Pre[MAXN], MAX_C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].c = c, t[cnt] = f ;</span><br><span class="line">E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].c = -c, t[cnt] = <span class="number">0</span> ;</span><br><span class="line">E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; vis[S] = dist[S] = <span class="number">0</span>, F[<span class="number">0</span>] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i) dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">node now = q.top() ; q.pop() ;</span><br><span class="line"><span class="keyword">int</span> fr = now.num, sec = now.dist ; <span class="keyword">if</span> (vis[fr]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">for</span> (vis[fr] = <span class="number">1</span>, k = head[fr] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">int</span> nowc = sec + E[k].c + H[fr] - H[to(k)] ;</span><br><span class="line"><span class="keyword">if</span> (E[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[to(k)] &amp;&amp; dist[to(k)] &gt; nowc)&#123;</span><br><span class="line">dist[to(k)] = nowc, q.push((node)&#123;dist[to(k)], to(k)&#125;) ;</span><br><span class="line">F[to(k)] = min(F[fr], E[k].f), Pre[to(k)] = fr, Last[to(k)] = k ; </span><br><span class="line">&#125;<span class="comment">//!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span>(_Ed != S)E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, S = <span class="number">0</span> ; </span><br><span class="line">T = N + M + <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(S, i, x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, T, x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + M ; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, j, Inf, x) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= cnt ; ++ i) printf("%d %d %d\n", E[i].to + 1, E[i].f, E[i].c) ;</span></span><br><span class="line">MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i], E[i].c = -E[i].c ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x02-分配问题"><a href="#rm-0x02-分配问题" class="headerlink" title="$\rm{0x02~}$ 分配问题"></a>$\rm{0x02~}$ 分配问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4014" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4014</a></p><p>这道题由于实在太水了，所以没有看题解(窃喜</p><p>其实就是建$2n$个点，然后$i \stackrel{f = Inf,c = base_{i,j}}{\longrightarrow} j$就连完了。</p><p>不得不说…建边真的是太水了，太水了，qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">此处是dijkstra……</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span>(_Ed != S)E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + N ; ++ i) Add(i, T, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + N ; ++ j)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x, Add(i, j, Inf, x) ;</span><br><span class="line">MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].c = -E[i].c, E[i].f = t[i] ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x03-数字梯形问题"><a href="#rm-0x03-数字梯形问题" class="headerlink" title="$\rm{0x03}~$数字梯形问题"></a>$\rm{0x03}~$数字梯形问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4013" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4013</a></p><p>看题解：$90\%$+…我是真没见过这种建边方式啊喂，并且我一开始建的边很迷…我没有看到，呃，换句话说，我看到了然后忘了，一个数只能向正下方和右下方走……</p><h2 id="第一问·完全不相交的路径"><a href="#第一问·完全不相交的路径" class="headerlink" title="第一问·完全不相交的路径"></a>第一问·完全不相交的路径</h2><p>我真是要菜死了，题解里面说”拆点已经是烂大街的$trick$了”，我：？？？</p><p>大概就是每个点拆成两个点，原因是我们需要<strong>把点上的限制转化成边上的限制</strong>，所以需要进行拆点，然后对于某个点和它的副本连一条$f=1,c=-base[x]$的边，毕竟是求最大值。然后$S$和最顶上的连$f=1,c=0$的边，$T$和最下面一层连$f=1,c=0$，就完了。</p><h2 id="第二问-·-边不相交的路径"><a href="#第二问-·-边不相交的路径" class="headerlink" title="第二问 · 边不相交的路径"></a>第二问 · 边不相交的路径</h2><p>我们考虑此时其实是删除了点的限制，那么我们就将每个点和自己的副本之间的边容量改成$Inf$，并把$T$与最底下的所有点的容量扩为$Inf$即可。注意后半部分的扩容，其目的在于防止中间节点的扩容被限制。</p><h2 id="第三问-·-随便的路径"><a href="#第三问-·-随便的路径" class="headerlink" title="第三问 · 随便的路径"></a>第三问 · 随便的路径</h2><p>既然都随便了，就直接把所有的边都设置成$Inf$，但是显然的是我们不能扩$S$连出去的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijk</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) </span><br><span class="line">dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">dist[S] = <span class="number">0</span>, q.push((Node)&#123;S, <span class="number">0</span>&#125;) ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">Node now = q.top() ; q.pop() ;</span><br><span class="line"><span class="keyword">int</span> num = now.num, dis = now.dist ; <span class="keyword">if</span> (vis[num]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[num] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">int</span> DIS = E[k].c + H[num] - H[to(k)] + dis ;</span><br><span class="line"><span class="keyword">if</span> (DIS &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f)</span><br><span class="line">F[to(k)] = min(F[num], E[k].f), dist[to(k)] = DIS, </span><br><span class="line">q.push((Node)&#123;to(k), DIS&#125;), Pre[to(k)] = num, Last[to(k)] = k ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijk())&#123;</span><br><span class="line">_End = T, Ans += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span> (_End) E[Last[_End]].f -= F[_End], E[Last[_End] ^ <span class="number">1</span>].f += F[_End], _End = Pre[_End] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; -Ans &lt;&lt; endl ;*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L1, R1, L ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N ; S = <span class="number">0</span>, T = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = (tot += <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) Add(S, Id[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>) ; L = cnt + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (L1 = cnt + <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N + M ; ++ i) Add(Id[N][i] + <span class="number">1</span>, T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">Add(Id[i][j], Id[i][j] + <span class="number">1</span>, <span class="number">1</span>, -base[i][j]) ; R1 = cnt ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i &lt; N) Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>), Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 ; i &lt; R1 ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 + <span class="number">1</span> ; i &lt;= R1 ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = L ; i &lt; cnt ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L + <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ; </span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/*  以下是错误的建边 </span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= M ; ++ i) </span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ;</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt; N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt;= M + i ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ;</span></span><br><span class="line"><span class="comment">for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, Inf, -base[tot]) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line"><span class="comment">/*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，大概这三个题就先分成一组吧！</p>]]></content>
    
    <summary type="html">
    
      网络流二十四题专题1——较简单的费用流专题
    
    </summary>
    
      <category term="网络流二十四题" scheme="http://www.orchidany.cf/categories/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%BA%8C%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="http://www.orchidany.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="费用流/最小费用流" scheme="http://www.orchidany.cf/tags/%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>随想七·言叶之庭</title>
    <link href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/"/>
    <id>http://www.orchidany.cf/2019/03/28/随想七·言叶之庭/</id>
    <published>2019-03-28T13:32:12.000Z</published>
    <updated>2019-03-31T13:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>​    Hello darkness my old friend. 黯淡如旧，今时重逢。<br>​    I’ve come to talk with you again. 阔别久日，可赴低叙？<br>​    Because a vision softly creeping. 如梦如幻，于我心萦。<br>​    Left its seeds while I was sleeping. 遗之入梦，齐我心同。<br>​    And the vision that was planted in my brain. 不知归处，不知归处。<br>​    Still remains with the sound of silence. 行舟如风，遣舟迟暮。<br>​    In restless dreams I walk alone. 吾心独行，兰皋止息。<br>​    Narrow streets of cobble stone. 越陌度阡，可有一醉？<br>​    Beneath the hallo of a street lamp’, 如光化影，于我心寂。<br>​    I turned my collar to the cold and damp. 浊寒入襟，刺我心底。<br>​    When my eyes were stabbled. 所见皆幻，所见皆明。<br>​    By the flash of a neon light. 万物皆虚，万物皆允。<br>​    That split the night. 不知归处，不知归处。<br>​    And touched the sound of silence 星瀚灿漫，行人慢走。</p><p>​    ——『$\rm{The ~Sound~of~Silence}$』寂静之声</p></blockquote><p>随想系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">戳我</a></p><p>这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。</p><hr><h1 id="rm-Part-1"><a href="#rm-Part-1" class="headerlink" title="$\rm{Part~1}$"></a>$\rm{Part~1}$</h1><p>月考结束了。我终于有时间把这本书读完。</p><p>之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。</p><p>我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。</p><p>但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。</p><p>《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。</p><p>那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。</p><p>并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。</p><p>或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。</p><h1 id="rm-Part-2"><a href="#rm-Part-2" class="headerlink" title="$\rm{Part~2}$"></a>$\rm{Part~2}$</h1><p>感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。</p><p>连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。</p><p>我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。</p><p>所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。</p><p>……</p><p>说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如……</p><p>但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。</p><p>现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套……</p><p>我不知道为什么。</p><p>总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。</p><p>我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了……</p><p>突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。</p><p>这绝对是我读过的最美的故事了。</p><h1 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h1><p>现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。</p><p>“这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。</p><p>但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。</p><p>我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。</p><p>……</p><p>读完之后，后记里面新海诚是这么描述的：</p><blockquote><p>我一直单恋着小说。<br>不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一<br>种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再<br>想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。</p><p>……</p><p>写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到<br>「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？<br>这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人<br>一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这<br>种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的<br>声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到<br>耳机声音外溢云云。<br>我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回<br>顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。</p><p>……</p><p>写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两<br>情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多<br>多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物<br>的心编织出这个世界。而本书想要描述的就是这点。<br>在「爱」以前，这是段「孤独希求」的故事。<br>这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋<br>爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。</p></blockquote><p>我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。</p><h1 id="rm-Part-4"><a href="#rm-Part-4" class="headerlink" title="$\rm{Part~4}$"></a>$\rm{Part~4}$</h1><p>选了几段放到这里，留作纪念。</p><p>首先是最后，孝雄和雪野重逢的情景：</p><blockquote><p>走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自<br>制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、<br>杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。<br>孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅<br>粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带<br>上缝着枫叶的形状。<br>这双鞋是为了那个人打造，一定可以走得更长更远。<br>不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。<br>——隐约雷鸣。<br>孝雄脱口而出这句话。<br>一股预感充满全身。<br>已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。<br>孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼<br>帘。<br>那是一位穿着浅绿色裙子的女人。<br>孝雄停下脚步。<br>有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。<br>看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。<br>孝雄心想，雨好像停了。</p></blockquote><p>然后是孝雄表白完、雪野拒绝后，雪野的心声：</p><blockquote><p>「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。<br>不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的<br>门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却<br>觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。<br>这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。<br>不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地<br>对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的<br>人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个<br>耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生<br>活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出<br>现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现<br>了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光<br>是不让自己蹲下，就必须耗费莫大的力气。<br>听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干<br>的制服。<br>「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便<br>朝着玄关走去。<br>「啊！」<br>雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，<br>不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的<br>声音，转开门把的声音。然后——</p><p>啪嗒。关门的声音。<br>那一瞬间，雪野突然感到很气愤。<br>「笨蛋！」<br>她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时<br>泄气地慢慢放下椅子，再次坐了下来。<br>「……笨蛋。」她小声地又说了一次。<br>秋月那个笨蛋。<br>一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑<br>假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃<br>饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。<br>一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一<br>切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续<br>冷却着。<br>——结束这段时光的人，是你啊！<br>雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换<br>连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，<br>静静地结束我们的关系。<br>其实我一直在忍耐。<br>其实我一直没有说出口。<br>其实我一直没有说出来过——</p><p>我喜欢你。</p></blockquote><p>还有两段段很有名的摘录下来：</p><blockquote><p>二十七岁的我，丝毫不比十五岁时候的我聪明。<br>雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想<br>着。</p></blockquote><p>还有孝雄的情感爆发：</p><blockquote><p>孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」<br>仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，<br>说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」<br>吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才<br>露出这副表情的她。<br>「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和<br>歌。」孝雄说着。<br>过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。<br>「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑<br>鄙！」<br>讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！<br>「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现<br>的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」<br>讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。<br>「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知<br>道！」<br>我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我<br>讨厌你！<br>「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」<br>但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更<br>加喜欢你。<br>「你就一直那样……」<br>——开什么玩笑，怎么连你也哭了？<br>「你就一直那样，摆出若无其事的表情……」<br>秋月的泪水滴滴答答滑落，大吼着。<br>「——一直孤单一人，度过一生吧！」</p></blockquote><p>……</p><p>今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。</p><p>孤独。</p><p>对，就是这个词，孤独。</p><p>无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。</p><p>总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。</p><p>或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。</p><p>或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许……</p><p>但我没有啊，哈。</p><p>但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。</p><p>天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。</p><h1 id="rm-Part-5-Ending"><a href="#rm-Part-5-Ending" class="headerlink" title="$\rm{Part~5/Ending}$"></a>$\rm{Part~5/Ending}$</h1><p>今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。</p><p>我一直在想，这本书到底能带给我什么。</p><p>是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？……</p><p>我不知道，但我觉得我列举的每个目的都太肤浅。</p><p>或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。</p><p>说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？</p><p>我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。</p><p>$\mathfrak{Orchidany, 3,31,2019}$</p>]]></content>
    
    <summary type="html">
    
      击中了我的心——孤独是耐人寻味的孤独。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>线性规划入门·对偶定理</title>
    <link href="http://www.orchidany.cf/2019/03/19/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    <id>http://www.orchidany.cf/2019/03/19/线性规划对偶定理/</id>
    <published>2019-03-19T06:09:15.000Z</published>
    <updated>2019-04-05T09:27:10.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-Preface-About-Duality-Theorm"><a href="#rm-Preface-About-Duality-Theorm" class="headerlink" title="$\rm{Preface:} About~Duality~Theorm$"></a>$\rm{Preface:} About~Duality~Theorm$</h1><p>首先要说的是<strong>线性规划对偶定理</strong>。我们朴素的线性规划大致如下：<br>$$<br>\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)<br>$$<br>那么我们称它的<strong>对偶</strong>为形如下的线性规划：<br>$$<br>\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)<br>$$<br>换做矩阵表示就会是这样：<br>$$<br>\text{最小化}\quad \boldsymbol{b^Ty} \\<br>\text{满足约束} \quad A^T\boldsymbol{y\geq c} \\\<br>\it{\qquad \qquad \quad} \boldsymbol {y} \geq 0<br>$$<br>那其实比较显然的是，我们原来线性规划中的约束向量与目标函数里的系数向量交换，目标函数的最大化变成了最小化。现在我们思考对偶的意义。</p><p>首先假设我们有这么一个线性规划：<br>$$<br>\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)<br>$$<br><del>其实就是上面那个</del></p><p>我们的目的其实等价于确定目标函数的下界。我们观察每一组约束，假设有一组约束是<br>$$<br>\quad \sum \limits_{j=1}^{m} a_{p,j}y_{j} \geq c_p\quad (i = 1,2,3\cdots n)<br>$$<br>并且我们保证有：<br>$$<br>\forall a_{p,j} \in \boldsymbol{a_p},\forall b_i \in{\boldsymbol{b}},\quad i=j \Longrightarrow b_i\geq a_{p,j}<br>$$<br>好像写的很不规矩……意思就是对应项的系数，目标函数都比这个约束里的大。</p><p>那么因为$\forall x\geq 0$，所以我们可以保证目标函数的最小值一定会是$c_p$。这个结论是显然的。</p><p>更进一步，那么我们最后确定的下界一定会是这样的（此处一点也不严谨地使用了$\Omega$符号）：<br>$$<br>\Omega(\rm{Aim}) = \it{\sum \limits_{j = 1}^{n}t_j\cdot\sum\limits_{i=1}^{n}\sum \limits_{k=1}^{m}a_{i,k}y_k}\\\<br>\forall t_j \geq 0<br>$$</p><p>而因为我们对于原来的约束有<br>$$<br>\quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n)<br>$$<br>所以我们将其代回我们画好的式子里面：<br>$$<br>\Omega(\rm{Aim}) \geq \it{\sum\limits_{j=1}^{n}t_jc_j}<br>$$<br>那么……目标函数的下界就变成了一个和式的上界——又变成了一个求解目标函数最大值的问题。</p><p>那么这或许感性证明了对偶定理的正确性？</p><h1 id="rm-Afterword-Some-Typical-Problem"><a href="#rm-Afterword-Some-Typical-Problem" class="headerlink" title="$\rm{Afterword:}Some~Typical~Problem$"></a>$\rm{Afterword:}Some~Typical~Problem$</h1><p><del>没见过吧，一篇文章只有前言和总结</del></p><p><del>其实博主就是在疯狂划水/摸鱼</del></p><p>其实常见的对偶问题有很多，博主功力不够，于是只能整理一个比较形式化的结论：</p><h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="$~$最大流问题"></a>$~$最大流问题</h2><p>形式化的最大流问题的线性规划如下：<br>$$<br>\text{最大化}\quad \quad \quad ~f_{s\to t} \quad ~ \quad \quad \quad \quad \quad \quad \\<br>\text{满足约束} \quad \quad f_{u\to v} \leq L_{u \to v}\qquad (u,v) \in E \\ <br>\qquad \quad \quad ~\sum\limits_{u}f_{u \to v} = \sum\limits_{v}f_{v \to u}\qquad u\in V<br> \\ \qquad \qquad \qquad ~~\quad f_{u\to v} \geq 0 \qquad (u,v) \in E ~\cup \text{e(s,t)}<br>$$<br>其中$e(u,v)$表示链接$u,v$的路径集合，$f$表示流量，$L$表示容量(Limit)。</p><p>其对偶过去就会是：<br>$$<br>\text{最小化}\quad \quad \quad \sum_{(u,v)\in E}L_{u\to v}d_{u \to v} \quad ~ \quad \quad \quad\\<br>\text{满足约束} \quad \quad d_{u\to v}-p_u+p_v \geq 0\qquad (u,v) \in E \\ <br>\qquad \quad \quad \quad \quad \quad ~~p_s - p_t \geq 1\qquad u\in V<br> \\ \qquad \qquad \qquad \quad  p_i,d_{i\to j}\in\{0,1\} ~\qquad<br>$$<br>里面$d_{i\to j}$表示$i \to j$这条边有没有被割，同时假设我们割完之后，原来的图分成了两部分$S$和$T$,那么会有$p_i = [i \in S]$。这个限制是为了保证割的逻辑性——所有的割边都连接着$S,T$两个集合，且源点和汇点在不同的集合。</p><p>emmm我实在不想再整理了(写式子太麻烦)，等什么时候我退完役闲下来再说吧233</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li></ul>]]></content>
    
    <summary type="html">
    
      通常的线性规划用于求解一类满足正向约束的最大值问题，但是通过对偶可以将其转化成一类求解满足逆向约束的最小值问题。
    
    </summary>
    
      <category term="-学习笔记 -线性规划" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
    
      <category term="线性规划/单纯形法" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划/对偶定理" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>多项式2·NTT以及任意模数NTT</title>
    <link href="http://www.orchidany.cf/2019/03/17/NTT1-2/"/>
    <id>http://www.orchidany.cf/2019/03/17/NTT1-2/</id>
    <published>2019-03-17T13:13:33.000Z</published>
    <updated>2019-03-19T07:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0x01-quad-rm-Preface"><a href="#0x01-quad-rm-Preface" class="headerlink" title="$0x01\quad \rm{Preface}$"></a>$0x01\quad \rm{Preface}$</h1><p>无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。</p><p>我们知道，对于$FFT​$而言，其得以优化成$\log​$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。</p><p>$\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，<strong>快速数论变换</strong>。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$：</p><ul><li><p>$\omega_n^n = 1$。</p></li><li><p>$\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。</p></li><li><p>{$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}​$}，这使得问题规模可以在计算的时候减半。</p></li><li><p>$$<br>\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k =<br> \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}<br>$$</p></li></ul><p>这样可以保证我们能够使用相同的方法进行逆变换。</p><hr><p>首先，原根的基本定义：设$g$为$p$的一个原根，则满足：<br>$$<br>𝑔^{𝑝−1}  \equiv 1(\mod p) \\<br>∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)<br>$$<br>换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。</p><p>同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过<br>$$<br>g^{p-1} \equiv1(\bmod~p) \ \omega_n^n=1<br>$$<br>而已。于是就满足性质一。</p><p>  而对于性质三，我们先考虑一个转化。我们如果要将$g​$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}​$。换句话说，$N | (p-1)​$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)​$，得到一个和单位根相似的形式。</p><p>  那么接下来，因为$p​$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)​$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)​$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：<br>$$<br>  g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)<br>$$<br>  再结合<del>显而易证的</del>消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。</p><p>  至于性质四，证明的大体相似于单位单位复根。即：<br>$$<br>  \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow  \frac{(g_n^n)^k -1}{g_n^k -1} \equiv  \frac{(1)^k -1}{g_n^k -1} = 0<br>$$<br>  而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。</p><h1 id="0x02-quad-rm-Codes"><a href="#0x02-quad-rm-Codes" class="headerlink" title="$0x02\quad \rm{Codes}$"></a>$0x02\quad \rm{Codes}$</h1><p>呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且$N$是$2$的幂次，所以素数$p$一定要是$2^j+1$的形式。</p><p>至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000010</span> ;</span><br><span class="line">LL A[MAXN], B[MAXN], Inv ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    LL Gn = expow(flag == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    N = read(), M = read() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - <span class="number">2</span>) ;</span><br><span class="line">    NTT(A, <span class="number">-1</span>) ; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) write((<span class="keyword">long</span> <span class="keyword">long</span>) (A[i] * Inv + P) % P) ; fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Gi</code>表示$998244353$的原根的逆元。</p><h1 id="0x03-quad-rm-Extending"><a href="#0x03-quad-rm-Extending" class="headerlink" title="$0x03\quad \rm{Extending}$"></a>$0x03\quad \rm{Extending}$</h1><p>接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。</p><p>先咕着qwq……</p>]]></content>
    
    <summary type="html">
    
      另一种神奇的多项式卷积求法，比FFT应用要广泛。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-NTT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-NTT/"/>
    
  </entry>
  
  <entry>
    <title>有趣的数学题 · [NOI2002]Savage/[Violet · 5]樱花</title>
    <link href="http://www.orchidany.cf/2019/03/17/Math1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Math1/</id>
    <published>2019-03-17T10:36:37.000Z</published>
    <updated>2019-03-17T11:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt=""></p><h2 id="rm-NOI2002-Savage"><a href="#rm-NOI2002-Savage" class="headerlink" title="$\rm{[NOI2002]}$ Savage"></a>$\rm{[NOI2002]}$ Savage</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1407" target="_blank" rel="noopener">$\color{violet}{Link}​$</a> </p><h3 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不算特别难…其实就是求方程$$C_{i}+P_{i}x \equiv C_j+P_jx ~(\bmod ~M)$$不存在一个解使得$x \leq min(L_i,L_j)$时，$M$的最小值。然后因为题目中的数据，假设我们令每个野人都只是绕着圈走而不重复经过对方的路径——即$M$的最大值，也不过是$100\times 106\times 100 = O(1e6)$的级别，于是考虑直接枚举$M$, 然后check。由于最多共有$15$个野人，且单次exgcd是$\log n $级别的，所以复杂度上限是$O (Mn^2 \log C_{max}) &lt; \Omega(1e8)$级别的。如果不是精心构造数据的话，可以直接艹过去。</p><p>喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ;</span><br><span class="line">            <span class="keyword">int</span> qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ;</span><br><span class="line">            x = x * w / qwq ; <span class="keyword">while</span> (x &lt;= <span class="number">0</span>) x += M ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后觉得一点问题都没有，$40pts$之后愣了大半天。</p><p>而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的$x$，应该不断取模$b/ \gcd(a,b)$</p><p>为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解：</p><blockquote><p>_这是上面这个式子为什么可以这么做的证明：_</p><p>若有$ax+by=c$且$a_0x+b_0y=c$</p><p>那么便有$a(x-x_0)+b(y-y_0)=0$<br>两边同时除以$gcd(a,b)$可得：<br>$\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)$ $ \quad$ $(1)$</p><p>而因为</p><p>$(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p><p>所以由$(1)$可得$\frac{b}{gcd(a,b)}$整除$(x-x_0)$</p><p>所以很显然有$\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in Z$</p><p>那么就有对于任意一个$x_i$，有</p><p>$ x_i=x_0+\frac{b}{gcd(a,b)} \times{t} $</p></blockquote><p>我特么…智商已经回退到上个世纪了吧$\rm{qaq}$，自闭了。</p><p>这就是我整理这道题的原因……还有，上面$P_i-P_j$似乎需要取模并使其变成正的，因为好像我的$exgcd$里面限制了$A&gt;0$的缘故。</p><p>心得：我退役吧嘤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B) &#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> A ;&#125;</span><br><span class="line">    <span class="keyword">int</span> t = exgcd(y, x, B, A % B) ; y -= A / B * x ; <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ; </span><br><span class="line">            x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; <span class="keyword">if</span> (!x) x += (M / qwq) ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> ( M ; ; ++ M) <span class="keyword">if</span> (check()) &#123; <span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Violet～5-樱花"><a href="#rm-Violet～5-樱花" class="headerlink" title="$\rm{[Violet～5]}$ 樱花"></a>$\rm{[Violet～5]}$ 樱花</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2721" target="_blank" rel="noopener">$\color{violet}{Link}​$</a> </p><p>这是好久之前做的一道题，突然被我发现了。大概就是求方程$$\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 1e6)$$的解的组数。</p><h3 id="rm-Sol-1"><a href="#rm-Sol-1" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不想思考系列问题，我这么懒还是退役吧。(sigh)</p><p>我们将柿子变个形：<br>$$<br>\frac{x+y}{xy} = \frac{1}{n!} \\<br>n!x + n!y = xy<br>$$<br><del>然后我就不会了，此题完结</del></p><p>然后有一步很妙的是两边同时$+(n!)^2$得到：<br>$$<br>(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\<br>(n!-x)(n!-y)=(n!)^2<br>$$<br>然后就会发现我们只需要找出$(n!)^2$的因子个数就好了…</p><p>好像我从来没有写过$\tau$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）<br>$$<br>x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)<br>$$<br><del>其实就是为了水字数</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Prime[MAXN] ;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">bitset</span> &lt;MAXN&gt; vis ; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, i, j, cnt, Ans, Cnt[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ego</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">1</span>] = vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) Prime[++ cnt] = i ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * Prime[j] &gt; N) <span class="keyword">break</span> ;</span><br><span class="line">vis[i * Prime[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!(i % Prime[j])) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = Prime[i] ; j &lt;= N ; j *= Prime[i])</span><br><span class="line">        ( Cnt[i] += (N / j) ) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; N ; Ans = <span class="number">1l</span>l, Ego() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">        (Ans *= (Cnt[i] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>) %= Mod ;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; Ans % Mod &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两道小清新数学题
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/扩展欧几里德" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="数学/素数/素数筛法" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E7%B4%A0%E6%95%B0-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>奇奇怪怪的线段树1（子段和+最长连续）</title>
    <link href="http://www.orchidany.cf/2019/03/17/Segment-Tree1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Segment-Tree1/</id>
    <published>2019-03-17T08:52:02.000Z</published>
    <updated>2019-03-17T10:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><p>最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$</p><h1 id="rm-Task1-子段和"><a href="#rm-Task1-子段和" class="headerlink" title="$\rm{Task1} $子段和"></a>$\rm{Task1} $子段和</h1><p>其实这个算是比较简单的了，毕竟$qyf​$曾经给我们讲过，当时我就觉得十分的……麻烦233.</p><p>那么例题其实就是$\rm{SPOJ}$的$GSS$系列——的前三道题<del>(后几道题都不会做)</del></p><h2 id="GSS1-区间求最大子段和-不带修"><a href="#GSS1-区间求最大子段和-不带修" class="headerlink" title="$GSS1$区间求最大子段和(不带修)"></a>$GSS1$区间求最大子段和(不带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">$\color{violet}{Link}​$</a></p><p>$2333$应该算是比较简单的了。我们对于每个区间维护一个<strong>区间和</strong>，维护一个<strong>从最左端开始且必须包含最左端元素的最大子段和</strong>，再维护一个<strong>从最右端开始且必须包含最右端元素的最大子段和</strong>，最后维护一个<strong>区间最大子段和</strong>。</p><p>那么转移($push$_$up$)时就显得十分方便。我们的父区间的$Lmax$只取决于左子区间的$Lmax$和<strong>当左区间的$Sum$等于$Max$时（即左区间全部都要纳入到其最大子段和中时）</strong>，左区间的$Sum$与右区间的$Lmax$的和。那么对于区间的$Rsum$，也是一个道理。最终对于该区间的最大子段和，我们<strong>不考虑</strong>从已经转移来的$Lmax/Rmax$，而是考虑从左右区间的$Max$以及左右区间的和来转移。大体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有值得注意的一点：在询问的时候，它比较膈应……就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来……所以所就要类似于边询问，边$push_up$这种感觉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后总代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line"><span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line"><span class="keyword">while</span> (M --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GSS3-区间求最大子段和-带修"><a href="#GSS3-区间求最大子段和-带修" class="headerlink" title="$GSS3$ 区间求最大子段和(带修)"></a>$GSS3$ 区间求最大子段和(带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1716" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>……其实吧，这个带修不带修……好像影响并不大？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">bool</span> MArk ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line"><span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L == l &amp;&amp; L == r)&#123;</span><br><span class="line">T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) change(ls(rt), l, mid, k) ;</span><br><span class="line"><span class="keyword">else</span> change(rs(rt), mid + <span class="number">1</span>, r, k ) ; P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line"><span class="keyword">while</span> (M --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R) ;</span><br><span class="line"><span class="keyword">if</span> (!MArk) change(<span class="number">1</span>, <span class="number">1</span>, N, R) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GSS4-区间开根问题"><a href="#GSS4-区间开根问题" class="headerlink" title="$GSS4$ 区间开根问题"></a>$GSS4$ 区间开根问题</h2><p><a href="https://www.luogu.org/problemnew/show/SP2713" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>这个和子段和一点儿关系都没有，顺便整一下233.</p><p>就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个$2^{63}$内的数值$N$，我们假设其开根$k$次可以得到$N &lt; 2$——只要$N &lt; 2$之后的计算就会集中在一个紧确的范围$(1,2)$内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。</p><p>那么现在，我们致力于去确定$k$的值域。我们不得不承认，$\sqrt n$在$[0,+\infty]$是单调递增的，同理三次方根也是，四次方根也是……所以我们不妨取最大值，考虑$N=2^{63}$时，$k$值的大小。而很显然，此时的$k$应该为$\log _263+1 ≈ 6.978$——这似乎是十分平凡的结论。</p><p>总之，我们得出，似乎运算次数的上界就是$k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是$\Omega(7n)$的样子，无非就是多几个常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll N, M, K, i, L, R ; </span><br><span class="line">ll base[MAXN], T[MAXN], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">p_u</span><span class="params">(ll rt)</span></span>&#123; ;&#125;</span><br><span class="line"><span class="keyword">void</span> _Build(ll rt, ll l, ll r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;T[rt] = base[l] ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _Build(ls(rt), l, mid) ;</span><br><span class="line">    _Build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) ret += _query(rs(rt), mid + <span class="number">1</span>, r, sl, sr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (T[rt] &lt;= (r - l + <span class="number">1</span>)) <span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">                T[rt] = (<span class="keyword">int</span>)(<span class="built_in">pow</span>((<span class="keyword">double</span>)T[rt], <span class="number">0.5</span>)) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), </span><br><span class="line">   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) _Sqrt(rs(rt), mid + <span class="number">1</span>, r, sl, sr), </span><br><span class="line">   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">    ++ tot, <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, tot) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    _Build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        K = qr(), L = qr(), R = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) swap(L, R) ;</span><br><span class="line">       <span class="keyword">if</span> (K)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, _query(<span class="number">1</span>, <span class="number">1</span>, N, L, R)) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        _Sqrt(<span class="number">1</span>, <span class="number">1</span>, N, L, R) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Task2-最长连续问题"><a href="#rm-Task2-最长连续问题" class="headerlink" title="$\rm{Task2}$ 最长连续问题"></a>$\rm{Task2}$ 最长连续问题</h1><p>这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括<strong>连续</strong>字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断$push_up$即可。</p><p>$emmm$在这边整理几道思路不错的题吧：</p><h2 id="rm-USACO-酒店-hotel"><a href="#rm-USACO-酒店-hotel" class="headerlink" title="$\rm{USACO}$ 酒店($hotel$)"></a>$\rm{USACO}$ 酒店($hotel$)</h2><p><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>初始的一个全零的序列，我们对它准确来说有以下三个操作：</p><ul><li>区间置$0$</li><li>区间置$1$</li><li>询问是否有一段长度为$k$的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作②</li></ul><hr><p>这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。</p><p>但事实上……这就是学数据结构学傻了的后果……毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。</p><p>唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于$NOI2005$维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。</p><p>诶，好像扯了什么奇怪的东西……</p><p>回到正题，我们不考虑直接维护这个东西，而是<strong>通过维护区间内的最长连续$0$的个数，达到辅助查找区间的目的</strong>。那么我们查找区间的时候，就直接**择最左边的区间优先，并$check$其是否有足够的$0$。</p><p>对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> Sum, Len, Lsum, Rsum, tag ; </span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, N, M, MArk, i, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ;</span><br><span class="line">&#125;</span><br><span class="line">T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].Sum == T[ls(rt)].Len) </span><br><span class="line">T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line"><span class="keyword">if</span> (T[rs(rt)].Sum == T[rs(rt)].Len) </span><br><span class="line">T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), </span><br><span class="line">T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">T[rt].tag = <span class="number">-1</span>,</span><br><span class="line">T[rt].Len = T[rt].Lsum = </span><br><span class="line">T[rt].Rsum = T[rt].Sum = r - l + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">T[rt].tag = k ;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">push_down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid) update(rs(rt), mid + <span class="number">1</span>, r, ul, ur, k) ;</span><br><span class="line">push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">push_down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].Sum &gt;= A) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) <span class="keyword">return</span> mid - T[ls(rt)].Rsum + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">while</span>(M --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MArk) ;</span><br><span class="line"><span class="keyword">if</span> (MArk == <span class="number">2</span>)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), update(<span class="number">1</span>, <span class="number">1</span>, N, A, A + B - <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A) ;</span><br><span class="line"><span class="keyword">if</span> (T[<span class="number">1</span>].Sum &gt;= A)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t = query(<span class="number">1</span>, <span class="number">1</span>, N)), update(<span class="number">1</span>, <span class="number">1</span>, N, t, t + A - <span class="number">1</span>, <span class="number">0</span>)  ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'0'</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。</p><h2 id="rm-SCOI-序列操作"><a href="#rm-SCOI-序列操作" class="headerlink" title="$\rm{SCOI}$ 序列操作"></a>$\rm{SCOI}$ 序列操作</h2><p><a href="https://www.luogu.org/problemnew/show/P2572" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>对于一个$01$序列，大体是这几种操作：</p><ul><li>区间清零</li><li>区间置为$1$</li><li>区间全部取非</li><li>区间查询$1$的个数</li><li>区间查询最长连续的$1$的长度</li></ul><p>好的，这道题被我秒了，爽啊……不过秒是秒了，对拍调试法调了好久$233$。</p><p>其实对于$1,2,4,5$都好说，只是第$3$个操作，需要再另维护区间最长连续的$0$的长度，如果存在取非标记生效，就交换一下就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> OS, OL, OR ;</span><br><span class="line"><span class="keyword">int</span> Sum, Lsum, Len, Rsum, S, tag, t ;</span><br><span class="line"><span class="comment">//tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor</span></span><br><span class="line">&#125;T[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, MArk, L, R, base[MAX], i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">T[rt].S = T[ls(rt)].S + T[rs(rt)].S ;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].S == T[ls(rt)].Len) </span><br><span class="line">  T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line"><span class="keyword">if</span> (T[rs(rt)].S == T[rs(rt)].Len) </span><br><span class="line">  T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="keyword">if</span> (!T[ls(rt)].S) </span><br><span class="line">  T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OL = T[ls(rt)].OL ;</span><br><span class="line"><span class="keyword">if</span> (!T[rs(rt)].S) </span><br><span class="line">  T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OR = T[rs(rt)].OR ;</span><br><span class="line">T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (T[rt].t == <span class="number">1</span>)&#123;</span><br><span class="line">T[ls(rt)].tag ^= <span class="number">1</span>, T[rs(rt)].tag ^= <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ;</span><br><span class="line">T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ;</span><br><span class="line"><span class="comment">//l</span></span><br><span class="line">T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ;</span><br><span class="line">T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ;</span><br><span class="line">T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ;</span><br><span class="line"><span class="comment">//r</span></span><br><span class="line">T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ;</span><br><span class="line">T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ;</span><br><span class="line">T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">1</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ;</span><br><span class="line">&#125;</span><br><span class="line">T[rt].tag = <span class="number">-1</span>, T[rt].t = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">T[rt].tag = k ;</span><br><span class="line"><span class="keyword">if</span> (!k)</span><br><span class="line">T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, </span><br><span class="line">T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">0</span>, </span><br><span class="line">  T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) _change(ls(rt), l, mid, k) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) _change(rs(rt), mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _reverse(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">T[rt].t = <span class="number">1</span> ;</span><br><span class="line">T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ;</span><br><span class="line">T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ;</span><br><span class="line">T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) _reverse(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) _reverse(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt].S ;</span><br><span class="line">down(rt) ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) res += Sum(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) res += Sum(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">T[rt].Len = r - l + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">if</span> (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">    res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; </span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">while</span> (M --)&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R),</span><br><span class="line">++ L, ++ R ;</span><br><span class="line"><span class="keyword">if</span> (MArk == <span class="number">0</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">1</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">2</span>) _reverse(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Sum(<span class="number">1</span>, <span class="number">1</span>, N)) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$push_up$真长啊$233$</p><p>艹完这个题是真的爽啊~</p><h1 id="Task3-总结一下"><a href="#Task3-总结一下" class="headerlink" title="$Task3~$ 总结一下"></a>$Task3~$ 总结一下</h1><p>其实这东西和$DP$是一样的吧？你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。</p><p>嗯，万物相同。</p><blockquote><p>野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？</p></blockquote><p>不知为什么，突然想到了这句话。</p><h1 id="mathscr-The-End"><a href="#mathscr-The-End" class="headerlink" title="$\mathscr{The~End}$"></a>$\mathscr{The~End}$</h1>]]></content>
    
    <summary type="html">
    
      奇奇怪怪的线段树散发着奇奇怪怪的香气（
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="线段树" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="题解" scheme="http://www.orchidany.cf/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>自适应Simpson法入门</title>
    <link href="http://www.orchidany.cf/2019/03/17/Simpson1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Simpson1/</id>
    <published>2019-03-17T08:39:35.000Z</published>
    <updated>2019-03-17T10:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p><h1 id="rm-0x01-前言"><a href="#rm-0x01-前言" class="headerlink" title="$\rm{0x01}$  前言"></a>$\rm{0x01}$  前言</h1><p>首先阐明一点，<strong>自适应辛普森算法($\rm{Adaptive ~Simpson’s~ rule}$ )</strong>是一类<strong>近似算法($\rm{Approximation ~algorithm}$)</strong>，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？</p><p>其思想是利用二次函数来不断<strong>拟合($\rm{Overfitting}$)</strong>所求曲线，而所谓的<strong>$Adapative$（自适应）</strong>则是用于优化时间复杂度的方法。</p><p>嗝…总之…比较简单？</p><p>表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。</p><h1 id="rm-0x02-mathcal-Simpson-Formula-辛普森公式"><a href="#rm-0x02-mathcal-Simpson-Formula-辛普森公式" class="headerlink" title="$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式"></a>$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式</h1><p>稍等，这个跟算法的关系不大，主要是公式：$$\rm{\int _{l}^{r} f(x) \rm{dx}\approx \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}} \,$$</p><p>事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大$233​$</p><p>这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$：</p><blockquote><p>因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：<br>$$\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx$$<br>求 $g(x)​$ 的不定积分为：<br>$$\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C$$<br>然后再带入 RR 和 LL ：<br>$$\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)$$<br>然后提公因式，原式为：<br>$$\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)$$<br>把里面展开来：<br>$$\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)$$<br>重新整理一下式子：<br>$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)$$<br>再整理：<br>$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))$$<br>代换可得：<br>$$aR^2+bR+c\approx f(R)$$<br>$$aL^2+bL+c\approx f(L)$$<br>$$4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})$$<br>把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：<br>$\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))$</p></blockquote><p>于是我们就得到了所谓的$\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是——</p><h1 id="rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法"><a href="#rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法" class="headerlink" title="$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法"></a>$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法</h1><p>我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑<strong>定向二分</strong>。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。</p><p>于是考虑<strong>自适应</strong>。</p><p>所谓<strong>自适应</strong>，说的直白点，无非就是<strong>需要多分治几次的地方，多分治几次；不需要的则可以少分治几次</strong></p><p>你会发现，其实他节约的就是一个点——<strong>时间效率</strong>。</p><p>举个栗子$^{[2]}$：</p><p>比如有这么个函数$\rm{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }$，我们要求$\int_{0}^{4}f(x) \rm{~dx}$ 并要求精度误差在$1e-5$ 以内。而我们有两种方法去解决：</p><ul><li>以固定的比例以及约束二分。</li><li>运用自适应策略分配</li></ul><p>那么我们首先要知道他真正的$value:$</p><p><img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165543353-1446042218.png" alt=""></p><p>看起来好像海星？然后我们用两种方法都试一试：</p><p>首先是自适应法，我们发现最后只需要求$20$段区间。表中的$a_k \&amp; b_k$表示左右区间，$S(l,r)$表示$[l,r]$内、运用$0x01$中的公式计算的，$\rm{Error~Bound}$表示误差界，$\rm{Tolerance}$表示计算时<strong>需要的误差</strong>(程序设计时会讲)。</p><p><img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165550075-1102374096.png" alt=""></p><p>那么最后算出来的值是$ −1.54878823413$ ，与真实值误差为$0.00000013840 $，一共调用了$79$次<strong>函数估值</strong>（留个坑，后文会讲）。</p><p>那么绘制出来的函数图像大概长这样：<img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165650450-478131070.png" alt=""></p><p>好像很流畅？$233$</p><p>那么第二种方法是定值分段。我们考虑分成区间$[0,4]$分为长度为$0.03125$的$128$段，并运用$0x01$的$Formula$，最后得出的结果为$−1.54878844029$，误差为$0.00000006776$……</p><p>好像是第一个误差的二分之一？听起来好像误差小了，但是却需要$257$次函数估值的调用……相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦的啦～</p><p>但是比起$1e-5$精度来说……这波稳赚啊$233$</p><h1 id="rm-0x04-mathcal-About-Code-代码实现"><a href="#rm-0x04-mathcal-About-Code-代码实现" class="headerlink" title="$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现"></a>$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现</h1><p>首先是<a href="https://www.luogu.org/problemnew/show/P4525" target="_blank" rel="noopener">$LuoguP4525$</a>的暴力解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (C * x + D) / (A * x + B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ;</span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Simp_calc(l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid) + do_divide(mid, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ;</span><br><span class="line">    Ans = do_divide(L, R) ; <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是……他对的很？</p><p>至于进化版<a href="https://www.luogu.org/problemnew/show/P4526" target="_blank" rel="noopener">$LuoguP4526$</a>，也是完全可以violently艹过去的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">23.3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R)) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，其真正的实现应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v Lans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) * 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, L, R ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Liu = <span class="number">1.0</span> / <span class="number">6</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * Liu * (F(l) + F(r) + <span class="number">4.0</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans, <span class="keyword">double</span> eps)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, t ; </span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ; </span><br><span class="line">    <span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; <span class="comment">//据说eps×15来自于Wiki……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">30</span> ; </span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们发现这就可以跟文章上面$0x03$中的例子呼应了：每次分治时计算两次，总共分治了$39$次，最终一共计算了$78+1=79$次，而二分则是一棵有$128$个叶子节点的递归树，总共计算了$256 +1=257$次。    </p><p>好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断$check\&amp;calc$, 而$check$的方式也很简单，只需要判断一下两段子区间的函数值之和与整个区间的函数值之和的差值是否在精度要求范围之内，之后如果满足精度误差就直接$return$，否则对于这段区间继续递归下去。</p><p>而这个地方有个要求，就是对于$eps$，你需要不断$half$他，原因很简单，对于一整段区间$U$，要求他的返回值的$|eps(U)| \leq k$的话，那么对于其作为子集两个连续区间$A,B$，当$A \bigcup B = U$时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq  \frac{k}{2}$，才能保证$|eps(U) = eps(A) + eps(B)| \leq k$，所以要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line">....................</span><br><span class="line"><span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ;</span><br></pre></td></tr></table></figure><p>好了，唯一的问题在于有句话迷的很：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ;</span><br></pre></td></tr></table></figure><p><img src="nky.jpg" alt=""></p><p>这个$\leq 15 \cdot eps$是什么意思？</p><p>好吧，笔者也不清楚，但是有个结论是长这样的：<img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165630989-1211570362.png" alt=""></p><p>什么？你说推什么倒？小小年纪整天想着推倒<del>学姐</del>可不好啊$233$</p><p>什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～</p><p>好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了……</p><p>于是结束，撒花花…（不是撒博主x）</p><h1 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm{Referance}$"></a>$\rm{Referance}$</h1><ul><li><p>$[1]$ :$NaCly_Fish$的$blog$ <a href="https://www.luogu.org/blog/NaCly-Fish-blog/SimpsonIntegral" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p></li><li><p>$[2]$ :某篇论文 <a href="https://files.cnblogs.com/files/pks-t/AdaptiveQuadProof.pdf" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p></li></ul><p>对于第二篇$refer$，借鉴的比较多（读书人的事……咳咳……），但是改了一个数据，就是$81 \to 79$，因为代码需要$233$</p><p>$Ps:$史上最不正经的$reference$诞生了……</p>]]></content>
    
    <summary type="html">
    
      一种很可爱的积分近似法，学的时候顺便看了好多论文qaq
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="积分/积分近似" scheme="http://www.orchidany.cf/tags/%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86%E8%BF%91%E4%BC%BC/"/>
    
      <category term="计算几何-Simpson积分" scheme="http://www.orchidany.cf/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Simpson%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Calc on Trees (1)</title>
    <link href="http://www.orchidany.cf/2019/03/16/Cal-on-Tree1/"/>
    <id>http://www.orchidany.cf/2019/03/16/Cal-on-Tree1/</id>
    <published>2019-03-16T12:15:28.000Z</published>
    <updated>2019-03-17T11:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p><p>好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。</p><p>问题大概有两类：只有查询$\&amp;​$修改查询都有</p><h2 id="mathscr-Task1-普通的查询问题"><a href="#mathscr-Task1-普通的查询问题" class="headerlink" title="$\mathscr{Task1}$普通的查询问题"></a>$\mathscr{Task1}$普通的查询问题</h2><p>大概问题就类似于这个典型的<a href="https://www.luogu.org/problemnew/show/P2420" target="_blank" rel="noopener">$XOR$问题</a> </p><p>其实说白了，这个题的解法十分简单——$LCA$</p><p>但其实……我一开始考虑$LCA$，没有细致考虑，只是觉得如果从$u,v$分别向$LCA$跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。</p><p>但是这个地方，$LCA$的作用十分巧妙——我们试图去拓展这个题。我们定义$D(\bigodot,r,u)$表示在运算$\bigodot$下，从根$r$到某一固定点$u$的边权运算结果，其中限定了运算$\bigodot$必须为可逆运算，比如说异或、加法、减法——注意，此时的可逆运算，可以是<strong>自可逆（自己对自己运算是逆运算，比如$A~XOR ~A = 0$）</strong>或者<strong>他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法）</strong>，那么我们就可以很方便地得出它的一般形式$$D(\bigodot,u,v) = D(\bigodot,r,u) \bigodot D(\bigodot,r,v) ~\bigoplus ~(~2 \cdot D(\bigodot,r,LCA(u,v)~)~)$$ ，其中我们假设运算$\bigodot$与$\bigoplus$互逆。树上前缀和大抵上就是这个意思。</p><p>那么回到这个题，我们对于每一个点的$D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$是一个相当平凡的结论；有权时，则直接$dfs$一遍即可。每次查询是$log$级别的，所以时间复杂度的渐进上界就是比较显然的$O(\max(m \log_2n,n))$。</p><p>代码大概是这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span> )+ (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].t = v ;</span><br><span class="line">    e[cnt].next = head[u] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">head[u] = cnt ;</span><br><span class="line">    e[++cnt].t = u ;</span><br><span class="line">    e[cnt].next = head[v] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _build(<span class="keyword">int</span> deep, <span class="keyword">int</span> now, <span class="keyword">int</span> f, <span class="keyword">int</span> _xor)&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f, dep[now] = deep, XOR[now] = _xor ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = head[now]; k ;k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[k].t == f) <span class="keyword">continue</span> ;</span><br><span class="line">        _build(deep + <span class="number">1</span>, e[k].t, now, _xor ^ e[k].v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Up = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Up; i ++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    pre = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= Up; j ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; pre) u = fa[u][j] ;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span>(j = Up; j &gt;= <span class="number">0</span>; j --) <span class="keyword">if</span>(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> fa[v][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr(), in3 = qr();</span><br><span class="line">        add(in1, in2, in3) ;</span><br><span class="line">    &#125;</span><br><span class="line">    M = qr() ;</span><br><span class="line">    _build(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), init( );</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr() ;</span><br><span class="line">        f1 = LCA(in1, in2) ;</span><br><span class="line">        <span class="keyword">int</span> t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathscr-Task-2-带有修改的查询问题："><a href="#mathscr-Task-2-带有修改的查询问题：" class="headerlink" title="$\mathscr{Task~2}$带有修改的查询问题："></a>$\mathscr{Task~2}$带有修改的查询问题：</h2><p>之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是<a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">某年国家集训队的板子题</a>和一道经典的<a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">边权修改启蒙题</a> </p><p>我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然<strong>只能转移到深度大的点上</strong>，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。</p><p>所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要<strong>忽略$LCA(u,v)$</strong>，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v]) ;</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v], d) ;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br></pre></td></tr></table></figure><p>即可。</p><p>而对于如何边权转点权，我用的总时间复杂度大约$O(n)$的区间赋值函数，好像比较方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">    n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，<del>题解好啊</del></p><p>那么上面两个题就比较简单了：</p><p>$\mathscr{T1 ~\text{の} ~code}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;  </span><br><span class="line"><span class="keyword">int</span> Id[MAX], M, N, tot, A, B, C, i ; <span class="keyword">char</span> STR[<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Max[MAX &lt;&lt; <span class="number">1</span>], Min[MAX &lt;&lt; <span class="number">1</span>], S[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ;</span><br><span class="line">    Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ;</span><br><span class="line">    S[rt] = S[Ls(rt)] + S[Rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ;</span><br><span class="line">        T[Ls(rt)] ^= <span class="number">1</span>, T[Rs(rt)] ^= <span class="number">1</span> ;</span><br><span class="line">        Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ;</span><br><span class="line">        Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ;</span><br><span class="line">        T[rt] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        S[rt] = Max[rt] = Min[rt] = k, T[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Max[rt] ;</span><br><span class="line">        Max[rt] = -Min[rt], Min[rt] = -t ; </span><br><span class="line">        T[rt] ^= <span class="number">1</span>, S[rt] = -S[rt] ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Max[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = -Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Min[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Minnnnn = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Minnnnn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ___query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Ssssss = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    <span class="keyword">return</span> Ssssss ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Min</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Sum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr() + <span class="number">1</span>, n[i].v = qr() + <span class="number">1</span>, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'N'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, _Update(A, B) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'S'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Sum(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'A'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'I'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Min(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$一定是<strong>异或而不是覆盖</strong> ……是一个坑点</p><p>$\mathscr{T2 ~\text{の} ~code}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ; <span class="comment">//0 = Change, 1 = Add .</span></span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">char</span> STR[<span class="number">50</span>] ; <span class="keyword">int</span> A, B, C ;</span><br><span class="line"><span class="keyword">int</span> Rec[MAX], Id[MAX], Aft[MAX] ;<span class="keyword">int</span> N, tot ;</span><br><span class="line"><span class="keyword">int</span> M[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>][<span class="number">2</span>], head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">0</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">        M[Ls(rt)] = T[rt][<span class="number">0</span>], M[Rs(rt)] = T[rt][<span class="number">0</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>], T[Ls(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>]; </span><br><span class="line">        T[rt][<span class="number">0</span>] = <span class="number">-1</span>, T[Rs(rt)][<span class="number">1</span>] = <span class="number">0</span>, T[Ls(rt)][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">1</span>])&#123;</span><br><span class="line">        M[Ls(rt)] += T[rt][<span class="number">1</span>], M[Rs(rt)] += T[rt][<span class="number">1</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>], T[Ls(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>] ; </span><br><span class="line">        T[rt][<span class="number">1</span>] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T[rt][<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;M[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">0</span>] = M[rt] = k, T[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">1</span>] += k, M[rt] += k ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> M[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; STR ;</span><br><span class="line">    <span class="keyword">while</span>(STR[<span class="number">0</span>] != <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'A'</span>) A = qr(), B = qr(), C = qr(), _Update(A, B, C) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span>) A = qr(), B = qr(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'o'</span>) A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ;    </span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'h'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。</p><h2 id="与树形-mathbb-DP-的巧妙结合"><a href="#与树形-mathbb-DP-的巧妙结合" class="headerlink" title="与树形$\mathbb{DP}$ 的巧妙结合"></a>与树形$\mathbb{DP}$ 的巧妙结合</h2><p>这个地方其实说的是一类问题。。。比如一道<del>我根本不会的</del> 经典题：</p><p>$Description$</p><p>一棵带权树，$n$个点$q$次询问，每次询问一个点的$\sum dis_{odd}$和$\sum dis_{even}$。</p><p>$\mathcal{Solution}$</p><p>其实这个题的题目意思是让我们求：</p><blockquote><p>$R$君想知道对于每个点来说，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。    </p></blockquote><p>那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？</p><p>这个东西比较简单，因为我们可以直接$dfs$。</p><p>那么如果是求所有点到所有点的距离和呢？</p><p>换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。</p><p>我首先忽略边权，令边权都是$1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道<strong>根节点到所有点的距离之和</strong>，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？</p><p>我们会发现，此时我们知道的量，同一般的树形$DP$或者说树形结构不同，我们现在已经知道了<strong>每一个子树的根节点的讯息；</strong>而平常的树形结构，我们知道的则是<strong>子节点的讯息$or$子树的讯息</strong>，这一点提示我们：<strong>反向$DP$</strong></p><p>我们不妨设$dp_u$表示$\sum \limits_{i \in T}^{}{dist(i,u)}$ 那么我们思考如何构造相邻两层的状态转移方程：</p><p>首先，我们已经决定反向$DP$，换句话说就是<strong>用父亲推出儿子</strong>；并且我们了解到，对于某一个点$u$，他的<strong>所有子节点到他的距离要比到他的父亲的距离少$1$</strong>（假设边权$=1$），同时所有<strong>除其子树之外的所有点到他的距离会多$1$</strong>.那么转移方程旧顺水推舟地：</p><h3 id="dp-v-dp-u-subsize-v-n-subsize-v-v-in-son-u"><a href="#dp-v-dp-u-subsize-v-n-subsize-v-v-in-son-u" class="headerlink" title="$dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$"></a>$dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$</h3><p>那么接下来我们思考，当边权不为$1$的时候呢？我们可以稍微魔改一下上式，于是就得到</p><h3 id="dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-N-cdot-pre-v"><a href="#dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-N-cdot-pre-v" class="headerlink" title="$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + N \cdot pre_v$"></a>$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + N \cdot pre_v$</h3><p>其中$pre_i$表示节点$i$的上行边，即父亲与它相连的那条边。</p><p>那么以上简单版本的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAX] ; <span class="keyword">int</span> head[MAX], cnt ; </span><br><span class="line"><span class="keyword">int</span> N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">sub[now] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">build(to(k), now) ;  </span><br><span class="line">sub[now] += sub[E[k].to], dp[<span class="number">1</span>] += sub[E[k].to] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwork</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[k].to == f) <span class="keyword">continue</span> ;</span><br><span class="line">dp[E[k].to] = dp[now] - <span class="number">2</span> * sub[E[k].to] + N ;</span><br><span class="line">fwork(to(k), now) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), _Add(A, B) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">0</span>) ; fwork(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一值得注意的地方就是其中$dp_1$或者说$dp_{root}$的处理。那么其实这个地方我们只需要不断加$size$即可。</p><p>高端版本的问题，代码类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">Sub[now] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">build(to(k), now) ;  Pre[to(k)] = E[k].v ;</span><br><span class="line">Sub[now] += Sub[to(k)], dp[<span class="number">1</span>] += Pre[to(k)] * Sub[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">dp[to(k)] = dp[now] - <span class="number">2</span> * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C), Add(A, B, C) ;;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">0</span>) ; dp_work(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。</p><p>我们致力于维护这样一个东西：对于每个$u \in T$， 我们试图确定除$u$及其子树外，到$u$点距离是奇数的点的个数$S0$$\&amp;$距离是偶数的点的个数$S1$，以便于状态转移时，作为第二部分。那么平均树高下，直接在$dfs/bfs$里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要$swap$一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）：</p><p>$$dp[to(k)][0] = dp[now][1] - Sub[to(k)][0] <em> Pre[to(k)] \ dp[to(k)][1] = dp[now][0] - Sub[to(k)][1] </em> Pre[to(k)] ，\ dp[to(k)][0] += S0 <em> Pre[to(k)] , \ dp[to(k)][1] += S1 </em> Pre[to(k)] ;$$</p><p>其中$to(k) \in son_{now}$</p><p>而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）：</p><p>$$dp[to(k)][1] = dp[now][1] - Sub[to(k)][1] <em> Pre[to(k)] ;\ dp[to(k)][0] = dp[now][0] - Sub[to(k)][0] </em> Pre[to(k)] ;\        dp[to(k)][1] += S1 <em> Pre[to(k)],\         dp[to(k)][0] += S0 </em> Pre[to(k)] ;$$</p><p>于是就结束了。其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句：</p><h3 id="dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-Count-cdot-pre-v"><a href="#dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-Count-cdot-pre-v" class="headerlink" title="$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_v$"></a>$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_v$</h3><p>其中$Count$表示某种神秘的计数。。。。</p><p>那么其实这种问题还可以拓展到“求对于每一个点$u$，$dist(u,v) \mod n =k$的点的个数，其中$k \in [0,k-1]$，我感觉做法应该会类似吧<del>（但是我肯定不会做因为根本不可能调的出来）</del></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>没啥好说的，只觉得第三模块的例题十分难调！十分难调！！！并且……我一开始没用$S0$或者$S1$，直接用的根节点的$sub_0$和$sub_1$，最后才法案根本不和逻辑。。。但他居然过样例了。。。</li><li>转移的时候还是需要有一个清醒的思路再code啊！</li><li>$DP$好啊！</li></ul>]]></content>
    
    <summary type="html">
    
      一类比较简单的树上路径统计问题
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模型" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="树形DP" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="树模型" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="轻重链剖分" scheme="http://www.orchidany.cf/tags/%E8%BD%BB%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>线性规划入门·单纯形</title>
    <link href="http://www.orchidany.cf/2019/03/15/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <id>http://www.orchidany.cf/2019/03/15/线性规划/</id>
    <published>2019-03-14T23:06:47.000Z</published>
    <updated>2019-04-05T08:41:48.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>许久之前开始学的算法了…今天终于学完了。主要参考的材料是董克凡的$2016$集训队论文和$\rm{Candy?}$的代码整理，在此处致以敬意。</p><hr><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>首先明确，线性规划主要解决的问题是：</p><p>$$<br>\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)<br>$$<br>不失一般性的，我们定义最大化的函数为<strong>目标函数($\rm{Aim-Func}$)</strong> ，定义约束函数的集合为<strong>约束函数集($\rm{Constraint-Set}$)</strong>。那么朴素的线性规划可以看求一组向量{$x_1,x_2\cdots x_n$}，使之既可以做约束函数的因变量，又满足其目标函数的值为$max​$。</p><p>同时，规定所有的$x$均满足$x&gt;0$。</p><p>当然，存在一种更加赏心悦目的矩阵表示方式：<br>$$<br>\text{最大化}\quad \boldsymbol{c^Tx} \\<br>\text{满足约束} \quad A\boldsymbol{x\leq b} \\\<br>\it{\qquad \qquad \quad} \boldsymbol {x} \geq 0<br>$$<br>其中$\boldsymbol{c,x,b}$均为一维向量，$A$为系数矩阵。</p><p>那么我们在高中数学必修五里面运用的智障做法是，通过每个约束确定一个凸包，再用目标函数不断平移以求得与凸包的切点/切线来达到最大值，但是这样的做法通常不具有一般性。所以需要引入一种更常用的方法来解决这类问题。</p><h1 id="rm-0x02-quad-松弛型矩阵与-rm-Pivot-操作"><a href="#rm-0x02-quad-松弛型矩阵与-rm-Pivot-操作" class="headerlink" title="$\rm{0x02\quad}$ 松弛型矩阵与$\rm{Pivot}$操作"></a>$\rm{0x02\quad}$ 松弛型矩阵与$\rm{Pivot}$操作</h1><p>我们考虑一种更加友好的线性规划方式——<strong>松弛型矩阵</strong>，即将原来的矩阵添加几个无实际作用的新变量$x_i$，使之换一个样子：<br>$$<br>\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\<br>\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} \quad (i = 1,2,3\cdots m) \\ \qquad\quad  x_j \geq 0\quad (j=1,2,3\cdots n+m)<br>$$<br>两种表示是等价的，但是我们更倾向于松弛型这种简洁的表述方式。</p><p>同时我们规定以下：</p><p>$1.$基变量：在松弛型约束中，等式左边的变量。</p><p>$2.$非基变量：在松弛型约束中，等式右边的变量。</p><p>那我们定义一次<strong>转轴操作$(pivot)$</strong>为<strong>将一个基变量换进等式右边，换出一个非基变量的过程</strong>。</p><p>假设我们在第$i$组约束中，有一个变量$x_k~(k&gt;n)$是基变量，我们要换出一个非基变量$x_p~(1\leq p\leq n)$，那么就会由：<br>$$<br>x_k= b_i -\sum \limits_{j=1}^{n} a_{i,j}x_{j}<br>$$<br>变成<br>$$<br>x_p = \frac{b_i - \sum \limits_{j\neq p}a_{i,j}x_j -x_k}{a_{i,p}}<br>$$<br>而单纯性做法的本质就是通过不断转轴，实现目标函数不断变大。</p><p>看上去似乎比较抽象？我们考虑对一次转轴操作，我们需要在转轴之后将原来目标函数里的非基变量代入，即用$(b_i - \sum _{j\neq p}a_{i,j}x_j -x_k)/a_{i,p}$这个东西去替换掉$x_p$，那么其中的常数项$\frac{b_i}{a_{i,p}}$就可以作为目标函数中的一个常数值，当$x_i~(i=1,2,3\cdots n)$均为$0$时，目标函数的值即为此。那么转轴操作就是通过这样的操作使得目标函数里的常数值不断增大，达到最优解。</p><p>注意，转轴之后的得到的$x_p$的表达式，不仅要代入目标函数，也要代入其余的约束。</p><h1 id="rm-0x03-quad-rm-Simplex"><a href="#rm-0x03-quad-rm-Simplex" class="headerlink" title="$\rm{0x03}\quad \rm{Simplex}$"></a>$\rm{0x03}\quad \rm{Simplex}$</h1><p>那么接下来，我们考虑单纯性做法的完整过程。</p><p>不失一般性的，我们假设所有$b_i\geq 0$</p><p>首先，我们对于转轴操作结束，回代一次之后，会发现目标函数中肯定会有至少一项系数变为负值，即转进来的前·基变量$x_k$，那么增大$x_k$一定会让结果目标函数变小。所以我们可以断言，<strong>当目标函数里的所有变量系数均为负值时，目标函数的最优值就会是现在目标函数中的常数值</strong>——因为我们在前文已经假定$x_i\geq 0$了。</p><p>同样，我们每次转轴操作需要保持原来线性规划的不变性，换句话说就是我们每次转轴时<strong>都需要找一个对与某个非基变量限制最紧的约束，将其换出</strong>。原因是我们考虑目标函数中的$x_i$，当其系数$\geq 0$时，$\rm{Aim  }\propto x_i$，所以我们需要找一个最紧的约束<strong>遏止</strong>$x_i​$的增长(即使我们不想)。</p><p>那么伪代码如下，$A,\boldsymbol{b,c}$的定义一开始已给出：</p><hr><p>Simplex(A, b, c){<br>$\qquad$ initialization(A,b,c)  ;<br> $\qquad$ while $∃e$ that $c_e&gt;0${<br>$\qquad$$\qquad$find the index $l$ that $A_{l,e}$ $&gt; 0$ and minimizes $b_l/A_{l,e}$<br>$\qquad$$\qquad$if $∀l, A_{l,e} ≤ 0$<br>$\qquad$$\qquad$$\qquad$return Unbounded ;<br>$\qquad$$\qquad$else<br>$\qquad$$\qquad$$\qquad$pivot(A, b, c, l, e)；<br>}</p><hr><p>值得注意的是，如果在寻找完最紧约束后，存在一个$A_{l,e} \leq 0$，那么我们在这组约束里无论怎么增大$x_e$都会使得目标函数增大，所以直接<code>return Unbounded</code>。</p><p>此时我们还需要进行额外的操作，即初始化。因为我们转轴操作的目的是使目标函数增大，所以我们需要保证所有的$b_i\geq 0$，但一开始给定的$b_i$很可能不满足这一约束，所以我们需要进行一次初始化。那么对于初始化，我们的思想是做另一次线性规划。<del>鬼知道那些发明这玩意儿的神仙怎么构造出的这个线性规划。</del></p><p>我们考虑一个这样的线性规划：<br>$$<br>\text{最大化}\quad -x_0 \\<br>\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} +x_0\quad (i = 1,2,3\cdots m)\\<br>\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=0,1,2,3\cdots n)<br>$$<br>首先，无论怎样，先思考他会不会对原来的线性规划产生什么影响——答案是：不会。因为我们考虑当$-x_0$最大时，一定是$x_0=0$的时候。所以对于约束中的$x_{n+i}$，大小不会变化。</p><p>那么我们考虑这种初始化方式的正确性。我们考虑每次都将$x_0$作为换入变量(即我们一开始将$x_0$视作非基变量)，那么$pivot$之后就会有<br>$$<br>x_0 = -b_i+x_{i+n}+\sum\limits_{j=1}^{n}a_{i,j}x_j<br>$$<br>由于我们一定找的时限制最小的，那么$b_i&lt;0\Longrightarrow-b_i &gt;0$，这组约束合法。</p><p>对于其余的约束，我们考虑代入之后，会有：<br>$$<br>x_{n+k}= b_k-b_i+\sum\limits_{j=1}^{n}(a_{k,j}-a_{i,j})x_j+x_{i+n}<br>$$<br>由于$b_i$最小，那么$b_k\geq b_i \Longrightarrow b_k-b_i\geq 0$。任务完成。</p><p>那么就可以愉快地上代码辣(≧▽≦)/！题目来自于<a href="http://uoj.ac/problem/179" target="_blank" rel="noopener">$\rm{UOJ179}​$</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e15</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, T, Id[MAXN], i, j ; <span class="keyword">double</span> A[MAXN][MAXN], Get[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    swap(Id[N + l], Id[e]) ;<span class="comment">//交换两个变量</span></span><br><span class="line">    <span class="keyword">double</span> t = A[l][e] ; A[l][e] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= N ; ++ i) A[l][i] /= t ;<span class="comment">//类似于高斯消元的第一步，把这一项挪到等式右边，所以要先都除以系数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= M ; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(A[i][e]) &gt; eps)</span><br><span class="line">            <span class="keyword">for</span>(t = A[i][e], A[i][e] = j = <span class="number">0</span> ; j &lt;= N ; ++ j) </span><br><span class="line">              A[i][j] -= A[l][j] * t ;<span class="comment">//此处则是代换。而由于代数式中肯定不会出现我们的A_&#123;i,e&#125;(毕竟是换到了等式右边)，所以对于这一项的系数要特殊处理成0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span> ; <span class="keyword">double</span> t = -eps ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][<span class="number">0</span>] &lt; t) l = i, t = A[i][<span class="number">0</span>] ; <span class="keyword">if</span>(!l) <span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//找系数最小的负值项</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; <span class="number">1</span>))) e = j ;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Infeasible"</span>), <span class="literal">false</span> ;  Pivot(l, e) ;</span><br><span class="line">    &#125;<span class="comment">//不合法的线性规划，因为我们假设全部的系数都为正，且我们前面已经假定了全部x_i为正，那么不可能满足标准型里面的小于b_l——此时b_l为负值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, e = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[<span class="number">0</span>][j] &gt; eps) &#123; e = j ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span>(!e) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][e] &gt; eps &amp;&amp; A[i][<span class="number">0</span>] / A[i][e] &lt; MAX) MAX = A[i][<span class="number">0</span>] / A[i][e], l = i ;<span class="comment">//选个最紧的约束</span></span><br><span class="line">        <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Unbounded"</span>), <span class="literal">false</span> ; Pivot(l,e) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; T ; srand(<span class="number">19260817</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Id[i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; A[<span class="number">0</span>][i] ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; <span class="built_in">cin</span> &gt;&gt; A[i ++][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="built_in">cin</span> &gt;&gt; A[i][j] ; </span><br><span class="line">    <span class="keyword">if</span> (!(Init() &amp;&amp; Simplex())) <span class="keyword">return</span> <span class="number">0</span> ; <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, -A[<span class="number">0</span>][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) Get[Id[N + i]] = A[i][<span class="number">0</span>] ; </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%.8lf "</span>,Get[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然鹅事实上这份代码只有$97pts​$…好像剩下3分就几乎没有人得过，除了kcz和std……</p><p>至于中间的<code>srand</code>，是由于我们随便$pivot$一个$e$就好，于是就<del>听长者的</del>。</p><h1 id="rm-0x04-quad-Afterwords"><a href="#rm-0x04-quad-Afterwords" class="headerlink" title="$\rm{0x04}\quad Afterwords$"></a>$\rm{0x04}\quad Afterwords$</h1><p>一直想学，一直没有机会学。</p><p>说起来确实有点儿小激动。第一次写单纯型的代码是前不久的一次周末，早上点起来之后头昏脑涨地扑向Candy?的博客，学了起来。在那之后才发现原来线性规划并不常考，甚至说，不考。但是我挺喜欢这种感觉，<del>感觉自己仿佛比出题人会的还多</del></p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$Candy?$的$blog$ <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li></ul>]]></content>
    
    <summary type="html">
    
      一类在约束条件下求解目标函数最大最大值的方法，通常利用其对偶性转化，并利用松弛型矩阵进行转轴($pivot$)操作求得最值。
    
    </summary>
    
      <category term="-学习笔记 -线性规划" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
    
      <category term="线性规划/单纯形法" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>随想六·难</title>
    <link href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/"/>
    <id>http://www.orchidany.cf/2019/03/10/随想六·Hard/</id>
    <published>2019-03-10T08:06:42.000Z</published>
    <updated>2019-03-20T08:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">$Link$</a></p><h2 id="text-Part0"><a href="#text-Part0" class="headerlink" title="$\text{Part0}$"></a>$\text{Part0}$</h2><p>不知道为什么，最近的心绪颇不宁静。</p><p>那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。</p><p>我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。</p><p>这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。</p><p>毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。</p><p>就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。</p><h2 id="text-Part1-cdot-Her"><a href="#text-Part1-cdot-Her" class="headerlink" title="$\text{Part1}\cdot Her$"></a>$\text{Part1}\cdot Her$</h2><p>“她”是谁？</p><p>我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系：</p><blockquote><p>头一次清晨在无人的校园里闲逛，<br>耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，<br>眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。<br>一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。<br>好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光——</p></blockquote><p>最后一句本来是<code>但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系</code>，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。</p><p>我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。</p><p>我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？……</p><p>以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说：</p><blockquote><p>大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。</p></blockquote><p>她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。</p><h2 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h2><p>我很烦。</p><p>机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。</p><p>我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年<code>NOIP</code>考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？</p><p>好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊…</p><p>最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了……</p><h2 id="rm-Part4"><a href="#rm-Part4" class="headerlink" title="$\rm{Part4}$"></a>$\rm{Part4}$</h2><p>不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。</p><p>其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望：</p><blockquote><p>我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。</p><p>同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。</p><p>如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。</p><p>没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。</p><p>保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙——</p><p>你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？</p><p>你知道每年有多少初中生在NOIp中碾压高中生吗？</p><p>你不知道。</p><p>每天几个小时？</p><p>做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。</p><p>你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。</p><p>我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。</p></blockquote><p>看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。</p><p>为什么会这么难呢？我不知道啊。</p><p>我只知道我的机会确乎是不多了。</p><p>今年省选还有没有戏呢？我也不知道。</p><p>我只知道我的时间不多了。</p><p>不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。</p><p>呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。</p><p>这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。</p>]]></content>
    
    <summary type="html">
    
      最近心绪颇不宁静。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>BSGS-Senior·扩展的BSGS</title>
    <link href="http://www.orchidany.cf/2019/02/22/exBSGS/"/>
    <id>http://www.orchidany.cf/2019/02/22/exBSGS/</id>
    <published>2019-02-22T13:10:55.000Z</published>
    <updated>2019-03-16T13:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><hr><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>$emmm$严格来讲，不应该被算到一个模板里面。因为在我看来<strong>模板</strong>是人构造出来的，但是这个算法应该是一个解决问题的$process$…更像是在解一道数学题，如果$BSGS$是定理的话，$exBSGS$更像是一个不断转化的过程233（手动@lxa并且溜</p><h1 id="rm-0x02-quad-Algorithm-Process"><a href="#rm-0x02-quad-Algorithm-Process" class="headerlink" title="$\rm{0x02\quad Algorithm~Process}$"></a>$\rm{0x02\quad Algorithm~Process}$</h1><p>今天才发现原来$\rm{BSGS}$有两种写法……并且觉得剩下的题解讲的都讲的不是很全的样子233。</p><p>其实本质上，当$p$不为素数时，我们无法进行朴素$\rm{BSGS}$的原因是我们的欧拉定理$a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理$(a,p)=1$的情况。那么我们知道，朴素的$\rm{BSGS}$的关键在于，可以保证最小解是有界的——$x$一定在$[1,\varphi(p)]$中。所以最后$BSGS$的复杂度才会是$\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的$p$是素数的情况下，时间复杂度为$\Theta(p)$。</p><p>那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。</p><p>我们思考，对于同余式$a^x\equiv b~(\bmod p)​$而言，我们先假定$(a,p)&gt;1 ​$。而此时如果有$((a,p), b)=1​$，那么说明此式只有可能在$x=0,b=1 ​$的时候有解——这个结论是平凡的。因为假设我们把它展开成$a\cdot a^{x-1} +kp=b ​$的形式，必须要有$(a,p)  ~|~ b​$的情况下，才能保证$a^{x-1}​$和$k ​$都是整数。</p><p>那么对于$(a,p)&gt;1$且$(a,p)~|~b $，我们令原式变成</p><p>$$<br>a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} (\bmod \frac{p}{(a,p)})<br>$$<br>的样子，如果此时$(a^{x-1},\frac{p}{(a,p)})=1$ 的话，我们就直接解</p><p>$$<br>a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }(\bmod \frac{p}{(a,p)})<br>$$<br>这个方程即可。否则我们继续分解直至$(p’,a)=1$。</p><p>那么此时有个问题需要注意，就是如果们在解这个方程时，出现了</p><p>$$<br>(a^{x-1}, \frac{p}{(a,p)})\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }<br>$$<br>的情况，那我们需要特判并<code>return -1</code> ；另一种情况，如果我们出现了</p><p>$$<br>a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1(\bmod \frac{p}{(a,p)})<br>$$<br>的情况，也需要特判并输出此$k$（此时同余式左边是$a^{x-k}$，因为$a^{x-k}\equiv1~(\bmod p)$所以直接输出$k$），不过也有可能不需要，完全看你写的$BSGS$能不能判断$x=0$的情况……一般情况下不能。</p><p>此时<strong>由于$\boldsymbol{p}$不再是素数，所以不能用费马小定理，需要我们用$exgcd$的方法求逆元，包括但不限于$\frac{b}{(a,p)}$的逆元和$a^{-im}$。</strong></p><p>以下是完整版代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; H ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, ans ; <span class="comment">// N ^x = M (mod P)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a ;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b) res = ((b &amp; <span class="number">1</span>)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line"> ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll mod, ll qaq)</span></span>&#123;</span><br><span class="line">    H.clear() ; ll Q, p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), x, y ; </span><br><span class="line">    exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, </span><br><span class="line">    Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * a % mod)  <span class="keyword">if</span> (!H.count(i)) H[i] = j ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = b, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * Q % mod)  <span class="keyword">if</span> (H[i]) <span class="keyword">return</span> j * p + H[i] ; <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll qaq = <span class="number">1</span> ;</span><br><span class="line">    ll k = <span class="number">0</span>, qwq = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">while</span> ((qwq = gcd(N, P)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (M % qwq) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ;</span><br><span class="line">        <span class="keyword">if</span> (qaq == M) <span class="keyword">return</span> k ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (qwq = BSGS(N, M, P, qaq)) == <span class="number">-1</span> ? <span class="number">-1</span> : qwq + k ;</span><br><span class="line">&#125;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;P, &amp;M); <span class="keyword">if</span> (!N &amp;&amp; !M &amp;&amp; !P) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        N %= P, M %= P, ans = exBSGS() ; <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x03-quad-Afterword"><a href="#rm-0x03-quad-Afterword" class="headerlink" title="$\rm{0x03\quad Afterword}$"></a>$\rm{0x03\quad Afterword}$</h1><p>今天才知道原来$BSGS$有两种写法qaq</p><p>$zyf2000$好像和我写的$BSGS$对“大步”和“小步”的定义不是很一样…于是最后还是自己$\rm{yy}$的233</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$zyf2000$的$blog$ <a href="https://blog.csdn.net/clove_unique/article/details/51227328" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul>]]></content>
    
    <summary type="html">
    
      众所周知，朴素的$BSGS$并不可以解决$p​$不为素数的问题。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="BSGS/exBSGS" scheme="http://www.orchidany.cf/tags/BSGS-exBSGS/"/>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>多项式1.5·拆系数FFT</title>
    <link href="http://www.orchidany.cf/2019/02/19/FFT2/"/>
    <id>http://www.orchidany.cf/2019/02/19/FFT2/</id>
    <published>2019-02-19T14:00:05.000Z</published>
    <updated>2019-03-17T13:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt=""></p><p>上一篇多项式：<a href="http://www.orchidany.cf/2019/02/19/FFT1/">多项式1·普通的FFT</a></p><hr><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。</p><p>由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做<del>抄</del>完，所以就先整理地仓促一点。</p><p>首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接<code>long long</code>爆艹。</p><h1 id="rm-0x02-Normal-Coefficient-Spliting-FFT"><a href="#rm-0x02-Normal-Coefficient-Spliting-FFT" class="headerlink" title="$\rm{0x02~Normal-Coefficient-Spliting~FFT}$"></a>$\rm{0x02~Normal-Coefficient-Spliting~FFT}$</h1><p>首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成<br>$$<br>A_i = a_iM+b_i~(0\leq b_i &lt;a_i) \\<br>B_i = c_iM+d_i~(0\leq d_i &lt;c_i)<br>$$<br>的形式。然后我们做乘法的话，会有<br>$$<br>A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i<br>$$<br>那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。</p><p>那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$</p><p>$$b_i\cdot d_i \approx \Theta(M^2)$$</p><p>$$a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)$$</p><p>$$(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor) $$</p><p>那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], L, x ; <span class="keyword">long</span> <span class="keyword">long</span> Ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + <span class="number">0.5</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; </span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, t ; <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = <span class="number">32767</span> ; N = <span class="number">1</span>, t = L1 + L2 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; </span><br><span class="line">    <span class="keyword">while</span>(N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ L ; rep(i, <span class="number">0</span>, N) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>), FFT(C, <span class="number">1</span>), FFT(D, <span class="number">1</span>) ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; </span><br><span class="line">    FFT(H1, <span class="number">-1</span>), FFT(H2, <span class="number">-1</span>), FFT(H3, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        Ans[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)H1[i].x * M % P * M % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H2[i].x % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H3[i].x * M % P) % P ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。</p><p>但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是——</p><h1 id="rm-0x03-Conjugate-Optimization"><a href="#rm-0x03-Conjugate-Optimization" class="headerlink" title="$\rm{0x03~Conjugate~Optimization}$"></a>$\rm{0x03~Conjugate~Optimization}$</h1><p>源自毛啸的《再探快速傅立叶变换》。</p><p>我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$<br>$$<br>\rm{P(x) = A(x) + iB(x)} \\<br>\rm{Q(x) = A(x) - iB(x)}<br>$$<br>我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。</p><p>同时，令$\text{conj(x)}$表示对$x$取共轭。</p><p>那么会有$^{[5]}$：<br>$$<br>\begin{align}<br>P’[k] &amp;= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\<br>&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\<br>&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; =  \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}<br>\\<br>Q’[k] &amp;= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\<br>&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\<br>&amp; = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\<br>&amp; = \text{conj} \left( P’[n-k] \right)<br>\end{align}<br>$$<br>好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。</p><p>那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：<br>$$<br>A’[k] = \frac{P’[k] + Q’[k]}{2} \\<br>B’[k] = \frac{P’[k] - Q’[k]}{2i}<br>$$<br>哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$.</p><p>以下是共轭优化$FFT$的初号机：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], Len, x, Ans[MAXN] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node(r, -i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                node T = w[N / j * l] ; T.i *= flag ;</span><br><span class="line">                node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; <span class="keyword">while</span> (N &lt;= L) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node ia, ib, a1, a2, b1, b2 ;</span><br><span class="line">    rr <span class="keyword">int</span> i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  FFT(t1, <span class="number">-1</span>), FFT(t2, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / N + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / N + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / N + <span class="number">0.5</span>) % P, Ans[i] = ((((<span class="keyword">long</span> <span class="keyword">long</span>)q3 &lt;&lt; <span class="number">30</span>) % P + ((<span class="keyword">long</span> <span class="keyword">long</span>)q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P + P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) f[i] = qr() % P ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x04-quad-拼命卡常"><a href="#rm-0x04-quad-拼命卡常" class="headerlink" title="$\rm{0x04\quad}$拼命卡常"></a>$\rm{0x04\quad}$拼命卡常</h1><p>好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$）</p><p><img src="1.png" alt=""></p><p>然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）：</p><p><img src="2.png" alt=""></p><p>特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$:</p><p><img src="3.png" alt=""></p><p><img src="4.png" alt=""></p><p>好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点……</p><p>于是考虑对共轭优化的进行大力卡常：</p><ul><li>多次使用的非全局变量。使用<code>register</code>修饰符。</li><li>将$double$转换成为$long~double$ 。</li><li>减少取模次数。</li><li>从yjk那里偷来的$\rm{fread/fwrite}$</li></ul><p>一番操作之后，我们成功地卡到了第五页上……</p><p><img src="5.png" alt=""></p><p>最后奉上最快的代码qwq：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 102333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 272333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[MAXM], Len, x, Ans[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node(r, -i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;<span class="comment">//定义的Complex型是用来进行复数运算的 </span></span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> <span class="keyword">double</span> &amp;Q) &#123; <span class="keyword">return</span> (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    rr node t ;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                rr node T = w[N / j * l] ;</span><br><span class="line">            rr node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + N), FFT(J) ; </span><br><span class="line">    rr <span class="keyword">int</span> i ; rr <span class="keyword">double</span> qwq = <span class="number">1.0</span> / N ; </span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) J[i] = J[i] * qwq ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    rr <span class="keyword">int</span> i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; </span><br><span class="line">    t = ((L1 = read()) + (L2 = read())), P = read(), N = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)), R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A), FFT(B) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">    IFFT(t1), IFFT(t2) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        write(((ll)(t1[i].r + <span class="number">0.5</span>) + ((ll)(t1[i].i + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">15</span>) + ((ll)(t2[i].r + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">30</span>)) % P) ;</span><br><span class="line">    fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！<br><img src="6.png" alt=""></p><h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？</p><p>但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢……</p><p>并且在学的过程中顺便认识了一个巨佬<code>CMXRYNP</code>，嘿嘿，也算不亏啦。</p><p>本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$.</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$lvzelong2014$的$blog$ <a href="https://blog.csdn.net/lvzelong2014/article/details/80156989" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[2]$:<code>无梦之梦</code>的$blog$ <a href="https://www.cnblogs.com/DreamlessDreams/p/10241267.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[3]$:$Cyhlnj$的$blog$ <a href="https://www.cnblogs.com/cjoieryl/p/10114614.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[4]$:$litble$的$blog$ <a href="https://blog.csdn.net/litble/article/details/84864516" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[5]​$:$CMXRYNP​$的$blog​$ <a href="https://cmxrynp.github.io/2019/01/07/fft-optimization/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li></ul>]]></content>
    
    <summary type="html">
    
      拆系数FFT主要用于解决不可思议的任意模数$NTT/FFT$问题，主要针对的就是【$Luogu4245·$任意模数NTT】这道题。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-FFT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-FFT/"/>
    
  </entry>
  
  <entry>
    <title>多项式1·普通的FFT</title>
    <link href="http://www.orchidany.cf/2019/02/19/FFT1/"/>
    <id>http://www.orchidany.cf/2019/02/19/FFT1/</id>
    <published>2019-02-19T03:26:08.000Z</published>
    <updated>2019-03-18T08:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>这篇文章初写于$7/1/2018$，是在陪同好友$yjk$与$wx$以及学长$rqy$一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍$FFT$并且写$MTT$，于是便有了这篇文章。</p><p>其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的<code>orchidany</code>特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。</p><p>但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。</p><h1 id="rm-0x02-quad-Convolution"><a href="#rm-0x02-quad-Convolution" class="headerlink" title="$\rm{0x02\quad Convolution}$"></a>$\rm{0x02\quad Convolution}$</h1><p><strong>卷积$\boldsymbol{(Convolution)}$</strong>，准确来说是一种<strong>通过两个函数$\boldsymbol f$ 和$\boldsymbol g​$ 生成第三个函数的一种数学算子.</strong></p><p>而广义上其定义为：$$\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}$$</p><p>我们称$h(x)$是$g(x)$与$f(x)$的<strong>卷积</strong>。</p><p>而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到</p><p>$$A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}} $$<br>其中$A(x)$和$B(x)$均为$N-1$次多项式<br>比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有$2n+1$项。</p><h1 id="rm-0x03-quad-Dot-Method"><a href="#rm-0x03-quad-Dot-Method" class="headerlink" title="$\rm{0x03\quad Dot~Method}$"></a>$\rm{0x03\quad Dot~Method}$</h1><p>我们知道，原本的多项式是系数表示法，现在我们将其转化为<strong>点值表示法$(\boldsymbol{dot~method} )$</strong>。即我们可以把多项式$F(x)$转化为多项式函数$f(x)$，那么这个$n$阶函数就可以由$n+1$个点唯一确定。即$$f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)….(x_n,y_n)}$$那么$$\forall k,y_k = f(x_k)$$这是很显然的，并且这$n+$个点是随意选取的——只要求它们相异即可。</p><ul><li><h2 id="rm-Advanced-Trick-Point-color-red-1-rm-Multiplication"><a href="#rm-Advanced-Trick-Point-color-red-1-rm-Multiplication" class="headerlink" title="$\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$"></a>$\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$</h2></li></ul><p>假设我们有两个关于$x$的$n+1$次多项式$A(x)$和$B(x)$，我们要对它的点值表达式进行乘法操作。由于结果有$2n+1$项，我们考虑补上一堆项，并对$$A(x) = {(x_0,y_0),(x_1,y_1)….(x_{2n},y_{2n})}$$ $$B(x) = {(x_0,y_0’),(x_1,y_1’)….(x_{2n},y_{2n})}$$ 做乘法可得 $$A(x)B(x) = {(x_0,y_0y_0’),(x_1,y_1y_1’)(x_{2n},y_{2n}y_{2n}’)}$$  </p><p>我们观察点乘法，它的时间复杂度达到了$\Theta(n)$，完全可以接受。那么不妨先看一下算法的大体思路：</p><blockquote><p>对于每个因子多项式，选取$n+1$个点，得出点值表达式（复杂度$\Theta(n^2)$） $\longrightarrow$点乘法(时间复杂度$\Theta(n)$)——&gt;将得出来的$C(x)$的点值表达式再转换成系数表达式(复杂度$\Theta(n^2)$)</p></blockquote><p>这就是$FFT$的大体流程。<del>转化之后怎么没多快常数还大了</del></p><p>虽然其余部分的时间复杂度还是很麻烦的$O(n^2)$，但是都是可以优化成$O(nlogn)$的。</p><hr><p>本质上的$FFT$包含<strong>$\boldsymbol{DFT}$（离散傅立叶变换）</strong>和<strong>$\boldsymbol{IDFT}$（逆离散傅立叶变换）</strong>实际上，<strong>$DFT$</strong>对应着的就是<strong>把系数表达式映射到点值表达式</strong>的过程，<strong>$IDFT$</strong>对应着的就是我们<strong>把点值表达式映射到系数表达式</strong>的过程。</p><h1 id="rm-0x04-Base-of-Optimization"><a href="#rm-0x04-Base-of-Optimization" class="headerlink" title="$\rm{0x04~Base ~of~Optimization}$"></a>$\rm{0x04~Base ~of~Optimization}$</h1><p>因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到$nlogn$的，那么总的时间复杂度，渐进意义下就是$O(nlogn)$的。</p><p>下面就让我们来看看如何优化：</p><ul><li><h2 id="rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root"><a href="#rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root" class="headerlink" title="$\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$"></a>$\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$</h2></li></ul><p>$n$次单位复根是满足$\omega^n = 1$ 的复数$\omega$，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出<strong>$n$次单位根有$n$个</strong>这个结论——亦或者是用代数基本定理证，都可以。而又因为复数$\omega^n$在复数平面上的模都是一，所以相乘之后还会是一，那么所有的$\omega_i,1 \leq i \leq n$就会均匀分布在单位圆上，类似当$n = 8​$时它是这样的：</p><p><img src="1.png" alt=""></p><p>我们考虑欧拉公式：</p><p>$$e^{ix} = cosx + isinx$$</p><p>我们取$x =2\pi$，可以得到如下关系式：$$e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}$$</p><p>们把此时的单位根称之为<strong>主次单位根</strong>，记作$$\omega_n = e^{\frac{2\pi i}{n}} $$</p><p>那么对于其他的单位根，记作$$\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k &lt; n$$都是主次单位根的整次幂，也就是上图中的一圈。</p><hr><p>诶，这个有啥用啊$QAQ$?</p><p>那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到$nlogn$的复杂度……</p><p>那么我们先来看其支持其规模减半的引理：</p><ul><li><h3 id="frak-Elimination-Lemma-quad-消去引理"><a href="#frak-Elimination-Lemma-quad-消去引理" class="headerlink" title="$\frak{Elimination ~Lemma\quad}$消去引理"></a>$\frak{Elimination ~Lemma\quad}$消去引理</h3></li></ul><hr><blockquote><p><strong>引理：对任何整数$n \geq 0,k \geq 0,d &gt;0$,有$$\omega_{dn}^{dk} = \omega_n^k$$</strong></p></blockquote><p>$\mathcal{Proof.}$</p><p>这个好像很好证的样子……代入定义可以获得$$\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k$$<br>$\mathcal{Q.E.D.}$</p><hr><ul><li><h3 id="frak-Binary-Lemma-quad-折半引理"><a href="#frak-Binary-Lemma-quad-折半引理" class="headerlink" title="$\frak{Binary~Lemma\quad}$ 折半引理"></a>$\frak{Binary~Lemma\quad}$ 折半引理</h3></li></ul><hr><blockquote><p><strong>引理：对于任何大于$0$的偶数$n$，都有$n$个$n$次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合。</strong></p></blockquote><p>$\mathcal{Proof.}$</p><p>我们可以由消去引理得到$$(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k$$那么</p><p>$$(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2​$$</p><p>$\mathcal{Q.E.D.}$</p><hr><p>那么接下来，如果对所有的$n$次单位跟平方一下，我们会发现$\frac{n}{2}$次单位根每个都恰好出现了两次——也就是说，在$n$个$n$此单位复数根的集合（朴素的集合，即不可重集）里，只有$\frac{n}{2}$个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。</p><p>那么把所有$n$单位根的平方画到一个数列上就是这样。</p><p><img src="2.png" alt=""></p><p>这个引理直接保证了我们求值的复杂度为$\Theta(n \log n)$</p><p>而我们在代码实现中，<strong>不能直接得到$e$或者虚数$i$</strong>，所以这个时候求单位根的任务就交给了我们上文中提到过的<strong>欧拉公式</strong>。</p><ul><li><h3 id="frak-Sum-Lemma-quad-求和引理"><a href="#frak-Sum-Lemma-quad-求和引理" class="headerlink" title="$\frak{Sum~Lemma\quad}$求和引理"></a>$\frak{Sum~Lemma\quad}$求和引理</h3></li></ul><hr><blockquote><p><strong>引理：对于任意$n&gt;0$且$k$不能整除$n$，我们都有$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0$$</strong></p></blockquote><p>$Proof.$</p><p>由几何级数的求和公式（等比数列求和公式)$$\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}$$可得$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow  \frac{(\omega_n^n)^k -1}{\omega_n^k -1} =  \frac{(1)^k -1}{\omega_n^k -1}$$由于保证了$k$不可整除$n$所以分母一定不为$0.$</p><p>$\mathcal{Q.E.D}$</p><hr><h1 id="rm-0x05-quad-DFT-to-FFT"><a href="#rm-0x05-quad-DFT-to-FFT" class="headerlink" title="$\rm{0x05\quad DFT \to FFT}$"></a>$\rm{0x05\quad DFT \to FFT}$</h1><p>那么我们在了解完单位复数根之后，便可以正式地对$DFT$给出定义与操作方案了。</p><ul><li><h2 id="DFT"><a href="#DFT" class="headerlink" title="$DFT$"></a>$DFT$</h2></li></ul><p>对于我们已知的一个多项式$$A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}$$在$\omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1}$处的取值，我们可以假定$n$是$2$的幂，因为即使它本身不是$2$的幂，我们也可以通过向高次幂补值为$0$的项来解决这个问题。而补足$2$的幂的目的，就是为了在$FFT$分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。</p><p>那我们现在会有一个$A$的向量组$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$，对于$k = 0, 1, 2, \cdots n -1$，定义$y_k$如下：$$y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}$$，那么向量$$\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}$$就称作系数向量$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$的<strong>离散型傅立叶变换（$\boldsymbol{Discrete   Fourier   Transformation}$）</strong>。</p><p>嗯，这个<strong>离散型</strong>我们可以由点乘法联想意会一下：本来$A(x)$是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容$qwq$），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。</p><ul><li><h2 id="FFT-优化-DFT"><a href="#FFT-优化-DFT" class="headerlink" title="$FFT$优化$DFT$"></a>$FFT$优化$DFT$</h2></li></ul><p>在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为$O(n^2)$，这是朴素算法。而我们只需要用一种被称作<strong>快速傅立叶变换（$\boldsymbol{Fast   Fourier   Transformation}$）</strong>的方式，就可以将其时间复杂度压缩成$O(nlogn)$。而在这里我们就用到了刚才证明的引理——<strong>折半引理</strong>。</p><p>我们考虑将原来的多项式$$A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}$$重定义成两个次数为$\frac{n}{2}$的小多项式$A^{[0]}(x)$和$A^{[1]}(x)$： </p><p>$$A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1}$$ $$ A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1}$$    那么也就是说，$A^{[0]}(x)$存储的是所有偶数位（二进制位最后一位是$0$），而$A^{[1]}(x)$存储的是所有的奇数位（二进制位最后一位是$1$），那么有下式：$$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$$那我们求$A(x)$在单位根们$\omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1}$处的值，就变成了先求出$A^{[0]}(x^2)$和$A^{[1]}(x^2)$的值，然后根据上式进行合并即可。</p><p>而显然的是，根据折半引理，我们根本不需要$O(n)$求，而是通过数据规模不断减小使之成为$O(\log n)$。于是，我们成功通过$FFT$优化了求值的复杂度。</p><p>那么同时对于另一边，我们可以根据</p><p>$$A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})$$</p><p>得到</p><p>$$A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})$$</p><p>从而有伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Lim = <span class="number">1</span>, N, M ;</span><br><span class="line"><span class="function">function <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> lenth, <span class="keyword">complex</span> *A, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">IF (Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">complex</span> A0[lenth &gt;&gt; <span class="number">1</span>], A1[lenth &gt;&gt; <span class="number">1</span>] ;<span class="comment">//分成两部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to lenth by_grow <span class="number">2</span>) A0[j &gt;&gt; <span class="number">1</span>] = A[j], A1[j &gt;&gt; <span class="number">1</span>] = A[j + <span class="number">1</span>] ;</span><br><span class="line">FFT(lenth &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">FFT(lenth &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line"><span class="keyword">complex</span> Wn = unit(,) , w = (<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂</span></span><br><span class="line">        <span class="comment">/*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to (lenth &gt;&gt; <span class="number">1</span>) by_grow <span class="number">1</span> with w = w * Wn)&#123;</span><br><span class="line">A[i] = A0[i] + A1[i] * w ;<span class="comment">//应用公式，下同 </span></span><br><span class="line">A[i + (lenth &gt;&gt; <span class="number">1</span>)] = A0[i] - A1[i] * w ; <span class="comment">//顺便求出另一半，由折半引理可显然。 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">function Main&#123;</span><br><span class="line">input(N), input(M) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to N by_grow <span class="number">1</span>) =&gt; input(A) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to M by_grow <span class="number">1</span>) =&gt; input(B) ; </span><br><span class="line"><span class="keyword">while</span>(Lim &lt; N + M) Lim &lt;&lt;= <span class="number">1</span> ;<span class="comment">//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分）</span></span><br><span class="line">FFT(Lim, A, <span class="number">1</span>) ;<span class="comment">//两遍FFT表示从系数化为点值 </span></span><br><span class="line">FFT(Lim, B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to Lim by_grow <span class="number">2</span>) =&gt; A[i] *= B[i] ;<span class="comment">//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是基于$pks$标准下的伪代码<del>你可以试试在c++标准下运行</del>，其中$for$循环部分，$grow$表示当前循环变量的<strong>单次增量</strong>，之后带有$with$表示每次循环结束都会进行的运算（下同</p><p>嗯，这就是求值的方法，好像很$nice$地达到了$O(n \log n)$</p><ul><li><h2 id="FFT-优化-IDFT"><a href="#FFT-优化-IDFT" class="headerlink" title="$FFT$优化$IDFT$"></a>$FFT$优化$IDFT$</h2></li></ul><p>上文中我们曾经提及过的<strong>范德蒙德矩阵</strong>可以放到这儿用：</p><p>$\begin{vmatrix}  1         &amp;  1  &amp; 1   &amp; \cdots &amp; 1      \newline 1         &amp;  \omega_n  &amp; \omega_n^2   &amp; \cdots &amp; w_n^{n-1}      \\newline1         &amp;  \omega_n^2  &amp; \omega_n^4   &amp; \cdots &amp; \omega_n^{2(n-1)}      \newline \vdots  &amp; \vdots &amp; \vdots  &amp;  \ddots &amp; \vdots \newline 1    &amp;  \omega_n^{n-1}  &amp; \omega_n^{2(n-1)}   &amp; \cdots &amp; \omega_n^{(n-1)(n-1)}        \newline  \end{vmatrix}$  $\begin{vmatrix}  a_0  \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix}$ = $\begin{vmatrix}  y_0  \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix}$</p><p>那为了求出我们的$\vec{a} = {a_0, a_1 \cdots ,a_{n-1}}$我们应该让刚刚求值算出的$\vec{y}$乘上我们$\vec{V}^{~-1}$（$\vec{V}$的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下：</p><hr><blockquote><p><strong>推论</strong>：对于$j,k = 0,1, 2 \cdots n-1,V_n^{-1}$的$(j, k)$处的值为$\omega_n^{-kj}/n$</p></blockquote><p>$Proof.$</p><p>我们考虑反向证明，已知$V_n’$是一个$(j,k)$处值为$\omega_n^{-kj}/n$的、与$V$形态相同的矩阵，那我们只需要证明$V’ \cdot V = I_n$即可，其中$I_n$是$n$阶单位矩阵，即主对角线都是$1$，其余位置上是$0$的矩阵。</p><p>那么我们考察$V’ V$中的元素$(i, j)$，有如下的式子$$V’V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}$$</p><p>由<strong>求和引理</strong>当且仅当$i=j$时其值为一，其余的时刻均为零，所以有$V’V = I_n$</p><p>$\mathcal{Q.E.D}$</p><hr><p>那么我们把我们刚刚求出来的逆矩阵$V^{-1}$美化一下，提出每一项所除的$n$，可以得到$IDFT$可以如此计算：$$IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]$$诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当$flag=1$时，他是正向$DFT$；当它等于$-1$时，它是逆向的$ IDFT$。这可以让我们通过这一个函数解决两个过程。我们只需要用$y$替换$a$，用$\omega_n^{-1}$替换$\omega_n$，其余的没什么差别，于是……时间复杂度还是$O(n \log n)$的!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> Lim,<span class="keyword">complex</span> *A,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[Lim &gt;&gt; <span class="number">1</span>], A1[Lim &gt;&gt; <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Lim ; i += <span class="number">2</span>)</span><br><span class="line">        A0[i &gt;&gt; <span class="number">1</span>] = A[i], A1[i &gt;&gt; <span class="number">1</span>] = A[i+<span class="number">1</span>] ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> unit = (<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span> * Pi / Lim) , flag * <span class="built_in">sin</span>(<span class="number">2.0</span> * Pi / Lim)&#125;, w = <span class="keyword">complex</span>(<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//欧拉公式 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        A[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        A[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......................</span><br><span class="line">FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，现在嘛……可以考虑撒花花啦！因为我们的$FFT$实际上已经结束了！$But$，这个递归版本的$FFT$由于牵扯到$sin/cos$的运算、$double$、递归时的入栈出栈（底层），所以常数特别的大$emmmmm$，那么——</p><h1 id="rm-0x06-Iterative-Optimization"><a href="#rm-0x06-Iterative-Optimization" class="headerlink" title="$\rm{0x06~Iterative~ Optimization}$"></a>$\rm{0x06~Iterative~ Optimization}$</h1><p>我们现在要引出的就是迭代版的$FFTqwq$</p><h2 id="·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation"><a href="#·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation" class="headerlink" title="· $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$"></a>· $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$</h2><p>$emmm$先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        a[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会发现……$\omega \cdot A^{[1]}[i]$被执行了两次，所以我们不妨用个变量记录它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = w * A1[i] ;</span><br><span class="line">a[i] = A0[i] + t ;</span><br><span class="line">       a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>嗯，这就是全部的优化啦！那么，FFT，完！</del></p><p>$qwq$这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好$\mathcal{QAQ}$。好吧，说这个的原因，只是为了引出我们关于<strong>蝴蝶操作</strong>的定义：</p><blockquote><p>我们定义$\omega_n^k$为<strong>旋转因子</strong>，那么每一次我们先将$y_k^{[1]}$与旋转因子的乘积存储在一个变量$t$里，并在$y_k^{[0]}$增加、减去$t$的操作称为一次蝴蝶操作。</p></blockquote><p>说白了，蝴蝶操作是一次$O(2)$的求出$A^{[0]}_k$与$A^{[1]}_k$的操作。</p><hr><p>我们首先考虑按照递归的思路，将$FFT$的分治流程刻画一下：</p><p><img src="3.png" alt=""></p><p>我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下：</p><blockquote><p>$step   1$  成对地取出儿子节点，用蝴蝶操作计算出其$DFT$。<br>$step   2$  用这一步的$DFT$替换之前的；<br>$step   3$  直到我们迭代到根节点为止，否则返回$step   1$</p></blockquote><p>而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层$for$，先枚举区间长度（1，2，4，8……），第二层枚举长度为$j*2$的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间$DFT$的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举区间长度，从小区间到大区间依次合并。</span></span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;<span class="comment">//两段区间两段区间的枚举，用于合并</span></span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;<span class="comment">//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。</span></span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;<span class="comment">//一次蝴蝶操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在$DFT$的时候，为了保证时间复杂度是$\Theta(\log n)$，我们曾经进行过一次$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是$0,1,2,3,4,5,6,7$，但是迭代版的$FFT$却需要的顺序应该跟叶子结点的顺序吻合，即$0, 4, 2, 6, 1, 5,3,7$。所以——</p><ul><li><h2 id="·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law"><a href="#·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law" class="headerlink" title="· $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$"></a>· $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$</h2></li></ul><p>这个嘛……我们可以选择打个表观察：<br>原来的序号 $0        1        2        3        4        5        6         7$<br>现在的序号 $0        4        2        6        1        5        3        7$<br>原来的二进制表示 $000        001        010        011        100        101        110        111$<br>现在的二进制表示 $000        100        010        110        100        101        011        111$</p><p>诶，二进制好像是反序的嗷~~这便是我们的最后一个$trick$，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在$FFT$之前$swap$一遍即可。</p><p>嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure></p><p>呃，这个二进制计算自己推一下就好。</p><p>那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。<del>真开森啊</del></p><p>最后附迭代版的代码(我写的常数好像有点儿大$QAQ$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN] ;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;<span class="comment">//前面的if保证只换一次</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(), M = qr() ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i].x = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i].x = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">    FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(A[i].x / Lim + <span class="number">0.5</span>)) ;<span class="comment">//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊……那就撒花花吧！！</p><h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>以下是原尾语，保留了下来：</p><blockquote><p>嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短<del>这么容易背过</del>。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天$qwq$，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他$DALAO$比对审核、或者缠着$rqy$问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。</p><p>以下是温馨提示：</p><ul><li>好多自己当初不理解的地方在代码里就只有半行qaq</li><li>三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的</li></ul></blockquote><p>真 · 结束语：</p><p>其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去<code>现在看这个算法，真是简单的一匹啊</code>，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$rvalue$的$blog$ <a href="https://www.cnblogs.com/rvalue/p/7351400.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :算法导论 <a href="https://pan.baidu.com/s/13PRy8pPn__zGj3UfOTX8Ew" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码: txs2 </li><li>[3]*：鸣谢rqy</li></ul><h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
    
    <summary type="html">
    
      一类在$\Theta(nlogn)$时间复杂度内解决平凡卷积的算法，相对来说比较入门。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-FFT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-FFT/"/>
    
  </entry>
  
  <entry>
    <title>随想五·手中没有红玫瑰</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/"/>
    <id>http://www.orchidany.cf/2019/02/14/随想五·情人节/</id>
    <published>2019-02-14T14:14:41.000Z</published>
    <updated>2019-03-10T08:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">戳我</a></p><hr><p>今天下了一天的雪。</p><p>我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。</p><p>“情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。</p><p>雪真美啊。</p><hr>        <div id="aplayer-CIqMOOMq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CIqMOOMq"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "空も飞べるはず",              author: "定能飞向天空",              url: "古谷拳-空も飛べるはず (定能飞向天空).mp3",              pic: "/2019/02/14/随想五·情人节/ggq.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>早恋？</p><p>“严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”……</p><p>说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。</p><p>直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了：</p><blockquote><p>小学五年级的时候，我喜欢班上的一个女孩子。<br>那时候想的很多。<br>比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。<br>那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。<br>这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。<br>我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。</p></blockquote><blockquote><p>如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。</p></blockquote><blockquote><p>我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。<br>他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。</p></blockquote><blockquote><p>于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。<br>家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。</p></blockquote><blockquote><p>后来初三开学，我收到了一封信。<br>来自那个小学时候喜欢的女孩子。<br>信的末尾有一句话：我准备报考X中，你要不要一起？</p></blockquote><blockquote><p>我的手不受控制地颤抖。<br>烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。</p></blockquote><blockquote><p>为什么要读书呢？<br>16岁的我获得了唯一的答案——为了和喜欢的人在一起。<br>我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。<br>对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。<br>是啦，他们总以为自己很懂。</p></blockquote><blockquote><p>很多人说，小孩子不要谈感情，因为反正不会有结果。<br>是，的确不会有结果。<br>就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。</p></blockquote><blockquote><p>可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。<br>爱过一个人，是我少年时最大的幸运。</p></blockquote><blockquote><p>所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。<br>是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。</p></blockquote><blockquote><p>有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。<br>结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。</p></blockquote><blockquote><p>我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。</p></blockquote><blockquote><p>他们轻蔑地说，小孩子懂什么恋爱。<br>好，那我们来看看大人们有多么懂爱情。<br>相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。<br>夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。<br>夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。</p></blockquote><blockquote><p>所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。<br>难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？</p></blockquote><blockquote><p>还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”<br>仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。</p></blockquote><blockquote><p>可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？<br>你们是真的有的是以后，还是早已离散在人海？<br>而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？</p></blockquote><blockquote><p>很久以后我们终于知道，大人都在说谎。<br>少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。</p></blockquote><blockquote><p>如果有还在上学的读者看到这里，请记住，人生没有那么多以后。<br>有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。</p></blockquote><blockquote><p>至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。</p></blockquote><blockquote><p>我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。</p></blockquote><blockquote><p>” 很多人即使只见过一面，已经算见过了最后一面。“</p></blockquote><blockquote><p>十八岁前不早恋，这辈子都来不及早恋。<br>你的人生看起来很长，每一秒都无法挽回。</p></blockquote><p>虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。</p><p>我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。</p><p>当然，也是给我自己讲。</p><p>关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。</p><p>现在不一样了吧，一生，多长啊。</p><p>我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。</p><p>没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。</p><p>等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？</p><p>不，我觉得不是。</p><p>我是在亵渎一种感情，是在侮辱一个人。</p><p>爱从来都是无私地付出，而不是拼命的占有啊。</p><p>我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。</p><p>你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊，</p><p>都不过是拼命地想被爱而已。</p>        <div id="aplayer-rmOBqvsV" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rmOBqvsV"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "clammbon-ソナタ",              author: "(奏鸣曲)",              url: "clammbon-ソナタ (奏鸣曲).mp3",              pic: "/2019/02/14/随想五·情人节/zmq.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><hr><p>不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊……</p><p>孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。</p><p>我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。</p><p>下面是歌词：</p><blockquote><p>我喜欢暖冬的太阳<br>我喜欢初春的青草<br>我喜欢午后的庭院和一旁发呆的秋千<br>我喜欢仲夏的冰沙<br>我喜欢清秋的明月<br>良宵的夜空 漫天星辰<br>我喜欢雨后的青蛙<br>我喜欢山前的杏<br>我喜欢周三的傍晚被霞光亲吻的水族馆<br>我喜欢成群的野<br>我喜欢凌乱的书架<br>清风的露台远处的灯海<br>我喜欢 走在无人的九十六号公路<br>我喜欢 木村拓哉长长的头发<br>我喜欢 无尽田野上奔跑的麋鹿<br>我喜欢 外婆门前的榕树<br>我喜欢母亲的便当<br>喜欢父亲的胡渣<br>我喜欢八月的夜晚还在营业的游乐场<br>我喜欢放学的铃铛<br>我喜欢停电的夜晚<br>点一对蜡烛 在幽静的玄关<br>我喜欢 城市尽头那远远的青山<br>我喜欢 热气球飞上西边的天空<br>我喜欢 清晨的石板路<br>雾腾腾的早餐店 阿公的桂花糕<br>我喜欢 每一朵暮云 每一株绿树<br>我喜欢你，你应该，也知道<br>我喜欢你，你应该，也知道</p></blockquote><p>优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句——</p><blockquote><p>我喜欢你，你应该，也知道.</p><p>我喜欢你，你应该，也知道。</p></blockquote><p>很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。</p><p>你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。</p><p>有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。</p><p>我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。</p><p>我喜欢你，你应该，也知道。</p>        <div id="aplayer-UiXolTUv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-UiXolTUv"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "我喜欢",              author: "彩虹合唱团",              url: "上海彩虹室内合唱团-我喜欢 (合唱版).flac",              pic: "/2019/02/14/随想五·情人节/wxh.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><hr><p>心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？</p><p>如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。</p><p>我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。</p><p>相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。</p><p>$19/2/14$ </p><hr><p>本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。</p><p>那么就补一个深沉一点的结尾吧。</p><p>我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。</p><p>但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧……</p><p>路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。</p><p>可是面对着无奈的明天的我，什么都不能做。</p><hr><p>雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。</p>        <div id="aplayer-StUPZYLC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-StUPZYLC"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "遇见",              author: "孙燕姿",              url: "孙燕姿-遇见.flac",              pic: "/2019/02/14/随想五·情人节/yj.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      又是一年情人节啊。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019赛季最后的随想/NOIP2018游记·启示录</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/"/>
    <id>http://www.orchidany.cf/2019/02/14/随想三·NOIP/</id>
    <published>2019-02-14T14:11:50.000Z</published>
    <updated>2019-03-10T08:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">戳我</a></p><hr><p>他看着眼前的屏幕，静静地发呆。</p><p>他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。</p><p>刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。</p><p>“希望别考期望吧，嘿嘿……”他心里这么想着。</p><p>晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。</p><p>他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。</p><p>从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。</p><hr><p>早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$Mac$版，连硕鼠也不能用了，便只得作罢。</p><p>终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。</p><p>“大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。</p><p>看了看天空，他上了大巴车。</p><hr><p>”昌邑一中真大啊“这是他到这儿后的第一想法。</p><p>到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。</p><p>宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。</p><p>他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。</p><hr><h2 id="rm-Day-1"><a href="#rm-Day-1" class="headerlink" title="$\rm{Day~1}$"></a>$\rm{Day~1}$</h2><p>突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。</p><p>考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。</p><p>入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。</p><p>$T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。</p><p>$T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。</p><p>$T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。</p><p>期望得分$100pts + random(0,100)+random(10,20) $</p><p>$Luogu$数据$100pts + 65pts + 15pts = 180pts$</p><p>听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。</p><p>下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。</p><p>考挂了，他想到。</p><p>这世界上似乎就他一个不会$T2$的人。</p><p>他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。</p><p>虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。</p><p>或许他期望着明天能翻盘？</p><p>晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。</p><hr><h2 id="rm-Day-2"><a href="#rm-Day-2" class="headerlink" title="$\rm{Day~2}$"></a>$\rm{Day~2}$</h2><p>今天他没有带什么吃的。</p><p>$T1$只会$60$分，转眼去看$T2$</p><p>写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。</p><p>$T3$连想的时间都没有。</p><p>退役了。</p><hr><p>他很伤心。</p><p>回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。</p><p>他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。</p><p>他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。</p><p>其余的都考炸了。</p><p>初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。</p><p>他一开始也并不怎样，没啥感觉。</p><p>直到那天下午。</p><hr><p>他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。</p><p>兴奋的他去奥赛室看成绩。</p><p>学长看错了。</p><p>他的两个同僚都是$370/380+$的样子。</p><p>只有他不到.</p><p>其他人的分数也比他高。</p><p>他大概全校第十几吧。</p><p>他感到了绝望。</p><p>本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。</p><p>他注定是失败者。</p><p>他伤心极了。</p><hr><p>他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。</p><p>他觉得一年来，他一事无成。</p><p>或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。</p><p>他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。</p><p>他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。</p><p>期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。</p><p>这似乎是实验部该有的成绩。可是跟他没有关系。</p><p>特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。</p><p>太失败了。</p><p>太失败了。</p><hr><p>大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。</p><p>我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。</p><p>这真是从未有过的轻松的感觉。</p><p>或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。</p><p>我感到无比的轻松。</p><p>以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。</p><p>我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。</p><p>嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。</p><p>但是其实山东没有开展$AO$的，不过我想当这个第一人。</p><p>我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。</p><p>到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。</p><hr><p>在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。</p><p>没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。</p><p>我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好的话+强大的理解能力=rqy这个等式也是成立的。</p><p>当然，不属于我啦。</p><p>虽然现在很不甘……但是没有办法，大概这就是人生吧。</p><p>如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。</p><p>听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。</p><p>总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么：</p><h2 id="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"><a href="#做什么事情，都要先从自己的灵魂出发，而不是从利益出发。" class="headerlink" title="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"></a>做什么事情，都要先从自己的灵魂出发，而不是从利益出发。</h2><p>之类的吧。</p><p>我想引用一句（段）话，来自《本杰明巴顿奇事》：</p><blockquote><p>有些人，注定可以于河边闲坐。<br>有些人被闪电击中过七次。<br>有些人对音乐有着非凡的天赋。<br>有些人是艺术家。<br>有些人是游泳健将。<br>有些人懂得制作纽扣。<br>有些人懂莎士比亚。<br>有些人是妈妈。<br>还有些人，是舞者。<br>我们注定要失去我们所爱的人，<br>要不然我们怎么知道他们对我们有多么的重要。</p></blockquote><p>后会有期。</p><h1 id="mathscr-THE-END"><a href="#mathscr-THE-END" class="headerlink" title="$\mathscr{THE~~~END}$"></a>$\mathscr{THE~~~END}$</h1>]]></content>
    
    <summary type="html">
    
      我不想退役。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>笙上月Project</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E7%AC%99%E4%B8%8A%E6%9C%88/"/>
    <id>http://www.orchidany.cf/2019/02/14/笙上月/</id>
    <published>2019-02-14T07:48:12.000Z</published>
    <updated>2019-03-10T08:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准确来说这是一个$project$，专门以$art/painting$、$music$为主。</p><p>现在已经在原博客上更了两期了，因为实在懒得再去捯饬图片的事儿，于是就直接链过来好了：</p><p><a href="https://www.cnblogs.com/pks-t/p/9349900.html" target="_blank" rel="noopener">ArseniXC &amp; 莫奈</a></p>        <div id="aplayer-QRaJbvjw" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-QRaJbvjw"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "人啊",              author: "徐佳莹",              url: "徐佳莹-人啊.mp3",              pic: "/2019/02/14/笙上月/rena.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      陶冶情操233
    
    </summary>
    
    
      <category term="笙上月" scheme="http://www.orchidany.cf/tags/%E7%AC%99%E4%B8%8A%E6%9C%88/"/>
    
  </entry>
  
</feed>
