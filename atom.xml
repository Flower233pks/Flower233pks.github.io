<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>Love is a touch but yet not a touch</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orchidany.cf/"/>
  <updated>2019-03-20T08:36:32.000Z</updated>
  <id>http://www.orchidany.cf/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想·目次表</title>
    <link href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>http://www.orchidany.cf/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-03-20T08:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><p>换了新的博客，把之前博客园里的三篇搬了下来。</p><p>每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。</p><p>时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。</p><p>读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。</p><p>读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。</p><p>是的，我是花，一个不理智的$Oier$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-KLKBhOjo" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KLKBhOjo"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 杨柳岸晓风残月</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人今安否？</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/01/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/">$Link$</a></td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">$\rm{empty}$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$\rm{empty}$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$\rm{empty}$</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>多项式2·NTT以及任意模数NTT</title>
    <link href="http://www.orchidany.cf/2019/03/17/NTT1-2/"/>
    <id>http://www.orchidany.cf/2019/03/17/NTT1-2/</id>
    <published>2019-03-17T13:13:33.000Z</published>
    <updated>2019-03-19T07:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0x01-quad-rm-Preface"><a href="#0x01-quad-rm-Preface" class="headerlink" title="$0x01\quad \rm{Preface}$"></a>$0x01\quad \rm{Preface}$</h1><p>无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。</p><p>我们知道，对于$FFT​$而言，其得以优化成$\log​$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。</p><p>$\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，<strong>快速数论变换</strong>。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$：</p><ul><li><p>$\omega_n^n = 1$。</p></li><li><p>$\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。</p></li><li><p>{$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}​$}，这使得问题规模可以在计算的时候减半。</p></li><li><p>$$<br>\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k =<br> \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}<br>$$</p></li></ul><p>这样可以保证我们能够使用相同的方法进行逆变换。</p><hr><p>首先，原根的基本定义：设$g$为$p$的一个原根，则满足：<br>$$<br>𝑔^{𝑝−1}  \equiv 1(\mod p) \\<br>∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)<br>$$<br>换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。</p><p>同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过<br>$$<br>g^{p-1} \equiv1(\bmod~p) \ \omega_n^n=1<br>$$<br>而已。于是就满足性质一。</p><p>  而对于性质三，我们先考虑一个转化。我们如果要将$g​$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}​$。换句话说，$N | (p-1)​$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)​$，得到一个和单位根相似的形式。</p><p>  那么接下来，因为$p​$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)​$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)​$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：<br>$$<br>  g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)<br>$$<br>  再结合<del>显而易证的</del>消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。</p><p>  至于性质四，证明的大体相似于单位单位复根。即：<br>$$<br>  \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow  \frac{(g_n^n)^k -1}{g_n^k -1} \equiv  \frac{(1)^k -1}{g_n^k -1} = 0<br>$$<br>  而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。</p><h1 id="0x02-quad-rm-Codes"><a href="#0x02-quad-rm-Codes" class="headerlink" title="$0x02\quad \rm{Codes}$"></a>$0x02\quad \rm{Codes}$</h1><p>呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且$N$是$2$的幂次，所以素数$p$一定要是$2^j+1$的形式。</p><p>至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000010</span> ;</span><br><span class="line">LL A[MAXN], B[MAXN], Inv ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    LL Gn = expow(flag == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    N = read(), M = read() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - <span class="number">2</span>) ;</span><br><span class="line">    NTT(A, <span class="number">-1</span>) ; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) write((<span class="keyword">long</span> <span class="keyword">long</span>) (A[i] * Inv + P) % P) ; fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Gi</code>表示$998244353$的原根的逆元。</p><h1 id="0x03-quad-rm-Extending"><a href="#0x03-quad-rm-Extending" class="headerlink" title="$0x03\quad \rm{Extending}$"></a>$0x03\quad \rm{Extending}$</h1><p>接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。</p><p>先咕着qwq……</p>]]></content>
    
    <summary type="html">
    
      另一种神奇的多项式卷积求法，比FFT应用要广泛。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-NTT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-NTT/"/>
    
  </entry>
  
  <entry>
    <title>有趣的数学题 · [NOI2002]Savage/[Violet · 5]樱花</title>
    <link href="http://www.orchidany.cf/2019/03/17/Math1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Math1/</id>
    <published>2019-03-17T10:36:37.000Z</published>
    <updated>2019-03-17T11:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt=""></p><h2 id="rm-NOI2002-Savage"><a href="#rm-NOI2002-Savage" class="headerlink" title="$\rm{[NOI2002]}$ Savage"></a>$\rm{[NOI2002]}$ Savage</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1407" target="_blank" rel="noopener">$\color{violet}{Link}​$</a> </p><h3 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不算特别难…其实就是求方程$$C_{i}+P_{i}x \equiv C_j+P_jx ~(\bmod ~M)$$不存在一个解使得$x \leq min(L_i,L_j)$时，$M$的最小值。然后因为题目中的数据，假设我们令每个野人都只是绕着圈走而不重复经过对方的路径——即$M$的最大值，也不过是$100\times 106\times 100 = O(1e6)$的级别，于是考虑直接枚举$M$, 然后check。由于最多共有$15$个野人，且单次exgcd是$\log n $级别的，所以复杂度上限是$O (Mn^2 \log C_{max}) &lt; \Omega(1e8)$级别的。如果不是精心构造数据的话，可以直接艹过去。</p><p>喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ;</span><br><span class="line">            <span class="keyword">int</span> qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ;</span><br><span class="line">            x = x * w / qwq ; <span class="keyword">while</span> (x &lt;= <span class="number">0</span>) x += M ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后觉得一点问题都没有，$40pts$之后愣了大半天。</p><p>而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的$x$，应该不断取模$b/ \gcd(a,b)$</p><p>为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解：</p><blockquote><p>_这是上面这个式子为什么可以这么做的证明：_</p><p>若有$ax+by=c$且$a_0x+b_0y=c$</p><p>那么便有$a(x-x_0)+b(y-y_0)=0$<br>两边同时除以$gcd(a,b)$可得：<br>$\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)$ $ \quad$ $(1)$</p><p>而因为</p><p>$(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p><p>所以由$(1)$可得$\frac{b}{gcd(a,b)}$整除$(x-x_0)$</p><p>所以很显然有$\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in Z$</p><p>那么就有对于任意一个$x_i$，有</p><p>$ x_i=x_0+\frac{b}{gcd(a,b)} \times{t} $</p></blockquote><p>我特么…智商已经回退到上个世纪了吧$\rm{qaq}$，自闭了。</p><p>这就是我整理这道题的原因……还有，上面$P_i-P_j$似乎需要取模并使其变成正的，因为好像我的$exgcd$里面限制了$A&gt;0$的缘故。</p><p>心得：我退役吧嘤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B) &#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> A ;&#125;</span><br><span class="line">    <span class="keyword">int</span> t = exgcd(y, x, B, A % B) ; y -= A / B * x ; <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ; </span><br><span class="line">            x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; <span class="keyword">if</span> (!x) x += (M / qwq) ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> ( M ; ; ++ M) <span class="keyword">if</span> (check()) &#123; <span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Violet～5-樱花"><a href="#rm-Violet～5-樱花" class="headerlink" title="$\rm{[Violet～5]}$ 樱花"></a>$\rm{[Violet～5]}$ 樱花</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2721" target="_blank" rel="noopener">$\color{violet}{Link}​$</a> </p><p>这是好久之前做的一道题，突然被我发现了。大概就是求方程$$\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 1e6)$$的解的组数。</p><h3 id="rm-Sol-1"><a href="#rm-Sol-1" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不想思考系列问题，我这么懒还是退役吧。(sigh)</p><p>我们将柿子变个形：<br>$$<br>\frac{x+y}{xy} = \frac{1}{n!} \\<br>n!x + n!y = xy<br>$$<br><del>然后我就不会了，此题完结</del></p><p>然后有一步很妙的是两边同时$+(n!)^2$得到：<br>$$<br>(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\<br>(n!-x)(n!-y)=(n!)^2<br>$$<br>然后就会发现我们只需要找出$(n!)^2$的因子个数就好了…</p><p>好像我从来没有写过$\tau$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）<br>$$<br>x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)<br>$$<br><del>其实就是为了水字数</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Prime[MAXN] ;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">bitset</span> &lt;MAXN&gt; vis ; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, i, j, cnt, Ans, Cnt[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ego</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">1</span>] = vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) Prime[++ cnt] = i ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * Prime[j] &gt; N) <span class="keyword">break</span> ;</span><br><span class="line">vis[i * Prime[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!(i % Prime[j])) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = Prime[i] ; j &lt;= N ; j *= Prime[i])</span><br><span class="line">        ( Cnt[i] += (N / j) ) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; N ; Ans = <span class="number">1l</span>l, Ego() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">        (Ans *= (Cnt[i] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>) %= Mod ;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; Ans % Mod &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      两道小清新数学题
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/扩展欧几里德" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="数学/素数/素数筛法" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E7%B4%A0%E6%95%B0-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>奇奇怪怪的线段树1（子段和+最长连续）</title>
    <link href="http://www.orchidany.cf/2019/03/17/Segment-Tree1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Segment-Tree1/</id>
    <published>2019-03-17T08:52:02.000Z</published>
    <updated>2019-03-17T10:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><p>最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$</p><h1 id="rm-Task1-子段和"><a href="#rm-Task1-子段和" class="headerlink" title="$\rm{Task1} $子段和"></a>$\rm{Task1} $子段和</h1><p>其实这个算是比较简单的了，毕竟$qyf​$曾经给我们讲过，当时我就觉得十分的……麻烦233.</p><p>那么例题其实就是$\rm{SPOJ}$的$GSS$系列——的前三道题<del>(后几道题都不会做)</del></p><h2 id="GSS1-区间求最大子段和-不带修"><a href="#GSS1-区间求最大子段和-不带修" class="headerlink" title="$GSS1$区间求最大子段和(不带修)"></a>$GSS1$区间求最大子段和(不带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">$\color{violet}{Link}​$</a></p><p>$2333$应该算是比较简单的了。我们对于每个区间维护一个<strong>区间和</strong>，维护一个<strong>从最左端开始且必须包含最左端元素的最大子段和</strong>，再维护一个<strong>从最右端开始且必须包含最右端元素的最大子段和</strong>，最后维护一个<strong>区间最大子段和</strong>。</p><p>那么转移($push$_$up$)时就显得十分方便。我们的父区间的$Lmax$只取决于左子区间的$Lmax$和<strong>当左区间的$Sum$等于$Max$时（即左区间全部都要纳入到其最大子段和中时）</strong>，左区间的$Sum$与右区间的$Lmax$的和。那么对于区间的$Rsum$，也是一个道理。最终对于该区间的最大子段和，我们<strong>不考虑</strong>从已经转移来的$Lmax/Rmax$，而是考虑从左右区间的$Max$以及左右区间的和来转移。大体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有值得注意的一点：在询问的时候，它比较膈应……就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来……所以所就要类似于边询问，边$push_up$这种感觉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后总代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line"><span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line"><span class="keyword">while</span> (M --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GSS3-区间求最大子段和-带修"><a href="#GSS3-区间求最大子段和-带修" class="headerlink" title="$GSS3$ 区间求最大子段和(带修)"></a>$GSS3$ 区间求最大子段和(带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1716" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>……其实吧，这个带修不带修……好像影响并不大？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">bool</span> MArk ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line"><span class="keyword">return</span> T[rt] ; </span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L == l &amp;&amp; L == r)&#123;</span><br><span class="line">T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) change(ls(rt), l, mid, k) ;</span><br><span class="line"><span class="keyword">else</span> change(rs(rt), mid + <span class="number">1</span>, r, k ) ; P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line"><span class="keyword">while</span> (M --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R) ;</span><br><span class="line"><span class="keyword">if</span> (!MArk) change(<span class="number">1</span>, <span class="number">1</span>, N, R) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GSS4-区间开根问题"><a href="#GSS4-区间开根问题" class="headerlink" title="$GSS4$ 区间开根问题"></a>$GSS4$ 区间开根问题</h2><p><a href="https://www.luogu.org/problemnew/show/SP2713" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>这个和子段和一点儿关系都没有，顺便整一下233.</p><p>就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个$2^{63}$内的数值$N$，我们假设其开根$k$次可以得到$N &lt; 2$——只要$N &lt; 2$之后的计算就会集中在一个紧确的范围$(1,2)$内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。</p><p>那么现在，我们致力于去确定$k$的值域。我们不得不承认，$\sqrt n$在$[0,+\infty]$是单调递增的，同理三次方根也是，四次方根也是……所以我们不妨取最大值，考虑$N=2^{63}$时，$k$值的大小。而很显然，此时的$k$应该为$\log _263+1 ≈ 6.978$——这似乎是十分平凡的结论。</p><p>总之，我们得出，似乎运算次数的上界就是$k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是$\Omega(7n)$的样子，无非就是多几个常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll N, M, K, i, L, R ; </span><br><span class="line">ll base[MAXN], T[MAXN], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">p_u</span><span class="params">(ll rt)</span></span>&#123; ;&#125;</span><br><span class="line"><span class="keyword">void</span> _Build(ll rt, ll l, ll r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;T[rt] = base[l] ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _Build(ls(rt), l, mid) ;</span><br><span class="line">    _Build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) ret += _query(rs(rt), mid + <span class="number">1</span>, r, sl, sr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (T[rt] &lt;= (r - l + <span class="number">1</span>)) <span class="keyword">return</span> ; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">                T[rt] = (<span class="keyword">int</span>)(<span class="built_in">pow</span>((<span class="keyword">double</span>)T[rt], <span class="number">0.5</span>)) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), </span><br><span class="line">   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) _Sqrt(rs(rt), mid + <span class="number">1</span>, r, sl, sr), </span><br><span class="line">   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">    ++ tot, <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, tot) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    _Build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        K = qr(), L = qr(), R = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) swap(L, R) ;</span><br><span class="line">       <span class="keyword">if</span> (K)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, _query(<span class="number">1</span>, <span class="number">1</span>, N, L, R)) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        _Sqrt(<span class="number">1</span>, <span class="number">1</span>, N, L, R) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Task2-最长连续问题"><a href="#rm-Task2-最长连续问题" class="headerlink" title="$\rm{Task2}$ 最长连续问题"></a>$\rm{Task2}$ 最长连续问题</h1><p>这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括<strong>连续</strong>字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断$push_up$即可。</p><p>$emmm$在这边整理几道思路不错的题吧：</p><h2 id="rm-USACO-酒店-hotel"><a href="#rm-USACO-酒店-hotel" class="headerlink" title="$\rm{USACO}$ 酒店($hotel$)"></a>$\rm{USACO}$ 酒店($hotel$)</h2><p><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>初始的一个全零的序列，我们对它准确来说有以下三个操作：</p><ul><li>区间置$0$</li><li>区间置$1$</li><li>询问是否有一段长度为$k$的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作②</li></ul><hr><p>这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。</p><p>但事实上……这就是学数据结构学傻了的后果……毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。</p><p>唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于$NOI2005$维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。</p><p>诶，好像扯了什么奇怪的东西……</p><p>回到正题，我们不考虑直接维护这个东西，而是<strong>通过维护区间内的最长连续$0$的个数，达到辅助查找区间的目的</strong>。那么我们查找区间的时候，就直接**择最左边的区间优先，并$check$其是否有足够的$0$。</p><p>对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> Sum, Len, Lsum, Rsum, tag ; </span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, N, M, MArk, i, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ;</span><br><span class="line">&#125;</span><br><span class="line">T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].Sum == T[ls(rt)].Len) </span><br><span class="line">T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line"><span class="keyword">if</span> (T[rs(rt)].Sum == T[rs(rt)].Len) </span><br><span class="line">T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), </span><br><span class="line">T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">T[rt].tag = <span class="number">-1</span>,</span><br><span class="line">T[rt].Len = T[rt].Lsum = </span><br><span class="line">T[rt].Rsum = T[rt].Sum = r - l + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">T[rt].tag = k ;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">push_down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid) update(rs(rt), mid + <span class="number">1</span>, r, ul, ur, k) ;</span><br><span class="line">push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">push_down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].Sum &gt;= A) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) <span class="keyword">return</span> mid - T[ls(rt)].Rsum + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">while</span>(M --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MArk) ;</span><br><span class="line"><span class="keyword">if</span> (MArk == <span class="number">2</span>)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), update(<span class="number">1</span>, <span class="number">1</span>, N, A, A + B - <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A) ;</span><br><span class="line"><span class="keyword">if</span> (T[<span class="number">1</span>].Sum &gt;= A)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t = query(<span class="number">1</span>, <span class="number">1</span>, N)), update(<span class="number">1</span>, <span class="number">1</span>, N, t, t + A - <span class="number">1</span>, <span class="number">0</span>)  ;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'0'</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。</p><h2 id="rm-SCOI-序列操作"><a href="#rm-SCOI-序列操作" class="headerlink" title="$\rm{SCOI}$ 序列操作"></a>$\rm{SCOI}$ 序列操作</h2><p><a href="https://www.luogu.org/problemnew/show/P2572" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p><p>对于一个$01$序列，大体是这几种操作：</p><ul><li>区间清零</li><li>区间置为$1$</li><li>区间全部取非</li><li>区间查询$1$的个数</li><li>区间查询最长连续的$1$的长度</li></ul><p>好的，这道题被我秒了，爽啊……不过秒是秒了，对拍调试法调了好久$233$。</p><p>其实对于$1,2,4,5$都好说，只是第$3$个操作，需要再另维护区间最长连续的$0$的长度，如果存在取非标记生效，就交换一下就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> OS, OL, OR ;</span><br><span class="line"><span class="keyword">int</span> Sum, Lsum, Len, Rsum, S, tag, t ;</span><br><span class="line"><span class="comment">//tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor</span></span><br><span class="line">&#125;T[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, MArk, L, R, base[MAX], i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">T[rt].S = T[ls(rt)].S + T[rs(rt)].S ;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (T[ls(rt)].S == T[ls(rt)].Len) </span><br><span class="line">  T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line"><span class="keyword">if</span> (T[rs(rt)].S == T[rs(rt)].Len) </span><br><span class="line">  T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="keyword">if</span> (!T[ls(rt)].S) </span><br><span class="line">  T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OL = T[ls(rt)].OL ;</span><br><span class="line"><span class="keyword">if</span> (!T[rs(rt)].S) </span><br><span class="line">  T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OR = T[rs(rt)].OR ;</span><br><span class="line">T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (T[rt].t == <span class="number">1</span>)&#123;</span><br><span class="line">T[ls(rt)].tag ^= <span class="number">1</span>, T[rs(rt)].tag ^= <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ;</span><br><span class="line">T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ;</span><br><span class="line"><span class="comment">//l</span></span><br><span class="line">T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ;</span><br><span class="line">T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ;</span><br><span class="line">T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ;</span><br><span class="line"><span class="comment">//r</span></span><br><span class="line">T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ;</span><br><span class="line">T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ;</span><br><span class="line">T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (T[rt].tag == <span class="number">1</span>)&#123;</span><br><span class="line">T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ;</span><br><span class="line">T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ;</span><br><span class="line">&#125;</span><br><span class="line">T[rt].tag = <span class="number">-1</span>, T[rt].t = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">T[rt].tag = k ;</span><br><span class="line"><span class="keyword">if</span> (!k)</span><br><span class="line">T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, </span><br><span class="line">T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">0</span>, </span><br><span class="line">  T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) _change(ls(rt), l, mid, k) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) _change(rs(rt), mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _reverse(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">T[rt].t = <span class="number">1</span> ;</span><br><span class="line">T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ;</span><br><span class="line">T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ;</span><br><span class="line">T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) _reverse(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) _reverse(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt].S ;</span><br><span class="line">down(rt) ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) res += Sum(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) res += Sum(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">T[rt].Len = r - l + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">if</span> (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span>  T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">Tree res, A, B ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">    res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; </span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">while</span> (M --)&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R),</span><br><span class="line">++ L, ++ R ;</span><br><span class="line"><span class="keyword">if</span> (MArk == <span class="number">0</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">1</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">2</span>) _reverse(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Sum(<span class="number">1</span>, <span class="number">1</span>, N)) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$push_up$真长啊$233$</p><p>艹完这个题是真的爽啊~</p><h1 id="Task3-总结一下"><a href="#Task3-总结一下" class="headerlink" title="$Task3~$ 总结一下"></a>$Task3~$ 总结一下</h1><p>其实这东西和$DP$是一样的吧？你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。</p><p>嗯，万物相同。</p><blockquote><p>野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？</p></blockquote><p>不知为什么，突然想到了这句话。</p><h1 id="mathscr-The-End"><a href="#mathscr-The-End" class="headerlink" title="$\mathscr{The~End}$"></a>$\mathscr{The~End}$</h1>]]></content>
    
    <summary type="html">
    
      奇奇怪怪的线段树散发着奇奇怪怪的香气（
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="线段树" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="题解" scheme="http://www.orchidany.cf/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>自适应Simpson法入门</title>
    <link href="http://www.orchidany.cf/2019/03/17/Simpson1/"/>
    <id>http://www.orchidany.cf/2019/03/17/Simpson1/</id>
    <published>2019-03-17T08:39:35.000Z</published>
    <updated>2019-03-17T10:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p><h1 id="rm-0x01-前言"><a href="#rm-0x01-前言" class="headerlink" title="$\rm{0x01}$  前言"></a>$\rm{0x01}$  前言</h1><p>首先阐明一点，<strong>自适应辛普森算法($\rm{Adaptive ~Simpson’s~ rule}$ )</strong>是一类<strong>近似算法($\rm{Approximation ~algorithm}$)</strong>，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？</p><p>其思想是利用二次函数来不断<strong>拟合($\rm{Overfitting}$)</strong>所求曲线，而所谓的<strong>$Adapative$（自适应）</strong>则是用于优化时间复杂度的方法。</p><p>嗝…总之…比较简单？</p><p>表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。</p><h1 id="rm-0x02-mathcal-Simpson-Formula-辛普森公式"><a href="#rm-0x02-mathcal-Simpson-Formula-辛普森公式" class="headerlink" title="$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式"></a>$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式</h1><p>稍等，这个跟算法的关系不大，主要是公式：$$\rm{\int _{l}^{r} f(x) \rm{dx}\approx \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}} \,$$</p><p>事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大$233​$</p><p>这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$：</p><blockquote><p>因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：<br>$$\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx$$<br>求 $g(x)​$ 的不定积分为：<br>$$\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C$$<br>然后再带入 RR 和 LL ：<br>$$\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)$$<br>然后提公因式，原式为：<br>$$\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)$$<br>把里面展开来：<br>$$\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)$$<br>重新整理一下式子：<br>$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)$$<br>再整理：<br>$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))$$<br>代换可得：<br>$$aR^2+bR+c\approx f(R)$$<br>$$aL^2+bL+c\approx f(L)$$<br>$$4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})$$<br>把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：<br>$\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))$</p></blockquote><p>于是我们就得到了所谓的$\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是——</p><h1 id="rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法"><a href="#rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法" class="headerlink" title="$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法"></a>$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法</h1><p>我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑<strong>定向二分</strong>。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。</p><p>于是考虑<strong>自适应</strong>。</p><p>所谓<strong>自适应</strong>，说的直白点，无非就是<strong>需要多分治几次的地方，多分治几次；不需要的则可以少分治几次</strong></p><p>你会发现，其实他节约的就是一个点——<strong>时间效率</strong>。</p><p>举个栗子$^{[2]}$：</p><p>比如有这么个函数$\rm{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }$，我们要求$\int_{0}^{4}f(x) \rm{~dx}$ 并要求精度误差在$1e-5$ 以内。而我们有两种方法去解决：</p><ul><li>以固定的比例以及约束二分。</li><li>运用自适应策略分配</li></ul><p>那么我们首先要知道他真正的$value:$</p><p><img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165543353-1446042218.png" alt=""></p><p>看起来好像海星？然后我们用两种方法都试一试：</p><p>首先是自适应法，我们发现最后只需要求$20$段区间。表中的$a_k \&amp; b_k$表示左右区间，$S(l,r)$表示$[l,r]$内、运用$0x01$中的公式计算的，$\rm{Error~Bound}$表示误差界，$\rm{Tolerance}$表示计算时<strong>需要的误差</strong>(程序设计时会讲)。</p><p><img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165550075-1102374096.png" alt=""></p><p>那么最后算出来的值是$ −1.54878823413$ ，与真实值误差为$0.00000013840 $，一共调用了$79$次<strong>函数估值</strong>（留个坑，后文会讲）。</p><p>那么绘制出来的函数图像大概长这样：<img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165650450-478131070.png" alt=""></p><p>好像很流畅？$233$</p><p>那么第二种方法是定值分段。我们考虑分成区间$[0,4]$分为长度为$0.03125$的$128$段，并运用$0x01$的$Formula$，最后得出的结果为$−1.54878844029$，误差为$0.00000006776$……</p><p>好像是第一个误差的二分之一？听起来好像误差小了，但是却需要$257$次函数估值的调用……相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦的啦～</p><p>但是比起$1e-5$精度来说……这波稳赚啊$233$</p><h1 id="rm-0x04-mathcal-About-Code-代码实现"><a href="#rm-0x04-mathcal-About-Code-代码实现" class="headerlink" title="$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现"></a>$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现</h1><p>首先是<a href="https://www.luogu.org/problemnew/show/P4525" target="_blank" rel="noopener">$LuoguP4525$</a>的暴力解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (C * x + D) / (A * x + B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ;</span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Simp_calc(l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid) + do_divide(mid, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ;</span><br><span class="line">    Ans = do_divide(L, R) ; <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是……他对的很？</p><p>至于进化版<a href="https://www.luogu.org/problemnew/show/P4526" target="_blank" rel="noopener">$LuoguP4526$</a>，也是完全可以violently艹过去的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">23.3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R)) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，其真正的实现应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v Lans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) * 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, L, R ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Liu = <span class="number">1.0</span> / <span class="number">6</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * Liu * (F(l) + F(r) + <span class="number">4.0</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans, <span class="keyword">double</span> eps)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, t ; </span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ; </span><br><span class="line">    <span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; <span class="comment">//据说eps×15来自于Wiki……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">30</span> ; </span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们发现这就可以跟文章上面$0x03$中的例子呼应了：每次分治时计算两次，总共分治了$39$次，最终一共计算了$78+1=79$次，而二分则是一棵有$128$个叶子节点的递归树，总共计算了$256 +1=257$次。    </p><p>好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断$check\&amp;calc$, 而$check$的方式也很简单，只需要判断一下两段子区间的函数值之和与整个区间的函数值之和的差值是否在精度要求范围之内，之后如果满足精度误差就直接$return$，否则对于这段区间继续递归下去。</p><p>而这个地方有个要求，就是对于$eps$，你需要不断$half$他，原因很简单，对于一整段区间$U$，要求他的返回值的$|eps(U)| \leq k$的话，那么对于其作为子集两个连续区间$A,B$，当$A \bigcup B = U$时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq  \frac{k}{2}$，才能保证$|eps(U) = eps(A) + eps(B)| \leq k$，所以要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line">....................</span><br><span class="line"><span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ;</span><br></pre></td></tr></table></figure><p>好了，唯一的问题在于有句话迷的很：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ;</span><br></pre></td></tr></table></figure><p><img src="nky.jpg" alt=""></p><p>这个$\leq 15 \cdot eps$是什么意思？</p><p>好吧，笔者也不清楚，但是有个结论是长这样的：<img src="https://img2018.cnblogs.com/blog/1337159/201901/1337159-20190116165630989-1211570362.png" alt=""></p><p>什么？你说推什么倒？小小年纪整天想着推倒<del>学姐</del>可不好啊$233$</p><p>什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～</p><p>好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了……</p><p>于是结束，撒花花…（不是撒博主x）</p><h1 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm{Referance}$"></a>$\rm{Referance}$</h1><ul><li><p>$[1]$ :$NaCly_Fish$的$blog$ <a href="https://www.luogu.org/blog/NaCly-Fish-blog/SimpsonIntegral" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p></li><li><p>$[2]$ :某篇论文 <a href="https://files.cnblogs.com/files/pks-t/AdaptiveQuadProof.pdf" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p></li></ul><p>对于第二篇$refer$，借鉴的比较多（读书人的事……咳咳……），但是改了一个数据，就是$81 \to 79$，因为代码需要$233$</p><p>$Ps:$史上最不正经的$reference$诞生了……</p>]]></content>
    
    <summary type="html">
    
      一种很可爱的积分近似法，学的时候顺便看了好多论文qaq
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="积分/积分近似" scheme="http://www.orchidany.cf/tags/%E7%A7%AF%E5%88%86-%E7%A7%AF%E5%88%86%E8%BF%91%E4%BC%BC/"/>
    
      <category term="计算几何-Simpson积分" scheme="http://www.orchidany.cf/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-Simpson%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Calc on Trees (1)</title>
    <link href="http://www.orchidany.cf/2019/03/16/Cal-on-Tree1/"/>
    <id>http://www.orchidany.cf/2019/03/16/Cal-on-Tree1/</id>
    <published>2019-03-16T12:15:28.000Z</published>
    <updated>2019-03-17T11:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p><p>好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。</p><p>问题大概有两类：只有查询$\&amp;​$修改查询都有</p><h2 id="mathscr-Task1-普通的查询问题"><a href="#mathscr-Task1-普通的查询问题" class="headerlink" title="$\mathscr{Task1}$普通的查询问题"></a>$\mathscr{Task1}$普通的查询问题</h2><p>大概问题就类似于这个典型的<a href="https://www.luogu.org/problemnew/show/P2420" target="_blank" rel="noopener">$XOR$问题</a> </p><p>其实说白了，这个题的解法十分简单——$LCA$</p><p>但其实……我一开始考虑$LCA$，没有细致考虑，只是觉得如果从$u,v$分别向$LCA$跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。</p><p>但是这个地方，$LCA$的作用十分巧妙——我们试图去拓展这个题。我们定义$D(\bigodot,r,u)$表示在运算$\bigodot$下，从根$r$到某一固定点$u$的边权运算结果，其中限定了运算$\bigodot$必须为可逆运算，比如说异或、加法、减法——注意，此时的可逆运算，可以是<strong>自可逆（自己对自己运算是逆运算，比如$A~XOR ~A = 0$）</strong>或者<strong>他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法）</strong>，那么我们就可以很方便地得出它的一般形式$$D(\bigodot,u,v) = D(\bigodot,r,u) \bigodot D(\bigodot,r,v) ~\bigoplus ~(~2 \cdot D(\bigodot,r,LCA(u,v)~)~)$$ ，其中我们假设运算$\bigodot$与$\bigoplus$互逆。树上前缀和大抵上就是这个意思。</p><p>那么回到这个题，我们对于每一个点的$D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$是一个相当平凡的结论；有权时，则直接$dfs$一遍即可。每次查询是$log$级别的，所以时间复杂度的渐进上界就是比较显然的$O(\max(m \log_2n,n))$。</p><p>代码大概是这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span> )+ (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].t = v ;</span><br><span class="line">    e[cnt].next = head[u] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">head[u] = cnt ;</span><br><span class="line">    e[++cnt].t = u ;</span><br><span class="line">    e[cnt].next = head[v] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _build(<span class="keyword">int</span> deep, <span class="keyword">int</span> now, <span class="keyword">int</span> f, <span class="keyword">int</span> _xor)&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f, dep[now] = deep, XOR[now] = _xor ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = head[now]; k ;k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[k].t == f) <span class="keyword">continue</span> ;</span><br><span class="line">        _build(deep + <span class="number">1</span>, e[k].t, now, _xor ^ e[k].v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Up = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Up; i ++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    pre = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= Up; j ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; pre) u = fa[u][j] ;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span>(j = Up; j &gt;= <span class="number">0</span>; j --) <span class="keyword">if</span>(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> fa[v][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr(), in3 = qr();</span><br><span class="line">        add(in1, in2, in3) ;</span><br><span class="line">    &#125;</span><br><span class="line">    M = qr() ;</span><br><span class="line">    _build(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), init( );</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr() ;</span><br><span class="line">        f1 = LCA(in1, in2) ;</span><br><span class="line">        <span class="keyword">int</span> t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathscr-Task-2-带有修改的查询问题："><a href="#mathscr-Task-2-带有修改的查询问题：" class="headerlink" title="$\mathscr{Task~2}$带有修改的查询问题："></a>$\mathscr{Task~2}$带有修改的查询问题：</h2><p>之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是<a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">某年国家集训队的板子题</a>和一道经典的<a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">边权修改启蒙题</a> </p><p>我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然<strong>只能转移到深度大的点上</strong>，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。</p><p>所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要<strong>忽略$LCA(u,v)$</strong>，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v]) ;</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v], d) ;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br></pre></td></tr></table></figure><p>即可。</p><p>而对于如何边权转点权，我用的总时间复杂度大约$O(n)$的区间赋值函数，好像比较方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">    n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，<del>题解好啊</del></p><p>那么上面两个题就比较简单了：</p><p>$\mathscr{T1 ~\text{の} ~code}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;  </span><br><span class="line"><span class="keyword">int</span> Id[MAX], M, N, tot, A, B, C, i ; <span class="keyword">char</span> STR[<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Max[MAX &lt;&lt; <span class="number">1</span>], Min[MAX &lt;&lt; <span class="number">1</span>], S[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ;</span><br><span class="line">    Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ;</span><br><span class="line">    S[rt] = S[Ls(rt)] + S[Rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ;</span><br><span class="line">        T[Ls(rt)] ^= <span class="number">1</span>, T[Rs(rt)] ^= <span class="number">1</span> ;</span><br><span class="line">        Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ;</span><br><span class="line">        Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ;</span><br><span class="line">        T[rt] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        S[rt] = Max[rt] = Min[rt] = k, T[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Max[rt] ;</span><br><span class="line">        Max[rt] = -Min[rt], Min[rt] = -t ; </span><br><span class="line">        T[rt] ^= <span class="number">1</span>, S[rt] = -S[rt] ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Max[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = -Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Min[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Minnnnn = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Minnnnn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ___query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Ssssss = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    <span class="keyword">return</span> Ssssss ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Min</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Sum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr() + <span class="number">1</span>, n[i].v = qr() + <span class="number">1</span>, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'N'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, _Update(A, B) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'S'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Sum(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'A'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'I'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Min(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$一定是<strong>异或而不是覆盖</strong> ……是一个坑点</p><p>$\mathscr{T2 ~\text{の} ~code}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ; <span class="comment">//0 = Change, 1 = Add .</span></span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">char</span> STR[<span class="number">50</span>] ; <span class="keyword">int</span> A, B, C ;</span><br><span class="line"><span class="keyword">int</span> Rec[MAX], Id[MAX], Aft[MAX] ;<span class="keyword">int</span> N, tot ;</span><br><span class="line"><span class="keyword">int</span> M[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>][<span class="number">2</span>], head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">0</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">        M[Ls(rt)] = T[rt][<span class="number">0</span>], M[Rs(rt)] = T[rt][<span class="number">0</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>], T[Ls(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>]; </span><br><span class="line">        T[rt][<span class="number">0</span>] = <span class="number">-1</span>, T[Rs(rt)][<span class="number">1</span>] = <span class="number">0</span>, T[Ls(rt)][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">1</span>])&#123;</span><br><span class="line">        M[Ls(rt)] += T[rt][<span class="number">1</span>], M[Rs(rt)] += T[rt][<span class="number">1</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>], T[Ls(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>] ; </span><br><span class="line">        T[rt][<span class="number">1</span>] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T[rt][<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;M[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">0</span>] = M[rt] = k, T[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">1</span>] += k, M[rt] += k ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> M[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; STR ;</span><br><span class="line">    <span class="keyword">while</span>(STR[<span class="number">0</span>] != <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'A'</span>) A = qr(), B = qr(), C = qr(), _Update(A, B, C) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span>) A = qr(), B = qr(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'o'</span>) A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ;    </span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'h'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。</p><h2 id="与树形-mathbb-DP-的巧妙结合"><a href="#与树形-mathbb-DP-的巧妙结合" class="headerlink" title="与树形$\mathbb{DP}$ 的巧妙结合"></a>与树形$\mathbb{DP}$ 的巧妙结合</h2><p>这个地方其实说的是一类问题。。。比如一道<del>我根本不会的</del> 经典题：</p><p>$Description$</p><p>一棵带权树，$n$个点$q$次询问，每次询问一个点的$\sum dis_{odd}$和$\sum dis_{even}$。</p><p>$\mathcal{Solution}$</p><p>其实这个题的题目意思是让我们求：</p><blockquote><p>$R$君想知道对于每个点来说，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。    </p></blockquote><p>那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？</p><p>这个东西比较简单，因为我们可以直接$dfs$。</p><p>那么如果是求所有点到所有点的距离和呢？</p><p>换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。</p><p>我首先忽略边权，令边权都是$1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道<strong>根节点到所有点的距离之和</strong>，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？</p><p>我们会发现，此时我们知道的量，同一般的树形$DP$或者说树形结构不同，我们现在已经知道了<strong>每一个子树的根节点的讯息；</strong>而平常的树形结构，我们知道的则是<strong>子节点的讯息$or$子树的讯息</strong>，这一点提示我们：<strong>反向$DP$</strong></p><p>我们不妨设$dp_u$表示$\sum \limits_{i \in T}^{}{dist(i,u)}$ 那么我们思考如何构造相邻两层的状态转移方程：</p><p>首先，我们已经决定反向$DP$，换句话说就是<strong>用父亲推出儿子</strong>；并且我们了解到，对于某一个点$u$，他的<strong>所有子节点到他的距离要比到他的父亲的距离少$1$</strong>（假设边权$=1$），同时所有<strong>除其子树之外的所有点到他的距离会多$1$</strong>.那么转移方程旧顺水推舟地：</p><h3 id="dp-v-dp-u-subsize-v-n-subsize-v-v-in-son-u"><a href="#dp-v-dp-u-subsize-v-n-subsize-v-v-in-son-u" class="headerlink" title="$dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$"></a>$dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$</h3><p>那么接下来我们思考，当边权不为$1$的时候呢？我们可以稍微魔改一下上式，于是就得到</p><h3 id="dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-N-cdot-pre-v"><a href="#dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-N-cdot-pre-v" class="headerlink" title="$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + N \cdot pre_v$"></a>$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + N \cdot pre_v$</h3><p>其中$pre_i$表示节点$i$的上行边，即父亲与它相连的那条边。</p><p>那么以上简单版本的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAX] ; <span class="keyword">int</span> head[MAX], cnt ; </span><br><span class="line"><span class="keyword">int</span> N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">sub[now] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">build(to(k), now) ;  </span><br><span class="line">sub[now] += sub[E[k].to], dp[<span class="number">1</span>] += sub[E[k].to] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwork</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[k].to == f) <span class="keyword">continue</span> ;</span><br><span class="line">dp[E[k].to] = dp[now] - <span class="number">2</span> * sub[E[k].to] + N ;</span><br><span class="line">fwork(to(k), now) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), _Add(A, B) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">0</span>) ; fwork(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一值得注意的地方就是其中$dp_1$或者说$dp_{root}$的处理。那么其实这个地方我们只需要不断加$size$即可。</p><p>高端版本的问题，代码类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">Sub[now] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">build(to(k), now) ;  Pre[to(k)] = E[k].v ;</span><br><span class="line">Sub[now] += Sub[to(k)], dp[<span class="number">1</span>] += Pre[to(k)] * Sub[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">dp[to(k)] = dp[now] - <span class="number">2</span> * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C), Add(A, B, C) ;;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">0</span>) ; dp_work(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。</p><p>我们致力于维护这样一个东西：对于每个$u \in T$， 我们试图确定除$u$及其子树外，到$u$点距离是奇数的点的个数$S0$$\&amp;$距离是偶数的点的个数$S1$，以便于状态转移时，作为第二部分。那么平均树高下，直接在$dfs/bfs$里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要$swap$一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）：</p><p>$$dp[to(k)][0] = dp[now][1] - Sub[to(k)][0] <em> Pre[to(k)] \ dp[to(k)][1] = dp[now][0] - Sub[to(k)][1] </em> Pre[to(k)] ，\ dp[to(k)][0] += S0 <em> Pre[to(k)] , \ dp[to(k)][1] += S1 </em> Pre[to(k)] ;$$</p><p>其中$to(k) \in son_{now}$</p><p>而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）：</p><p>$$dp[to(k)][1] = dp[now][1] - Sub[to(k)][1] <em> Pre[to(k)] ;\ dp[to(k)][0] = dp[now][0] - Sub[to(k)][0] </em> Pre[to(k)] ;\        dp[to(k)][1] += S1 <em> Pre[to(k)],\         dp[to(k)][0] += S0 </em> Pre[to(k)] ;$$</p><p>于是就结束了。其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句：</p><h3 id="dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-Count-cdot-pre-v"><a href="#dp-v-dp-u-2-cdot-pre-v-cdot-subsize-v-Count-cdot-pre-v" class="headerlink" title="$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_v$"></a>$dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_v$</h3><p>其中$Count$表示某种神秘的计数。。。。</p><p>那么其实这种问题还可以拓展到“求对于每一个点$u$，$dist(u,v) \mod n =k$的点的个数，其中$k \in [0,k-1]$，我感觉做法应该会类似吧<del>（但是我肯定不会做因为根本不可能调的出来）</del></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>没啥好说的，只觉得第三模块的例题十分难调！十分难调！！！并且……我一开始没用$S0$或者$S1$，直接用的根节点的$sub_0$和$sub_1$，最后才法案根本不和逻辑。。。但他居然过样例了。。。</li><li>转移的时候还是需要有一个清醒的思路再code啊！</li><li>$DP$好啊！</li></ul>]]></content>
    
    <summary type="html">
    
      一类比较简单的树上路径统计问题
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模型" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="树形DP" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="树模型" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="轻重链剖分" scheme="http://www.orchidany.cf/tags/%E8%BD%BB%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>随想六·难</title>
    <link href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/"/>
    <id>http://www.orchidany.cf/2019/03/10/随想六·Hard/</id>
    <published>2019-03-10T08:06:42.000Z</published>
    <updated>2019-03-20T08:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">$Link$</a></p><h2 id="text-Part0"><a href="#text-Part0" class="headerlink" title="$\text{Part0}$"></a>$\text{Part0}$</h2><p>不知道为什么，最近的心绪颇不宁静。</p><p>那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。</p><p>我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。</p><p>这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。</p><p>毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。</p><p>就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。</p><h2 id="text-Part1-cdot-Her"><a href="#text-Part1-cdot-Her" class="headerlink" title="$\text{Part1}\cdot Her$"></a>$\text{Part1}\cdot Her$</h2><p>“她”是谁？</p><p>我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系：</p><blockquote><p>头一次清晨在无人的校园里闲逛，<br>耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，<br>眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。<br>一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。<br>好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光——</p></blockquote><p>最后一句本来是<code>但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系</code>，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。</p><p>我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。</p><p>我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？……</p><p>以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说：</p><blockquote><p>大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。</p></blockquote><p>她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。</p><h2 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h2><p>我很烦。</p><p>机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。</p><p>我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年<code>NOIP</code>考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？</p><p>好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊…</p><p>最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了……</p><h2 id="rm-Part4"><a href="#rm-Part4" class="headerlink" title="$\rm{Part4}$"></a>$\rm{Part4}$</h2><p>不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。</p><p>其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望：</p><blockquote><p>我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。</p><p>同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。</p><p>如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。</p><p>没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。</p><p>保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙——</p><p>你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？</p><p>你知道每年有多少初中生在NOIp中碾压高中生吗？</p><p>你不知道。</p><p>每天几个小时？</p><p>做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。</p><p>你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。</p><p>我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。</p></blockquote><p>看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。</p><p>为什么会这么难呢？我不知道啊。</p><p>我只知道我的机会确乎是不多了。</p><p>今年省选还有没有戏呢？我也不知道。</p><p>我只知道我的时间不多了。</p><p>不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。</p><p>呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。</p><p>这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。</p>]]></content>
    
    <summary type="html">
    
      最近心绪颇不宁静。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>BSGS-Senior·扩展的BSGS</title>
    <link href="http://www.orchidany.cf/2019/02/22/exBSGS/"/>
    <id>http://www.orchidany.cf/2019/02/22/exBSGS/</id>
    <published>2019-02-22T13:10:55.000Z</published>
    <updated>2019-03-16T13:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><hr><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>$emmm$严格来讲，不应该被算到一个模板里面。因为在我看来<strong>模板</strong>是人构造出来的，但是这个算法应该是一个解决问题的$process$…更像是在解一道数学题，如果$BSGS$是定理的话，$exBSGS$更像是一个不断转化的过程233（手动@lxa并且溜</p><h1 id="rm-0x02-quad-Algorithm-Process"><a href="#rm-0x02-quad-Algorithm-Process" class="headerlink" title="$\rm{0x02\quad Algorithm~Process}$"></a>$\rm{0x02\quad Algorithm~Process}$</h1><p>今天才发现原来$\rm{BSGS}$有两种写法……并且觉得剩下的题解讲的都讲的不是很全的样子233。</p><p>其实本质上，当$p$不为素数时，我们无法进行朴素$\rm{BSGS}$的原因是我们的欧拉定理$a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理$(a,p)=1$的情况。那么我们知道，朴素的$\rm{BSGS}$的关键在于，可以保证最小解是有界的——$x$一定在$[1,\varphi(p)]$中。所以最后$BSGS$的复杂度才会是$\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的$p$是素数的情况下，时间复杂度为$\Theta(p)$。</p><p>那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。</p><p>我们思考，对于同余式$a^x\equiv b~(\bmod p)​$而言，我们先假定$(a,p)&gt;1 ​$。而此时如果有$((a,p), b)=1​$，那么说明此式只有可能在$x=0,b=1 ​$的时候有解——这个结论是平凡的。因为假设我们把它展开成$a\cdot a^{x-1} +kp=b ​$的形式，必须要有$(a,p)  ~|~ b​$的情况下，才能保证$a^{x-1}​$和$k ​$都是整数。</p><p>那么对于$(a,p)&gt;1$且$(a,p)~|~b $，我们令原式变成</p><p>$$<br>a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} (\bmod \frac{p}{(a,p)})<br>$$<br>的样子，如果此时$(a^{x-1},\frac{p}{(a,p)})=1$ 的话，我们就直接解</p><p>$$<br>a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }(\bmod \frac{p}{(a,p)})<br>$$<br>这个方程即可。否则我们继续分解直至$(p’,a)=1$。</p><p>那么此时有个问题需要注意，就是如果们在解这个方程时，出现了</p><p>$$<br>(a^{x-1}, \frac{p}{(a,p)})\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }<br>$$<br>的情况，那我们需要特判并<code>return -1</code> ；另一种情况，如果我们出现了</p><p>$$<br>a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1(\bmod \frac{p}{(a,p)})<br>$$<br>的情况，也需要特判并输出此$k$（此时同余式左边是$a^{x-k}$，因为$a^{x-k}\equiv1~(\bmod p)$所以直接输出$k$），不过也有可能不需要，完全看你写的$BSGS$能不能判断$x=0$的情况……一般情况下不能。</p><p>此时<strong>由于$\boldsymbol{p}$不再是素数，所以不能用费马小定理，需要我们用$exgcd$的方法求逆元，包括但不限于$\frac{b}{(a,p)}$的逆元和$a^{-im}$。</strong></p><p>以下是完整版代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; H ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, ans ; <span class="comment">// N ^x = M (mod P)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a ;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b) res = ((b &amp; <span class="number">1</span>)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line"> ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll mod, ll qaq)</span></span>&#123;</span><br><span class="line">    H.clear() ; ll Q, p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), x, y ; </span><br><span class="line">    exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, </span><br><span class="line">    Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * a % mod)  <span class="keyword">if</span> (!H.count(i)) H[i] = j ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = b, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * Q % mod)  <span class="keyword">if</span> (H[i]) <span class="keyword">return</span> j * p + H[i] ; <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll qaq = <span class="number">1</span> ;</span><br><span class="line">    ll k = <span class="number">0</span>, qwq = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">while</span> ((qwq = gcd(N, P)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (M % qwq) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ;</span><br><span class="line">        <span class="keyword">if</span> (qaq == M) <span class="keyword">return</span> k ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (qwq = BSGS(N, M, P, qaq)) == <span class="number">-1</span> ? <span class="number">-1</span> : qwq + k ;</span><br><span class="line">&#125;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;P, &amp;M); <span class="keyword">if</span> (!N &amp;&amp; !M &amp;&amp; !P) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        N %= P, M %= P, ans = exBSGS() ; <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x03-quad-Afterword"><a href="#rm-0x03-quad-Afterword" class="headerlink" title="$\rm{0x03\quad Afterword}$"></a>$\rm{0x03\quad Afterword}$</h1><p>今天才知道原来$BSGS$有两种写法qaq</p><p>$zyf2000$好像和我写的$BSGS$对“大步”和“小步”的定义不是很一样…于是最后还是自己$\rm{yy}$的233</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$zyf2000$的$blog$ <a href="https://blog.csdn.net/clove_unique/article/details/51227328" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul>]]></content>
    
    <summary type="html">
    
      众所周知，朴素的$BSGS$并不可以解决$p​$不为素数的问题。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="BSGS/exBSGS" scheme="http://www.orchidany.cf/tags/BSGS-exBSGS/"/>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>多项式1.5·拆系数FFT</title>
    <link href="http://www.orchidany.cf/2019/02/19/FFT2/"/>
    <id>http://www.orchidany.cf/2019/02/19/FFT2/</id>
    <published>2019-02-19T14:00:05.000Z</published>
    <updated>2019-03-17T13:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt=""></p><p>上一篇多项式：<a href="http://www.orchidany.cf/2019/02/19/FFT1/">多项式1·普通的FFT</a></p><hr><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。</p><p>由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做<del>抄</del>完，所以就先整理地仓促一点。</p><p>首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接<code>long long</code>爆艹。</p><h1 id="rm-0x02-Normal-Coefficient-Spliting-FFT"><a href="#rm-0x02-Normal-Coefficient-Spliting-FFT" class="headerlink" title="$\rm{0x02~Normal-Coefficient-Spliting~FFT}$"></a>$\rm{0x02~Normal-Coefficient-Spliting~FFT}$</h1><p>首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成<br>$$<br>A_i = a_iM+b_i~(0\leq b_i &lt;a_i) \\<br>B_i = c_iM+d_i~(0\leq d_i &lt;c_i)<br>$$<br>的形式。然后我们做乘法的话，会有<br>$$<br>A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i<br>$$<br>那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。</p><p>那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$</p><p>$$b_i\cdot d_i \approx \Theta(M^2)$$</p><p>$$a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)$$</p><p>$$(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor) $$</p><p>那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], L, x ; <span class="keyword">long</span> <span class="keyword">long</span> Ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + <span class="number">0.5</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; </span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, t ; <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = <span class="number">32767</span> ; N = <span class="number">1</span>, t = L1 + L2 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; </span><br><span class="line">    <span class="keyword">while</span>(N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ L ; rep(i, <span class="number">0</span>, N) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>), FFT(C, <span class="number">1</span>), FFT(D, <span class="number">1</span>) ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; </span><br><span class="line">    FFT(H1, <span class="number">-1</span>), FFT(H2, <span class="number">-1</span>), FFT(H3, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        Ans[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)H1[i].x * M % P * M % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H2[i].x % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H3[i].x * M % P) % P ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。</p><p>但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是——</p><h1 id="rm-0x03-Conjugate-Optimization"><a href="#rm-0x03-Conjugate-Optimization" class="headerlink" title="$\rm{0x03~Conjugate~Optimization}$"></a>$\rm{0x03~Conjugate~Optimization}$</h1><p>源自毛啸的《再探快速傅立叶变换》。</p><p>我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$<br>$$<br>\rm{P(x) = A(x) + iB(x)} \\<br>\rm{Q(x) = A(x) - iB(x)}<br>$$<br>我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。</p><p>同时，令$\text{conj(x)}$表示对$x$取共轭。</p><p>那么会有$^{[5]}$：<br>$$<br>\begin{align}<br>P’[k] &amp;= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\<br>&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\<br>&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; =  \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}<br>\\<br>Q’[k] &amp;= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\<br>&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\<br>&amp; = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\<br>&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\<br>&amp; = \text{conj} \left( P’[n-k] \right)<br>\end{align}<br>$$<br>好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。</p><p>那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：<br>$$<br>A’[k] = \frac{P’[k] + Q’[k]}{2} \\<br>B’[k] = \frac{P’[k] - Q’[k]}{2i}<br>$$<br>哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$.</p><p>以下是共轭优化$FFT$的初号机：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], Len, x, Ans[MAXN] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node(r, -i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                node T = w[N / j * l] ; T.i *= flag ;</span><br><span class="line">                node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; <span class="keyword">while</span> (N &lt;= L) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node ia, ib, a1, a2, b1, b2 ;</span><br><span class="line">    rr <span class="keyword">int</span> i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  FFT(t1, <span class="number">-1</span>), FFT(t2, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / N + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / N + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / N + <span class="number">0.5</span>) % P, Ans[i] = ((((<span class="keyword">long</span> <span class="keyword">long</span>)q3 &lt;&lt; <span class="number">30</span>) % P + ((<span class="keyword">long</span> <span class="keyword">long</span>)q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P + P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) f[i] = qr() % P ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x04-quad-拼命卡常"><a href="#rm-0x04-quad-拼命卡常" class="headerlink" title="$\rm{0x04\quad}$拼命卡常"></a>$\rm{0x04\quad}$拼命卡常</h1><p>好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$）</p><p><img src="1.png" alt=""></p><p>然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）：</p><p><img src="2.png" alt=""></p><p>特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$:</p><p><img src="3.png" alt=""></p><p><img src="4.png" alt=""></p><p>好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点……</p><p>于是考虑对共轭优化的进行大力卡常：</p><ul><li>多次使用的非全局变量。使用<code>register</code>修饰符。</li><li>将$double$转换成为$long~double$ 。</li><li>减少取模次数。</li><li>从yjk那里偷来的$\rm{fread/fwrite}$</li></ul><p>一番操作之后，我们成功地卡到了第五页上……</p><p><img src="5.png" alt=""></p><p>最后奉上最快的代码qwq：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 102333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 272333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[MAXM], Len, x, Ans[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node(r, -i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;<span class="comment">//定义的Complex型是用来进行复数运算的 </span></span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> <span class="keyword">double</span> &amp;Q) &#123; <span class="keyword">return</span> (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    rr node t ;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                rr node T = w[N / j * l] ;</span><br><span class="line">            rr node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + N), FFT(J) ; </span><br><span class="line">    rr <span class="keyword">int</span> i ; rr <span class="keyword">double</span> qwq = <span class="number">1.0</span> / N ; </span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) J[i] = J[i] * qwq ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    rr <span class="keyword">int</span> i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; </span><br><span class="line">    t = ((L1 = read()) + (L2 = read())), P = read(), N = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)), R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A), FFT(B) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">    IFFT(t1), IFFT(t2) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        write(((ll)(t1[i].r + <span class="number">0.5</span>) + ((ll)(t1[i].i + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">15</span>) + ((ll)(t2[i].r + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">30</span>)) % P) ;</span><br><span class="line">    fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！<br><img src="6.png" alt=""></p><h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？</p><p>但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢……</p><p>并且在学的过程中顺便认识了一个巨佬<code>CMXRYNP</code>，嘿嘿，也算不亏啦。</p><p>本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$.</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$lvzelong2014$的$blog$ <a href="https://blog.csdn.net/lvzelong2014/article/details/80156989" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[2]$:<code>无梦之梦</code>的$blog$ <a href="https://www.cnblogs.com/DreamlessDreams/p/10241267.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[3]$:$Cyhlnj$的$blog$ <a href="https://www.cnblogs.com/cjoieryl/p/10114614.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[4]$:$litble$的$blog$ <a href="https://blog.csdn.net/litble/article/details/84864516" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[5]​$:$CMXRYNP​$的$blog​$ <a href="https://cmxrynp.github.io/2019/01/07/fft-optimization/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}​$</a></li><li>$[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li></ul>]]></content>
    
    <summary type="html">
    
      拆系数FFT主要用于解决不可思议的任意模数$NTT/FFT$问题，主要针对的就是【$Luogu4245·$任意模数NTT】这道题。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-FFT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-FFT/"/>
    
  </entry>
  
  <entry>
    <title>多项式1·普通的FFT</title>
    <link href="http://www.orchidany.cf/2019/02/19/FFT1/"/>
    <id>http://www.orchidany.cf/2019/02/19/FFT1/</id>
    <published>2019-02-19T03:26:08.000Z</published>
    <updated>2019-03-18T08:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>这篇文章初写于$7/1/2018$，是在陪同好友$yjk$与$wx$以及学长$rqy$一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍$FFT$并且写$MTT$，于是便有了这篇文章。</p><p>其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的<code>orchidany</code>特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。</p><p>但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。</p><h1 id="rm-0x02-quad-Convolution"><a href="#rm-0x02-quad-Convolution" class="headerlink" title="$\rm{0x02\quad Convolution}$"></a>$\rm{0x02\quad Convolution}$</h1><p><strong>卷积$\boldsymbol{(Convolution)}$</strong>，准确来说是一种<strong>通过两个函数$\boldsymbol f$ 和$\boldsymbol g​$ 生成第三个函数的一种数学算子.</strong></p><p>而广义上其定义为：$$\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}$$</p><p>我们称$h(x)$是$g(x)$与$f(x)$的<strong>卷积</strong>。</p><p>而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到</p><p>$$A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}} $$<br>其中$A(x)$和$B(x)$均为$N-1$次多项式<br>比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有$2n+1$项。</p><h1 id="rm-0x03-quad-Dot-Method"><a href="#rm-0x03-quad-Dot-Method" class="headerlink" title="$\rm{0x03\quad Dot~Method}$"></a>$\rm{0x03\quad Dot~Method}$</h1><p>我们知道，原本的多项式是系数表示法，现在我们将其转化为<strong>点值表示法$(\boldsymbol{dot~method} )$</strong>。即我们可以把多项式$F(x)$转化为多项式函数$f(x)$，那么这个$n$阶函数就可以由$n+1$个点唯一确定。即$$f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)….(x_n,y_n)}$$那么$$\forall k,y_k = f(x_k)$$这是很显然的，并且这$n+$个点是随意选取的——只要求它们相异即可。</p><ul><li><h2 id="rm-Advanced-Trick-Point-color-red-1-rm-Multiplication"><a href="#rm-Advanced-Trick-Point-color-red-1-rm-Multiplication" class="headerlink" title="$\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$"></a>$\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$</h2></li></ul><p>假设我们有两个关于$x$的$n+1$次多项式$A(x)$和$B(x)$，我们要对它的点值表达式进行乘法操作。由于结果有$2n+1$项，我们考虑补上一堆项，并对$$A(x) = {(x_0,y_0),(x_1,y_1)….(x_{2n},y_{2n})}$$ $$B(x) = {(x_0,y_0’),(x_1,y_1’)….(x_{2n},y_{2n})}$$ 做乘法可得 $$A(x)B(x) = {(x_0,y_0y_0’),(x_1,y_1y_1’)(x_{2n},y_{2n}y_{2n}’)}$$  </p><p>我们观察点乘法，它的时间复杂度达到了$\Theta(n)$，完全可以接受。那么不妨先看一下算法的大体思路：</p><blockquote><p>对于每个因子多项式，选取$n+1$个点，得出点值表达式（复杂度$\Theta(n^2)$） $\longrightarrow$点乘法(时间复杂度$\Theta(n)$)——&gt;将得出来的$C(x)$的点值表达式再转换成系数表达式(复杂度$\Theta(n^2)$)</p></blockquote><p>这就是$FFT$的大体流程。<del>转化之后怎么没多快常数还大了</del></p><p>虽然其余部分的时间复杂度还是很麻烦的$O(n^2)$，但是都是可以优化成$O(nlogn)$的。</p><hr><p>本质上的$FFT$包含<strong>$\boldsymbol{DFT}$（离散傅立叶变换）</strong>和<strong>$\boldsymbol{IDFT}$（逆离散傅立叶变换）</strong>实际上，<strong>$DFT$</strong>对应着的就是<strong>把系数表达式映射到点值表达式</strong>的过程，<strong>$IDFT$</strong>对应着的就是我们<strong>把点值表达式映射到系数表达式</strong>的过程。</p><h1 id="rm-0x04-Base-of-Optimization"><a href="#rm-0x04-Base-of-Optimization" class="headerlink" title="$\rm{0x04~Base ~of~Optimization}$"></a>$\rm{0x04~Base ~of~Optimization}$</h1><p>因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到$nlogn$的，那么总的时间复杂度，渐进意义下就是$O(nlogn)$的。</p><p>下面就让我们来看看如何优化：</p><ul><li><h2 id="rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root"><a href="#rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root" class="headerlink" title="$\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$"></a>$\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$</h2></li></ul><p>$n$次单位复根是满足$\omega^n = 1$ 的复数$\omega$，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出<strong>$n$次单位根有$n$个</strong>这个结论——亦或者是用代数基本定理证，都可以。而又因为复数$\omega^n$在复数平面上的模都是一，所以相乘之后还会是一，那么所有的$\omega_i,1 \leq i \leq n$就会均匀分布在单位圆上，类似当$n = 8​$时它是这样的：</p><p><img src="1.png" alt=""></p><p>我们考虑欧拉公式：</p><p>$$e^{ix} = cosx + isinx$$</p><p>我们取$x =2\pi$，可以得到如下关系式：$$e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}$$</p><p>们把此时的单位根称之为<strong>主次单位根</strong>，记作$$\omega_n = e^{\frac{2\pi i}{n}} $$</p><p>那么对于其他的单位根，记作$$\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k &lt; n$$都是主次单位根的整次幂，也就是上图中的一圈。</p><hr><p>诶，这个有啥用啊$QAQ$?</p><p>那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到$nlogn$的复杂度……</p><p>那么我们先来看其支持其规模减半的引理：</p><ul><li><h3 id="frak-Elimination-Lemma-quad-消去引理"><a href="#frak-Elimination-Lemma-quad-消去引理" class="headerlink" title="$\frak{Elimination ~Lemma\quad}$消去引理"></a>$\frak{Elimination ~Lemma\quad}$消去引理</h3></li></ul><hr><blockquote><p><strong>引理：对任何整数$n \geq 0,k \geq 0,d &gt;0$,有$$\omega_{dn}^{dk} = \omega_n^k$$</strong></p></blockquote><p>$\mathcal{Proof.}$</p><p>这个好像很好证的样子……代入定义可以获得$$\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k$$<br>$\mathcal{Q.E.D.}$</p><hr><ul><li><h3 id="frak-Binary-Lemma-quad-折半引理"><a href="#frak-Binary-Lemma-quad-折半引理" class="headerlink" title="$\frak{Binary~Lemma\quad}$ 折半引理"></a>$\frak{Binary~Lemma\quad}$ 折半引理</h3></li></ul><hr><blockquote><p><strong>引理：对于任何大于$0$的偶数$n$，都有$n$个$n$次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合。</strong></p></blockquote><p>$\mathcal{Proof.}$</p><p>我们可以由消去引理得到$$(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k$$那么</p><p>$$(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2​$$</p><p>$\mathcal{Q.E.D.}$</p><hr><p>那么接下来，如果对所有的$n$次单位跟平方一下，我们会发现$\frac{n}{2}$次单位根每个都恰好出现了两次——也就是说，在$n$个$n$此单位复数根的集合（朴素的集合，即不可重集）里，只有$\frac{n}{2}$个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。</p><p>那么把所有$n$单位根的平方画到一个数列上就是这样。</p><p><img src="2.png" alt=""></p><p>这个引理直接保证了我们求值的复杂度为$\Theta(n \log n)$</p><p>而我们在代码实现中，<strong>不能直接得到$e$或者虚数$i$</strong>，所以这个时候求单位根的任务就交给了我们上文中提到过的<strong>欧拉公式</strong>。</p><ul><li><h3 id="frak-Sum-Lemma-quad-求和引理"><a href="#frak-Sum-Lemma-quad-求和引理" class="headerlink" title="$\frak{Sum~Lemma\quad}$求和引理"></a>$\frak{Sum~Lemma\quad}$求和引理</h3></li></ul><hr><blockquote><p><strong>引理：对于任意$n&gt;0$且$k$不能整除$n$，我们都有$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0$$</strong></p></blockquote><p>$Proof.$</p><p>由几何级数的求和公式（等比数列求和公式)$$\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}$$可得$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow  \frac{(\omega_n^n)^k -1}{\omega_n^k -1} =  \frac{(1)^k -1}{\omega_n^k -1}$$由于保证了$k$不可整除$n$所以分母一定不为$0.$</p><p>$\mathcal{Q.E.D}$</p><hr><h1 id="rm-0x05-quad-DFT-to-FFT"><a href="#rm-0x05-quad-DFT-to-FFT" class="headerlink" title="$\rm{0x05\quad DFT \to FFT}$"></a>$\rm{0x05\quad DFT \to FFT}$</h1><p>那么我们在了解完单位复数根之后，便可以正式地对$DFT$给出定义与操作方案了。</p><ul><li><h2 id="DFT"><a href="#DFT" class="headerlink" title="$DFT$"></a>$DFT$</h2></li></ul><p>对于我们已知的一个多项式$$A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}$$在$\omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1}$处的取值，我们可以假定$n$是$2$的幂，因为即使它本身不是$2$的幂，我们也可以通过向高次幂补值为$0$的项来解决这个问题。而补足$2$的幂的目的，就是为了在$FFT$分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。</p><p>那我们现在会有一个$A$的向量组$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$，对于$k = 0, 1, 2, \cdots n -1$，定义$y_k$如下：$$y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}$$，那么向量$$\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}$$就称作系数向量$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$的<strong>离散型傅立叶变换（$\boldsymbol{Discrete   Fourier   Transformation}$）</strong>。</p><p>嗯，这个<strong>离散型</strong>我们可以由点乘法联想意会一下：本来$A(x)$是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容$qwq$），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。</p><ul><li><h2 id="FFT-优化-DFT"><a href="#FFT-优化-DFT" class="headerlink" title="$FFT$优化$DFT$"></a>$FFT$优化$DFT$</h2></li></ul><p>在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为$O(n^2)$，这是朴素算法。而我们只需要用一种被称作<strong>快速傅立叶变换（$\boldsymbol{Fast   Fourier   Transformation}$）</strong>的方式，就可以将其时间复杂度压缩成$O(nlogn)$。而在这里我们就用到了刚才证明的引理——<strong>折半引理</strong>。</p><p>我们考虑将原来的多项式$$A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}$$重定义成两个次数为$\frac{n}{2}$的小多项式$A^{[0]}(x)$和$A^{[1]}(x)$： </p><p>$$A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1}$$ $$ A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1}$$    那么也就是说，$A^{[0]}(x)$存储的是所有偶数位（二进制位最后一位是$0$），而$A^{[1]}(x)$存储的是所有的奇数位（二进制位最后一位是$1$），那么有下式：$$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$$那我们求$A(x)$在单位根们$\omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1}$处的值，就变成了先求出$A^{[0]}(x^2)$和$A^{[1]}(x^2)$的值，然后根据上式进行合并即可。</p><p>而显然的是，根据折半引理，我们根本不需要$O(n)$求，而是通过数据规模不断减小使之成为$O(\log n)$。于是，我们成功通过$FFT$优化了求值的复杂度。</p><p>那么同时对于另一边，我们可以根据</p><p>$$A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})$$</p><p>得到</p><p>$$A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})$$</p><p>从而有伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Lim = <span class="number">1</span>, N, M ;</span><br><span class="line"><span class="function">function <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> lenth, <span class="keyword">complex</span> *A, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">IF (Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">complex</span> A0[lenth &gt;&gt; <span class="number">1</span>], A1[lenth &gt;&gt; <span class="number">1</span>] ;<span class="comment">//分成两部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to lenth by_grow <span class="number">2</span>) A0[j &gt;&gt; <span class="number">1</span>] = A[j], A1[j &gt;&gt; <span class="number">1</span>] = A[j + <span class="number">1</span>] ;</span><br><span class="line">FFT(lenth &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">FFT(lenth &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line"><span class="keyword">complex</span> Wn = unit(,) , w = (<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂</span></span><br><span class="line">        <span class="comment">/*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to (lenth &gt;&gt; <span class="number">1</span>) by_grow <span class="number">1</span> with w = w * Wn)&#123;</span><br><span class="line">A[i] = A0[i] + A1[i] * w ;<span class="comment">//应用公式，下同 </span></span><br><span class="line">A[i + (lenth &gt;&gt; <span class="number">1</span>)] = A0[i] - A1[i] * w ; <span class="comment">//顺便求出另一半，由折半引理可显然。 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">function Main&#123;</span><br><span class="line">input(N), input(M) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to N by_grow <span class="number">1</span>) =&gt; input(A) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to M by_grow <span class="number">1</span>) =&gt; input(B) ; </span><br><span class="line"><span class="keyword">while</span>(Lim &lt; N + M) Lim &lt;&lt;= <span class="number">1</span> ;<span class="comment">//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分）</span></span><br><span class="line">FFT(Lim, A, <span class="number">1</span>) ;<span class="comment">//两遍FFT表示从系数化为点值 </span></span><br><span class="line">FFT(Lim, B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i : <span class="number">0</span> to Lim by_grow <span class="number">2</span>) =&gt; A[i] *= B[i] ;<span class="comment">//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是基于$pks$标准下的伪代码<del>你可以试试在c++标准下运行</del>，其中$for$循环部分，$grow$表示当前循环变量的<strong>单次增量</strong>，之后带有$with$表示每次循环结束都会进行的运算（下同</p><p>嗯，这就是求值的方法，好像很$nice$地达到了$O(n \log n)$</p><ul><li><h2 id="FFT-优化-IDFT"><a href="#FFT-优化-IDFT" class="headerlink" title="$FFT$优化$IDFT$"></a>$FFT$优化$IDFT$</h2></li></ul><p>上文中我们曾经提及过的<strong>范德蒙德矩阵</strong>可以放到这儿用：</p><p>$\begin{vmatrix}  1         &amp;  1  &amp; 1   &amp; \cdots &amp; 1      \newline 1         &amp;  \omega_n  &amp; \omega_n^2   &amp; \cdots &amp; w_n^{n-1}      \\newline1         &amp;  \omega_n^2  &amp; \omega_n^4   &amp; \cdots &amp; \omega_n^{2(n-1)}      \newline \vdots  &amp; \vdots &amp; \vdots  &amp;  \ddots &amp; \vdots \newline 1    &amp;  \omega_n^{n-1}  &amp; \omega_n^{2(n-1)}   &amp; \cdots &amp; \omega_n^{(n-1)(n-1)}        \newline  \end{vmatrix}$  $\begin{vmatrix}  a_0  \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix}$ = $\begin{vmatrix}  y_0  \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix}$</p><p>那为了求出我们的$\vec{a} = {a_0, a_1 \cdots ,a_{n-1}}$我们应该让刚刚求值算出的$\vec{y}$乘上我们$\vec{V}^{~-1}$（$\vec{V}$的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下：</p><hr><blockquote><p><strong>推论</strong>：对于$j,k = 0,1, 2 \cdots n-1,V_n^{-1}$的$(j, k)$处的值为$\omega_n^{-kj}/n$</p></blockquote><p>$Proof.$</p><p>我们考虑反向证明，已知$V_n’$是一个$(j,k)$处值为$\omega_n^{-kj}/n$的、与$V$形态相同的矩阵，那我们只需要证明$V’ \cdot V = I_n$即可，其中$I_n$是$n$阶单位矩阵，即主对角线都是$1$，其余位置上是$0$的矩阵。</p><p>那么我们考察$V’ V$中的元素$(i, j)$，有如下的式子$$V’V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}$$</p><p>由<strong>求和引理</strong>当且仅当$i=j$时其值为一，其余的时刻均为零，所以有$V’V = I_n$</p><p>$\mathcal{Q.E.D}$</p><hr><p>那么我们把我们刚刚求出来的逆矩阵$V^{-1}$美化一下，提出每一项所除的$n$，可以得到$IDFT$可以如此计算：$$IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]$$诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当$flag=1$时，他是正向$DFT$；当它等于$-1$时，它是逆向的$ IDFT$。这可以让我们通过这一个函数解决两个过程。我们只需要用$y$替换$a$，用$\omega_n^{-1}$替换$\omega_n$，其余的没什么差别，于是……时间复杂度还是$O(n \log n)$的!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> Lim,<span class="keyword">complex</span> *A,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[Lim &gt;&gt; <span class="number">1</span>], A1[Lim &gt;&gt; <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Lim ; i += <span class="number">2</span>)</span><br><span class="line">        A0[i &gt;&gt; <span class="number">1</span>] = A[i], A1[i &gt;&gt; <span class="number">1</span>] = A[i+<span class="number">1</span>] ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> unit = (<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span> * Pi / Lim) , flag * <span class="built_in">sin</span>(<span class="number">2.0</span> * Pi / Lim)&#125;, w = <span class="keyword">complex</span>(<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//欧拉公式 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        A[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        A[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......................</span><br><span class="line">FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，现在嘛……可以考虑撒花花啦！因为我们的$FFT$实际上已经结束了！$But$，这个递归版本的$FFT$由于牵扯到$sin/cos$的运算、$double$、递归时的入栈出栈（底层），所以常数特别的大$emmmmm$，那么——</p><h1 id="rm-0x06-Iterative-Optimization"><a href="#rm-0x06-Iterative-Optimization" class="headerlink" title="$\rm{0x06~Iterative~ Optimization}$"></a>$\rm{0x06~Iterative~ Optimization}$</h1><p>我们现在要引出的就是迭代版的$FFTqwq$</p><h2 id="·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation"><a href="#·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation" class="headerlink" title="· $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$"></a>· $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$</h2><p>$emmm$先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        a[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会发现……$\omega \cdot A^{[1]}[i]$被执行了两次，所以我们不妨用个变量记录它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = w * A1[i] ;</span><br><span class="line">a[i] = A0[i] + t ;</span><br><span class="line">       a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>嗯，这就是全部的优化啦！那么，FFT，完！</del></p><p>$qwq$这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好$\mathcal{QAQ}$。好吧，说这个的原因，只是为了引出我们关于<strong>蝴蝶操作</strong>的定义：</p><blockquote><p>我们定义$\omega_n^k$为<strong>旋转因子</strong>，那么每一次我们先将$y_k^{[1]}$与旋转因子的乘积存储在一个变量$t$里，并在$y_k^{[0]}$增加、减去$t$的操作称为一次蝴蝶操作。</p></blockquote><p>说白了，蝴蝶操作是一次$O(2)$的求出$A^{[0]}_k$与$A^{[1]}_k$的操作。</p><hr><p>我们首先考虑按照递归的思路，将$FFT$的分治流程刻画一下：</p><p><img src="3.png" alt=""></p><p>我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下：</p><blockquote><p>$step   1$  成对地取出儿子节点，用蝴蝶操作计算出其$DFT$。<br>$step   2$  用这一步的$DFT$替换之前的；<br>$step   3$  直到我们迭代到根节点为止，否则返回$step   1$</p></blockquote><p>而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层$for$，先枚举区间长度（1，2，4，8……），第二层枚举长度为$j*2$的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间$DFT$的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举区间长度，从小区间到大区间依次合并。</span></span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;<span class="comment">//两段区间两段区间的枚举，用于合并</span></span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;<span class="comment">//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。</span></span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;<span class="comment">//一次蝴蝶操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在$DFT$的时候，为了保证时间复杂度是$\Theta(\log n)$，我们曾经进行过一次$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是$0,1,2,3,4,5,6,7$，但是迭代版的$FFT$却需要的顺序应该跟叶子结点的顺序吻合，即$0, 4, 2, 6, 1, 5,3,7$。所以——</p><ul><li><h2 id="·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law"><a href="#·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law" class="headerlink" title="· $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$"></a>· $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$</h2></li></ul><p>这个嘛……我们可以选择打个表观察：<br>原来的序号 $0        1        2        3        4        5        6         7$<br>现在的序号 $0        4        2        6        1        5        3        7$<br>原来的二进制表示 $000        001        010        011        100        101        110        111$<br>现在的二进制表示 $000        100        010        110        100        101        011        111$</p><p>诶，二进制好像是反序的嗷~~这便是我们的最后一个$trick$，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在$FFT$之前$swap$一遍即可。</p><p>嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure></p><p>呃，这个二进制计算自己推一下就好。</p><p>那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。<del>真开森啊</del></p><p>最后附迭代版的代码(我写的常数好像有点儿大$QAQ$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN] ;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;<span class="comment">//前面的if保证只换一次</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(), M = qr() ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i].x = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i].x = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">    FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(A[i].x / Lim + <span class="number">0.5</span>)) ;<span class="comment">//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊……那就撒花花吧！！</p><h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>以下是原尾语，保留了下来：</p><blockquote><p>嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短<del>这么容易背过</del>。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天$qwq$，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他$DALAO$比对审核、或者缠着$rqy$问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。</p><p>以下是温馨提示：</p><ul><li>好多自己当初不理解的地方在代码里就只有半行qaq</li><li>三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的</li></ul></blockquote><p>真 · 结束语：</p><p>其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去<code>现在看这个算法，真是简单的一匹啊</code>，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$rvalue$的$blog$ <a href="https://www.cnblogs.com/rvalue/p/7351400.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :算法导论 <a href="https://pan.baidu.com/s/13PRy8pPn__zGj3UfOTX8Ew" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码: txs2 </li><li>[3]*：鸣谢rqy</li></ul><h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
    
    <summary type="html">
    
      一类在$\Theta(nlogn)$时间复杂度内解决平凡卷积的算法，相对来说比较入门。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多项式-FFT" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F-FFT/"/>
    
  </entry>
  
  <entry>
    <title>随想五·手中没有红玫瑰</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/"/>
    <id>http://www.orchidany.cf/2019/02/14/随想五·情人节/</id>
    <published>2019-02-14T14:14:41.000Z</published>
    <updated>2019-03-10T08:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">戳我</a></p><hr><p>今天下了一天的雪。</p><p>我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。</p><p>“情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。</p><p>雪真美啊。</p><hr>        <div id="aplayer-rbhJVjxY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rbhJVjxY"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "空も飞べるはず",              author: "定能飞向天空",              url: "古谷拳-空も飛べるはず (定能飞向天空).mp3",              pic: "/2019/02/14/随想五·情人节/ggq.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>早恋？</p><p>“严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”……</p><p>说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。</p><p>直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了：</p><blockquote><p>小学五年级的时候，我喜欢班上的一个女孩子。<br>那时候想的很多。<br>比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。<br>那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。<br>这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。<br>我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。</p></blockquote><blockquote><p>如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。</p></blockquote><blockquote><p>我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。<br>他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。</p></blockquote><blockquote><p>于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。<br>家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。</p></blockquote><blockquote><p>后来初三开学，我收到了一封信。<br>来自那个小学时候喜欢的女孩子。<br>信的末尾有一句话：我准备报考X中，你要不要一起？</p></blockquote><blockquote><p>我的手不受控制地颤抖。<br>烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。</p></blockquote><blockquote><p>为什么要读书呢？<br>16岁的我获得了唯一的答案——为了和喜欢的人在一起。<br>我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。<br>对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。<br>是啦，他们总以为自己很懂。</p></blockquote><blockquote><p>很多人说，小孩子不要谈感情，因为反正不会有结果。<br>是，的确不会有结果。<br>就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。</p></blockquote><blockquote><p>可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。<br>爱过一个人，是我少年时最大的幸运。</p></blockquote><blockquote><p>所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。<br>是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。</p></blockquote><blockquote><p>有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。<br>结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。</p></blockquote><blockquote><p>我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。</p></blockquote><blockquote><p>他们轻蔑地说，小孩子懂什么恋爱。<br>好，那我们来看看大人们有多么懂爱情。<br>相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。<br>夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。<br>夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。</p></blockquote><blockquote><p>所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。<br>难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？</p></blockquote><blockquote><p>还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”<br>仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。</p></blockquote><blockquote><p>可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？<br>你们是真的有的是以后，还是早已离散在人海？<br>而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？</p></blockquote><blockquote><p>很久以后我们终于知道，大人都在说谎。<br>少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。</p></blockquote><blockquote><p>如果有还在上学的读者看到这里，请记住，人生没有那么多以后。<br>有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。</p></blockquote><blockquote><p>至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。</p></blockquote><blockquote><p>我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。</p></blockquote><blockquote><p>” 很多人即使只见过一面，已经算见过了最后一面。“</p></blockquote><blockquote><p>十八岁前不早恋，这辈子都来不及早恋。<br>你的人生看起来很长，每一秒都无法挽回。</p></blockquote><p>虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。</p><p>我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。</p><p>当然，也是给我自己讲。</p><p>关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。</p><p>现在不一样了吧，一生，多长啊。</p><p>我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。</p><p>没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。</p><p>等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？</p><p>不，我觉得不是。</p><p>我是在亵渎一种感情，是在侮辱一个人。</p><p>爱从来都是无私地付出，而不是拼命的占有啊。</p><p>我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。</p><p>你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊，</p><p>都不过是拼命地想被爱而已。</p>        <div id="aplayer-HbiQvKcv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-HbiQvKcv"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "clammbon-ソナタ",              author: "(奏鸣曲)",              url: "clammbon-ソナタ (奏鸣曲).mp3",              pic: "/2019/02/14/随想五·情人节/zmq.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><hr><p>不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊……</p><p>孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。</p><p>我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。</p><p>下面是歌词：</p><blockquote><p>我喜欢暖冬的太阳<br>我喜欢初春的青草<br>我喜欢午后的庭院和一旁发呆的秋千<br>我喜欢仲夏的冰沙<br>我喜欢清秋的明月<br>良宵的夜空 漫天星辰<br>我喜欢雨后的青蛙<br>我喜欢山前的杏<br>我喜欢周三的傍晚被霞光亲吻的水族馆<br>我喜欢成群的野<br>我喜欢凌乱的书架<br>清风的露台远处的灯海<br>我喜欢 走在无人的九十六号公路<br>我喜欢 木村拓哉长长的头发<br>我喜欢 无尽田野上奔跑的麋鹿<br>我喜欢 外婆门前的榕树<br>我喜欢母亲的便当<br>喜欢父亲的胡渣<br>我喜欢八月的夜晚还在营业的游乐场<br>我喜欢放学的铃铛<br>我喜欢停电的夜晚<br>点一对蜡烛 在幽静的玄关<br>我喜欢 城市尽头那远远的青山<br>我喜欢 热气球飞上西边的天空<br>我喜欢 清晨的石板路<br>雾腾腾的早餐店 阿公的桂花糕<br>我喜欢 每一朵暮云 每一株绿树<br>我喜欢你，你应该，也知道<br>我喜欢你，你应该，也知道</p></blockquote><p>优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句——</p><blockquote><p>我喜欢你，你应该，也知道.</p><p>我喜欢你，你应该，也知道。</p></blockquote><p>很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。</p><p>你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。</p><p>有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。</p><p>我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。</p><p>我喜欢你，你应该，也知道。</p>        <div id="aplayer-VpSpPhdG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VpSpPhdG"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "我喜欢",              author: "彩虹合唱团",              url: "上海彩虹室内合唱团-我喜欢 (合唱版).flac",              pic: "/2019/02/14/随想五·情人节/wxh.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><hr><p>心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？</p><p>如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。</p><p>我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。</p><p>相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。</p><p>$19/2/14$ </p><hr><p>本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。</p><p>那么就补一个深沉一点的结尾吧。</p><p>我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。</p><p>但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧……</p><p>路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。</p><p>可是面对着无奈的明天的我，什么都不能做。</p><hr><p>雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。</p>        <div id="aplayer-ZGOtuBpv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZGOtuBpv"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "遇见",              author: "孙燕姿",              url: "孙燕姿-遇见.flac",              pic: "/2019/02/14/随想五·情人节/yj.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      又是一年情人节啊。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019赛季最后的随想/NOIP2018游记·启示录</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/"/>
    <id>http://www.orchidany.cf/2019/02/14/随想三·NOIP/</id>
    <published>2019-02-14T14:11:50.000Z</published>
    <updated>2019-03-10T08:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/">戳我</a></p><hr><p>他看着眼前的屏幕，静静地发呆。</p><p>他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。</p><p>刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。</p><p>“希望别考期望吧，嘿嘿……”他心里这么想着。</p><p>晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。</p><p>他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。</p><p>从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。</p><hr><p>早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$Mac$版，连硕鼠也不能用了，便只得作罢。</p><p>终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。</p><p>“大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。</p><p>看了看天空，他上了大巴车。</p><hr><p>”昌邑一中真大啊“这是他到这儿后的第一想法。</p><p>到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。</p><p>宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。</p><p>他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。</p><hr><h2 id="rm-Day-1"><a href="#rm-Day-1" class="headerlink" title="$\rm{Day~1}$"></a>$\rm{Day~1}$</h2><p>突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。</p><p>考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。</p><p>入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。</p><p>$T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。</p><p>$T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。</p><p>$T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。</p><p>期望得分$100pts + random(0,100)+random(10,20) $</p><p>$Luogu$数据$100pts + 65pts + 15pts = 180pts$</p><p>听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。</p><p>下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。</p><p>考挂了，他想到。</p><p>这世界上似乎就他一个不会$T2$的人。</p><p>他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。</p><p>虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。</p><p>或许他期望着明天能翻盘？</p><p>晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。</p><hr><h2 id="rm-Day-2"><a href="#rm-Day-2" class="headerlink" title="$\rm{Day~2}$"></a>$\rm{Day~2}$</h2><p>今天他没有带什么吃的。</p><p>$T1$只会$60$分，转眼去看$T2$</p><p>写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。</p><p>$T3$连想的时间都没有。</p><p>退役了。</p><hr><p>他很伤心。</p><p>回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。</p><p>他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。</p><p>他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。</p><p>其余的都考炸了。</p><p>初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。</p><p>他一开始也并不怎样，没啥感觉。</p><p>直到那天下午。</p><hr><p>他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。</p><p>兴奋的他去奥赛室看成绩。</p><p>学长看错了。</p><p>他的两个同僚都是$370/380+$的样子。</p><p>只有他不到.</p><p>其他人的分数也比他高。</p><p>他大概全校第十几吧。</p><p>他感到了绝望。</p><p>本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。</p><p>他注定是失败者。</p><p>他伤心极了。</p><hr><p>他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。</p><p>他觉得一年来，他一事无成。</p><p>或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。</p><p>他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。</p><p>他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。</p><p>期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。</p><p>这似乎是实验部该有的成绩。可是跟他没有关系。</p><p>特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。</p><p>太失败了。</p><p>太失败了。</p><hr><p>大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。</p><p>我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。</p><p>这真是从未有过的轻松的感觉。</p><p>或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。</p><p>我感到无比的轻松。</p><p>以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。</p><p>我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。</p><p>嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。</p><p>但是其实山东没有开展$AO$的，不过我想当这个第一人。</p><p>我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。</p><p>到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。</p><hr><p>在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。</p><p>没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。</p><p>我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好的话+强大的理解能力=rqy这个等式也是成立的。</p><p>当然，不属于我啦。</p><p>虽然现在很不甘……但是没有办法，大概这就是人生吧。</p><p>如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。</p><p>听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。</p><p>总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么：</p><h2 id="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"><a href="#做什么事情，都要先从自己的灵魂出发，而不是从利益出发。" class="headerlink" title="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"></a>做什么事情，都要先从自己的灵魂出发，而不是从利益出发。</h2><p>之类的吧。</p><p>我想引用一句（段）话，来自《本杰明巴顿奇事》：</p><blockquote><p>有些人，注定可以于河边闲坐。<br>有些人被闪电击中过七次。<br>有些人对音乐有着非凡的天赋。<br>有些人是艺术家。<br>有些人是游泳健将。<br>有些人懂得制作纽扣。<br>有些人懂莎士比亚。<br>有些人是妈妈。<br>还有些人，是舞者。<br>我们注定要失去我们所爱的人，<br>要不然我们怎么知道他们对我们有多么的重要。</p></blockquote><p>后会有期。</p><h1 id="mathscr-THE-END"><a href="#mathscr-THE-END" class="headerlink" title="$\mathscr{THE~~~END}$"></a>$\mathscr{THE~~~END}$</h1>]]></content>
    
    <summary type="html">
    
      我不想退役。
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>笙上月Project</title>
    <link href="http://www.orchidany.cf/2019/02/14/%E7%AC%99%E4%B8%8A%E6%9C%88/"/>
    <id>http://www.orchidany.cf/2019/02/14/笙上月/</id>
    <published>2019-02-14T07:48:12.000Z</published>
    <updated>2019-03-10T08:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准确来说这是一个$project$，专门以$art/painting$、$music$为主。</p><p>现在已经在原博客上更了两期了，因为实在懒得再去捯饬图片的事儿，于是就直接链过来好了：</p><p><a href="https://www.cnblogs.com/pks-t/p/9349900.html" target="_blank" rel="noopener">ArseniXC &amp; 莫奈</a></p>        <div id="aplayer-IQEvyQoY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IQEvyQoY"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "人啊",              author: "徐佳莹",              url: "徐佳莹-人啊.mp3",              pic: "/2019/02/14/笙上月/rena.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      陶冶情操233
    
    </summary>
    
    
      <category term="笙上月" scheme="http://www.orchidany.cf/tags/%E7%AC%99%E4%B8%8A%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>CF#536Div2の题解(E&amp;F)</title>
    <link href="http://www.orchidany.cf/2019/02/08/CF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F/"/>
    <id>http://www.orchidany.cf/2019/02/08/CF-536Div2の题解-E-F/</id>
    <published>2019-02-07T16:11:14.000Z</published>
    <updated>2019-03-16T13:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89--%2F%E7%9C%81%E9%80%89-blueviolet.svg" alt=""></p><h2 id="0x01-Preface"><a href="#0x01-Preface" class="headerlink" title="$0x01~~Preface$"></a>$0x01~~Preface$</h2><p>$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕</p><p>这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233</p><p>简单总结一下前面四道题<a href="http://codeforces.com/contest/1106" target="_blank" rel="noopener">$\color{red}{Link}$</a>：</p><ul><li><p>A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次<del>身败名裂XD</del></p></li><li><p>B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树）</p></li><li>C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。</li><li>D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞</li></ul><p>下面两道题就好像不是那么水了qaq</p><h2 id="0x02-E-cdot-text-Lunar-New-Year-and-Red-Envelopes"><a href="#0x02-E-cdot-text-Lunar-New-Year-and-Red-Envelopes" class="headerlink" title="$0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$"></a>$0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$</h2><h3 id="color-red-Link"><a href="#color-red-Link" class="headerlink" title="$\color{red}{Link}$"></a><a href="http://codeforces.com/contest/1106/problem/E" target="_blank" rel="noopener">$\color{red}{Link}$</a></h3><p>简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。</p><p>最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。</p><h3 id="mathfrak-Solution"><a href="#mathfrak-Solution" class="headerlink" title="$\mathfrak {Solution}$"></a>$\mathfrak {Solution}$</h3><p>呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。</p><p>之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。</p><p>Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark, d, w ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> time_node &amp;T) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d);</span><br><span class="line">&#125;</span><br><span class="line">&#125; base[MAXN] ; </span><br><span class="line"><span class="built_in">map</span> &lt;time_node, <span class="keyword">int</span>&gt; M_set ; </span><br><span class="line"><span class="built_in">vector</span>&lt;time_node&gt;Time[MAXN] ; <span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, A, B, C, D, i, j ; <span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN][MAXM] ;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;A, &amp;B, &amp;C, &amp;D), </span><br><span class="line">        Time[A].push_back((time_node)&#123;<span class="number">1</span>, C, D&#125;) ;</span><br><span class="line">        Time[B + <span class="number">1</span>].push_back((time_node)&#123;<span class="number">2</span>, C, D&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> tot = Time[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; tot ; ++ j) </span><br><span class="line">            <span class="keyword">if</span> (Time[i][j].mark == <span class="number">1</span>) ++ M_set[Time[i][j]] ; </span><br><span class="line">            <span class="keyword">else</span> M_set[Time[i][j]] &gt; <span class="number">1</span> ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ;</span><br><span class="line">        <span class="keyword">if</span> (M_set.size()) base[i] = (*M_set.begin()).first ; <span class="keyword">else</span> base[i] = (time_node)&#123;<span class="number">0</span>, i, <span class="number">0</span>&#125; ;</span><br><span class="line">    &#125;dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, Ans = dp[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">            j &gt; <span class="number">0</span> ? dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j]) : <span class="number">1</span> ;</span><br><span class="line">            dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - <span class="number">1</span>][j] + base[i].w) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-F-cdot-text-Lunar-New-Year-and-a-Recursive-Sequence"><a href="#0x03-F-cdot-text-Lunar-New-Year-and-a-Recursive-Sequence" class="headerlink" title="$0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$"></a>$0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$</h2><p><a href="http://codeforces.com/contest/1106/problem/E" target="_blank" rel="noopener">$Link$</a></p><p>简单来说就是给你一个序列$F_x$的$k$项的递推法则（幂次积式递推），在认定前$k-1$项都满足$F_x=1$的基础上给定$F_n$，让你倒推出$F_k$来。</p><h3 id="mathfrak-Solution-1"><a href="#mathfrak-Solution-1" class="headerlink" title="$\mathfrak {Solution}$"></a>$\mathfrak {Solution}$</h3><p>恕我直言…这道题我考场上是不可能会的…（已扑街</p><p>首先我们观察一般形式：$$F_x = \begin{cases}1~, &amp;\rm{x&lt;k} \newline ?~, &amp; \rm{x = k} \newline \prod\limits_{j=1}^kF_{x-j}^{b_j}  ,  &amp; \rm{x&gt;k}\end{cases}~ (\mod 998,244,353)$$</p><p>大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个<del>我没想出来、想出来也不会用的</del>$Idea​$，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。</p><p>次我们选择$998,244,353​$的<strong>原根</strong>作为底数。因为原根有一个很优美的性质，就是<strong>$p​$的原根的幂次可以遍历$p​$的简化剩余系。</strong>而由$NTT​$里得到的经验，这个模数的最小原根是$3​$。</p><hr><p>原根的基本定义：设$g$为$p$的一个原根，则满足：<br>$$𝑔^{𝑝−1}  \equiv 1(\mod p)$$<br>$$∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$</p><hr><p>之后呢？之后我们就找一个函数$q(x)$，令$$g^{q(x)} \equiv x(\bmod p)$$ 目的是为了构造一个$l_x = q(F_x)$，使得等式$$g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}}( \mod p)$$成立。而比较特殊的是，因为$F_1$~$F_{k-1}$都为$1$，所以$l_i=0\quad(1 \leq i &lt;k)$ 。那么也就是说对于指数上的$l_x$满足$$l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i}( \mod p-1)$$这就是一个线性递推的形式了。</p><p>此处有个小$trick$，就是我们为了防止$l_x$过大，我们需要对它取模，此时直接依据费马小定理，取$p-1$做模数即可。</p><p>接下来是一个十分巧妙的$Idea$，我们虽然不知道$l_k$，但是我们可以知道$l_k$到$l_n$是如何变化的。观察题目性质，$$l_j = \omega_j l_k \mod(p-1)$$其中的$\omega_j$是一个关于$b_k$的常量因子。证明也比较简单，因为$l_i=0\quad(1 \leq i &lt; k) $是显然的。</p><p>那么我们只需要做一下矩阵快速幂——幂次上是$n-k$——就可以得出$\omega_n$来。而我们的$l_n$是可以通过对原根$g$求$BSGS$解得的。那么现在就是$$l_k\omega_n = l_n \mod (p-1)$$移个项可以得到$$l_k \omega_n + t(p-1)= l_n$$由于原题让求的是最小的正整数解，所以应用一下$exgcd$判一下是否有解就解决了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; Hash ;</span><br><span class="line"><span class="keyword">int</span> N, T, base[MAXN] ;</span><br><span class="line">LL Ft, Hn, Xs, Ans, X, Y, G  ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    LL M[MAXN][MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N; ++ k)</span><br><span class="line">                    Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                    Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix T, LL P)</span></span>&#123;</span><br><span class="line">    Matrix Ans ; Ans.reset() ;</span><br><span class="line">    <span class="keyword">while</span> (P)&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &amp; <span class="number">1</span>) Ans = Ans * T ;</span><br><span class="line">        T = T * T, P &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    LL P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p - <span class="number">1</span>)), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= P ; ++ j, (i *= x) %= p)  <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; </span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p)  <span class="keyword">if</span> (Hash.count(i)) <span class="keyword">return</span> Hash[i] + j * P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line">    LL t = exgcd(b, a % b, y, x) ;  y -=  a / b * x ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL k = <span class="number">0</span>, p = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; c = getchar() ; <span class="keyword">if</span> (c == <span class="string">'-'</span>) p = <span class="number">-1</span> ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; Ft ;  Matrix lab ;  lab.clear() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) lab.M[i][i - <span class="number">1</span>] = <span class="number">1l</span>l  ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) lab.M[i][N] = <span class="number">1l</span>l * base[N -i + <span class="number">1</span>] ;</span><br><span class="line">    lab = expow(lab, T - N), Hn = bsgs(<span class="number">3</span>,Ft, Mod), Xs = lab.M[N][N] ; </span><br><span class="line">    G = exgcd(Xs, Mod - <span class="number">1</span>, X, Y) ; <span class="keyword">if</span> (Hn % G) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    X = (X % (Mod - <span class="number">1</span>) * (Hn / G) % (Mod - <span class="number">1</span>) + Mod - <span class="number">1</span>) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">    Ans = expow(<span class="number">3</span>, X, Mod) ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x00-quad-后记"><a href="#0x00-quad-后记" class="headerlink" title="$0x00\quad$后记"></a>$0x00\quad$后记</h2><p>说实话，这是第一次做整套CF的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A$~$E$都还好，但是$F$实在是……看题解都要想半天的那种……尤其是这个解离散方根的东西……哇塞恶心死了从没听说过还有这东西qaq</p><p>rqy说$F$题是省选一轮的难度——虽然没说是$D$几$T$几，但我感觉他的语气不像是在说一道很难的题……</p><p>完了，要跪了。</p><blockquote><p>奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。</p><p>​                                                    ——（pks《春日绝句》）</p></blockquote>]]></content>
    
    <summary type="html">
    
      春节前的一场$CF$～名字很$nice$的说～
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="BSGS" scheme="http://www.orchidany.cf/tags/BSGS/"/>
    
      <category term="线性代数-矩阵" scheme="http://www.orchidany.cf/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="CodeForces" scheme="http://www.orchidany.cf/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>Lagrange Formula·拉格朗日插值法</title>
    <link href="http://www.orchidany.cf/2019/02/07/Lagrange-Formula/"/>
    <id>http://www.orchidany.cf/2019/02/07/Lagrange-Formula/</id>
    <published>2019-02-07T10:06:40.000Z</published>
    <updated>2019-03-16T13:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt=""></p><h2 id="rm-0x01-Preface"><a href="#rm-0x01-Preface" class="headerlink" title="$\rm{0x01~~} Preface$"></a>$\rm{0x01~~} Preface$</h2><p><strong>插值($Interpolaton$)</strong> 在多项式域中可以看做是<strong>求值$(Evaluation)$</strong>的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。</p><p>而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明——</p><h2 id="rm-0x02-rm-Proof"><a href="#rm-0x02-rm-Proof" class="headerlink" title="$\rm{0x02}~~\rm{Proof}$"></a>$\rm{0x02}~~\rm{Proof}$</h2><h3 id="Proof-of-Existence"><a href="#Proof-of-Existence" class="headerlink" title="$Proof ~of~Existence$"></a>$Proof ~of~Existence$</h3><p>​    我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。</p><p>​    首先我们需要构造一个对于第$i$个二元组的特殊多项式$L_i(x)$，满足$$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \newline 0, &amp; \rm{i \neq j}\end{cases}$$</p><p>那么我们所求的多项式$F(x)​$就可以写作$$F(x)  = \sum L_i(x_i)\cdot y_i​$$这个式子保证了我们对应的$n​$个二元组，$F(x)=y​$恒成立。</p><p>​    那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出$$L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)$$其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数$$k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}$$那么$$L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$从而$$F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$</p><h3 id="mathcal-Q-E-D"><a href="#mathcal-Q-E-D" class="headerlink" title="$\mathcal{Q.E.D.}$"></a>$\mathcal{Q.E.D.}$</h3><hr><h3 id="Proof-of-Uniqueness-1"><a href="#Proof-of-Uniqueness-1" class="headerlink" title="$Proof~of~Uniqueness^{[1]}$"></a>$Proof~of~Uniqueness^{[1]}$</h3><p>​    我们接下来要证明的是多项式$L_i(x)​$的唯一性</p><p>​    我们假设同时有两个实数域上的$n-1​$次多项式$L_1(x),L_2(x)​$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}​$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2​$在取所有的$x_i​$时，其值均为$0​$。那么一定会有多项式$$L’(x) = \prod\limits_{i=1}^{n}(x - x_i)​$$满足$$L’|L_{\Delta}​$$ 其中$|​$表示多项式整除。但是我们知道，对于$L’​$这个多项式，其次数为$n-1​$；而对于我们所定义的$L_i(x)​$，均为$(n-2)​$次的，从而$L_{\Delta}​$也是$n-2​$次多项式。所以我们可以得出$$L_{\Delta} = 0​$$从而有$$L_1=L_2​$$</p><h3 id="mathcal-Q-E-D-1"><a href="#mathcal-Q-E-D-1" class="headerlink" title="$\mathcal{Q.E.D.}$"></a>$\mathcal{Q.E.D.}$</h3><h2 id="rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$"></a>$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">题号：Luogu4781</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL Ans, xs ;</span><br><span class="line"><span class="keyword">int</span> N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B &amp; <span class="number">1</span>) (res *= A) %= Mod ; </span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>, (A *= A) %= Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;xv[i], &amp;yv[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        t = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (xv[i] - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        t = expow(t, Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (T - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; Ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul><h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
    
    <summary type="html">
    
      一种常见的函数插值法。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Math - Lagrange Formula" scheme="http://www.orchidany.cf/tags/Math-Lagrange-Formula/"/>
    
  </entry>
  
  <entry>
    <title>群论入门</title>
    <link href="http://www.orchidany.cf/2019/02/06/%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8/"/>
    <id>http://www.orchidany.cf/2019/02/06/群论入门/</id>
    <published>2019-02-06T01:55:55.000Z</published>
    <updated>2019-02-19T15:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。</p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="1-群的定义"><a href="#1-群的定义" class="headerlink" title="$1~)~$群的定义"></a>$1~)~$群的定义</h2><p>比较简单的来讲，所谓<strong>群$(\rm{group})$</strong>指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质：</p><p>我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算：</p><h4 id="Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G"><a href="#Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G" class="headerlink" title="$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$"></a>$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$</h4><h4 id="Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c"><a href="#Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c" class="headerlink" title="$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$"></a>$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$</h4><h4 id="Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a"><a href="#Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a" class="headerlink" title="$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$"></a>$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$</h4><h4 id="Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e"><a href="#Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e" class="headerlink" title="$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$"></a>$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$</h4><p>那么也就是说的直白点吧，对所有的元素，做完该群所带有的<strong>带有结合律的运算</strong>之后，所得结果<strong>仍然属于该群</strong>且一定存在单位元，对于每个元素存在运算逆元。</p><p>那我们不妨定义一些其他的：</p><ul><li><h3 id="阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。"><a href="#阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。" class="headerlink" title="阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。"></a>阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。</h3></li><li><h3 id="半群：满足封闭性和结合律的群。"><a href="#半群：满足封闭性和结合律的群。" class="headerlink" title="半群：满足封闭性和结合律的群。"></a>半群：满足封闭性和结合律的群。</h3></li><li><h3 id="有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶"><a href="#有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶" class="headerlink" title="有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶"></a>有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶</h3></li></ul><p>结合几个例子来解释一下：</p><p>比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)​$$ $$(R\setminus{0}~, ~\cdot)​$$$$ (C\setminus{0}~,~\cdot)​$$</p><p>他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。</p><p>或者一个好玩儿的乘法群$$((1, -1)~~, ~~\cdot)$$或者是所有<strong>非奇异的$n$阶矩阵</strong>也可以组成一个乘法群。</p><p>或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断<strong>是否成群</strong>,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。</p><hr><p>$Extra   Things :$</p><p>以下是两种复合抽代数据结构（名字自己起的$233$）：</p><h3 id="环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群"><a href="#环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群" class="headerlink" title="环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群"></a>环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群</h3><p>举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。</p><h3 id="域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群"><a href="#域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群" class="headerlink" title="域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群"></a>域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群</h3><p>举例子 ：$Q,R,C$即有理数域、实数域和复数域。</p><hr><p>好的，那我们尝试证明两个命题：</p><h3 id="Proposition1-一个群中的单位元唯一"><a href="#Proposition1-一个群中的单位元唯一" class="headerlink" title="$Proposition1~~~~$一个群中的单位元唯一"></a>$Proposition1~~~~$一个群中的单位元唯一</h3><p>设有两个单位元$e_1,e_2$</p><p>那么$e_1=e_1e_2=e_2$，其实是一个$233$</p><h3 id="Proposition2-群中元素的逆元唯一"><a href="#Proposition2-群中元素的逆元唯一" class="headerlink" title="$Proposition2~~~~$群中元素的逆元唯一"></a>$Proposition2~~~~$群中元素的逆元唯一</h3><p>以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$</p><p>显然也是同一个。</p><p>那么此时我打算整理一个群的共性特征：<br>$$(ab)^{-1}=b^{-1}a^{-1}$$</p><p>很显然，证明如下：<br>$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$</p><p>提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心</p><p>那么之后我们讨论<strong>周期</strong></p><p>对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$</p><p>$o(a)$表示最小正整数，使得$a^{o(a)}=e$</p><hr><h2 id="2-子群及衍生"><a href="#2-子群及衍生" class="headerlink" title="$2~)~$子群及衍生"></a>$2~)~$子群及衍生</h2><p>本节所指<strong>“群”</strong>没有特别说明便均为<strong>有限群</strong></p><p>不妨先给出子群的浅显版定义：</p><h3 id="如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示"><a href="#如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示" class="headerlink" title="如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示"></a>如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示</h3><p>那么从而我们可以定义<strong>生成子群</strong>这个东西：</p><p><strong>生成子群：若$S \subseteq G​$， 并且对于运算$C​$而言，$(G,C)​$也是一个群，那么就称$G​$为集合$S​$在运算$C​$下的生成子群。集合$S​$的生成子群用$&lt;​$$S​$$&gt;​$表示</strong></p><p>这之后我们就可以定义<strong>陪集</strong>这个概念</p><p>陪集一般上包含<strong>左陪集</strong>和<strong>右陪集</strong>。</p><h3 id="左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。"><a href="#左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。" class="headerlink" title="左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。"></a>左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。</h3><h3 id="右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。"><a href="#右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。" class="headerlink" title="右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。"></a>右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。</h3><p>$233$也可以叫做<strong>傍集</strong>或者<strong>旁系</strong>之类的~</p><p>那么我们这个地方先只研究右陪集$233$</p><h4 id="Lemma1"><a href="#Lemma1" class="headerlink" title="$Lemma1:$"></a>$Lemma1:$</h4><p>我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的<strong>群中元素数量</strong>。 </p><p>这个其实比较显然，因为事实上群都是定义在<strong>非可重集</strong>上面的。</p><p>较为严谨的证明如下：</p><hr><p>$Proof.$</p><p>对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$</p><p>反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾</p><p>对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$</p><hr><h4 id="Lemma2"><a href="#Lemma2" class="headerlink" title="$Lemma2:$"></a>$Lemma2:$</h4><p>之后我们再证明一些好玩儿的：</p><p>命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ </p><p>看起来好像不是那么好玩……</p><hr><p>$Proof.$</p><p>若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$</p><p>若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$</p><p>$hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$</p><p>因此$H_a=H_b$</p><hr><p>那么我们还可以有一个推论：</p><p>若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$</p><hr><p>$Proof.$</p><p>假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾</p><hr><p>从而还可以有个定理（$Lagrange$定理）：</p><p>由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么</p><p>$$|G|=|H|\cdot [G:H]$$</p><p>也就是说$|H|$是$|G|$的约数。</p><p>这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。</p><p>但是其实这是个很伟大的定理$233$ </p><hr><p>好的，那么从而就会有一些神奇的推论：</p><p><strong>推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ </strong></p><p><strong>$Proof.$</strong> 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ </p><p><strong>推论二：对任意的$a \in G,a ^{|G|} = e$</strong></p><p>$Proof.$ 比较显然，由推论一可知。</p><p><strong>推论三：若$|G|$为素数，则$G$是循环群</strong></p><p>$Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。</p><p>接下来我们真的要去做些好玩的了~</p><hr><h3 id="定理-1-·-Fermat-小定理"><a href="#定理-1-·-Fermat-小定理" class="headerlink" title="定理$1$·$Fermat$小定理"></a>定理$1$·$Fermat$小定理</h3><p>如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $</p><h3 id="Proof"><a href="#Proof" class="headerlink" title="$Proof. $"></a>$Proof. $</h3><p>考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知：</p><p>$$\forall a\in G, a^{p-1}=1(\mod p)$$ </p><h3 id="定理2·-Euler-定理"><a href="#定理2·-Euler-定理" class="headerlink" title="定理2·$Euler$定理"></a>定理2·$Euler$定理</h3><p>$a^{\phi(n)}=1 (\mod n)$</p><h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="$Proof.$"></a>$Proof.$</h3><p>考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法</p><p>那么会有$|G|=\phi(n)$，从而有：</p><p>$$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$</p><hr><p>没错，证明十分的简洁美观。</p><p>作者被这种神奇的证明给折服了$stO$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="抽象代数-群论" scheme="http://www.orchidany.cf/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E7%BE%A4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>BSGS-Junior·BSGS算法初探</title>
    <link href="http://www.orchidany.cf/2019/02/06/BSGS-junior/"/>
    <id>http://www.orchidany.cf/2019/02/06/BSGS-junior/</id>
    <published>2019-02-05T23:48:17.000Z</published>
    <updated>2019-03-16T13:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt=""></p><h1 id="rm-0x01-mathcal-Preface"><a href="#rm-0x01-mathcal-Preface" class="headerlink" title="$\rm{0x01}$  $\mathcal{Preface}$"></a>$\rm{0x01}$  $\mathcal{Preface}$</h1><p><strong>$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法</strong>。当然也会被叫做<strong>拔山盖世</strong>、<strong>北上广深</strong>算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : </p><blockquote><p>给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x$, 使得$a^x≡ b~(\mod p)$</p></blockquote><p>而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)​$，并且我们还知道$a^0=1≡1  ~(\mod p)​$，所以我们可以得出一个断言：</p><p><strong>如果方程$a^x≡ b~(\mod p)​$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))​$中</strong> $\qquad \qquad(1) ​$</p><p>此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。</p><p>之后我们将以此为基础进行类似分块的操作——</p><h1 id="rm-0x02-Baby-Step-Giant-Step"><a href="#rm-0x02-Baby-Step-Giant-Step" class="headerlink" title="$\rm{0x02~~Baby~Step~Giant~Step}$"></a>$\rm{0x02~~Baby~Step~Giant~Step}$</h1><p>首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq  \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：$$a^{i\cdot n+j}≡ b~(\mod p)$$移一下项就可以变成$$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$$那么现在我们的策略是算出所有$a^j$来，在$\mod p$  意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做<strong>小步$(\rm{Baby~Step})$</strong>，  称右边枚举$b \cdot a^{-i\cdot n}$叫做<strong>大步$~(\rm{Giant~Step})$</strong>。</p><p>那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中细节还是有的：</p><ul><li><p>计算<code>sqrt</code>时要上<strong>取整</strong>。</p></li><li><p>我们在求$a^{-i\cdot n}​$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。</p></li><li>两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$</li><li>算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的<code>Q</code>就会<code>=0</code>，从而在下面的第二个循环处出错——我们的<code>hash[i]</code>和<code>j</code>不能同时为$0$，从而输出错误的答案。</li></ul><h1 id="rm-0x03-例题"><a href="#rm-0x03-例题" class="headerlink" title="$\rm{0x03}$   例题"></a>$\rm{0x03}$   例题</h1><p>$T1~$<a href="https://www.luogu.org/problemnew/show/P4028" target="_blank" rel="noopener">$LuoguP4028$</a></p><p>裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tr1 ; <span class="keyword">int</span> T ;</span><br><span class="line">LL A, B, M, P, Q ; <span class="built_in">unordered_map</span> &lt;LL, LL&gt; Hash ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        M = qr(), A = qr(), B = qr() ;</span><br><span class="line">        <span class="keyword">if</span> ((!(A % M == <span class="number">0</span> &amp;&amp; B))) bsgs(A, B, M) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$T2~$ <a href="https://www.luogu.org/problemnew/show/P3846" target="_blank" rel="noopener">$TJOI2007~Cute~Prime​$</a></p><p>最裸最裸的、无特判的题……可以水一下双倍经验。</p><h1 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter: pks}$"></a>$\mathfrak{writter: pks}$</h1>]]></content>
    
    <summary type="html">
    
      一类解决$a^x\equiv b(~\bmod~p)$，且$p$为$prime$的同余式的算法。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="BSGS/exBSGS" scheme="http://www.orchidany.cf/tags/BSGS-exBSGS/"/>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LCT&#39;s Junior Intro</title>
    <link href="http://www.orchidany.cf/2019/02/04/LCT-s-Junior-Intro/"/>
    <id>http://www.orchidany.cf/2019/02/04/LCT-s-Junior-Intro/</id>
    <published>2019-02-04T15:18:58.000Z</published>
    <updated>2019-03-16T13:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p><h1 id="rm-0x01-闲话-·-LCT-的用途以及具体思路"><a href="#rm-0x01-闲话-·-LCT-的用途以及具体思路" class="headerlink" title="$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路"></a>$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路</h1><p>咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护<strong>森林连通性</strong>的。</p><p>嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。</p><p>但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为<strong>辅助树</strong>，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">$Luogu3391$</a>，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。</p><p>也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。</p><h1 id="rm-0x02-闲话-·-关于-rm-splay"><a href="#rm-0x02-闲话-·-关于-rm-splay" class="headerlink" title="$\rm{0x02}$ 闲话 · 关于$\rm{splay}$"></a>$\rm{0x02}$ 闲话 · 关于$\rm{splay}$</h1><p>道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？<del>后宫佳丽三千我该翻谁的牌子呢</del></p><p>历史的重任最后落到了$\rm{splay}​$的身上。然后$\rm{splay}​$他居然：</p><p><img src="t1.jpg" alt=""></p><p>他甚至还：</p><p><img src="t2.png" alt=""></p><p>……</p><p>好吧，由于某些<del>rqy也不知道的</del>原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$</p><h1 id="rm-0x03-LCT-的思路和基础操作"><a href="#rm-0x03-LCT-的思路和基础操作" class="headerlink" title="$\rm{0x03}$   $LCT$的思路和基础操作"></a>$\rm{0x03}$   $LCT$的思路和基础操作</h1><h2 id="一-主要思路"><a href="#一-主要思路" class="headerlink" title="一 主要思路"></a>一 主要思路</h2><p>主要思路嘛……大概是基于<strong>实链剖分</strong>的操作。</p><p><strong>朴素的树剖是重链剖分</strong>，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。</p><p>而实链剖分大体上就是把边分为<strong>虚边</strong>和<strong>实边</strong>。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。</p><p>实链剖分的好处呢？在于<strong>实链剖分是一种动态剖分</strong>，他可以<strong>随意改变边的虚实属性</strong>。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。</p><p>那么接下来我们来看一个$LCT​$是如何定义的:</p><ul><li>首先，一棵$LCT​$管控的是一对分散的点，点以几棵分散的$splay​$的形式聚集。起初整棵$LCT​$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access​$、$makeroot​$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT​$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。</li><li>实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。<strong>但是两种边都没有用到显式存储</strong>，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别：</li><li>虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。</li><li>实边是完整的双向存储。</li><li>$\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。</li><li>如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱.</li></ul><h2 id="二-基础操作"><a href="#二-基础操作" class="headerlink" title="二 基础操作"></a>二 基础操作</h2><p>$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作，我们这个地方先把点$n$所在联通块儿内的树的根记作$root(n) $，把与$n$以实边相连的儿子记作实儿子。</p><ul><li><h2 id="rm-1-Access"><a href="#rm-1-Access" class="headerlink" title="$\rm{1}$  $Access$"></a>$\rm{1}$  $Access$</h2></li></ul><p>这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是<strong>$Access(n)$表示从$root(n)$向$n$打通一条实链，并以$n$点为最深度最大的点、$root(n)$为深度最小的点形成一棵$\rm{splay}$</strong>。</p><p>不难看出，这个操作其实跟是一种<strong>逻辑层面的自我调控，没有改变原树的结构。</strong></p><p>我们思考，如果此时我们$Access​$完点$n​$之后，理论上来讲，$n​$点应该不再有实儿子了——显然，如果有实儿子的话，$splay​$中是应该包含这个实儿子的——而这就不符合$n​$是$\rm{splay}​$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}​$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}​$连上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">splay(x), rc = qwq, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这就是$Access​$了。</p><ul><li><h2 id="2-Make-Root"><a href="#2-Make-Root" class="headerlink" title="$2 ~~Make~ Root~$"></a>$2 ~~Make~ Root~$</h2></li></ul><p>$make_root​$先从原来的根向$n​$打通一条路径，然后$splay​$上去，最后$reverse​$一下。此处由于一开始$n​$的深度最大，$splay​$之后深度依旧最大，但此时$n​$是$splay​$的根，所以$reverse(n)​$就相当于翻转了整条树上的链，那么翻转之后，$n​$的深度就变成了最小，于是就是这个联通块儿的根节点了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line"><span class="keyword">while</span>(check(x))&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处$splay$中由于要下放标记，保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。</p><ul><li><h2 id="3-Merge"><a href="#3-Merge" class="headerlink" title="$3 ~Merge~$"></a>$3 ~Merge~$</h2></li></ul><p>此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="4-Link-amp-Cut"><a href="#4-Link-amp-Cut" class="headerlink" title="$4~~Link~\&amp;~Cut$"></a>$4~~Link~\&amp;~Cut$</h2></li></ul><p>如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ;  T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Merge(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br></pre></td></tr></table></figure><p>此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。        </p><p>但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作……</p><ul><li>$New-Link$ </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br></pre></td></tr></table></figure><p>此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233</p><p>但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。</p><p>多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根</p><ul><li>$New-Cut$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">Rooten(x) ; </span><br><span class="line"><span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; </span><br><span class="line">T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。</p><p>之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$Depth(x) &lt; Depth(y\text{的左儿子们})  &lt; Depth(y)$，其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。</p><p>剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。</p><ul><li><h2 id="5-Rotate-中的坑点"><a href="#5-Rotate-中的坑点" class="headerlink" title="5 $~Rotate$中的坑点"></a>5 $~Rotate$中的坑点</h2></li></ul><p>呃……其实就一处而已。就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g_fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$</p><p>剩下的……大概就没了吧……</p><p>于是——</p><h1 id="color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$"></a>$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk ;</span><br><span class="line"><span class="keyword">int</span> base[MAXN], N, M, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line"><span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line"><span class="keyword">while</span>(check(x))&#123;</span><br><span class="line"><span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line"><span class="keyword">if</span> (check(fa)) &#123;</span><br><span class="line">        rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">rep(i, <span class="number">1</span>, N) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">rep(i, <span class="number">1</span>, M)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C) ;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">0</span>) split(B, C), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[C].S) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="number">1</span>) Link(B, C) ; <span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="number">2</span>) Cut(B, C) ; <span class="keyword">else</span> splay(B), base[B] = C ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x00-后记和参考"><a href="#rm-0x00-后记和参考" class="headerlink" title="$\rm{0x00}$   后记和参考"></a>$\rm{0x00}$   后记和参考</h1><p>可写完了……嗝……<del>打个肥宅嗝犒劳犒劳自己</del></p><p>怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨……</p><p>写博客真是一个陶冶情操的过程啊……<del>包括做表情包</del></p><p>加油吧，$pks$！</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$Flash_Hu$的$blog$ <a href="http://www.cnblogs.com/flashhu/p/8324551.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li><li>$[2]$ :某篇论文，结合食用效果显著 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb.html" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></li></ul><h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
    
    <summary type="html">
    
      一种以$Splay$作为辅助树的、动态维护连通性的算法。
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LCT-Link Cut Tree" scheme="http://www.orchidany.cf/tags/LCT-Link-Cut-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Intro</title>
    <link href="http://www.orchidany.cf/2019/02/04/Intro-1/"/>
    <id>http://www.orchidany.cf/2019/02/04/Intro-1/</id>
    <published>2019-02-04T15:13:49.000Z</published>
    <updated>2019-03-10T08:16:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello, here is <strong>Orchidany</strong>, a high-school student from S.D., China.</p><p>Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is <strong>Olympiad in Informatics</strong>，shorthanded for <strong>OI</strong>.  And this blog is mainly gonna to record my Learning Steps. </p><p>Although I’m a bit weak in OI by now, but I shall catch the glimmer and keep getting stronger!</p><p>During daliy lives, I shall also write some about my own emotion, music &amp; art…it seems like I’m a chairwamrer in OI hhhhh…</p><p>See you soon in my articles !</p><p><strong>Somthing Special</strong></p><p>Errr…About this ID _Orchidany_, there is a theory about that:</p><p>My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) :</p><blockquote><h4 id="鹃住落英满，柳拂溪畔沙。"><a href="#鹃住落英满，柳拂溪畔沙。" class="headerlink" title="鹃住落英满，柳拂溪畔沙。"></a>鹃住落英满，柳拂溪畔沙。</h4><h4 id="南城略炊烟，浣女徐归家。"><a href="#南城略炊烟，浣女徐归家。" class="headerlink" title="南城略炊烟，浣女徐归家。"></a>南城略炊烟，浣女徐归家。</h4><h4 id="故人今安否，欲歌口偏哑。"><a href="#故人今安否，欲歌口偏哑。" class="headerlink" title="故人今安否，欲歌口偏哑。"></a>故人今安否，欲歌口偏哑。</h4><h4 id="笔寒下梅去，皎月半洒花。"><a href="#笔寒下梅去，皎月半洒花。" class="headerlink" title="笔寒下梅去，皎月半洒花。"></a>笔寒下梅去，皎月半洒花。</h4></blockquote><p>So……I’ m glad to encounter you!</p>]]></content>
    
    <summary type="html">
    
      $\rm{Introduction~with~poor~English}$
    
    </summary>
    
      <category term="杂记" scheme="http://www.orchidany.cf/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>可并堆·左偏树（1）</title>
    <link href="http://www.orchidany.cf/2019/01/27/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>http://www.orchidany.cf/2019/01/27/左偏树/</id>
    <published>2019-01-27T08:00:31.000Z</published>
    <updated>2019-03-17T10:20:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt=""></p><p>嗯…就当作是复习了233…时隔好几个月（其实就两个月）才想起来要整理。</p><h1 id="rm-0x01-关于左偏树"><a href="#rm-0x01-关于左偏树" class="headerlink" title="$\rm{0x01}$  关于左偏树"></a>$\rm{0x01}$  关于左偏树</h1><p>首先是整理自己想出来的几个梗</p><ul><li><p>$\mathcal{To~be~(left) ~or~not ~to~be~(left), this~is ~a~question}$ 左偏还是右偏，这是个问题。（哈姆雷特梗）</p></li><li><p>$Hell~!~Where~is~my~Left~Leaning~Tree?$ 该死，我的左偏树向右偏了。</p></li><li><p>左偏树是1个log，右偏树也是1个log，那我左右都偏是不是就会更快！（恭喜你建出了一棵满二叉树）</p></li><li><p>讲个鬼故事：每棵树都是下偏树。</p></li><li><p>其实，左耳离心脏更近，所以甜言蜜语麻烦合并到左偏树里吧。（《左耳》梗）</p></li></ul><p><del>好吧我承认不是很好笑</del></p><p>呐，下面进入正题。左偏树，一种<strong>可以合并的堆状结构</strong>，支持$insert/remove/merge$等操作。稳定的时间复杂度在$\Theta(\log n)$的级别。对于一个左偏树中的节点，需要维护的值有$dist$和$value$。其中$value$不必多说，$dist$记录这个节点到它子树里面最近的叶子节点的距离，叶子节点距离为$0$。</p><p>首先，他有以下几个喜闻乐见的性质：</p><ul><li>一个节点的$value$必定（或小于）左、右儿子的$value$                     <strong>（堆性质）</strong></li><li>一个节点的左儿子的$dist$不小于右儿子的$dist$                           <strong>（左偏性质）</strong></li><li>一个节点的距离始终等于右儿子$+1$</li></ul><p>那么这就可以推出以下性质：</p><ul><li>推论：任何时候，节点数为$n$的左偏树，距离最大为$\log (n+1)-1$<br>$$<br>Proof.<br>$$<pre><code>        对于一棵距离为定值$k$的树，点数最少时，一定是一棵满二叉树。这是显然的。因为对于每个节点，如果想要有最少的儿子，那么起码要做到左儿子的数量等于右儿子的数量。那么对于他的逆命题也是成立的——“若一棵左偏树的距离为$k$，则这棵左偏树至少有$2^{k+1}-1$个节点。”    所以会有$$n \geq 2^{k+1}-1$$,$$\log_2{(n+1)} \geq k+1$$, $$\log_2{(n+1)}-1 \geq k$$ </code></pre>$$<br>\mathcal{Q.E.D}<br>$$</li></ul><p>$emmm$这可是一个很美妙的性质啊。</p><h1 id="rm-0x02-基本操作"><a href="#rm-0x02-基本操作" class="headerlink" title="$\rm{0x02}~~$基本操作"></a>$\rm{0x02}~~$基本操作</h1><ul><li><h2 id="Merge"><a href="#Merge" class="headerlink" title="$Merge$"></a>$Merge$</h2></li></ul><p>这是整个左偏树的重头戏，时间复杂度稳定在一个$log$，其主要思想就是不断把新的堆合并到新的根节点的右子树中——因为我们的右子树决定“距离”这个变量，而距离又一定保证在$~\log~$的复杂度内，所以不断向右子树合并。</p><p>大体思路（以小根堆为例），首先我们假设两个节点$x$和$y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了。</p><p>合并了$x$的右子树和$y$之后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护性质二，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x = dist_{rson(x)}+1$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; </span><br><span class="line">    <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; </span><br><span class="line">    S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察，我们是不断交替拆分右子树，由推论可得我们的距离不会大于$\Theta(\log(n_x+1))+\Theta(\log(n_y+1))-2 =O(\log n_x+ \log n_y) $ </p><p>这个地方比较喜闻乐见的是需要存$root$，即需要路径压缩。不路径压缩的话，寻一次$rt$就是$\Theta(n)$的了，复杂度是不对的<del>但似乎Luogu的模板，不路径压缩会更快</del></p><ul><li><h2 id="Pop"><a href="#Pop" class="headerlink" title="$Pop$"></a>$Pop$</h2></li></ul><p>……$pop$的话，乱搞就好了$233$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br></pre></td></tr></table></figure><p>然后就是总代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line"><span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x03-一点问题"><a href="#rm-0x03-一点问题" class="headerlink" title="$\rm{0x03}$    一点问题"></a>$\rm{0x03}$    一点问题</h1><p>问题大概就是路径压缩……</p><p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">$LuoguP3377$</a>很不负责任地处了数据，导致以下这份代码可以过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, val, F, Son[<span class="number">2</span>] ;</span><br><span class="line">&#125;S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].F = S[rs].F = <span class="number">0</span>, Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">    rs = Merge(rs, y), S[rs].F = x ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">            <span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span> || B == C) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; Merge(f1, f2) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切都很正常，但问题在于他复杂度不对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br></pre></td></tr></table></figure><p>这显然是个上界为$O(n)$的函数……不寒而栗……</p><p>所以他是不对的，<a href="https://www.luogu.org/discuss/show/96561" target="_blank" rel="noopener">这组数据</a>可以很好的卡掉（由巨佬小粉兔制作）。</p><p>所以应该用一个并查集维护。而我们在路径压缩之后，必须要在$pop$后，给$pop$掉的点一个指针指向新的根，所以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br></pre></td></tr></table></figure><p>于是最后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 150010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap my_swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line"><span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x04-一道水题"><a href="#rm-0x04-一道水题" class="headerlink" title="$\rm{0x04}$    一道水题"></a>$\rm{0x04}$    一道水题</h1><p>无论怎么说，单独用一篇博客来整理板子题实在是太$Low$了（尤其是显得笔者很没品位），于是就直接拼到一起吧qwq</p><p><strong>[LuoguP1456]Monkey King</strong> <a href="https://www.luogu.org/problemnew/show/P1456" target="_blank" rel="noopener">链接</a></p><p>这玩意儿真tm水爆啊…直接存个代码证明我做过这道题吧qaq：</p><p>等会儿，突然想起来这道题的坑点来。就是原来的板子题，都是维护序列那种感觉，一个元素pop掉之后又就不用管它了。但是这道题是一道应用题，所以不应该删完不管，应该清空qwq。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a, i, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, dis, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> N, M, A, B, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == T[x].rt)  <span class="keyword">return</span> x ;</span><br><span class="line"><span class="keyword">return</span> T[x].rt = get(T[x].rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line"><span class="keyword">if</span> (T[x].val &lt; T[y].val) x ^= y ^= x ^= y ;</span><br><span class="line">rc = Merge(rc, y) ; <span class="keyword">if</span> (T[lc].dis &lt; T[rc].dis) lc ^= rc ^= lc ^= rc ;</span><br><span class="line">T[lc].rt = T[rc].rt = T[x].rt = x, T[x].dis = T[rc].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N))&#123;</span><br><span class="line"><span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">rep(<span class="number">1</span>, i, N) T[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T[i].val) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">rep(<span class="number">1</span>, i, M)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ; <span class="keyword">int</span> rt1, rt2 ;</span><br><span class="line"><span class="keyword">int</span> f1 = get(A), f2 = get(B) ; <span class="keyword">int</span> ff1, ff2 ;  </span><br><span class="line"><span class="keyword">if</span> (f1 == f2) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">T[f1].val &gt;&gt;= <span class="number">1</span>, T[f2].val &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">rt1 = Merge(T[f1].Son[<span class="number">0</span>], T[f1].Son[<span class="number">1</span>]) ; </span><br><span class="line">T[f1].Son[<span class="number">0</span>] = T[f1].Son[<span class="number">1</span>] = T[f1].dis = <span class="number">0</span> ; </span><br><span class="line">rt2 = Merge(T[f2].Son[<span class="number">0</span>], T[f2].Son[<span class="number">1</span>]) ; </span><br><span class="line">T[f2].Son[<span class="number">0</span>] = T[f2].Son[<span class="number">1</span>] = T[f2].dis = <span class="number">0</span> ; </span><br><span class="line">ff1 = Merge(f1, rt1), ff2 = Merge(f2, rt2) ;</span><br><span class="line">T[ff2].rt = T[ff1].rt = Merge(ff1, ff2), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[get(T[ff1].rt)].val) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\rm{writter:Flower_pks}$</p>]]></content>
    
    <summary type="html">
    
      一种支持nlogn合并的堆结构
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="可并堆/左偏树" scheme="http://www.orchidany.cf/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86-%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
  </entry>
  
</feed>
