<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orchidany.cf/"/>
  <updated>2019-12-15T11:49:54.949Z</updated>
  <id>http://www.orchidany.cf/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>http://www.orchidany.cf/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-12-15T11:49:54.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-teDXKlYX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-teDXKlYX"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th align="center">题目</th><th align="center">链接（点击即可）</th></tr></thead><tbody><tr><td align="center">随想一 · 山丘</td><td align="center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td align="center">随想二 · 丘吉尔</td><td align="center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td align="center">随想三 · 本赛季最后的随想/启示录</td><td align="center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td align="center">随想四 · 故人</td><td align="center">咕</td></tr><tr><td align="center">随想五 · 手中没有红玫瑰</td><td align="center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td align="center">随想六 · 难</td><td align="center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td align="center">随想七 · 言叶之庭</td><td align="center"><a href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td align="center">随想八 · 逃吧</td><td align="center">咕</td></tr><tr><td align="center">随想九 · 意义</td><td align="center"><a href="http://www.orchidany.cf/2019/07/18/Nine/">$Link$</a></td></tr><tr><td align="center">随想十 · 繁星</td><td align="center">咕</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="http://www.orchidany.cf/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【题解】树的直径泛做</title>
    <link href="http://www.orchidany.cf/2019/12/31/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%BA%94%E7%94%A8/"/>
    <id>http://www.orchidany.cf/2019/12/31/树的直径应用/</id>
    <published>2019-12-31T01:37:14.000Z</published>
    <updated>2020-01-01T11:29:03.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了做和这一块儿有关的题。</p><p><del>说是泛做然而只做了三道题</del></p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>嗯，首先就是考虑一点定义。</p><ul><li>树的直径：一棵树内最长的一条简单路径。</li></ul><p>然后关于直径有一些性质，大部分都可以拿反证法证出来：</p><ul><li><p>对树上随便一个点 $x$ 而言，与之相距最远的点一定是直径的某个端点。</p><ul><li>证明的话可以分类讨论:<ul><li><ol><li>对于直径上一点 $x$，离他最远点设为 $y$，不在直径上，那么直径完全可以从这个地方拐到 $y$ 从而变得更大，与直径的最优性矛盾。</li></ol></li><li><ol start="2"><li>对于非直径上一点 $x$，离他最远的点为 $y$，不在直径上。那么考虑设 $x$ 到直径上最近一点 $u$ 的距离为 $d_u$，直径远端的距离为 $d$，到 $y$ 的距离为 $d_y$。那么有 $d_y+d_u&gt;d$ 。于是考虑如果让直径从 $u$ 拐到 $y$ 的话显然会更优，与直径的最优性矛盾。 </li></ol></li></ul></li></ul></li><li><p>定义一棵树的 <strong>中心</strong> 为 $\max_{v\in T}{d_{u,v}}$ 最小的点 $u$，那么 $u$ 在直径上。</p><ul><li>证明的话考虑如果不在直径上，那么考虑到直径上最近的一点 $p$，发现 $p$ 对于直径的两个端点距离要小于 $p$ 。再结合上面证明过的，对于 $u$ 而言，$\max_{v\in T}{d_{u,v}}$ 一定会在直径上面取到，而 $u$ 的次远点到 $p$ 的距离一定小于 $p$ 到直径端点的距离，所以中心 $u$ 一定在直径上。</li></ul></li></ul><p>这两个结论有事还是很有用的2333</p><hr><p>以上是证明着玩的。接下来考虑直径的求法。</p><p>首先就是喜闻乐见的两遍 $dfs/bfs$ 求。大概就是考虑第一遍随便选一个点找一个与他相距最远的点 $u$， 那么 $u$ 一定会在直径上。之后再dfs求一遍最远点即可。由于固定了端点所以就直接脑残求就完了。</p><p>然而我是这么 $dfs$ 的。回想起来自己是个憨憨：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法是直接 $dp$ ，这个比较傻，维护最长链和次长链即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n), ans = max(ans, dp[n] + dp[to(k)] + val(k)) ;</span><br><span class="line">        dp[n] = max(dp[n], dp[to(k)] + val(k)) ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2 例题"></a>2 例题</h1><h2 id="1-APIO2010-巡逻"><a href="#1-APIO2010-巡逻" class="headerlink" title="1 [APIO2010]巡逻"></a>1 [APIO2010]巡逻</h2><blockquote><p>给定一棵树。可以连 $K~(K\in\{1,2\})$ 条额外的边使得从 $1$ 号点出发，遍历所有路径一次，使走的走路程最短。</p><p>同时有以下约束：</p><ul><li>每条路必须经过<strong>至少</strong>一次，点可以经过多次。</li><li>最后要回到一号点。</li></ul></blockquote><p>发现 $K=1$ 时比较容易考虑，把直径两端连起来放到最后走，这样一定是最优的。于是此时答案为 $2(n-1) - (L-1)=2n-L+1$ 。</p><p>然后考虑 $K=2$ 。发现 $K=2$ 时和 $K=1$ 情况大致相似，第一条边连直径。然后考虑第二条边，发现第二条边可能存在连出的圈与第一个圈有相交一部分的情况。但解决方法也很简单，把直径上的边权设置为其相反数即可。</p><p>然后就是求两遍直径就完事了233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)] || to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        val(k) = <span class="number">-1</span>, val(k ^ <span class="number">1</span>) = <span class="number">-1</span>, do_do(to(k), n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">do_dp(to(k), u), </span><br><span class="line">L2 = max(L2, d[to(k)] + val(k) + d[u]) ; </span><br><span class="line">d[u] = max(d[u], d[to(k)] + val(k)) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ;</span><br><span class="line">    dfs(n, <span class="number">0</span>), L1 = d[n] + (<span class="keyword">bool</span>)(K == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, n = pre[n] ;</span><br><span class="line">    vis[n] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; L1 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        do_do(n, <span class="number">0</span>) ;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)) ; </span><br><span class="line">do_dp(<span class="number">3</span>, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; L1 &lt;&lt; " " &lt;&lt; L2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * N - L1 - L2 &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-NOIp2007-树网的核"><a href="#2-NOIp2007-树网的核" class="headerlink" title="2 [NOIp2007]树网的核"></a>2 [NOIp2007]树网的核</h2><blockquote><p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：<br>$$<br>\max_{\begin{aligned}u,v &amp; \in \rm T\\ u\in V, &amp;v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}<br>$$</p><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p><p>$1\leq n\leq 5,000$</p></blockquote><p>类比一开始对中心的位置的证明，可以发现这段路径一定在直径上（事实上可以把这段路径缩成一个点来考虑）。然后就考虑先把直径找出来，然后 $n^2$ 枚举路径端点 $(p,q)$ ，$O(n)$ 算一下最长距离，这样是 $O(n^3)$ 的。然而发现可以贪心，链长期望越长，式子的值期望越小。所以可以 $n^2$ 预处理出来直径上离每个点最远且距离 $\leq s$ 的端点，然后 $n^2$ 做即可。最终复杂度 $n^2$。</p><h2 id="3-SDOI2011-消防"><a href="#3-SDOI2011-消防" class="headerlink" title="3 [SDOI2011]消防"></a>3 [SDOI2011]消防</h2><blockquote><p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：<br>$$<br>\max_{\begin{aligned}u,v &amp; \in \rm T\\ u\in V, &amp;v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}<br>$$</p><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p><p>$1\leq n\leq 500,000$</p></blockquote><p>……所以其实就是上一道题的加强版。</p><p>考虑怎么优化一下 $n^2$ 的算法，发现两部分都需要优化。首先考虑 <code>n^2 预处理出来直径上离每个点最远且距离 ≤ s 端点</code> 这东西，发现完全可以二分，于是变成了 $\log$ ；然后发现后一部分，完全可以一遍 $dp$ 求出来 “离直径上每个点最远的点的距离”这个东西，然后就可以 $\rm rmq$ 解决。然后两部分就都变成了 $n\log n$ 。（当然你也可以认为 $rmq$ 是 $O(\rm C)$ 的）</p><p>但实际上可以继续优化。首先发现的是那个二分可以拿尺取法做掉。之后考虑拿出之前整过的结论操作一下。令 $d_u$ 表示直径上一点 $u$ 在不经过直径的情况下，到某个非直径上点的最远距离。设直径的点集为 $l$，起点为 $s$， 终点为 $t$。那么答案就是</p><p>$$<br>\min_{i,j\in l} \{ \quad \max (dist_{s,i},dist_{j,t},\max_{v\in \mathrm{path}(i,j)} \{ d_v \}) \quad \}<br>$$<br>但是其实里面的最后一项 $\max_{v\in \mathrm{path}(i,j)} \{ d_v \}$ 可以被换成 $\max_{v\in l} \{ d_v \}$。原因是考虑当前枚举的段外一点（此处默认是在靠 $s$ 近的一侧） $w$ 的 $d_w$ 肯定会小于等于 $dist(s,w)$，而由于 $i$ 在这一段外面，所以 $dist(s,w)&lt;dist(s,i)$ ，也就是说对答案没有贡献，可以直接忽略掉。</p><p>于是最后就可以 $O(n)$ 做了。</p><p>然后先上一下 $rmq$ 的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        do_do(to(k), u) ;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">        d[u] = max(d[to(k)] + val(k), d[u]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> d[l] ;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt;= r - l) k ++ ;</span><br><span class="line">    k -- ; <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k)][k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span>, res = Inf ; </span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) rev[s[i]] = i ; </span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; ~j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) f[i][<span class="number">0</span>] = d[s[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j + (<span class="number">1</span> &lt;&lt; i) &lt;= tot + <span class="number">1</span> ; ++ j)</span><br><span class="line">            f[j][i] = max(f[j][i - <span class="number">1</span>], f[j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)][i - <span class="number">1</span>]) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = max(ans, d[i]) ; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ; <span class="comment">//cout &lt;&lt; base[tot] &lt;&lt; " " ; </span></span><br><span class="line">        res = min(res, max(max(base[l], base[tot] - base[r]), query(l, r))) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是另一个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &lt; b? a : b ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &gt; b? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">    N = read(), S = read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        u = read(), v = read(), w = read(), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = Max(ans, d[s[i]]) ; res = ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ;</span><br><span class="line">        res = Min(res, Max(Max(base[l], base[tot] - base[r]), ans)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    write(res) ; fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>程序猿的生命大多葬送给了调试。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了做和这一块儿有关的题。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;说是泛做然而只做了三道题&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="动态规划-树形DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="树上技巧/树的直径的应用" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】灭绝树</title>
    <link href="http://www.orchidany.cf/2019/12/30/%E7%81%AD%E7%BB%9D%E6%A0%91/"/>
    <id>http://www.orchidany.cf/2019/12/30/灭绝树/</id>
    <published>2019-12-30T12:50:59.000Z</published>
    <updated>2020-01-01T12:22:35.049Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来想学支配树，据说和灭绝树就是一个东西，就滚去学了灭绝树。</p><p>不过一说到灭绝树，脑海中就会勾勒出一副好久之前的场景，让人怀念……</p><a id="more"></a><h1 id="1-ZJOI2012-灾难"><a href="#1-ZJOI2012-灾难" class="headerlink" title="1 [ZJOI2012] 灾难"></a>1 [ZJOI2012] 灾难</h1><blockquote><p>给定一个 $\rm DAG$，定义灾难值：在一个节点被删去后以它为根从上到下逐步删去入度为 $0$ 的点，最终被删去的点的数量。求每个点的灾难值。</p><p>$n \leq 100,000$</p></blockquote><p>不说构造方面的东西了，直接考虑怎么做。直接建一棵树， $fa_x$ 记录的是这么一个点 $u$，表示如果 $u$ 挂了那么 $x$ 肯定会挂且 $dist(u,x)$ 最小。然后考虑这个东西实际上就是每个 $x$ 的入边的另一个端点在这棵树上的 $\rm LCA$ ，于是考虑边 <code>topsort</code> 边建树。然后子树大小 $-1$ 就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>], e[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], Head[MAXN], sz[MAXN], cnt1, cnt2 ;</span><br><span class="line"><span class="keyword">int</span> N, deg[MAXN], dep[MAXN], fa[MAXN], anc[MAXN][<span class="number">20</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ cnt1].to = v, e[cnt1].next = head[u], head[u] = cnt1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt2].to = v, E[cnt2].next = Head[u], Head[u] = cnt2 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = Head[u] ; k ; k = E[k].next)</span><br><span class="line">        dfs(E[k].to), sz[u] += sz[E[k].to] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, x, y ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">        <span class="keyword">while</span> (y) add1(y, i), deg[i] ++, <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; deg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) fa[i] = <span class="number">0</span>, q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        q.pop(), add2(fa[n], n) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[n] ; i ; i = e[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[e[i].to] == <span class="number">-1</span>) fa[e[i].to] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[e[i].to] = lca(n, fa[e[i].to]) ;</span><br><span class="line">            <span class="keyword">if</span> (!(-- deg[e[i].to])) q.push(e[i].to) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " " ;</span></span><br><span class="line">    dfs(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (sz[i] - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是很简单的吧？</p><h1 id="2-CF757F-Team-Rocket-Rises-Again"><a href="#2-CF757F-Team-Rocket-Rises-Again" class="headerlink" title="2 CF757F Team Rocket Rises Again"></a>2 CF757F Team Rocket Rises Again</h1><p>一道例题？</p><blockquote><p>给定一个 $n$ 个点，$m$ 条边的带权无向图和起点 $\rm S$。选择一个点 $u$ $(u\not =\rm S)$，使在图中删掉点 $u$ 后，有尽可能多的点到 $\rm S$ 的最短距离改变。</p><p>$n\leq 200,000$</p></blockquote><p>在发现求完一遍最短路这个图变成 DAG之后，这道题就变成了一道傻题。</p><p>哦，忘了，有个坑点。他可能给的这个图一开始不连通，所以要判一下 <code>vis</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    E[m][++ cnt[m]].to = v, E[m][cnt[m]].val = w,</span><br><span class="line">    E[m][cnt[m]].next = head[m][u], head[m][u] = cnt[m] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">2</span>][u] ; k ; k = E[<span class="number">2</span>][k].next)</span><br><span class="line">        dfs(E[<span class="number">2</span>][k].to), sz[u] += sz[E[<span class="number">2</span>][k].to] ;</span><br><span class="line">    <span class="keyword">if</span> (vis[u] &amp;&amp; u &amp;&amp; u != S) ans = max(ans, sz[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w),</span><br><span class="line">        add(<span class="number">0</span>, u, v, w), add(<span class="number">0</span>, v, u, w) ;</span><br><span class="line">    q.push(S) ; vis[S] = <span class="number">1</span> ;</span><br><span class="line">    fill(dis + <span class="number">1</span>, dis + N + <span class="number">1</span>, Inf), dis[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ; q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">0</span>][n] ; k ; k = E[<span class="number">0</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[E[<span class="number">0</span>][k].to] &gt; dis[n] + E[<span class="number">0</span>][k].val)&#123;</span><br><span class="line">                dis[E[<span class="number">0</span>][k].to] = dis[n] + E[<span class="number">0</span>][k].val ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[E[<span class="number">0</span>][k].to])</span><br><span class="line">                    vis[E[<span class="number">0</span>][k].to] = <span class="number">1</span>, q.push(E[<span class="number">0</span>][k].to) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[<span class="number">0</span>][i] ; j ; j = E[<span class="number">0</span>][j].next)</span><br><span class="line">            <span class="keyword">if</span> (dis[i] + E[<span class="number">0</span>][j].val == dis[E[<span class="number">0</span>][j].to])</span><br><span class="line">                add(<span class="number">1</span>, i, E[<span class="number">0</span>][j].to, <span class="number">0</span>), deg[E[<span class="number">0</span>][j].to] ++ ;</span><br><span class="line">    fill(vis, vis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    q.push(S), fa[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        q.pop(), vis[n] = <span class="number">1</span>, add(<span class="number">2</span>, fa[n], n, <span class="number">0</span>) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>][n] ; k ; k = E[<span class="number">1</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ww = E[<span class="number">1</span>][k].to ;</span><br><span class="line">            <span class="keyword">if</span> (!(~fa[ww])) fa[ww] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[ww] = lca(fa[ww], n) ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[ww]) q.push(ww) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-吐槽"><a href="#3-吐槽" class="headerlink" title="3 吐槽"></a>3 吐槽</h1><p>这东西在 Luogu 上也能算紫色的？</p><h1 id="4-一点回忆"><a href="#4-一点回忆" class="headerlink" title="4 一点回忆"></a>4 一点回忆</h1><p>那是 18 年的 4 月。想来已经是前年了，有些伤感。</p><p>当时金牌教练让 rqy 给我们出题考试，题目如下：</p><div class="pdf" target="./P0.pdf" height></div><p>T1是个有点 tricky 的最小字典序最大独立集，T2就是个灭绝树的板子，T3是个 DLX 的板子。然而当时大家最高分只有 $60$ 分也是有点惨惨。</p><p>还记得当时大家几乎都在认真地做 T2，我在做 T1 的前 60 分。然而最后 T1 还是因为边表没开两倍而 RE 挂了 40，大家 T2 都是枚举每个点然后再去 topsort , 可惜当时我连 topsort 也不会。</p><p>然后大家考完之后，听完 rqy 讲题就开始研究 T2，发现原来就是“[ZJOI]灾难”那题。然后大家就都去做了那道题。</p><p>还记得wx在考场上已经想出了几近正解，当时自己只会膜。</p><p>到现在为止，“灾难”这题在Luogu的题解区，地一篇题解依旧是wx的，他的前三条评论依旧是我的。</p><p>感觉……有点伤感。不知道是不是机房太冷的缘故，感到大脑有些麻木。是啊，rqy不再是当年的rqy了，LCEZ55级机房也不是之前那个LCEZ55级机房了，也搬到了新校。总之，一切都变了。</p><p>倒不是说改变不好，只是那些夕阳下的场景总是让现如今孑然一身的我感到有些无所适从。</p><p>看来我就是那被遗忘在时光里的老人了吧。</p><p>要说启迪什么的，大概就是不要再等到失去之后发现自己当时有多么愚蠢。</p><p>以前总是不理解为什么 rqy 要为了没有人陪他学OI而哭，现在才发现，“哦，原来是这样子的感觉啊”。</p><p>『 初闻不解戏中意，如今已是戏中人。』</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来想学支配树，据说和灭绝树就是一个东西，就滚去学了灭绝树。&lt;/p&gt;
&lt;p&gt;不过一说到灭绝树，脑海中就会勾勒出一副好久之前的场景，让人怀念……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="灭绝树" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%81%AD%E7%BB%9D%E6%A0%91/"/>
    
    
      <category term="倍增" scheme="http://www.orchidany.cf/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="图论/灭绝树" scheme="http://www.orchidany.cf/tags/%E5%9B%BE%E8%AE%BA-%E7%81%AD%E7%BB%9D%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Cf Round 250</title>
    <link href="http://www.orchidany.cf/2019/12/30/CFR250/"/>
    <id>http://www.orchidany.cf/2019/12/30/CFR250/</id>
    <published>2019-12-30T12:43:12.000Z</published>
    <updated>2020-01-02T00:37:16.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先呢，做这一场的原因是看了 vfk 的 blog（<a href="https://blog.csdn.net/VFleaKing/article/details/90521383" target="_blank" rel="noopener">戳我</a>）感觉很有趣，并且似乎以前的 CF 的 <code>div1</code> 难度比现在低一点，于是就打算做一下。</p><p>嗯，是一场 CNround，可能会更贴合国内的出题氛围？感觉质量还是很好的233.</p><p>题号是 $\rm CF437/438$。</p><p>向前辈们致敬！</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>给出一个四项选择题，三长选一短，三短选一长，否则选 $C$。</p><p>其中“短”和“长”限制了 2 倍关系。</p></blockquote><p>我不会告诉你这题我交了5遍:(</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; L[<span class="number">4</span>] ;</span><br><span class="line"><span class="keyword">char</span> I[<span class="number">4</span>][MAXN] ; <span class="keyword">int</span> ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (I[<span class="number">0</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">1</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">2</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">3</span>] + <span class="number">1</span>) ;</span><br><span class="line">    L[<span class="number">0</span>].sc = <span class="number">0</span>, L[<span class="number">1</span>].sc = <span class="number">1</span>, L[<span class="number">2</span>].sc = <span class="number">2</span>, L[<span class="number">3</span>].sc = <span class="number">3</span> ;</span><br><span class="line">    L[<span class="number">0</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">0</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">1</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">1</span>] + <span class="number">1</span>) - <span class="number">2</span> ;</span><br><span class="line">    L[<span class="number">2</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">2</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">3</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">3</span>] + <span class="number">1</span>) - <span class="number">2</span> ; </span><br><span class="line">  sort(L, L + <span class="number">4</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">3</span>].fr &gt;= L[<span class="number">2</span>].fr * <span class="number">2</span>) ++ ans ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">0</span>].fr * <span class="number">2</span> &lt;= L[<span class="number">1</span>].fr) ans += <span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">3</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ans == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">0</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"C"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给你两个整数$n$, $m$，要求在 $1\sim m$ 中选任意个数 $x_i$，使得 $\sum lowbit(x_i)=n$ 。 </p></blockquote><p>一开始脑残写了一堆奇怪的东西？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, cnt, ans[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x &amp; (-x)) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        p[i] = make_pair(lowbit(i), i) ;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + M + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= p[i].first)</span><br><span class="line">            N -= p[i].first, ans[++ cnt] = p[i].second ;</span><br><span class="line">    <span class="keyword">if</span> (N) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">    <span class="comment">/*while (N)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; N &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        if (N == lowbit(N))</span></span><br><span class="line"><span class="comment">            ans[++ cnt] = N ;</span></span><br><span class="line"><span class="comment">        else ans[++ cnt] = lowbit(N) ;</span></span><br><span class="line"><span class="comment">        if (ans[cnt] &gt; M) return puts("-1") ;</span></span><br><span class="line"><span class="comment">        else N -= lowbit(N) ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">while</span> (cnt) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[cnt --]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>$n$ 个带权点，$m$ 条无向边，删除一个点就要付出所有与之有相连且没有被删除的点的点权之和的代价。</p><p>求删除所有点的最小代价。</p><p>$n,m\leq 200,000$</p></blockquote><p>小清新题，可能需要想一会儿。由于发现最后每条边只会被删一次，且每条边显然都可以做到被小权值的点删掉，于是答案就是 $\sum <em>{k\in E} \min(val</em>{from(k)},val_{to(k)})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, j, u, v ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, ans += <span class="number">1l</span>l * min(base[u], base[v]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>给定一张点权图，随机选两个点，求两点间所有简单路径中路径上最小点权的最大值的期望。</p><p>$n,m\leq 200,000$</p></blockquote><p><del>开始时一直读不懂题我好难啊</del></p><p>大概就是考虑一遍建生成树一边建生成树一边同记。首先考虑路径一定会在最大生成树上。然后发现由于是最小点权，所以要用小的那个点来统计答案。于是排好序后，对于加入一个点 $u$ 之前的那些点，点权都大于 $u$ 。所以此时 $u$ 可以作为只剩下权值比他大的点时的图中的答案点，统计一下即可。</p><p>嗯，是个 trick。记得当时做“货车运输”那题是为了应付作业直接 copy 的同学的代码，导致后来一直不是很熟悉……233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], fa[MAXN], sz[MAXN], Id[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> base[a] &gt; base[b] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) sz[i] = <span class="number">1</span>, fa[i] = Id[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    sort(Id + <span class="number">1</span>, Id + N + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        LL ctn = <span class="number">0</span> ; <span class="keyword">int</span> n = Id[i], f1, f2 ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[n] ; j ; j = next(j))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to(j)]) <span class="keyword">continue</span> ;</span><br><span class="line">            f1 = find(n), f2 = find(to(j)) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ctn += <span class="number">1l</span>l * sz[f1] * sz[f2],</span><br><span class="line">                sz[f1] += sz[f2], fa[f2] = f1 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1l</span>l * base[n] * ctn, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ans * <span class="number">2.0</span> / (<span class="number">1.0</span> * N * (N - <span class="number">1</span>))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给出 $n$ 个点，求这个多边形的三角剖分的方案数对 $1e9+7$ 取模。</p><p>$n\leq 200$</p></blockquote><p>恕我直言…我对三角剖分唯一知道的就是能叉出多边形面积来233</p><p>根据数据范围猜算法，发现应该是区间 $dp$ 的形式。$f_{l,r}$ 表示区间 $l,r$ 内的点的三角剖分方案数。那么转移就是考虑<br>$$<br>f_{l,r}=\sum_{k=l}^{r} [\mathrm{convex}(l\to k\to r)]\cdot (f_{l,k}\times f_{k,r})<br>$$<br>其中 $[]$ 还是艾佛森括号，$\rm convex$ 函数为一个 $0/1$ 函数，返回给定的三个点对于整个多边形是否是凸的。</p><p>然后为了快速判断这个东西，可以先把所有点按照一个方向排一圈，然后叉积求出是否在外侧。</p><p>以下是如何用叉积去判:</p><p>如果 $a\times b &lt; 0$ 说明 $a$ 在 $b$ 的逆时针方向， $=0$ 说明通向， $&gt;0$ 说明 $a$ 在 $b$ 的顺时针方向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">double</span> s ;</span><br><span class="line">LL f[MAXN][MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    nodes <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (nodes)&#123;a.x - b.x, a.y - b.y&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    s += base[N] * base[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        s += base[i] * base[i + <span class="number">1</span>], f[i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) reverse(base + <span class="number">1</span>, base + N + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">2</span> ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> ((base[i] - base[j]) * (base[k] - base[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                    (f[j][i] += f[j][k] * f[k][i]) %= Mod ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][N] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote><p>给定数列，区间查询和，区间取模，单点修改。</p><p>$1\leq n,m\leq 100,000,\quad 0\leq a_i\leq 10^9$。</p></blockquote><p>大概就是发现取模的一个性质，就是取模成功之后数值至少减半。可以分类讨论 $p&gt;\frac{n}{2}$ 和 $p\leq \frac{n}{2}$ ，发现 $n$ 对  $p$ 取完膜之后肯定 $&lt;\frac{n}{2}$ 。于是这东西就是 $\log$ 的。于是就可以直接 $m \log n + m\log a_i$ 做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mk, n, m, base[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N &lt;&lt; <span class="number">1</span>] ; LL s[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid) ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) _change(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> _change(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] %= mod, s[rt] %= mod, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, mod) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, mod) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r)) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;v),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;v), _change(<span class="number">1</span>, <span class="number">1</span>, n, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><blockquote><p>求每个结点都有个权值只在 $c_1, c_2, …, c_n$中取的，总点权为 $s$ 的二叉树的个数。对于每个 $1 \leq s \leq m$ 计算答案。</p><p>$1\leq n,m \leq 10^5$ 。</p></blockquote><p>发现其实是一个卡特兰数的转移形式。令 $f_n$ 表示总点权为 $n$ 的二叉树个数，那么转移应该这么转移：<br>$$<br>f_n=[n=0]+\sum_{p=1}^{m}[p\in c] \sum_{q=0}^{m-p}f_{q}f_{m-p-q}<br>$$<br>发现后面是 $p + q + m-p-q=m$ 是卷积的形式，然后如果设 $\{ f_n\}$ 的生成函数为 $\rm F$， $g_x=[x\in c]$，$\{g_n\}$ 的生成函数为 $\rm G$，则有：<br>$$<br>\rm F = G\times F^2+1<br>$$<br>那么解一下可以得到<br>$$<br>\rm F=\frac{1±\sqrt{1-4G}}{2G}<br>$$<br>发现改变一下形式之后：<br>$$<br>\rm F=\frac{2}{1±\sqrt{1-4G}}<br>$$<br>这东西，在取负号的时候，分母是不存在逆元的。所以分母取正号。</p><p>然后就多项式一顿套就完了233。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gp = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, Gi, R[MAXN] ;</span><br><span class="line">LL G[MAXN], H[MAXN], F[MAXN], t[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> L, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr LL Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        Gn = expow(Gp, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = Gi * Gn % P)&#123;</span><br><span class="line">                rr <span class="keyword">int</span> real = J[j + k], iroot = J[j + k + i] * Gi % P ;</span><br><span class="line">                J[j + k] = (real + iroot) % P, J[j + k + i] = (real - iroot + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Inv = expow(L, P - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Inv(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, <span class="number">1</span>), NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - t[i] * g[i] % P + P) % P * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">LL Ig[MAXN], pf[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _sqr(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)&#123; g[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _sqr(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) Ig[i] = <span class="number">0</span>, pf[i] = <span class="number">2</span> * g[i] % P ;</span><br><span class="line">    _Inv(pf, Ig, len) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) <span class="comment">/* */</span> t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; ( l - <span class="number">1</span> )) ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; NTT(Ig, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, l = <span class="number">1</span> ;</span><br><span class="line">    Gi = expow(Gp, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, ++ K, M = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j), F[j] = <span class="number">1</span> ;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        F[i] = (<span class="number">-4l</span>l * F[i] % P + P) % P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; F[i] &lt;&lt; " " ;</span></span><br><span class="line">    _sqr(F, G, K), (G[<span class="number">0</span>] += <span class="number">1</span>) %= P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; G[i] &lt;&lt; " " ;</span></span><br><span class="line">    _Inv(G, H, K) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, H[i] * <span class="number">2l</span>l % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先呢，做这一场的原因是看了 vfk 的 blog（&lt;a href=&quot;https://blog.csdn.net/VFleaKing/article/details/90521383&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我&lt;/a&gt;）感觉很有趣，并且似乎以前的 CF 的 &lt;code&gt;div1&lt;/code&gt; 难度比现在低一点，于是就打算做一下。&lt;/p&gt;
&lt;p&gt;嗯，是一场 CNround，可能会更贴合国内的出题氛围？感觉质量还是很好的233.&lt;/p&gt;
&lt;p&gt;题号是 $\rm CF437/438$。&lt;/p&gt;
&lt;p&gt;向前辈们致敬！&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="多项式的应用" scheme="http://www.orchidany.cf/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="组合计数/生成函数" scheme="http://www.orchidany.cf/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】李超树</title>
    <link href="http://www.orchidany.cf/2019/12/28/%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    <id>http://www.orchidany.cf/2019/12/28/李超树/</id>
    <published>2019-12-28T08:53:30.000Z</published>
    <updated>2020-01-02T00:08:03.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>李超树，一种奇怪的数据结构——然而其实是线段树，用于维护平面优势直线。</p><p>顺便学了学标记永久化。</p><a id="more"></a><p>虽然不知道是谁，但是先orz李超233</p><h1 id="1-标记永久化"><a href="#1-标记永久化" class="headerlink" title="$1$ 标记永久化"></a>$1$ 标记永久化</h1><p>似乎李超树不是很好 <code>push_down</code> 的样子，于是去网上学了一发。大概思想就是，线段树区间维护时信息不再打标记，而是选择把标记打在自己身上不再下传。查询的时候一路查下去，记录覆盖在这条路径上的信息，然后基于修改的信息对整个区间的信息合并一下即可。</p><p>然后是瞎写的伪代码？Sumblime 3 真好用，自创语法真有趣233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认区间修改 = 区间的每个单点更新信息 </span></span><br><span class="line">Class Segment_Tree&#123;</span><br><span class="line">Inform * Tag, Val ;</span><br><span class="line"><span class="keyword">int</span> : L, R, Mid, Lson, Rson ;</span><br><span class="line"><span class="function">Function <span class="title">Clear</span><span class="params">()</span> </span>&#123;....&#125; ;</span><br><span class="line">&#125;<span class="comment">//其中 *Tag 是当前点维护信息时打的标记，*Val 是当前节点的信息。</span></span><br><span class="line"></span><br><span class="line">Function[Inform] Merge(Inform * n, Inform * m) &#123;....&#125; ;</span><br><span class="line">Function[<span class="keyword">void</span>] Update(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line">Do_Some_Work(T[root], qL, qR, S) ;</span><br><span class="line"><span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR)</span><br><span class="line"><span class="keyword">return</span> T[root].Tag = Merge(S, T[root].tag), <span class="keyword">void</span>() ;  </span><br><span class="line"><span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">Update(T, T[root].Lson, qL, qR, S) ;</span><br><span class="line"><span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">Update(T, T[root].Rson, qL, qR, S) ;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>() ; </span><br><span class="line">&#125;</span><br><span class="line">Function[Inform] Query(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line"><span class="comment">//询问操作，最后一个参数代表一路询问下来的合并标记</span></span><br><span class="line">Inform * res ; res = EMPTY ; </span><br><span class="line"><span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR) </span><br><span class="line"><span class="keyword">return</span> res = Merge(T[root].Val, S) ; </span><br><span class="line"><span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">res = Merge(res, Query(T, T[root].Lson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line"><span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">res = Merge(res, Query(T, T[root].Rson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-李超树"><a href="#2-李超树" class="headerlink" title="$2$ 李超树"></a>$2$ 李超树</h1><p>首先李超树的最简单操作就是：</p><ul><li>向平面内添加一条直线</li><li>查询覆盖在某个坐标上的直线中，纵坐标值最大/最小值</li><li>$n,m\leq 200,000$</li></ul><p>考虑如何维护这个东西，考虑维护每个点代表区间的<strong>优势直线</strong>，即在大多数区域内<strong>可能</strong>是最优解的那条线——或者，在代表区间的中点是最优解的直线。这么做采用了启发式的思想，保存了有限多的备选最优解。于是就可以保证最后询问的时候，采用标记永久化的思想，取所有覆盖在一个单点上的优势直线的最大值即可，复杂度 $\log n$ 。</p><p>那么考虑怎么维护优势区间。假设区间 $\rm [L,R]$ 的优势直线为 $l$ ，现在插入一条直线 $l’$，开始分类讨论：</p><ul><li><p>如果当前区间的左端和右端都满足 $l’$ 更优，那么直接拿 $l’$ 替代。</p></li><li><p>如果当前取件的左端和右端都满足 $l’$ 更劣，那么 $l’$ 爱滚哪去滚哪去。</p></li><li><p>$\mathrm {slope}(l’)&gt;\mathrm{slope}(l)$</p><ul><li><p>当 $l$ 在中点处的值比 $l’$ 劣时，那么左区间可能要算一波，右区间就一定会是 $l’$ 更优。这个时候为了保证 $l$ 作为潜在的优选方案不丢失，就把 $l’$ 保存在当前区间，把 $l$ 送到自己的左儿子区间。</p></li><li><p>$l’$ 更劣时，那么右区间可能算一波，当前区间的优势直线也不会变，所以只去改右区间即可。</p></li></ul></li><li><p>$\mathrm {slope}(l’)&lt;\mathrm{slope}(l)$</p><ul><li>同理可证，显然，证毕（</li></ul></li></ul><p>于是就上代码，模板题 <code>LG4254 JSOI2008 BlueMarry开公司</code>。注意本题给的直线需要平移一下再用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ; <span class="keyword">int</span> m, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[id] * (x - <span class="number">1</span>) + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">    o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">    q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">    s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (k[v[rt]] &gt; k[id20])</span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v[rt]), v[rt] = id ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, v[rt]), v[rt] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val(x, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span>, l, mid, x)) ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'P'</span>)</span><br><span class="line">            ++ cnt,</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;b[cnt], &amp;k[cnt]),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, cnt) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)query(<span class="number">1</span>, <span class="number">1</span>, n, x) / <span class="number">100</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-一道例题"><a href="#3-一道例题" class="headerlink" title="$3$ 一道例题"></a>$3$ 一道例题</h1><p>例题就是 <code>HEOI2013 Segment</code> 。插入一条<strong>线段</strong>，维护每个横坐标的优势线段编号。</p><p>发现魔改一下就可以。然后一个坑点就是斜率为 $\inf$ 的线段要特殊处理一下，然而一开始自己直接把这种线段的 $\max val$ 当作 $\inf$ 算了也是很降智。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 19260817.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M1 39989</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M2 1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> L, m, mk, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * x * k[id] + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">        o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">        q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">        s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">        <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (k[v[rt]] &gt; k[cnt])</span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span>, l, mid, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M1 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M2 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, e, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)&#123;</span><br><span class="line">            ++ cnt ;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;e, &amp;c, &amp;d) ;</span><br><span class="line">            a = w(a), e = g(e), c = w(c), d = g(d) ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; a &lt;&lt; " " &lt;&lt; e &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt; c) swap(a, c), swap(d, e) ;</span><br><span class="line">            <span class="keyword">if</span> (c == a) k[cnt] = <span class="number">0</span>, b[cnt] = max(d, e) ;</span><br><span class="line">            <span class="keyword">else</span> k[cnt] = (<span class="keyword">double</span>)(d - e) / (<span class="keyword">double</span>)(c - a),</span><br><span class="line">                 b[cnt] = <span class="number">1.0</span> * d - <span class="number">1.0</span> * c * k[cnt] ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; k[cnt] &lt;&lt; " " &lt;&lt; b[cnt] &lt;&lt; endl ;</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, a, c, cnt) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), x = w(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L = query(<span class="number">1</span>, <span class="number">1</span>, n, x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;李超树，一种奇怪的数据结构——然而其实是线段树，用于维护平面优势直线。&lt;/p&gt;
&lt;p&gt;顺便学了学标记永久化。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="李超树" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    
    
      <category term="数据结构/李超树" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9D%8E%E8%B6%85%E6%A0%91/"/>
    
      <category term="数据结构/线段树" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】对抗搜索与Alpha-Beta剪枝</title>
    <link href="http://www.orchidany.cf/2019/12/28/%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2/"/>
    <id>http://www.orchidany.cf/2019/12/28/对抗搜索/</id>
    <published>2019-12-28T08:52:48.000Z</published>
    <updated>2019-12-31T03:28:01.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学了一下比较简单的博弈模型的常规求解方式，发现就是爆搜。顺便学了有启发式思想的 Alpha-Beta 剪枝，现在觉得是玄学……可能还是记搜比较靠谱？</p><a id="more"></a><h1 id="1-对抗搜索"><a href="#1-对抗搜索" class="headerlink" title="1 对抗搜索"></a>1 对抗搜索</h1><p>……然而其实就是搜索。每次大概就是记录一下双方的决策结果和（哈希之后的）局面，然后改谁走谁走就完了。伪代码大概可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">Value res = -Inf ;</span><br><span class="line">State Moveable_Set = calc(S) ;   </span><br><span class="line"><span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">Value now = evaluate(doMin(S)) ;</span><br><span class="line"><span class="keyword">if</span> [now &gt; res] res = now ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">Value res = Inf ;</span><br><span class="line">State Moveable_Set = calc(S) ;   </span><br><span class="line"><span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">Value now = evaluate(doMax(S)) ;</span><br><span class="line"><span class="keyword">if</span> [now &lt; res] res = now ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是交替迭代的思想。</p><p>考虑一棵博弈树，节点承载的信息是局面 。那么对于一个零和博弈游戏，双方必然是让自己得益更多，于是考虑转化一下，令局面的分数为「先手的分数 - 后手的分数」，那么先手就是最大化局面分数，后手则是最小化。</p><p>于是定义轮到<strong>最大化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Max}$<strong>节点</strong>，轮到<strong>最小化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Min}$<strong>节点</strong> 。那么显然在博弈树上同类节点集合是一个独立集。这种博弈也叫做 <strong>零和博弈完全信息公平博弈</strong> ，双方的目的均是 <strong>最值化局面分数</strong>。</p><h1 id="2-Alpha-Beta-剪枝"><a href="#2-Alpha-Beta-剪枝" class="headerlink" title="2 Alpha-Beta 剪枝"></a>2 Alpha-Beta 剪枝</h1><p>然后这东西就是一个剪枝，给每个节点一个 $\alpha$ 下界和 $\beta$ 上界。类比状态转移，考虑相邻的状态，大致如下：</p><ul><li><p>假设当前节点为 $\boldsymbol{Max}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Max}$ 状态的分数 $&gt;$ <strong>上一层</strong>决策的分数<strong>上限</strong> $\beta’$，那么当前节点的父亲节点，$\boldsymbol{Min}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Max$ 决策。</p></li><li><p>假设当前节点为 $\boldsymbol{Min}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Min}$ 状态的分数 $&lt;$ <strong>上一层</strong>决策的分数<strong>下限</strong> $\alpha’$，那么当前节点的父亲节点，$\boldsymbol{Max}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Min$ 决策。</p></li><li><p>于是我们记录 $\alpha$ 值为每个 $\boldsymbol{Max}$ 状态的<strong>得分下界</strong>，$\beta$ 值为每个 $\boldsymbol{Min}$ 状态的得分下界。初始为 $\alpha=-\infty,\beta=+\infty$</p></li><li><p>考虑优化的意义。当前状态的分支可能有很多，但是如果在搜第一个分支的时候就发现已经有 $\alpha_n&gt;\beta_{fa_n}$ 了，那么 $fa_n$ 就一定不会走这个决策（毕竟最次也可以让对方得益），于是剩下的分支就不用再搜了。</p></li><li><p>显然，这种决策是启发性的。同时有以下特点：</p><ul><li><p>决策顺序影响时间效率。如果每次搜都在第一次跳出自然可以让时间上做到最优，但是如果每次都在最后一次跳出就是压根没剪。</p></li><li><p>不可以裸的记忆化。考虑每个节点如果要记忆化，记下来的应该是当前状态能扩展到的最优局面。但是 Alpha-Beta 剪枝的目的就是在未得到这个点的最优决策时，已经知道该不该继续走。</p></li></ul></li></ul><p>然后就是伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S, Value alpha, Value beta)</span></span>&#123;</span><br><span class="line">State Moveable_Set = calc(S) ;   </span><br><span class="line"><span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">Value now = evaluate(doMin(S)) ;</span><br><span class="line"><span class="keyword">if</span> [now &gt; alpha] alpha = now ;</span><br><span class="line"><span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> alpha ;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> alpha ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S, Value alpha, Value Beta)</span></span>&#123;</span><br><span class="line">State Moveable_Set = calc(S) ;   </span><br><span class="line"><span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">Value now = evaluate(doMax(S)) ;</span><br><span class="line"><span class="keyword">if</span> [now &lt; beta] beta = now ; </span><br><span class="line"><span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> beta ;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> beta ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话，我们顶多是能快速计算谁赢谁输而不是赢多少/输多少。于是考虑魔改一下：</p><p>版本一：某一方获利最多。参考题目：[九省联考]一双木棋，可以拿到 $70pts$</p><p>其实就是修改一下终态的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet, <span class="keyword">int</span> sa, <span class="keyword">int</span> sb)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (dep &gt;= N * M) <span class="keyword">return</span> sa - sb ; <span class="keyword">int</span> val, b = dep &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    memset(R[b], 0, sizeof(R[b])) ;</span></span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "A" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa + A[i][j], sb) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span> ; alp = max(val, alp) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> alp ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "B" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa, sb + B[i][j]) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> bet ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二：败方存活时间最长。参考题目：[CQOI2013]棋盘游戏，可以拿到 $40pts$</p><p>这种的话就直接返回 $-1^{\text{胜方}}\times \text{深度}$ 即可，最大化的就是败方存活的最大深度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> xa, <span class="keyword">int</span> ya, <span class="keyword">int</span> xb, <span class="keyword">int</span> yb, <span class="keyword">bool</span> w, <span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt; <span class="number">3</span> * N) <span class="keyword">return</span> _d_a_y ;</span><br><span class="line">    <span class="keyword">if</span> (xa == xb &amp;&amp; ya == yb) <span class="keyword">return</span> w ? -step : step ; <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">if</span> (!w)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = xa + dx[i], ky = ya + dy[i] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                val = dfs(kx, ky, xb, yb, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                alp = max(alp, val) ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = xb + dx[i], ky = yb + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            val = dfs(xa, ya, kx, ky, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">            bet = min(val, bet) ; <span class="keyword">if</span> (bet &lt;= alp) <span class="keyword">return</span> bet ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bet ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-两道例题"><a href="#3-两道例题" class="headerlink" title="3 两道例题"></a>3 两道例题</h1><p>uva好啊。</p><h2 id="1-UVA10111-Find-the-Winning-Move"><a href="#1-UVA10111-Find-the-Winning-Move" class="headerlink" title="$(1$ UVA10111 Find the Winning Move"></a>$(1$ UVA10111 Find the Winning Move</h2><blockquote><p>两人下 $4\times 4$ 的井字棋，给出一个残局，问是否有先手必胜策略。</p><p>井字棋：必须要四子连珠才能赢。</p></blockquote><p>这东西只问赢没赢，于是就可以愉快地把局面分数赋为 $1/-1$。搜就完事了233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">        res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[i][j] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[j][i] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][<span class="number">5</span> - i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = (ans - step) &amp; <span class="number">1</span>, val ;</span><br><span class="line">    <span class="keyword">if</span> (!st)&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">2</span>) || !step) <span class="keyword">return</span> -check(<span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">1</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt; alp)&#123;</span><br><span class="line">                        alp = val ;</span><br><span class="line">                        <span class="keyword">if</span> (step == ans)</span><br><span class="line">                            resx = i - <span class="number">1</span>, resy = j - <span class="number">1</span> ;</span><br><span class="line">                        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">1</span>) || !step) <span class="keyword">return</span> check(<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">2</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                    <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> bet ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'$'</span>) <span class="keyword">return</span> <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, bc[i] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">                base[i][j] = bc[i][j] == <span class="string">'x'</span> ? <span class="number">1</span></span><br><span class="line">                          : (bc[i][j] == <span class="string">'.'</span> ? <span class="number">0</span> : <span class="number">2</span>) ;</span><br><span class="line">                ans += (!base[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= <span class="number">12</span>) &#123; <span class="built_in">puts</span>(<span class="string">"#####"</span>) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line">        ans = battle(ans, <span class="number">-1</span>, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>, resx, resy) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"#####"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-UVA751-Triangle-War"><a href="#2-UVA751-Triangle-War" class="headerlink" title="$(2$ UVA751 Triangle War"></a>$(2$ UVA751 Triangle War</h2><blockquote><p>给出 $10$ 个点，共有 $18$ 条边，每次 $A,B$ 两个人轮流加入一条边。A先加。</p><p>如果形成一个三角形，则三角形归他所有，<strong>而且还必须再走一步</strong>。最后三角形多的人胜。</p><p>现在已经给出一部分已经完成的步数，由于两位玩家都是<strong>最聪明的</strong>，他们都会走<strong>为自己带来最大优势</strong>的步数。你需要判断谁会赢得游戏。</p></blockquote><p>一道憨憨题。发现可以直接状压且每个询问图不变，所以果断<del>打开题解找到思路差不多的把打的表copy过来</del>手推。然后其实就是一开始先把初始状态走完，然后因为一共九个三角形，所以如果一方比另一方多 $5$ 个游戏就结束了，于是发现可以把这个差值当做局面分数，搜就完事了。</p><p>还有一个烂大街的 $trick$，按秩转移每条边于是想到 $\rm lowbit$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q, T, M, A[N][N], st[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e[<span class="number">11</span>][<span class="number">11</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">17</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">16</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t[<span class="number">9</span>] = &#123;<span class="number">7</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">448</span>, <span class="number">3584</span>, <span class="number">6160</span>, <span class="number">28672</span>, <span class="number">49280</span>, <span class="number">229376</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span></span>&#123;</span><br><span class="line">    rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (((p &amp; t[i]) != t[i]) &amp;&amp; ((q &amp; t[i]) == t[i])) ++ ret ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">0</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">1</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> O = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>, ss ;</span><br><span class="line">    <span class="keyword">int</span> _rest = s ^ O, now, val ;</span><br><span class="line">    <span class="keyword">for</span> ( ; _rest ; _rest -= low(_rest))&#123;</span><br><span class="line">        now = calc(s, ss = s | low(_rest)) ;</span><br><span class="line">        <span class="keyword">if</span> (n)</span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            bet = min(bet, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            alp = max(alp, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n ? bet : alp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T, Q = T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M) ;</span><br><span class="line">        st[<span class="number">0</span>] = st[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> _state = <span class="number">0</span>, n = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, z, i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), </span><br><span class="line">            z = calc(_state, _state | (<span class="number">1</span> &lt;&lt; e[x][y])) ;</span><br><span class="line">            _state |= (<span class="number">1</span> &lt;&lt; e[x][y]), st[n] += z, n ^= (((<span class="keyword">bool</span>)z) ^ <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; _state &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game %d: "</span>, Q - T) ;</span><br><span class="line">        <span class="keyword">if</span> (battle(n, _state, <span class="number">-23333</span>, <span class="number">23333</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"A wins.\n"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"B wins.\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学这个就图一乐。想得高分请记搜/kel。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了一下比较简单的博弈模型的常规求解方式，发现就是爆搜。顺便学了有启发式思想的 Alpha-Beta 剪枝，现在觉得是玄学……可能还是记搜比较靠谱？&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="博弈论" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="搜索/剪枝" scheme="http://www.orchidany.cf/tags/%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/"/>
    
      <category term="博弈论/对抗搜索" scheme="http://www.orchidany.cf/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2/"/>
    
      <category term="博弈论/Alpha-Beta剪枝" scheme="http://www.orchidany.cf/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA-Alpha-Beta%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】构造题选做 · 2</title>
    <link href="http://www.orchidany.cf/2019/12/24/%E6%9E%84%E9%80%A02/"/>
    <id>http://www.orchidany.cf/2019/12/24/构造2/</id>
    <published>2019-12-24T02:01:07.000Z</published>
    <updated>2019-12-27T03:45:29.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没啥特别原因，就是底下那篇文章题太多了就分流出一部分。</p><a id="more"></a><h3 id="1-UVa1697"><a href="#1-UVa1697" class="headerlink" title="$1$ UVa1697"></a>$1$ UVa1697</h3><blockquote><p>给定一排长度为 $4n$ 的格子，编号从 $-2n+1$ 到 $2n$ 每个编号为正的格子中有一个物品，其中每个编号为奇数的格子中有一个 $B$ 类物品，编号为偶数的格子中有一个 $A$ 类物品。</p><p>你只能进行一种操作：选择某两个相邻的都有物品的格子，移动到另外两个相邻的空格子中，同时不能改变两个格子的相对位置。</p><p>要求进行最少的操作使得所有物品以 <code>AAA…ABBB…B</code> ($n$ 个 $A$ 和 $n$ 个 $B$) 的形式排列在一起 输出一种可行方案 </p><p>$3\leq n \leq 100$</p></blockquote><p>人类智慧学不来了orz</p><p>考虑 $n=3,4,5,6,7$ 的时候都可以人类智慧。那么对于 $n &gt; 7$ 时考虑增量构造，即从 $n$ 构造到 $n+4$。</p><p>那么 $n=4$ 时可以这么构造：</p><blockquote><p><code>__babababa</code></p><p><code>abbabab__a</code></p><p><code>abba__bbaa</code></p><p><code>a__abbbbaa</code></p><p><code>aaaabbbb__</code></p></blockquote><p>然后考虑对于 $n+4$，记 $|BA|$  表示有一堆 <code>bababa</code> 这种东西。</p><p>那么考虑 $n+4$ 可以这么玩：</p><blockquote><p><code>__|BA|</code></p><p><code>ab|BA|b__a</code></p><p><code>abba__|BA|bbaa</code></p></blockquote><p>发现中间那一段和起始状态是一样的，就可以大力递归，回代的时候回代一下即可。</p><p>$n=3\sim 7$ 我选择直接从网上抄来别人的人类智慧，毕竟我莫得智慧.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" to "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = R - L + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">3</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(<span class="number">2</span>, <span class="number">-1</span>), oo(<span class="number">5</span>, <span class="number">2</span>), oo(<span class="number">3</span>, <span class="number">-3</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">4</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">5</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">5</span>), oo(L - <span class="number">1</span>, L + <span class="number">2</span>), oo(L + <span class="number">6</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">7</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">8</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">6</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">9</span>, L - <span class="number">2</span>), oo(L + <span class="number">6</span>, L + <span class="number">9</span>), oo(L + <span class="number">1</span>, L + <span class="number">6</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">1</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">10</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">7</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">4</span>, L + <span class="number">7</span>), oo(L + <span class="number">11</span>, L + <span class="number">4</span>),</span><br><span class="line">               oo(L + <span class="number">2</span>, L + <span class="number">11</span>), oo(L + <span class="number">8</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">8</span>), oo(L + <span class="number">12</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    oo(R - <span class="number">2</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, R - <span class="number">2</span>), work(L + <span class="number">4</span>, R - <span class="number">4</span>), oo(L - <span class="number">1</span>, R - <span class="number">5</span>), oo(R - <span class="number">1</span>, L - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) work(<span class="number">1</span>, N * <span class="number">2</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-BZOJ4148-Pillars"><a href="#2-BZOJ4148-Pillars" class="headerlink" title="$2$ BZOJ4148 Pillars"></a>$2$ BZOJ4148 Pillars</h3><blockquote><p>给定一个 $n\times m$ 的矩形，其中有 $f$ 个 $2\times 2$ 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 $6$，且每个障碍物的中心到边缘的距离至少为 $3$。</p><p>请找到一条从左下角 $(1,1)$ 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。</p><p>保证 $n,m$ 均为偶数，且 $1\leq n,m\leq 1000$ .</p></blockquote><p>就是考虑如果没有障碍的走法，由于 $n,m$ 都是偶数，所以可以从 $(1,1)$ 上到 $(1,n)$，然后从 $(1,n)$ 到 $(n,n)$ 再到 $(n,n-1)$ 再到 $(2,n-1)$ 这么蛇形走。</p><p>考虑有了障碍，因为每个障碍可以看做是独立的的，所以大概可以这么走：</p><p><img src="qwq.png" alt></p><p>其中紫色是障碍，黄色是原来的路线，红色是新的。由于 $6$ 的限制，所以可以这么绕。</p><p>所以是道细节题233</p><p>代码先鸽着，什么时候有心情再写。s</p><h3 id="3-【UR-6】-智商锁"><a href="#3-【UR-6】-智商锁" class="headerlink" title="$3$ 【UR #6】 智商锁"></a>$3$ 【UR #6】 智商锁</h3><blockquote><p>构造一个节点数不超过 $100$ 的无向图，使其生成树个数对 $998244353$ 取模的结果为 $k$ 。</p><p>$k\leq 10^9$</p></blockquote><p>看题，仔细一想，莫非是什么神秘的 $\boldsymbol{EGF}$ 大力乱搞（警觉）。</p><p>结果人傻了……以下是官方做法：</p><p>考虑如果两个图只有一个公共点，那么生成树个数为两个图相乘。那么随机 $1000$ 个随机无向图，两两拼凑出 $10^6$ 个无向图，然后对每一个在 <code>map</code> 里找 $k$ 的逆元即可。<del>如果没有就再随机一遍。</del></p><p>发现这样实际上几乎不可能没有解。。。</p><p><img src="http://img.uoj.ac/utility/bear-thinking.gif" alt="思考熊"></p><p>降智打击.jpg</p><h3 id="4-【UNR-1】Jakarta-Skyscrapers"><a href="#4-【UNR-1】Jakarta-Skyscrapers" class="headerlink" title="$4$  【UNR #1】Jakarta Skyscrapers"></a>$4$  【UNR #1】Jakarta Skyscrapers</h3><blockquote><p>有一个数集，最初其中只有 $a$ 和 $b$。</p><p>你可以进行最多 $400$ 次操作，每次选择集合中满足 $i&gt;j$ 的 $i$ 和 $j$，把 $i-j$ 加入集合中，使得最后 $c$ 在这个集合中。</p><p>$a,b,c\leq 10^{18}$</p></blockquote><p>考虑构造中间状态。发现可以用 $a-(a-b-c)$ 构造 $b+c$， 可以用 $a-(a-b-b)$ 构造倍增，于是考虑先辗转相除得到 $1$，然后倍增，然后就没了。注意，如果一开始 $(a,b) \not|~c$ 的话是无解的。那么考虑同除<br>$(a,b)$ 就可以快乐地更相减损得到 $1$ 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没啥特别原因，就是底下那篇文章题太多了就分流出一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="构造" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】构造题选做 · 1</title>
    <link href="http://www.orchidany.cf/2019/12/24/%E6%9E%84%E9%80%A01/"/>
    <id>http://www.orchidany.cf/2019/12/24/构造1/</id>
    <published>2019-12-24T02:01:07.000Z</published>
    <updated>2019-12-27T03:46:00.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从网课和 <code>uoj</code> 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。</p><a id="more"></a><h3 id="1-神秘的题目"><a href="#1-神秘的题目" class="headerlink" title="1 神秘的题目"></a>1 神秘的题目</h3><p>设 $f_A$ 表示 $A$ 的本质不同子串个数<br>给出 $x, y$，要求构造出两个字符串 $A, B$<br>满足：<br>$f_A = x , f_B = y , f_{A+B} = x + y$</p><p>$x, y ≤ 5000$</p><hr><p>考虑 $x$ 个 $a$，$y$ 个 $a$ ，然后拼起来就好……</p><h3 id="2-CF743C"><a href="#2-CF743C" class="headerlink" title="2 CF743C"></a>2 CF743C</h3><p>给出 n，构造出 x, y, z，满足：</p><p>$$<br>\frac{2}{n} = \frac{1}{x}+\frac{1}{y}+\frac{1}{z}\<br>x\not= y, x\not= z, y\not= z<br>$$<br>无解输出 −1<br>$n ≤ 10^4$</p><hr><p>考虑通分（分时裂项），即<br>$$<br>\frac{1}{n}-\frac{1}{n+1}=\frac{1}{n(n+1)}\<br>\frac{1}{n}=\frac{1}{n+1}+ \frac{1}{n(n+1)}\<br>\frac{2}{n}=\frac{1}{n} + \frac{1}{n+1}+ \frac{1}{n(n+1)}<br>$$<br>然后就做完了。</p><p>注意1要特判。</p><h3 id="3-CF359B"><a href="#3-CF359B" class="headerlink" title="3 CF359B"></a>3 CF359B</h3><p>给出 $n, k , 2k ≤ n$，构造出 $2n$ 的一个排列，满足：</p><p>$$<br>∑^n_{i=1} |a_{2i−1} − a_{2i}| − |∑^n_{i=1}(a_{2i−1} − a_{2i})| = 2k<br>$$</p><p>$n ≤ 50000$</p><hr><p>寄几想了一种构造，就是$a_{i+1} = a_i+k,<del>i=2p,</del>p \in \mathbb{N+}$，然后随便两次交换两项就好了。然而并不对，因为这样构造出的结果并不合法；于是遂决定改成$a_{i+1} = a_i+2k,<del>i=2p,</del>p \in \mathbb{N+}$，但也不对，单次交换的步长太长了，是$4k$。于是我又想能否有什么诡异的交换方法可以补救回来$2k$……失败了qaq</p><p>然而其实很简单，我们只要把步长控制为$1$就一定能凑出来。所以一开始先令$a_i=a_{i+1}+1$这种感觉，然后交换$k$次即可。</p><h3 id="color-violet-4-rm-CF-it-512E"><a href="#color-violet-4-rm-CF-it-512E" class="headerlink" title="$\color{violet}{4~ \rm{CF}\it{512E}}$"></a>$\color{violet}{4~ \rm{CF}\it{512E}}$</h3><p>对于一个正 n 边形，可以用 n − 3 条边分成 n − 2 个三角形<br>给出两种划分，你需要进行若干次操作把第一种划分变成第二种划分<br>每次操作选择一个四边形删去它的对角线，连另外一条对角线<br>n ≤ 1000，操作次数不超过 20000</p><hr><p> 开始掉线……</p><p>其实主要思想就是<del>酱油瓶</del>状态替换，把起始状态 $s$ 变成对角线都从 $1$ 出发的状态 $p$，再从 $p$ 出发变成终态 $t$。</p><p>具体操作好像是</p><p>别想了，掉线了怎么可能还会有？</p><h3 id="5-神秘的题目"><a href="#5-神秘的题目" class="headerlink" title="$5$ 神秘的题目"></a>$5$ 神秘的题目</h3><blockquote><p>给出一棵树，定义一个点的邻居集合为到它距离 $\leq 2$ 的所有点。</p><p>给出所有点的邻居集合，还原原树。</p><p>$n\leq 1,000$</p></blockquote><p>考虑一个结论，如果两个点的邻居集合交集大小为 $2$， 那么交集中的点一定有连边。（$\rm bitset$ 做到 $\frac{n^3}{w}$）</p><p>于是就可以先把 <strong>非叶子节点</strong> 两两之间的连边求出来</p><p>然后考虑如何求出叶子。发现叶子有个性质，就是叶子到某些非叶节点的距离一定 $=$ 与之相邻的非叶节点到某些非叶节点的距离 $+1$。所以就可以再把离每个非叶节点距离为 $1$ 的非叶节点求出来，称这个点集为<strong>旁边集合</strong>。那么如果叶子 $u$ 的邻居集合与非叶节点 $v$ 的旁边集合相同，那么 $u$ 就一定挂在 $v$ 上。</p><h3 id="6-AT3877"><a href="#6-AT3877" class="headerlink" title="$6$ AT3877"></a>$6$ AT3877</h3><blockquote><p>给定 $\rm X,Y$， 给出 $[d_{i,j}]$ 表示当 $\mathrm X=i,\mathrm Y=j$ 时，$\rm S$ 到 $\rm T$ 的最短路。</p><p>构造这张图，使之点数 $&lt;300$，无自环和重边，每条边的权值 $\leq 100$， 权值可以是数也可以是 $\rm X,Y$，并给出 $\rm S,T$ 。</p></blockquote><p>设 $g_{i,j}$ 表示从 $\rm S$ 到 $\rm T$ ，经过了包含 $i$ 条 $\rm X$ 边， $j$ 条 $\rm Y$ 边的路径，其它边的边权最小和。</p><p>那么发现这东西可以这么转移出 $[d_{i,j}]$来<br>$$<br>d_{i,j}= \min_{p,q}{(p\cdot i+q\cdot j + g_{p,q})}<br>$$<br>然后可以得到松弛条件<br>$$<br>\forall p,q, \quad \exists~ d_{i,j}\leq p\cdot i+q\cdot j+g_{p,q}<br>$$<br>移项可以得到<br>$$<br>g_{p,q}=\max_{i,j}{(d_{i,j}-p\cdot i - q\cdot j)}<br>$$<br>于是考虑求出 $g $ ，之后反推出 $[d_{i,j}]’$ 观察是否吻合。吻合则考虑根据经过的 $\rm X,Y$ 连边即可。</p><h3 id="7-ARC-095F"><a href="#7-ARC-095F" class="headerlink" title="$7$ ARC 095F"></a>$7$ ARC 095F</h3><blockquote><p>给定一棵树 $\rm T$, 要求构造一个排列 $p$ .</p><p>对于每一个 $p_i$ ，找到最大的 $j$ 使得 $p_j&lt;p_i$，然后在 $i,j$ 间连边。</p><p>问是否可以构造出与 $\rm T$ 同构的树。</p><p>如果可以，则给出字典序最小的排列。</p><p>$n\leq 100,000$</p></blockquote><p>反向考虑，观察对于一个排列生成的树。按照排列的权值升序操作，维护最靠右的位置 $mxp$ 即可。</p><p>然后发现由于一个排列不可能同时有两个最大值，这样生成的树一定会是一根长链周围分散着单点。</p><p>于是考虑把直径抽出来，对上面的点扫一遍。遇到有挂在上面的肯定考虑从小到大放在前面，然后就没有然后了。</p><p>可能实现还不太会，要再想想。</p><h3 id="8-小题整理"><a href="#8-小题整理" class="headerlink" title="$8$ 小题整理"></a>$8$ 小题整理</h3><p>8.1 覆盖</p><blockquote><p>平面上给定 $n$ 个点，每个点可以覆盖 $\frac{1}{4}$ 的平面，求最少需要多少个点才能覆盖所有点</p></blockquote><hr><p>orz我和ouuuyuuu一开始觉得题很傻，最多四个，结果发现原来最多两个就可以，然后发现我们很傻。。</p><p>找某一维坐标最大/最小的两个点，再判一下是不是只需要一个点就可以满足，就做完了。</p><p>8.2 CF477B</p><blockquote><p>有 $n$ 个集合，彼此交集为空。</p><p>每个集合有 $4$ 个元素，两两之间均有 $\gcd = k$</p><p>求 $4n$ 个数中最大值的最小值</p><p>$1\leq n\leq 10000$</p></blockquote><p>发现可以同除以 $k$ ，于是就变成两两互质了，于是 $4$ 个数中至多 $1$ 个偶数。</p><p>同时发现一个<del>鬼能发现的</del>性质，就是相邻两个奇数一定互质，那么就构造<br>$$<br>\mathrm{S}:{6i-1,6i-3,6i-5,6i-4 }<br>$$<br>可知它们互质。然后就没了。</p><h3 id="9-CF-527D"><a href="#9-CF-527D" class="headerlink" title="$9$ CF 527D"></a>$9$ CF 527D</h3><blockquote><p>每个元素有一个 $a_i$ 一个 $b_i$ .</p><p>求一个最大的点集使得 $\forall p,q\in \mathrm{S},\quad |a_p-a_q|\geq b_p+b_q$</p><p>$n\leq 200,000$</p></blockquote><p>我丢，其实就是把每个元素看做 $(a_i-b_i,a_i+b_i)$ 这么一段区间，然后求的就是最长不相交的区间个数。</p><p>然后就没了……就没了……</p><h3 id="10-ARC-084D"><a href="#10-ARC-084D" class="headerlink" title="$10$ ARC 084D"></a>$10$ ARC 084D</h3><blockquote><p>求出 $K$ 的倍数中，各位数字的和最小的那个数字的数字和。</p><p>$K \leq 100,000$</p></blockquote><p>考虑从 $i$ 到 $i+1$ 连一条长度为 $1$ 的边，$i$ 到 $10\cdot i$ 连长度为 $0$ 的边。然后按照$\bmod k$ 的余数建边，最后就是  $1\to 0$ 的最短路。</p><h3 id="11-神秘的题目"><a href="#11-神秘的题目" class="headerlink" title="$11$ 神秘的题目"></a>$11$ 神秘的题目</h3><blockquote><p>给出一张 $n \cdot m$ 的网格图，曼哈顿距离为 $2$ 或 $3$ 的点之间连一条边，构造出一条哈密尔顿回路。</p><p>可能无解。哈密尔顿回路：经过每个点恰一次。</p></blockquote><p>发现可以走法可以是棋盘染色，即黑白相间染色，先走完黑色再走完白色。</p><p>发现只有 $n=2,m=2$ 时无解。当 $\min(n,m)=1$ 时，考虑 $(1,2),(1,3),(2,4),(2,5)$ 都必须连（保证有回路），剩下的瞎构造即可。</p><h3 id="12-CF-468A"><a href="#12-CF-468A" class="headerlink" title="$12$ CF 468A"></a>$12$ CF 468A</h3><blockquote><p>用 $1\sim n$ 的所有数凑出 $24$，输出方案。</p><p>每个数都要用，只能用 <code>+</code>、<code>-</code>、<code>×</code> 三种运算。 $n\leq 100,000$</p></blockquote><p>发现 $n\leq 3$ 显然不行。</p><p>然后 $n=4$ 的时候阶乘即可，$n=5$ 的时候发现可以 $5\times 3+4\times 2+1$ 这么算。</p><p>然后考虑 $n&gt;5$，那么 $n$ 一定可以由 $n-2$ 推过来，因为只要乘上 $n-(n-1)$ 即可。发现这样总是可以构造出来合法解。</p><h3 id="13-Loj-525"><a href="#13-Loj-525" class="headerlink" title="$13$ Loj #525"></a>$13$ Loj #525</h3><blockquote><p>给定一个正整数 $k$，你需要寻找一个系数均为 $0$ 到 $k−1$ 之间的非零多项式 $f(x)$，满足对于任意整数 $x$ 均有 $f(x)≡0~(\bmod k)$</p><p>要求 $\deg(f)\leq 60000$</p><p>$k\leq 30000$<br>首先发现只要对 $0\sim k-1$ 成立那么就满足条件。 <del>然后就变成傻题了，分治FFT！分治FFT！</del></p></blockquote><p>然而分治FFT会T。不妨令 $q\geq \varphi(k)$，则由于扩展欧拉定理有：<br>$$<br>x^q\equiv x^{q\bmod \varphi(k)+\varphi(k)}(\mod k)<br>$$<br>那么如果令 $v=q+\varphi(k)$，就会有</p><p>$$<br>\begin{aligned}<br>x^v &amp; \equiv x^{v\bmod \varphi(k)+\varphi(k)} (\bmod k) \\ &amp;\equiv x^{(q\bmod \varphi(k)+\varphi(k) \bmod \varphi(k))\bmod \varphi(k) +\varphi(k)} (\bmod k)\\ &amp; \equiv x^{q\bmod \varphi(k)+\varphi(k)}(\bmod k)\\ &amp; \equiv x^q(\bmod k)<br>\end{aligned}<br>$$<br>然后就构造第 $\varphi(k)$ 项系数为 $k-1$，第 $2\cdot \varphi(k)$ 项系数为 $1$ 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从网课和 &lt;code&gt;uoj&lt;/code&gt; 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="构造" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="奇怪的技巧" scheme="http://www.orchidany.cf/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【练习记录】之前的杂题整理（To Be Continued....）</title>
    <link href="http://www.orchidany.cf/2019/12/22/%E6%9D%82%E9%A2%98%E6%B3%9B%E5%81%9A%C2%B7%E4%B9%8B%E5%89%8D/"/>
    <id>http://www.orchidany.cf/2019/12/22/杂题泛做·之前/</id>
    <published>2019-12-22T13:14:22.000Z</published>
    <updated>2019-12-23T23:30:52.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是 <code>CSP-S 2019</code> 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……</p><a id="more"></a><hr><p>1、<a href="https://www.luogu.com.cn/problem/P1357" target="_blank" rel="noopener">LG5317 花园</a></p><p>发现一共只有两种方格，并且转移只跟 $\rm M$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p><p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，然后就快速幂。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波。</p><p>2、<a href="https://www.luogu.com.cn/problem/P4318#submit" target="_blank" rel="noopener">LG4218 完全平方数</a></p><p>一道傻题，大概就是考察 $\mu$ 的性质。</p><ul><li><p>$\rm Algorithm~1$</p><ul><li>发现可以容斥，且 $\mu$ 函数的性质在于，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子且 $x$ 的不同素因子个数为 $k$。所以就考虑先二分，二分完了求一下 </li><li>$$<br>\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \frac{n}{i^2}\rfloor<br>$$<ul><li>就变成傻题了。复杂度 $T \cdot \sqrt n \log n$</li></ul></li></ul></li></ul><p>顺便记录一个很绝的 <code>idea</code></p><ul><li><p>$\rm Algorithm~2$</p><ul><li><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p><ul><li><p>$$<br>\sum _{i=1}^{x}\mu^2(x)\leq K<br>$$</p><p>然后我们发现这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p></li></ul></li></ul></li></ul><p><del>但显然杜教筛被暴力给爆锤了好吗</del></p><p>3、[]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是 &lt;code&gt;CSP-S 2019&lt;/code&gt; 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="技巧/状态压缩" scheme="http://www.orchidany.cf/tags/%E6%8A%80%E5%B7%A7-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="容斥/暴力容斥" scheme="http://www.orchidany.cf/tags/%E5%AE%B9%E6%96%A5-%E6%9A%B4%E5%8A%9B%E5%AE%B9%E6%96%A5/"/>
    
      <category term="数学/线性代数/矩阵" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>【游记】CSP-S2019游记</title>
    <link href="http://www.orchidany.cf/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/"/>
    <id>http://www.orchidany.cf/2019/12/20/CSP-S2019游记/</id>
    <published>2019-12-19T19:38:34.000Z</published>
    <updated>2019-12-27T02:33:04.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想不到吧，还有这个时候写游记的。</p><p>在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233</p><p>这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。</p><a id="more"></a><h1 id="rm-Day-quad"><a href="#rm-Day-quad" class="headerlink" title="$\rm Day\quad -???$"></a>$\rm Day\quad -???$</h1><p>LCEZ机房终于只剩8个人了。</p><p>分别是经常会灵光一现的wxl，稳得一批的yjk，经常被膜被AKIOI的wx，玩梗宅男ljp，爱占便宜的lwy，智商不低的qcr，首席颓蛋/电视导购lzr和我。</p><p>其实初三刚来实验班一开始是12个人，但是后来1个人去了友校，1个人选择在 <code>NOIP2018</code> 之前去学文化课，我们把她在团队里的名字改成了“等你回来”，但是最后也没等到；剩下两个人选择考完NOIP2018就退出，现在其中一个因为选了一科地理去了平行班，另一个选择留在文化课班专攻文化课。当然，那就是另一个故事了。</p><p>NOIP2018，我们之中有人考得很好，有人铩羽而归，而我属于后者。所以大家都在积极准备着，选择在国庆之后就停课。</p><p>国庆的时候，我和lzr，wx和qcr去了青岛参加正睿，自认为是停课效果排名比较靠前的一次外出培训了。我只记得前几天每天闲的时候会选择去打 _This is the police 2_，并且在走的前一天成功丢了身份证awa，lzr 则在狂颓上古卷轴Online，wx和qcr在另一个屋，所以我并不清楚。无论怎样，青岛的培训也是很值得回忆的吧。我到现在也可以回想起夜里无人的大街、昏黄的房间只有一件台灯、抑郁的我、经常去买的大桶雪碧和辣条<del>和我丢了的身份证</del>。</p><p>无论怎样，青岛的外卖没有济南的好吃，嘿嘿。</p><h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad -??$"></a>$\rm Day\quad -??$</h1><p>我选择把每天上午安排给ZR的模拟赛，一般名次都不会很高，唉菜死了。</p><p>剩下人可能在做题，可能在颓。印象最深刻的就是我每五次去找yjk玩，有三次他都在刷知乎。。。</p><p>发现自己无论什么大型比赛之前都会发现自己原来有整理不完的博客，平时习惯太差带来的后果真可怕e</p><p>不过似乎是有我引起的一阵风，机房里大家都开始晚上喝_香飘飘_，甚至连铁公鸡yjk也拔毛了买过几次奶茶，于是走廊上就一股浓郁的奶茶味233</p><p>之前嘛，就做了做<code>dp</code>，学了学<code>odt</code>，第一次写莫队结果被逼着调了半天最后套了个线段树。剩下的或许就没有什么印象深刻的事情了。</p><p>哦，胜利一中的神仙们一直很在状态。我就很奇怪为什么会有人每天坚持打比赛还能坚持整完所有题目的……期间我整天听歌，还抽了一个晚上看了集《奇葩说》，感觉李诞认真起来实力也不弱蛤。</p><p>要来了吗？要来了吧。</p><h1 id="rm-Day-quad-3"><a href="#rm-Day-quad-3" class="headerlink" title="$\rm Day\quad-3$"></a>$\rm Day\quad-3$</h1><p>给最喜欢的语文老师写了封信，跟她说我觉得我可能在考完之后不会继续走下去了，这让我很难过，因为我割舍不下那些回忆，觉得她可能会理解我。她回信了。我很高兴她没有硬塞什么心灵鸡汤。于是每天晚上我都会拿出信来读一遍。</p><p>哦对，她以前是我的语文老师，文化课/奥赛分班之后她就只教隔壁了。</p><p>其实你说现在我有什么感受呢？我也不知道，就是蔡琴唱过的 <em>让它好好的来，让它好好的去</em> 这种感觉吧。</p><h1 id="rm-Day-quad-0"><a href="#rm-Day-quad-0" class="headerlink" title="$\rm Day\quad 0$"></a>$\rm Day\quad 0$</h1><p>报到日，群体乘大巴。大巴上我教yjk打音游和拳皇，打deemo他菜的一批233</p><p>到了考点，日照什么职业技术大学。校园一般，宿舍还行，起码有插头和桌子。</p><p>去试了试饭菜，感觉还可以，挺丰富的。发现是兑换餐币，于是就换了三种面值的留下作纪念了。</p><p>晚上去试机，豪华六边形方桌，和机房里一样，感到很开心。键盘也很轻。听别人说键盘难用、座位之间间距太小，才知道原来不是每个考场都是豪华六边形方桌。有抽中大奖的喜悦233</p><p>试机回来就是瞎写了写板子，写了写博客。睡前听的是德彪西的《月光》。</p><p>考前和yjk估摸了一下，Day1要拿260左右才能稳，不知道明天会怎样。</p><p>哦，对，当时听的那一版《月光》，是我听完好多版之后最喜欢的一个版本。但之后我尝试找过，但无论怎么找都找不到了…</p><h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad 1$"></a>$\rm Day\quad 1$</h1><p>考啦考啦。</p><p>开题发现有一些奇怪的说明，没管。</p><p>开 $\rm T1$，发现是个sb题，写了$\rm [5,10]min$ 左右切了，开考 $15\min$ 的时候拍上了。</p><p>开 $\rm T2$，发现 $50$ 在送，于是先写了 $50$ 。之后寻思着去做做 $\rm T3$，发现不太会。本着求稳，写了 $10pts$ 就回去写 $\rm T2$了。于是就开始演，演了半小时写出了一堆不知道啥东西，然后又演了半小时发现大样例爆栈了……</p><p>我不会告诉你我接下来浪费了快半小时去回忆<code>Dev</code>怎么开栈…… </p><p>最后还是失败了，但是发现其实大样例不需要 <code>dfs</code> ，于是写了个序列版本给演过去了。之后 $\rm T2$ 就拍上了。此时大概是 $10:15$ 。</p><p>觉得去刚 $\rm T3$ 应该不至于一分没有，结果就真的一分没有，伤心。</p><p>之后就自闭了。出了考场，我戴紧冲锋衣帽子冲到了一个僻静的小路里面，周围都是密密麻麻的树，开始思考人生。在家庭群里用微信发了句 “考挂了，没救了”，跟妹子说了声“要退役了”就找了个角落开始思考人生。思考完之后开始在校园里闲逛，不想回宿舍。我觉得一定会有 sb 学弟或者 sb 同级生在对 tnd 答案，结果最后手机没电了不得不回去。</p><p>回去之后要了份脆皮鸡饭叫上 yjk 出去逛，发现原来大家都是 210 左右，心态得到了放松。结果不知道为啥，后半程跟 yjk 越走越自闭。我们俩大概是这么聊天的：</p><blockquote><p>我：你最后考到多少名还学？</p><p>yjk：20~30吧。</p><p>我：嗯我也是。那 70 以后呢（因为他去年这个名次）？</p><p>yjk：不学了吧。。</p><p>我：嗯我也是。</p><p>yjk：今天的题感觉没有区分度啊</p><p>我：是啊，没有区分度啊。回去还要补文化课。大家今天都 210，全天下都 210，明天还会更难，肯定会加大区分度，那我可能就被区分下去了…（开始碎碎念）</p><p>yjk：是啊……</p></blockquote><p>于是我俩就在四季桥那里自闭了，和俩二傻子一样蹲在桥边，如果忽略肤色，宛如两尊佛。</p><p>不过后来走着走着心态又回来了。回到宿舍后被辅导员骂了一顿，因为手机落在宿舍并且没签到，233.</p><p>之后选择去吃晚饭，碰到了胜利一中的神仙，但是显然他们不可能认识我，所以我就像一个狗仔一样单方面盯着他们看……233</p><p>晚饭挺不错！这是真的！之后去买了红牛，希望明天能用上。</p><p>晚上其实一直在颓火影和拳皇……睡之前写了写博客，<code>hexo -d</code> 之后就睡了。</p><p>还是听的《月光》。</p><h1 id="rm-Day-quad-2"><a href="#rm-Day-quad-2" class="headerlink" title="$\rm Day\quad 2$"></a>$\rm Day\quad 2$</h1><p>……自闭了。</p><p>开场看T1，发现是计数，不会。去搞 T2，觉得很可做，发现40在送；写完去看T3，发现40在送。于是决定写 T2。然后 T2 猜了一波单调性发现可以 64，于是数据分治了一下，拍上了；之后去写了个T3的40。T2推了推，觉得似乎可以斜率优化，但是发现有二次项似乎很难办，就没管。剩下的时间就在做T1……</p><p>最大的失误是啥呢？可能就是我T1<strong>把 n 和 m 看反了，并且过了前两个样例</strong>，于是觉得这题64在送。但是死活过不去第三个样例。好久之后才发现看反了，赶紧写了个玄学dfs。赛后一测re了。真开心。T3当时看的时候觉得75都是送，但是最后也没来得及写……于是第二天就这么凉了。</p><p>一出来，就自闭了。闲逛了好久，用QQ跟妹子说“真退役了”，用微信跟家长说“已经准备迎接新生活了”，后来就没有后来了。回去一问发现大家也都挂了……yjk哭了，我头一次见他哭。</p><p>不用想的，Day2就是考区分度。之前zr做题的时候就明白了，我是那种被区分下去的人。容斥、dp、贪心之类的这些基本功，我都很烂很不扎实，被区分下去是我活该。你说我会为自己以前拼命学多项式感到不值吗？可能确实不值，但是说啥都没用了。</p><p>回去的路上还是比较愉快的。车上的电视终于不放上21世纪初的悲情无脑乡村恋爱歌曲，改放《欢乐喜剧人》，于是最终和yjk看了一路233</p><p>rqy哭了，可能是因为觉得我们都退役了吧。但是我感觉我和他已经不是一个世界的人了。我一直感觉，如果让我从实力和陪伴里面选一个，我肯定毫不迟疑地选择前者。但，结束了。</p><p>晚上回家了，就是在一直颓而已，没啥别的，期间励志要开启新生活，觉得很有斗志。</p><h1 id="rm-Day-7"><a href="#rm-Day-7" class="headerlink" title="$\rm Day ~7$"></a>$\rm Day ~7$</h1><p>在校的周六，选择去机房收拾东西，顺便看了眼民间数据成绩单。发现自己和yjk都是省里50多名，还一个分…这就很难了，我们之前没讨论过这个区间该干啥呀？</p><h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>之后？之后就是我又滚回来追梦，yjk去文化课了，剩下的人都退役了。</p><p>LCEZ55 级的机房故事，也就这么结束了吧？我一直觉得，我们机房没有其它机房可爱，我是罪魁祸首。我身为队长，要张罗日常事务，但是从来没真正关心过谁，加上脾气很差容易着急（虽然现在好很多了？）。并且一开始我很菜，要一直不遗余力的提升自己实力，不顾什么”同学友谊“啊啥的，功利且浮躁。大家平时也不怎么敢跟我交流，于是机房就很冷清。</p><p>但机房里也时常会有笑声，比如联赛前，机房里一直其乐融融的。现在看来那似乎是遥远的回忆了。</p><p>现在机房里只有我一个人了，我开心吗？终于等到了我喜欢的悠远的寂静，我更快乐吗？</p><p>向前走吧。</p><p>我还很菜，啥都不会，迷茫且不知所措。</p><p>但是人生也就应该是这样的吧。</p><p>明天你好。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家一起加油吧！为了梦想和明天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想不到吧，还有这个时候写游记的。&lt;/p&gt;
&lt;p&gt;在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233&lt;/p&gt;
&lt;p&gt;这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.orchidany.cf/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】闲谈</title>
    <link href="http://www.orchidany.cf/2019/12/15/%E9%97%B2%E6%89%AF/"/>
    <id>http://www.orchidany.cf/2019/12/15/闲扯/</id>
    <published>2019-12-15T07:29:19.000Z</published>
    <updated>2020-01-01T23:46:08.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>别名：一句话日记</del></p><p>可能就是用来随时记录自己感悟的东西？</p><a id="more"></a><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>颓了一天，下午就返校了。上午主要是看了看B站跨年的回放。⑧说了，邓紫棋天下第一（</p><p>晚上突然很难受。还是关于妹子的事，可能我真的需要一段时间才能缓过来吧？感觉自己的祝福，每一句话、每一个字都在痛击自己的心。但是我能怎么样呢？我又能怎么样呢？</p><p>又是CSP考完那种无力感：就这样了吗？就这样了吧。</p><p>一个人的奥赛室，孤独到让我想哭。是啊，以后就再也不能去找妹子说最近自己心态崩了求安慰之类的话了，也必须要描黑那道若有若无的界限了，感觉生活少了点什么。</p><p>但总之，是一个新的开始不是吗？</p><p>明天可还要继续啊。s</p><p>喂喂，pks，我们可是舞台上的战士啊，怎么能这么早就谢幕呢？</p><blockquote><p>《你的答案》<em>by 阿冗</em></p><p>也许世界就这样<br>我也还在路上<br>没有人能诉说<br>也许我只能沉默<br>眼泪湿润眼眶<br>可又不甘懦弱<br>低着头 期待白昼<br>接受所有的嘲讽<br>向着风 拥抱彩虹<br>勇敢的向前走<br>黎明的那道光<br>会越过黑暗<br>打破一切恐惧我能<br>找到答案<br>哪怕要逆着光<br>就驱散黑暗<br>丢弃所有的负担<br>不再孤单<br>不再孤单<br>不再孤单</p></blockquote><h3 id="Goodbye-2019"><a href="#Goodbye-2019" class="headerlink" title="Goodbye 2019"></a>Goodbye 2019</h3><blockquote><p>又是一年啊。 </p><p>这一年里，我失去了很多，也获得了不少；看清了很多，也迷茫了不少。每一次相遇，每一次离别都值得回忆；每一份高兴，每一分忧伤也都值得我带到未来。</p><p>对于2019，「让它好好地来，让它好好地去」，我更喜欢这么来形容。</p><p>明年有什么心愿呢？生而为人，握紧很简单，但是放下却很难。然而握得越紧越发现原来没有握住，看得越重越发现自己扑了个空。所以，我希望，我可以一觉醒来发现自己什么都不记得，这样才可以放下之前的所有，大踏步得走向明天。2020，请让我变得更释然一些吧，好吗？ </p><p>总之呢，谢谢各位一年的陪伴。</p><p>2020，这个世界，与我重新来过吧。</p></blockquote><h3 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h3><p>今天早上很高兴地在早读给妹子写完新年快乐的明信片+信，让隔壁班同学当信使给送去。听他说了下最近隔壁班的八卦，发现以前觉得会厮守很久的情侣不在了，以前觉得根本不搭的两个人在一起了。感觉和他们同班的日子已经远去很久了。</p><p>顺便知道了原来喜欢的妹子已经有了男票，于是打算把写好的东西扔进垃圾桶。在信使老鸽的劝说下还是没扔，还是送了出去。最后感觉有点惆怅。从初中到现在，自己似乎一直在趟别人的浑水，感觉自己似乎跟他们早就不是一个世界的人了。</p><p>是啊，不是一个世界的人了。可能我真的需要破除『我执』了吧，不想再去纠结这些没头没脑的固执了。于是趁着夜幕还没被拽走，便匆匆来到了奥赛室。</p><hr><p>冷静思考了思考，发现自己一旦对什么东西有了厌恶感就很难再喜欢上了。所以真正对的那个人应该还没来吧，我需要继续等下去。嗯，从小父母就教导，走丢的时候原地等着是最好的选择。所以也只有等待，才是迎接光明的最好办法吧。</p><hr><p>然后晚上她用她闺蜜的 qq 给我发信息。不知道为啥。她说她本来以为我今天下午会在班里看电影（因为我们班奥赛退役选手在其它班联欢的时候，在班里看电影），然而实际上我在奥赛室看了一下午的《进击的巨人》（233。所以她就给我拍过来一张照片：</p><p><img src="hello.jpg" alt></p><p>。。。那个“弄得我很怂”的上文是我问她说每次跟她偶然遇见她为啥都故意不看我233</p><p>然后事情是这么发展的：</p><blockquote><p>她：还有一件信息量比较大的事情</p><p>她：我脱单了</p></blockquote><p>啊。</p><p>下午时一直在想，如果她其实和那个男生还没真正确定的话，我去“兴师问罪”是不是有点不太好？</p><p>好在事态的发展没让我那么尴尬……</p><p>我当时似乎，似乎是，思考了一瞬间，就已经知道该怎么回她了。那些“为什么你有了男朋友而不告诉我？”和“有了男朋友为什么还要给别人以希望”之类的话，已经被扔到了不知处。</p><p><img src="1.png" alt></p><blockquote><p>题外话：</p><p>……可能大家都不知道我们到底是什么关系，大概就是她知道我一直喜欢她但是我是这么一种心态：</p><blockquote><p>喜欢不等于占有</p></blockquote><p>于是和她就变成了好朋友？起码在聊天软件里还是很铁的（</p><p>至于她是什么人，我只能说是很单纯一妹子……就是跟比人qq聊天还用<code>。。。。</code>这东西做前后缀的人，现如今几乎没有了吧？</p></blockquote><p>嗯，就这样了吗？就这样了吧。</p><p>晚上看了看C菌的《心魔》，玩到最后虽然很爽，但是感觉和《逃生二》一样，爽是爽了，但是没啥深度。</p><p>睡了睡了。</p><h3 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h3><p>昨晚不知道为啥宿舍里有一堆蚊子…让人很难过地一点多才睡，于是今天就变成了活死人状态。上午看了看高数，发现到一阶微分方程那里公式已经不是人记的了，于是觉得无聊就不学了。下午和晚上做了做 <code>vfk</code> 曾经出的某场 <code>cf</code>，剩下的时间学了发笛卡尔树就去颓了。</p><p>前几天看了梁文道的《我执》，几天晚上方才明白<code>我执</code>的意思，突然很有感触。以下是摘录，转自<a href="https://www.zhihu.com/question/20015896/answer/15644432" target="_blank" rel="noopener">链接</a>，有删改：</p><blockquote><p>你的名字不是你，你的职业不是你，在哪里上班的那个也不是你，这一切是你的经验，但经验不是你本身。我们经由我们生命的内容来定义自己，我们的年龄、健康、人际关系、财务状况、工作和生活情境以及心理情绪状态等等，但是这些是经验的客体，而不是主体。我们的错误就是会把这些经验当成是我们的主体，然后与它们认同，把它们当成自我的一部分。</p><p>一言以蔽之：我执就是在外在事物上所建立的那个虚假的自我感（ 这里的外在事物还包括你的情绪和念头，下面会细谈)。无论你执着什么，你就是在把它当成自我的一部分，而那个东西就是你「我执」的体现。在根本上，并无一个实体的，不变的「我」存在。也正是因为我们把自我感建立在这些外在的事物上，所以当它们变化时，我们的痛苦便产生了。但是这些事物的变化是不可避免的，因为它们的本质便是「无常」。所以，只要你把自我感建立在外在稍纵即逝的事物上，则我们心理上的痛苦就不可避免。</p><p>我们的悲哀是，我们终其一生，都只是在为自我填充这一个个意象。财富，权位，知识，还有你执着的任何东西，如果它没有伤害到他人，我想这些都是好东西，但是只要你没有认清这些东西和你的本质是完全无关的，只要你还在这些事物上建立认同感，那你所得到的一切不过是加强我执而已，而当那个意象破灭，则痛苦就将来临。</p></blockquote><p>于是感觉似乎佛教不是印象里那种玄学的宗教，而是一套科学化理论化的世界观和方法论。</p><p>我什么时候才能「看惯风波里，闲步红尘外」呢？</p><h3 id="12-29"><a href="#12-29" class="headerlink" title="12.29"></a>12.29</h3><p>上午考的数学和英语，下午考的语文，成功要到了记忆中上一次合格考跟我一个考场、这次也一个考场的可爱妹子的QQ。感觉到达了人生巅峰。</p><p>然后晚上回来学了学支配树，发现有神仙说灭绝树就是支配树，然后发现自己还不会灭绝树，然后就去做灭绝树了233</p><p>啊，终于马上要放假了，开森。</p><h3 id="12-28"><a href="#12-28" class="headerlink" title="12.28"></a>12.28</h3><p>上午在奥赛室背政治……下午考了政治觉得自己还可以。</p><p>晚上尝试写了一下「一双木棋」，发现 <code>alpha-beta</code> 只能干出 $70pts$ 来，然后就去颓了。</p><h3 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h3><p>没啥好讲的，明天要合格考了，在发愁自己的政治233</p><h3 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h3><p>上午下午一共做了三道题，从李煜东的蓝书上看来的。中途写挂了好几次，但是最终调出来还是挺有成就感的。</p><p>饭卡丢了，有点郁闷。毕竟电话卡和饭卡是一张卡，电话卡丢了还要去电信营业厅补办。。。太麻烦了吧233</p><p>……然后……然后就因为一些奇怪的事情陷入了奇怪的思考。感觉自己正在被拽进奇怪的漩涡中，感觉自己似乎如同「奇异人生」里面 <code>Max</code> 经常梦到的场景，在风暴之中，自己在被撕扯着想要登上灯塔。可惜只有我一个人。</p><p>看着一堆东西还没学，也不是很想学。后天还要考政治，什么都没背，感觉有点不太好。</p><p>似乎我走迷了路。或者说，我经常会走迷了路。高中到现在为止我一直在追求着什么，放弃了很多，但是到现在我也一直不知道我到底在追求些什么。是奥赛吗？我恍惚了。是功成名就吗？我恍惚了。</p><p>感觉到现在为止，我只有每个学期刚刚开始，即18年9月 $\sim$ 10月和今年的9月 $\sim$ 10月有认真学过文化课，剩下的时间都在划水；美其名曰学研究奥赛，学来的线性规划或者 <code>HLPP</code> 可能永远也用不上。我在干什么？其他人丰富有趣、值得回忆的高中生活，在我眼里就是一场又一场的白日梦，一次又一次地跌倒再爬起来再欺骗自己：你没跌倒。这一切的一切，真是我想要的吗？</p><p>我又在瞎想了。给梁文道做序的某作家（忘了名字）说，为什么人们喜欢寓哲学于文学呢，因为人们喜欢问没有答案的问题，喜欢去体味这种求索的感觉。可能对我来说，这也算是一点心理安慰了吧。</p><p>嗯，写完这些感觉内心明显平静了许多。</p><h3 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h3><p>今天有点颓，上午只写了一篇题解，下午做$[\rm SNOI2019]$的D2T1，做了好久，剩下的时间不知道干什么去了。</p><p>晚上继续和 <code>ouuuyuuu</code> 出去跑圈。外面开始下雪了，十分开心。但是一边跑，风雪夹带着冷雨扑打过来有点难受。眼镜中途还因为镜面上水太多，想用手套擦，结果擦成了磨砂玻璃…233摘下眼镜来继续跑就会感觉跟喝了一壶一样，看着周围都是一派虚无缥缈的景象。</p><p>开始看梁文道的《我执》了。感觉还行。但是毕竟只看了一点，也不知道到底有什么精彩等待着我。</p><p>发现自己写文章的时候，可能是因为平时说话说太快了，一直不喜欢加句号。大多数情况下都是一大段全是逗号233</p><p>晚上发现胜利一中的神仙们去逛了我的 <code>Luogu</code> 博客，比较开心。因为似乎我也没法跟别人交流了。</p><p>瞎扯一句，感觉 <code>rqy</code> 能一个人在这儿奋斗两年，十分厉害。孤独+经常会有的绝望+偶尔的希望，不把人逼自闭已经算是很好了。</p><p>诶，刚刚才发现原来自己有三个博客，但是这三个博客上的东西几乎都不一样。。。233</p><h3 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h3><p>平安夜，很自闭233</p><p>看了一上午+大半个下午的构造，感觉一般。听 <code>ouuuyuuu</code> 说构造题只能长经验，是学不会的，感觉有点小失落。</p><p><del>人总要有梦想，万一我就学会了呢</del></p><p>晚上复盘了一下自己的 $\rm CSP-S~2019$ ，感觉虽然和大家都很有差距，但是如果从进步的意义上来讲，比起去年来自己进步还是蛮多的。毕竟去年也就那点水平。</p><p>嗯，所以呢，谁知道将来我会不会进步到我想象不到的水平呢？加油吧，我可是想要创造奇迹的笨蛋啊！</p><h3 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h3><p>越来越困了，发现啥都学不会，然后自闭了。</p><p>发现去了 <code>pkuwc</code> 的小伙伴们似乎都有约拿了，感觉更自闭了。</p><p>……我觉得我现在应该是全校最盼着放寒假的人了。当初觉得似乎机房生活会很轻松，结果发现比文化课生活自闭了不止一个量级。可海星……</p><p>发现啥都学不会了，发现比别人拉下的不止一点半点……有点难受，但是一想到马上要放假了（虽然还有一个多月）就会开心一点phh</p><h3 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h3><p>……之前换了几天的 <code>jacman</code> 主题，说实话感觉不是很漂亮。换主题的原因是我关了一次 <code>icloud</code>，然后他就给我吞了……迷惑。于是只能重新建一个主题。不过好在我<del>找回了失去的脑子</del>找到了对应的文件夹，于是九成功复原了。于是现在就又换回了 <code>next</code> 主题。</p><p>怎么说呢，虽然 <code>next</code> 主题确实用的比较多，有烂大街的嫌疑，但是你要真让我去挑其他的喜欢的并且配置出来，确实很麻烦。</p><p>嗯，这个故事告诉我们要学会备份。 </p><h3 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h3><p>upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。</p><p>新建了这个文档，本想写很多，结果突然发现自己WC都去不了。</p><p>然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;别名：一句话日记&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;可能就是用来随时记录自己感悟的东西？&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://www.orchidany.cf/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="笔尖生花" scheme="http://www.orchidany.cf/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Manacher简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/Manacher%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/Manacher泛做/</id>
    <published>2019-12-15T07:26:25.000Z</published>
    <updated>2019-12-15T07:28:45.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>在？为啥不用PAM？</del></p><p>emm那可能是空间开不下（自我安慰</p><a id="more"></a><h1 id="1-LG1659-国家集训队-拉拉队排练"><a href="#1-LG1659-国家集训队-拉拉队排练" class="headerlink" title="$1$ LG1659 [国家集训队]拉拉队排练"></a>$1$ LG1659 [国家集训队]拉拉队排练</h1><blockquote><p>求前$k$大的奇数长度回文串的长度之积。</p><p>$\rm |S|\leq 1e6,K\leq 1e12$</p></blockquote><p>……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq</p><p>二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。</p><p>以下是错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L = <span class="number">-1</span> ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> x = ed[p], i ; </span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; p ; ++ i)</span><br><span class="line">ret += <span class="number">1l</span>l * ((ed[i] - ed[p] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret + (buc[ed[p]]) &gt;= K) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) buc[base[i] - <span class="number">1</span>] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i += <span class="number">2</span>) <span class="keyword">if</span> (buc[i]) ed[++ tot] = i ; </span><br><span class="line">reverse(ed + <span class="number">1</span>, ed + tot + <span class="number">1</span>) ; <span class="keyword">int</span> L = <span class="number">1</span>, R = tot, Mid, ans, pos = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">/*if (rand() % 2)</span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/</span></span><br><span class="line"><span class="keyword">if</span> (check(Mid)) ans = Mid, R = Mid - <span class="number">1</span> ; <span class="keyword">else</span> L = Mid + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line">pos = ans, res = <span class="number">1l</span>l, _up = ed[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ed[pos] ; i &lt;= ed[<span class="number">1</span>] ; i += <span class="number">2</span>) fact *= <span class="number">1l</span>l * i ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (ed[i] &lt; _up) fact /= _up, _up -= <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">if</span> ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span> &gt; K)&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K)</span><br><span class="line">res = res * <span class="number">1l</span>l * ed[i], ed[i] -= <span class="number">2</span>, ++ j ; </span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line">&#125; </span><br><span class="line">res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ;</span><br><span class="line">K -= <span class="number">1l</span>l * ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line"><span class="keyword">if</span> (K &lt;= <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">LL ret = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= x) %= Mod ; </span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= <span class="number">1</span>) ++ base[i] ; </span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i], id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">ans += buc[i] ; </span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= K)</span><br><span class="line">(res *= expow(i, ans)) %= Mod, K -= ans ; </span><br><span class="line"><span class="keyword">else</span> &#123; (res *= expow(i, K)) %= Mod, K -= ans ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。</p><h1 id="2-LG4555-国家集训队-最长双回文串"><a href="#2-LG4555-国家集训队-最长双回文串" class="headerlink" title="$2$ LG4555 [国家集训队]最长双回文串"></a>$2$ LG4555 [国家集训队]最长双回文串</h1><p>这题比第一题友善了很多。。。</p><blockquote><p>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。</p></blockquote><p>嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">int</span> i, id = <span class="number">0</span>, rt = <span class="number">0</span> ; ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(rt - i + <span class="number">1</span>, base[<span class="number">2</span> * id - i]) ;  </span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"><span class="keyword">if</span> (i + base[i] &gt; rt) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> l = i / <span class="number">2</span> - (base[i] / <span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> r = i / <span class="number">2</span> + (base[i] / <span class="number">2</span>) - <span class="number">1</span> ; <span class="keyword">if</span> (ns[i] == <span class="number">35</span>) ++ r ;</span><br><span class="line">Ls[r] = max(Ls[r], base[i] - <span class="number">1</span>), Rs[l] = max(Rs[l], base[i] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + <span class="number">1</span>]) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;在？为啥不用PAM？&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;emm那可能是空间开不下（自我安慰&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
  </entry>
  
  <entry>
    <title>【题解】PAM简单题泛做</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAM%E6%B3%9B%E5%81%9A/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAM泛做/</id>
    <published>2019-12-15T07:23:16.000Z</published>
    <updated>2019-12-15T07:26:12.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都是简单的PAM习题</p><a id="more"></a><h1 id="1-LG5496-【模板】回文自动机"><a href="#1-LG5496-【模板】回文自动机" class="headerlink" title="$1$ LG5496 【模板】回文自动机"></a>$1$ LG5496 【模板】回文自动机</h1><blockquote><p>对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。</p><p>$|s|\leq 1e6$</p></blockquote><p>然后就是PAM的板子题<del>咋感觉好像没有不是很板的PAM题呢</del></p><p>考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移<br>$$<br>cnt_{p}=cnt_{fail_p}+1<br>$$<br>然后就没有然后了。</p><h1 id="2-APIO2014-回文串"><a href="#2-APIO2014-回文串" class="headerlink" title="$2$ [APIO2014]回文串"></a>$2$ [APIO2014]回文串</h1><blockquote><p>给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。</p><p>对于给你的这个字符串$s$，求所有回文子串中的最大存在值。</p><p>$|s|\leq 1e6$</p></blockquote><p>感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然<strong>“串的最长回文后缀唯一”</strong>的逆命题<strong>“任何串会唯一作为其他串的最长回文后缀”</strong>也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用<br>$$<br>\rm f_u=ctn_u+\sum_{v\in S(u)}f_v<br>$$<br>其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。</p><p>emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; i --) </span><br><span class="line">    P.f[P.pre[i]] += P.f[i], ans = max(ans, <span class="number">1l</span>l * P.len[i] * P.f[i]) ;</span><br></pre></td></tr></table></figure><p><del>哪那么多P话，就是背啊</del></p><h1 id="3-LG5555-秩序魔咒"><a href="#3-LG5555-秩序魔咒" class="headerlink" title="$3$ LG5555 秩序魔咒"></a>$3$ LG5555 秩序魔咒</h1><blockquote><p>求两个串的最长公共回文子串以及该长度的出现次数。</p><p>$\rm |S|,|T|\leq 10^6$</p></blockquote><p><del>恭喜发现一个新套路</del></p><p>观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ans == P.len[x]) res ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; P.len[x]) res = <span class="number">1</span>, ans = P.len[x] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By the way，奇根/偶根都要$dp$一次。</p><h1 id="4-JSOI2013-快乐的-JYY"><a href="#4-JSOI2013-快乐的-JYY" class="headerlink" title="$4$ [JSOI2013]快乐的 JYY"></a>$4$ [JSOI2013]快乐的 JYY</h1><blockquote><p>求两个串的不同公共回文串的个数，其中不同意思是下标不同。</p><p>$|s|,|t|\leq 10^6$</p></blockquote><p>……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x + y &gt; <span class="number">2</span>) ans += <span class="number">1l</span>l * P.f[x] * Q.f[y] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.Init(), Q.Init() ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Insert(S[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, S) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) Q.Insert(T[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, T) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">1</span>) ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans&lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-闲扯"><a href="#5-闲扯" class="headerlink" title="$5$ 闲扯"></a>$5$ 闲扯</h1><p>写模板题真是让人感到空虚……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是简单的PAM习题&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】PAM &amp; Manacher</title>
    <link href="http://www.orchidany.cf/2019/12/15/PAMandManacher/"/>
    <id>http://www.orchidany.cf/2019/12/15/PAMandManacher/</id>
    <published>2019-12-15T06:05:19.000Z</published>
    <updated>2019-12-15T06:18:31.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PAM &amp; Manacher，两种用来处理回文串的玩意儿。</p><a id="more"></a> <h1 id="1-Manacher"><a href="#1-Manacher" class="headerlink" title="$1$ Manacher"></a>$1$ Manacher</h1><p><del>挺短，背是挺好背的</del></p><p>Manacher用于求回文串长度。思想大概就是：</p><p>1、加入字符集之外的识别字符（比如<code>#</code>）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。</p><p>2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定<strong>至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$}</strong> 。然后就不断扩展即可。</p><p>3、关于复杂度证明。我们记<strong>一次帅气的操作</strong>的意义是<strong>成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$</strong>，记以当前点为轴的最长回文子串为$\rm T$，$T$的右端点为$q$。可以知道</p><ul><li>（1）$\rm S$的右端点是单增的；</li><li>（2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然<code>while</code>1次，$maxlen$增大一次；</li><li>（3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出<code>while</code>；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。</li></ul><p>So,最终复杂度就是$\Theta(n)$的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id, fars, i ; </span><br><span class="line">id = <span class="number">0</span>, fars = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line"><span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line"><span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> <span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), </span><br><span class="line">L = <span class="number">-1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; Manacher(In) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) ans = max(ans, base[i] - <span class="number">1</span>) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-PAM"><a href="#2-PAM" class="headerlink" title="$2$ PAM"></a>$2$ PAM</h1><p>学了PAM，不知道为啥感觉比SAM简单？</p><p>其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下：</p><p>0、一个串的回文子串至多有$O(n)$个。</p><p>1、首先每个节点需要保存这个节点中回文串的长度。</p><p>2、显然始状态需要有两个，即奇数长度的$s$和偶数长度的$s$，称作<strong>“奇根”</strong>和<strong>“偶根”</strong>。那么为了方便呢，奇根的长度设置为$-1$，偶根长度设置为$0$。</p><p>3、考虑要从$last$指针扩展当前状态，假设当前需要<code>insert</code>的字母是$c$，是这个串里面的第$p$个字符，那我们需要找到一个后缀$s[j…p-1]\quad s.t.\quad s[j…p-1]$本身回文且$s[j-1]=c$，那么就可以向下扩展。</p><p>4、考虑怎么找这个后缀，显然对于一个串$S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的<strong>最长回文后缀</strong>。</p><p>5、插入新节点时，考虑跳完$fail$后如果没有相应的转移边，就要新建一个状态然后连$fail$.</p><p>然后是代码和一点注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line"><span class="keyword">int</span> rt0, rt1, last, sz ;</span><br><span class="line"><span class="keyword">int</span> len[MAXN], fail[MAXN] ;</span><br><span class="line">&#125;P ;</span><br><span class="line"><span class="keyword">void</span> _init(PAM &amp;p)&#123;</span><br><span class="line">p.sz = <span class="number">-1</span>, </span><br><span class="line">p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ;</span><br><span class="line">p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ;</span><br><span class="line">p.last = p.rt0, p.len[p.rt0] = <span class="number">0</span>, p.len[p.rt1] = <span class="number">-1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line"><span class="keyword">int</span> u = p.last ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line"><span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line"><span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line"><span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line"><span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, </span><br><span class="line">&#125;</span><br><span class="line">p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn,</span><br></pre></td></tr></table></figure><p>原因是当$fa=u$时就出现环了。</p><h1 id="3-闲扯"><a href="#3-闲扯" class="headerlink" title="$3$ 闲扯"></a>$3$ 闲扯</h1><p>学完才知道，$\rm PAM$又简单又好背功能又多……Manacher被打爆了啊喂qwq。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PAM &amp;amp; Manacher，两种用来处理回文串的玩意儿。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PAM,回文自动机" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
      <category term="字符串/Manacher" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-Manacher/"/>
    
      <category term="字符串/PAM,回文自动机" scheme="http://www.orchidany.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-PAM-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces前11场泛做</title>
    <link href="http://www.orchidany.cf/2019/11/15/cf1-11/"/>
    <id>http://www.orchidany.cf/2019/11/15/cf1-11/</id>
    <published>2019-11-14T23:34:18.000Z</published>
    <updated>2020-01-02T00:08:35.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq</p><a id="more"></a><h1 id="rm-CF·1C"><a href="#rm-CF·1C" class="headerlink" title="$\rm {CF·1C}$"></a>$\rm {CF·1C}$</h1><blockquote><p>求包含给定三点的正多边形最小面积。</p></blockquote><hr><p>先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。</p><p>之后对于该多边形，我们考虑，由于其让求的正多边形需要<strong>面积最小</strong>。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是<strong>该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍</strong></p><p>那么我们就做一个<code>double</code>类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。</p><p>最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-4</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.00000</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> mark ; <span class="comment">// 0 = exist, 1 = inexist ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">&#125;A, B, C, O, m1, m2, m3 ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ;<span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line">    <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; <span class="comment">// y = kx + b, x = k, y = k ;</span></span><br><span class="line">&#125;L[<span class="number">12</span>] ; <span class="keyword">double</span> Len[<span class="number">4</span>], agl[<span class="number">4</span>], R, angle ; <span class="keyword">int</span> i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is x = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is y = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_Mid</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.x + B.x) / <span class="number">2</span>, (A.y + B.y) / <span class="number">2</span> &#125; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_verti</span><span class="params">(Node n, Line a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.mark) <span class="keyword">return</span> (Line) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (a.mark == <span class="number">1</span>) <span class="keyword">return</span> (Line) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = <span class="number">-1.0</span> / a.k, bb = n.y - n.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_Line</span><span class="params">(Node A, Node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A. y == B. y) <span class="keyword">return</span> (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A. x == B. x) <span class="keyword">return</span> (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, A.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; </span><br><span class="line">  <span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span><span class="params">(Line A, Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, get_x(A, B), get_y(A, B)&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.y - B.b) / B.k, A.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (B.y - A.b) / A.k, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, B.x, B.x * A.k + A.b&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, A.x, A.x * B.k + B.b&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">gcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; Eps) <span class="keyword">return</span> a ; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; Eps) <span class="keyword">return</span> b ; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, <span class="built_in">fmod</span>(a, b)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; </span><br><span class="line">  A.mark = B.mark = C.mark = <span class="number">0</span> ;</span><br><span class="line">    L[<span class="number">1</span>] = get_Line(A, B), L[<span class="number">2</span>] = get_Line(B, C), L[<span class="number">3</span>] = get_Line(A, C) ; </span><br><span class="line">  m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ;</span><br><span class="line">    L[<span class="number">4</span>] = get_verti(m1, L[<span class="number">1</span>]), L[<span class="number">5</span>] = get_verti(m2, L[<span class="number">2</span>]) ;</span><br><span class="line">  O = get_inter(L[<span class="number">4</span>], L[<span class="number">5</span>]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / <span class="number">3.0</span> ;</span><br><span class="line">    Len[<span class="number">1</span>] = dis(A, B), Len[<span class="number">2</span>] = dis(B, C), Len[<span class="number">3</span>] = dis(A, C) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) agl[i] = <span class="built_in">acos</span>(<span class="number">1</span> - Len[i] * Len[i] / (<span class="number">2</span> * R * R) ); </span><br><span class="line">    agl[<span class="number">3</span>] = <span class="number">2</span> * Pi - agl[<span class="number">1</span>] - agl[<span class="number">2</span>], angle = gcd(agl[<span class="number">3</span>], gcd(agl[<span class="number">1</span>], agl[<span class="number">2</span>])) ; <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (Pi * R * R * <span class="built_in">sin</span>(angle)) / angle) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·2B"><a href="#rm-CF·2B" class="headerlink" title="$\rm CF·2B$"></a>$\rm CF·2B$</h1><blockquote><p>给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走</p><p>以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾.</p><p>$n\leq 1,000$</p></blockquote><p>考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> &amp;N, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!N) &#123; zerox = i, zeroy = j ; <span class="keyword">return</span> <span class="number">1</span> ; &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ; <span class="keyword">while</span> (!(N % fac)) ++ res, N /= fac ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark, <span class="keyword">int</span> kind)</span></span>&#123; <span class="comment">//mark 1 : D, 2 : R ;</span></span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (kind == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mark) <span class="keyword">return</span> ; <span class="keyword">if</span> (mark == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"D"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp2)), dp2[<span class="number">1</span>][<span class="number">0</span>] = dp2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(dp5, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp5)), dp5[<span class="number">1</span>][<span class="number">0</span>] = dp5[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp2[i][j] = min(dp2[i - <span class="number">1</span>][j], dp2[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">1</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">2</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp5[i][j] = min(dp5[i - <span class="number">1</span>][j], dp5[i][j - <span class="number">1</span>]) </span><br><span class="line">          + (base[i][j][<span class="number">2</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">5</span>)) ;</span><br><span class="line">    Ans = min(dp5[N][N], dp2[N][N]) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans &gt; <span class="number">1</span> &amp;&amp; zerox &amp;&amp; zeroy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zerox ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zeroy ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zerox + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zeroy + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  dp5[N][N] &gt; dp2[N][N] ? Print(N, N, <span class="number">0</span>, <span class="number">1</span>) : Print(N, N, <span class="number">0</span>, <span class="number">2</span>) ;</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·2C"><a href="#rm-CF-·2C" class="headerlink" title="$\rm CF ·2C$"></a>$\rm CF ·2C$</h1><blockquote><p>给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。</p></blockquote><p><del>咋又是计算几何啊</del></p><p>设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。</p><p>那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有$$\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}$$</p><p>稍微移一下项，就会有$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)} $$</p><p>那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。</p><p>事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可：</p><p>设比例系数为$k(k \geq 1)$, 那么：</p><p>$$<br>\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\<br>\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2<br>$$</p><p>稍微移一下项就会得到<br>$$<br>(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0<br>$$</p><p>看起来有点儿长……</p><p>令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$</p><p>那么就会变成<br>$$<br>Ax^2 + Ay^2+ Cx + Dy+E = 0<br>$$<br>由于$A,C,D,E$都是常数，所以这是一个<strong>圆的一般方程。</strong></p><p>我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说<strong>当且仅当两个圆半径相等时，点$T$的轨迹是一条直线</strong>。其余的情况则是<strong>一个圆</strong>。</p><p>我们不妨先记这种<strong>到两个圆的圆心的距离成定比例的</strong>轨迹为两个圆的<strong>生成曲线</strong>。</p><p>那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要：</p><ul><li>$(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。</li><li>$(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}$$的点，我们需要判断对于圆$C$是否也满足<br>$$<br>\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}<br>$$</li><li>$(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。</li></ul><p>然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233</p><p>代码很繁琐233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-3</span> ; <span class="keyword">int</span> i ;<span class="comment">//以下的mark都是记录状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> xa, ya, xb, yb ; &#125; I[<span class="number">5</span>] ; </span><br><span class="line"><span class="comment">// 0 = inexist, 1 = exist*1, 2 = exist*2 ;</span></span><br><span class="line"><span class="comment">//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; &#125;L[<span class="number">12</span>] ; </span><br><span class="line"><span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ; <span class="comment">// 1 : circle ; 0 : Line ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r ;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, D, E ;</span><br><span class="line">    Circle <span class="keyword">friend</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> Circle &amp;A, <span class="keyword">const</span> Circle &amp;B)&#123;</span><br><span class="line">        <span class="keyword">return</span> (Circle)&#123;<span class="number">0</span>, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;C[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">double</span> ansx, ansy ; <span class="keyword">bool</span> check ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> A.mark &lt; B.mark ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is (x = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is (y = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disa</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); </span><br><span class="line">&#125;<span class="comment">//第一个点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disb</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); </span><br><span class="line">&#125;<span class="comment">//第二个点之间的距离</span></span><br><span class="line"><span class="comment">//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">Line_inter</span><span class="params">(Line A, Line B)</span></span>&#123;<span class="comment">//斜截式直线求交点（之前写的直接copy过来的）</span></span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) ) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, get_x(A, B), get_y(A, B), <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.y - B.b) / B.k, A.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (B.y - A.b) / A.k, B.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, B.x, B.x * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, A.x, A.x * B.k + B.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span> <span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//“生成曲线”求交点</span></span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">0</span> &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == <span class="number">0</span>))&#123;<span class="comment">//一条是直线，一个是圆</span></span><br><span class="line">        <span class="keyword">if</span> (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; <span class="comment">// B is a line ;</span></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span> + (B.C / B.D) * (B.C / B.D), del ;</span><br><span class="line">        <span class="keyword">double</span> c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ;</span><br><span class="line">        <span class="keyword">double</span> b = (A.C - B.C * A.D / B.D + <span class="number">2</span> * B.C * B.E /((B.D) * (B.D)) ) ; </span><br><span class="line">        <span class="keyword">if</span> ((del = (b * b - <span class="number">4</span> * a * c)) &lt; -Eps) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ; </span><br><span class="line">        <span class="comment">// printf("%lf %lf %lf %lf\n", a, b, c, del) ;</span></span><br><span class="line">        <span class="keyword">double</span> xa =  (-b + <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a), xb = (-b - <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a) ;</span><br><span class="line">        <span class="keyword">double</span> ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">return</span> (Node)&#123;<span class="number">2</span>, xa, ya, xb, yb&#125; ;<span class="comment">//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.mark &amp;&amp; !B.mark)&#123;</span><br><span class="line">        Line La, Lb ; <span class="comment">//两条都是直线，那么就直接转化成斜截式求。</span></span><br><span class="line">        <span class="keyword">if</span> (!A.C) La = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - A.E / A.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!A.D) La = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -A.E / A.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> La = (Line)&#123;<span class="number">2</span>, -A.C / A.D, -A.E / A.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (!B.C) Lb = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - B.E / B.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!B.D) Lb = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -B.E / B.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> Lb = (Line)&#123;<span class="number">2</span>, -B.C / B.D, -B.E / B.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">        <span class="keyword">return</span> Line_inter(La, Lb) ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (A.mark &amp;&amp; B.mark)&#123;</span><br><span class="line">        Circle C = A - B ; <span class="keyword">return</span> get_inter(C, A) ;</span><br><span class="line">        <span class="comment">//此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">make_rat</span><span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//rat = ratio[n.]比例；比率，用来求生成曲线的函数</span></span><br><span class="line">    <span class="keyword">double</span> _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; <span class="keyword">double</span> t ; </span><br><span class="line">    Ans.A = Ans.B = (_k2 - <span class="number">1</span>), </span><br><span class="line">  Ans.C = <span class="number">-2</span> * (_k2 * B.x - A.x), </span><br><span class="line">  Ans.D = <span class="number">-2</span> * (_k2 * B.y - A.y), </span><br><span class="line">    Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), </span><br><span class="line">  Ans.x = Ans.y = Ans.r = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (Ans.A != <span class="number">0</span>) </span><br><span class="line">      Ans.mark = <span class="number">1</span>, t = Ans.A, Ans.A /= t, </span><br><span class="line">  Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; </span><br><span class="line">  <span class="keyword">else</span> Ans.mark = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_for_Ans</span><span class="params">()</span></span>&#123;<span class="comment">//最后的结果，判断选哪个交点</span></span><br><span class="line">    sort(I + <span class="number">1</span>, I + <span class="number">3</span>, Comp) ;<span class="comment">//我闲的，方便一点</span></span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>].mark &lt;= <span class="number">1</span>) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> A1, A11, B1, B11 ;</span><br><span class="line">        I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]) ;</span><br><span class="line">        A1 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        A11 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        B1 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        B11 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        <span class="keyword">if</span> (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) </span><br><span class="line">          check = <span class="number">1</span> ;<span class="comment">//如果在误差范围内都不相等就说明无解。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> Ja = <span class="built_in">sin</span>(<span class="number">1</span> / A1), Jb = <span class="built_in">sin</span>(<span class="number">1</span> / B1) ;<span class="comment">//比较角的大小，通过sin来搞</span></span><br><span class="line">            <span class="keyword">if</span> (Ja &gt; Jb) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">          <span class="keyword">else</span> ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ;</span><br><span class="line">    C[<span class="number">4</span>] = make_rat(C[<span class="number">1</span>], C[<span class="number">2</span>]), </span><br><span class="line">  C[<span class="number">5</span>] = make_rat(C[<span class="number">2</span>], C[<span class="number">3</span>]), </span><br><span class="line">  C[<span class="number">6</span>] = make_rat(C[<span class="number">3</span>], C[<span class="number">1</span>]), </span><br><span class="line">    I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]), </span><br><span class="line">  I[<span class="number">2</span>] = get_inter(C[<span class="number">5</span>], C[<span class="number">6</span>]), </span><br><span class="line">  I[<span class="number">3</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">6</span>]) ; </span><br><span class="line">    <span class="comment">/*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!I[<span class="number">1</span>].mark || !I[<span class="number">2</span>].mark || !I[<span class="number">3</span>].mark) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'\n'</span>), <span class="number">0</span> ; </span><br><span class="line">  make_for_Ans() ; (!check) ? <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf"</span>, ansx, ansy) : <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·3B"><a href="#rm-CF·3B" class="headerlink" title="$\rm CF·3B$"></a>$\rm CF·3B$</h1><blockquote><p>有一辆载重量为$v$的货车， 准备运送两种物品。 </p><p>物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。</p><p>$n\leq 100,000\quad v\leq 1e9$</p></blockquote><p>其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。</p><p>$\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学）</p><p>有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ,val ;</span><br><span class="line">&#125; base1[MAXN], base2[MAXN] ; <span class="keyword">int</span> N, M, p, v, v1, v2, c ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ; <span class="keyword">int</span> tot1, tot2, t1, t2, i ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Data a, Data b)</span></span>&#123; <span class="keyword">return</span> a.val &gt; b.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="built_in">memset</span>(base1, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base1)) ; </span><br><span class="line">    <span class="built_in">memset</span>(base2, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base2)) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v) ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">1</span>) base2[++ tot2].val = v, base2[tot2].num = i ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*qwq*/</span>base1[++ tot1].val = v, base1[tot1].num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base1 + <span class="number">1</span>, base1 + tot1 + <span class="number">1</span>, Comp), </span><br><span class="line">    sort(base2 + <span class="number">1</span>, base2 + tot2 + <span class="number">1</span>, Comp) ;</span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp; <span class="number">1</span>) ans.pb(base1[<span class="number">1</span>].num), Ans += base1[<span class="number">1</span>].val, ++ t1, M -- ;</span><br><span class="line">    <span class="keyword">while</span> (M &gt; <span class="number">1</span>)&#123;<span class="comment">//此处&gt;1是选v=2时防止越界</span></span><br><span class="line">        v2 = base2[t2 + <span class="number">1</span>].val ;</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) <span class="keyword">break</span> ;</span><br><span class="line">        v1 = base1[t1 + <span class="number">1</span>].val + base1[t1 + <span class="number">2</span>].val ; </span><br><span class="line">        <span class="keyword">if</span> (t1 + <span class="number">2</span> &gt; tot1) v1 = base1[t1 + <span class="number">1</span>].val, c = <span class="number">1</span> ; <span class="keyword">else</span> c = <span class="number">2</span> ; </span><br><span class="line">        <span class="keyword">if</span> (v1 &gt;= v2)&#123;</span><br><span class="line">            Ans += v1 ; M -= c ;</span><br><span class="line">            rep(i, <span class="number">1</span>, c) ans.pb(base1[++ t1].num) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Ans += v2, M -= <span class="number">2</span>, ans.pb(base2[++ t2].num) ; </span><br><span class="line">    &#125;<span class="comment">//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp;&amp; t1 &lt; tot1) </span><br><span class="line">      Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; </span><br><span class="line">  <span class="keyword">if</span> (Ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) <span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="string">" "</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·4D"><a href="#rm-CF·4D" class="headerlink" title="$\rm{CF·4D}$"></a>$\rm{CF·4D}$</h1><blockquote><p>给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$</p><p>求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度<br>$n \leq 5,000$</p></blockquote><p>一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), f[i] = <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">if</span> (A &lt;= W || B &lt;= H) <span class="keyword">continue</span> ;</span><br><span class="line">      E[++ tot].w = A, E[tot].h = B, E[tot].num = i ;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(E + <span class="number">1</span>, E + tot + <span class="number">1</span>, Comp) ;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h)</span><br><span class="line">              <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                  f[i] = f[j] + <span class="number">1</span>, r[i] = j ;</span><br><span class="line">              &#125; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; ans) ans = f[i], End = i ;</span><br><span class="line">  <span class="keyword">while</span>(End) s.push(End), End = r[End] ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">while</span> (!s.empty()) <span class="built_in">cout</span> &lt;&lt; E[s.top()].num &lt;&lt; <span class="string">" "</span>, s.pop() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5C"><a href="#rm-CF·5C" class="headerlink" title="$\rm CF·5C$"></a>$\rm CF·5C$</h1><blockquote><p>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。</p><p>$n\leq 1,000,000$</p></blockquote><p>好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s ; </span><br><span class="line"><span class="keyword">int</span> N, dp[MAXN], f[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) s.push(i)<span class="comment">/*, cout &lt;&lt; "qwq" &lt;&lt; endl */</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s.empty()) base[s.top()] = base[i] = <span class="number">1</span>, s.pop() ; </span><br><span class="line">    &#125; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (base[i]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span> ; <span class="keyword">else</span> dp[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      f[i] = max(f[i - <span class="number">1</span>], dp[i]) ; <span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">  <span class="keyword">int</span> maxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dp[i] == f[N]) ++ ans ; <span class="built_in">cout</span> &lt;&lt; (f[N] ? ans : <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5D"><a href="#rm-CF·5D" class="headerlink" title="$\rm CF·5D$"></a>$\rm CF·5D$</h1><blockquote><p>有一个长度为$l$的道路，你的加速是$a$。</p><p>从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。</p><p>$w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。</p></blockquote><p>高中物理模拟题？？</p><p>其实就是分类讨论一下就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> mark ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span> ; </span><br><span class="line"><span class="keyword">double</span> x_1, x_2, ans, x ;</span><br><span class="line"><span class="keyword">double</span> vnow, a, vmax, L, D, vmaxd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; a) swap(a, b) ;</span><br><span class="line"><span class="keyword">return</span> ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">0.5</span> * (<span class="number">2</span> * a * D + vmaxd * vmaxd)) ; </span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmax) vnow = vmax, mark = <span class="number">1</span> ;</span><br><span class="line">x_1 = vnow * vnow / <span class="number">2</span> / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;</span><br><span class="line"><span class="comment">//if (!mark)&#123;</span></span><br><span class="line">ans += vnow / a + (vnow - vmaxd) / a ; </span><br><span class="line"><span class="keyword">if</span> (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ;</span><br><span class="line"><span class="comment">/*&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment">ans += vnow / a + (vnow - vmaxd) / a ;</span></span><br><span class="line"><span class="comment">x = ans += x / vnow ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmax, x = vnow * vnow / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L || equal(x, L))&#123;</span><br><span class="line">ans = vnow / a, ans += (L - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * L) ;</span><br><span class="line">ans = vnow / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = (vmax * vmax - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line"><span class="keyword">if</span> (x &lt; L - D || equal(x, L - D))&#123;</span><br><span class="line">ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vnow = vmaxd, x = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * (L - D) + vnow * vnow) ;</span><br><span class="line">ans += (x - vnow) / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·5E"><a href="#rm-CF·5E" class="headerlink" title="$\rm CF·5E$"></a>$\rm CF·5E$</h1><blockquote><p>有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。</p><p>$n\leq 100,000$</p></blockquote><p>一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; ++ i) <span class="built_in">stack</span>[i] = Mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">init(M), ans = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i, tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line"><span class="keyword">while</span> (tp &amp;&amp; <span class="built_in">stack</span>[tp].first &lt; base[i]) </span><br><span class="line">      ans += <span class="built_in">stack</span>[tp].second, -- tp ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>[tp].first != base[i])  </span><br><span class="line">ans += (tp &gt; <span class="number">0</span>), <span class="built_in">stack</span>[++ tp] = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">else</span> ans += (tp &gt; <span class="number">1</span>) + <span class="built_in">stack</span>[tp].second, ++ <span class="built_in">stack</span>[tp].second ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i + N] = base[i] = qr() ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; St, Ed ;</span><br><span class="line">St = Mp(<span class="number">-1</span>, <span class="number">0</span>), Ed = Mp(<span class="number">-1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (St.first &lt; base[i]) </span><br><span class="line">      Ed = St, St = Mp(base[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (St.first == base[i]) ++ St.second ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Ed.first &lt; base[i]) Ed = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ed.first == base[i]) ++ Ed.second ;</span><br><span class="line">&#125;</span><br><span class="line">Ans = Solve(<span class="number">2</span> * N) - Solve(N),</span><br><span class="line">  Ans -= (St.second * St.second + ((St.second == <span class="number">1</span>) ? Ed.second : <span class="number">0</span>)), </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·6D"><a href="#rm-CF·6D" class="headerlink" title="$\rm CF·6D$"></a>$\rm CF·6D$</h1><blockquote><p>有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。</p><p>不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。</p><p>$n\leq 10$</p></blockquote><p>看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, a, b, blood[MAXN], i, j, k, l ; </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; From[MAXN][MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">Print(step - <span class="number">1</span>, From[step + <span class="number">1</span>][jj][kk].first, From[step + <span class="number">1</span>][jj][kk].second) ;</span><br><span class="line"><span class="keyword">int</span> tow = dp[step][From[step + <span class="number">1</span>][jj][kk].first][From[step + <span class="number">1</span>][jj][kk].second] ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">1</span> ; qwq &lt;= dp[step + <span class="number">1</span>][jj][kk] - tow ; ++ qwq) <span class="built_in">printf</span>(<span class="string">"%d "</span>, step) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; a &gt;&gt; b ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; blood[i], ++ blood[i] ;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">2</span>][blood[<span class="number">1</span>]][blood[<span class="number">2</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= blood[i - <span class="number">1</span>] ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= blood[i] ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> down_ = (j + b - <span class="number">1</span>) / b ;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j][k] &gt; INF) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">int</span>up_ = max(down_, max((blood [i + <span class="number">1</span>] + b - <span class="number">1</span>) / b, (k + a - <span class="number">1</span>) / a)) ;</span><br><span class="line"><span class="keyword">for</span> (l = down_ ; l &lt;= up_ ; ++ l)&#123;</span><br><span class="line"><span class="keyword">int</span> now_j = max(<span class="number">0</span>, k - a * l) ;</span><br><span class="line">          <span class="keyword">int</span> now_k = max(<span class="number">0</span>, blood[i + <span class="number">1</span>] - b * l) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i + <span class="number">1</span>][now_j][now_k] &gt; dp[i][j][k] + l)</span><br><span class="line">dp[i + <span class="number">1</span>][now_j][now_k] = dp[i][j][k] + l, </span><br><span class="line">          From[i + <span class="number">1</span>][now_j][now_k] = Mp(j ,k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; Print(N - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF-·6E"><a href="#rm-CF-·6E" class="headerlink" title="$\rm CF ·6E$"></a>$\rm CF ·6E$</h1><blockquote><p>给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。</p><p>$n\leq 100,000$</p></blockquote><p>憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233</p><p>值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。</p><p>然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, h1 = <span class="number">1</span>, t1 = <span class="number">0</span>, h2 = <span class="number">1</span>, t2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ;</span><br><span class="line">  <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ;</span><br><span class="line">  q[++ t1] = p[++ t2] = i ; </span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123;</span><br><span class="line">  l ++ ; <span class="keyword">while</span> (q[h1] &lt; l) ++ h1 ; <span class="keyword">while</span> (p[h2] &lt; l) ++ h2 ;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, s[i] - s[l - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是二分$st$表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_ST</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> H = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= H ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) &lt;= N + <span class="number">1</span> ; ++ i)</span><br><span class="line">dp1[i][j] = max(dp1[i][j - <span class="number">1</span>], dp1[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]), </span><br><span class="line">dp2[i][j] = min(dp2[i][j - <span class="number">1</span>], dp2[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> max(dp1[l][k - <span class="number">1</span>], dp1[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line"><span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line"><span class="keyword">return</span> min(dp2[l][k - <span class="number">1</span>], dp2[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">dp1[i][<span class="number">0</span>] = dp2[i][<span class="number">0</span>] = base[i] = qr() ;</span><br><span class="line">build_ST(), ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">L = i, R = N ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (query_max(i, Mid) - query_min(i, Mid) &lt;= K) </span><br><span class="line">t = Mid, L = Mid + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">else</span> R = Mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">L = t ;</span><br><span class="line"><span class="keyword">if</span> (L - i + <span class="number">1</span> &gt; ans) ans = L - i + <span class="number">1</span>, Ans[cnt = <span class="number">1</span>][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (L - i + <span class="number">1</span> == ans) Ans[++ cnt][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i][<span class="number">0</span>], Ans[i][<span class="number">1</span>]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·7C"><a href="#rm-CF·7C" class="headerlink" title="$\rm CF·7C$"></a>$\rm CF·7C$</h1><blockquote><p>给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。</p></blockquote><p>sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq</p><h1 id="rm-CF·7D"><a href="#rm-CF·7D" class="headerlink" title="$\rm CF·7D$"></a>$\rm CF·7D$</h1><blockquote><p>一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，<code>abaaba</code>是3阶字符串。</p><p>现在给定你一字符串，请你求出其所有前缀的的阶级之和。</p><p>$|\sf S|\leq 5,000,000$</p></blockquote><p>似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么<br>$$<br>f_i=[\quad H[1…\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1…i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)<br>$$</p><p>答案就是$\sum f_i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">131</span> ;<span class="keyword">bool</span> mark[MAXN] ;</span><br><span class="line"><span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> N, Ans, i, j, h, ans[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1[MAXN], base2[MAXN], times[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">times[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base1[i] = (base1[i - <span class="number">1</span>] * base + S[i]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">base2[i] = (base2[i - <span class="number">1</span>] * base + S[N - i + <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) times[i] = times[i - <span class="number">1</span>] * base % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), </span><br><span class="line">N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), init() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">h = i / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t1 = base1[h] % Mod ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ;</span><br><span class="line">ans[i] = (t1 == t2) * (ans[h] + <span class="number">1</span>),  Ans += ans[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·8C"><a href="#rm-CF·8C" class="headerlink" title="$\rm CF·8C$"></a>$\rm CF·8C$</h1><blockquote><p>平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。</p></blockquote><p>我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN], Pre[MAXN], Max ;</span><br><span class="line"><span class="keyword">int</span> N, D[<span class="number">50</span>][<span class="number">50</span>], i, j, k, bit[<span class="number">50</span>], tp ; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Obj[<span class="number">50</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Obj[<span class="number">0</span>].fr &gt;&gt; Obj[<span class="number">0</span>].sc &gt;&gt; N ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; ++ j)</span><br><span class="line">D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) </span><br><span class="line">      + (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ;</span><br><span class="line">Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i) dp[i] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit)), tp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) bit[++ tp] = j + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= tp ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tp ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j != k)&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]], </span><br><span class="line">          Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>])</span><br><span class="line">dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>], </span><br><span class="line">        Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &lt; <span class="number">1061109567</span>) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[Max] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">while</span> (Max)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">int</span> qaq = Max ^ Pre[Max] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; qaq) <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">Max = Pre[Max] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·9D"><a href="#rm-CF·9D" class="headerlink" title="$\rm CF·9D$"></a>$\rm CF·9D$</h1><blockquote><p>用$n$个点组成二叉树，问高度大于等于$h$的有多少个。</p><p>$n\leq 35$</p></blockquote><p>没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; H ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; j ; ++ k)</span><br><span class="line">dp[j][i] += dp[k][i - <span class="number">1</span>] * dp[j - k - <span class="number">1</span>][i - <span class="number">1</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[N][N] - dp[N][D - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10C"><a href="#rm-CF·10C" class="headerlink" title="$\rm CF·10C$"></a>$\rm CF·10C$</h1><blockquote><p>定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$</p><p>现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。</p><p>$N\leq 1000000$</p></blockquote><p>考虑$d()$的本质：<br>$$<br>d(x)=\left{\begin{array}{ll}{x \bmod 9,} &amp; {x \bmod 9 \neq 0} \ {9,} &amp; {x \bmod 9=0}\end{array}\right.<br>$$<br>那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。</p><p>那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, base[<span class="number">20</span>], A, B, i, j ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i % <span class="number">9</span>] ++, B += N / i ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">A += base[i] * base[j] * base[i * j % <span class="number">9</span>] ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A - B &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·10D"><a href="#rm-CF·10D" class="headerlink" title="$\rm CF·10D$"></a>$\rm CF·10D$</h1><blockquote><p>求两个串的最长公共上升子序列。</p><ul><li><p>$n\leq 500$</p></li><li><p>$n\leq 5,000$</p></li></ul></blockquote><p>第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">if</span> (base1[i] != base2[j]) <span class="keyword">continue</span> ;</span><br><span class="line">dp[i][j] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt; j ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][k] + <span class="number">1</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, f[j] = k ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。</p><p>于是最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">dfs(pre[x]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, n = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (N = qr(), i = <span class="number">1</span> ; i &lt;= N ; ++ i) A[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (M = qr(), i = <span class="number">1</span> ; i &lt;= M ; ++ i) B[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, befo = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] != B[j]) f[i][j] = f[i - <span class="number">1</span>][j] ;</span><br><span class="line"><span class="keyword">else</span> f[i][j] = res + <span class="number">1</span>, pre[j] = befo ;</span><br><span class="line"><span class="keyword">if</span> (B[j] &lt; A[i]) </span><br><span class="line"><span class="keyword">if</span> (res &lt; f[i - <span class="number">1</span>][j]) </span><br><span class="line">res = f[i - <span class="number">1</span>][j], befo = j ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (ans &lt; f[N][i]) ans = f[N][i], n = i ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; dfs(n) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11C"><a href="#rm-CF·11C" class="headerlink" title="$\rm CF·11C$"></a>$\rm CF·11C$</h1><blockquote><p>你有一个$01$矩阵。里面有多少个正方形？</p><p>其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣：</p><p>第一种：每条边与矩阵的边平行的正方形；</p><p>第二种：每条边与矩阵的对角线平行的正方形。</p><p>$t\leq 10,000\quad 2\leq n,m\leq 250$</p></blockquote><p>然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base[x][y] != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    base[x][y] = <span class="number">-1</span>, ++ step ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &gt;= <span class="number">1</span> &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= <span class="number">1</span> &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + step &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + i][y] != <span class="number">-1</span>) | (base[x][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + step][y + i] != <span class="number">-1</span>) | (base[x + i][y + step] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = step &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x + lx &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (base[x + lx][y] != <span class="number">-1</span> || y &lt; step) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + lx - i][y - i] != <span class="number">-1</span>) | (base[x + lx - i][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + i][y - i] != <span class="number">-1</span>) | (base[x + i][y + i] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][j] != <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                res = <span class="number">0</span>, dfs(i, j, res) ;</span><br><span class="line">                <span class="keyword">if</span> (res % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; res / <span class="number">4</span> &lt;= min(N, M))</span><br><span class="line">                    ans += chk1(res / <span class="number">4</span>, i, j) + chk2(res / <span class="number">4</span>, i, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-CF·11D"><a href="#rm-CF·11D" class="headerlink" title="$\rm CF·11D$"></a>$\rm CF·11D$</h1><blockquote><p>求简单无向图的环数。</p><p>$n\leq 19$</p></blockquote><p>一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。</p><p>观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从<code>lowbit</code>转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M, Mx = (1 &lt;&lt; N) - 1 ;</span><br><span class="line">for (i = 1, j = 0 ; j &lt; N ; ++ j, i &lt;&lt;= 1) f[i][j] = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] = A[v][u] = 1 ;</span><br><span class="line">for (s = 1 ; s &lt;= Mx ; ++ s)&#123;</span><br><span class="line">    for (i = 0 ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ;</span><br><span class="line">        for (j = 0 ; j &lt; N ; ++ j)&#123;</span><br><span class="line">            if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ;</span><br><span class="line">            if ((1 &lt;&lt; j) == low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans += f[s][i] ;</span><br><span class="line">            else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] += f[s][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codefoces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codefoces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="数学/扩展欧几里德" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="贪心" scheme="http://www.orchidany.cf/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="计算几何/基础的点、直线与圆" scheme="http://www.orchidany.cf/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%9F%BA%E7%A1%80%E7%9A%84%E7%82%B9%E3%80%81%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%9C%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-711 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-711/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-711/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:14.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个马来西亚老哥出的一场<code>Div2</code>，题目还算有点意思，于是就virtual了后三个题。</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。</p><p>$n,m\leq 100$</p></blockquote><p>一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= K ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= M ; ++ k)</span><br><span class="line">dp[i][j][k] = Inf ; </span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = i - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*/</span></span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">if (j &gt;= pos[i])&#123;</span></span><br><span class="line"><span class="comment">for (k = 1 ; k &lt;= M ; ++ k)</span></span><br><span class="line"><span class="comment">for (l = 1 ; l &lt;= M ; ++ l)</span></span><br><span class="line"><span class="comment">for (w = 1 ; w &lt;= K ; ++ w)</span></span><br><span class="line"><span class="comment">if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (base[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[<span class="number">1</span>][<span class="number">1</span>][i] = val[<span class="number">1</span>][i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (!base[i])&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)&#123;</span><br><span class="line">dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k] + val[i][k]);</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= M ; ++ l)</span><br><span class="line"><span class="keyword">if</span> (k != l) </span><br><span class="line">             dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][l] + val[i][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j][base[i]]) ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k )</span><br><span class="line"><span class="keyword">if</span> (k != base[i]) </span><br><span class="line">           dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Ans = Inf, i = <span class="number">1</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (Ans == Inf ? - <span class="number">1</span> : Ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 </p><p>每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环</p></blockquote><p>一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。</p><p>好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>, base = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep, vis[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), deep + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)] &lt;= <span class="number">1</span>) rop[++ tot] = dep[u] - dep[to(k)] + <span class="number">1</span> ;</span><br><span class="line"> &#125;</span><br><span class="line">vis[u] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, Ans = <span class="number">1</span> ; <span class="keyword">int</span> qaq ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qaq), Add(i, qaq) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> ( !dep[i] ) dfs(i, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) </span><br><span class="line">    cnt += rop[i], (Ans *= (expow(rop[i]) - <span class="number">2</span> + Mod)) %= Mod ;</span><br><span class="line">Ans = Ans * expow(N - cnt) % Mod ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。</p><p>$n,k\leq 10^{18},\rm Mod=1e6+3$</p></blockquote><p>首先考虑答案就是<br>$$<br>\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}<br>$$<br>然后就变成了如果把这个东西求出来<del>传统艺能.jpg</del></p><p>1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。</p><p>2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来</p><p>3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$.</p><p>4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到<br>$$<br>\begin{aligned}<br>(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&amp;=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\ &amp;=(\prod\limits_{i=1}^{k}i,2^n)\ &amp;=(k!,2^n)<br>\end{aligned}<br>$$</p><p>再结合抽屉原理，只需要枚举$2$的幂就可以算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; ll Son, Mom ;</span><br><span class="line">ll N, M, Inv, _gcd, qwq, i, base = <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= Mod ;</span><br><span class="line">(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">base &lt;&lt;= <span class="number">1</span> ; <span class="keyword">if</span> (base &gt;= M) &#123; ans = <span class="number">0</span> ; <span class="keyword">break</span> ;&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1 1"</span>), <span class="number">0</span> ;  Son = <span class="number">1</span> ;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M - <span class="number">1</span> ; i &lt;&lt;= <span class="number">1</span>) qwq += (M - <span class="number">1</span>) / i ;  </span><br><span class="line">_gcd = expow(<span class="number">2</span>, qwq), </span><br><span class="line">  Inv = expow(_gcd, Mod - <span class="number">2</span>) ; </span><br><span class="line">  Mom = expow(<span class="number">2</span>, N  % (Mod - <span class="number">1</span>) * (M - <span class="number">1</span>) % (Mod - <span class="number">1</span>)) ;</span><br><span class="line">  (Mom *= Inv) %= Mod ; </span><br><span class="line">  <span class="keyword">if</span> (M - <span class="number">1</span> &gt;= Mod) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, Mom, Mom), <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; M ; ++ i) </span><br><span class="line">    Son = Son * (expow(<span class="number">2</span>, N) - i + Mod) % Mod ; </span><br><span class="line">  (Son *= Inv) %= Mod, </span><br><span class="line">  Son = ((Mom - Son) % Mod + Mod) % Mod ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Son &lt;&lt; <span class="string">" "</span> &lt;&lt; Mom &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个马来西亚老哥出的一场&lt;code&gt;Div2&lt;/code&gt;，题目还算有点意思，于是就virtual了后三个题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>【题解】Codeforces Round-840 Virtual</title>
    <link href="http://www.orchidany.cf/2019/11/14/Codeforces-840/"/>
    <id>http://www.orchidany.cf/2019/11/14/Codeforces-840/</id>
    <published>2019-11-14T03:37:08.000Z</published>
    <updated>2019-12-15T06:23:07.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。</p><p>但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。</p><p>$n\leq 10^5$</p></blockquote><p>刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的……</p><p>然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）<br>$$<br>\begin{aligned}<br>F(n,k)&amp;=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\&amp;=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\&amp;=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\&amp;=\frac{n+1}{k+1}<br>\end{aligned}<br>$$<br>然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。</p><p>你需要选出一些边（不一定联通），使得这些边构成的图符合要求。</p><p>$n\leq 3\cdot 10^5$</p></blockquote><p>首先考虑如果没有<code>-1</code>并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。</p><p>发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。</p><p>然后分类讨论：<code>0</code>的点和<code>1</code>的点</p><ul><li><code>0</code>的点。直接忽略，因为不产生影响；</li><li><code>1</code>的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。</li></ul><p>于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span> ; <span class="keyword">int</span> ret = base[u] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (ST(to(k))) </span><br><span class="line">      res[++ tot] = (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ret ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (base[u] &lt; <span class="number">0</span>) ret = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), </span><br><span class="line">  (base[i] &lt; <span class="number">0</span>) ? mr1 = i : (mr2 ^= base[i]) ;</span><br><span class="line"><span class="keyword">if</span> (!mr1 &amp;&amp; mr2) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">ST(mr1 ? mr1 : <span class="number">1</span>) ;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  sort(res + <span class="number">1</span>, res + tot + <span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。</p></blockquote><p>考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$后，两个数相同时，其乘积才会为完全平方数。</p><p>那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。</p><p>那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$<br>$$<br>f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll d, ll z)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (z)&#123;</span><br><span class="line"><span class="keyword">if</span> (z &amp; <span class="number">1</span>) (res *= d) %= Mod ;</span><br><span class="line">( d *= d ) %= Mod, z &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N, dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i] ; <span class="keyword">bool</span> mk = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">ll p = trunc(<span class="built_in">sqrt</span>(base[i] * grp[j])) ;</span><br><span class="line"><span class="keyword">if</span> (p * p == base[i] * grp[j])&#123;++ tm[j], mk = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mk) grp[++ cnt] = base[i], tm[cnt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span> (Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (Frac[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; tot += tm[i], ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= tot ; ++ j) </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tm[i] ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --)</span><br><span class="line"><span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt; N) </span><br><span class="line">            (dp[i][t] += </span><br><span class="line">             Frac[tm[i]] * Cm[tm[i] - <span class="number">1</span>][k - <span class="number">1</span>] % Mod </span><br><span class="line">           * Cm[j][l] % Mod * Cm[tot - j + <span class="number">1</span>][k - l] % Mod </span><br><span class="line">           * dp[i - <span class="number">1</span>][j] % Mod) %= Mod ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[cnt][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>这个D曾经单独写过：<a href="http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/">Link</a></p><p>233反正就是乱搞就对了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/构造" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维题/计数" scheme="http://www.orchidany.cf/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E2</title>
    <link href="http://www.orchidany.cf/2019/11/14/xiaone-2/"/>
    <id>http://www.orchidany.cf/2019/11/14/xiaone-2/</id>
    <published>2019-11-14T01:59:40.000Z</published>
    <updated>2019-12-15T06:33:45.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛第二弹</p><a id="more"></a><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote><p>$𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 </p></blockquote><p>性质题，找不出来人似乎就没了233</p><p>考虑最优情况下肯定会是<strong>单调地跳</strong>，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。</p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote><p>小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。</p><p>小$c$开始了漫长的<code>debug</code>的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。</p><p>等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出<code>NO</code></p></blockquote><p>题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。</p><p>我也是贪心做的，不过是正着做的。没有限制时，如果上一个是<code>(</code>，那我这一个就安排成<code>)</code>就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是<code>()(</code>这样，第三个括号被强制为右括号，就顺便把前一个右括号改成<code>(</code>，即变为<code>(()</code>，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; M, i = <span class="number">1</span> ; i &lt;= M ; ++ i) ok[qr()] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (ok[i] &amp;&amp; !stk[base[i]].size())&#123;</span><br><span class="line">ans[i] = <span class="number">1</span> ; </span><br><span class="line">stk[base[i]].pb(mat[buc[base[i]]]) ;</span><br><span class="line">ans[i] = <span class="number">1</span>, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = <span class="number">0</span> ;</span><br><span class="line">mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> mat[i] = stk[base[i]].back(), ans[i] = <span class="number">1</span>, </span><br><span class="line"> mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (!ans[i]) <span class="built_in">stack</span>[++ t] = i ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">stack</span>[t --] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%d "</span>, ans[i] ? <span class="string">'-'</span> : <span class="string">'+'</span>, base[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote><p>给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个${a}$的子集来凑出$x$。同时，求最小$|{a}|$下凑出所有$x$的方案总数。</p></blockquote><p>第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。</p><p>第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ .</p><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote><p>已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。</p><p>JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。</p></blockquote><p><del>质疑题面在恰饭</del></p><p>一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。</p><p>然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。</p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote><p>给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。</p><p>$n,q\leq 100,000$</p></blockquote><p>一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。</p><p>考虑推式子<br>$$<br>\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\<br>x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\<br>y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}<br>$$<br>然后如果我们令$val_i=y\cdot A_i-x \cdot  B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去<code>uoj</code>群里问了一圈发现这个被<code>lxl</code>规约到了$n \sqrt n$的问题上面……</p><p>然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了<code>100ms~6500ms</code>这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。</p><p>然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? </span><br><span class="line">        blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇数块正着排，偶数块倒着排，就会快好多。</p><p>然后最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写了一下午QAQ</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[MAXN] ; <span class="keyword">int</span> l, r, buc[MAXM], val[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> blg[MAXN], T[MAXM &lt;&lt; <span class="number">2</span>], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, X, Y, M, S, U, base[MAXN], cnt[<span class="number">2</span>][MAXM], pre[MAXN][<span class="number">2</span>], res, res2 ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> T[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R, p, v) ;</span><br><span class="line">    T[rt] = max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">0</span>][val[p]]) cnt[<span class="number">0</span>][val[p]] = Nxt[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">1</span>][val[p]]) cnt[<span class="number">1</span>][val[p]] = Pre[p] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;<span class="comment">// cout &lt;&lt; T[1] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">0</span>][val[p]] = min(cnt[<span class="number">0</span>][val[p]], p) ;</span><br><span class="line">    cnt[<span class="number">1</span>][val[p]] = max(cnt[<span class="number">1</span>][val[p]], p) ;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        base[i] = s[i] - <span class="string">'A'</span>,</span><br><span class="line">        pre[i][base[i]] = pre[i - <span class="number">1</span>][base[i]] + <span class="number">1</span>,</span><br><span class="line">        pre[i][base[i] ^ <span class="number">1</span>] = pre[i - <span class="number">1</span>][base[i] ^ <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][<span class="number">0</span>] - X * pre[i][<span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">-1</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i &gt;= <span class="number">0</span> ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + <span class="number">1</span>, buc[val[i]] = i ;</span><br><span class="line">    M = qr() ; S = <span class="built_in">pow</span>(M, <span class="number">0.5832</span>) ; U = <span class="built_in">ceil</span>((<span class="keyword">double</span>)M / S) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">0</span>], <span class="number">63</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">1</span>], <span class="number">-1</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = (i - <span class="number">1</span>) * S + <span class="number">1</span> ; j &lt;= i * S ; ++ j) blg[j] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) q[i].l = qr() - <span class="number">1</span>, q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + M + <span class="number">1</span>, comp) ; l = <span class="number">0</span>, r = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) upd(++ r) ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) upd(-- l) ;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">        ans[q[i].id] = res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233</p><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote><p>你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。</p><p>算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。</p><p>你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了）</p><p>然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。</p><p>现在，你需要求出完成上述一系列动作走过的最短路程。</p><p>$n \leq 20$</p></blockquote><p>一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。</p><p>然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个<code>floyd</code>，然后每次的代价就是</p><p>$$<br>\mathsf{\min <em>{x\in S,y\in T}(f</em>{S,x}+dis_{x,y}+g_{T,y})+\min <em>{x\in S,y\in T}(g</em>{S,x}+dis_{x,y}+f_{T,y}})<br>$$</p><p>然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[MAXS][MAXN], pre[MAXS][<span class="number">2</span>], sz[MAXS], ans ;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, ans = Inf ;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span> (f)) ; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) dis[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= E ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; k &gt;&gt; o,</span><br><span class="line">        A[j][k] = A[k][j] = o,</span><br><span class="line">        dis[j][k] = dis[k][j] = o ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span> * (dis[<span class="number">0</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>])), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][now] = min(f[i][now], f[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ; g[<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)][N - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)) + <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> g[i][now] = min(g[i][now], g[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; g[M][1] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] != N / <span class="number">2</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> stA = i, stB = (~i &amp; M), res = Inf, fg = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stA)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stB) </span><br><span class="line">res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//        if (!fg) res = 0 ;</span></span><br><span class="line">stB ^= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>), stB |= <span class="number">1</span> ;</span><br><span class="line">stA ^= <span class="number">1</span>, stA |= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stB)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;</span><br><span class="line"><span class="comment">//if (!fg) ans *= 2 ;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校内模拟赛第二弹&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="校内模拟赛" scheme="http://www.orchidany.cf/categories/%E9%A2%98%E8%A7%A3/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
    
      <category term="动态规划-普通DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="数学/观察性质,结论与构造" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="数据结构/线段树" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态规划-状压DP" scheme="http://www.orchidany.cf/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="http://www.orchidany.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 1</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-1/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-17T01:32:32.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly <del>Direct</del> Counting~ on~ Tree}$，“优雅的树上暴力统计”。</p><a id="more"></a><h1 id="rm-0x01-前言-amp-技术分析"><a href="#rm-0x01-前言-amp-技术分析" class="headerlink" title="$\rm 0x01$ 前言$&amp;$技术分析"></a>$\rm 0x01$ 前言$&amp;$技术分析</h1><p>严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛：</p><blockquote><p>1、维护子树信息；</p><p>2、不能带修改操作。</p></blockquote><p>但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。</p><p>然后来看技术分析。</p><p>首先，假设我们有这样一个问题：</p><blockquote><p>给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。</p><p>$n,q\leq 5\cdot1e5$</p><p>一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。</p></blockquote><p>考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。</p><p>考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。</p><p>现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。</p><p>所以这样就解决了维护树上信息的问题，复杂度$n\log n$。</p><h1 id="0x02-入门题目选整"><a href="#0x02-入门题目选整" class="headerlink" title="$0x02$ 入门题目选整"></a>$0x02$ 入门题目选整</h1><p>感觉大部分<code>blog</code>找的题目都很不清真233</p><h2 id="rm-Task1-rm-Cf600E-Lomsat-gelral"><a href="#rm-Task1-rm-Cf600E-Lomsat-gelral" class="headerlink" title="$\rm Task1$ $\rm Cf600E$ Lomsat gelral"></a>$\rm Task1$ $\rm Cf600E$ Lomsat gelral</h2><p>一句话题意</p><blockquote><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 </p></blockquote><p>考虑套$\rm EDCT$的板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line"><span class="keyword">if</span> (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa, <span class="number">1</span>) ; ans[u] = res ; <span class="keyword">if</span> (son[u]) vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (!mk) calc(u, fa, <span class="number">-1</span>), res = <span class="number">0</span>, max_cnt = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最后的<code>calc</code>函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">buc[clr[u]] += mk ; </span><br><span class="line"><span class="keyword">if</span> (mk &gt; <span class="number">0</span> &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[clr[u]] &gt; max_cnt) </span><br><span class="line">    res = <span class="number">0</span>, max_cnt = <span class="number">1l</span>l * buc[clr[u]] ;</span><br><span class="line">res += <span class="number">1l</span>l * clr[u] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; </span><br><span class="line">calc(to(k), u, mk) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Task2-Cf570D-Tree-Requests"><a href="#rm-Task2-Cf570D-Tree-Requests" class="headerlink" title="$\rm Task2 ~Cf570D$ Tree Requests"></a>$\rm Task2 ~Cf570D$ Tree Requests</h2><p>一句话题意：</p><blockquote><p>给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. </p></blockquote><p>这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] ^= (<span class="number">1</span> &lt;&lt; base[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (x) ret += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(ret &lt;= <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">buc[dep[u]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(getl(buc[qs[u][k]])) ; </span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly &lt;del&gt;Direct&lt;/del&gt; Counting~ on~ Tree}$，“优雅的树上暴力统计”。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 2</title>
    <link href="http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/"/>
    <id>http://www.orchidany.cf/2019/11/13/dsu-on-tree-2/</id>
    <published>2019-11-13T13:39:18.000Z</published>
    <updated>2019-12-15T06:33:12.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要就是整理一下dsu on tree的进阶版习题。</p><a id="more"></a><h1 id="0x01-rm-Cf375D-Tree-and-Queries"><a href="#0x01-rm-Cf375D-Tree-and-Queries" class="headerlink" title="$0x01$ $\rm Cf375D$  Tree and Queries"></a>$0x01$ $\rm Cf375D$  Tree and Queries</h1><blockquote><p>给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 </p></blockquote><p>考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，<code>calc</code>到每个点的时候先<code>del</code>掉原来的再<code>upd</code>新的信息……然后就做完了233</p><p>然而一开始的时候我调了好久，因为我是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ts[base[u]] -- ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _count(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)&#123;</span><br><span class="line"><span class="keyword">bool</span> fg = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (!chk[base[u]]) </span><br><span class="line">chk[base[u]] = <span class="number">1</span>, </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, val), fg = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; </span><br><span class="line"><span class="keyword">if</span> (!fg) chk[base[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_do(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">_count(u, fa, <span class="number">-1</span>) ; do_del(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去很对的亚子，但是错就错在<strong>必须每个点独立计算完贡献才能考虑下一个点</strong>，否则下一个点的信息就是错误的——也就是说不能整体<code>del</code>再整体<code>upd</code>，必须逐个逐个的<code>del</code>和<code>upd</code>。。然而事实上关键问题还是在$buc$的统计上出了问题233</p><p>于是最后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] ++ ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">ts[base[u]] -- ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">calc(u, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">ans[u].pb(query(<span class="number">1</span>, <span class="number">1</span>, N, qs[u][k] + <span class="number">1</span>, N)) ;</span><br><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths"><a href="#0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths" class="headerlink" title="$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"></a>$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</h1><blockquote><p> 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 </p></blockquote><p>似乎是<code>Cf570D</code>的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的：</p><blockquote><p>我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数</p></blockquote><p>然后就是考虑怎么维护这个东西。</p><ul><li><p>不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$.</p></li><li><p>经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。</p></li></ul><p>看上去应该这么实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">f[dis[u]] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> &amp; ans, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans = max(ans, f[dis[u]] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans = max(ans, f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>), ans[u] = max(ans[u], ans[to(k)]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) </span><br><span class="line">dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span>, </span><br><span class="line">ans[u] = max(ans[u], ans[son[u]]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != fa) </span><br><span class="line">calc(to(k), u, ans[u], dep[u]), update(to(k), u) ;</span><br><span class="line"><span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u]] - dep[u]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">ans[u] = max(ans[u], f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] - dep[u]) ;</span><br><span class="line">f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。</p><p>唔，感觉这个题还是比较有技巧性的233</p><h1 id="0x03-rm-NOIP2018-模拟-·-树"><a href="#0x03-rm-NOIP2018-模拟-·-树" class="headerlink" title="$0x03$ $\rm NOIP2018$模拟 · 树"></a>$0x03$ $\rm NOIP2018$模拟 · 树</h1><p>这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：<a href="https://www.luogu.org/problem/U92408" target="_blank" rel="noopener">$\rm Link$</a></p><p>题面：</p><blockquote><p>给定一棵树。</p><p>令$[L,R]$描述的是序号在$[L,R]$内的点的集合。</p><p>同时，令函数$\boldsymbol F({ \rm S})$表示令集合$\rm S$内的点联通的需要的最小边数。</p><p>问题则是求：</p><p>$$<br>\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])<br>$$</p><p>$n\leq 100,000$</p></blockquote><hr><p>一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。</p><p>子树内的比较容易维护，考虑假设现在有了${1,2,3},{5,6}$两个集合，将其视作两个连通块，当加进来${4}$时，会和左右都相连接，不妨假设先与${1,2,3}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用<strong>并查集+并查集的$size$</strong>来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。</p><p>之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的<code>ans_out</code>显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，<code>set</code>里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了<br>$$<br>calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)<br>$$<br>原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。</p><p>所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], op[MAXN] ;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span> ; &#125;</span><br><span class="line"><span class="keyword">void</span> _clear()&#123;</span><br><span class="line">s.clear() ;</span><br><span class="line">ansout = calc(N), ansin = <span class="number">0</span>, </span><br><span class="line">s.insert(<span class="number">0</span>), s.insert(N + <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> x == fr[x] ? x : fr[x] = _find(fr[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">s.insert(u) ; op[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; :: iterator l, r, mid ;</span><br><span class="line">l = r = mid = s.find(u), l --, r ++ ;</span><br><span class="line">ansout += calc(*r - *mid - <span class="number">1</span>) + calc(*mid - *l - <span class="number">1</span>) - calc(*r - *l - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (op[u - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u - <span class="number">1</span>), f2 = _find(u) ; </span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (op[u + <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> f1 = _find(u + <span class="number">1</span>), f2 = _find(u) ;</span><br><span class="line">ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">fuck(u) ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> _update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">op[u] = <span class="number">0</span>, fr[u] = u, bg[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> _delete(to(k), u) ; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">_update(u, fa), ans += calc(N) - ansout - ansin ; </span><br><span class="line"><span class="keyword">if</span> (!mk) _delete(u, fa), _clear() ; vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Warning"><a href="#rm-Warning" class="headerlink" title="$\rm Warning$"></a>$\rm Warning$</h1><ul><li><p>注意一个地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br></pre></td></tr></table></figure><p>把这两句写反了会调一下午，欢迎尝试quq</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要就是整理一下dsu on tree的进阶版习题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="dsu on tree" scheme="http://www.orchidany.cf/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/dsu-on-tree/"/>
    
    
      <category term="树上技巧/dsu on tree" scheme="http://www.orchidany.cf/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dsu-on-tree/"/>
    
  </entry>
  
</feed>
