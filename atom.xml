<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-frWKXsVp" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-frWKXsVp"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-02-14T01:39:05.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ</p><p>如果可以的话，谢谢你喜欢我！</p><a id="more"></a><h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p><p>CSP-2019考的太菜，导致现在十分被动。</p><p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p><p>其实挺热爱算法的吧？</p><p>CF平时真的不是很常打，所以并不想给CF的ID。sorry啦。</p><p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p><p>QQ:2836531293</p><h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p><p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p><p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p><p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p><p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p><h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p><p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p><h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p><p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p><h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p><p>我一个人很无聊的说QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ&lt;/p&gt;
&lt;p&gt;如果可以的话，谢谢你喜欢我！&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】4 · 最大流模型进阶</title>
    <link href="https://www.orchidany.cn/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
    <id>https://www.orchidany.cn/2020/02/29/网络流24题·最大流模型进阶/</id>
    <published>2020-02-29T02:16:07.000Z</published>
    <updated>2020-03-01T23:17:27.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下稍微进阶一点的、可以用最大流解决的问题：</p><p><code>loj#6003 魔术球</code> 、 <code>loj#6005 最长递增子序列</code> 和 <code>loj#6015 星际转移</code>.</p><a id="more"></a><h1 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h1><blockquote><p>假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1, 2,3, . . .$ 的球。</p><p>(1) 每次只能在某根柱子的最上面放球。</p><p>(2) 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。</p><p>试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球.</p><p>$n\leq 55$</p></blockquote><p>考虑对于一组 $(i,j)$ ，如果 $i+j$ 是完全平方数，就由较小的那个向较大的那个连一条边。之后考虑本质上每根柱子上就是一个路径覆盖，所以持续加边，一直加到最小路径覆盖数 $&gt; $ 柱子数为止。</p><p>有一个很有意思的性质，就是网络流可以在线加边并且不用考虑之前的决策。</p><p>这题真nm是写到吐血。板子也改了一下如果不完全连通时的写法，需要特判每个点是否连通。这题神烦的是需要一遍一遍地清空，然后边的编号很容易就写错。</p><p>最后zay教育我只需要二分就可以了，这样每次就可以把全部的边都加进去，这样就可以瞎清空。我太dd了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[_s] = <span class="number">100000000</span> ; h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ;</span><br><span class="line">    <span class="keyword">if</span> (h[_s] &gt;= <span class="number">10000000</span>) <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ; <span class="keyword">else</span> h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span> &amp;&amp; h[to(k)] &lt;= n)</span><br><span class="line">            vis[to(k)] = <span class="number">1</span>, p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; p.pop() ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (h[x] == <span class="number">100000000</span>) <span class="keyword">break</span> ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x] &amp;&amp; minh&lt;=n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        h[i] = n + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ; <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[p] ; ~k ; k = e[k].next)</span><br><span class="line">        <span class="keyword">if</span> (!fw(k) &amp;&amp; to(k) != <span class="number">2</span> &amp;&amp; !(to(k) &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, (to(k) - <span class="number">2</span>) / <span class="number">2</span>), output(to(k) - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n = <span class="number">2</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>, h[<span class="number">2</span>] = <span class="number">0</span>, head[<span class="number">1</span>] = head[<span class="number">2</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">1</span> ; ; ++ res)&#123;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(<span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(n, <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span>, n, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; res ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sqrt</span>(res + j) == (<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(res + j)))</span><br><span class="line">                add(<span class="number">2</span> * j + <span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">2</span> * j + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            h[i] = <span class="number">100000000</span>, vis[i] = gap[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> ans = HLPP() ; <span class="keyword">if</span> (res - ans &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "--------------------" &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res -- ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; <span class="number">1</span> &amp;&amp; (fr(i) &amp; <span class="number">1</span>) &amp;&amp; !(to(i) &amp; <span class="number">1</span>)  &amp;&amp; to(i) != <span class="number">2</span> &amp;&amp; !fw(i))</span><br><span class="line">            fa[find((to(i) - <span class="number">2</span>) / <span class="number">2</span>)] = find(fa[(fr(i) - <span class="number">1</span>) / <span class="number">2</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), output(i * <span class="number">2</span> + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><blockquote><p>给定正整数序列 $x_1 \ldots, x_n$。</p><p>1、计算其最长不下降子序列的长度 $s$。</p><p>2、如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</p><p>3、如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个<strong>不同的</strong>长度为 $s$ 的不下降子序列。</p><p>$n\leq 500$</p></blockquote><p>考虑第一问可以直接拿来跑一个 $n^2$ 的 $dp$ 。对于第二问，考虑网络流。对于每个数，有限制只能用 $1$ 次，且必须要保证每个 LIS 长度都为 $s$ 。所以如果单纯地拿每个 $i$ 与起点和终点连边，对于一组 $i&lt;j$ 且 $a_i&lt;a_j$ 且 $f_j=f_{i}+1$ 的 $(i,j)$ ，中间连流量为 $1$ 的边。</p><p>这样建图就很有问题：</p><p>1、考虑这样建图，加谁一个点的入度为 $d_1$，出度为 $d_2$ ，那么实质上它会被使用 $\min\{d_1,d_2\}$ 次。为了防止这种情况出现，所以把一个点拆成两个点，一个点用来接收入度，一个点用来接收出度，$i\to i’$ 连流量为 $1$ 的边。</p><p>2、同时，由于并不能很容易地确定一条流经过多少条边，所以不是很容易得到长度为 $s$ 的 LIS。所以考虑换一种建图方式。即只让 $f_i=s$ 的每个 $i$ 与 $\rm T$ 连边。这样就保证走出来的只会是长度为 $s$ 的 LIS。</p><p>那么第三问，考虑再加上 $s\stackrel{f = +\infty}{\longrightarrow}1,1\stackrel{f = +\infty}{\longrightarrow}1’$ 这种边。如果 $f_n=s$ 的话也类似处理即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    _s = <span class="number">2</span> * n + <span class="number">1</span>, <span class="keyword">_t</span> = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], f[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[j] &lt;= base[i])</span><br><span class="line">                f[i] = max(f[i], f[j] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) res = max(res, f[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(i, i + n, <span class="number">1</span>), add(i + n, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == <span class="number">1</span>) add(<span class="number">2</span> * n + <span class="number">1</span>, i, <span class="number">1</span>), add(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == res) add(i + n, <span class="number">2</span> * n + <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span> * n + <span class="number">2</span>, i + n, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i] &lt;= base[j] &amp;&amp; f[i] + <span class="number">1</span> == f[j])</span><br><span class="line">                add(i + n, j, <span class="number">1</span>), add(j, i + n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">if</span> (f[t] == res)&#123;</span><br><span class="line">        add(t, <span class="keyword">_t</span>, <span class="number">100000000</span>), add(<span class="keyword">_t</span>, t, <span class="number">0</span>) ;</span><br><span class="line">        add(t, t + t, <span class="number">100000000</span>), add(t + t, t, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(_s, <span class="number">1</span>, <span class="number">100000000</span>), add(<span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, t + <span class="number">1</span>, <span class="number">100000000</span>), add(t + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="星际转移"><a href="#星际转移" class="headerlink" title="星际转移"></a>星际转移</h1><blockquote><p>现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船 $i$ 只可容纳 $p_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如：$\{1,3,4\}$ 表示该太空船将周期性地停靠太空站 134134134 …</p><p>每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站（或月球、地球）时上、下船。</p><p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p><p>$n,m\leq 50$ 。</p></blockquote><p>很神奇的分层图建图。考虑本身似乎是路径规划问题，但是具有以下性质：1、边的限制跟网络流图的限制几乎相同；2、每条边的代价都是 $1$  ; 3、数据范围 $n,m\leq 50$ ，可以知道如果有解，最多就是在 $0\to -1$ 路径上的每个点都停一遍，考虑每次停最多停 $n$ 个市场，那么最终答案的上界就是 $O(n^2)$ 。</p><p>根据以上性质，可以发现似乎枚举答案复杂度不高，可以转化为判定性问题。而网络流恰好可以解决判定性问题。所以考虑现在要做的就是如何建一个流图，使得跑出来的最大流就是当前能够运输的最多的人数。</p><p>发现决策对时间负责，那么每个时间，一个点可以走出去或者原地傻愣。根据状态最原始的表示方式，可知如果将每个时刻的每个点都单列一个状态，恰好可以转移。</p><p>所以建一个超级 $\rm S$ 连向每个 $t$ 的 $0$ ，建一个超级 $\rm T $ 让每个 $t$ 的 $-1$ 连向它，剩下的就按照转移来建就好了。</p><p>最后写了个 dinic…还是dinic好…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> cur[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        dis[i] = <span class="number">0</span>, cur[i] = head[i] ; dis[<span class="keyword">_t</span>] = <span class="number">0</span> ;</span><br><span class="line">    dis[_s] = <span class="number">1</span> ; q.push(_s) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (!dis[to(k)] &amp;&amp; fw(k) &gt; <span class="number">0</span>)</span><br><span class="line">                dis[to(k)] = dis[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, minf ;</span><br><span class="line">    <span class="keyword">if</span> (x == aim || !f) <span class="keyword">return</span> f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;k = cur[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[to(k)] != dis[x] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (( minf = dfs(to(k), aim, min(f, fw(k))) ) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ret += minf, fw(k) -= minf, fw(k ^ <span class="number">1</span>) += minf ;</span><br><span class="line">            f -= minf ; <span class="keyword">if</span> (f &lt;= <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> rn[N] ;</span><br><span class="line"><span class="keyword">int</span> ctn[N] ;</span><br><span class="line"><span class="keyword">int</span> ways[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    _s = <span class="number">0</span> ; <span class="keyword">_t</span> = <span class="number">50000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm &gt;&gt; s ; n = nn + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rn[i] &gt;&gt; ctn[i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; ctn[i] ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ways[i][j] ; ways[i][j] += <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) fa[find(ways[i][j])] = find(ways[i][j - <span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">2</span>) != find(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; <span class="keyword">else</span> nn += <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">0</span> ; ; ++ res)&#123;</span><br><span class="line">        add(<span class="keyword">_t</span>, res * nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">2</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">1</span>, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        add(_s, res * nn + <span class="number">2</span>, <span class="number">100000000</span>) ;</span><br><span class="line"><span class="keyword">if</span> (res)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">            add(res * nn + i, (res - <span class="number">1</span>) * nn + i, <span class="number">0</span>) ;</span><br><span class="line">            add((res - <span class="number">1</span>) * nn + i, res * nn + i, <span class="number">100000000</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = ctn[i] ;</span><br><span class="line">            <span class="keyword">int</span> x = ways[i][res % r] ;</span><br><span class="line">            <span class="keyword">int</span> y = ways[i][(res - <span class="number">1</span>) % r] ;</span><br><span class="line">            x += nn * res, y += nn * (res - <span class="number">1</span>) ;</span><br><span class="line">            add(y, x, rn[i]), add(x, y, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        n = <span class="number">1</span> + (res + <span class="number">1</span>) * nn ;</span><br><span class="line"><span class="keyword">while</span> (bfs()) ans += dfs(_s, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= s) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括以下稍微进阶一点的、可以用最大流解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loj#6003 魔术球&lt;/code&gt; 、 &lt;code&gt;loj#6005 最长递增子序列&lt;/code&gt; 和 &lt;code&gt;loj#6015 星际转移&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】3 · 最小割模型</title>
    <link href="https://www.orchidany.cn/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.orchidany.cn/2020/02/29/网络流24题·最小割模型/</id>
    <published>2020-02-29T01:39:39.000Z</published>
    <updated>2020-03-01T10:53:32.767Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是比较神奇的最小割模型。</p><p>涉及的题目有 <code>loj#6007 方格取数</code> 、 <code>loj#6001 太空飞行计划</code> 和 <code>loj#6226 骑士共存问题</code>。 </p><a id="more"></a><h1 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h1><blockquote><p>有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</p></blockquote><p>考虑对于方格中，取格子要求“没有公共边”，那么需要想到就是在进行一个黑白染色，不能选与之四连通的格子。所以最后本质上就是一个二分图，不能选有边相连的点，也就是对于每一条边 $\rm e$， 两个端点至多选一个。</p><p>然后就是很神奇的建图方式。考虑为了模拟出这个过程，建一个 $\rm S$ 连向所有黑点，流量即为点权；建一个 $\rm T$ 让所有白点连向它，流量同样是点权。中间根据连通性来连流量为 $+\infty$ 的边。这样建模之后，考虑最小割的本质含义。对于一条边 $(u,v)$ ，$\mathrm S\to u$ 和 $v\to\rm T$ 必定有一个需要被割，满足「两个端点至多选一个」的限制。那么如果用最小割的话，就可以将挑出来的边作为删去的点从总权中减去即为答案。</p><p>那么大概最小割的建模技巧，就是考虑用连通性这个东西来操作。比如什么「A和B至多选一个使得最终权值最大/小」，就可以用类似的技巧来建模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; tot = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[++ tot]), Ans += base[tot],</span><br><span class="line">            (i + j &amp; <span class="number">1</span>) ? white[++ w] = tot : black[++ b] = tot, <span class="built_in">map</span>[i][j] = tot ;</span><br><span class="line">    S = <span class="number">1</span>, T = tot + <span class="number">1</span> ; <span class="comment">/*cout &lt;&lt; tot &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) Add(S, white[i], base[white[i]])  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">ceil</span>((<span class="keyword">double</span>)(white[i] - <span class="number">1</span>) / M) ;</span><br><span class="line">        <span class="keyword">int</span> y = (white[i] - <span class="number">1</span>) - (x - <span class="number">1</span>) * M ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = x + dx[j], ky = y + dy[j] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= <span class="number">0</span> || ky &lt;= <span class="number">0</span> || ky &gt; M || kx &gt; N) <span class="keyword">continue</span> ;</span><br><span class="line">            Add(white[i], <span class="built_in">map</span>[kx][ky], INF) ;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= b ; ++ i) </span><br><span class="line">      Add(black[i], T, base[black[i]]) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans - HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="太空飞行计划"><a href="#太空飞行计划" class="headerlink" title="太空飞行计划"></a>太空飞行计划</h1><blockquote><p>现已确定了一个可供选择的实验集合 $E = \{ E_1, E_2, \cdots, E_m \}$，和进行这些实验需要使用的全部仪器的集合$ I = \{ I_1, I_2, \cdots, I_n \}$。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \subseteq I$。</p><p>配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。</p><p>对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。</p></blockquote><p>这个题的模型似乎是什么「最大权闭合子图」，大概就是如果选了某个点 $v$ ，那么 $v$ 指向的所有点都必须要选，最大化点权和。</p><p>考虑以这么一种方式建图。$\rm S$ 连向所有正权点，流量为该点的点权；所有负权点连向 $\rm T$ ，流量为该点的绝对值；原本图中的点按照原来的方式连上去，流量为 。跑一个最小割，然后正权点和-最小割就是最终的答案。</p><p>考虑这么做的正确性。对于最小割而言，既然是割，那么要么会去割一个正权点，代表正权点连接点集都不选；或者选择割掉与之相连的所有负权点，代表选了这个点集。那么这样两种决策的本质上都是在倒扣代价。所以是成立的。</p><p>这题还要憨憨地输出方案。这个地方有个神奇的输出方式，就是判断每个点是否与 $\rm S$ 相连，如果一个点指向的某个点不与 $\rm S$ 连通，那么他就它俩之间的边就是一条割边。</p><p>首先不难知道，这些边都是满流的。考虑之所以这些满流的边就是被割的边，原因是他们恰好是 $\rm S$ 到 $\rm T$ 每条路径的瓶颈边，所以他们的流量加起来就是最大流(因为即使有更多也不能流了)，那么也就是最小割。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> newline ;</span><br><span class="line"><span class="keyword">int</span> E[M * <span class="number">2</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="number">48</span> , ch = getchar() ;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\n'</span>) newline = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">100000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">        x = read() ;</span><br><span class="line">        sum += x ; newline = <span class="number">0</span> ;</span><br><span class="line">        add(_s, i, x) ; add(i, _s, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (!newline)&#123;</span><br><span class="line">            y = read() ;</span><br><span class="line">            add(y + nn, i, <span class="number">0</span>) ;</span><br><span class="line">            add(i, y + nn, <span class="number">100000000</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y, add(i + nn, <span class="keyword">_t</span>, y), add(<span class="keyword">_t</span>, i + nn, <span class="number">0</span>) ;</span><br><span class="line">    n = nn + mm ; res = sum - dinic() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i) ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nn + <span class="number">1</span> ; i &lt;= mm + nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - nn) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="骑士共存"><a href="#骑士共存" class="headerlink" title="骑士共存"></a>骑士共存</h1><blockquote><p>给定 $n^2$ 个方格的国际象棋棋盘和障碍标志，有障碍的不能放，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。</p><p>$n\leq 200$ </p></blockquote><p>大概这种题一开始被我当作一般图最大独立集做了…然后不会…</p><p>感觉在网格图搞事情，还是需要有种观察性质的直觉的。比如就会发现，骑士跳的每两步，都不会是同一个颜色。那么这就会转化成一个二分图问题，同种颜色之间没有边相连，有两种颜色，符合二分图的限制。所以最后只需要求一发二分图最大独立集即可。</p><p>考虑把原二分图转为流图，中间的边流量为 inf ，其余为 1 。这个网络的最小割满足，对于中间每一条边，两端的点必定选择了一个，否则 S 与 T 仍连通。故最小割对应最小点覆盖。而最小点覆盖与最大独立集互为对偶问题，所以算一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> x, y, kx, ky ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">60001</span>, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, mark[x][y] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span> ; x &lt;= n ; ++ x)</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">1</span> ; y &lt;= n ; ++ y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[x][y]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> ((x + y) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">7</span> ; ++ k)&#123;</span><br><span class="line">                    kx = x + dx[k] ;</span><br><span class="line">                    ky = y + dy[k] ;</span><br><span class="line">                    <span class="keyword">if</span> (mark[kx][ky]) <span class="keyword">continue</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || ky &gt; n || kx &gt; n) <span class="keyword">continue</span> ;</span><br><span class="line">                    add(kx * (n + <span class="number">1</span>) + ky, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                    add(x * (n + <span class="number">1</span>) + y, kx * (n + <span class="number">1</span>) + ky, <span class="number">100000000</span>) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, _s, <span class="number">0</span>) ;</span><br><span class="line">                add(_s, x * (n + <span class="number">1</span>) + y, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(<span class="keyword">_t</span>, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, <span class="keyword">_t</span>, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = (n + <span class="number">1</span>) * (n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t * t - m - dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方大概需要注意，两个点之间不要连双向的边。这样最小割就会错，因为最大流的意义不对了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是比较神奇的最小割模型。&lt;/p&gt;
&lt;p&gt;涉及的题目有 &lt;code&gt;loj#6007 方格取数&lt;/code&gt; 、 &lt;code&gt;loj#6001 太空飞行计划&lt;/code&gt; 和 &lt;code&gt;loj#6226 骑士共存问题&lt;/code&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="网络流/最小割" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题专题】2 · 较简单的最大流</title>
    <link href="https://www.orchidany.cn/2020/02/28/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%982%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <id>https://www.orchidany.cn/2020/02/28/网络流24题2·简单的最大流问题/</id>
    <published>2020-02-28T03:29:15.000Z</published>
    <updated>2020-03-01T00:07:47.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下较为简单的可以用最大流解决的问题：</p><p><code>loj#6000 搭配飞行员</code>、<code>loj#6006 试题库</code>、 <code>loj#6004 圆桌聚餐</code> 和 <code>loj#6002 最小路径覆盖</code> 。</p><a id="more"></a><h1 id="搭配飞行员"><a href="#搭配飞行员" class="headerlink" title="搭配飞行员"></a>搭配飞行员</h1><blockquote><p>飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员，需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。</p><p>因为驾驶工作分工严格，两个正驾驶员或两个副驾驶员都不能同机飞行。</p></blockquote><p>这显而易见的就是一个二分图匹配的问题。考虑 $\rm S$ 向左部每个点连 $f=1$ 的边，右部的向 $\rm T$ 连 $f=1$ 的边。考虑一组匹配会贡献 $1$ 的流量，且每个点只有 $1$ 的原始流保证了只可使用一次，所以不难证明是但俺就是最大流。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;  </span><br><span class="line">fill(head, head + N + <span class="number">30</span>, <span class="number">-1</span>); S = <span class="number">0</span>, T = N + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B)  add(A, B, <span class="number">23333</span>), add(B, A, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M ; i ++) add(S, i, <span class="number">1</span>), add(i, S, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = M + <span class="number">1</span>; i &lt;= N ; i ++) add(i, T, <span class="number">1</span>), add(T, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题库"><a href="#试题库" class="headerlink" title="试题库"></a>试题库</h1><blockquote><p>假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。</p></blockquote><p>很水的建模，$\rm S$ 向每个题连 $f=1$ 的边表示只能用一次，每个题向对应的类型连边，每个类型向 $\rm T$ 连 $f=need_x$ 的边。然后输出方案就只需要看一下每个类型连的边有谁 $f$ 被流成 $0$ 了即可。</p><p>很久之前的 Dinic 代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N, T = N + K + <span class="number">1</span> ;</span><br><span class="line">cnt = <span class="number">-1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>) ; L1 = cnt + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + K ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), w1 += x, Add(i, T, x) ; </span><br><span class="line">R1 = cnt ; L2 = R1 + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x) ; </span><br><span class="line"><span class="keyword">while</span> (x --) <span class="built_in">cin</span> &gt;&gt; y, Add(i, N + y, <span class="number">1</span>) ; </span><br><span class="line">&#125; R2 = cnt ;</span><br><span class="line"><span class="keyword">while</span>(BFS())&#123; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ;</span><br><span class="line">w += dfs(S, T, Inf) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (w != w1) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>), <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = L2 ; i &lt; R2 ; i += <span class="number">2</span>) </span><br><span class="line">    <span class="keyword">if</span> (!E[i].f) Ans[to(i) - N].push_back(E[i].fr) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i, <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>) </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>, j = <span class="number">0</span> ; j &lt; Ans[i].size() ; ++ j) <span class="built_in">cout</span> &lt;&lt; Ans[i][j] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="圆桌聚餐"><a href="#圆桌聚餐" class="headerlink" title="圆桌聚餐"></a>圆桌聚餐</h1><blockquote><p>假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。</p><p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。</p></blockquote><p>发现是一个特殊的匹配问题，考虑从 $\rm S$ 到每个单位连 $f=r_i$ 的边，每个桌子向 $\rm T$ 连一条 $f=c_i$ 的边，同时每个单位和每张桌子之间连 $f=1$ 的边。这样就可以控制每个单位至多一个在某个餐桌。同样，如果限制同一张餐桌不能做超过 $k$ 个同一单位的人，只需要把 $f$ 从 $1$ 改成 $k$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> A[M][M] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ; fw(cnt) = c ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">    <span class="keyword">return</span> cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ; h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span>) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">            p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; h[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; vis[x] = <span class="number">0</span> ; p.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        gap[h[i]] --, h[i] = n + <span class="number">1</span>, gap[h[i]] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        head[i] = <span class="number">-1</span>, h[i] = <span class="number">1000000000</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    n = nn + mm + <span class="number">2</span> ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n ; Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, res += w,</span><br><span class="line">        add(_s, i + <span class="number">1</span>, w), add(i + <span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, add(i + nn + <span class="number">1</span>, <span class="keyword">_t</span>, w), add(<span class="keyword">_t</span>, i + nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">            A[i][j] = add(i + <span class="number">1</span>, j + nn + <span class="number">1</span>, <span class="number">1</span>), add(j + nn + <span class="number">1</span>, i + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (HLPP() &lt; res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (fw(A[i][j]) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小路径覆盖问题"><a href="#最小路径覆盖问题" class="headerlink" title="最小路径覆盖问题"></a>最小路径覆盖问题</h1><blockquote><p>给定有向图 $\rm G=\{V,E\}$。设 $\rm P$ 是 $\rm G$ 的一个简单路（顶点不相交）的集合。如果 $\rm V$ 中每个顶点恰好在 $\rm P$ 的一条路上，则称 $\rm P$ 是 $\rm G$ 的一个路径覆盖。 $\rm P$ 中路径可以从 $\rm V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 $0$。 的最小路径覆盖是 $\rm G$ 的所含路径条数最少的路径覆盖。</p></blockquote><p>嗯，这道题大概是教了一下怎么拆点。考虑对于每个点 $v$，新建一个替身点 $v’$ 。原图中的路径 $(u,v)$ 变换为 $(u,v’)$ ，然后 $\rm S$ 向所有 $v$ 连边，所有 $v’$ 向 $\rm T$ 连边。思考这么做本质上是在求一个匹配，最后没有匹配的到左部的一个有部点可以看做是一条路径的结尾。那么考虑这样跑完一组匹配之后，所有没有匹配上的点都是一条路径的结尾，也就是路径的数量。所以跑一个最大流，就可以得到最少的路径数量，也就是最小路径匹配。</p><p>这代码还是上古时期拿 dinic 写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, S = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    Add(S, i, <span class="number">1</span>), Add(i + N, T, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B + N, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (BFS()) &#123; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ; </span><br><span class="line">    Ans += dfs(S, T, Inf) ; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = i ; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (fr(i) &gt;= <span class="number">1</span> &amp;&amp; fr(i) &lt;= N &amp;&amp; to(i) &lt; T &amp;&amp; to(i) &gt; N &amp;&amp; !E[i].f) </span><br><span class="line">fa[find(to(i) - N)] = find(fa[fr(i)]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) begin_output(i), <span class="built_in">puts</span>(<span class="string">""</span>) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; N - Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么不难看出建虚点这个操作的目的，就是限制每个点的经过次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括以下较为简单的可以用最大流解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loj#6000 搭配飞行员&lt;/code&gt;、&lt;code&gt;loj#6006 试题库&lt;/code&gt;、 &lt;code&gt;loj#6004 圆桌聚餐&lt;/code&gt; 和 &lt;code&gt;loj#6002 最小路径覆盖&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="网络流/最大流" scheme="https://www.orchidany.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[ARC066]C/D/E Sol</title>
    <link href="https://www.orchidany.cn/2020/02/26/ARC066C-E/"/>
    <id>https://www.orchidany.cn/2020/02/26/ARC066C-E/</id>
    <published>2020-02-26T08:52:52.000Z</published>
    <updated>2020-03-01T23:18:50.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是正好做到了这一场的F，就顺便把前三个题给做了。</p><p>嗯，感觉思维能力还是很重要的。所以不能再这么沉沦了啊。</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>有编号为 $1\sim N$ 号的 $N$ 个人，给你第 $i$ 个人的「自己的左排列的人数和自己的右排列的人数的差的绝对值」$A_i$。 请根据他们的报告，求出原来的排列方法有几种。对 $10^9+7$ 取模 。</p><p>$A_i\leq 10^9,N\leq 10^5$</p></blockquote><p>或许可以根据样例猜出来，大概是一点性质吧，比如什么数值必须对称分布。那么想到这一点，再深入想一下就可以发现对于每个 $n$ 而言，他们的 $A_i$ 是固定的。所以直接生成这个标准答案序列，然后把给出的 $A$ 排一遍序，比较是否相同即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        yes[<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = <span class="number">2</span> * (++ cnt) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        yes[<span class="number">1</span>] = yes[<span class="number">2</span>] = ++ cnt ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = (cnt += <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, expow(<span class="number">2</span>, n / <span class="number">2</span>)), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote><p>求出整数对 $u$ 和 $v$ $(0≤u,v≤N)$ 的数目，使得存在两个非负整数 $a$ 和 $b$ 满足 $a xor b = u$ 和 $a + b= v$.</p><p>要求对答案取模 $10^9 + 7$ 。$N\leq 10^{18}$。</p></blockquote><p>这个题好像有一堆十分有趣的做法…但是碍于智商并不是很想去学qaq，就放个链接吧 <a href="https://qiita.com/259_Momone/items/86e90d17e4efe3b22433" target="_blank" rel="noopener">戳</a> 。</p><p>然后自己就对着一个神奇的做法编了一下原理。<del>发现自己果然是马后炮选手</del> 。</p><p>考虑 </p><script type="math/tex; mode=display">a+b=((a~\mathrm{and}~b)<<1)+(a~\mathrm{xor}~b)</script><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到 $a+b\geq  a~\mathrm{xor}~b$ 这样的结论。</p><p>那么如果由于 $u\leq v$，所以如果 $v$ 不越界那么 $u$ 一定不越界。于是考虑按 $v$ 进行 $dp$。具体的，考虑状态 $f_{i,j}$ 表示考虑了 $a$ 和 $b$ 二进制下的前 $i$ 位，当前 $v=a+b=j$ 的方案数。</p><p>考虑如何转移。对于 $a$ 和 $b$ 而言，第 $i$ 位有三种情况，$(0,0),(0,1),(1,1)$ 。那么也就是假设原来的和为 $j’$，和当前的和 $j$ 可能有以下关系：</p><p>1、$2\cdot (j’+1)=j$，对应着都补一位 $1$。</p><p>2、$2\cdot j’=j$，对应着都补一位 $0$ 。</p><p>3、$j’+ (j’ + 1)=j$，对应着一个补 $1$ 一个补 $0$ 。</p><p>那么也就是</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,\lfloor\frac{j}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-2)}{2}\rfloor}</script><p>发现本质上，第一维状态随着第二维递减，且都是 $\Delta(\log)$ 级别，并且每次计算，必定存在三项中有两项是相等的，所以可知最后状态数一定介于 $\Omega(2\log N)\sim O(\log N)$ 之间，可以通过本题。</p><p>然后第一维就可以直接压掉了。</p><p>不过话说回来，关于这个状态数，我还是不知道该怎么算，最终还是打表打出来的这么一个界，大概是在 $2^k-1$ 时达到下界，$2^k$ 时达到上界。想了想这么分布似乎很合理，但是还是不知道为啥。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(<span class="keyword">int</span> p, LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.count(x)) <span class="keyword">return</span> m[x] ; <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> m[x] = <span class="number">1</span> ; <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> m[x] = <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">return</span> m[x] = ((f(p - <span class="number">1</span>, x / <span class="number">2</span>) + f(p - <span class="number">1</span>, (x - <span class="number">1</span>) / <span class="number">2</span>)) % P + f(p - <span class="number">1</span>, (x - <span class="number">2</span>) / <span class="number">2</span>)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(log2(n) + <span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote><p>给你一个只包含 $’+’$ 、$’-‘$、正整数的式子，你需要在式子中添加一些括号，使运算结果最大，输出最大的结果。</p><p>$n\leq 10^5,a_i\leq 10^9$ 。 </p></blockquote><p>大概是个观察性质题。首先可以知道，加号后面不会右括号，或者说可以被忽略掉；其次，最多有两层括号嵌套，多了没有意义，因为比如 $-((a-b)-(a-(a-b)-b))$ 这个就可以写成 $-((a-b)-(a-a)-(b-b))$ 的形式。</p><p>考虑 $dp$ 实现，状态大概设计为 $f_{i,j}$ 表示考虑了前 $i$ 个数，一共有 $j$ 个左括号没有闭合的最大结果。可以知道第二维只会是 $0,1,2$ 。思考如何转移，大概就是分类讨论左括号数量。一开始带符号地读入 $x$ ，那么可知可以先赋初值： $f_{i,0}=x,f_{i,1}=-x,f_{i,2}=x$ 这样。然后考虑转移。发现我们可以通过加一个右括号使得未匹配的左括号数量减少，那么也就是 $f_{i,0}$ 可以加上 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，$f_{i,1}$ 可以加上 $\max\{f_{i-1,1},f_{i-1,2}\}$ ， $f_{i,2}$ 就只能原地转移。然后就是考虑，如果当前的 $x &lt;0$ ，也就是读进来一个符号，那么可以考虑放一个左括号，所以需要 <code>chkmax</code> 一下 <code>(f[i][2],f[i][1]),(f[i][1],f[i][0])</code> 。 </p><p>注意最后要输出 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，原因是根据状态的定义，我们没有考虑在第 $n$ 个数最后添上右括号的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; LL x ;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">2</span>] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">52</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        x = qr() ;</span><br><span class="line">        f[i][<span class="number">0</span>] = x ;</span><br><span class="line">        f[i][<span class="number">2</span>] = x ;</span><br><span class="line">        f[i][<span class="number">1</span>] = -x ;</span><br><span class="line">        f[i][<span class="number">2</span>] += f[i - <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line">        f[i][<span class="number">1</span>] += max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]) ;</span><br><span class="line">        f[i][<span class="number">0</span>] += max(f[i - <span class="number">1</span>][<span class="number">0</span>], max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>])) ;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i][<span class="number">2</span>], f[i][<span class="number">1</span>]) ;</span><br><span class="line">            f[i][<span class="number">1</span>] = max(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(f[n][<span class="number">1</span>], max(f[n][<span class="number">0</span>], f[n][<span class="number">2</span>])) &lt;&lt; <span class="built_in">endl</span>  ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>思路题还是要自己先认真想，不然真的做了效果不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是正好做到了这一场的F，就顺便把前三个题给做了。&lt;/p&gt;
&lt;p&gt;嗯，感觉思维能力还是很重要的。所以不能再这么沉沦了啊。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
  </entry>
  
  <entry>
    <title>【题解】[AGC012E]Camel and Oases</title>
    <link href="https://www.orchidany.cn/2020/02/25/AGC012E/"/>
    <id>https://www.orchidany.cn/2020/02/25/AGC012E/</id>
    <published>2020-02-25T13:35:02.000Z</published>
    <updated>2020-02-26T01:03:32.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，保证 $-10^{9}\le x_1&lt;x_2…&lt;x_n\le 10^9$</p><p>现在有一个人在沙漠中进行旅行，他初始的背包的水容积为 $V$ 升，同时他初始拥有 $V$ 升水，每次到达一个绿洲时，他拥有的水的量将自动重置为容积上限。他现在可以选择两个操作来进行旅行：</p><ol><li><p>走路，行走距离为 $d$ 时，需要消耗 $d$ 升水。清注意，任意时刻你拥有的水的数量不能为负数。</p></li><li><p>跳跃，令 $v$ 为你当前拥有的水量，若 $v&gt;0$，则你可以跳跃至任意一个绿洲，然后重置容积上界和所拥有的水量为 $v/2$ （四舍五入取整）。</p></li></ol><p>对于每一个 $i$ 满足 $1\le i\le n$，你需要求当你在第 $i$ 个绿洲作为起点时，你能否依次遍历其他所有绿洲。如果可以，输出 <code>Possible</code>，否则输出 <code>Impossible</code>。</p><p>$1\leq n,v\leq 2\times10^5$。</p></blockquote><p>神仙状态设计题orz</p><a id="more"></a><p>定义 $G$ 为全集，具体定义后文详谈。</p><p>首先考虑一点，就是本质上最多有 $\log V$ 种容积，可以把这个看做 $\log V$ 层，每层都有 $n$ 个点。定义层与层之间的方向「从上至下」代表容积不断变小，同上从上至下给每一层一个递增的编号。考虑对于每一层，可以把所有能够互相到达的连通块缩成几条线段，这样每层就是几条线段了。那么题目要求的就是，在限制第一层选某个线段时，每层至多选一个线段，是否可以讲整个 $[1,n]$ 覆盖。</p><p>考虑首先预处理出来 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ ，分别表示在第 $s$ 层内，某个点所在线段的左端点和右端点。然后考虑预处理出这么两个状态：$expanL_t$ 和 $expanR_t$ ，表示只考虑集合 $t$ 内的那几层，最多从 $1$ 向右扩展至什么地方和最多从 $n$ 向左扩展到什么地方。考虑先把所有包含第一层的集合忽略，那么存在转移：</p><script type="math/tex; mode=display">expanL_t=\max_{s\in t}\{R[t][expanL_{t-\{s\}} +1] \}\\expanR_t=\min_{s\in t}\{L[t][expanR_{t-\{s\}} -1] \}\\</script><p>这个转移十分神奇。以 $expanL$ 的转移为例，本质上对于一个集合 $t-\{s\}$，为了求出连续块，应该去枚举第  $s$ 层内第一个不包含在 $expanL_{t-\{s\}}$ 内的线段，然后用这个线段是右端点来更新，所以或许需要一个二分。但是其实根本不需要，直接可以用上面推出来的 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ 进行转移，还是很巧妙的。</p><p>最后就可以枚举每条线段，去找是否存在一个不包含第一层的状态 $t$ ， $expanL_t$ 覆盖了 $1\sim l_t$ ，同时 $expanR_{G-t}$ 覆盖了 $r_{G-t}\sim n$ ，那么如果这个线段的左右端点 $l,r$ 分别满足 $l-1\leq l_t$ 和 $r+1\geq r_{G-t}$，那么这个线段内部的点都是合法的。</p><p>最终复杂度 $O(\max\{(n+v)\log v, n\log n\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">40</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1001000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep ;</span><br><span class="line"><span class="keyword">int</span> maxn ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> L[M][N] ;</span><br><span class="line"><span class="keyword">int</span> R[M][N] ;</span><br><span class="line"><span class="keyword">int</span> farfrl[N] ;</span><br><span class="line"><span class="keyword">int</span> farfrr[N] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rg[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; j &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        R[++ dep][n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            L[dep][i] = (base[i] - base[i - <span class="number">1</span>] &gt; j) ? i : L[dep][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            R[dep][i] = (base[i + <span class="number">1</span>] - base[i] &gt; j) ? i : R[dep][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Auxiliary_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= dep ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] + <span class="number">1</span>]) ;</span><br><span class="line">                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    base[<span class="number">0</span>] = -MAX ;</span><br><span class="line">    base[n + <span class="number">1</span>] = MAX ; k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; Init_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        rg[i].l = L[<span class="number">1</span>][i], rg[i].r = R[<span class="number">1</span>][i] ;</span><br><span class="line">    sort(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) ; maxn = (<span class="number">1</span> &lt;&lt; dep) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; ++ i) farfrr[i] = n + <span class="number">1</span> ;</span><br><span class="line">    k += unique(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) - rg ; Auxiliary_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= maxn ; j += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (farfrl[j] + <span class="number">1</span> &gt;= rg[i].l &amp;&amp; farfrr[(maxn ^ j) ^ <span class="number">1</span>] - <span class="number">1</span> &lt;= rg[i].r)</span><br><span class="line">                &#123; <span class="keyword">for</span> (<span class="keyword">int</span> o = rg[i].l ; o &lt;= rg[i].r ; ++ o) ans[o] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">puts</span>(ans[i] ? <span class="string">"Possible"</span> : <span class="string">"Impossible"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，保证 $-10^{9}\le x_1&amp;lt;x_2…&amp;lt;x_n\le 10^9$&lt;/p&gt;
&lt;p&gt;现在有一个人在沙漠中进行旅行，他初始的背包的水容积为 $V$ 升，同时他初始拥有 $V$ 升水，每次到达一个绿洲时，他拥有的水的量将自动重置为容积上限。他现在可以选择两个操作来进行旅行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;走路，行走距离为 $d$ 时，需要消耗 $d$ 升水。清注意，任意时刻你拥有的水的数量不能为负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;跳跃，令 $v$ 为你当前拥有的水量，若 $v&amp;gt;0$，则你可以跳跃至任意一个绿洲，然后重置容积上界和所拥有的水量为 $v/2$ （四舍五入取整）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于每一个 $i$ 满足 $1\le i\le n$，你需要求当你在第 $i$ 个绿洲作为起点时，你能否依次遍历其他所有绿洲。如果可以，输出 &lt;code&gt;Possible&lt;/code&gt;，否则输出 &lt;code&gt;Impossible&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;$1\leq n,v\leq 2\times10^5$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神仙状态设计题orz&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#6433 [PKUSC2018]最大前缀和</title>
    <link href="https://www.orchidany.cn/2020/02/25/PKUSC2018%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://www.orchidany.cn/2020/02/25/PKUSC2018最大前缀和/</id>
    <published>2020-02-25T13:12:00.000Z</published>
    <updated>2020-02-26T01:03:43.238Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个长为 $n$ 的序列 $a_n$，求这个序列随机打乱后最大前缀和的期望值。</p><p> $n ≤ 20, |a_i | ≤ 10^9$</p></blockquote><p>一道让人更透彻地理解动态规划的好题orz</p><a id="more"></a><p>这是个神仙题…</p><p>考虑从这个 $dp$ 的本质入手。以下记 $\{a_m\}$ 表示长度为 $m$ 的序列 $a_1,a_2,\cdots a_m$ 。</p><p>首先，对于一个最大前缀和 $(p,\{s_n\})$ 表示的是 $s_1,s_2\cdots s_p$ 构成这个序列的最大前缀和，那么有两个性质：</p><p>1、对于 $\{s_n\}$ 的任意 $k&gt;p$ 的 $k\sim n$ 后缀，都有 $sum(k\sim n) \leq 0$ 。</p><p>2、对于 $\{s_p\}$ （即 $\{s_n\}$ 的 $1\sim p$ 前缀）的任意 $k&gt;1$ 的 $k\sim p$ 后缀，有 $sum(k\sim p)\geq 0$ 。</p><p>那么考虑枚举集合 $t$，表示这个集合的全部元素都用来贡献最大前缀和，记 $f_t$ 为满足条件2的排列方案数，$g_t$ 为满足条件1的方案数，那么考虑如何按秩转移。对于已经有的一个排列，考虑在序列最前端加一个数or在序列最后端加一个数，这样我们保证了按秩的同时，可以比较方便地讨论：</p><p>1、如果 $sum_t&lt;0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $g_{t\cup\{k\}}$ 贡献 $g_t$ 的方案数，也就是向序列后方添一个数。</p><p>2、如果 $sum_t\geq 0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $f_{t\cup\{k\}}$ 贡献 $f_{t}$ 的方案数，也就是向序列前端添一个数。</p><p>但是这个地方有个问题，就是如果最大的前缀和为负，他依然有贡献，但是没有统计。考虑一个贪心的性质如果最大前缀和为负，那么肯定最大前缀和只有第一个元素。所以一开始把所有只有一个元素的 $f$ 都置为 $1$ 即可。</p><p>这个地方有个很需要学习的地方，就是 <strong>刷表法在此处由于和dp的推法一致，也就是在模拟加入一个数的过程，所以刷表会比较自然，而朴素地填表就会出错</strong>。</p><p>嗯，拿小本本记下来了/kel</p><p>于是最后答案就是： </p><script type="math/tex; mode=display">\sum_{t⊆ m} sum_{\mathrm{t}}\cdot f_{\mathrm{t}}\cdot g_{\mathrm{m}-\mathrm{t}}</script><p>以下是向srz学习的dp方式，本质上也是在枚举 $&gt;0$ 后缀：</p><p>考虑另一种推 $f$ 的方式，考虑本质上 $f_t$ 计算的是有多少种方案使得 $sum_t$ 成为最大前缀和，那么就可以这么转移：</p><script type="math/tex; mode=display">f_t=|t|!-\sum_{s⊆t}f_s\cdot g_{t-s}</script><p>也就是枚举有多少种不合法的方案，通过子集转移。裸的转移是 $3^n$ 的，但观察到本质上是在做一个集合的对称差，于是可以用 $\rm FWT$ 优化到 $2^nn^2$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line">LL ans ;</span><br><span class="line">LL f[M] ;</span><br><span class="line">LL g[M] ;</span><br><span class="line">LL sum[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; g[<span class="number">0</span>] = <span class="number">1l</span>l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], sum[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sum[i] = (sum[low(i)] + sum[i ^ low(i)]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; j) &amp; i)) (f[i | (<span class="number">1</span> &lt;&lt; j)] += f[i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; i) (g[i] += g[(<span class="number">1</span> &lt;&lt; j) ^ i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        (ans += sum[i] * f[i] % P * g[m ^ i] % P) %= P ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (((ans % P) + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个长为 $n$ 的序列 $a_n$，求这个序列随机打乱后最大前缀和的期望值。&lt;/p&gt;
&lt;p&gt; $n ≤ 20, |a_i | ≤ 10^9$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道让人更透彻地理解动态规划的好题orz&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[ARC066F]Contest with Drinks(Hard)</title>
    <link href="https://www.orchidany.cn/2020/02/23/ARC066F/"/>
    <id>https://www.orchidany.cn/2020/02/23/ARC066F/</id>
    <published>2020-02-23T05:39:21.000Z</published>
    <updated>2020-02-26T00:35:13.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个点，选择第 $i$ 个点有 $a_i$ 的代价。如果一个极大的、长度为 $L$ 的区间内的点都被选了，这个区间会带来$\frac{L^2+L}{2}$ 的收益。</p><p>询问共 $q$ 组，为对 $a_i$ 的单点修改。 询问彼此独立。</p><p>形式化地讲，给定 $\{t_n\}$ ，求一组 $\{x_n\},\forall i \in[1, n], x_{i} \in[0,1]$ 使可以得到：</p><script type="math/tex; mode=display">\max \left\{\sum_{i=1}^{n} \sum_{j=i}^{n}\left(\prod_{k=i}^{j} x_{k}\right)-\sum_{i=1}^{n} x_{i} t_{i}\right\}</script><p>$n, q ≤ 3 × 10^5$</p></blockquote><p>一道神题…本质上虽然不是很难，但是碍于个人对斜率优化这个东西掌握的实在十分差劲，所以几乎把所有能踩的坑全踩了一遍。</p><a id="more"></a><h1 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm Sol$"></a>$\rm Sol$</h1><p>首先考虑对于每个询问，主要思想是维护一个前缀的 $f_i$ 表示不选 $i$ ，前 $i-1$ 个元素的最优解；$g_i$ 则是用来维护一个后缀，表示不选 $i$，$i+1\sim n$ 中元素的最优解。同时，再维护一个 $h_i$ 表示选了 $i$ 的全局最优解。那么这样就可以如此回答询问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是考虑这三个东西应该怎么转移。先考虑 $f$ :</p><script type="math/tex; mode=display">\begin{aligned}f_i&=\max\{f_j+\frac{(i-j)(i-j-1)}{2}-(s_i-s_j)\}\\f_i&=\max\{f_i,f_{i-1}\}\end{aligned}</script><p>枚举的是 $[j,i-1]$ 这段区间。</p><p>变形可得</p><script type="math/tex; mode=display">f_j+s_j+\frac{j^2+j}{2}=i\cdot j+f_i+s_i- \frac{i^2-i}{2}</script><p>于是就发现，这是一个以 $f_j+s_j+\frac{j^2+j}{2}$ 为纵坐标，$i$ 为斜率的斜率优化。观察可知，横坐标 $j$ 单增，同时斜率 $i$ 也单增。所以对于这种类型的 $dp$ 只能用<strong>单调栈</strong>来维护。</p><p>同时，关于 $g$，只需要倒着做一遍 $f$ 的 $dp$ 即可。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line"><span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>考虑关于于 $h$ 的转移，朴素的转移是 $O(n^3)$ 的，类似这样：</p><script type="math/tex; mode=display">h_i=\max_{x\leq i\leq y}\{f_x+\frac{(y-x+1)(y-x+2)}{2}-s_y+s_x+g_y\}</script><p>发现并不可以过。发现转移是一个区间的形式，于是考虑分治。但是这个分治有个 $bug$ ，就是不是很容易维护跨过 $mid$ 的信息。</p><p>但发现一个性质，对于 $[mid+1,r]$ 之间的所有 $h$ 值，左边的所有点仅仅是帮助其成为最优解，也就是左边对右边的点满足单调性。那么我们就可以用单调栈来维护上一个不选的（即维护 $x$）同时枚举最后选的（枚举 $y$），即用 $[l,mid]$ 的值去更新 $[mid+1,r]$；同理对于右半边我们也可以这么做。</p><p>具体的，以用 $[l,mid]$ 的值去更新 $[mid+1,r]$ 为例，在算左半边的决策集合的时候，不需要考虑 $g_y$ 的贡献，所以就是一个裸的斜率优化；之后转移就只需要弹栈转移即可。</p><p>发现在转移 $h$ 的时候，由于固定了其中一个端点，依然满足斜率优化，于是复杂度为 $\max\{n\log n, Q\}$。</p><p>以下是坑点：</p><p>1、注意如果按照上述方式来转移，两个转移常数有些微不同（但是这些不同很致命</p><p>2、注意因为一开始 $\{g_n\}$ 这个东西是按照 <code>reverse</code> 的前缀和来转移的，所以在分治的时候需要重新计算前缀和。</p><p>3、在分治的时候，斜率啊什么的变换频繁，所以如果想要推明白，可以在维护上凸壳的时候偷懒这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define tranl(b,a) g[a + 1] - s[a] + S[b] + F[b] + 1ll * ((a - b)*(a - b + 1)/ 2ll)</span><br><span class="line">#define tranr(b,a) f[a - 1] - s[a] + S[b] + G[b] + 1ll * ((b - a)*(b - a + 1)/ 2ll)</span><br></pre></td></tr></table></figure><p>然后每次比较就不需要斜率了，只需要 <code>while (top &gt; 1 &amp;&amp; tranl(stk[top], i) &lt;= tranr(stk[top - 1], i)) -- top</code> ;  虽然显然本质上没什么不同，但这样或许会简单很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL g[N] ;</span><br><span class="line">LL o[N] ;</span><br><span class="line">LL s[N] ;</span><br><span class="line">LL tmp[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y + <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y2(x) - <span class="number">1.0</span> * Y2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY2(x) - <span class="number">1.0</span> * YY2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> o[l] = max(o[l], f[l - <span class="number">1</span>] + g[r + <span class="number">1</span>] + <span class="number">1</span> - base[l]), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL ans ;</span><br><span class="line">    solve(l, mid) ; solve(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[l - <span class="number">1</span>] = s[r + <span class="number">1</span>] = <span class="number">0</span> ; t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[i] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>), s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span> ; i &lt;= mid ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = f[stk[t]] + calc(i, stk[t]) - s[i] + s[stk[t]] + g[i + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= mid + <span class="number">1</span> ; -- i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">    t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l ; -- i) s[i] = s[i + <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span> ; i &gt; mid ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid ; i &gt;= l ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = g[stk[t]] + calc(stk[t], i) - s[i] + s[stk[t]] + f[i - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= mid ; ++ i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"2.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"1.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    t = <span class="number">0</span> ; <span class="keyword">int</span> p, x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]),</span><br><span class="line">        o[i] = - (<span class="number">1l</span>l  &lt;&lt;  <span class="number">62</span>),</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br><span class="line">    g[<span class="number">0</span>] = g[n + <span class="number">1</span>], g[n + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; g[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    solve(<span class="number">1</span>, n) ; <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; o[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这题我从 <code>2020.2.22</code> 的晚上7点开始写，<del>中间看了两个小时C菌直播行尸走肉并且睡了一个小时</del>，本来写的很顺，后来发现一堆细节没考虑就开始自闭了，<del>感觉就是行尸走肉太带劲了思路断了</del>，$1$ 点垂死梦中惊坐起之后在黑黑的房间里 <code>debug</code> 到了早上4点，睡了3.5h之后起来发现只剩一个「 $g$ 当时是倒着求的」这么一个问题了，但不幸走了很多弯路，不过最终还是AC了…</p><p>其实有时候根本不知道自己为啥要这么做，这么做的意义似乎也不是很大，中途破坏了自己本来想早睡早起的计划、浪费了一场300iq出的比赛外加和老妈吵了一架。</p><p>但可能人生中没意义的事情还多的多，并且一件更比一件没意义，所以可能也不需要这么伤心。</p><p>安啦安啦，还要继续走下去啊。</p><p><img src="1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个点，选择第 $i$ 个点有 $a_i$ 的代价。如果一个极大的、长度为 $L$ 的区间内的点都被选了，这个区间会带来$\frac{L^2+L}{2}$ 的收益。&lt;/p&gt;
&lt;p&gt;询问共 $q$ 组，为对 $a_i$ 的单点修改。 询问彼此独立。&lt;/p&gt;
&lt;p&gt;形式化地讲，给定 $\{t_n\}$ ，求一组 $\{x_n\},\forall i \in[1, n], x_{i} \in[0,1]$ 使可以得到：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\max \left\{\sum_{i=1}^{n} \sum_{j=i}^{n}\left(\prod_{k=i}^{j} x_{k}\right)-\sum_{i=1}^{n} x_{i} t_{i}\right\}&lt;/script&gt;&lt;p&gt;$n, q ≤ 3 × 10^5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道神题…本质上虽然不是很难，但是碍于个人对斜率优化这个东西掌握的实在十分差劲，所以几乎把所有能踩的坑全踩了一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="atcoder" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/atcoder/"/>
    
    
      <category term="生活碎片" scheme="https://www.orchidany.cn/tags/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"/>
    
      <category term="分治" scheme="https://www.orchidany.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【泛学笔记】动态规划杂项</title>
    <link href="https://www.orchidany.cn/2020/02/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.orchidany.cn/2020/02/22/动态规划杂项/</id>
    <published>2020-02-22T00:09:33.000Z</published>
    <updated>2020-03-01T23:14:43.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是听课笔记，但后来发现没啥可听的就变成了做题笔记(?)</p><a id="more"></a><h1 id="单调队列部分"><a href="#单调队列部分" class="headerlink" title="单调队列部分"></a>单调队列部分</h1><p>单调队列主要用来优化，对于状态 $\rm S$ 的某个后继状态 $\rm S’$，如果 $\rm S’$ 比 $\rm S$ 更优就可以舍弃掉 $\rm S$ 的转移。通常表现形式为会有限制，比如</p><script type="math/tex; mode=display">f_{i}=\max\{f_j\}+w_i \quad(j\in[L_i,i-1]\cap\mathbb Z)</script><p>其中 $\{L\}$ 是一个给定常数，且 $\forall i, L_i\geq L_{i-1}$ 。那么可知对于后续状态 $s_i$ ，他的可转移范围一定更大，至少比 $s_j$ 大，所以可以删除 $s_j$.</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知 $L_i$ 不降，于是就对每个 $d$ 用单调队列即可。</p><h1 id="斜率优化部分"><a href="#斜率优化部分" class="headerlink" title="斜率优化部分"></a>斜率优化部分</h1><p>这部分虽然简单但是不熟，所以可能需要多做点题。</p><h2 id="傻狗题"><a href="#傻狗题" class="headerlink" title="傻狗题"></a>傻狗题</h2><blockquote><p>把一个长为 $n$ 的正整数序列划分成若干段，每一段的代价是内部元素和的平方加上一个定值 $m$。求划分整个序列的最小代价。</p></blockquote><p>可知转移</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_i-s_j)^2\}+m</script><script type="math/tex; mode=display">f_j+s_j^2=2s_is_j+f_i-s_i^2-m</script><p>于是就变成了有一个以 $s_i$ 为斜率，$f_j+s_j^2$ 为纵坐标，$s_i$ 为横坐标的斜率优化。考虑横坐标和斜率都是单调的，就可以直接队尾删/队尾插入。</p><h2 id="USACO08MAR-Land-Acquisition"><a href="#USACO08MAR-Land-Acquisition" class="headerlink" title="[USACO08MAR]Land Acquisition"></a>[USACO08MAR]Land Acquisition</h2><blockquote><p>有 $n$ 块长方形的土地需要购买，你每次可以选择一组土地一起购买，价 格为这些土地中最大的长乘以最大的宽。求购买所有土地的最小费用。 </p><p>$n ≤ 50000$</p></blockquote><p>考虑先排序，然后考虑如果直接 $dp$，那么本身需要枚举 $i\sim j$ 之间的元素取 $\max$，这样显然复杂度就多了一维 $n$。仔细思考后发现，如果对于一组 $(i,j)$，满足 $w_i\geq w_j$ 且 $h_i\geq j_j$ ，那么就可以删掉 $j$ 。具体的，考虑按照 $h$ 排序之后，用一个单调栈来维护这个东西。</p><p>那么这样最后剩下的一定满足 $w$ 单调。所以就会得到类似</p><script type="math/tex; mode=display">f_i=\min\{f_{j}+h_{j+1}\cdot w_i\}\\f_j=-h_{j+1}\cdot w_i+f_i</script><p>那么令 $h_{j+1}$ 作为横坐标，横坐标单调；$w_i$ 作为斜率，斜率单调。于是就变成了最 <code>general</code> 的斜率优化问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">LL f[N] ;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grid</span>&#123;</span></span><br><span class="line">    LL x, y ;</span><br><span class="line">&#125;base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(grid a, grid b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &gt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!top || t[top].y &lt; base[i].y) t[++ top] = base[i] ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= 50 ; ++ i) cout &lt;&lt; t[i].x &lt;&lt; " " &lt;&lt; t[i].y &lt;&lt; endl ;</span></span><br><span class="line">    n = top ; q.push_back(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.front() ; q.pop_front() ; o = q.front() ;</span><br><span class="line">            <span class="keyword">if</span> (f[p] - f[o] &lt;= t[i].y * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_front(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         f[i] = f[q.front()] + t[q.front() + <span class="number">1</span>].x * t[i].y ;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.back() ; q.pop_back() ; o = q.back() ;</span><br><span class="line">            <span class="keyword">if</span> ((f[p] - f[o]) * (t[p + <span class="number">1</span>].x - t[i + <span class="number">1</span>].x) &lt;= (f[i] - f[p]) * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_back(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         q.push_back(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BTW，如何推凸包的维护方式，可以考虑是维护下凸壳还是上凸壳，但是似乎又一种方式更简便：</p><p>令 $0\leq k&lt;j&lt;i$ ，那么如果 $j$ 比 $k$ 好，那么需要满足</p><script type="math/tex; mode=display">\begin{aligned}f_{j}+w_{j+1} \times l_{i} & \leq f_{k}+w_{k+1} \times l_{i} \\f_{j}-f_{k} & \leq l_{i} \times\left(w_{k+1}-w_{j+1}\right)\\l_{i} &\geq \frac{f_{j}-f_{k}}{w_{k+1}-w_{j+1}}\end{aligned}</script><p>这么做就会比较直观？</p><p>值得注意的是，斜率优化的时候很可能会因为移项的时候符号变错了而GG。</p><p>还有，似乎如果斜率和横坐标的单调方式相同，那么就可以用单调栈替换掉单调队列。虽然…没啥用233</p><h1 id="期望相关"><a href="#期望相关" class="headerlink" title="期望相关"></a>期望相关</h1><h2 id="Red-is-Good"><a href="#Red-is-Good" class="headerlink" title="Red is Good"></a>Red is Good</h2><blockquote><p>$n$ 张红牌，$m$ 张黑牌随机打乱顺序放在桌面上，你可以翻牌，翻到红色则得到 $1$ 元，黑色则失去 $1$ 元。求在最优策略下平均能得到多少钱。</p><p>$n,m\leq 5000$</p></blockquote><p>考虑如何设状态为 “已经xxx了”，不是很容易转移。于是考虑令 $f_{i,j}$ 为剩下 $i$ 张红的，$j$ 张黑的时的最大值。注意到由于是最优决策，所以有</p><script type="math/tex; mode=display">f_{i,j}=\max\{0,\frac{i}{i+j}(f_{i-1,j}+1)+\frac{j}{i+j}(f_{i,j-1}-1)\}</script><h2 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="[HNOI2015]亚瑟王"></a>[HNOI2015]亚瑟王</h2><blockquote><p>有 $n$ 张卡牌，玩 $r$ 轮游戏。每轮游戏从左向右轮流考虑每张没有发动过的卡牌，考虑到第 $i$ 张卡时，它有 $p_i$ 的概率发动并产生 $d_i$ 的贡献， 然后本轮立即结束并进入下一轮。若没有卡牌发动则直接进入下一轮。 $T$ 组数据，求期望贡献。</p><p>$T\leq 500, n\leq 300,r\leq 200$</p></blockquote><p>考虑分别计算出每张卡牌的发动概率，然后分别乘上每张卡牌的权值得到答案。</p><p>具体的，令 $f_{i,j}$ 表示当前只在考虑第 $i$ 张牌，还剩 $j$ 次游戏没有开始的概率。考虑转移：</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j+1}\cdot(1-(1-p_{i-1})^{j+1})+f_{i-1,j}\cdot(1-p_{i-1})^j</script><p>其实就是在计算牌 $i-1$ 是否被发动了，前半部分计算了第 $i$ 张牌在之后的 $j$ 次以及当前这一次中任意一次发动成功的概率，所以是 $1-一次也没发动成功的概率$；后半部分以此类推。注意，此处忽略了题目中「直接结束本轮」的约束。本质上，$f$ 保证了还有 $j$ 轮时，前 $i$ 张卡牌不会被选。</p><p>那么考虑如何计算第 $i$ 张牌是否发动了的概率：</p><script type="math/tex; mode=display">P_i=\sum_{j=1}^rf_{i,j}\cdot (1-(1-p_i)^j)</script><p>之后用线性性算一下就好了。复杂度 $O(nTr)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n, r ;</span><br><span class="line"><span class="keyword">double</span> ans ;</span><br><span class="line"><span class="keyword">double</span> d[N] ;</span><br><span class="line"><span class="keyword">double</span> p[N] ;</span><br><span class="line"><span class="keyword">double</span> f[N][N] ;</span><br><span class="line"><span class="keyword">double</span> xs[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r ; <span class="keyword">double</span> res ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;d[i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = xs[i][j] = <span class="number">0</span> ;</span><br><span class="line">        f[<span class="number">0</span>][r] = <span class="number">1</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            res = <span class="number">1.0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                xs[i][j] = res, res *= (<span class="number">1.0</span> - p[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = r ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (<span class="number">1.0</span> - xs[i - <span class="number">1</span>][j + <span class="number">1</span>]) + f[i - <span class="number">1</span>][j] * xs[i - <span class="number">1</span>][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                ans += d[i] * f[i][j] * (<span class="number">1.0</span> - xs[i][j]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实就是听课笔记，但后来发现没啥可听的就变成了做题笔记(?)&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj1559 [JSOI2009]密码</title>
    <link href="https://www.orchidany.cn/2020/02/20/JSOI2009%E5%AF%86%E7%A0%81/"/>
    <id>https://www.orchidany.cn/2020/02/20/JSOI2009密码/</id>
    <published>2020-02-20T10:53:03.000Z</published>
    <updated>2020-02-21T01:47:20.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定长度 $L$ 个 $m$ 个子串，要求拼出一个长度为 $L$ 的长串使之包含所有的子串。</p><p>如果方案数 $\leq42$ 则输出全部方案，否则只输出方案数。</p><p>$L\leq 25,m\leq 10$。</p></blockquote><a id="more"></a><p>…这题大概也就是蓝~紫左右，这个黑实在太虚了。</p><p>但这不影响我还是不太会233</p><p>观察题意，由 <code>good+day=gooday</code> 可知应该放在 $\rm AC$ 自动机上做，因为存在重合。观察范围可知是状压。于是考虑在 $\rm$ AC 自动机上 $dp$。</p><p>记 $f_{i,j,s}$ 表示匹配到串的第 $i$ 位，走到了自动机上的第 $j$ 个节点，当前已经拼完了集合 $s$ 中的模式串的方案数。转移的话就考虑直接枚举当前状态的所有子状态，暴力转移即可（用来计数的状压 $dp$ 还能怎么转移啊喂）。值得提一句的的是，由于本身 $\rm AC$ 自动机存在路径压缩，所以是 <code>认子不认父</code> 的结构，只能刷表而不能填表。</p><p>之后考虑输出方案。发现如果直接搜 $\rm AC$ 自动机上的每个方案十分暴力，于是考虑加一个可行性剪枝。即由于很容易 $dfs$ 出每个状态 $(i,j,s)$ 是否可以转移到终点，所以不需要考虑 $42$ 的限制，预处理一个 $g_{i,j,s}$是否可以拼出最终状态，剪完枝直接输出即可。</p><p>同时，只要在 $\rm AC$ 自动机上保证每次走最小的字母，就一定是字典序最优的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> o ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line">LL f[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> g[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> v[N][W][Z] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> _ed[W] ;</span><br><span class="line">    <span class="keyword">int</span> fail[W] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> trans[W][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *t, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, len ;</span><br><span class="line">        len = <span class="built_in">strlen</span>(t + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span> ; i &lt;= len ; ++ i)&#123;</span><br><span class="line">            x = t[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trans[rt][x])</span><br><span class="line">                trans[rt][x] = ++ size ;</span><br><span class="line">            rt = trans[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[rt] |= (<span class="number">1</span> &lt;&lt; num) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">            q.pop() ; _ed[x] |= _ed[fail[x]] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[x][i]) trans[x][i] = trans[fail[x]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trans[x][i]] = trans[fail[x]][i], q.push(trans[x][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] = (<span class="keyword">bool</span>)(z == o) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> p = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v[x][y][z])</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] ;</span><br><span class="line">    <span class="keyword">else</span> v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        p |= search(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">    <span class="keyword">return</span> g[x][y][z] = p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g[x][y][z]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, t[i] + <span class="string">'a'</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        t[x + <span class="number">1</span>] = i, output(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; S.size = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), S.Ins(s, i - <span class="number">1</span>) ;</span><br><span class="line">    S.build() ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; o = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= S.size ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= o ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j][k])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; <span class="number">26</span> ; ++ l)</span><br><span class="line">                        f[i + <span class="number">1</span>][S.trans[j][l]][k | S._ed[S.trans[j][l]]] += f[i][j][k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= S.size ; ++ i) ans += f[n][i][o] ;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">42</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>, search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), output(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定长度 $L$ 个 $m$ 个子串，要求拼出一个长度为 $L$ 的长串使之包含所有的子串。&lt;/p&gt;
&lt;p&gt;如果方案数 $\leq42$ 则输出全部方案，否则只输出方案数。&lt;/p&gt;
&lt;p&gt;$L\leq 25,m\leq 10$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="字符串/AC自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj2555 Substring</title>
    <link href="https://www.orchidany.cn/2020/02/20/bzoj2555/"/>
    <id>https://www.orchidany.cn/2020/02/20/bzoj2555/</id>
    <published>2020-02-20T10:43:05.000Z</published>
    <updated>2020-02-21T01:47:27.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>要求实现两种操作：</p><p>(1): 在当前字符串的后面插入一个字符串</p><p>(2): 询问字符串 $s$ 在当前字符串中出现了几次？(作为连续子串)</p><p>你必须在线支持这些操作。</p><p>长度 $\leq 600000$，询问次数 $\leq 10000$，询问总长度 $\leq 3,000,000$。 </p></blockquote><a id="more"></a><p>一直听说有 $\rm LCT$ 维护 $parent$ 树的题，没想到真做到了233。</p><p>考虑字符串 $s$ 出现的次数，在SAM中，一个节点里面的某个子串的出现次数就是它的子树的出现次数和，因为长的后缀与短的后缀之间信息不共享，所以修改操作本质上是在进行 $parent$ 树上的链加。</p><p>考虑一种神奇的写法。每次对于新建的节点 $np$ ，他的贡献应该是 $parent$ 树上 $1\sim np$ 这条路径上的所有点。于是考虑先 <code>merge(1, np)</code> ，把 $np$ 给 <code>splay</code> 上去之后内部就变成了一棵以 $np$ 为根的一条链，这样就可以不用考虑链加，直接在 $np$ 处打标记即可。</p><p>似乎查询操作更为神奇。因为查询的时候只需要对于走到的一个点 $x$ ，直接把他 <code>splay</code> 掉就可以维护信息。看上去似乎不是很对，因为对 $x$ 产生贡献的是一颗子树而不是一条链。但这样做其实有他独特的正确性保证，即每个点都存在且仅存在于一棵 <code>splay</code> ，换 <code>splay</code> 的时候势必要 <code>access</code>，而 <code>access</code> 时本质上就已经把原来的标记给下放干净了，所以每次只有可能是当前的 <code>splay</code> 还有信息没有维护清楚。也就是每次只需要管一条链，剩下的链的标记已经清完了。这样就只需要 <code>splay</code> 一下即可。</p><p>写的时候，为了卡常发现了个更神奇的地方，就是在SAM里面抠点插子树/插点这两个操作，由于都保证了父亲不存在，所以 <code>Link</code> 这个操作，本质上是不需要 <code>make_root</code> 的，实测这样就会快很多很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(x) t[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tg(x) t[x].tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> tag ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[M] ;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">char</span> o[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span> ; swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tg(x))&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) vl(lc(x)) += tg(x), tg(lc(x)) += tg(x) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) vl(rc(x)) += tg(x), tg(rc(x)) += tg(x) ;</span><br><span class="line">        tg(x) = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (nroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x ;</span><br><span class="line">    stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(y))</span><br><span class="line">        stk[++ tp] = (y = fa(y)) ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (nroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    access(y) ; splay(y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    fa(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    merge(x, y) ;</span><br><span class="line">    fa(x) = t[y].son[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> mk)</span> </span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; len ; ++ j)</span><br><span class="line">        mk = (mk * <span class="number">131</span> + j) % len, swap(s[j], s[mk]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> last ;</span><br><span class="line">    <span class="keyword">int</span> len[M] ;</span><br><span class="line">    <span class="keyword">int</span> fal[M] ;</span><br><span class="line">    <span class="keyword">int</span> trans[M][<span class="number">2</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> q, nq, p = last ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fal[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)&#123;</span><br><span class="line">            fal[np] = <span class="number">1</span> ;</span><br><span class="line">            link(np, <span class="number">1</span>), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)&#123;</span><br><span class="line">            fal[np] = q ;</span><br><span class="line">            link(np, q), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        cut(fal[q], q) ;</span><br><span class="line">        fal[nq] = fal[q] ;</span><br><span class="line">        link (q, nq) ;</span><br><span class="line">        link (np, nq) ;</span><br><span class="line">        link (nq, fal[q]) ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        fal[q] = fal[np] = nq ;</span><br><span class="line">        splay(q) ; vl(nq) = vl(q) ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">8</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fal[p] ;</span><br><span class="line">        merge(<span class="number">1</span>, np), vl(np) ++, tg(np) ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ; S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) S.Ins(s[i] - <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, o + <span class="number">1</span>) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), Input(ans) ;</span><br><span class="line">        <span class="keyword">if</span> (o[<span class="number">1</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)</span><br><span class="line">                S.Ins(s[i] - <span class="string">'A'</span>) ; <span class="comment">//, cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rt = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)&#123;</span><br><span class="line">                rt = S.trans[rt][s[i] - <span class="string">'A'</span>] ;</span><br><span class="line">                <span class="keyword">if</span> (!rt) <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!rt) res = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">else</span> splay(rt), res = vl(rt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res) ; ans = ans ^ res ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要求实现两种操作：&lt;/p&gt;
&lt;p&gt;(1): 在当前字符串的后面插入一个字符串&lt;/p&gt;
&lt;p&gt;(2): 询问字符串 $s$ 在当前字符串中出现了几次？(作为连续子串)&lt;/p&gt;
&lt;p&gt;你必须在线支持这些操作。&lt;/p&gt;
&lt;p&gt;长度 $\leq 600000$，询问次数 $\leq 10000$，询问总长度 $\leq 3,000,000$。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="字符串/后缀自动机(SAM)" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    
      <category term="LCT" scheme="https://www.orchidany.cn/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>【题解】loj#2059 [HEOI/TJOI2016]字符串</title>
    <link href="https://www.orchidany.cn/2020/02/20/HEOI-TJOI2016%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.orchidany.cn/2020/02/20/HEOI-TJOI2016字符串/</id>
    <published>2020-02-20T10:32:16.000Z</published>
    <updated>2020-02-22T10:30:17.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个串，每次给出区间 $[a,b]$ 和 $[c,d]$，询问 $[a,b]$ 中的子串与 $s[c…d]$ 的 $lcp$ 最大值。</p><p>要求做法 $n~\mathrm{poly}(\log)$，其中 $\deg(\mathrm{poly}(\log))\leq 3$ 。 </p></blockquote><a id="more"></a><p>考虑二分，那么就变成了一个判定性问题，即考虑 $s[c…c+mid-1]$ 在 $[a…b]$ 中是否出现过。那么考虑倍增，对于每个点可以倍增出 $s[1…c+mid-1]$ 的 $endpos$ 所在的那个节点，那么现在就是要求这个 $endpos$ 中是否存在某个元素 $\in$ $[a+mid-1,b]$ 。 那么这个东西就可以插入时维护每个点当前的 $endpos$，之后对当前的 $parent$ 树做一次线段树合并即可。</p><p>需要注意的是这种写法的线段树合并可能会炸空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> Id[N] ;</span><br><span class="line"><span class="keyword">char</span> t[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> dad[N][<span class="number">21</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> lc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rt[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> sum[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[rt] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= mid) Ins(lc[rt], l, mid, v) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(rc[rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[rt] ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res += query(lc[rt], l, mid, ql, qr) ;</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res += query(rc[rt], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = ++ size ;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> y ;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[p] = sum[x] + sum[y] ;</span><br><span class="line">        lc[p] = merge(lc[x], lc[y], l, mid) ;</span><br><span class="line">        rc[p] = merge(rc[x], rc[y], mid + <span class="number">1</span>, r) ;</span><br><span class="line">        <span class="keyword">return</span> p ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">20</span> ; ++ k)</span><br><span class="line">        dad[x][k] = dad[dad[x][k - <span class="number">1</span>]][k - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        dad[to(k)][<span class="number">0</span>] = x, dfs(to(k)) ;</span><br><span class="line">        T.rt[x] = T.merge(T.rt[x], T.rt[to(k)], <span class="number">1</span>, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N] ;</span><br><span class="line">    <span class="keyword">int</span> len[N] ;</span><br><span class="line">    <span class="keyword">int</span> last, size ;</span><br><span class="line">    <span class="keyword">int</span> trans[N][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, nq ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fa[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = <span class="number">1</span>, last ;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = q, last ;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        fa[nq] = fa[q] ;</span><br><span class="line">        fa[q] = fa[np] = nq ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">104</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">        <span class="keyword">return</span> last ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= size ; ++ i) add(fa[i], i) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("str5.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>), S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Id[i] = S.Ins(t[i] - <span class="string">'a'</span>) ;</span><br><span class="line">        T.Ins(T.rt[Id[i]], <span class="number">1</span>, n, i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    S.Add() ; dfs(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = min(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>), mid, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> x = Id[c + mid - <span class="number">1</span>] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; mid &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (dad[x][j] &amp;&amp; S.len[dad[x][j]] &gt;= mid)</span><br><span class="line">                    x = dad[x][j] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (T.query(T.rt[x], <span class="number">1</span>, n, a + mid - <span class="number">1</span>, b))</span><br><span class="line">                ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个串，每次给出区间 $[a,b]$ 和 $[c,d]$，询问 $[a,b]$ 中的子串与 $s[c…d]$ 的 $lcp$ 最大值。&lt;/p&gt;
&lt;p&gt;要求做法 $n~\mathrm{poly}(\log)$，其中 $\deg(\mathrm{poly}(\log))\leq 3$ 。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="loj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/loj/"/>
    
    
      <category term="字符串/后缀自动机(SAM)" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    
      <category term="数据结构/数据结构方法/线段树合并" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】矩阵加速转移</title>
    <link href="https://www.orchidany.cn/2020/02/20/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82dp%E6%B3%9B%E5%81%9A/"/>
    <id>https://www.orchidany.cn/2020/02/20/矩阵快速幂dp泛做/</id>
    <published>2020-02-20T08:58:33.000Z</published>
    <updated>2020-02-21T01:49:09.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是整理“[HNOI2008]GT考试”和“[SNOI2017]礼物”两道题。由于实在找不出什么共同点来，所以就随便找了个理由把两道题放在一起了233</p><p>从各个角度来看，都算是比较妙的设计方式了？</p><a id="more"></a><h1 id="HNOI2008-GT考试"><a href="#HNOI2008-GT考试" class="headerlink" title="[HNOI2008]GT考试"></a>[HNOI2008]GT考试</h1><blockquote><p>求 $n$ 位数字串不连续包括某个长度为 $m$ 的数字串的方案数。</p><p>$n\leq 10^9,m\leq 20$</p></blockquote><p>考虑直接 $dp$ 。个人认为这个地方还是有一点 trivial 的。首先就是考虑一种状态设计，记 $f_{i,j}$ 表示长串匹配到第 $i$ 位，短串匹配到第 $j$ 位的合法方案数。那么考虑可以转移：</p><script type="math/tex; mode=display">f_{i,j}=\sum_{k=0}^{9}f_{i-1,o}</script><p>其中 $o=0\sim j-1$，取决于怎么个失配法。这样转移似乎并不可以。于是考虑另一种方式转移</p><script type="math/tex; mode=display">f_{i,j}=\sum_{k=0}^{m-1}f_{i-1,k}\cdot g_{k,j}</script><p>其中 $g_{x,y}$ 表示现在已经匹配到了第 $x$ 位，有多少种方案使得在加了一个数字后变成匹配到 $y$ 位的方案数。</p><p>发现本质上这就是在做一个 KMP。于是可以用 KMP 预处理处这样的一张数表 $\{g\}$ 。同时，发现对于原来的式子，右边的 $g$ 不变，且转移方式就是矩阵的转移方式，于是考虑直接用矩阵优化掉。最终复杂度 $m^3\log n$。</p><p>btw，由于本质上转移已经写在那里了，所以不用费劲去构造一个矩阵了…wsdd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fail[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> M[N][N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b)&#123;</span><br><span class="line">        Matrix ans ; ans.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    (ans.M[i][j] += a.M[i][k] * b.M[k][j] % p) %= p ;</span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (Matrix a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        Matrix res ; res.reset() ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = res * a ;</span><br><span class="line">            a = a * a ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p ; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++ j ; fail[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; m ; j = ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="string">'0'</span> ; c &lt;= <span class="string">'9'</span> ; j = i, ++ c)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; (<span class="keyword">int</span>)s[j + <span class="number">1</span>] != c) j = fail[j] ;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)s[j + <span class="number">1</span>] == c) ++ j ; g.M[i][j] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    g = g ^ n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">        (ans += g.M[<span class="number">0</span>][i]) %= p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SNOI2017-礼物"><a href="#SNOI2017-礼物" class="headerlink" title="[SNOI2017]礼物"></a>[SNOI2017]礼物</h1><blockquote><p> 给定 $k$，设 $f_i$ 的递推式如下：</p><script type="math/tex; mode=display">f_{i}=i^k+\sum_{j=1}^{i-1}f_j</script><p>$k\leq 500,n\leq 10^{18}$</p></blockquote><p>当然这题有什么其余的大力多项式算法，复杂度是什么 $O(k+\log n)$ 的…要知道原原本本这题 $k$ 只有 $10$ 这么大啊/kk</p><p>考虑先设 $s_n=\sum_{i=1}^nf_i$ ，那么发现</p><script type="math/tex; mode=display">\begin{aligned}f_n&=s_{n-1}+n^k\\s_n&=s_{n-1}+f_n\\&=2\cdot s_{n-1}+n^k\end{aligned}</script><p>于是发现可以递推 $s_n$。那么发现这个地方有一个常系数 $n^k$，尝试依靠</p><script type="math/tex; mode=display">(m+1)^k=\sum_{i=1}^k\binom{k}{i}m^i</script><p>这个东西来得到，即</p><script type="math/tex; mode=display">\left[\begin{array}{cccccc}{2} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\{0} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\{0} & {0} & {\binom{k-1}{0}} & {\binom{k-1}{1}} & {\cdots} & {\binom{k-1}{k-1}} \\{0} & {0} & {0} & {\binom{k-2}{0}} & {\cdots} & {\binom{k-2}{k-1}} \\{\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} \\{0} & {0} & {0} & {0} & {0} & {\binom{0}{0}}\end{array}\right]\times\left[\begin{array}{c}{s_n} \\{n^{k}} \\{n^{k-1}} \\{n^{k-2}} \\{\vdots} \\{n^{0}}\end{array}\right]=\left[\begin{array}{c}{s_{n+1}} \\{(n+1)^{k}} \\{(n+1)^{k-2}} \\{\vdots} \\{(n+1)^{0}}\end{array}\right]</script><p>然后就可以愉快地矩乘了。</p><p>不过似乎有个性质值得注意，就是本身这个转移矩阵就是一个上三角的形式，所以可能会存在什么有趣的东西…不得而知不得而知…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAK 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">ll N, K, Ans, T, C[MAK][MAK]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span> ; x %= Mod ;  </span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % Mod ; </span><br><span class="line">x = x * x % Mod, <span class="comment">/* pks */</span> y &gt;&gt;= <span class="number">1</span> ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">Ans = (T + expow(i, K)) % Mod, T = (T + Ans) % Mod ;</span><br><span class="line"><span class="keyword">return</span> Ans ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Ma&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> M[<span class="number">50</span>][<span class="number">50</span>] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; clear() ; <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= K + <span class="number">1</span> ; ++ i) M[i][i] = <span class="number">1</span> ; &#125;</span><br><span class="line">Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; <span class="keyword">int</span> P = K + <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= P ; ++ k)</span><br><span class="line">                    Ans.M[i][j] = (Ans.M[i][j] + <span class="number">1l</span>l * A.M[i][k] * B.M[k][j] % Mod ) % Mod ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">   Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">                    Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % Mod ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;P, Ans ; <span class="keyword">int</span> C[MAK][MAK] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.M[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) C[i][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">C[i][j] = (<span class="number">1l</span>l * C[i - <span class="number">1</span>][j] + <span class="number">1l</span>l * C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) P.M[<span class="number">1</span>][i + <span class="number">1</span>] = C[K][i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = i ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">P.M[i][j] = C[K + <span class="number">2</span> - i][j - i] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = K + <span class="number">2</span> ; i &gt;= <span class="number">1</span> ; -- i) Ans.M[i][<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">Matrix res ; res.reset() ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x ;</span><br><span class="line">x = x * x, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (y)&#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % Mod ;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % Mod, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">P.clear() ; Init() ; </span><br><span class="line">Matrix A1, A2, N1, N2 ;</span><br><span class="line">N1 = expow(P, N - <span class="number">2</span>), N2 = N1 * P ;  <span class="comment">/*</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= K + 2 ; ++ i, cout &lt;&lt; endl)</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt;= K + 2 ; ++ j)</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; P.M[i][j] &lt;&lt; " " ; */</span></span><br><span class="line"><span class="comment">//Matrix t = Ans * P ; </span></span><br><span class="line">A1 = N1 * Ans, A2 = N2 * Ans ; </span><br><span class="line"><span class="keyword">return</span> (A2.M[<span class="number">1</span>][<span class="number">1</span>] - A1.M[<span class="number">1</span>][<span class="number">1</span>] + Mod) % Mod ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; </span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">1000000</span>) <span class="built_in">cout</span> &lt;&lt; Solve1() ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (Ma :: Solve2()) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唉，比人会的我都不会，没有前途啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是整理“[HNOI2008]GT考试”和“[SNOI2017]礼物”两道题。由于实在找不出什么共同点来，所以就随便找了个理由把两道题放在一起了233&lt;/p&gt;
&lt;p&gt;从各个角度来看，都算是比较妙的设计方式了？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="字符串/KMP" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-KMP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】uoj#221 [NOI2016]循环之美</title>
    <link href="https://www.orchidany.cn/2020/02/18/NOI2016%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/"/>
    <id>https://www.orchidany.cn/2020/02/18/NOI2016循环之美/</id>
    <published>2020-02-18T02:51:45.000Z</published>
    <updated>2020-02-21T01:48:03.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n, m, k$，求有多少数值上互不相等的可以表示成 $\frac{x}{y}$ 的数， 满足 $1 ≤ x ≤ n$，$1 ≤ y ≤ m$，且其在 $k$ 进制下是纯循环小数。 </p><p>特别的，整数是纯循环小数。  $1 ≤ n, m ≤ 10^9,2 ≤ k ≤ 2000$ 。</p></blockquote><a id="more"></a><p>考虑本质上小数是如何产生的，发现就是当 $x/y$ 除到不能除时，$k$ 进制下，$x\times k$ 之后继续除下去。那么假设循环节长度为 $L$ ，那么会有 $x\bmod y=x\cdot k^L\bmod y$ 。也就是解得 $k^L\equiv1(\bmod y)$ 。那么由于逆元唯一，所以存在这样的一个 $L$，也就是存在逆元的充要条件就是 $k \perp y$ 。</p><p>并且由于不算重，还要求 $x\perp y$ 。所以最后本质上是要求：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]</script><p>随便反演一下</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]\\=&\sum_{i=1}^n\sum_{j=1}^m[j\perp k]\sum_{d|i\operatorname{and}d|j} \mu(d)\\=&\sum_{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor\cdot [d\perp k] \cdot \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} [j\perp k]\end{aligned}</script><p>考虑后面那个 $\sum$ 。若令</p><script type="math/tex; mode=display">f_n=\sum_{i=1}^n[i\perp k]</script><p>那么由于 $\gcd$ 的优秀性质 $\gcd(a,b)=\gcd(b,a\bmod b)$ 所以</p><script type="math/tex; mode=display">f_n=\lfloor\frac{n}{k}\rfloor\cdot f_{k}+f_{n\bmod k}</script><p>这个转移本质上是在做一个分块。</p><p>那么考虑前半部分这个 $\sum $ 。发现如果要数论分块的话，需要快速求</p><script type="math/tex; mode=display">s(n,k)=\sum_{i=1}^n\mu(i)\cdot [i\perp k]</script><p>这个东西。根据一个神奇的 $\mu$ 函数的性质 $\mu(ab)=[a\perp b]\mu(a)\mu(b)$，可以得到</p><script type="math/tex; mode=display">\begin{aligned}s(n,k)&=\sum_{i=1}^n\mu(i)\cdot [i\perp k]\\&=\sum_{i=1}^n\mu(i)\sum_{d|i\operatorname{and}d|k} \mu(d)\\&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d\cdot i) \\&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d)\cdot \mu(i)\cdot[i\perp d]\\&=\sum_{d|k} \mu^2(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)\cdot[i\perp d] \\&=\sum_{d|k} \mu^2(d) \cdot s(\lfloor\frac{n}{d}\rfloor,d) \end{aligned}</script><p>那么这东西显然可以用一个类杜教筛状物来做，大致就是当 $k=1$ 时本质上就是在做一个杜教筛，当 $k&gt;1$ 时只需要枚举 $x$ 的全部因子，这样转移最多有 $\sigma_0(k)$ 种，$k$ 也只会有 $\sigma_0(k)$ 个，递归做下去就好了。这样复杂度的上界是 $O(n^{\frac{2}{3}}+\sigma_0^2(k)\sqrt n)$ ，是一个极其松的上界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1001000</span> ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL G[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> mu[M] ;</span><br><span class="line"><span class="keyword">int</span> pr[M] ;</span><br><span class="line"><span class="keyword">int</span> smu[M] ;</span><br><span class="line"><span class="keyword">int</span> chk[M] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="built_in">map</span>&lt;pint, <span class="keyword">int</span>&gt; S ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!y) ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">F</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * ((n / k) * f[k] + f[n % k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; x) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">            mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n || (k == <span class="number">1</span> &amp;&amp; n &lt; M))</span><br><span class="line">        <span class="keyword">return</span> smu[n] ; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    pint t = mkp(n, k) ;</span><br><span class="line">    <span class="keyword">if</span> (S.count(t)) <span class="keyword">return</span> S[t] ;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">        ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = n / (n / l) ;</span><br><span class="line">            ans -= (r - l + <span class="number">1</span>) * s(n / r, k) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i * i &lt;= k ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mu[i]) ans += s(n / i, i) ;</span><br><span class="line">                <span class="keyword">if</span> (i * i != k &amp;&amp; mu[k / i])</span><br><span class="line">                    ans += s(n / (k / i), k / i) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S[t] = ans ; <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, last = <span class="number">0</span>, now ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ; now = s(r, k) ;</span><br><span class="line">        ans += (now - last) * (LL)(n / l) * F(m / l, k) ; last = now ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve(M - <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="keyword">bool</span>)(gcd(i, k) == <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve()) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n, m, k$，求有多少数值上互不相等的可以表示成 $\frac{x}{y}$ 的数， 满足 $1 ≤ x ≤ n$，$1 ≤ y ≤ m$，且其在 $k$ 进制下是纯循环小数。 &lt;/p&gt;
&lt;p&gt;特别的，整数是纯循环小数。  $1 ≤ n, m ≤ 10^9,2 ≤ k ≤ 2000$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/积性函数求和/杜教筛" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C-%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【泛学笔记】组合计数杂项</title>
    <link href="https://www.orchidany.cn/2020/02/17/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.orchidany.cn/2020/02/17/组合计数杂项/</id>
    <published>2020-02-17T09:34:17.000Z</published>
    <updated>2020-02-17T15:08:02.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是听课听来的组合计数相关.jpg</p><a id="more"></a><h2 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h2><p>$a\in \mathbb{R}$</p><script type="math/tex; mode=display">(x+y)^{a}=\sum_{k=0}^{\infty} \frac{a^{\underline k}}{k!} x^{k} y^{a-k}\\\</script><p>泰勒展开证明。</p><h2 id="抽屉原理一个比较有意思的表达"><a href="#抽屉原理一个比较有意思的表达" class="headerlink" title="抽屉原理一个比较有意思的表达"></a>抽屉原理一个比较有意思的表达</h2><p>把 $kx+b$ 个物品放进 $x$ 个盒子里 $(0&lt;b\leq k)$，必有 $1$ 个盒子里面至少有 $k+1$ 个物品。</p><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><script type="math/tex; mode=display">h_n=\binom{2n}{n}-\binom{2n}{n-1}</script><p>方格行走数。</p><p>瞎jb走，从$0,0$到$n,0$，共$2n$次决策，选$n$次向下。</p><p>减去走错了的，考虑我们第一次走到 $y=-1$ 这条直线上，关于这条直线把 $(n,0)$ 对称下来，然后就变成了从 $(0,0)$ 走到 $(n,-2)$ 的问题，即选择 $n-1$ 步向上，$n+1$ 步向下。</p><p>然后，我sd了，原因在于我思考了半天为什么减去的贡献不用 $\times 2$，因为这不对称，结果发现原来走到 $y=1$ 是合法的，艹，脑袋莫得了。</p><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>有符号的第一类斯特林数记作$\rm \mathrm{S}_s$，无符号记作$\rm \mathrm{S}_u$。</p><script type="math/tex; mode=display">\mathrm{S}_s(n,m)=(-1)^{n+m}\mathrm{S}_u(n,m)</script><p>圆排列方案数。</p><p>同时 $\rm \mathrm{S}_s$ 的生成函数是 $x^{\underline{n}}$，即固定 $n$ 不变时，$\rm \mathrm{S}_s$ 的 $m$ 在 $1\to \infty$ 时的生成函数是 $x$ 的 $n$ 次下降幂。</p><p>（$n$ 固定下来之后的某一行）</p><h2 id="第二类斯特林数："><a href="#第二类斯特林数：" class="headerlink" title="第二类斯特林数："></a>第二类斯特林数：</h2><script type="math/tex; mode=display">\begin{array}{l}{\mathrm{S}(n, m)=\mathrm{S}(n-1, m-1)+m * \mathrm{S}(n-1, m)} \\\ {\mathrm{S}(n, m)=\frac{1}{m !} \sum(-1)^{k}\left(\begin{array}{c}{m} \\ {k}\end{array}\right)(m-k)^{n}}\end{array}</script><p>贝尔数为第二类斯特林数之和，即把 $n$ 个数拆成 $k~(k\in \mathbb{N+})$ 集合的方案数之和。</p><p>ps：二斯都是不带标号的，似乎因为定义出来也没啥意义吧。</p><h2 id="拆分数的非OGF做法"><a href="#拆分数的非OGF做法" class="headerlink" title="拆分数的非OGF做法"></a>拆分数的非OGF做法</h2><p>第二类斯特林数实际上是<strong>$\boldsymbol{n}$带标号（n个不同物品），$\boldsymbol{m}$不带标号</strong>。</p><p>当$n,m$都无标号时，这个问题实际上就是<strong>拆分数</strong>问题，即$3=2+1$只代表一种情况，而如果有标号的话应该是三种情况（$C_3^2$）.</p><p>那么对于这个问题，考虑两种$dp$.</p><ul><li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：<script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}+f_{i-j,j}</script>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢到一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</li><li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：<script type="math/tex; mode=display">g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</li></ul><p>嗯，所以有时候状态的转移与设计存在“高阶状态对低阶状态有天然的累加效应”，换个不严谨的措辞就是<code>+</code>运算使得存在状态间的的相互归约。这是设计状态中需要考虑的一个新奇的东西。</p><p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p><h2 id="LOJ-6268-分拆数"><a href="#LOJ-6268-分拆数" class="headerlink" title="LOJ 6268 分拆数"></a>LOJ 6268 分拆数</h2><p>发现是 <code>#6</code> 的升级版。</p><p>考虑根号分治。先用 $f$ 求出来 $j\leq \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字，具体就是第一维把 $\sqrt n$ 当作步长转移即可。</p><p>之后考虑合并这两个转移。发现最后转移完做一个累加，统计出两个多项式来，分别代表凑出体积 $i$ 的方案数。那么两个多项式的合并就是一个卷积的形式，就直接 $\rm NTT$ 做就完了。</p><h2 id="连通图计数"><a href="#连通图计数" class="headerlink" title="连通图计数"></a>连通图计数</h2><p>定义连通图的 $\rm EGF$ 为 $F(x)$，任意图的 $\rm EGF$ 为 $G(x)$ 。</p><p>考虑</p><script type="math/tex; mode=display">G(x)=\sum_{n \geq 0} \frac{2^{n(n-1) / 2}}{n !} x^{n}</script><p>那么考虑一定有 $G(x)=e(F(x))$ ，即 $F(x)=\ln G(x)$ 。</p><p>这是因为任意图本身由任意个连通图构成，即考虑 $G$ 的另一种组成方式，从分成的连通块个数进行讨论。那么由 $n$ 个连通块构成的图，应该至少有 $F^n$ ，并且由于带标号且无序，所以 $F$ 应该用指数生成函数来刻画。</p><p>也就是从连通块的角度来考虑：</p><script type="math/tex; mode=display">G=\sum\frac{F^n}{n!}</script><p>然后就可以肥宅快乐 $\exp$ 了。</p><p>大概类似于变换组合对象构造恒等式这种操作。</p><h2 id="Best-Theorem"><a href="#Best-Theorem" class="headerlink" title="Best Theorem"></a>Best Theorem</h2><p>一个有向图G，欧拉回路的数量是</p><script type="math/tex; mode=display">t_{1}(G) * \prod_{i=1}^{n}(\operatorname{deg}(i)-1) !</script><p>其中 $t_1(G)$ 表示 $G$ 中以 $1$ 为根的生成树的数量。</p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote><p>给定一个 $n$ 个点 $m$ 条边的图，每条边有长度 $d_i$ 和价值 $v_i$。 随机选出一个长度和最小的生成树，求价值和的期望。 </p><p>$n, m ≤ 50$</p></blockquote><p>考虑如果长度都是 $1$（或者所有边长度均相同，本质是一样的），那么可以很方便地从每条边的贡献入手。大致就是考虑删掉一条边，用剩下的求一遍生成树计数，那么就可以算出这条边被选上的概率，这样就可以一条边一条边的计算贡献。复杂度 $mn^3$。</p><p>如果不是，那么考虑按照权值递增的顺序做如下过程：把当前最小的边拿出来，这样会是多个联通块。考虑在最后的生成树中，这样的边的权值一定会体现在其中，所以相当于每个联通块内选出一棵树，由于现在边权相等所以做法可以先用上一段里的方法。之后考虑把这个联通块缩成一个点，继续做下去，直到边满了为止。</p><p>似乎这样做不是很需要注意细节。因为本质上就是在重复一个贪心MST的过程。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>给定一张 $n$ 个点，$m$ 条边的无向图，每条边有红绿蓝三种颜色，要求绿边数量不超过 $g$, 蓝边不超过 $b$ 的生成树数量，答案对 $10^9 + 7$ 取模 </p><p>$n ≤ 40$</p></blockquote><p>考虑给每条绿边一个权值变量 $x$, 每条蓝边一个权值变量 $y$，根据扩展 MT 定理，最终只需要对着 $xy$ 的次数找系数即可。</p><p>而问题在于如何求这样一个行列式。考虑带入 $n^2$ 对点值给 $x$ 和 $y$，最终使用这些点值进行二维插值，恢复出本来的多项式。复杂度似乎是 $O(n^5)+O(n^4\sim n^6)$ 。</p><p><del>二维插值怎么可能会的嘛，所以复杂度不重要，反正我也不会去写。</del></p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><blockquote><p>给定一个带权无向图，定义一棵生成树的权值是边权和的 $k$ 次方，求所有生成树的权值和，答案对 $10^9 + 7$ 取模。 </p><p>$n, k ≤ 50$</p></blockquote><p>一步转化，考虑一堆数的 $k$ 次方等价于从这堆数里选出 $k$ 个可重复的数字的积 (考虑顺序)，再求和。 </p><p>那么可以将每条边的边权重新定义一个多项式 </p><script type="math/tex; mode=display">∑^k_{i=0}\frac{(vx)^i}{i!}</script><p>表示一条边所代表的权值具体被选了若干次的权值。对新的权值使用 <code>Matrix-tree</code>, 得到一个 $nk$ 次的多项式，$x_k$ 的系数乘上 $k!$ 就是答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是听课听来的组合计数相关.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="泛学" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%AD%A6/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="组合计数/斯特林数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part3</title>
    <link href="https://www.orchidany.cn/2020/02/15/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>https://www.orchidany.cn/2020/02/15/《母函数》学习笔记3/</id>
    <published>2020-02-15T12:11:00.000Z</published>
    <updated>2020-02-17T09:33:50.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是整理一下「伯努利数」吧…</p><p>其实还有一块关于切比雪夫不等式的内容，但是我觉得不是很有意思，决定不整理了.jpg</p><a id="more"></a><h1 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>考虑用母函数的方式定义。此处直接定义伯努利数的指数型母函数是：</p><script type="math/tex; mode=display">\mathbf B=\frac{x}{e(x)-1}</script><p>那么考虑如何展开。记伯努利数为 $\{B_n\}$。发现移一下项</p><script type="math/tex; mode=display">x=\left(B_0+B_1x+\frac{B_2}{2!}x^2\cdots\right) * \left(e(x)-1\right)</script><p>如果记右边卷出来的结果是 $\{a_n\}$，那么发现</p><script type="math/tex; mode=display">a_n=\sum_{k=0}^{n-1}\binom{n}{k}B_k</script><p>此处上界为 $n-1$ 的原因是 $\left(e(x)-1\right)_0=0$ ，其余项均为 $1$ 。 </p><p>比较同次项系数可知</p><script type="math/tex; mode=display">B_0=1\\\sum_{k=0}^{n-1}\binom{n}{k}B_k=0\qquad (n=2,3,4\cdots)</script><p>考虑用这个方程去递推每一项。大致思路是左右两边同时加上 $B_n$ 。</p><script type="math/tex; mode=display">\sum_{k=0}^{n}\binom{n}{k}B_k=B_n</script><p>然后就可以发现，比如拿 $n=2$ 举例：</p><script type="math/tex; mode=display">B_0+2B_1+B_2=B_2</script><p>就可以消掉 $B_2$ 求出 $B_1$。以此类推，每次用 $n$ 可以消出 $B_{n-1}$ 。</p><h2 id="一个小性质"><a href="#一个小性质" class="headerlink" title="一个小性质"></a>一个小性质</h2><p>考虑 $B_n$ 的性质，发现推出来的大概长这样：</p><script type="math/tex; mode=display">\begin{aligned}&B_0=1\\&B_1=-\frac{1}{2}\\&B_2=\frac{1}{6}\\&B_3=0\\&B_4=-\frac{1}{30}\\&B_5=0\\&B_6=\frac{1}{42}\\&B_7=0\\&B_8=-\frac{1}{30}\\&B_9=0\\&B_{10}=\frac{5}{66}\\&\cdots\end{aligned}</script><p>发现似乎，除了 $B_1$ 之外，其余 $n$ 为奇数的时候均为 $0$ 。证明考虑：</p><script type="math/tex; mode=display">\frac{x}{e(x)-1}=\sum \frac{B_n}{n!}x^n=1-\frac{x}{2}+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>那么如果令</p><script type="math/tex; mode=display">f(x)=\frac{x}{e(x)-1}+\frac{x}{2}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}f(-x)&=\frac{-x}{e(-x)-1}-\frac{x}{2}\\&=\frac{-x}{\frac{1}{e(x)}-1}-\frac{x}{2}\\&=\frac{-xe(x)}{1-e(x)}-\frac{x}{2}\\&=x-\frac{x}{1-e(x)}-\frac{x}{2}\\&=\frac{x}{e(x)-1}+\frac{x}{2}\\&=f(x)\end{aligned}</script><p>可知 $f(x)$ 是偶函数，那么也就是 </p><script type="math/tex; mode=display">1+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>是偶函数。考虑他是偶函数的条件，当且仅当所有奇次幂系数都为 $0$ 的时候，才会是偶函数。所以可以证明上面的结论。</p><h2 id="伯努利多项式"><a href="#伯努利多项式" class="headerlink" title="伯努利多项式"></a>伯努利多项式</h2><p>考虑观察下列两个EGF的卷积：</p><script type="math/tex; mode=display">\frac{x}{e(x)-1}*e(tx)</script><p>其中 $t$ 是任意常数。考虑记卷积结果为 $\beta(t)$ 。那么显然</p><script type="math/tex; mode=display">\beta_n(t)=\sum_{k=0}^n\binom{n}{k}B_kt^{n-k}</script><p>记这样的多项式为伯努利多项式。这个多项式有个很有用的性质：</p><script type="math/tex; mode=display">\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)\qquad(n=0,1,2,3\cdots)</script><p>考虑直接做差法证明。首先设出两个式子：</p><script type="math/tex; mode=display">\frac{xe(tx)}{e(x)-1}=\sum\frac{\beta_n(t)}{n!}x^n\qquad(1)\\\frac{xe((t+1)x)}{e(x)-1}=\sum\frac{\beta_n(t+1)}{n!}x^n\qquad(2)\\</script><p>$(2)-(1)$ 得到</p><script type="math/tex; mode=display">\frac{xe(tx)[e(x)-1]}{e(x)-1}=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>即</p><script type="math/tex; mode=display">xe(tx)=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>比较系数可知</p><script type="math/tex; mode=display">\frac{\beta_n(t+1)-\beta_n(t)}{n!}=\frac{t^{n-1}}{(n-1)!}</script><p>变一下形就可以得到：</p><script type="math/tex; mode=display">\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)</script><h2 id="用伯努利多项式求自然数的-k-次方和"><a href="#用伯努利多项式求自然数的-k-次方和" class="headerlink" title="用伯努利多项式求自然数的 $k$ 次方和"></a>用伯努利多项式求自然数的 $k$ 次方和</h2><p>考虑决定自然数 $k$ 次方的要素在于下标 $n$ 。于是考虑所有自然数的 $k$ 次方和就是这样：</p><script type="math/tex; mode=display">(k+1)\mathbf S^{(k)}=\sum_{i=1}^{\infty}\left(\beta_{k+1}(i+1)-\beta_{k+1}(i)\right)</script><p>展开之后</p><script type="math/tex; mode=display">\mathbf S_n^{(k)}=\frac{\left(\beta_{k+1}(n+1)-\beta_{k+1}(1)\right)}{k+1}</script><p>也就是</p><script type="math/tex; mode=display">\mathbf S_n^{(k)}=\frac{1}{k+1}\sum_{r=1}^{k+1}\binom{k+1}{r}B_{k+1-r}(n+1)^{r}</script><p>其中 $r=0$ 时减掉了 $\beta_{k+1}(1)$ 这一项。</p><p>发现本质上可以 $k\log k$ 用 $\exp$ 来预处理伯努利数，然后就可以 $O(k)$ 算不限制 $n$ 时的 $k$ 次方和了。</p><p>emmm似乎预处理也不用 $\rm exp$ ，$e(x)-1$ 直接写出来，然后直接多项式求逆就可以了？</p><p>但显然这个方法被线性插值给爆锤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是整理一下「伯努利数」吧…&lt;/p&gt;
&lt;p&gt;其实还有一块关于切比雪夫不等式的内容，但是我觉得不是很有意思，决定不整理了.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="数学/伯努利数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part2</title>
    <link href="https://www.orchidany.cn/2020/02/14/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://www.orchidany.cn/2020/02/14/《母函数》学习笔记2/</id>
    <published>2020-02-14T04:04:10.000Z</published>
    <updated>2020-02-17T09:33:43.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是从「特征多项式」整理到「指数型母函数及其应用」。</p><a id="more"></a><h1 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>考虑对于一个以 $\{c_i\}$ 为递推转移的 $k$ 阶线性循环数列 $\{a_i\}$ 的母函数，根据构造似乎可以被写成这样的形式：</p><script type="math/tex; mode=display">\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k}</script><p>$\{b_i\},m$ 都是根据实际情况会变的参数。</p><p>那么可以发现这样的恒等的关系：</p><script type="math/tex; mode=display">\begin{aligned}\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k}&=a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots\\b_0+b_1x+b_2x^2\cdots b_{m}x^{m}&=(a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots)\times(1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k)\\\end{aligned}</script><p>即</p><script type="math/tex; mode=display">\begin{aligned}&b_0=a_0,\\&b_1=a_1-c_1a_0,\\&b_2=a_2-c_1a_1-c_2a_0\\&\cdots,\\&b_{k-1}=a_{k-1}-\sum_{i=1}^{k-1}c_ia_{k-1-i},\\&\cdots,\\ &b_p=a_p-\sum_{i=1}^{k}c_i=0\quad \mathrm{if}~(p\geq k) \end{aligned}":</script><p>可以发现分子上的多项式至多有 $k-1$ 次.</p><p>像这种根据递推方式快速确定的一个线性循环数列母函数的方法，称为特征法。而多项式</p><script type="math/tex; mode=display">1-c_1x-c_2x^2-\cdots c_kx^k</script><p>则称为 $\{a_i\}$ 的特征多项式。</p><p>e.g.</p><blockquote><p>求</p><script type="math/tex; mode=display">a_n=a_{n-1}+9a_{n-2}-9a_{n-3},a_0=1,a_1=1,a_2=2</script><p>的通项。</p></blockquote><hr><p>首先分解因式</p><script type="math/tex; mode=display">(1-x-9x^2-9x^3)=(1-3x)(1+3x)(1-x)</script><p>并且观察到 $b_0=1,b_1=0,b_2=-8$。</p><p>那么不妨设</p><script type="math/tex; mode=display">\frac{a}{1-3x}+\frac{b}{1+3x}+\frac{c}{1-x}=\frac{1-8x^2}{1-x-9x^2-9x^3}</script><p>解得</p><script type="math/tex; mode=display">a=\frac{1}{12},b=\frac{1}{24},c=\frac{7}{8}</script><p>那么就可以知道 $\frac{1-8x^2}{1-x-9x^2-9x^3}$ 的展开是：</p><script type="math/tex; mode=display">\sum_{n=1}^{\infty}(\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8})x^n</script><p>那么通项就是</p><script type="math/tex; mode=display">a_n=\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8}</script><h2 id="非齐次"><a href="#非齐次" class="headerlink" title="非齐次"></a>非齐次</h2><p>非齐次的话，可以直接把常数构造在系数里，本质上没什么不同的。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>（1）用 $1,2,3$ 三个数来构造一个 $n$ 位数。不允许两个 $1$ 相邻，求方案数。</p></blockquote><p>发现如果第一位放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-1}$ 的方案；如果放 $1$，那么第二维只能放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-2}$ 的方案。所以有 $a_n=2a_{n-1}+2a_{n-2}$ 。</p><blockquote><p>（2）有一行方格，每个格子可以放黑色或者白色，白色不能相邻地放。求方案树。</p></blockquote><p>发现还是讨论第一个位置放的是不是白色。$f_n=f_{n-1}+f_{n-2}$ 。</p><h1 id="高阶差分"><a href="#高阶差分" class="headerlink" title="高阶差分"></a>高阶差分</h1><h2 id="一点定义"><a href="#一点定义" class="headerlink" title="一点定义"></a>一点定义</h2><p>定义 $\{a_i\}$ 的一阶差分 $\Delta^1\{a_i\}$ 是这样的数列 $\{a_1-a_0,a_2-a_1,\cdots,a_n-a_{n-1}\}$ 。</p><p>那么 $k$ 阶差分指的是 $\Delta^k\{a_i\}=\Delta\{\Delta^{k-1}\{a_i\}\}$ 。</p><p>假设一个数列 $\{a_i\}$ 在 $k$ 阶差分时不是全 $0$ 数列，在 $k+1$ 阶差分时是全 $0$ 数列，那么称这个数列为 $k$ 阶等差数列。</p><h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><blockquote><p> 如果记 $\Delta^k\{a_i\}:\{a_0^{(k)},a_1^{(k)},a_2^{(k)},\cdots,a_n^{(k)}\cdots \}$，那么有：</p><script type="math/tex; mode=display">\begin{aligned}a_n^{(k)}&=a_{n+k}-\binom{k}{1}a_{n+k-1}+\binom{k}{2}a_{n+k-2}-\cdots+(-1)^ka^n\\&=\sum_{i=0}^k(-1)^i\binom{k}{i}a_{n+k-i}\end{aligned}</script></blockquote><p>这个显然可以直接归纳。就懒得证了。</p><h2 id="k-阶等差数列-a-n-的前-n-项和。"><a href="#k-阶等差数列-a-n-的前-n-项和。" class="headerlink" title="$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。"></a>$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。</h2><p>考虑对于数列 $\{s_n\}$ ，满足 $s_i=\sum_{j=0}^ia_i$，那么发现可以直接让 $\{a_n\}*(\frac{1}{1-x})$ 得到 $\{s_n\}$</p><script type="math/tex; mode=display">\left(\sum a_nx^n\right)*\left(\sum x^n\right)=\sum_{n=0}^{\infty}\left(\sum_{j=0}^n a_j\right)x=\sum s_nx^n</script><p>所以假设 $\{a_n\}$ 的母函数是 $f(x)$，那么 $\{s_n\}$ 的母函数就是 $\frac{f(x)}{1-x}$。</p><p>那么考虑如何计算 $f(x)$ 。根据性质可知：</p><script type="math/tex; mode=display">a_n^{(k+1)}=a_{n+k+1}-\binom{k+1}{1}a_{n+k}+\binom{k+1}{2}a_{n+k-1}-\cdots+(-1)^{k+1}a^n</script><p>那么由于 $a_{n}^{(k+1)}=0$ ，所以可以得到：</p><script type="math/tex; mode=display">a_{n+k+1}=\binom{k+1}{1}a_{n+k}-\binom{k+1}{2}a_{n+k-1}+\cdots-(-1)^{k+1}a^n</script><p>发现本质上 $\binom{k+1}{x}$ 属于常数项。所以可以知道 $\{a_n\}$ 是一个 $k+1$ 个线性循环数列。所以可以用特征法直接求出。</p><p>但其实这种方法有时候比归纳要麻烦很多。这种方法主要用来解决一些比较妙的问题。</p><h2 id="一点应用"><a href="#一点应用" class="headerlink" title="一点应用"></a>一点应用</h2><p>e.g.</p><blockquote><p> 给定 $n$ ，求坐标系中 $|x|+|y|=m,(m=0,1,2,3\cdots n)$ 的 $(x,y)$ 点对数。</p></blockquote><p>考虑设 $\{a_i\}$ 表示 $i=m$ 时的方案数，$\{s_i\}$ 即为所求。那么可以知道 $a_i$ 的母函数为：</p><script type="math/tex; mode=display">f(x)=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2</script><p>看上去十分 $easy$，因为每个坐标有$+-$ 两种取值，所以加一个系数 $2$ 。</p><p>那么发现可以这么转化：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2\\&=(1+2x(1+x+x^2+\cdots+x^n+\cdots))^2\\&=(1+\frac{2x}{1-x})^2\\&=(\frac{1+x}{1-x})^2\end{aligned}</script><p>所以 $\{s_n\}$ 的母函数 $f_s(x)$ 为</p><script type="math/tex; mode=display">f_s(x)=\frac{f(x)}{1-x}=\frac{(x+1)^2}{(1-x)^3}</script><p>发现 $(1-x)$ 是它的 $3$ 重根，所以有：</p><script type="math/tex; mode=display">f_s(x)=\frac{4}{(1-x)^3}-\frac{4}{(1-x)^2}+\frac{1}{1-x}</script><p>那么可以展开得到：</p><script type="math/tex; mode=display">f_s(x)=\sum_{i=0}^{\infty}\left[4\binom{n+2}{2}-4(n+1)+1\right]x^n</script><p>于是可知 $s_n=2n^2+2n+1$ 。</p><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>首先发现卡特兰数的定义式就是</p><script type="math/tex; mode=display">a_n=\sum_{k=1}^{n}a_{n-k}a_{k}</script><p>那么这东西的母函数大概可以这么求（默认第 $0$ 为位是 $0$ 而不考虑）：</p><script type="math/tex; mode=display">\begin{aligned}f^2(x)&=\left(\sum a_ix^i\right)^2\\&= a_1^2x^2+(a_1a_2+a_2a_1)x^3+(a_1a_3+a_2a_2+a_3a_1)x^4\cdots+\left(\sum_{i=1}^{n}a_{i}a_{n-i}\right) x^n+\cdots\\&=f(x)-a_1x\end{aligned}</script><p>那么解一下方程可以得到俩根：</p><script type="math/tex; mode=display">f_1(x)=\frac{1-\sqrt{1-4x}}{2},f_2(x)=\frac{1+\sqrt{1-4x}}{2}</script><p>验一下发现应该取 $f_1$.</p><p>在不考虑牛顿迭代的情况下，不加证明地给出一个等式：</p><script type="math/tex; mode=display">\sqrt{1+x}=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1} x^{n}</script><p>那么代换一下可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{1-4 x} &=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1}(-4 x)^{n} \\&=1+\sum_{n=1}^{\infty} \frac{(-1)^{2 n-1}}{n 2^{2 n-1}} 4^{n} \binom{2(n-1)}{n-1} x^{n} \\&=1-\sum_{n=1}^{\infty} \frac{2}{n} \binom{2(n-1)}{n-1} x^{n}\end{aligned}</script><p>再带回去得到：</p><script type="math/tex; mode=display">f(x)=\sum_{n=1}^{\infty}\frac{\binom{2(n-1)}{n-1}}{n} x^n</script><p>那么可知卡特兰数第 $n$ 项 $\mathrm{Cat}_n=\frac{\binom{2(n-1)}{n-1}}{n}$。</p><p>当然一般情况下 $\rm Cat$ 的定义有从 $0$ 开始的，只是把这种方式向前平移了一项而已。</p><h1 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h1><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>出于需要，定义另一种生成函数，即指数型母函数 $(\mathbf{EGF})$ 。对于数列 $\{a\}$，他的 $\rm EGF$  是：</p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n</script><p>那么可以得出两个 $\rm EGF$ 卷积的结果是：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n&= \left(\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n\right)\cdot \left(\sum_{n=0}^{\infty}\frac{b_n}{n!}x^n\right)\\&= \sum_{n=0}^{\infty} x^n\sum_{i+j=n}\frac{a_ib_j}{i!j!}\\&= \sum_{n=0}^{\infty} \frac{1}{n!}x^n\sum_{i+j=n}\left(a_ib_j\cdot\frac{n!}{i!j!}\right)\\\end{aligned}</script><p>可以发现有</p><script type="math/tex; mode=display">c_n=\sum_{k=0}^n\binom{n}{k}a_kb_{n-k}</script><p>那么之所称之为指数型母函数，则依赖于下面的性质：</p><p>令</p><script type="math/tex; mode=display">e(x)=1+x+\frac{x^2}{2!}+\cdots +\frac{x^n}{n!}+\cdots</script><p>可以发现有</p><script type="math/tex; mode=display">e(x)e(y)=e(x+y)</script><p>证明大概是可以把 $e(y)$ 改写成</p><script type="math/tex; mode=display">e(y)=\sum \frac{1}{n!}(\frac{y}{x})^nx^n</script><p>然后</p><script type="math/tex; mode=display">\begin{aligned}e(x)e(y)&=\left(\sum \frac{1}{n!}x^n\right)\cdot \left[\sum \frac{1}{n!}(\frac{y}{x})^nx^n\right]\\&=\sum \frac{\sum_{k=0}^n\binom{n}{k}\cdot (\frac{y}{x})^k}{n!}x^n\\&=\sum \frac{(1+\frac{y}{x})^n}{n!}x^n\\&=\sum \frac{\frac{1}{x^n}(x+y)^n}{n!}x^n\\&=\sum \frac{(x+y)^n}{n!}\\&= e(x+y)\end{aligned}</script><p>发现这种性质类似于指数运算的性质，所以称之为指数型母函数。</p><p>同时可知，令 $y=-x$ 则有 $e(x)=\frac{1}{e(-x)}$ 。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><blockquote><p>设 $\{a_n\}$ 给定，且</p><script type="math/tex; mode=display">b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i</script><p>则必有</p><script type="math/tex; mode=display">a_n=\sum_{i=0}^n\binom{n}{i}(-1)^ib_i</script></blockquote><p>考虑让数列 $\{(-1)^na_n\}$ 的母函数卷上 $e(x)$ 得到：</p><script type="math/tex; mode=display">e(x)*\sum\frac{(-1)^na_n}{n!}x^n=\sum\frac{\sum_{k=0}^n\binom{n}{k}(-1)^ka_k}{n!}x^n=\sum\frac{b_n}{n!}x^n</script><p>也就是</p><script type="math/tex; mode=display">\sum\frac{(-1)^na_n}{n!}x^n=\frac{1}{e(x)}*\sum\frac{b_n}{n!}x^n</script><p>因为 $\frac{1}{e(x)}=e(-x)$ ，所以有：</p><script type="math/tex; mode=display">\sum\frac{(-1)^na_n}{n!}x^n=\sum(-1)^n\frac{\sum_{k=0}^n\binom{n}{k}(-1)^kb_k}{n!}x^n</script><p>对比第 $n$ 项即可得到</p><script type="math/tex; mode=display">a_n=\sum_{k=0}^n\binom{n}{k}(-1)^kb_k</script><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><script type="math/tex; mode=display">\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=-\frac{1}{n}</script><p>首先有一个比较 <code>general</code> 的结论：</p><script type="math/tex; mode=display">\sum_{k=0}^n\frac{(-1)^k}{k+1}\binom{n}{k}=\frac{1}{n+1}\qquad(1)</script><p>这是由于</p><script type="math/tex; mode=display">\binom{n+1}{k+1}=\frac{n+1}{k+1}\binom{n}{k}</script><p>那么稍微变一下形态：</p><script type="math/tex; mode=display">\sum_{k=0}^n(-1)^k\frac{n+1}{k+1}\binom{n}{k}=\sum_{k=1}^{n+1}(-1)^k\binom{n+1}{k}=1+(1-1)^n=1</script><p>移个项就完了。</p><p>那么根据这个可以再证明出一个更强一点的结论：</p><script type="math/tex; mode=display">\sum_{k=1}^n\frac{(-1)^{k-1}}{k}\binom{n}{k}=1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\qquad (2)</script><p>考虑直接归纳。不难验证 $n=1$ 成立。那么考虑 $n\to n+1$ 的过程</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\binom{n+1}{k}\\=&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\left(\binom{n}{k}+\binom{n}{k-1}\right)\\=&\sum_{k=1}^{n}\frac{(-1)^{k-1}}{k}\binom{n}{k}+\sum_{k=0}^{n}\frac{(-1)^{k+1}}{k}\binom{n}{k}\\=&\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)+\frac{1}{n+1}\end{aligned}</script><p>其中最后一步用的就是上面的 $(1)$。</p><p>那么回到本题，考虑设 $a_0=0, a_n=-\frac{1}{n}\quad (n=1,2,3\cdots )$ 。同时设 $b_0=0$，</p><script type="math/tex; mode=display">b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i=\sum_{i=0}^n\frac{(-1)^{i+1}}{i}\binom{n}{i}</script><p>那么根据 $(2)$ 和二项式反演可以得到</p><script type="math/tex; mode=display">b_n=\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)\\\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=\sum_{k=1}^n(-1)^kb_k=a_n=-\frac{1}{n}</script><h1 id="指数型母函数的应用"><a href="#指数型母函数的应用" class="headerlink" title="指数型母函数的应用"></a>指数型母函数的应用</h1><h2 id="有限制的可重排列问题"><a href="#有限制的可重排列问题" class="headerlink" title="有限制的可重排列问题"></a>有限制的可重排列问题</h2><blockquote><p>给定 $n$ 个物品，从中取 $r$ 个进行排列，第 $k~(k=1,2,3\cdots m)$ 种物品有 $n_k$ 个，求排列方案数。</p></blockquote><p>首先给出这东西的母函数：</p><script type="math/tex; mode=display">f_e(x)=\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_1}}{n_1!}\right)*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_2}}{n_2!}\right)*\cdots*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_m}}{n_m!}\right)</script><p>考虑这样表示的意义。对于 $f_e(x)$ 的第 $r+1$ 项，有：</p><script type="math/tex; mode=display">[x^r]f_e(x)=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}</script><p>其中 $\{d_m\}$ 可以看做是满足 $d_1+d_2+\cdots+d_m=r$ 的一组枚举量。</p><p>考虑这样做的可行性。首先变一下形</p><script type="math/tex; mode=display">\begin{aligned}&[x^r]f_e(x)\\&=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}\\&=\frac{r!}{\prod d_i!}\cdot\frac{x^r}{r!}\end{aligned}</script><p>发现第 $r+1$ 项的系数 $\frac{r!}{\prod d_i!}$，正好是从 $r$ 个物品中，共 $m$ 中，每种分别有 $d_i$ 个，取满 $r$ 个的方案数。所以正确性显然。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>用 $1,2,3,4$ 四个数字能组成多少五位数？要求 $1$ 只能出现 $2$ 或 $3$ 次，$2$ 出现 $0$ 或 $1$ 次，$3$ 没有限制， $4$ 出现偶数次。</p></blockquote><p>这个问题的母函数显然就是这个：</p><script type="math/tex; mode=display">f_e(x)=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot \left(1+x\right)\cdot e(x)\cdot \left[1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots\right]</script><p>考虑一个性质</p><script type="math/tex; mode=display">1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots=\frac{e(x)+\frac{1}{e(x)}}{2}</script><p>那么原式就变成了</p><script type="math/tex; mode=display">\begin{aligned}f_e(x)&=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\cdot e(x)\cdot \frac{1}{2}\left(e(x)+\frac{1}{e(x)}\right)\\&=\frac{e(2x)}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)+\frac{1}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\end{aligned}</script><p>发现本质上右边不存在 $x^5$ 这一项，所以忽略。</p><p>于是最后通过化简可知答案是 $140$ .</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分大概是从「特征多项式」整理到「指数型母函数及其应用」。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="数学/常系数齐次线性递推" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】母函数Part1</title>
    <link href="https://www.orchidany.cn/2020/02/13/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/02/13/《母函数》学习笔记/</id>
    <published>2020-02-13T02:23:17.000Z</published>
    <updated>2020-02-21T13:17:52.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是好久之前的学习笔记？</p><p>边复习边发吧。其实MO再不做题的时候，拿来磨磨脑子也挺有意思的。</p><p>这一部分大概是从「基础组合计数」到「一般型母函数」，再到「线性循环数列」。</p><a id="more"></a><h1 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h1><h2 id="一点瞎扯"><a href="#一点瞎扯" class="headerlink" title="一点瞎扯"></a>一点瞎扯</h2><p>考虑二项式定理 $(x+y)^n=\sum\binom{n}{i}x^iy^{n-i}$，由于展开成了二元多项式的形式，所以存在卷积性质。利用此或可证明一些东西。</p><h2 id="一点有趣的证明题"><a href="#一点有趣的证明题" class="headerlink" title="一点有趣的证明题"></a>一点有趣的证明题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote><p>证明：</p><script type="math/tex; mode=display">\sum_{x=1}^n x\cdot\binom{n}{x}=n\cdot 2^{n-1}</script></blockquote><p>考虑一个式子：$\binom{n}{k}=\frac{n}{k}\binom{n-1}{k-1}$。那么对于原式的右边就可以化成</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{x=1}^n x\cdot\binom{n}{x}\\=&\sum_{x=1}^n n\cdot \binom{n-1}{x-1}\\=&n\cdot 2^{n-1}\end{aligned}</script><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>证明</p><script type="math/tex; mode=display">\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}</script></blockquote><p>考虑 $(1+x)^{n+1}$ 的两种展开方式：</p><script type="math/tex; mode=display">\begin{aligned}(1+x)^{n+1}=&\sum \binom{n+1}{i+1}x^{i+1}\\(1+x)^{n+1}=&(1+x)\sum \binom{n}{i}x^{i}\\=&\sum \binom{n}{i}\left(x^{i}+x^{i+1}\right)\\=&\sum \left(\binom{n}{i}+\binom{n}{i+1}\right)x^{i+1}\end{aligned}</script><p>比较两个多项式中 $i+1$ 项的系数，可知证毕。</p><h1 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h1><h2 id="关于-frac-1-1-x"><a href="#关于-frac-1-1-x" class="headerlink" title="关于 $\frac{1}{1-x}$"></a>关于 $\frac{1}{1-x}$</h2><p>设该商为 $\sum c_nx^n$。那么有</p><script type="math/tex; mode=display">1=(1-x)\sum c_ix^i\\1=c_0+\sum(c_i-c_{i-1})x^i\\</script><p>可知 $c_0=1,c_i=c_{i-1}$ 。所以每一项的系数都为 $1$ 。故有形式幂级数基本定理：</p><script type="math/tex; mode=display">1+x+x^2+x^3\cdots=\frac{1}{1-x}</script><h2 id="一系列求母函数例子"><a href="#一系列求母函数例子" class="headerlink" title="一系列求母函数例子"></a>一系列求母函数例子</h2><script type="math/tex; mode=display">\begin{aligned}\{C_n^{n},C_{n+1}^n,C_{n+2}^{n}\cdots\}&\to\sum \binom{n+i}{n}x^i=\frac{1}{(1-x)^{n+1}}\\\{1,5,25,125\cdots\}&\to\sum 5^ix^i=\sum{5x^i}=\frac{1}{(1-5x)}\\\{0,1\times 2,2\times 3,3\times 4\cdots\}&\to\sum (i+1)\cdot i\cdot x^i=\sum x^i\cdot 2\sum_{j=1}^ij=(\sum i\cdot x^i)*(\sum 2x^i)=\frac{2}{1-x}\cdot\frac{x}{(1-x)^2}\\\{0,0,0,-1,1,-1,1\cdots\} & \to \sum_{i=3}^{\infty}(-1)^ix^i=x^3\sum(-x)^i=\frac{x^3}{1+x}\\\end{aligned}</script><h1 id="部分分式"><a href="#部分分式" class="headerlink" title="部分分式"></a>部分分式</h1><p>这一章的作用在于把一个复杂的计数问题转化为许多个简单的 $\rm OGF$ 的形式。</p><h2 id="预备定理"><a href="#预备定理" class="headerlink" title="预备定理"></a>预备定理</h2><blockquote><p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，$a$ 是 $Q(x)$ 的一个 $k$ 重根，那么存在一个数列 $A_{1\sim k}$ 使得</p><script type="math/tex; mode=display">\frac{P(x)}{Q(x)}=\sum_{i=1}^k\frac{A_i}{(x-a)^i}+\frac{P'(x)}{Q'(x)}</script><p>其中 $\frac{P’(x)}{Q’(x)}$ 依旧是真分式。</p></blockquote><p>懒得证了。感性理解。</p><h2 id="部分分式定理"><a href="#部分分式定理" class="headerlink" title="部分分式定理"></a>部分分式定理</h2><blockquote><p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，如果 $a_1,a_2,\cdots a_m$ 分别是多项式 $Q(x)$ 的 $k_1,k_2,\cdots k_m$ 重根。那么存在一张数表 $\mathbf A$ ，使得</p><script type="math/tex; mode=display">\frac{P(x)}{Q(x)}=\sum_{i=1}^m\sum_{j=1}^{k_i}\frac{\mathbf A_{i,j}}{(x-a_i)}</script></blockquote><p>由预备定理可知显然。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h3><blockquote><p> 分解 $\frac{1}{x^3-x^2-x+1}$ 为部分分式。</p></blockquote><p>首先因式分解可以知道 $1$ 是他的二重根，$-1$ 是他的一重根。那么可以根据部分分式定理得到</p><script type="math/tex; mode=display">\frac{1}{x^3-x^2-x+1}=\frac{a}{(x-1)^2}+\frac{b}{x-1}+\frac{c}{x-1}</script><p>两边通分后发现是个恒等式，于是就可以对 $x$ 用特殊值法得到 </p><script type="math/tex; mode=display">a=\frac{1}{2},b=-\frac{1}{4},c=\frac{1}{4}</script><p>然后就没有然后了。</p><h3 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h3><blockquote><p>将分解 $\frac{6x^2+22x+18}{x^3+6x^2+11x+6}$ 为部分分式</p></blockquote><p>继续考虑将分母因式分解。即</p><script type="math/tex; mode=display">x^3+6x^2+11x+6=(x+1)\cdot (x+2)\cdot (x+3)</script><p>那么之后就变成sb题了，分解为 $\frac{1}{x+1}+\frac{2}{x+2}+\frac{3}{x+3}$。</p><h1 id="简单组合问题"><a href="#简单组合问题" class="headerlink" title="简单组合问题"></a>简单组合问题</h1><h2 id="一般组合问题"><a href="#一般组合问题" class="headerlink" title="一般组合问题"></a>一般组合问题</h2><blockquote><p> 设有 $n$ 种不同的物体，分别只能取 $a_1,a_2,a_3\cdots a_n$ 个，如果要取 $r$ 个，有多少种方案。</p></blockquote><p>形式幂级数大概就是</p><script type="math/tex; mode=display">\prod _{i=1}^n(1+x+x^2+\cdots+x^{a_i})</script><p>这样。或者考虑一个更特殊的问题，从 $n$ 个不同物品里可以重复地取出 $r$ 个的方案数：</p><script type="math/tex; mode=display">\prod_{i=1}^n(1+x+x^2+\cdots)=\frac{1}{(1-x)^n}</script><p>由上面的形式幂级数展开可以知道，这个东西的第 $r$ 项是 $\binom{n-1+r}{n-1}=\binom{n+r-1}{r}$，是个常见的结论。</p><h2 id="砝码模型"><a href="#砝码模型" class="headerlink" title="砝码模型"></a>砝码模型</h2><blockquote><p>设有 $n$ 种砝码，质量分别为 $c_1,c_2\cdots c_n$，分别有 $b_1,b_2\cdots b_n$ 枚，求一共可以称出多少种不同质量的物品。</p></blockquote><p>这个东西的形式幂级数大概是</p><script type="math/tex; mode=display">\prod_{i=1}^n (1+x^{c_i}+x^{2\cdot c_i}+x^{3\cdot c_i}+\cdots+x^{b_i\cdot c_i})</script><h2 id="不定方程相关"><a href="#不定方程相关" class="headerlink" title="不定方程相关"></a>不定方程相关</h2><blockquote><p>求</p><script type="math/tex; mode=display">p_1x_1+p_2x_2+\cdots+p_nx_n=r</script><p>的非负整数解个数。</p></blockquote><p>很显然是 </p><script type="math/tex; mode=display">\prod_{i=1}^n (1+x^{p_i}+x^{2\cdot p_i}+\cdots)</script><p>这里继续把 $1$ 当作一个物品，每个变量只能拿 $p_i$ 的倍数个就很好理解了。</p><p>那么这东西的母函数显然是</p><script type="math/tex; mode=display">\frac{1}{(1-x^{p_1})(1-x^{p_2})(1-x^{p_3})\cdots(1-x^{p_n})}</script><h2 id="有关分拆数的拓展"><a href="#有关分拆数的拓展" class="headerlink" title="有关分拆数的拓展"></a>有关分拆数的拓展</h2><p>在正整数 $r$ 的所有分拆中， 不超过 $n$ 的有几种？</p><p>发现本质上是在求这样一个不定方程</p><script type="math/tex; mode=display">1\cdot x_1+2\cdot x_2+3\cdot x_3+\cdots+n\cdot x_n=r</script><p>的非负整数解个数。</p><p>那么显然就是 $\frac{1}{(1-x)(1-x^2)\cdots(1-x)^n}$</p><h2 id="又一个拓展-OI中的应用"><a href="#又一个拓展-OI中的应用" class="headerlink" title="又一个拓展(OI中的应用)"></a>又一个拓展(OI中的应用)</h2><blockquote><p>给定 $n$ 和 $c_i(1\leq c_i\leq \rm m)$，求 $0\leq x_i\leq c_i$ 时，$\sum x_i=s$ 的解的数量。</p><p>对于前 $30\%$ 的数据，有 $n\leq 16,0\leq m,s\leq 10^9$  。</p><p>对于前 $70\%$ 的数据，有 $n\leq 35，0\leq m,s\leq 10^9$ 。</p><p>对于另外 $30\%$ 的数据，有 $1\leq n\leq 5\cdot 10^5,0\leq m,s\leq 100$。</p></blockquote><p>发现大概 $30\%$ 的可以直接大力容斥，最后 $30\%$ 的可以生成函数，中间 $40\%$ 的就需要神秘的 $\rm Meet~in~Middle$ 了。想了想大概就是分成两部分，枚举第二部分的时候顺便乘法原理一下第一部分的结果就完了。</p><h1 id="线性循环数列"><a href="#线性循环数列" class="headerlink" title="线性循环数列"></a>线性循环数列</h1><h2 id="斐波那契数列通项"><a href="#斐波那契数列通项" class="headerlink" title="斐波那契数列通项"></a>斐波那契数列通项</h2><p>考虑斐波那契数列 $\{a_n\}$ 的母函数可以这么得到：</p><script type="math/tex; mode=display">f(x)=a_0+a_1x+\cdots+a_nx^n+\cdots\\-xf(x)=-a_0x-a_1x^2-\cdots-a_nx^{n+1}\cdots\\-x^2f(x)=-a_0x^2-a_1x^3-\cdots-a_nx^{n+2}\cdots\\</script><p>考虑 ① + ② + ③ 得到：</p><script type="math/tex; mode=display">(1-x-x^2)f(x)=a_0+(a_1-a_0)x+(a_2-a_1-a_0)x^2\cdots</script><p>可知</p><script type="math/tex; mode=display">f(x)=\frac{1}{1-x-x^2}</script><p>那么考虑如何展开这个东西。令 $r_1,r_2$ 为方程 $1-x-x^2$ 的两个根。那么有</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{x-r_1}-\frac{1}{x-r_2}\right)</script><p>变一下形：</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{r_2\left(1-\frac{1}{r_2}x\right)}-\frac{1}{r_1\left(1-\frac{1}{r_1}x\right)}\right)</script><p>然后有一步很神仙的转化。由</p><script type="math/tex; mode=display">\frac{1}{1-\frac{1}{r_1}x}=\sum\left(\frac{1}{r_1}\right)^ix^i\\\frac{1}{1-\frac{1}{r_2}x}=\sum\left(\frac{1}{r_2}\right)^ix^i</script><p>得到</p><script type="math/tex; mode=display">\frac{1}{1-x-x^2}=\sum\left[\frac{1}{r_2-r_1}\left(\frac{1}{r_2^{i+1}}-\frac{1}{r_1^{i+1}}\right)\right]x^i</script><p>可知</p><script type="math/tex; mode=display">a_n=\frac{1}{\left(r_1r_2\right)^n}\cdot\frac{r_2^{n+1}-r_1^{n+1}}{r_1-r_2}</script><p>继而可以得到</p><script type="math/tex; mode=display">a_n=\frac{1}{\sqrt 5}\left[\left(\frac{1+\sqrt 5}{2}\right)^{n+1}-\left(\frac{1-\sqrt 5}{2}\right)^{n+1}\right]</script><h2 id="一般线性循环数列"><a href="#一般线性循环数列" class="headerlink" title="一般线性循环数列"></a>一般线性循环数列</h2><p>由上例可知，对于一个给定的 $k$ 阶线性循环数列，求母函数只需要构造出除了前 $k$ 项之外系数都为 $0$ 的幂级数即可。</p><p>比如给定数列 $\{a_n\}$ 满足：</p><script type="math/tex; mode=display">a_0=0,a_1=1,a_2=-1\\a_n=-a_{n-1}+16a_{n-2}-20a_{n-3}\quad(n=3,4,5\cdots)\\</script><p>那么考虑构造如下四个：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=a_0+a_1x+\cdots+a_nx^n+\cdots\\xf(x)&=a_0x+a_1x^2+\cdots + a_nx^{n+1}\cdots\\-16x^2f(x)&=-16a_0x^2-16a_1x^3-\cdots-16a_nx^{n+2}\cdots\\20x^3f(x)&=-20a_0x^3+20a_1x^4+\cdots+20a_nx^{n+3}\cdots\\\end{aligned}</script><p>还是 ① + ② + ③ + ④：</p><script type="math/tex; mode=display">(1+x-16x^2+20x^3)f(x)=x\\f(x)=\frac{x}{1+x-16x^2+20x^3}</script><p>就完了。</p><p>嗯，剩下的内容就留给下一篇了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是好久之前的学习笔记？&lt;/p&gt;
&lt;p&gt;边复习边发吧。其实MO再不做题的时候，拿来磨磨脑子也挺有意思的。&lt;/p&gt;
&lt;p&gt;这一部分大概是从「基础组合计数」到「一般型母函数」，再到「线性循环数列」。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生成函数" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="组合计数/二项式定理" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    
      <category term="组合计数/生成函数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【练习记录】平日里口胡的题目系列1</title>
    <link href="https://www.orchidany.cn/2020/02/09/%E5%B9%B3%E6%97%A5%E9%87%8C%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%E7%B3%BB%E5%88%971/"/>
    <id>https://www.orchidany.cn/2020/02/09/平日里口胡的题目系列1/</id>
    <published>2020-02-09T14:25:43.000Z</published>
    <updated>2020-02-22T02:39:27.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是有些题实在不想写，就把这些题给嘴了。</p><p>由于同一篇文章太长会造成很差的观感。所以就分成很多 $parts$ 了。</p><p>对于个人认为比较妙的题，会打上 <code>*</code> 的图标。</p><a id="more"></a><h1 id="MdOI2020"><a href="#MdOI2020" class="headerlink" title="MdOI2020"></a>MdOI2020</h1><p>当成月赛打了。T1写了个诡异的算法结果因为特判时没输出换行拿了64，然后就没有打的兴趣了（</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>考虑对于一种拆分是最优的。即 $(a,b,c)=d$，$d$ 为所求，那么发现会有 $d\cdot (\frac{a}{d}+\frac{b}{d}+\frac{c}{d})=n$。发现当 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同时，一定可以转化成其中一个数 $=d$ 的构造方式。</p><p>所以考虑质因数分解之后枚举 $\frac{n}{d}$。发现当 $\frac{n}{d}\leq 5$ 的时候，当前枚举的 $d$ 不可以让 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同。所以判掉这些数据，剩下的取 $\rm max$ 即可。</p><p>发现现在要求的，就是从 $n$ 的所有分解里面，挑出一个最接近 $6$ 且 $\geq 6$ 的构造 $\frac{n}{d}$ 的方案。发现最多需要三个素因子才可以超过 $6\to (2,2,2)$，最少的话一个就足够了。所以考虑 $\log ^3n$ 三重循环枚举所有的质因子即可。</p><p>质因数分解完全可以 $\rm pollard-rho$。最后复杂度 $O(T\max(\log^3 n,n^\frac{1}{4}))$</p><p>(这个题写的长是因为直接把自己写的题解给粘过来了)</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>考虑一个性质，排好序后，最后不变的一定是一个连续区间。所以考虑枚举这个连续区间，尺取或者二分出右端点，检验一下就可以了。复杂度 $O(n)$。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>考虑一个性质。发现其实左上角的数定住之后，之后的数都确定了。所以可以随便用点差分 $trick$ 实现 $n^2$ .</p><h2 id="D"><a href="#D" class="headerlink" title="D*"></a>D*</h2><p>比较有趣的题。根据第二个子任务的提示可以发现，对于每个询问可以把当前点旋到根，然后求的就是一个区间内点的 $lca$ 的深度。发现这个东西有结合律，比较容易用线段树维护。</p><p>然而每次换根复杂度显然不对。考虑进一步分析性质，当询问点 $q$ 不在原树上的 $lca$ 的子树内时，换根不会影响距离，所以直接统计即可；当询问点 $q$ 不在 $lca$ 的子树内时，考虑换根之后的 $lca’$ 一定也是原树里 $p$ 的某个祖先。通过画图可以知道，只需要倍增找出 $p$ 的第一个包含 $[l,r]$ 内点的祖先即可。求交集可以用主席树来维护。复杂度 $(n\log^2n+q\log^2n)$。</p><h2 id="E"><a href="#E" class="headerlink" title="E*"></a>E*</h2><p>发现可以转化成枚举一个点 $x$ ，从 $x$ 的子树内外各选一对点使得 xor 值最大，发现直接拿Trie维护一个回滚莫队状物即可。复杂度 $n\sqrt n\log V$ 。</p><p>似乎可以用什么值域分块的黑科技优化一下。emmm但我还不会。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>是个推式子题，暂时不是很想推。</p><h1 id="EA的练习赛"><a href="#EA的练习赛" class="headerlink" title="EA的练习赛"></a>EA的练习赛</h1><p>发现自己被叫去验题结果啥都不会十分丢人.jpg</p><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><p>发现如果第一个字符和后面的任意一个字符相同，那么就一定不合法；反之一定合法。所以答案是 $26\times 25^{n-1}$ 。</p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B*"></a>B*</h2><p>根据期望的线性性，发现可以将每个点的答案转化一下：$E=\sum_{i=1}^{n-1}P(x\geq i)$ 。</p><p>考虑每个点什么时候被删除。发现只跟离他最近的前后两个比他大的数有关，每当有一个与 $x$ 相邻时 $x$ 就会挂。所以用容斥原理算一下，$P(x\geq i)=1-P(pre\sim x)-P(x\sim~nxt)+P(pre\sim nxt)$ 。发现这东西显然有组合意义，所以算一波组合数即可。复杂度 $O(n^2)$ 。</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>有意思的题。发现切割方式严格要求从左到右，那么对于两根弦，如果以 $u_j\geq u_i,v_j\leq v_i$ 的方式相交，那么就可以把 $j$ 这条弦给删掉。所以删掉之后重新排序，然后按弦 $dp$。$f_i$ 表示处理完前 $i$ 根弦的 $\min$ 。那么转移就枚举一下把哪个 $j\sim i$ 的连续区间给删掉。</p><p>那么转移大概是 $f_i=\min_{0\leq j&lt;i}(f_j+A_{u_{j+1}-1}\times B_{v_i+1})$ 。其中 $A,B$ 分别是 $a_i,b_i$ 的前后缀最小值。</p><p>发现稍微变一下形，就是 $f_j=-A_{u_{j+1}-1}\times B_{v_i+1}+f_i$。发现斜率 $B$ 单调，$x$ 坐标 $A$ 单调递减。所以就是在维护一个下凸壳，直接最裸的斜率优化就好了。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D**"></a>D**</h2><p>很有意思的组合题。发现对于每个点，如果在访问他之前访问了比他深度更小的叶子节点，他就不会被访问。所以考虑对于一个点 $x$ 的每个祖先 $anc_x$ ，设 $anc_x$ 有 $n’$ 个儿子，其中有 $m’$ 个子树内叶节点的最小深度小于 $x$ 的深度，那么这一层不会进入死亡分叉的方案数就是 $\binom{n’}{m’+1}\cdot (n’-m’-1)!\cdot (m’)!$ ，计数思路大概就是选出 $m’+1$ 个位置来，每次选都把这 $m’+1$ 位置中的第一个位置留给当前的 $x$ 所在子树放，剩下就是排列数。</p><p>然后考虑进入 $x$ 的概率就是很神奇的 $\prod \frac{1}{m_{anc_i}’+1}$。考虑这个东西怎么快速算。发现对于同一棵子树，$lca$ 上方的信息都是一样的，改变的只有子树内部的方案。那么考虑对于每个儿子，直接按照「子树内叶子的最小深度」排序，就可以顺序处理出结果。</p><p>类似于用栈来维护 $k$ 级祖先的过程，发现只需要一个可撤销的树状数组即可。复杂度 $n\log n$。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>似乎是一道神秘的插值题。鸽了鸽了。</p><h1 id="LG二月月赛-·-加油武汉"><a href="#LG二月月赛-·-加油武汉" class="headerlink" title="LG二月月赛 · 加油武汉"></a>LG二月月赛 · 加油武汉</h1><p>没参加的一场月赛，似乎被爆破了.jpg</p><h2 id="A-2"><a href="#A-2" class="headerlink" title="A**"></a>A**</h2><p>这题本来想枚举最后选的哪个数来做，但是发现根本不科学，自闭了半天。就是考虑钦定了一个数，如果不是最后一个取他，那么前 $k$ 个一定都放比他小的数，同时可以在他的位置和 $k$ 个之间也放一些比他小的数，但是这些方案对于不同的前 $k$ 个元素的最大值，方案是不同的，所以复杂度很假也很麻烦。</p><p>发现似乎直接枚举前 $k$ 个元素的最大值比较容易做。分成两类来讨论，一类情况是取到了某个 $x$，另一类情况是不得不取最后一个，发现当且仅当集合里的最大值在前 $k$ 个才会发生。</p><p>1、第一种情况。对于每个最大值 $x$，取到他的概率是 $\frac{\binom{x-1}{k-1}}{\binom{n}{k}}$，在取到最大值为 $x$ 的情况下，期望就再乘上一个 $\frac{\mathrm{S-S_{p_x}}}{n-p_x}$。其中 $\rm S$ 表示集合元素的总和，$\rm S_x$ 表前 $x$ 小的元素的和，$p_x$ 表示 $x$ 是第几小的。不难发现这样是对的。</p><p>2、第二种情况。不难发现概率是 $\frac{\binom{n-1}{k-1}}{\binom{n}{k}}=\frac{k}{n}$ 。那么期望的话，发现这种情况下最后一个数是谁情况相同。所以乘上一个 $\frac{\mathrm{S}-x_{\max}}{n-1}$ 就完了。</p><p>嗯。这个故事告诉我们有时候期望题并不可以直接大力去组合所有情况来算，还是需要一定技巧的。</p><p>啊…不会转换组合对象…我太弱了…</p><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><p>由于是完全图，那么每个点贡献的异色三角形个数就是 $(n-1-b)\cdot b$ 。</p><p>所以最后算一下补，答案就是 $\binom{n}{3}-\frac{1}{2}\sum_{i=1}^n(n-1-b_i)\cdot b_i$ 。做完才发现是一道做烂了的题.jpg</p><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>sb费用流。发现最大流的情况下，不会出现一个点覆盖了另一个强连通分量中的某个点。所以可以直接流。用一些贪心的 $trick$ 就可以边数消掉一个 $n$ 了 。</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D*"></a>D*</h2><p>很有意思一道题。首先发现原来 $min_25$ 筛并不可以过得去。之后发现 </p><script type="math/tex; mode=display">\begin{aligned}\sigma_0(n)&=\prod(e_i+1)\\\sigma_0(n^k)&= \prod(k\times e_i+1)\end{aligned}</script><p>于是可以发现，大概对于每个 $n$，他的 $\sigma_0$ 都是一个关于 $k$ 的 $\omega(n)$ 次多项式。于是就可以筛出多项式来，前缀和一下。然后就做完了。复杂度大概 $O(\max(\omega\cdot n, \omega\cdot q))$ 。</p><p>可能筛多项式需要一些诡秘的 $trick$ 吧。不过大概还是通过记录最小质因子来转移。</p><p>由于以前没见过这种题，于是写了个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    poly[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])&#123;</span><br><span class="line">            frm[i] = <span class="number">1</span> ;</span><br><span class="line">            chk[i] = <span class="number">1</span> ;</span><br><span class="line">            mind[i] = i ;</span><br><span class="line">            mindc[i] = <span class="number">1</span> ;</span><br><span class="line">            pr[++ cnt] = i ;</span><br><span class="line">            poly[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            poly[i][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m, j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            m = <span class="number">1l</span>l * pr[j] * i ; </span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) <span class="keyword">break</span> ; chk[m] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                mind[m] = pr[j] ;</span><br><span class="line">                mindc[m] = <span class="number">1</span>, frm[m] = i ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mindc[m] = mindc[i] + <span class="number">1</span> ;</span><br><span class="line">                mind[m] = mind[i] ; frm[m] = frm[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">8</span> ; ++ k)</span><br><span class="line">                poly[m][k] = poly[frm[m]][k] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">8</span> ; k &gt;= <span class="number">1</span> ; -- k)</span><br><span class="line">                (poly[m][k] += <span class="number">1l</span>l * mindc[m] * poly[m][k - <span class="number">1</span>] % P) %= P ;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">            poly[i][j] -= (poly[i][j] += poly[i - <span class="number">1</span>][j]) &gt;= P ? P : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有很长的题面以及红色的难度标签。于是决定跳过。</p><h2 id="F-1"><a href="#F-1" class="headerlink" title="F"></a>F</h2><p>辣鸡二分答案题。难点在于知道要去二分答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概就是有些题实在不想写，就把这些题给嘴了。&lt;/p&gt;
&lt;p&gt;由于同一篇文章太长会造成很差的观感。所以就分成很多 $parts$ 了。&lt;/p&gt;
&lt;p&gt;对于个人认为比较妙的题，会打上 &lt;code&gt;*&lt;/code&gt; 的图标。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="数学/素数/素数筛法" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%B4%A0%E6%95%B0-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/概率,期望" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="多项式的应用" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="动态规划/斜率优化" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据结构/可持久化/可持久化线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="有技巧的差分" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
</feed>
