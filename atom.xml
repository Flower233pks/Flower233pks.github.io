<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-KPMEoaXb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KPMEoaXb"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-04-29T12:34:46.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><p><del>恭喜你来到了没有知识的荒原.</del></p><p>这篇文章已经移步到侧边栏的「<code>Navigation</code>」里啦！还不去看看？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】从零开始的数位DP生活</title>
    <link href="https://www.orchidany.cn/2020/04/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E4%BD%8DDP%E7%94%9F%E6%B4%BB/"/>
    <id>https://www.orchidany.cn/2020/04/27/从零开始的数位DP生活/</id>
    <published>2020-04-27T09:13:20.000Z</published>
    <updated>2020-04-29T12:35:54.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…</p><p>冲冲冲！</p><a id="more"></a><h1 id="Luogu4317-花神的数论题"><a href="#Luogu4317-花神的数论题" class="headerlink" title="[Luogu4317] 花神的数论题"></a>[Luogu4317] 花神的数论题</h1><blockquote><p>话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\prod_{i=1}^{N}\text{sum}(i)$ ，也就是  $\text{sum}(1)\sim\text{sum}(N)$  的乘积。</p><p>对于 100% 的数据，$N≤10^{15}$ 。</p></blockquote><p><del>为什么花神出的题花不会呢，为什么为什么</del> 。</p><h1 id="LuoguP1822-魔法指纹"><a href="#LuoguP1822-魔法指纹" class="headerlink" title="[LuoguP1822] 魔法指纹"></a>[LuoguP1822] 魔法指纹</h1><blockquote><p>对于任意一个至少两位的正整数 $n$，按如下方式定义 $magic(n)$ ：将 $n$ 按十进制顺序写下来，依次对相邻两个数写下差的绝对值。这样，得到了一个新数，去掉前导 $0$，则定义为 $magic(n)$。若 $n$ 为一位数，则 $magic(n)=n$。</p><p>对任意一个数 $n$，序列 $n,magic(n),magic(magic(n)),…$ 迟早会变成一个一位数。最后的这个值称为数 $n$ 的 $magic$ 指纹。</p><p>对 $100\%$ 数据，$0&lt;A≤B≤1,000,000,000$ 。</p></blockquote><h1 id="loj10165-Windy数"><a href="#loj10165-Windy数" class="headerlink" title="[loj10165] Windy数"></a>[loj10165] Windy数</h1><blockquote></blockquote><p>咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…&lt;/p&gt;
&lt;p&gt;冲冲冲！&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/数位DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做·第3季</title>
    <link href="https://www.orchidany.cn/2020/04/26/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC3%E5%AD%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/简单题选做·第3季/</id>
    <published>2020-04-26T12:52:04.000Z</published>
    <updated>2020-04-29T13:16:51.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>终于！终于不是UVA了！</del></p><p>主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。</p><p>争取一句话题解…这一弹大概有 $25$ 道题左右吧。 </p><a id="more"></a><h1 id="HNOI2011-数学作业"><a href="#HNOI2011-数学作业" class="headerlink" title="[HNOI2011]数学作业"></a>[HNOI2011]数学作业</h1><blockquote><p>给定正整数 $n,m$，要求计算 $\text{Concatenate}(n) \bmod  m$  的值，其中 $\text{Concatenate}(n)$ 是将 $1 \sim n$ 所有正整数 顺序连接起来得到的数。</p><p>$1\le n \le 10^{18}$，$1\le m \le 10^9$。</p></blockquote><p>…考虑递推，那自然是 $f_{i}=(f_{i-1}\cdot T+i)\bmod m$ 。其中 T 是根据不同的数字位数而变的这么一个计数器。于是就是分段矩乘即可。 </p><h1 id="Luogu5110-块速递推"><a href="#Luogu5110-块速递推" class="headerlink" title="[Luogu5110]块速递推"></a>[Luogu5110]块速递推</h1><blockquote><p><script type="math/tex">a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1</script> 。</p><p>求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。</p><p>$1\leq T\leq 5\times 10^7,1\leq n\leq 10^{18}$ 。</p></blockquote><p>朴素的矩乘是 $8\cdot \log n$ 的样子。这样算出来复杂度是 $O(8\cdot T\cdot \log n)$ ，好像很慢的样子。</p><p>于是考虑预处理一点东西。比较常见的方法当然就是分块来做，预处理 $a^{1},a^{2},a^{3}\cdots a^{\sqrt n},a^{2\cdot \sqrt n},a^{3\cdot \sqrt n}\cdots$ 这些。那么复杂度度转化成了 $O(\sqrt n\log\sqrt n+8\cdot T)$。</p><p>注意到可以借助扩展欧拉定理 $a^b\equiv a^{b\bmod \varphi(m)+\varphi(m)}\pmod{m}$ 使得复杂度变成 $O(\sqrt{Mod}\log\sqrt{Mod}+8\cdot T)$ 。信仰一波就过了。</p><h1 id="USACO13JAN-Seating-G"><a href="#USACO13JAN-Seating-G" class="headerlink" title="[USACO13JAN]Seating G"></a>[USACO13JAN]Seating G</h1><blockquote><p>有一排 $n$ 个座位，$m$ 次操作。</p><p>A操作：将 $a$ 名客人安置到最左的连续 $a$ 个空位中，没有则不操作。</p><p>L操作：$[a,b]$ 的客人离开。</p><p>求A操作的失败次数。</p><p>$n,m,10^5$ 。</p></blockquote><p>这…大概就是维护区间最长连续和然后再直接线段树上二分吧…发现自从领悟了线段树上二分之后，好多奇怪的线段树题也就都这么回事了…</p><h1 id="APIO2012-派遣"><a href="#APIO2012-派遣" class="headerlink" title="[APIO2012]派遣"></a>[APIO2012]派遣</h1><blockquote><p>在这个帮派里，有一名忍者被称之为 Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。</p><p>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。</p><p>你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。</p><p>写一个程序，给定每一个忍者 $i$ 的上级 $B_i$ ，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$ ，输出在预算内满足上述要求时顾客满意度的最大值。</p><p><strong>简化版题面：给定一棵树，求</strong> </p><script type="math/tex; mode=display">\max_{u\in T}\{L_u\cdot t_u\}</script><p><strong>其中设</strong> $s$ <strong>是以</strong> $u$ <strong>为根的子树中的某个点集，</strong>$\mathrm{card}$ <strong>表示集合的元素个数， 则</strong></p><script type="math/tex; mode=display">t_u=\max_s\{\mathrm{card}(s)\cdot [ \sum_{i\in s} c_i\leq m]\}</script><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>读题读半天系列x</p><p>…发现是暴力，暴力选每个点当根，然后拿一个支持快速合并的数据结构对子树内的点进行合并，选出重量最小的那几个即可。注意到暴力合并的话似乎是要二分…这样一般而言复杂度就变成两个 $\log$ 了。但是如果每次插入完之后，统计答案时选择不断删掉当前 $c_i$ 最大的元素，这样就可以在保证正确性的同时降低询问的复杂度。发现可以直接拿左偏树来维护。复杂度 $O(n\log n)$ 。</p><h1 id="Luogu1858-多人背包"><a href="#Luogu1858-多人背包" class="headerlink" title="[Luogu1858]多人背包"></a>[Luogu1858]多人背包</h1><blockquote><p>01背包的前 $k$ 优解。</p><p>$k\le 50,m\le 5000,n\le 200$ .</p></blockquote><p>考虑暴力做并不简单，一个直观的想法就是再记一维 $k$ ，即 $f_{i,v,k}$ 表示考虑了前 $i$ 个物品，总体积为 $v$ 的 $k$ 优解是多少。考虑转移。通过观察单调性，可以发现当 $p&gt;q$ 时， $i-1,v$ 时的 $p$  优解是不会对 $i,v+w_i$ 时的 $q$ 优解产生贡献的，也就是说对于一个状态 $f_{i,v,k}$ ，都是从某个 $f_{i-1,v,j}$ 或者 $f_{i-1,v-w_i,j}+v_i$ 转移过来的。于是考虑直接把这两个状态集归并排序一下即可。复杂度 $O(n\cdot m\cdot k)$ 。</p><h1 id="SCOI2016-萌萌哒"><a href="#SCOI2016-萌萌哒" class="headerlink" title="[SCOI2016]萌萌哒"></a>[SCOI2016]萌萌哒</h1><blockquote><p>一个长度为 $n$ 的大数，用 $s_1s_2s_3 \cdots s_n$表示，其中 $s_i$ 表示数的第 $i$ 位， $s_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串$s_{l_1}s_{l_1+1}s_{l_1+2} \cdots s_{r_1}$与$s_{l_2}s_{l_2+1}s_{l_2+2} \cdots s_{r_2}$完全相同。</p><p>求本质不同的大数个数。</p><p>$1\le n\le 10^5$，$1\le m\le 10^5$ 。</p></blockquote><p>（以下默认并查集的复杂度是 $O(\log n)$ ，实际上这是一个很松的上界）</p><p>考虑暴力做当然是对每个位置开一个并查集，然后对于每个修改暴力 <code>for</code> 过去，这样最后答案就是 $9\cdot 10^{cnt-1}$ ，其中 $cnt$ 是不同的集合数量。这样做是 $O(nm\log n)$ 修改、$O(n\log n)$ 查询的。发现这样做的复杂度十分不平衡。考虑将复杂度向查询倾斜，即优化修改操作的复杂度。</p><p>考虑二进制拆分。对每个位置 $i$ 维护 $i\sim i+2^k-1$ 的连通状态，这样每次修改就是 $\log ^2n$ 的了。之后考虑对于一个长为 $2^k$ 的区间，可以push_down成两个长为 $2^{k-1}$ 的子区间再分别连边。于是查询的时候就可以直接查询了。</p><p>总复杂度 $O(m\log ^2n+n\log ^2 n)$ 。</p><h1 id="SCOI2010-生成字符串"><a href="#SCOI2010-生成字符串" class="headerlink" title="[SCOI2010]生成字符串"></a>[SCOI2010]生成字符串</h1><blockquote><p>lxhgww 最近接到了一个生成字符串的任务，任务需要他把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，但是任务还要求在组成的字符串中，在任意的前 $k$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。现在 lxhgww 想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？</p><p>$1\leq m,n\leq 10^6$ 。</p></blockquote><p>这…理论上如果没有个数限制的话就是卡特兰数了吧。</p><p>考虑一个转化，从 $(0,0)$ 开始出发，设当前点为 $(x,y)$ 每次如果遇到 $1$ 就走到 $(x+1,y-1)$ ，每次遇到 $0$ 就走到 $(x+1,y+1)$，那么最终就是走到 $(n+m,m-n)$ 的、不跨过直线 $x=0$ 方案数。这…似乎是一个十分经典的组合问题了。大概就是考虑把走到 $y=1$ 这条直线以下的那些路径全都翻转到 $y=1$ 以下（做镜像对称），那么就可以看做是从 $(0,2)$ 走到 $(n+m,m-n)$ 的方案数。所以答案就是两者相减。</p><p>考虑怎么算这两部分。发现本质上从 $(0,0)$ 走到 $(n+m,m-n)$ 、每次向右下或者右上走的方案数。一种比较简单的理解就是从 $n+m$ 步里面选出 $n$ 步向右下走的方案数，所以答案是 $\binom{n+m}{m}-\binom{n+m}{m-1}$ ，因为从 $(0,2)$ 开始走相当于把其中向上走的某一步魔改成了成了向下走的，所以 $m$ 要减一。</p><h1 id="SP19148-Kill-them-All"><a href="#SP19148-Kill-them-All" class="headerlink" title="[SP19148]Kill them All"></a>[SP19148]Kill them All</h1><blockquote><p>$n$ 只怪兽，每一次可让 Digo 杀或 Sharry 杀。求在每杀掉一只怪物后，Digo 的击杀数都比 Sharry 的击杀数多的方案数。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>回顾历史的时候顺便发现了这道题…</p><p>大概就是上个题把 $\geq $ 换成了 $&gt;$ 。考虑首先让 $1$ 号怪兽必须被 <code>Digo</code> 干掉，那么就变成了从 $(1,0)$ 出发，走 $n-1$ 步，途中不能碰到 $y=0$ 的方案数。考虑最后走到的地方只会是 $(n,\lceil\frac{n}{2}\rceil),(n,\lceil\frac{n}{2}\rceil+1)\cdots (n,n)$，那么不妨对这些东西分别计数，那么答案就是</p><script type="math/tex; mode=display">1+\sum_{i=1}^{\lceil\frac{n}{2}\rceil-1}\left(\binom{n-1}{i}-\binom{n-1}{i-1}\right)</script><p>其中第一个 $1$ 是全部被 <code>Digo</code> 干掉的方案数。那么可以知道…这个式子里面前面的都被消掉了，最后只剩一个 $1+\binom{n-1}{\lceil\frac{n}{2}\rceil-1}-\binom{n-1}{0}=\binom{n-1}{\lceil\frac{n}{2}\rceil-1}$ 。 然后就没有然后了。</p><h1 id="UVA11149-Power-of-Matrix"><a href="#UVA11149-Power-of-Matrix" class="headerlink" title="[UVA11149]Power of Matrix"></a>[UVA11149]Power of Matrix</h1><blockquote><p>给定整数 $k$ 和一个 $n$ 阶矩阵 $A$ ，求 </p><script type="math/tex; mode=display">A+A^2+A^3+A^4+\cdots+A^k</script><p>$n\leq 100,k\leq 10^6$ 。</p></blockquote><p>这题其实有两种做法。一种做法是 $O(n^3\log k)$ 的，另一种也是 $O(n^3\log k)$ 的，只不过会多一个 $8$ 的常数。</p><h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑对着这个找规律（雾），大概是考虑分块做，发现原来的式子可以写成：</p><script type="math/tex; mode=display">A+A^2+A^3+\cdots +A^{\sqrt k}+A^{\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})+A^{2\cdot\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})\cdots</script><p>那么就可以预处理再做了。这样复杂度是 $O(n^3\sqrt k)$ 的，好像大概是 $10^9$ 的复杂度…过不去。</p><p>不过既然分块可以，那倍增应该也可以。具体的，可以这么化：</p><script type="math/tex; mode=display">A^1+A^1\cdot A^1 + A^2\times (A^1+A^2)+A^4\times(A^1+A^2+A^3+A^4)</script><p>那么这样就可以先预处理出 $n^3\log k$ 个 $A,A^2,A^4\cdots$ ，然后就可以再用 $n^3\log k$ 的时间预处理出 $s_1,s_2,s_4\cdots$ 其中 $s_i=\sum{A^i}$ 。之后就可以直接二进制拆分了。总复杂度 $n^3\log k$ 。</p><h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>考虑直接对所有矩阵的和进行递推。计 $A^u$ 为当前矩阵的 $u$ 次幂，那么不妨构造一个复合矩阵</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">s_i = \sum \limits_{j = 1}^{i}A^i</script><p>发现它可以这么转移：</p><script type="math/tex; mode=display">\begin{bmatrix} A^k\\ s_k \end{bmatrix} = \begin{bmatrix}A^{k-1}\\s_{k-1}\end{bmatrix}\cdot \begin{bmatrix}A &0\\I_n&I_n\end{bmatrix}</script><p>其中 $I_n$ 表示 $n$ 阶单位矩阵。然后就没有然后了。注意到这样做矩阵其实是升阶了，所以会带一个常数。</p><h1 id="SDOI2011-打地鼠"><a href="#SDOI2011-打地鼠" class="headerlink" title="[SDOI2011]打地鼠"></a>[SDOI2011]打地鼠</h1><blockquote><p>打地鼠是这样的一个游戏：地面上有一些地鼠洞，地鼠们会不时从洞里探出头来很短时间后又缩回洞中。玩家的目标是在地鼠伸出头时，用锤子砸其头部，砸到的地鼠越多分数也就越高。</p><p>游戏中的锤子每次只能打一只地鼠，如果多只地鼠同时探出头，玩家只能通过多次挥舞锤子的方式打掉所有的地鼠。你认为这锤子太没用了，所以你改装了锤子，增加了锤子与地面的接触面积，使其每次可以击打一片区域。如果我们把地面看做 $m\times n$ 的方阵，其每个元素都代表一个地鼠洞，那么锤子可以覆盖 $r\times c$ 区域内的所有地鼠洞。但是改装后的锤子有一个缺点：每次挥舞锤子时，对于这的区域中的所有地洞，锤子会打掉恰好一只地鼠。也就是说锤子覆盖的区域中，每个地洞必须至少有 $1$ 只地鼠，且如果某个地洞中地鼠的个数大于 $1$，那么这个地洞只会有 $1$ 只地鼠被打掉，因此每次挥舞锤子时，恰好有$r\times c$ 只地鼠被打掉。由于锤子的内部结构过于精密，因此在游戏过程中你不能旋转锤子（即不能互换 $r$ 和 $c$）。</p><p>你可以任意更改锤子的规格(即你可以任意规定 $r$ 和 $c$ 的大小)，但是改装锤子的工作只能在打地鼠前进行(即你不可以打掉一部分地鼠后，再改变锤子的规格)。你的任务是求出要想打掉所有的地鼠，至少需要挥舞锤子的次数。</p><p>Hint：由于你可以把锤子的大小设置为 $1\times 1$，因此本题总是有解的。</p><p>$1\leq m,n\leq 100$。</p></blockquote><p>以下是翻车现场，这题根本没有「行列无关」的性质：</p><blockquote><p>一道十分经典的行列无关技巧普及题目。但这题行列无？关比较的深刻。</p><p>考虑如果暴力枚举的话，复杂度大概是枚举 $r\times c$ 之后再一个一个打，这样复杂度是 $O(n^6)$，实现的好一点就可以 $O(n^4\log^2 n)$ 。但是，如果这题满足行列无关的话，就可以 $r$ 和 $c$ 分别枚举。准确来说，对于另一维设为 $1$，那么可以只去找这一维的最大值。考虑这么做判断的复杂度就是 $O(n^3)$，枚举的复杂度是 $O(n)$ 。那么最后总复杂度就是 $O(n^4)$ 。</p><p>那么唯一的问题在于如何证明行列无关在这题里面是对的。考虑对于所枚举的锤子大小所覆盖的某个区域，其中有两个点 $(a,b)$ 和 $(c,d)$ ，不同行也不同列，但是可以知道 $(a,b)$ 和 $(c,b)$ 的确定关系，$(c,d)$ 和 $(c,b)$ 的确定关系。即我断言，如果 $(a,b)$ 和 $(c,b)$ 满足同时合法，$(c,d)$ 和 $(c,b)$ 也同时合法，那么这三个点就可以同时合法，反之则不可以。</p><p>考虑这个断言为什么合理。发现每次如果以 $(c,b)$ 为量度去砸，那么 $(c,d)$ 和 $(a,b)$ 被砸的次数都只会与 $(c,b)$ 的地鼠数量有关，因为 $(c,b)$ 必须被精确砸完……</p><p><del>编不下去了，就当记结论了</del></p></blockquote><p>然后就是一个二维差分，然后就没了。</p><h1 id="UVA11134-Fabled-Rooks"><a href="#UVA11134-Fabled-Rooks" class="headerlink" title="[UVA11134]Fabled Rooks"></a>[UVA11134]Fabled Rooks</h1><blockquote><p>在一个 $n\times n$（$1\leq n\leq 5000$）的棋盘上放置 $n$ 个车，每个车都只能在给定的一个矩形( $x_{l_i},x_{r_i},y_{l_i},y_{r_i}$) 里放置，使其 $n$ 个车两两不在同一行和同一列，判断并给出解决方案。</p></blockquote><p>又是一道考察行列无关知识的题目。</p><p>考虑放每个车时行与列显然是无关的，所以就可以分开做。那就是给定一堆区间，每个区间内选一个点使之不被放在同一个位置。贪一波就完了。</p><h1 id="NOI2005-瑰丽华尔兹"><a href="#NOI2005-瑰丽华尔兹" class="headerlink" title="[NOI2005]瑰丽华尔兹"></a>[NOI2005]瑰丽华尔兹</h1><blockquote><p>舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。</p><p>艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。</p><p>$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。K是时间段的数量，T 是总时间。</p></blockquote><p>考虑最朴素的 $dp$ 就是 $f_{t,i,j}$ 表示时刻 $t$ 时在位置 $(i,j)$ 结尾的最长路径。转移时 $O(1)$ 的。但由于状态数太高导致不得不放弃。发现本质上每段时间内，转移的方向唯一。所以可以按段来 $dp$ ，$f_{k,i,j}$ 表示经过了 $k$ 段之后，结尾于位置 $(i,j)$ 的最长路径。这样状态数就是 $O(nmk)$ 的、转移是 $O(\max\{n,m\})$ 的了。发现由于每一段决策区间单调，且决策点彼此之间存在单调性，于是可以拿单调队列优化到均摊 $O(1)$ 转移。</p><h1 id="BalticOI2008-Elect"><a href="#BalticOI2008-Elect" class="headerlink" title="[BalticOI2008]Elect"></a>[BalticOI2008]Elect</h1><blockquote><p>$n$ 个政党要组成一个联合内阁，每个党都有自己的席位数。 </p><p>现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。 </p><p>对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。</p><p>求最大席位并构造一组解。</p><p>$1\leq n\leq 300,1\leq m\leq 10^5$ 。</p></blockquote><p>大概是长个经验？</p><p>发现倒着贪心并不是对的…虽然观察数据范围发现 $O(nm)$ 可过，但是一般情况下很难想到要去背包，因为有一个「多余」的限制…</p><p>但是发现如果从大到小排完序之后再背包，当前加进去的东西一定是最小的。此时如果出现把这个东西拿出来，剩下的都一定比这个大。所以不难理解这么更新的正确性。</p><p>考虑如何记录方案。可以对于每种权值都开一个 <code>bitset</code>，对于每种权值，第一次更新的时候顺便更新 <code>bitset</code>（根据单调性这样一定是最合法的那个）。那么最后的复杂度就是 $O(nm+\frac{nm}{w})$。注意到这么写的意义在于，通过聚和分析可以得知，对于每个权值 $m$ 至多会与其他的价值 $or$ 一次，所以本质上是 $O(\frac{nm}{w})$ 而不是 $O(\frac{n^2m}{w})$（虽然也能过就是了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> half, sum ;</span><br><span class="line"><span class="keyword">int</span> i, v, ans, n ; </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; b[MAXM] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &gt; b.fr ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; f[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].fr) ;</span><br><span class="line">sum += base[i].fr, base[i].sc = i ; </span><br><span class="line">&#125;</span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, cmp) ; half = sum &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span> (v = sum ; v &gt;= base[i].fr ; v --)&#123; </span><br><span class="line"><span class="keyword">if</span> (!f[v] &amp;&amp; f[v - base[i].fr])</span><br><span class="line">b[v] = b[v - base[i].fr], b[v].<span class="built_in">set</span>(base[i].sc), f[v] = <span class="number">1</span> ;    </span><br><span class="line"><span class="keyword">if</span> (v &gt; half &amp;&amp; f[v] &amp;&amp; v - base[i].fr &lt;= half) ans = max(ans, v) ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[ans].count() &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (b[ans][i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LuoguP1531-鬼子进村"><a href="#LuoguP1531-鬼子进村" class="headerlink" title="[LuoguP1531]鬼子进村"></a>[LuoguP1531]鬼子进村</h1><blockquote><p>县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：</p><ol><li><p>若消息为 <code>D x</code>：鬼子将 $x$ 号房子摧毁了，地道被堵上。</p></li><li><p>若消息为 <code>R</code> ：村民们将鬼子上一个摧毁的房子修复了。</p></li><li><p>若消息为 <code>Q x</code>：有一名士兵被围堵在 $x$ 号房子中。</p></li></ol><p>李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。</p><p>$1\leq n,m\leq 5\times 10^4$。</p></blockquote><p><del>降智题，说实话我第一眼觉得那必然是 LCT；又觉得可达性不好统计，然后就懵了 1min</del></p><p>其实是有两种方法的：</p><h2 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑暴力线段树维护，修复和拆毁都是单点修改。查询的话自然是查询一个点左边第一个 $0$ 的位置、右边第一个 $0$ 的位置。首先这显然是可以外层二分，内层区间查询来做到 $\log ^2$ 的（其实也可以不线段树维护，用分块技巧，$O(1)$ 查询区间和、 $O(\sqrt n)$ 单点加的分块，也可以通过本题，同时虽然插入删除都是 $O(\sqrt n)$ 的，但是询问变成了 $\log$ 的）；或者直接在线段树上二分，做到一个 $\log$ 。</p><h2 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>发下有一个性质并没有很好利用起来<del>(虽然本身就是一个很没用的性质)</del>。每次删除的点一定是之前插入的点。所以考虑对于所有炸毁的点维护一棵平衡树，以 $pos$ 作为键值，那么每次查询本质上就是询问前驱和后继。</p><p>……还有要注意可能本身就被炸了，判一下就好了。这种方法也是 $1$ 个 $\log$ 的。</p><h1 id="AT3741-String-Problem"><a href="#AT3741-String-Problem" class="headerlink" title="[AT3741] String Problem"></a>[AT3741] String Problem</h1><blockquote><p>给出两个字符串S和T. 通过执行以下操作，判断是否可以将字符串S转换为字符串T.</p><ul><li>操作 A：删除S中任意位置的字母 A .</li><li>操作 B：在S的任意位置插入一个字母 B .</li></ul><p>S 和 T 的字符都为大写字母，并且 S 和 T 的长度 $\le 1000$ 。</p></blockquote><p>……其实是水题，不过发生了一些奇妙的事情，然后就打算整理一下我的做法？感觉其他人的做法都一毛一样…</p><p>大概就是首先根据样例解释的提示，可以想出一个「先加 B 再删 A」的思路，然后发现前半部分就是一个魔改的 LCS，后半部分就只需要记录一下最少要用多少个 B，看看 s 比 t 多的那些字符是否全是 A 就好了。</p><h1 id="Luogu3795-钟式映射"><a href="#Luogu3795-钟式映射" class="headerlink" title="[Luogu3795]钟式映射"></a>[Luogu3795]钟式映射</h1><blockquote><p>设集合 $N=M=\left\{x|x\in N_+,x\leq k,k\in N_+\right\}$ 。设 $f$ 为 $N$ 到 $M$ 的映射。求满足 $f[f(x)]=x$ 的不同的映射 $f$ 的个数。</p><p>$k\leq 10^{8}$ 。</p></blockquote><p>说实话…我遇到这种题就会战术后仰然后不会…类似于什么置换啊、复合映射啊，我就蒙圈的很。</p><p>考虑新加入一个元素。对于一个 $x$，要么 $f(x)=x$，要么就会有一个 $y$ 和 $x$ 配对。所以有</p><script type="math/tex; mode=display">g_i=g_{i-1}+g_{i-2}\cdot (i-1)</script><p>然后就递推即可。</p><p>感觉这个式子本质上和错排可能会有点类似。考虑一个 $n-$完全错位排列 的方案数。假设 $n$ 号元素排到了 $k$ 号位置上，$k$ 号元素恰好也排在了 $n$ 号位置上，那么就是 $(n-1)\cdot g_{n-2}$ ；否则 $k$ 号元素随便错排，那么就是 $(n-1)\cdot g_{n-1}$。那么就是</p><script type="math/tex; mode=display">g_{i}=(i - 1)\cdot(g_{n-1}+g_{n-2})</script><p>感觉递推思想方面是有类似的吧…自己还是…太不聪明了啊</p><p>别找那些理由，就是泥萌的不努力！</p><h1 id="UVA1451-Average"><a href="#UVA1451-Average" class="headerlink" title="[UVA1451]Average"></a>[UVA1451]Average</h1><blockquote><p>给定一个长度为 $n$ 的 $01$ 串，选一个长度至少为 $L$  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 $1$ ~ $n$，因此 $[1,n]$ 就是完整的字符串。</p><p>$1\le n\le 100000,1\le L\le 1000$。</p></blockquote><p><del>又到了复习斜率优化的时间了，斜率优化，常读常新。</del></p><p>考虑前缀和一下就转化成了对每个 $i$ 找到一个 $j&lt;i$ 使得 $\frac{s_i-s_j}{i-j}$ 最大。发现这就是在求最大的斜率。考虑本质上 $x$ 坐标和 $y$ 坐标都是不降的，所以为了斜率单增，要维护一个下凸壳。于是拿一个单调栈维护斜率就好了。复杂度线性。</p><h1 id="HNOI2008-玩具装箱"><a href="#HNOI2008-玩具装箱" class="headerlink" title="[HNOI2008]玩具装箱"></a>[HNOI2008]玩具装箱</h1><blockquote><p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。</p><p>为了方便整理，P教授要求：</p><ul><li><p>在一个一维容器中的玩具编号是连续的。</p></li><li><p>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。</p></li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。</p><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$</p></blockquote><p>大概是斜率优化板板题？考虑方程：</p><script type="math/tex; mode=display">f_{i}=\min_{j=1}^{i-1}\{f_{j}+(i-j+s(i)-s(j)-L)^2\}</script><p>然后考虑拆一下，并且令 $p(i)=s(i)+i,q(i)=s(i)+i+L$ ，那么：</p><script type="math/tex; mode=display">f_{i}=f_{j-1}+(p(i)-q(j))^2=f_{j-1}+p(i)^2-2\cdot p(i)\cdot q(j)+q(j)^2</script><p>那么证明斜率优化可行的基本讨论就是找一个 $j$ 和一个 $k$ 来比大小：</p><p>若 $j&gt;k$ 且 $j$ 比 $k$ 优，那么有</p><script type="math/tex; mode=display">\begin{aligned}f_{j-1}-2\cdot p(i)\cdot q(j)+q(j)^2&<f_{k-1}-2\cdot p(i)\cdot q(k)+q(k)^2\\2\cdot p(i)\cdot q(k)-2\cdot p(i)\cdot q(j)&<f_{k-1}-f_{j-1}+q(k)^2-q(j)^2\end{aligned}</script><p>设 $X_i=q(i),Y_i=f_{i-1}-q(i)^2$，那么有</p><script type="math/tex; mode=display">2\cdot p(i)>\frac{Y_{k}-Y_{j}}{X_{k}-X_{j}}</script><p>也就说当这个式子满足的时候，存在 $j&gt;k$ 且 $j$  比 $k$ 优。</p><p>所以对此可以直接采用斜率优化。注意到 $X$ 单增的同时，斜率本身不降；同时据此可以知道应该维护一个上凸壳，所以可以直接取到队首进行转移的元素。复杂度线性。</p><h1 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="[HAOI2008]硬币购物"></a>[HAOI2008]硬币购物</h1><blockquote><p>共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。</p><p>某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。</p><p>$1 \leq c_i, d_i, s \leq 10^5$，$1 \leq n \leq 1000$。</p></blockquote><p>比较常规的容斥题目。考虑由于硬币个数的限制，大概是要做一个多重背包计数，这样复杂度是 $O(4\cdot n\cdot s)$，大概是 $4e8$ 的级别，如果常数小的话没准信仰一波也是可以过的。</p><p>考虑更加正经一点的做法。发现虽然硬币个数很多，但是种类很少，同时发现不限制使用次数的方案数是很好计算的，于是考虑容斥。$f_v$ 表示不考虑硬币个数，用四种面值凑出 $v$ 的方案数。那么考虑如何统计不合法的方案数。考虑对于一种硬币 $(c_i,d_i)$，看上去，所有他的不合法方案应该是 </p><script type="math/tex; mode=display">\sum_{j=d_i+1}^{+\infty} f_{s-c_i\cdot j}</script><p>但是发现背包模型在计算方案时，状态本身具有简并性。 也就是对于任何一个状态 $f_{i,k}$ 都是被更小的 $f_{i,k-t\cdot c_i}$ 给拼插起来的。所以方案数应该为</p><script type="math/tex; mode=display">f_{s-c_i\cdot (d_i+1)}</script><p>于是容斥一下即可。复杂度 $O(4\cdot s+16\cdot n)$ 。</p><h1 id="CF933A-A-Twisty-Movement"><a href="#CF933A-A-Twisty-Movement" class="headerlink" title="[CF933A]A Twisty Movement"></a>[CF933A]A Twisty Movement</h1><blockquote><p>给定一个序列 A，你可以翻转其中的一个区间内的数，求翻转后的序列的最长不下降子序列的长度。（$|A|\le 2000,1\le a_i \le 2$ ）</p><p>$1\leq n\leq 10^3$。</p></blockquote><p>自己想了一个暴力做法。大概是对于每个位置 $s$ ，可以比较方便地维护出 $s$ 之前以 $0/1$ 结尾的最长上升子序列，同时也可以维护出 $s$ 之后以 $0/1$ 开头结尾的最长上升子序列，这一部分不是那么直观，但是考虑对于一个位置 $p$ ，一定是有某个位置 $q&gt;p$ 使得 $p+1\sim q$ 之间只选 $0$，$q+1\sim n$ 之间只选 $1$ 。这个东西倒着预处理似乎可以 $poly(\log)$ 或者线性，但是由于数据范围所以可以直接暴力。然后每次枚举两个端点暴力即可。中间可能要进行一下玄学的 dp。</p><p>……但其实是可以直接暴力 $dp$ 的。考虑最后选取的一定是一个形如 $1…2….1…2…$ 的子序列，于是就可以设状态 $f_{i,0/1/2/3/4}$ 表示分成了 $0/1/2/3/4$  后的、形如这样的子序列。转移的话就是相邻状态转移即可。复杂度线性。</p><p>当然这题也存在一个闲的胃疼的高级做法，就是线段树上分别维护 $1 \rightarrow 1,1 \rightarrow 2,2 \rightarrow 1,2 \rightarrow 2$ 的最长上升子序列，然后暴力枚举每个区间，复杂度 $O(n^2\log n)$ 。</p><p>emmm 启发了一个 Idea 但是自己不会做，惨惨。</p><h1 id="LuoguP6435-「EZEC-1」数列"><a href="#LuoguP6435-「EZEC-1」数列" class="headerlink" title="[LuoguP6435] 「EZEC-1」数列"></a>[LuoguP6435] 「EZEC-1」数列</h1><blockquote><p>给你一个正整数 $n$，有数列 $\{a_n\}:1,2,3,…,n$。</p><p>分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：</p><p> $1\times a+2\times b+c,2\times a+3\times b +c,…,(n-1)\times a+n\times b+c$。</p><p>对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。</p><p>$1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$ 。</p></blockquote><p>…比较有意思的题目？本质上数学题。</p><p>考虑直接递推。设 $f_k$ 表示经历完 $k$ 次操作之后的第一项。那么考虑最开始 $a_2-a_1$ 的值是 $1$ ，之后每次会变成原来的 $(a+b)$ 倍，那么也就是有：</p><script type="math/tex; mode=display">f_{i}=a\cdot f_{i-1}+b\cdot (f_{i-1}+(a+b)^{i-2})+c</script><p>那么也就是</p><script type="math/tex; mode=display">f_i=(a+b)\cdot f_{i-1}+b\cdot(a+b)^{i-2}+c</script><p>考虑高中数学技巧</p><script type="math/tex; mode=display">\frac{f_i}{(a+b)^i}=\frac{f_{i-1}}{(a+b)^{i-1}}+\frac{b}{(a+b)^2}+\frac{c}{(a+b)^i}</script><p>那么可以通过差分得到</p><script type="math/tex; mode=display">f_i=(i-1)\cdot b\cdot (a+b)^{i-2}+(a+b)^{i-1}+c\cdot \sum_{j=0}^{i-2}(a+b)^j</script><p>发现前面很好算，后面是一个等比数列的形式。由于不保证 $p$ 是素数，所以不能直接求逆元。于是考虑分治乘法。具体的，对于一个 $\sum_{i=1}^n(a+b)^i$ 可以这么算：</p><script type="math/tex; mode=display">\sum_{i=1}^n(a+b)^i=\begin{cases}(a+b)^{\frac{n}{2}}\cdot \sum_{i=1}^{\frac{n}{2}}(a+b)^i+\sum_{i=1}^{\frac{n}{2}-1}(a+b)^i&\mathrm{if}~(n~\mathrm{is~even}) \\(a+b)^{\lfloor \frac{n}{2}\rfloor }\cdot \sum_{i=1}^{\lfloor \frac{n}{2}\rfloor }(a+b)^i+\sum_{i=1}^{\lfloor \frac{n}{2}\rfloor -1}(a+b)^i + (a+b)^n &\mathrm{otherwise}\end{cases}</script><p>然后就可以分治做下去了。复杂度 $\rm poly(\log )$ 。</p><h1 id="LuoguP5007-DDOSvoid-的疑惑"><a href="#LuoguP5007-DDOSvoid-的疑惑" class="headerlink" title="[LuoguP5007] DDOSvoid 的疑惑"></a>[LuoguP5007] DDOSvoid 的疑惑</h1><blockquote><p>给定一棵以 1 为根的有根树，定义树的一个毒瘤集为一个集合，并且集合中任意两个元素之间不存在祖先与后代关系。</p><p>定义一个毒瘤集的毒瘤指数为集合内所有元素的价值之和</p><p>要求给定树的所有毒瘤集的毒瘤指数之和，答案对 $10^8+7$ 取模。</p><p>但这个问题太难了，所以我们考虑化简。</p><p>因为点的编号跟它毒瘤指数密切相关，所以我们将会再给出一个整数 T，T = 1 表示 i 号点的毒瘤指数为 i，T = 0，表示所有点的毒瘤指数都是 1。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>不难发现这个可以以子树为状态来转移。</p><p>咕咕咕咕咕。咕是不可能不咕的。咕与不咕，这篇没写完的文章都在这里，不离、不弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;终于！终于不是UVA了！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。&lt;/p&gt;
&lt;p&gt;争取一句话题解…这一弹大概有 $25$ 道题左右吧。 &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="技巧/分块" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%88%86%E5%9D%97/"/>
    
      <category term="技巧/倍增" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E5%80%8D%E5%A2%9E/"/>
    
      <category term="数学/扩展欧几里德" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/左偏树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
      <category term="暴力,brute-force" scheme="https://www.orchidany.cn/tags/%E6%9A%B4%E5%8A%9B-brute-force/"/>
    
      <category term="动态规划/状态合并" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="技巧/行列无关" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E8%A1%8C%E5%88%97%E6%97%A0%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round2] C~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/26/NOIOL-Round-2-题解/</id>
    <published>2020-04-26T03:40:56.000Z</published>
    <updated>2020-04-26T12:23:44.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依旧是按照个人做题时认为的难度排序…</p><p>打比赛的时候严重翻车，比赛经验还是太差劲了啊！</p><p><del>于是这篇文章就变成了游记+翻车实录</del></p><a id="more"></a><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>作为苏打绿死忠的我…觉得普及这个 T1 题目背景and题目名称都很赞！</p><h1 id="C-涂色游戏"><a href="#C-涂色游戏" class="headerlink" title="C 涂色游戏"></a>C 涂色游戏</h1><blockquote><p>你有 $10^{20}$ 个格子，它们从 $0$ 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色：</p><ol><li>编号是 $p_1$ 倍数的格子（包括 $0$ 号格子，下同）染成红色。</li><li>编号是 $p_2$ 倍数的格子染成蓝色。</li><li>编号既是 $p_1$ 倍数又是 $p_2$ 倍数的格子，你可以选择染成红色或者蓝色。</li></ol><p>其中 $p_1$ 和 $p_2$ 是给定的整数，若格子编号是 $p_1$ 或 $p_2$ 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 $k$ 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 $p_1$, $p_2$, $k$，你想知道是否有一种染色方案不是无聊的。</p><p>对于所有测试点：$1 \leq T\leq 10^6$，$1\leq p_1,p_2,k\le 10^9$。</p></blockquote><p>以下是做题时凌乱的内心活动</p><blockquote><p>先开题…嗯，混乱地读了半天题，觉得大概是问是否存在一个 $x$ 和一个 $y$ 使得 $p_1&gt;p_2$ 时</p><script type="math/tex; mode=display">y\cdot p_1\leq x\cdot p_2\leq (x+k-1)\cdot p_2\leq (y+1)\cdot p_1</script><p>然后发现似乎很难处理编号是 $[p_1,p_2]$ 及其倍数的情况。然后就开始摸。摸了一会儿之后发现几个性质：</p><p>1、最多只用考虑 <code>yxyxy</code> 这种分布，即最多算上一个 $x$ 和 $y$ 的公倍数。因为如果存在连续两个 $x$ 和 $y$ 的公倍数之间，没有单独的 $y$ 的倍数，那么就说明 $x|y\cdot t,x|y\cdot (t+1)$，也就证明了 $x|y$ ，而这种情况是显然 <code>Yes</code> 的； </p><p>2、大概是每 $\rm lcm$ 一次循环…然后…</p></blockquote><hr><p>然后，读了半天题，才发现读题读反了…这题是要你去 <code>check</code> 是否对于任意一个 $y$ 都存在一个 $x$ 使得</p><script type="math/tex; mode=display">y\cdot p_1< x\cdot p_2< (x+k-1)\cdot p_2< (y+1)\cdot p_1</script><p>同时也不用考虑 $\rm lcm$ 的问题了，因为遇到 $\rm lcm$ 肯定会涂 $p_1$ 色。所以上式直接换成了拟序。</p><p>那么也就是考虑是否满足</p><script type="math/tex; mode=display">p_1-1\geq (k-1)\cdot p_2</script><p>其中为什么是 $p_1-1$ 呢？因为不考虑 $\rm lcm$ 时这就是最近的界。但是注意到这个界有点宽，当且仅当 $(p_1,p_2)=1$ 的时候，存在这种最劣的情况，即式子 $bp_2-ap_1=1$ 存在整数解。</p><p>然后大概就是个代换，发现同时除以 $(p_1,p_2)$ 之后与原结果是等价的。然后就没了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !y ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k, g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        n = qr(), m = qr(), k = qr() ; </span><br><span class="line">        g = gcd(n, m), n /= g, m /= g ;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ll)(k - <span class="number">1</span>) * min(n, m) &lt; max(n, m) - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-建设城市"><a href="#D-建设城市" class="headerlink" title="D 建设城市"></a>D 建设城市</h1><blockquote><p>球球是一位建筑师。一天，他收到市长的任务：建设城市。球球打算建造 $2n$ 座高楼。为了保证城市美观，球球做出了如下计划：</p><ul><li><p>球球喜欢整齐的事物。他希望高楼从左向右排成一行，编号依次为 $1\sim 2n$。</p></li><li><p>球球喜欢整数，他要求每座高楼的高度都是正整数。</p></li><li><p>由于材料限制，高楼的高度无法超过 $m$。</p></li><li><p>球球喜欢中间高，两边低的造型。他要求前 $n$ 座高楼的高度不下降，后 $n$ 座高楼的高度不上升。</p></li><li><p>球球打算选两座编号为 $x,y$ 的高楼作为这座城市的地标。他认为只有当这两座高楼高度相等时，才会让城市变得美观。</p></li></ul><p>球球把自己的想法告诉了市长。市长希望得知所有建设城市的方案数。两种方案不同，当且仅当某座高楼的高度在两个方案中不同。这个问题可难倒了球球。球球找到了你，希望你能帮他算出答案。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。</p></blockquote><p>下午 vp 这道题的时候是真的降智…首先先上已经写好的题解吧：</p><hr><p>首先考虑不加 $a_x=a_y$ 的限制，单纯计算一个不递减序列的方案数。</p><p>发现本质上是这么一个问题：从 $(0,1)$ 开始走，每一步可以向右走，或者向右上走（此处右上指的是 $(x,y)\to(x+1,y+k)\quad k&gt;0$ 的走法），最终走到 $(n,1),(n,2),(n,3)\cdots (n,m)$ 的方案数。那么不难发现，本质上是在对于两个楼之间的高度差进行拼插。若令 $h_0=0,d_{i}=h_{i}-h_{i-1}$ 的话， 那么本质上就是在解一个如下的方程：</p><script type="math/tex; mode=display">d_1+d_2+\cdots+d_n=m</script><p>本质上就是在求这个式子中非负整数解得个数…然而并不是。由于 $1$ 号楼必然高度 $\geq 1$ ，所以差分之后， 需要保证 $d_1&gt;0$ 。</p><p>考虑做一个容斥，用 $d_1\geq 0$ 的答案减去 $d_1=0$ 时的答案。对于 $d_1\geq 0$ ，本质上就是一个 $n$ 元一次不定方程非负整数解计数。那么答案就是 $\binom{n+m-1}{m}$ 。$d_1=0$ 时，相当于用 $n-1$ 个未知元凑出 $m$ 来，方案数就是 $\binom{n+m-2}{m}$ 。所以可知如果不考虑 $x$ 和 $y$ 的限制，答案应该为 $\left(\binom{n+m-1}{m}-\binom{n+m-2}{m}\right)^2$ 。</p><p>考虑加上 $x$ 和 $y$ 的限制。那么需要分类讨论。</p><p>1、考虑如果 $x$ 和 $y$ 在同侧，那么可以都转化到 $1\leq x\leq y\leq n$ 的情况来做。那么 $x,y$ 之间的数都要相等假设此时 $x$ 和 $y$ 均等于 $z$，那么 $1\sim x$ 的方案数就是 $\binom{x+z-1}{z}-\binom{x+z-2}{z}$ ，$y\sim n$ 的方案数就是 $\binom{n-y+z}{z}$，因为此时相相当于有 $n-y+1$ 个未知元，和为 $z$ 的非负整数解个数。最后把这两部分拼插一下即可。</p><p>2、考虑如果 $x$ 和 $y$ 在异侧，那么两者本质上就没有关系了。于是考虑分别处理 $1\sim x,1\sim y,x\sim n,y\sim n$ 的答案，最后拼插一下即可。</p><p>于是复杂度线性。</p><hr><p>然后是花絮…这题说实话我做了很久很久…以下事情按时间线排布：</p><ul><li>看了这题，觉得 $60$ 分很 ez，然后就在想 $100$ 分怎么搞。因为上次 NOIonline 给我的经验是，生成函数是可以进普及组的，于是觉得这个 100 一定是个生成函数。</li><li>wqy 说是 xxs 组合题。我想了一会儿觉得大概可以转化成从 $(0,1)$ 走到 $(n,m)$ ，每一步可以平着走或者飞到右边一列一个更高的高度上。算了一波，觉得可能跟 $m$ 的 $n$ 元可含 $0$ 有序拆分有关…觉得不太行。</li><li>wqy 说是插板法。我觉得自己是个弱智。因为「 $m$ 的 $n$ 元可含 $0$ 有序拆分」 本质上就是 $n$ 元一次不定方程组 <script type="math/tex; mode=display">x_1+x_2+\cdots +x_n=m</script></li></ul><p>的非负整数解组数。于是觉得枚举 $x$ 的高度然后做就很稳，遂开始写代码。</p><ul><li>写了半天，恍惚中觉得应该对 $\binom{n+m-1}{m}$ 这东西做一个前缀和，因为 $x$ 的高度如果是 $h$ ，那么 $x-1$ 的高度似乎可以是 $0\sim h$ …【注意！这个地方是有两个bug！！</li><li>连写带调试过了好久，发现自己是弟弟，前缀和压根不对。因为枚举的是 $x$ 的高度，所以对于每个 $x$ 的高度，$[1…x-1]$ 的不同方案已经被准确计数了…发现自己的思路乱的很。</li><li>又写了很久，还是不对，心情郁闷。冷静了一下发现 $1$ 号位置，即 $x_1$ ，取值不能为 $0$ 。想了想，觉得容斥一下就好了。</li><li>最后发现 $70$ 分。下了数据之后思考了一下，发现是 <code>case1</code> 里面，如果 $x$ 和 $y$ 都在另一侧，那么转过来应该是 $y&lt;x$…</li></ul><p>写完之后感觉自己花了这么多时间，十分弟弟。总结一下问题：</p><p>1、平时深入思考的情况比较少，遇到这种需要认真思考的东西，思路就会很乱很乱。</p><p>2、自己思维方式一直存在很大问题，加上草稿打的十分乱，就让人做题的时候内心不安静。</p><p>要抓紧改正啊。<del>虽然我觉得可能是我太困了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> num[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> numx[N] ;</span><br><span class="line"><span class="keyword">int</span> numy[N] ;</span><br><span class="line"><span class="keyword">int</span> xnum[N] ;</span><br><span class="line"><span class="keyword">int</span> ynum[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n, x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y ; ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m + n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[m + n + <span class="number">1</span>] = expow(fac[m + n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = (ll)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!((n - x &gt;= <span class="number">0</span>) ^ (n - y &gt;= <span class="number">0</span>)))&#123;</span><br><span class="line">        x = x &lt; n ? x : n - (x - n) + <span class="number">1</span> ;</span><br><span class="line">        y = y &lt; n ? y : n - (y - n) + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) swap(x, y) ; numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = binom(n - y + i, i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) num[i] = addn(num[i - <span class="number">1</span>], decn(binom(n + i - <span class="number">1</span>, i), binom(n + i - <span class="number">2</span>, i))) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans, (ll)numx[i] % P * numy[m - i] % P) ;</span><br><span class="line">        ans = (ll)ans * num[m] % P ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    y = n - (y - n) + <span class="number">1</span> ;</span><br><span class="line">    xnum[<span class="number">0</span>] = ynum[<span class="number">0</span>] = numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = decn(binom(y + i - <span class="number">1</span>, i), binom(y + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) xnum[i] = binom(n - x + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ynum[i] = binom(n - y + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        add(ans, (ll)numx[i] % P * numy[i] % P * ynum[m - i] % P * xnum[m - i] % P) ; <span class="comment">//, cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-简单子序列问题"><a href="#E-简单子序列问题" class="headerlink" title="E 简单子序列问题"></a>E 简单子序列问题</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。</p><p>现在，请你求出 </p><script type="math/tex; mode=display">\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2</script><p>由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。</p><p>对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。</p></blockquote><p>这题似乎是普及题，但是我不知道为什么，就把这题转化到了这个题的对称问题上…导致这题做了很久很久很久…</p><p>以下是题解：</p><hr><p>我来说一个很不正常的解法…不正常在他特别麻烦…特别难调…</p><p>我的做法是先算出全部区间的贡献：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^n(j-i)^2=\sum_{i=1}^n(1^2+2^2+3^2+\cdots +(n-i)^2)</script><p>也就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{(n-i)(n-i+1)(2\times (n-i)+1)}{6}</script><p>然后考虑减掉那些不合法的。具体的，预处理出每个位置左边最近的那个相同颜色的下标 $pre_x$ 。那么 $x$ 和 $pre_x$ 会对左端点在 $1\sim pre_x$ ，右端点在 $x+1\sim n$ 的区间产生贡献。贡献怎么算呢？</p><p>考虑假设一个区间长为 $L$ 。那么第一组 $(pre_x,x)$ 出现时，会有</p><script type="math/tex; mode=display">L^2\to (L-1)^2=L^2-2L+1=L^2-(2L-1)</script><p>第二组出现时：</p><script type="math/tex; mode=display">(L-1)^2\to (L-2)^2=(L-1)^2-2(L-1)+1=(L-1)^2-(2L-3)</script><p>以此类推，当一个区间存在 $t$ 个重复颜色时（即假设某种颜色的数量为 $c$，那么这种颜色的「重复颜色数」为 $c-1$），他需要减去 $(2\cdot t\cdot L-t^2)$ 的贡献。</p><p>考虑拆成两半做：</p><p>1、$2\cdot t\cdot L$</p><p>需要枚举每个位置 $i$ ，设 $j=pre_i$ 。记 $p=\max\{(n-i+1),i\},q=\min\{i,(n-i+1)\}$ 。即 $p$ 是左右两边较长的那个区间，$q$ 是较短的那个。同时记当前区间长度为 $d$，即 $d=i-pre_i$ 。以下默认省略前面的系数 $2$ 。</p><p>那么需要再分三类讨论会被产生贡献的区间长度 $L$ ，以下在计算 $L$ 时，用 $d+\Delta$ 来代替：</p><blockquote><p>（1）$d+1\leq L\leq q+d$ </p><p>对于每个这样的 $L$ ，会存在 $L-d$ 个区间产生合法贡献，所以这部分贡献就是</p></blockquote><script type="math/tex; mode=display">\sum_{L=d+1}^{q+d}L\cdot i=\sum_{i=1}^{q}(d+i)\cdot i</script><blockquote><p>可以通过预处理 $\sum i$ ，$\sum i^2$ 快速计算。</p><p>（2） $q+d+1\leq L\leq p+d$ </p><p>对于每个这样的 $L$ ，由于不能全部取到，所以至多会有 $q$ 个。所以这部分贡献是：</p></blockquote><script type="math/tex; mode=display">\sum_{L=q+d+1}^{p+d}L\cdot q=\sum_{i=q+1}^{p}(d+i)\cdot q</script><blockquote><p>这部分比较好算。</p><p>（3） $p+d+1\leq L\leq n$</p><p>对于每个这样的 $L$ ，发现最多只能取到 $n-L+1$ 次。所以这部分贡献是</p></blockquote><script type="math/tex; mode=display">\sum_{L=p+d+1}^{n}L\cdot (n-L+1)=\sum_{i=p+1}^{n-d}(n-d-i+1)\cdot (d+i)</script><blockquote><p>这一部分同样可以通过预处理来快速计算。</p></blockquote><p>综上，这一部分的复杂度是排序外线性。</p><p>2、$-t^2$ </p><p>设 $i$ 右边第一个和 $i$ 同颜色的元素为 $r_i$ 。</p><p>也就是现在把问题转化成了「{区间内重复出现的数字个数 $-1$ 的平方和」。考虑扫描线。一开始将所有的数都加进线段树。从左开始，每次都删掉一个最左边的元素 $i$。如果这个元素的颜色依旧出现在后面的序列中，那么可以知道对于所有右端点 $\geq r_i$ 的区间，都会少掉一个 $(i, r_i)$ 组成的 <code>pair</code>，也就是会少掉一个重复颜色的元素。所以就是后缀减 $-1$ and 询问后缀的平方和，线段树维护即可。</p><p>这一部分复杂度 $O(n\log n)$ 。   </p><p>如何卡常：</p><p>1、不要用 <code>map</code> .</p><p>2、(mayaohua 在 uoj 群里的高论)发现中间，一段区间内部的平方的和本质上是不会爆 <code>long long</code> 的，所以可以减少取模次数。</p><hr><p>心路历程：</p><ul><li>A 完 T1 之后，发现这题「不就是记一下上次出现的位置，然后减掉左端点在 $[1,pre_x]$、右端点在 $[x,n]$ 内的贡献吗？妥了妥了！」<del>期间甚至嘲讽了一波这题很套路</del></li><li>算了一下发现…这个平方和好像很难算。一波拆分之后，觉得应该分成两半做。比较难的似乎是后面的 $t^2$(很久很久的以后我才发现不是这样)。</li><li>然后开始写写写，期间由于思路混乱(D里面提到的缺点集中展现)，于是写了一会儿才写完(但此时，我只想到了前两部分，没有考虑第三部分)。</li><li>写完之后才意识到…我似乎把这个问题转化到了一个和原问题等难的问题上…就很降智。然后决定先写 $50pts$ 的暴力做法。</li><li>写完暴力才意识到原来扫描线就好了…于是开始写线段树。</li><li>这个线段树我写的就…就很梦幻…我不记得我写过这么梦幻的线段树。大概就是 bug 满天飞…体验极差…</li><li>最终总算是调完了，和 $50pts$ 暴力对着拍了几组觉得很稳。</li><li>因为总觉得自己第一部分推的有问题，所以写了个 $n^3$ 暴力。写完才发现挂惨了…</li><li>冷静了很久，发现是自己推挂了。于是推了推第三部分，发现展开之后式子很长。然后 <code>main</code> 函数中间的那个 <code>for</code> 就写了很长…</li><li>最后在谷上测发现自己 TLE+取模挂了，于是把 <code>map</code> 改成 <code>sort+lower_bound</code> 就 A 掉了…</li></ul><p>…技不如人，技不如人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dec</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; x = x &lt; <span class="number">0</span> ? x + mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">addn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; <span class="keyword">return</span> (x = x &gt; mod ? x - mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">decn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; <span class="keyword">return</span> (x = x &lt; <span class="number">0</span> ? x + mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line">ll tg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] = val[l]  ;</span><br><span class="line">        t[rt] = s[rt] * s[rt] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(ls, l, mid) ;</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">s[rt] = s[ls] + s[rs] ;</span><br><span class="line">t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tg[rt])&#123;</span><br><span class="line">        ll p = tg[rt] * tg[rt] % P ;</span><br><span class="line">        ll pr = r - ((l + r) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">        ll pl = ((l + r) &gt;&gt; <span class="number">1</span>) - l + <span class="number">1</span> ;</span><br><span class="line">        tg[ls] += tg[rt], tg[rs] += tg[rt] ;</span><br><span class="line">        dec(t[ls], decn(<span class="number">2l</span>l * s[ls] * tg[rt] % P, p * pl)) ;</span><br><span class="line">        dec(t[rs], decn(<span class="number">2l</span>l * s[rs] * tg[rt] % P, p * pr)) ;</span><br><span class="line">        dec(s[ls], tg[rt] * pl % P) ; dec(s[rs], tg[rt] * pr % P) ; tg[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        dec(t[rt], decn(<span class="number">2l</span>l * s[rt] % P, <span class="number">1l</span>l * (r - l + <span class="number">1</span>))) ;</span><br><span class="line">        dec(s[rt], <span class="number">1l</span>l * (r - l + <span class="number">1</span>)) ; tg[rt] += <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    s[rt] = s[ls] + s[rs] ; t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ll res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) res += query(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) res += query(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll sum1[N] ;</span><br><span class="line">ll sum2[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll fuck[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">base[i] = tmp[i] = qr() ;</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) pos[i] = buc[base[i]] ; buc[base[i]] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        sum1[i] = addn(sum1[i - <span class="number">1</span>], i) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">sum2[i] = addn(sum2[i - <span class="number">1</span>], i * i)  ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(ans, (i + <span class="number">1</span>) * i * (<span class="number">2l</span>l * i + <span class="number">1l</span>l) % P) ;</span><br><span class="line">    ans = ans * Inv6 % P ;</span><br><span class="line">    ll q, maxx, minx, m, p, len1, len2, d ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos[i])</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">q = n - i + <span class="number">1</span> ;</span><br><span class="line">        maxx = q, minx = pos[i] ;</span><br><span class="line">        p = i - pos[i], m = n - p ;</span><br><span class="line">        d = decn(sum1[m], sum1[maxx]) ;</span><br><span class="line">        <span class="keyword">if</span> (minx &gt; maxx) swap(minx, maxx) ;</span><br><span class="line">        len2 = m - maxx, len1 = maxx - minx ;</span><br><span class="line">      <span class="comment">//part1</span></span><br><span class="line">        add(res, sum2[minx]) ;</span><br><span class="line">        add(res, sum1[minx] * p) ;</span><br><span class="line">      <span class="comment">//part2</span></span><br><span class="line">        add(res, p * minx * len1) ;</span><br><span class="line">        add(res, minx * decn(sum1[maxx], sum1[minx], P) % P) ;</span><br><span class="line">        <span class="comment">//part3</span></span><br><span class="line">        dec(res, <span class="number">2l</span>l * p * d % P) ;</span><br><span class="line">        dec(res, p * p * len2 % P) ;</span><br><span class="line">add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * d % P) ;</span><br><span class="line">dec(res, decn(sum2[m], sum2[maxx])) ;</span><br><span class="line">        add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * p * len2 % P) ;</span><br><span class="line">        dec(ans, <span class="number">2l</span>l * res % P) ; res = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">           fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                buc[base[j]] ++ ;</span><br><span class="line">                fuck[i][j] = fuck[i][j - <span class="number">1</span>] + (buc[base[j]] &gt; <span class="number">1</span>) ;</span><br><span class="line">                add(ans, fuck[i][j] * fuck[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        nxt[i] = buc[base[i]] ? buc[base[i]] : n + <span class="number">1</span>, buc[base[i]] = i ;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        buc[base[i]] ++, val[i] = val[i - <span class="number">1</span>] + (buc[base[i]] &gt; <span class="number">1</span>) ;</span><br><span class="line">    build (<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, i, n) % P) ;</span><br><span class="line">        <span class="keyword">if</span> (nxt[i] &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, nxt[i], n) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-游戏"><a href="#F-游戏" class="headerlink" title="F 游戏"></a>F 游戏</h1><blockquote><p>小 A 和小 B 正在玩一个游戏：有一棵包含 $n=2m$ 个点的有根树（点从 $1\sim n$ 编号），它的根是 $1$ 号点，初始时两人各拥有 $m$ 个点。游戏的每个回合两人都需要选出一个自己拥有且之前未被选过的点，若对手的点在自己的点的子树内，则该回合自己获胜；若自己的点在对方的点的子树内，该回合自己失败；其他情况视为平局。游戏共进行 $m$ 回合。</p><p>作为旁观者的你只想知道，在他们随机选点的情况下，第一次非平局回合出现时的回合数的期望值。</p><p>为了计算这个期望，你决定对于 $k=0,1,2,\cdots,m$，计算出非平局回合数为 $k$ 的情况数。两种情况不同当且仅当存在一个小 A 拥有的点 $x$，小 B 在 $x$ 被小 A 选择的那个回合所选择的点不同。</p><p>由于情况总数可能很大，你只需要输出答案对 $998244353$ 取模后的结果。</p><p>$n\leq 5000$ 。</p></blockquote><p><del>第一眼看到「期望」字样其实我是想弃的。</del></p><p>不算十分有趣的题，比较中规中矩地考察了<del>我没有的</del>硬实力。</p><p>考虑因为是随机选点，先要计算一个 $f_{i,j}$ 表示子树 $i$ 内凑出 $j$ 个不同的「非平局点对」的方案数。转移考虑两部分:</p><p>1、子树之间的贡献：就是普通的树上背包那么转移。注意到如果界定的好是可以 $n^3\to n^2$ 的。</p><p>2、根与子树之间的贡献：加法原理一波带走即可。</p><p>然后考虑 $f_{1,i}$ 就是整棵树凑出 $i$ 个不合法对，也就是不平局 $i$ 次的方案数。考虑利用这个东西，本质上还是很难求出共非平局 $k$ 次的方案数，因为无法快速统计剩下那些平局的贡献。但是考虑，可以快速计算出非平局 $\geq k$ 次的方案数，就是 $f_{1,k}\cdot (\frac{n}{2}-k)! $ 。至于为什么呢…可以理解为剩下 $n-2\cdot k$ 个人，固定住一半个人，剩下一半的人随便找一个匹配，那么方案数就是剩下一半人的全排列，即 $(\frac{n-2\cdot k}{2})!$ 。</p><p>那么考虑令 $f_i$ 表示至少非平局 $i$ 次的方案数，设 $g_i$ 为恰好平局 $i$ 次的方案数，那么根据二项式反演有 </p><script type="math/tex; mode=display">f_i=\sum_{j=i}^{m}g_j\binom{j}{i}\cdot (-1)^{j-i}</script><p>于是复杂度 $O(n^2)$，略卡常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll F[N] ;</span><br><span class="line">ll G[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll tmp[N] ;</span><br><span class="line">ll f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> suma[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll comb[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span> ; f[x][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa)</span><br><span class="line"><span class="keyword">continue</span> ; do_dp(to(k), x) ;</span><br><span class="line">fill(tmp, tmp + size[to(k)] + size[x] + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = min(size[x], n / <span class="number">2</span>) ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = min(size[to(k)], n / <span class="number">2</span> - i) ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f[to(k)][j])</span><br><span class="line">add(tmp[i + j], f[x][i] * f[to(k)][j] % P, P) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size[x] + size[to(k)] ; ++ i) f[x][i] = tmp[i] ;</span><br><span class="line">        suma[x] += suma[to(k)] ; size[x] += size[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line"><span class="keyword">if</span> (!base[x])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(size[x] - suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(".in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">//freopen(".out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, fac[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]), suma[i] = base[i] ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add_e(u, v) ; do_dp(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>], P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        F[i] = f[<span class="number">1</span>][i] * fac[n / <span class="number">2</span> - i] % P ;</span><br><span class="line"><span class="comment">//debug(f[1], 0, n) ; debug(F, 0, n) ; debug(fac, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(G[i], F[j] * comb[j][i] % P, P) : dec(G[i], F[j] * comb[j][i] % P, P) ;</span><br><span class="line">    debug(G, <span class="number">0</span>, n / <span class="number">2</span>, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是太弱啊…不过打这一场比赛确实很浪费精力，毕竟一道线段树+一道 xxs 组合加起来我能调 $7h$ 也是相当弱菜了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是按照个人做题时认为的难度排序…&lt;/p&gt;
&lt;p&gt;打比赛的时候严重翻车，比赛经验还是太差劲了啊！&lt;/p&gt;
&lt;p&gt;&lt;del&gt;于是这篇文章就变成了游记+翻车实录&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="好多好多细节" scheme="https://www.orchidany.cn/tags/%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%BB%86%E8%8A%82/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="组合计数/有技巧的计数" scheme="https://www.orchidany.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【赛题整理】[NOIonline Round1] A~F题解</title>
    <link href="https://www.orchidany.cn/2020/04/24/NOIOLRound1-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.orchidany.cn/2020/04/24/NOIOLRound1-题解/</id>
    <published>2020-04-24T11:47:41.000Z</published>
    <updated>2020-04-29T13:12:52.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…</p><p>于是就打算整理一下这六道题。感觉…还是有点东西的吧。</p><p>题目难度按我自己心目中的升序排序。</p><blockquote><p>心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。</p></blockquote><a id="more"></a><h1 id="A-文具订购"><a href="#A-文具订购" class="headerlink" title="A 文具订购"></a>A 文具订购</h1><blockquote><p>小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：</p><ol><li>圆规，每个 $7$ 元。</li><li>笔，每支 $4$ 元。</li><li>笔记本，每本 $3$ 元。</li></ol><p>小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：</p><ol><li>$n$ 元钱必须正好用光，即 $7a+4b+3c=n$。</li><li>在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。</li><li>在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。</li></ol><p>请你帮助小明求出满足条件的最优方案。可以证明若存在方案，则最优方案唯一。</p><p>对于全部的测试点，保证 $0 \leq n \leq 10^5$。</p></blockquote><p>考虑贪心。发现大概是 $14$ 元一套，于是就从 $\lfloor\frac{n}{14}\rfloor$ 枚举到 $0$ 。如果钱数不是 $14$ 的倍数，当然是把剩下的用来买 $3$ 和 $4$ 最合理。于是就模拟一遍即可，同时再去找 $a+b+c$ 的最大值。大概是 div2B 的难度？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = n / <span class="number">14</span> ;</span><br><span class="line">    <span class="keyword">while</span> (ans &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        outp = <span class="number">0</span> ;</span><br><span class="line">        a = b = c = ans ;</span><br><span class="line">        pq = a * <span class="number">14</span>, res = n - pq ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= res / <span class="number">3</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> ((res - i * <span class="number">3</span>) % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                outp = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> * ans + i + (res - i * <span class="number">3</span>) / <span class="number">4</span> &gt; a + b + c)</span><br><span class="line">                    b = ans + (res - i * <span class="number">3</span>) / <span class="number">4</span>, c = ans + i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (outp)</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c) ;</span><br><span class="line">        <span class="keyword">else</span> ans -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-冒泡排序"><a href="#B-冒泡排序" class="headerlink" title="B 冒泡排序"></a>B 冒泡排序</h1><blockquote><p>给定一个 $1 ∼ n$ 的排列 $p_i$，接下来有 $m$ 次操作，操作共两种：</p><ol><li>交换操作：给定 $x$，将当前排列中的第 $x$ 个数与第 $x+1$ 个数交换位置。</li><li>询问操作：给定 $k$，请你求出当前排列经过 $k$ 轮冒泡排序后的逆序对个数。</li></ol><p>对一个长度为 $n$ 的排列 $p_i$ 进行一轮冒泡排序的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1 to n-1:</span><br><span class="line">  if p[i] &gt; p[i + 1]:</span><br><span class="line">    swap(p[i], p[i + 1])</span><br></pre></td></tr></table></figure><br>对于所有测试点：$2 \leq n,m \leq 2 \times 10^5$，$t_i \in \{1,2\}$，$1 \leq x &lt; n$，$0 \leq k &lt; 2^{31}$。</p></blockquote><p>这题在考场上写了神必线段树…复杂度也不对…就很弱智。</p><p>大概就是首先要去洞见冒泡排序的一个性质。每轮冒泡排序会让每个元素排到他后面第一个比他大的元素之前，把最大的元素移到序列最后。假设这是一对 $(i,j)$ ，$j$ 是 $i$ 后面第一个大于 $i$ 的元素。那么考虑这个操作使得， $i$ 移动到 $j$ 前面一个位置，同时所有 $x$ 之间不会彼此交换。</p><p>回顾这一过程，发现 $i+1\le x\le j-1$ 的所有 $x$ 的逆序对(此处特指 $x$ 与 $1\sim x-1$ 形成的逆序对)数量都会向前移动一位且不变(中间只会进行跟 $i$ 有关的操作)，且由于本质上 $i$ 与前面构成的逆序对数量等于 $j$ 与前面构成的逆序对数量 (因为此时并不存在一个比 $i$ 小的 $k$ 满足 $a_k&gt;a_i$ ，因为根据冒泡排序这会让 $a_i$ 被 $a_k$ 换掉成为前面某个「对」的 $x’$) ，所以此时 $j$ 的逆序对数为 $0$，那么 $i$ 的逆序对数也为 $0$ 。</p><p>更进一步，本题相当于需要维护一个序列 $\{p_n\}$，支持：</p><p>1、单点加/减（维护初始逆序对数</p><p>2、询问</p><script type="math/tex; mode=display">\left(\sum_{p_i>k} p_i\right)-\left(\sum_{p_i > k} k\right)</script><p>考虑这东西就拿一个树状数组维护一下权值就好了。复杂度 $m\log n$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    <span class="keyword">int</span> p ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &lt; y.v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= n ; p += low(p)) b[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += b[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] += c1 ;</span><br><span class="line">        t[rt] += c2 ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, c1, c2) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, c1, c2) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    t[rt] = t[rt &lt;&lt; <span class="number">1</span>] + t[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask1(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask1(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask2(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask2(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> t, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].v), base[i].p = i ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        res[base[i].p] = ask(base[i].p) ;</span><br><span class="line">        ans += res[base[i].p] ; add(base[i].p, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, res[i], res[i], <span class="number">1</span>) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;c) ;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(res[c], res[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], -res[c], <span class="number">-1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], -res[c + <span class="number">1</span>], <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (base[c].v &lt; base[c + <span class="number">1</span>].v) </span><br><span class="line">res[c + <span class="number">1</span>] ++ ; <span class="keyword">else</span> res[c] -- ;  </span><br><span class="line">            swap(base[c], base[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], res[c], <span class="number">1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], res[c + <span class="number">1</span>], <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ret ;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = ask1(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line">                ret -= (ll)c * ask2(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; c &lt;&lt; " " &lt;&lt; ask1(1, 1, n, c + 1, n) &lt;&lt; " " &lt;&lt; ask2(1, 1, n, c + 1, n) &lt;&lt; endl ;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>最后还是写的线段树，略略略</del></p><h1 id="C-跑步"><a href="#C-跑步" class="headerlink" title="C 跑步"></a>C 跑步</h1><blockquote><p>小 H 是一个热爱运动的孩子，某天他想给自己制定一个跑步计划。小 H 计划跑 $n$ 米，其中第 $i(i \geq 1)$ 分钟要跑 $x_i$ 米（$x_i$ 是正整数），但没有确定好总时长。</p><p>由于随着跑步时间增加，小 H 会越来越累，所以小 H 的计划必须满足对于任意 $i(i &gt;1)$ 都满足 $x_i \leq x_{i-1}$。</p><p>现在小 H 想知道一共有多少个不同的满足条件的计划，请你帮助他。两个计划不同当且仅当跑步的总时长不同，或者存在一个 $i$，使得两个计划中 $x_i$ 不相同。</p><p>由于最后的答案可能很大，你只需要求出答案对 $p$ 取模的结果。 </p><p>对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq p &lt; 2^{30}$。</p></blockquote><p>发现就是整数拆分问题。分拆数问题本质上是 $n$ 也无标号的第二类斯特林数问题（第二类斯特林数是 $n$ 有标号但是 $k$ 无标号）。</p><p>那么对于这个问题，考虑两种 $dp$.</p><ul><li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}+f_{i-j,j}</script><p>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢掉一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</p><ul><li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：</li></ul><script type="math/tex; mode=display">g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script><p>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</p><p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p><p>但是上述做法是 $n^2$ 的。总结两个 $dp$ 的优劣，发现如果采用根号分治的策略，对于 $f$ 只转移 $&lt; \sqrt n$ 的，对于 $g$ 只转移 $\geq \sqrt n$ 的，那么两者均只需要 $n\sqrt n$ 的时空代价（因为大于 $\sqrt n$ 的数不会用超过 $\sqrt n$ 个）。</p><p>具体的，考虑对先用 $f$ 求出来 $j&lt; \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字：就是第一维把 $\sqrt n$ 当作步长转移即可。</p><p>之后考虑如何合并答案。发现 $f,g$ 对于同一个 $n$，计数的部分互斥且互补，那么就可以直接乘法原理解决。合并是个卷积状物，但由于本题只需要求第 $n$ 项，所以直接算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">403</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, p ;</span><br><span class="line"><span class="keyword">int</span> f[N][B] ;</span><br><span class="line"><span class="keyword">int</span> g[N][B] ;</span><br><span class="line"><span class="keyword">int</span> X[N], Y[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">    S = n / B + <span class="number">1</span> ; X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; B ; ++ i) f[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; B ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) f[i][j] = f[i][j - <span class="number">1</span>] ;</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p ;</span><br><span class="line">            X[i] = f[i][j] ; <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; X[i] &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span> ; Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S &amp;&amp; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B) (g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) (g[i][j] += g[i - j][j]) %= p ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S ; ++ j)</span><br><span class="line">            (Y[i] += g[i][j]) %= p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        (ans += <span class="number">1l</span>l * X[i] * Y[n - i] % p) %= p ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-序列"><a href="#D-序列" class="headerlink" title="D 序列"></a>D 序列</h1><blockquote><p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p><p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p><p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p><p>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in \{1,2\}$，$1\le u_i,v_i \le n$。</p></blockquote><p>被教育了，我大概并查集这方面就是白痴中的战斗机了。</p><p>考虑大概能琢磨出这么几个没啥用的性质：1、如果 $a,b$ 和 $b,c$ 两对之间分别被 $1$ 相连，那么相当于 $a$ 和 $c$ 被 $1$ 相连；2、如果 $a,b$ 之间 $0$ 相连，$b,c$ 之间 $0$ 相连，那么可以知道 $a$ 和 $c$ 就相当于有一条 $1$ 边。</p><p>然后…大概就可以搞一个边带权并查集了。同一个集合内部如果只有 $1$ 边，那么总和可以随意分配；如果某个集合内部向自己连了 $1$ 边和 $0$ 边，那么就可以让某两个元素同时加减，只要和是偶数即可。</p><p>其实也不难吧…还是自己过于弱菜啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> D[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x] ;</span><br><span class="line">    <span class="keyword">int</span> dad = find(fa[x]) ;</span><br><span class="line">    val[x] ^= val[fa[x]] ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = dad ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2)</span><br><span class="line">res[f1] |= val[x] ^ val[y] ^ c ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">val[f1] = val[x] ^ val[y] ^ c ;</span><br><span class="line">        fa[f1] = f2 ; res[f2] |= res[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sign</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> t, u, v, ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            val[i] = f[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">fa[i] = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), D[i] = A[i] - B[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;u, &amp;v) ;</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">1</span>) t -= <span class="number">2</span> ; merge(t, u, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">f[i] += D[i] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f[p] += get_sign(val[i]) * D[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i) ;</span><br><span class="line"><span class="keyword">if</span> (p != i) f[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (res[i] &amp;&amp; f[i] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f[i] != <span class="number">0</span>)  &#123; ans = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">puts</span>(ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-魔法"><a href="#E-魔法" class="headerlink" title="E 魔法"></a>E 魔法</h1><blockquote><p>C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。</p><p>现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。</p><p>注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 </p><p>$1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。</p><p>$1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。</p></blockquote><p>其实也不难？考虑暴力做的话就是分层图最短路，状态数是 $O(nk)$ 的。可以拿到洛谷数据的 $70$ 分。大概就是先拿每条边预处理出 $f_{i,j,1}$ 表示 $(i,j)$ 之间只修改了 $1$ 次的答案。考虑转移的话，自然就是以 $1$ 为步长转移(小技巧，只用枚举最小规模的子问题)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; ll w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; pq ;</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">-1</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i ^ j) dis[i][j] = (ll)<span class="number">1e12</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w) ;</span><br><span class="line">        A[u][v] = w, dis[u][v] = min(dis[u][v], w) ;</span><br><span class="line">        edg[i][<span class="number">0</span>] = u, edg[i][<span class="number">1</span>] = v, edg[i][<span class="number">2</span>] = w ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = dis[i][j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = edg[k][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">int</span> y = edg[k][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                f[i][j][<span class="number">1</span>] = min(f[i][j][<span class="number">1</span>], dis[i][x] + dis[y][j] - (ll)edg[k][<span class="number">2</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= pq ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= n ; ++ o)</span><br><span class="line">                    f[i][j][k] = min(f[i][j][k], f[i][o][k - <span class="number">1</span>] + f[o][j][<span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">if</span> (!pq) <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n][pq] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最后的转移形式为 </p><script type="math/tex; mode=display">f_{i,j,k}=\min_{o}\{f_{i,o,k-1}+f_{o,j,1}\}</script><p>这是一个扩展矩乘的形式。所以可以直接把预处理出来的 $f_{i,j,1}$ 作为矩阵的元素，快速幂即可。</p><h1 id="F-最小环"><a href="#F-最小环" class="headerlink" title="F 最小环"></a>F 最小环</h1><blockquote><p>给定一个长度为 $n$ 的正整数序列 $a_i$，下标从 $1$ 开始编号。我们将该序列视为一个首尾相邻的环，更具体地，对于下标为 $i$, $j(i \leqslant j)$ 的两个数 $a_i$, $a_j$，它们的距离为 $\min(j-i, i+n-j)$。</p><p>现在再给定 $m$ 个整数 $k_1$, $k_2$,…, $k_m$，对每个 $k_i(i=1$, $2$,…, $m)$，你需要将上面的序列 $a_i$ 重新排列，使得环上任意两个距离为 $k_i$ 的数字的乘积之和最大。</p><p>对于所有测试数据：$1 \leqslant m \leqslant n \leqslant 2 \times 10^5$，$0 \leqslant k \leqslant \lfloor n/2\rfloor$，$1 \leqslant a_i \leqslant 10^5$。</p></blockquote><p>为什么把这题放在 F 呢？因为一方面我最优化比较菜，另一方面我一看这种题就有种「信我，你不会」感觉233</p><p>这居然是个贪心…我也是人傻掉… 感觉自己贪心真的是菜爆了啊！</p><p>首先考虑相邻的元素大概是 $t~,~t+k~,~t+2\times k~,~t+3\times k~,~t+4\times k\cdots \pmod{n}$ 这种。记这个数列为「$t$ 在模 $n$ 意义下关于 $k$ 的轨迹」。</p><p>那么可以解一下方程求得循环节的长度：</p><script type="math/tex; mode=display">t\equiv t+p\times k\pmod n</script><p>根据同余的基本性质可以得出</p><script type="math/tex; mode=display">p\equiv 0\pmod {\frac{n}{(n,k)}}</script><p>那么可以知道最小的循环长度为 $\frac{n}{(n,k)}$ 。那么最多就会有 $(n,k)$ 条不同的轨迹。</p><p>另一方面，如果存在两个不同的 $t_0,t_1$，他们某一刻轨迹产生了相交，即</p><script type="math/tex; mode=display">t_0+p\times k\equiv t_1+q\times k\pmod{n}</script><p>那么会有</p><script type="math/tex; mode=display">(t_0-t_1)\equiv k\times (q-p)\pmod n</script><p>因为这个式子等价于一个一元二次不定方程，可知如果这个式子可以解出一组整数解，必须满足 </p><script type="math/tex; mode=display">(n,k)|(t_0-t_1)</script><p>那么也就是说，如果两个 $t$ 的轨迹有相交，那么需要这两个 $t$ 之间的距离是 $(n,k)$ 的倍数。这也间接证明了，至多只会有 $(n,k)$ 条本质不同的轨迹。</p><p>考虑根据排序不等式，乘积方面一定是大的和大的拼在一起，小的和小的拼在一起更优。所以可以预处理每个不同的环长 $\zeta$ ，对于每一个 $\zeta$，把从大到小排好序的 $a_i$ ，$a_1\sim a_{\zeta}$ 分到第一组，$a_{\zeta+1}\sim a_{2\cdot \zeta}$ 分到第二组，以此类推。考虑对于同一组，最好的放的方式就是类似这样：</p><script type="math/tex; mode=display">\ldots n-3,n-1,n,n-2,n-4\ldots</script><p>于是就可以按照奇偶性分个类预处理了。复杂度 $O(nd(n)+m\log n)$ 。后面那个 $\log$ 是求 $\gcd$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ll ans ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line">ll res[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base, base + n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j += i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i - <span class="number">2</span> ; ++ k)</span><br><span class="line">                    res[i] += (ll)base[j + k] * (ll)base[j + k + <span class="number">2</span>] ;</span><br><span class="line">                res[i] += (ll)base[j] * (ll)base[j + <span class="number">1</span>] ;</span><br><span class="line">res[i] += (ll)base[j + i - <span class="number">1</span>] * (ll)base[j + i - <span class="number">2</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">ans += (ll)base[i] * (ll)base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) ;</span><br><span class="line"><span class="keyword">if</span> (!k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[n / gcd(n, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树状数组</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…&lt;/p&gt;
&lt;p&gt;于是就打算整理一下这六道题。感觉…还是有点东西的吧。&lt;/p&gt;
&lt;p&gt;题目难度按我自己心目中的升序排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】我说啊…</title>
    <link href="https://www.orchidany.cn/2020/04/21/%E6%88%91%E8%AF%B4%E5%95%8A/"/>
    <id>https://www.orchidany.cn/2020/04/21/我说啊/</id>
    <published>2020-04-21T10:05:06.000Z</published>
    <updated>2020-04-29T12:59:31.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。</p><p>我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。</p><p>我要学的还有很多。</p><p>我一直在路上。</p><a id="more"></a><h1 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h1><p>今天和我校生物奥赛同僚偶然突然提到了「支撑下去的信念」这个话题。自己其实一直很迷惑吧。从今年不知道什么时候开始，感觉自己就是在混日子，一天混过来再混一天。斯嘉丽的那句 _After all, Tomrrow is another day!_ 倒是和我的想法不谋而合——只不过是 _another new_ 和 _another numb_ 罢了。</p><p>于是我的回答自然是模棱两可，并且向他表达了自己的质疑「我就不明白了，为什么大家这么多人都在这里拼啊？都拿银牌以上不显然是不可能的吗？」</p><p>他想了想，说「我们教练说，竞赛锻炼的是一种能力，学竞赛的目的也应该是锻炼能力、锻炼一种可以让你学文化课时、办事时、将来学习时都有用的能力」。</p><p>我突然愣了愣。不是愣在这个观点的新颖，而是愣在我之前，再早、再早一些的时候，仿佛也用这句话劝说过别人。总之，我清楚地记得我说过、坚信过类似的内容…但…</p><p>但不知道什么时候，我仿佛已经忘记了自己的初心。一天天一天天，我一直在拿「我没有别人那么喜欢OI，所以不努力也可以理解」来搪塞自己、坚信 OI 是高智商对低智商的剥削，看到曾经自己的文字「不要功利地学 OI」时开始变得麻木、甚至有些纳闷——看着当时自己对这个世界的劝告，才发现「活成你最讨厌的人」与我仅有咫尺…我迷茫了。</p><p>他又问：「你的目标是什么？」</p><p>我：……</p><p>他：「没事的。目标就是要去寻找的嘛，人活着不就是去寻找活着的目标吗？就算找了很久找不到，这也是一种精彩的人生吧。」</p><p>我愣了愣。看着一旁洒进食堂的阳光，周围的嘈杂在那一刹那仿佛消失不见了；筷子掉到桌子上，发出悠长的回响，不绝于耳。</p><h1 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h1><p>总会因为奇奇怪怪的事情陷入东亚式情绪内卷…</p><p>感觉有很多事情都是自讨没趣。自己找来痛苦让自己承受。习惯痛苦之后，积极的生活态度反而让人感到陌生…</p><p>争取逐渐削弱这个内卷的过程吧。</p><h1 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h1><p>郁郁寡欢…不过山崎将义的「One more time, one more chance」里面倒是提过</p><blockquote><p>如果只是缓解寂寞，随便一个人就可以了吧。</p></blockquote><p>…我一直把这个当做信条。自己会经常期许很多不能得到的东西、不能传达的心意。如果这么想的话，可能自己会稍微好受一点吧。</p><p>感觉自己从未真正变得成熟过…</p><h1 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h1><p>我…很烦「浮躁」的感觉。如果每天不给我几分钟，让我去仔细思考一下人生，我就会感到难以入睡。</p><p>我才发现，虽然我很向往热烈，但是骨子里还是喜欢孤独一人的感觉。自由、不受约束。身上不需要承担那些若有若无的责任…我向往人与人之间的羁绊，但我同时也在一直回避这些。</p><h1 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h1><p>最近一直很忙，忙着把自己之前做过的题都复习一遍，不给自己的青春留下遗憾。</p><p>计数啦，刘汝佳的紫书/蓝书啦，李煜东的书啦…都是我未尽的回忆。</p><p>我就像一个小心翼翼的孩子，认真地找回失落的每一块拼图，笨笨地拼回原处…拼的东倒西歪，但算不上不满意。</p><p>就这样吧。尽我所能，把自己丢下的、落下的，一件一件拾起来。</p><p>但…我还没有看过远处的风景啊，现在就要准备沿途返回了吗？我不甘心的吧？</p><p>可能，有些人属于这里，有些人不属于这里。这有点宿命论的意味——虽然我是不信的，但你不得不说，有时候这东西似乎就是贯穿万事万物的那一条透明的线，引领着每个人走向自己的终章。</p><p>终章之后呢？是一片新的天地吧。</p><p>但…还是最好不要停下来吧。</p><h1 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h1><p>我被关在笼子里。</p><p>周围密布的…是黑色。</p><p>外面…似乎也套着笼子。这个机房是笼子，这栋综合楼是笼子，这个学校是笼子。</p><p>要继续说下去的话，这个城市，这个地区，这个世界都是笼子。似乎找不到任何一缕自由的风。</p><p>虽然我看不见——因为最靠近我的这个笼子已经将我的双眼层层蒙蔽。但我坚信。</p><p>其实我是被自己的心关起来的，我自己很清楚。</p><p>我不断地反复，跟自己博弈、决斗、撕扯、争吵…最终是赢了呢？还是输了呢？我只知道无论输赢，我都还是停留在这个笼子里。</p><p>所以，外界可能并不存在什么笼子，罩着我的只有一层笼子，其余的只是我内心积攒的恐惧而已。</p><p>但是…虽然自己提出了疑问，但是我依然相信外面是有笼子的、数不清的那种…</p><p>是的，这种寄托方式，是坚信。区分「坚信」和「迷信」的根据大概就是，坚信可以包容质疑，但是迷信从来不容置疑。</p><p>你看我为数不多的信念，也只能用在这种地方了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。&lt;/p&gt;
&lt;p&gt;我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。&lt;/p&gt;
&lt;p&gt;我要学的还有很多。&lt;/p&gt;
&lt;p&gt;我一直在路上。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】RE:从零开始的计数生活</title>
    <link href="https://www.orchidany.cn/2020/04/21/RE-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E6%95%B0%E7%94%9F%E6%B4%BB/"/>
    <id>https://www.orchidany.cn/2020/04/21/RE-从零开始的计数生活/</id>
    <published>2020-04-21T09:19:55.000Z</published>
    <updated>2020-04-29T12:35:43.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是整理一下自己做过的计数题？</p><p>感觉有很多题都很神(不)仙(会)。慢慢来吧…</p><p>感觉其实本质上考察的还是 dp 功底+组合技巧/能力。</p><p>总的来说，如果没有计数头脑(个人认为是可以练出来的)的人，遇到这种题一般要么是 <code>dfs</code>/子集枚举，要么是状压，大概是常见比赛里面 $3/5/7/10$ 这档最低的部分分…所以计数这东西如果不是天赐之才，其实是需要深入研究的吧。</p><p><del>等会儿，我扯这些干什么？扯这些能帮我学会计数吗？</del></p><a id="more"></a><p><del>咕咕咕咕咕，只写了题面，题解留给大家自行思考</del></p><h1 id="BJWC2018-最长上升子序列"><a href="#BJWC2018-最长上升子序列" class="headerlink" title="[BJWC2018]最长上升子序列"></a>[BJWC2018]最长上升子序列</h1><blockquote><p>现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。$n\leq 20$ 。</p></blockquote><p>其实是把数据范围改小了，原题是个打表题233</p><p>考虑观察最长上升子序列的性质。记 $h_i$ 为截止到前 $i$ 位中最长上升子序列的长度，同时设 $g_{i}=\max_{j=1}^i\{h_j\}$ ，那么可以知道</p><script type="math/tex; mode=display">g_{i}\leq g_{i+1}\leq g_{i}+1</script><p>发现这个序列差分之后正好是 $01$ 串，不妨设 $\{g_n\}$ 的一阶差分是 $\{d_n\}$，于是考虑对着这个东西 $dp$ 。即设 $f_{i,s}$ 表示以 $i$ 结尾的，差分序列是 $s$ 的排列数。考虑从小向大插入每个数。假设当前的 $x$ 插在原来的串的 $i$ 和 $i+1$ 之间，那么因为 $x$ 比之前任何一个数都大，那么可以知道 $h’_{i+1}=h_i+1$ ，同时假设存在某个 $k&gt;i$ 使得 $a_k$ 是第一个大于 $a_i$ 的数，那么可以知道根据差分，应该将 $d_k$ 置为 $0$ ，所以从大到小扫的时候不断更新即可。</p><p>于是最后复杂度 $O(2^n\cdot n^2)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> fac[N] ; </span><br><span class="line"><span class="keyword">int</span> size[M] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][M] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)_bit[i] = <span class="number">1</span> &lt;&lt; i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">size[i] = size[i -(i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//debug(_bit, 1, n) ;</span></span><br><span class="line"><span class="comment">//debug(size, 1, m) ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> ; </span><br><span class="line">fill(f[d ^ <span class="number">1</span>], f[d ^ <span class="number">1</span>] + t + <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span> ; s &lt;= t ; ++ s)&#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">2333</span> ; </span><br><span class="line">add(f[d ^ <span class="number">1</span>][s &lt;&lt; <span class="number">1</span>], f[d][s]) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &gt;= <span class="number">0</span> ; -- k)&#123;</span><br><span class="line"><span class="keyword">int</span> t = (s &gt;&gt; k) &lt;&lt; (k + <span class="number">1</span>) ; </span><br><span class="line">t  |= _bit[k], t |= (_bit[k] - <span class="number">1</span>) &amp; s ; </span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; s) pos = k ; </span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">2333</span>) t ^= _bit[pos + <span class="number">1</span>] ;</span><br><span class="line">add(f[d ^ <span class="number">1</span>][t], f[d][s]) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">d ^= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line"><span class="comment">//debug(fac, 1, n) ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">add(ans, (<span class="keyword">int</span>)(<span class="number">1l</span>l * f[(n - <span class="number">1</span>) &amp; <span class="number">1</span>][i] * (size[i] + <span class="number">1</span>) % P)) ;</span><br><span class="line">ans = (ll)ans * expow(fac[n], P - <span class="number">2</span>) % P ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AGC002-F-Left-Most-Ball"><a href="#AGC002-F-Left-Most-Ball" class="headerlink" title="[AGC002 F]Left Most Ball"></a>[AGC002 F]Left Most Ball</h1><blockquote><p>给你 $n$ 种颜色的球，每个球有 $k$ 个，把这 $n\times k$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色(初始球不包含白色)，求有多少种不同的颜色序列，答案对 $10^9+7$ 取模。</p><p>$1\leq n, k\leq 2000$。</p></blockquote><h1 id="CQOI2011-放棋子"><a href="#CQOI2011-放棋子" class="headerlink" title="[CQOI2011]放棋子"></a>[CQOI2011]放棋子</h1><blockquote><p>在一个 $m$ 行 $n$ 列的棋盘里放一些颜色在 $1\sim c$ 之间的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？</p><p>$1\le n,m\le 30$，$1\le c\le 10$，总棋子数 $\le \min(250,n\times m)$。</p></blockquote><h1 id="LuoguP5241-序列"><a href="#LuoguP5241-序列" class="headerlink" title="[LuoguP5241] 序列"></a>[LuoguP5241] 序列</h1><blockquote><p>构建一个 $n$ 个点的有向图 G，初始没有任何边。</p><p>接下来构建一个长度为 E 的边的序列 A，序列中每条边都是满足 $1≤s,t≤n$ 且 $s≠t$ 的有向边 $(s,t)$，且序列中的边互不相同。按照顺序把这些边加入到 G 中，每次加入后计算当前图的强连通分量个数并记录下来，得到一个新的长度为 E 的正整数序列 B。如果两个边的序列得到的 B 相同则称它们本质相同。</p><p>请问有多少种本质不同的边的序列，</p><p>$1\leq n\leq 400$ 。</p></blockquote><h1 id="SDOI2010-地精部落"><a href="#SDOI2010-地精部落" class="headerlink" title="[SDOI2010]地精部落"></a>[SDOI2010]地精部落</h1><blockquote><p>传说很久以前，大地上居住着一种神秘的生物：地精。地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 $N$ 的山脉 $H$ 可分为从左到右的 $N$ 段，每段有一个<strong>独一无二</strong>的高度 $H_i$ ，其中 $H_i$ 是 $1$ 到 $N$ 之间的正整数。</p><p>如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。</p><p>地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。</p><p>地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。</p><p>地精们希望这 $N$ 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。</p><p>现在你希望知道，长度为 $N$ 的可能有地精居住的山脉有多少种。两座山脉 $A$ 和 $B$ 不同当且仅当存在一个 $i$，使得 $A_i≠B_i$。由于这个数目可能很大，你只对它除以 $P$ 的余数感兴趣。</p><p>对于 $100\%$ 的数据，满足 $3≤N≤4200$，$P≤10^9$。</p></blockquote><h1 id="ARC074C-RGB-Sequence"><a href="#ARC074C-RGB-Sequence" class="headerlink" title="[ARC074C]RGB Sequence"></a>[ARC074C]RGB Sequence</h1><blockquote><p>有一个序列 $\left\{a_{n}\right\}$，要给序列中的每个元素一种颜色：红/绿/蓝。有 $m$ 条限制 $(l,r,x)$，表示格子 $l\sim r$ 中颜色的种类数要恰好为 $x$，问可行的方案数。</p><p>$ 1\leq n,m\leq 300 $ 。</p></blockquote><h1 id="ARC071D-Infinite-Sequence"><a href="#ARC071D-Infinite-Sequence" class="headerlink" title="[ARC071D] Infinite Sequence"></a>[ARC071D] Infinite Sequence</h1><blockquote><p>定义 $n-$可爱序列 指无限长的由 $\{1,2…,n\}$ 组成的序列。同时 $a_1,a_2…$满足以下条件:</p><p>1.第 $n$ 个及以后的元素是相同的，即若 $\forall i,j\geq n,a_i=a_j$ 。</p><p>2.对于每个位置 $i$，紧随第 $i$ 个元素后的 $a_i$ 个元素是相同的，即若 $\forall  i&lt;j&lt;k≤i+a_i,a_j=a_k$。</p><p>输入 $n$，请输出 $n-$可爱序列的数量 $\bmod 10^9+7$ 。</p><p>$n\leq{10^6}$。</p></blockquote><h1 id="Luogu-P5464-缩小社交圈"><a href="#Luogu-P5464-缩小社交圈" class="headerlink" title="[Luogu]P5464 缩小社交圈"></a>[Luogu]P5464 缩小社交圈</h1><blockquote><p>社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。</p><p>现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。</p><p>请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。</p><p>$1\leq n\leq 2000,1\leq l_i,r_i\leq 4000$ 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分大概是整理一下自己做过的计数题？&lt;/p&gt;
&lt;p&gt;感觉有很多题都很神(不)仙(会)。慢慢来吧…&lt;/p&gt;
&lt;p&gt;感觉其实本质上考察的还是 dp 功底+组合技巧/能力。&lt;/p&gt;
&lt;p&gt;总的来说，如果没有计数头脑(个人认为是可以练出来的)的人，遇到这种题一般要么是 &lt;code&gt;dfs&lt;/code&gt;/子集枚举，要么是状压，大概是常见比赛里面 $3/5/7/10$ 这档最低的部分分…所以计数这东西如果不是天赐之才，其实是需要深入研究的吧。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;等会儿，我扯这些干什么？扯这些能帮我学会计数吗？&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模型" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做·第二弹</title>
    <link href="https://www.orchidany.cn/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
    <id>https://www.orchidany.cn/2020/04/21/简单题选做·第二弹/</id>
    <published>2020-04-21T09:19:23.000Z</published>
    <updated>2020-04-27T06:38:01.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感觉自己真的是菜成一团…</p><p>感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？</p><p>可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？</p><p>人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。</p><p>Hide your skill from your clumsiness, make you fast in slowly.</p><p>本文共计 15 道题。</p><a id="more"></a><h1 id="UVA1407-Caves"><a href="#UVA1407-Caves" class="headerlink" title="UVA1407 Caves"></a><a href="https://uva.onlinejudge.org/external/14/p1407.pdf" target="_blank" rel="noopener">UVA1407 Caves</a></h1><blockquote><p>给定一棵 $n$ 个节点、边带权的树。$q$ 次询问，每次给定一个 $x$ ，询问从根出发走多少个点，满足走过的边权和 $&lt;x$ 且经过的点最多。点可以重复经过，但只会被计算一次。</p><p>$n\leq 500,q\leq 10^5,x\leq 5\cdot 10^8$ 。</p></blockquote><p>一个比较基础的思想是背包，但这时空显然不是背包能做的。这个地方考虑，点数只有 $500$，也就是至多只能走 $500$ 个点。于是就考虑把状态定义到点上，即 $f_{x,j}$ 表示以 $x$ 为根走了 $j$ 个不同的点的最小代价。注意到由于可以重复经过，所以多记一维 $0/1$ ，即 $f_{x,j,0/1}$ 表示以 $x$ 为根走了 $j$ 个不同的点，最终没回到/回到了 $i$ 的最小代价。考虑转移：</p><script type="math/tex; mode=display">\begin{aligned}f_{x,j,1}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,1}+w\times 2\} \\f_{x,j,0}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,0}+w,f_{x,k,0}+f_{y,j-k,1}+w\times 2\} \end{aligned}</script><p>其中第二个转移表达的是这条路径的终点是否在以 $y$ 为根的子树内。注意转移的时候要倒序枚举 $j$ ，保证当前转移不重复。</p><p>发现 $f_{root}$ 显然是单调的，于是回答询问时二分即可。复杂度 $O(n^2+q\log n)$ 。因为好像有证明，这种东西的复杂度是 $O(n^2)$ 的…</p><h1 id="BZOJ4160-Exclusive-Access-2"><a href="#BZOJ4160-Exclusive-Access-2" class="headerlink" title="BZOJ4160 Exclusive Access 2"></a><a href="https://darkbzoj.tk/problem/4160" target="_blank" rel="noopener">BZOJ4160 Exclusive Access 2</a></h1><blockquote><p>给出 $n$ 个点 $m$ 条边的无向图，定向得到有向无环图，使得最长路最短。</p><p>$1\leq n ≤ 15, 1\leq m ≤ 100$ .</p></blockquote><p>大概是 $\rm dilworth$ 定理的应用，考虑 $\rm dilworth$ 定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $m$ 是反链的最大长度。则 $X$ 可以被划分成 $m$ 个但不能再少的链。 即：链的最少划分数 $=$ 反链的最长长度.。</p></blockquote><p>同时也存在对偶定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $r$ 是其最长链的大小。则 $X$ 可以被划分成 $r$ 个但不能再少的反链。</p></blockquote><p>也就是：</p><blockquote><p><strong>偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong> 。</p></blockquote><p>其中「全序集」指的是这样的一个偏序集 $(Y,\leq )$ ，改偏序集内部所有元素两两<strong>均可比</strong>。反链则指的是这样一个偏序集 $(Z,\leq )$ ，改偏序集内部所有元素两两均<strong>不可比</strong>。</p><p>换言之，假设给原图定向，那么根据 dilworth 定理，最长链的长度就是最小的独立集的大小，其中「独立集」的定义为原无向图中距离大于 $1$ 的两个点可以组成一个独立集(不考虑连通性)，因为只要两者没有边相连，两者的关系就是「不可比」。</p><p>于是这东西就可以状压了。$f_{s}$ 表示 $s$ 集合中最少有多少个独立集。这东西就可以先预处理一下每个 $s$ 是否是独立集，然后 $3^n$  暴力 $dp$ 即可。</p><h1 id="POJ3735-Training-little-cats"><a href="#POJ3735-Training-little-cats" class="headerlink" title="POJ3735 Training little cats"></a><a href="http://poj.org/problem?id=3735" target="_blank" rel="noopener">POJ3735 Training little cats</a></h1><blockquote><p>现在给你一个长度为 $n$ 的序列，开始这个序列都是 0。对这个序列一共有三种操作：</p><p>操作 1：输入一个 $x$，把 $x$ 位置上的值 $+1$ 。</p><p>操作 2：输入一个 $x$ 一个 $y$，交换 $x$，$y$ 位置上的值。</p><p>操作 3：输入一个 $x$，把 $x$ 位置上的值变成 $0$ 。</p><p>我们接着对这个序列进行 $k$ 次操作。</p><p>我们把这 $k$ 次操作叫做一轮，现在这个 $k$ 个操作进行了 $m$ 轮。</p><p>输出最后的序列。</p><p>$1\leq n\leq 100,1\leq k\le 10^4,1\leq m\leq 10^9$ 。</p></blockquote><p>…矩阵快速幂神题 sto</p><p>考虑一开始把这个空的序列记作一个 $n+1$ 维向量 $A:[1,0,0\cdots,0]$ 。其中第一维留空赋值为 $1$ ，$2\sim n+1$ 分别代表序列的第 $1\sim n$ 号元素。</p><p>那么考虑由于 $m$ 比较大，但是每次操作都是一样的，于是启发要用矩阵快速幂。</p><p>考虑三个操作，以下默认右乘转移矩阵 $T$ 、位置 $p,q$ 都是原序列右移一位的位置。</p><p>1、位置 $p$ 的数 $+1$ 。</p><p>考虑对于 $n+1$ 阶单位矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&0&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>考虑如何使得乘上这个矩阵的某个变形之后，位置 $p$ 实现 $+1$ 。考虑矩阵运算的本质是 $c_{i,j}=\sum_{k}a_{i,k}\cdot b_{k,j}$ ，那么 $A’_{1,p}=\sum _{i=1}^{n+1}A_{1,i}\cdot T_{i,p}$ ，因为 $A_{1,1}$ 恒定为 $1$ ，所以可知应该让 $T_{1,p}=1$ 实现 $+1$ 的功能。比如 $p=2$ ：</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&1&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>2、交换位置 $p,q$ 的数。</p><p>还是考虑 $n+1$ 阶单位矩阵。观察矩阵乘法本质，$A’_{1,q}=\sum_{i=1}^{n+1}A_{1,i}T_{i,q}$ ，那么一方面要让之前 $q$ 位置的数消失，一方面又要让 $A’_{1,q}=A_{1,p}$ ，于是应该让 $T_{q,q}=0,T_{p,q}=1$ 。 即如果 $p=1,q=2$ ，则应该是：</p><script type="math/tex; mode=display">\begin{bmatrix}1&0&0&\cdots &0\\ 0&0&1&\cdots&0 \\ 0&1&0&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>3、位置 $p$ 的数清零。</p><p>…$T_{p,p}=0$ 就好了。</p><p>注意到上面都是单独进行一个操作的情况。如果出现多个操作冗杂在一起，那么一方面可以建 $k$ 个转移矩阵，每次新的转移矩阵要乘上之前的矩阵，这样复杂度就是 $O(n^3k+n^3\log m)$ 。有点爆炸。</p><p>注意到可以把这 $k$ 次操作都放到一个转移矩阵里面，第 $2,3$ 操作就要相应发生改变，$2$ 操作就需要对换 $T$ 的 $p$ 列和 $q$ 列，$3$ 操作则需要把 $p$ 这一列全部清零。这样复杂度就是 $O(nk+n^3\log m)$ 了， 可以通过本题。</p><p>但其实 $n$ 可以出到 $2000$。注意到本题中最多只有 $O(n)$ 个不为零的位置。所以只需要对这些位置做矩阵乘法即可。复杂度变成了 $O(nk+n^2\log m)$ 。</p><p>哦，poj 上多组数据，那没事了（</p><h1 id="UVA1437-String-painter"><a href="#UVA1437-String-painter" class="headerlink" title="UVA1437 String painter"></a><a href="https://www.luogu.com.cn/problem/UVA1437" target="_blank" rel="noopener">UVA1437 String painter</a></h1><blockquote><p>给定一个串 $s$ 和一个目标串 $t$。每次可以将 $s$ 的连续一段刷成一个同一个字符。求最少多少次操作使得 $s$ 变成 $t$ 。</p><p>$1\leq |s|,|t|\leq 500$ 。</p></blockquote><p>一开始的错误思路：考虑如果两个对应位置的字符相同，那么就可以把这对字符删掉不需要管，剩下的 $s$ 就可以看做空串。对这个进行 $dp$ ，$f_{i,j}$ 表示刷好了区间 $[i,j]$ 内字符的最小代价，每次转移考虑如果 $i$ 和 $j$ 相同就从 $f_{i+1,j}$ 或者 $f_{i,j-1}$ 转移过来之类的…反正很乱很乱很乱…</p><p>写了一发之后发现挂了。理了理思路，发现首先有个错误的点，即不一定「删掉不管」是最优的，可能相同的字符会先被覆盖然后再涂上。所以这个思路本来就是错的。之后再考虑，以 $1$ 为步长转移本身没有道理，因为转移时枚举一个子状态，要枚举一个可能存在的确定量。</p><p>所以设 $f_{i,j}$ 表示一个空串的 $[l,r]$ 刷成 $t[l…r]$ 的最少代价。转移时考虑枚举一个和 $l$ 或 $r$ 同色的端点 $k\in[l,r]$ 分成两个子问题即可。之后考虑如何把 $s$ 刷成 $t$ 。设 $g_i$ 表示 $s[1…i]$ 刷成 $t[1…i]$ 的最小代价。考虑比起一个空串，$s$ 中可能存在某些与 $t$ 对应相等的位置。这时只要 <code>chkmax(g[i], g[i - 1])</code> 即可。为了保证转移全面，直接枚举断点转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt; n ; ++ len)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - len ; ++ i)&#123;</span><br><span class="line">j = i + len ; f[i][j] = f[i][j - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &lt;= j - <span class="number">1</span> ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (t[j] == t[k]) </span><br><span class="line">chkmin(f[i][j], f[k + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">g[i] = f[<span class="number">1</span>][i] ;</span><br><span class="line">chkmin(g[i], s[i] == t[i] ? g[i - <span class="number">1</span>] : P) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= i ; ++ k)</span><br><span class="line">chkmin(g[i], g[k - <span class="number">1</span>] + f[k][i]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为什么总是学不会？</span></span><br></pre></td></tr></table></figure><h1 id="UVA1427-Parade"><a href="#UVA1427-Parade" class="headerlink" title="UVA1427 Parade"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA1427 Parade</a></h1><blockquote><p>有一个由 $n+1$ 条横向路和 $m+1$ 条竖向路构成的网格图，每条横向路有一个高兴值和经过的时间。</p><p>现在想从网格的最下方走到最上方，求能得到的最大的高兴值是多少。</p><p>走路有限制：不能多次经过同样的路，也不会从下往上走。另外，在每条横向路上所花的时间不能超过 $k$ 。</p><p>$1\leq n\leq 100,1\leq m\le 10^4$ 。</p></blockquote><p>一开始想的是直接暴力 $dp$，枚举每一行的每个出发点(即从上一行转移过来的点)，考虑向左走一定是走一个包含当前点的最大子段和，向右也是。然后一开始觉得这个思路很有道理，但有点疑惑：我把 $n$ 和 $m$ 读反了，导致我以为这个做法是 $n^2m$ 没准可以卡过去的…后来发现是 $m^2n$ …虽然 $n^2m$ 也必定过不去就是了。</p><p>后来想了想，大概可以定义一个比较靠谱的状态。$f_{i,j}$ 表示到达了 $(i,j)$ 的最大高兴值。那么每次转移可以定向，从右边或者从左边。注意到由于存在 $k$ 的限制，决策区间具有单调性。所以可以用单调队列优化掉一个 $m$ 。</p><p>好像很简单的样子…但是不能一眼 A 就是罪过吧…</p><h1 id="UVA11795-Mega-Man’s-Mission"><a href="#UVA11795-Mega-Man’s-Mission" class="headerlink" title="UVA11795 Mega Man’s Mission"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA11795 Mega Man’s Mission</a></h1><blockquote><p>洛克人最初只有一种武器 “Mega Buster”（这种武器可以消灭特定的一些机器人），你需要按照一定的顺序消灭 n 个其他机器人。每消灭一个机器人你将会得到他的武器（也可能没有得到武器），而这些武器可以消灭特定的机器人。你的任务是计算出消灭所有机器人的<strong>顺序总数</strong>。注意：一个机器人的武器可能可以消灭自己，但这对最终答案没有影响，因为必须先消灭这个机器人才能够得到他的武器。</p><p>$1\leq n\leq 16$ 。</p></blockquote><p>其实是很水的题…只是记录一个坑点。遇到这种求顺序总数的时候，我大脑总会选择性宕机…准确来说，显然这题是要预处理一个 $g_s$ 表示杀死 $s$ 中的怪物后可以获得那些武器。然后考虑 $f_s$ 表示杀死 $s$ 中的怪兽的顺序总数。对于 $f$ 的转移，我一开始是想的是要首先枚举每个元素，再去枚举这个元素第几个出现合法，但是这就需要再记一个其他元素的顺序，然后就爆炸了。</p><p>这也反映了自己并没有理解认真理解 $dp$ 子问题重叠的本质。考虑如何简化子问题。发现无论以什么顺序转移，最后一个加进去的元素是固定的(感性理解)。或者换句话说我们并不关心某个元素 $x$ 在集合内第几个出现，这些状态都可以合并到集合较小时 $x$ 最后一个加入的状态。所以只需要枚举最后一个元素+判断合法性即可。</p><p>菜成一坨，GGGGGGGGG。</p><h1 id="UVA1625-Color-Length"><a href="#UVA1625-Color-Length" class="headerlink" title="UVA1625 Color Length"></a><a href="https://uva.onlinejudge.org/external/16/p1625.pdf" target="_blank" rel="noopener">UVA1625 Color Length</a></h1><blockquote><p>输入两个长度分别是 $n$ 和 $m$ 的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p><p>记 $L(c)$ 为关于颜色 $c$ 和合并之后的排列的一个函数，定义如下：</p><script type="math/tex; mode=display">L(c)=\max_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\} - \min_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\}</script><p>你的任务是找一种合并方式，使得所有 $L(c)$ 的总和最小。</p><p>$1\leq n,m\leq 5000$ 。</p></blockquote><p>考虑朴素的状态当然是 $f_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 的最小总和…等下，似乎这东西并不可以很好的转移，因为考虑对于每个前驱状态，并不是很好记录每个颜色第一出现的位置，同时也不好维护最后出现的位置，根本没法转移。</p><p>考虑一个 trick，提前计算贡献。即虽然其余的都很麻烦，但是可以比较方便地知道有哪些颜色一定没有合并完。所以可以每次转移时，计算还没有合并完的贡献。这样做本质上是把贡献分摊到每个元素上面。因为考虑这种转移，对于每个终止状态，并不关心前面代价转移的形式，只关心代价转移的结果。</p><p>于是就预处理一个 $g_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 时有多少个字母还没有闭合。剩下的 $nm$ 转移即可。</p><h1 id="UVA1218-Perfect-Service"><a href="#UVA1218-Perfect-Service" class="headerlink" title="UVA1218 Perfect Service"></a><a href="https://onlinejudge.org/external/12/p1218.pdf" target="_blank" rel="noopener">UVA1218 Perfect Service</a></h1><blockquote><p>一个网络中有 $n$ 个节点，由 $n-1$ 条边连通，每个节点是服务器或者客户端。如果节点 $u$ 是客户端，就意味着 $u$ 所连接的所有点中有且仅有一台服务器。求最少要多少台服务器才能满足要求。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>这题比较水，主要是整理一下，给自己提个醒。如果设 $f_{x,0/1}$ 表示 $x$ 当根不选/选自己的话，注意到会出现 $f_{son_x,0}$ 没法转移到 $f_{x,1}$ 这种情况，因为不知道 $son_{son_x}$ 选没选。这种定义状态的方式就过于模糊。</p><p>于是考虑因为难以记儿子，所以记父亲。$f_{x,0/1/2}$ 分别表示「$x$ 和 $fa_x$ 都没选」、「$x$ 选了 $fa_x$ 不管(因为选不选都不引起冲突)」、「$x$ 没选 $fa_x$ 选了」，于是就是：</p><script type="math/tex; mode=display">\begin{aligned}f_{x,0}&=\min_{y\in son(x)}\{f_{y,1}+\sum_{z\in son(x),z\not=y} f_{z,0}\}\\f_{x,1}&=1+\sum_{y\in son(x)} \min\{f_{y,1}+f_{y,2}\} \\f_{x,2}&=\sum_{y\in son(x)} f_{y,0} \end{aligned}</script><p>注意到，其中 $f_{x,1}$ 这个状态，本质上是两个状态的合并。可以考虑分裂成 $f_{x,3/4}$ 表示 $x$ 选了 $fa_x$ 选没选，发现被转移的时候，两者转移是一样的。所以就可以简并成一个状态。</p><h1 id="UVA12099-The-Bookcase"><a href="#UVA12099-The-Bookcase" class="headerlink" title="UVA12099 The Bookcase"></a><a href="https://uva.onlinejudge.org/external/120/p12099.pdf" target="_blank" rel="noopener">UVA12099 The Bookcase</a></h1><blockquote><p>有 $n$ 本书，每本书有一个高度 $h_i$ 和一个宽度 $w_i$。 现在要构建一个 $3$ 层的书架，你可以选择将 $n$ 本书放在书架的哪一层。设 $3$ 层高度(每层书的最大高度)之和为 $h$，书架总宽度为 $w$，要求 $h×w$ 尽量小。</p><p>$3\le n\leq 70,1\leq h_i\leq 300,1\leq w_i\le 30$ 。</p></blockquote><p>本质上是要最优化两样东西，宽度和高度。所以不妨让其中一个变得有序，所以考虑先按照 $h_i$ 把所有书降序排序。</p><p>考虑如何设计状态。发现如果某一层有最高的那本书，那么无论怎么放书，这一层的高度都不会再受影响；同时，把每一层的高度和宽度都记下来是没有必要的，于是可以记某一维为某个确切数值时另一维的最小值。具体的，$f_{i,j,k}$ 表示考虑了前 $i$ 本书，第二层的宽度为 $j$，第三层宽度为 $k$ 时，第二层、第三层的最小高度和。此处记宽度为状态是因为一方面高度和宽度是对称的，另一方面宽度的数据范围显然比高度要小。</p><p>考虑转移。首先应该定一个顺序，比如第二层高度应该大于第三层，那么此时转移有：</p><script type="math/tex; mode=display">f_{i,j,k}=\min\{f_{i-1,j,k}~,~f_{i-1,j-w_{i},k}+[j-w_i=0]\cdot h_i~,~f_{i-1,j,k-w_{i}}+[k-w_i=0]\cdot h_i\}</script><p>其中第三个决策当且仅当第二层已经有了一本书。</p><p>考虑这样 $dp$ 的复杂度，似乎是 $O(n\cdot \left(\sum w_i\right)^2)$ ，有点爆炸。考虑如何剪枝：</p><p>1、$j+k\leq \sum_{t=1}^iw_t$ 。</p><p>2、$\sum_{t=1}^iw_t-j-k+30\geq j,j+30\geq k$。</p><p>其中第一可行性个比较好理解，第二个最优性剪枝是在说，因为 $\max\{w_i\}\leq 30$，所以如果高层的宽度比低层的宽度 $+30$ 还要大，那么不妨将几本书放到低层，可知这样放一定不会使结果更劣。</p><p>这么一波剪枝之后似乎就跑的飞快了…似乎是要滚一下第一维的样子。</p><p>大概转移and初始赋值这些会有一点细节的样子吧。</p><h1 id="UVA10559-Blocks"><a href="#UVA10559-Blocks" class="headerlink" title="UVA10559 Blocks"></a><a href="https://uva.onlinejudge.org/external/105/p10559.pdf" target="_blank" rel="noopener">UVA10559 Blocks</a></h1><blockquote><p>有 $n$ 个带有颜色的方块，没消除一段长度为 $x$ 的连续的相同颜色的方块可以得到 $x^2$ 的分数，让你用一种最优的顺序消除所有方块使得得分最多。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>大概是比较神仙的 $dp$ 了吧…</p><p>第一感觉肯定就是 $f_{l,r}$ 嘛，但是这么做的话本质上就变成贪心了，因为可能转移时，$f_{l,k}$ 和 $f_{k,r}$ 是消掉中间一部分，再合并起来的模式。注意到，对于一段 $i,j$，假设 $i&lt;q&lt;j$ 满足 $q\sim j$ 同色，$i&lt;o&lt;p&lt;q$ 满足 $o\sim p$ 与 $q\sim j$ 同色，那么一种决策就是把这两段合并。但是注意到可能还会存在一个区间 $i&lt;s&lt;t&lt;o$ 满足 $s\sim t$ 和 $o\sim p$ 同色。</p><p>于是这就启发(个鬼，这怎么可能想得出来)要多记一维状态 $d$，即 $f_{l,r,d}$ 表示 $l\sim r$ 的这段区间内，区间右侧还有 $d$ 个元素和 $r$ 同颜色时的最大得分。这样每次就以「和右端点颜色相同的颜色段」为子决策进行转移。那么需要枚举每次有多少个块和右端点一起删掉，在这基础枚举一个和右端点同色的、靠左的点进行转移，表示右端点所在的同色段暂时先不删，加入继续向左延伸的长同色段的一部分。</p><p>复杂度的话，状态是 $O(n^3)$ 的，然后我这种写法好像很迷幻，<del>我觉得应该是 $n^5$ 但不知道为什么测出来极限数据(即所有颜色都相同)时运算量在 $n^4$ 量级</del>  …剪枝是要剪的，每次只关心和 $r$ 同色的元素就好了。</p><p>好的，我又重新写了一下测了一下，觉得应该把访问记忆化结果也算 $1$ 次运算。发现 $100$ 个相同的颜色放在一起，这么写的运算量大概是 $258712510\approx2.6\cdot 10^8$，大概 $1s$ 内是可以跑出来结果的(uoj custom test 900ms左右)。$200$ 个颜色相同的就已经是紫荆花之恋那题跑不出来的程度了(即 $14s$ 以内跑不出来，只能本地测试)，似乎足足要 $1\min+$，大概是 $8136350020\approx8\cdot 10^9$ 的运算量<del>中间可执行文件还一度被系统给 kill 掉了</del> 。</p><p>然后…然后我就加了一个好像很牛逼的剪枝，大概就是判断一下 $l\sim r$ 这一整段是不是同色，如果是的话就直接算完了返回即可。发现这样之后极端数据就应该是只有两种颜色然后左右交替这种，就可以在 $370\sim400ms$ 左右跑出来<del>但似乎应该还是过不了，因为极限可以有15组数据，每组都这个速度肯定跑不进3s鸭</del>。</p><p>然后发现这个某个区间是否同色可以预处理，然后就预处理了一下，发现一组快的话只需要 $320ms$ 左右了…</p><p>然后又改了一下，发现可以稍微贪一下，「枚举每次有多少个块和右端点一起转移走」显然是最大的那个快最好了。但这并没有快…</p><p>删了点重复计算和冗杂判断…发现大概是稳定在 $320ms$ 左右了…</p><p>…发现自己是个弟弟，如果要把右边和左边合并的话，那肯定是全都一起合并最优。所以现在大概是真正的 $O(n^4)$ 算法了？一组大概是 $200ms$ 左右了…人艰不拆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1 最大点 400ms</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r, j = lst[r] ; i &gt;= l ; j = lst[j], i = lst[i])</span><br><span class="line"><span class="keyword">if</span> (i != j + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ; </span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (check(l, r)) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;<span class="comment">//剪枝 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l &amp;&amp; base[i] == base[r] ; -- i)&#123;</span><br><span class="line">chkmax(f[l][r][t], solve(l, i - <span class="number">1</span>, <span class="number">0</span>) + (t + r - i + <span class="number">1</span>) * (t + r - i + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line"><span class="keyword">if</span> (base[j] == base[r]) </span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, r - i + <span class="number">1</span> + t)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2 最大点 320- ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (g[r] &lt;= l) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;</span><br><span class="line">chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= g[r] ; -- i)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> pq = t + r - i + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, pq)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ; Q = T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">n = qr() ;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line"><span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line"><span class="built_in">memset</span>(lst, <span class="number">0</span>, <span class="keyword">sizeof</span>(lst)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, Q - T) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">lst[i] = buc[base[i] = qr()], buc[base[i]] = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line"><span class="keyword">if</span> (base[i] == base[j]) g[i] = j ; <span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>, n, <span class="number">0</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本3 200- ms 左右 此时根本不需要判整段是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//if (g[r] &lt;= l) return f[l][r][t] = (t + r - l + 1) * (t + r - l + 1) ;</span></span><br><span class="line">chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = lst[g[r]] ; j &gt;= l ; j = lst[j])</span><br><span class="line">chkmax(f[l][r][t], solve(j + <span class="number">1</span>, g[r] - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, (t + r - g[r] + <span class="number">1</span>) )) ;</span><br><span class="line"><span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA1380-A-Scheduling-Problem"><a href="#UVA1380-A-Scheduling-Problem" class="headerlink" title="UVA1380 A Scheduling Problem"></a><a href="https://onlinejudge.org/external/13/p1380.pdf" target="_blank" rel="noopener">UVA1380 A Scheduling Problem</a></h1><blockquote><p>给定一棵树，pks把其中某些边改成了有向边。现在要求把所有边都改成有向边，求最长链的长度最小值。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>考虑首先，对于这种带方向性的计算链长，在树上一般都是要分成两部分做。于是不妨令 $f_i$ 表示从 $i$ 开始，到 $i$ 子树中的某个点结束的最长链，令 $g_i$ 表示到 $i$ 结束，起点是子树内某个点的最长链。然后开始分类讨论，设当前点为 $x$ ：</p><p>1、如果对于某个 $x$ ，该点与所有儿子的连边均为有向边，那么：</p><p>那么就是比较朴素的转移。</p><script type="math/tex; mode=display">f_{x}=1+\max_{y\in son(x)}\{f_{y}\cdot [\exists(x,y),x\to y]\}\\g_{x}=1+\max_{y\in son(x)}\{g_{y}\cdot [\exists(y,x),y\to x]\}\\</script><p>2、如果存在某个 $y\in son(x)$ ，$(x,y)$ 是无向边，那么： </p><p>那自然是再分类讨论这条边重定向成 $x\to y$ 还是 $y\to x$ 。但…这样做毕竟是 $2^{\mathrm{count}(son(x))}$ 的，如果一棵树全都是无向边那人就没了。</p><p>考虑观察一点更深刻的性质。发现如果对于某个 $y$ ，被定向成了 $y\to x$ ，那么考虑对于其他 $g_z&lt;g_y$ 的 $(x,z)$ 未定向的 $z\in son(x)$ ，一定是要定向成 $z\to x$ 的。原因是，定向成 $z\to x$ 对当前没有任何贡献，因为边不带权，且 $y$ 转移过来一定更优；同时 $z\to x$ 对另一边的 $f$ 的转移没有任何贡献。综上，这样做一定不会使得结果更劣。</p><p>那么就可以考虑，一开始用 <code>vector&lt;int&gt;</code> 将所有无向边连接的儿子给 <code>push_back</code> 进来。对于 $f$ 和 $g$ 分别处理。这个地方需要注意到题目中有个定理：</p><blockquote><p>假如 $\rm G$ 是一棵树，那么需要的天数是 $k$ 或 $k+1$ 。$k$ 满足：$k$ 是 $\rm G$ 中所有链中一条链能包含的最多顶点数。</p><p>链的定义：在一条路径 $ P=(x_1, x_2, …, x_k)$中 ，对于任意的 $i=1,2,…,k-1$，总有一条从 $x_i$ 指向 $x_{i+1}$ 的有向边。</p></blockquote><p><del>但其实这个定理也可以没有用。因为只需要在外层套一个二分就好了。</del>·</p><p>这提示我们只关心最长链是否 $&gt;k$，而不关心是否真的被最小化了。也就是说，我们致力于保证 $f$ 和 $g$ 是最优的，但是不用考虑 $f$ 和 $g$ 怎么合并——因为这个地方，可能会出现最优化 $g$ 和 $f$ 的时候，对于一条无向边被用了两次。但这并不重要，因为可能存在这么一个局面， $f_x$ 此时没有被最优化，$g_x$ 也没有被最优化，但是 $f_x+g_x\leq k$ 并且两者的决策不相交——这就可以保证至少在 $x$ 这里 $k$ 是合法的。那么就考虑在排完序扫两遍的过程中记录贡献即可。</p><p>注意一个问题，由于这个状态记录的不是子树的最大值(当然也可以多记一个这个)，所以如果中有以某点为根，路径长度 $&gt;k$ 的，需要将这个信息向上传导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_in</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; <span class="keyword">char</span> w ;</span><br><span class="line">res = cnt = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; n = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; u)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ret ;</span><br><span class="line">        ret = <span class="number">1</span>, n = <span class="built_in">std</span> :: max(u, n) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%c"</span>, &amp;v, &amp;w) &amp;&amp; v)&#123;</span><br><span class="line">            fa[v] = u ; n = <span class="built_in">std</span> :: max(n, v) ;</span><br><span class="line">            <span class="keyword">if</span> (w == <span class="string">'d'</span>) add_e(u, v, <span class="number">2</span>), add_e(v, u, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w == <span class="string">'u'</span>) add_e(u, v, <span class="number">1</span>), add_e(v, u, <span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">else</span> add_e(u, v, <span class="number">0</span>), add_e(v, u, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">std</span> :: max(ans, len) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; val(k) == <span class="number">2</span>) dfs(to(k), x, len + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> f[x] &lt; f[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> g[x] &lt; g[y] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">    f[x] = g[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> F, G, df, dg ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!do_dp(to(k), x)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!val(k)) son[x].p_b(to(k)) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val(k) &gt; <span class="number">1</span>)</span><br><span class="line">                 f[x] = <span class="built_in">std</span> :: max(f[x], f[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> g[x] = <span class="built_in">std</span> :: max(g[x], g[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    F = f[x] ; G = g[x] ;</span><br><span class="line"><span class="keyword">if</span> (son[x].empty()) <span class="keyword">return</span> (<span class="keyword">bool</span>)(F + G &lt;= ans) ;</span><br><span class="line">    f[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_f) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], g[son[x][i]]) ;</span><br><span class="line"><span class="comment">//debug(suf, 0, n) ;</span></span><br><span class="line"><span class="keyword">if</span> (F + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) f[x] = F ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, f[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (df + dg &lt;= ans) f[x] = <span class="built_in">std</span> :: min(f[x], df) ;</span><br><span class="line">&#125;</span><br><span class="line">    g[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_g) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">-1</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], f[son[x][i]]) ;</span><br><span class="line"><span class="comment">//debug(suf, 0, n) ;</span></span><br><span class="line"><span class="keyword">if</span> (G + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) g[x] = G ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, g[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(df + dg &lt;= ans) g[x] = <span class="built_in">std</span> :: min(g[x], dg) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; F &lt;&lt; " " &lt;&lt; G &lt;&lt; " " &lt;&lt; f[x] &lt;&lt; " " &lt;&lt; g[x] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">bool</span>)(f[x] &lt;= ans || g[x] &lt;= ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read_in())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa[i]) root = i ;</span><br><span class="line">dfs(i, <span class="number">0</span>, <span class="number">0</span>) ; son[i].clear() ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; to(i) &lt;&lt; " " &lt;&lt; val(i) &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res = do_dp(root, <span class="number">0</span>) ; <span class="comment">//return 0 ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//      for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">//if (f[i] + g[i] &gt; ans)&#123; res = 1 ; break ; &#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (res ? ans + <span class="number">1</span> : ans + <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA12170-Easy-Climb"><a href="#UVA12170-Easy-Climb" class="headerlink" title="UVA12170 Easy Climb"></a><a href="https://uva.onlinejudge.org/external/121/p12170.pdf" target="_blank" rel="noopener">UVA12170 Easy Climb</a></h1><blockquote><p>给出一堆山的高度 $h_i$ ，给定一个数 $d$ 。除了 $h_1,h_n$ 之外，可以任意修改山的高度，设改完之后山的高度是 $h’$，那么修改的代价是 $|h-h’|$ 。求使得任意两座相邻山峰的之间高度差得绝对值不超过 $d$ 的最小修改代价。</p><p>$1\leq n\leq 100,0\leq h_i\leq 10^9$ 。</p></blockquote><p><del>orz又是性质题，好烦啊怎么一直不会</del></p><p>考虑暴力怎么做。$f_{i,v}$ 表示把 $i$ 改成了 $v$ 后前 $i$ 座山彼此之间合法的最小代价和。你发现这个 $v$ 大概是没法直接转移的…</p><p>于是考虑一个深刻的性质。对于一个 $1&lt;i&lt;n$ ， $h_i$ 一定会被改成 $\max\{h_{i-1},h_{i+1}\}-d$ 或者 $\min\{h_{i-1},h_{i+1}\}+d$ 两者之一，如果一开始就满足性质就不用改，否则如果不满足就一定要去凑最近那个边界。类似的，考虑如果 $h_i ‘=h_{i+1}+d$ ，那么 $h_{i+1}’$ 就应该是关于 $h_{i}’$ 或者 $h_{i+2}$ 的一个带有常数个 $\mp d$ 的答案。那么这也就证明了，最终每座山都会变成某个 $h_p+q\cdot d$ 的形式，其中 $p\in [1,n]\cap\mathbb{Z_+}$，$q\in[-n,n]\cap\mathbb Z$ 。那么状态数就变成了 $O(n)\cdot O(n^2)=O(n^3)$ 个。考虑转移：</p><script type="math/tex; mode=display">f_{i,x}=|x-h_i|+\min\{f_{i-1,y}\} \quad (x-d\leq y\leq x+d)</script><p>发现可以对 $x$ 这一维用单调队列。于是复杂度 $O(n^3)$ 。如果实现不精细可能会多一个 $\log$ 。注意到可以一开始把所有可能的 $x$ 值排序后存起来，这样就可以避免 <code>map</code> 或者 <code>set</code> 的滥用。</p><h1 id="UVA1228-Integer-Transmisson"><a href="#UVA1228-Integer-Transmisson" class="headerlink" title="UVA1228 Integer Transmisson"></a><a href="https://uva.onlinejudge.org/external/12/p1228.pdf" target="_blank" rel="noopener">UVA1228 Integer Transmisson</a></h1><blockquote><p>在一个仿真网络中传输一个 $n$ 比特的非负整数 $k$。各比特从左到右传输，第 $i$ 个比特的发送时刻为 $i$ 。每个比特的网络延迟总是为 $0\sim d$ 之间的整数(因此从左到右第 $i$ 个比特的到达时刻为 $i\sim i+d$ 之间)。若同时有多个比特到达，实际收到的顺序任意。</p><p>求实际收到的整数有多少种 ，以及它们的最小值和最大值。</p><p>例如，$n=3$，$d=1$，$k=2$ (二进制为<code>010</code>)实际收到的整数的二进制可能是 <code>001</code>(1)，<code>010</code>(2) 和 <code>100</code>(4)。</p><p>$1\leq n\leq 64,0\leq d\leq n,0\leq k\leq 2^n $。</p></blockquote><p>最小值和最大值都显然可以贪心。考虑求方案数。比较直接的想法就是设 $f_{i,j}$ 表示考虑前 $i$ 个 $0$ 和前 $j$ 个 $1$ 后，组成整数的方案数。但是转移并不知道要怎么转移，因为可能上一个 $0/1$ 的出现时间不确定，导致无法判定当前在整个数最右边插入 $0/1$ 是否合法。</p><p>然后就需要洞见一个比较深刻的性质了。考虑如果希望凑出某个数 $w$ ，那么对于任意时刻，最右边那位(指被收到的最右边那一位)必然可以<strong>没有延迟</strong> 。因为即使延迟了，结果也不会更优（即也不会存在没延迟拼不出来，只有延迟才能拼出来的情况）。证明的话比较简单，因为「若同时有多个比特到达，实际收到的顺序任意」，所以如果某个比特延后至 $&gt;$ 最右边的数接收的时间，就可以调整成等于然后重排。</p><p>于是就可以知道，假设第 $i$ 位的发送时间是 $t_i$，那么考虑如何从 $f_{i,j}$ 转移到 $f_{i+1,j}$ 和 $f_{i,j+1}$ 。观察到本质上是要求插入一个新的 $1$ 或者新的 $0$ 。那么考虑假设第 $i+1$ 个 $0$ 的发送时间是 $t_0$ ，第 $j+1$ 个 $1$ 的发送时间是 $t_1$ ，那么如果为了让 $0$ 能够被尽早接收到，就需要满足 $t_0\leq t_1+d$ ，同理如果是想要 $1$ 能够尽量早到，就需要 $t_1\leq t_0+d$ 。于是转移时判断一下即可。复杂度 $O(n^2)$ 。</p><p><del>代码懒得写了</del></p><h1 id="UVA1628-Pizza-Delivery"><a href="#UVA1628-Pizza-Delivery" class="headerlink" title="UVA1628 Pizza Delivery"></a><a href="https://onlinejudge.org/external/16/p1628.pdf" target="_blank" rel="noopener">UVA1628 Pizza Delivery</a></h1><blockquote><p>你是一个披萨店的老板，有一天突然收到了 $n$ 个客户的订单。</p><p>你所在的小镇只有一条笔直的大街，其中位置 $0$ 是你的披萨店，第 $i$ 个客户所在的位置为 $p_i$，如果你选择给第 $i$ 个客户送餐，他将会支付你 $e_i-t_i$ 元。其中 $t_i$ 是你到达他家的时刻。</p><p>当然，如果你到的太晚，使得 $e_i-t_i&lt;0$ 。你可以路过他家但是不能进去给他送餐，免得他反过来找你要钱。</p><p>最大化收益。</p><p>$n \leq 100$ 。</p></blockquote><p>考虑对于这种每秒代价递增的问题，一般都是代价提前计算。但是这题也不是最朴素的这类问题，因为存在可以放弃某些位置的情况。</p><p>然后就是比(我)较(又)神(不)仙(会)的状态设计环节。首先是，根据题面可知不用全部送餐，所以要把「准备送餐给ta」的人数 $k$ 放到状态里面。同时如果定义「选了某个区间内的全部数」作为状态，显然是不合适的。于是设 $f_{i,j,k,0/1}$ 表示<strong>不考虑</strong>区间 $[i,j]\cap\mathbb {Z_+}$  内的元素，还要给 $k$ 个人送餐，当前位于 $i(0)$ 还是 $j(1)$  的最小代价。那么最后答案就是 </p><script type="math/tex; mode=display">\max_{k=0}^n\{\max_{i=1}^n\{f_{i,i,k-1,0/1}+(e_i-|p_i|)\times k\}\}</script><p>考虑转移。发现对于一个 $f_{i,j,k,0/1}$ 而言，必然是由一个包含 $[i,j]$ 的更大的区间 $[l,r]$ 通过切分得来的，同时为了每次只转移走一个子问题，需要 $r=j$ 或者 $l=i$ 的更大区间。于是考虑每次只转移一个点，故转移为：</p><script type="math/tex; mode=display">f_{i,j,k,0}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_i|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_i|)\}\\f_{i,j,k,1}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_j|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_j|)\}</script><p>然后就刷表就好了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = n - <span class="number">1</span> ; len ; -- len)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n - len ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i + len ; j &lt;= n ; ++ i, ++ j)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span> ; p &lt;= j ; ++ p)&#123;</span><br><span class="line">chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[p] - pos[i])) ;</span><br><span class="line">chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j - <span class="number">1</span> ; q &gt;= i ; -- q)&#123;</span><br><span class="line">chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[q])) ;</span><br><span class="line">chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这东西看似是 $n^4$ 的，实际上跑得很快（</p><h1 id="UVA12105-Bigger-is-Better"><a href="#UVA12105-Bigger-is-Better" class="headerlink" title="UVA12105 Bigger is Better"></a><a href="https://onlinejudge.org/external/121/p12105.pdf" target="_blank" rel="noopener">UVA12105 Bigger is Better</a></h1><blockquote><p>用不超过 $n$ 根火柴摆出一个尽量大的、能被 $m$ 整除的数。</p><p>$1\leq n\leq 100,1\leq m\leq 3000$ 。</p></blockquote><p>大概是个套路？遇到这种被 $m$ 整除余几的，大概需要在 $\bmod m$ 的余数之间来回转移。</p><p>然后可能是因为脑子抽了，一开始设计的状态是 $f_{i,j}$ 表示用了 $i$ 根火柴，模 $m$ 余 $j$ 时可以拼出来的最大的数，然后发现最多可以有 $50$ 位，但是 <code>__int128</code> 也只是大概 $36\cdot 10^{36}$ 多一点，不足以记下所有可行的的数字。</p><p>然后又尝试用 <code>string</code> ，写了一会儿才意识到 string 自定义的比较函数是按字典…<del>当然也可以写一个大整数类，似乎最多只会带一个 50 的常数</del>。</p><p>然后考虑这么设计不行，就只能去最小化贡献，然后手动构造了。考虑 $g_{i,j}$ 表示如果想要凑出从高到低的 $i$ 位，$\bmod m$ 余 $j$ 时最少需要用多少根火柴。转移和第一个转移…基本上差不多，刷就对了。然后考虑从第一位开始贪心地凑，注意判几次合法性就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, m ;</span></span><br><span class="line"><span class="comment">ll f[N][M], ans ;</span></span><br><span class="line"><span class="comment">int num[10] = &#123;6, 2, 5, 5, 5, 5, 6, 3, 7, 6&#125; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; n)&#123;</span></span><br><span class="line"><span class="comment">        if (!n) return 0 ; ans = -1 ;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; m ; memset(f, -1, sizeof(f)) ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt;= 9 ; ++ i) f[i % m][num[i]] = i ;</span></span><br><span class="line"><span class="comment">        for (int j = 2 ; j &lt;= n ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            for (int k = 0 ; k &lt;= 9 ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">                for (int i = 0 ; i &lt; m ; ++ i)</span></span><br><span class="line"><span class="comment">                    chkmax(f[((i * 10) + k) % m][j + num[k]], f[i][j] * 10 + k) ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 2 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">            chkmax(ans, f[0][i]) ; cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T ;</span><br><span class="line"><span class="keyword">int</span> pw[N], ans[N], f[N][M] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++ T), <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans)) ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">9</span> ; ++ k)</span><br><span class="line">                        chkmin(f[i + <span class="number">1</span>][(j * <span class="number">10</span> + k) % m], f[i][j] + num[k]) ;</span><br><span class="line"><span class="keyword">for</span> (res = n + <span class="number">1</span> ; f[res][<span class="number">0</span>] &gt; n ; -- res) ;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, cost = n ; pw[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= res ; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = j * pw[res - i + <span class="number">1</span>] % m ;</span><br><span class="line">                <span class="keyword">if</span> (num[j] + f[res - i][((m - p - t) % m + m) % m] &lt;= cost)&#123;</span><br><span class="line">                    cost -= num[j] ; (p += t) %= m ; ans[i] = j ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span> ; <span class="keyword">while</span> (!ans[q] &amp;&amp; q &lt; res) ++ q ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q ; i &lt;= res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意几个细节：</p><p>1、最后数字的位数不具有可二分性，所以还是枚举吧。</p><p>2、注意可能存在前导 $0$ ，需要删掉。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实学到了许多吧？自己基础一点也不好，所以其实是把别人很早之前付出的努力，再重新付出了一遍。很遗憾，这些题目里面还是有不少无不太会做的题目…</p><p>感谢兔队的教导可以让我安心学下去：藏巧于拙，寓快于慢。只要努力，就一定会比昨天的我更优秀吧？</p><p>不过，努力和选择同样重要。希望在接下来越来越紧张的时间里面，我可以想清楚自己到底要做些什么题、要学习一些什么知识吧。加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉自己真的是菜成一团…&lt;/p&gt;
&lt;p&gt;感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？&lt;/p&gt;
&lt;p&gt;可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？&lt;/p&gt;
&lt;p&gt;人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。&lt;/p&gt;
&lt;p&gt;Hide your skill from your clumsiness, make you fast in slowly.&lt;/p&gt;
&lt;p&gt;本文共计 15 道题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="动态规划/树形DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="数学/线性代数/矩阵" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/"/>
    
      <category term="图论/Dilworth定理" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-Dilworth%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【泛做】简单题选做</title>
    <link href="https://www.orchidany.cn/2020/04/19/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A/"/>
    <id>https://www.orchidany.cn/2020/04/19/简单题选做/</id>
    <published>2020-04-19T01:07:23.000Z</published>
    <updated>2020-04-27T06:37:35.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是由于基础太差了，然后打算去做点题补一下基础和脑子…</p><p>这个故事告诉我们，永远不要偷懒，有些力气，早晚是要出的。</p><p>如果来看我 blog 的你有什么好题推荐，欢迎评论，其他博客也是可以评论的（疯狂暗示</p><p>对了，像我这种明明要准备省选却在刷简单题补基础的人，是不是应该发一个「年度最佳人才」奖？</p><p>争取一句话题解…先整理十道题吧…因为奇奇怪怪的事情浪费了不少时间。</p><a id="more"></a><h1 id="UVA10891-Game-of-Sum"><a href="#UVA10891-Game-of-Sum" class="headerlink" title="UVA10891 Game of Sum"></a><a href="https://www.luogu.com.cn/problem/UVA10891" target="_blank" rel="noopener">UVA10891 Game of Sum</a></h1><blockquote><p>有一个长度为 $n$ 的整数序列，两个游戏者 $A$ 和 $B$ 轮流取数，$A$ 先取。每次玩家只能从左端或者右端取任意数量的数，但不能两边都取。所有数都被取走视为游戏结束，然后统计每个人取走的数之和，作为各自的得分。两个人采取的策略都是让自己得分尽可能高，并且两个人都很机智，求 $A$ 得分 - $B$ 得分后的结果。</p></blockquote><p>自己一开始想的 $dp$ 是要 $f_{i,j,0/1}$ ，并且转移有点复杂，结果发现根本不需要…考虑在博弈树上 dp，每个 $max$ 局面接下来一定是一个 $min$ 局面，所以有</p><script type="math/tex; mode=display">f_{i,j}=sum(i,j)-\min\{\min_{k\in[i+1,j]}\{f_{k,j}\},\min_{k\in[i,j-1]}\{f_{i,k}\}\}</script><p>也就是找到与一端边界相邻，且最小的那个对方的决策（$min$ 局面）。发现前后缀 $min/max$ 维护一下就可以 $O(n^2)$ 了。</p><h1 id="CF493D-Vasya-and-Chess"><a href="#CF493D-Vasya-and-Chess" class="headerlink" title="CF493D Vasya and Chess"></a><a href="https://www.luogu.com.cn/problem/CF493D" target="_blank" rel="noopener">CF493D Vasya and Chess</a></h1><blockquote><p>有一个  $n\times n$  的国际象棋棋盘。将白后放在  $(1,1)$ ，黑后放在  $(1,n)$  ，其余位置全都是中立的卒。<br>双方交替移动。白方先手。 每次移动，后（Queen）可以朝八个方向（上下左右对角线）之一移动任意格，直到碰到另外一个棋子，然后吃掉这个棋子。注意，在本题中，每次移动必须吃掉一个棋子。<br>当你的皇后被吃了或者你没有棋子可以吃了，就输了。 给出棋盘大小，请问哪方会赢。</p></blockquote><p><del>发现这种对称位置决策的…一般后手都比较神必，拖，就硬拖。</del></p><p>考虑后手模仿先手的动作，那么如果两者之前相隔为奇数，后手可以模仿先手，发现这么做一定可以吃掉先手。如果相隔为偶数，那先手就要学聪明，移动到 $(1,2)$ ，然后成为上一种情况的后手…</p><h1 id="UVA1099-Sharing-Chocolate"><a href="#UVA1099-Sharing-Chocolate" class="headerlink" title="UVA1099 Sharing Chocolate"></a><a href="https://www.luogu.com.cn/problem/UVA1099" target="_blank" rel="noopener">UVA1099 Sharing Chocolate</a></h1><blockquote><p>给出一块长为 $x$, 宽为 $y$ 的矩形巧克力，每次操作可以沿一条直线把一块巧克力切割成两块长宽均为整数的巧克力（一次不能同时切割多块巧克力）。 </p><p>问：是否可以经过若干次操作得到 $n$ 块面积分别为 $a_1, a_2, …, a_n$ 的巧克力。</p><p>$n\leq 15,1\leq x,y\leq 100$ 。</p></blockquote><p>大力状压，$f_{s,x,y}$ 表示 $s$ 这个集合内的巧克力是否可以被 $x,y$ 给切出来。考虑这样转移存在问题。因为必须要枚举子集来转移，所以最后时间复杂度 $O(3^nxy)$，空间复杂度 $O(2^nxy)$ 。有点爆炸。</p><p>考虑化简状态。发现固定了巧克力集合 $s$ ，那么对于一个固定的 $x$ ，$y$ 要么不存在要么同样被固定。所以状态就可以简化成 $f_{s,\min\{x,y\}}$ 。转移时依旧要判断两个状态是否都可行。注意转移来的状态 $f_{s’,x’}$ 也需要保证信息是落在较短边上的。复杂度 $O(x3^n)$。</p><p>神必 uva 卡我常数。不过也需要记得，对于这种信息 $01$ 且求并的转移，一旦某个状态确定为 $1$ 了就可以 <code>break</code>。这个技巧确实要记住。</p><h1 id="LA4725-Airport"><a href="#LA4725-Airport" class="headerlink" title="LA4725 Airport"></a><a href="https://www.luogu.com.cn/problem/UVA1450" target="_blank" rel="noopener">LA4725 Airport</a></h1><blockquote><p>机场上有两个跑道，分别为 W 和 E，每个时刻 $i$，W和E都分别有 $a_i,b_i$ 架飞机进入跑道。每个跑道的飞机都按顺序从 0 开始排序，每个时刻都允许一架飞机起飞，现要求你安排起飞的飞机，使得任意时刻的飞机的最大编号最小。</p><p>$1\leq n\leq 5000$ 。</p></blockquote><p>这题能比较自然地想到要二分。但是问题在于二分了之后并不知道要怎么去 check。这个地方有个很妙的 idea。就是如果之前有机会要飞，可以不飞，等到什么时候攒到了 $mid$ 号再飞。这样就不需要再考虑这东西的后效性了。但是有一点需要注意，就是攒着一起飞的话，在第 $i$ 个时刻只能选择飞之前的，因为这个决策本质上等价于在 $i-1$ 时刻飞。所以也要分别统计 $W$ 和 $E$ 的可飞量。</p><h1 id="LA4094-Wonder-Team"><a href="#LA4094-Wonder-Team" class="headerlink" title="LA4094 Wonder Team"></a><a href="https://vjudge.net/problem/UVALive-4094" target="_blank" rel="noopener">LA4094 Wonder Team</a></h1><blockquote><p>There are $n$ football teams participating in the competitions, each team plays twice (home and away) against each other team. Each team receives three points for a win and one point for a draw. No point is awarded for a loss. </p><p>When the games are finished, teams are ranked by numbers from $1$ to $n$ according to the total points. The rank of each team $t$ having $p$ points is one plus the number of teams having more than $p$ points. It is possible that more than one team have the same ranks. In addition to the Champion (the first ranked team or teams), the <strong>Wonder Team</strong> is also awarded, if there exists one. The team that has absolutely <strong>the highest number of wins</strong> (absolutely means no other teams has the same number of wins), absolutely <strong>the highest number of goals scored</strong>, and absolutely <strong>the lowest number of goals </strong>conceded, is called the WonderTeam. (WonderTeam should have all these properties.)</p><p>Your task is to find out the worst possible rank for the <strong>Wonder Team</strong>.</p><p>$1\leq n\leq 50$ 。</p></blockquote><p>English problem, English solution!</p><p>First of all, I’d like to claim that the 2nd Constraint and 3rd Constraint is no-use, becauce we always can let WT won another team with $10^9:1$. </p><p>Let’s assume $a_1,b_1$ means the WonderTeam’s wins and draws, $a_2,b_2$ means an arbitrary team’s wins and draws, whose rank is higher than WT. After a series of easy inference, if one team has higher rank than WT,   the equation below should be satisfied:</p><script type="math/tex; mode=display">b_2-b_1>3(a_1-a_2)\qquad (1)</script><p><del>Then my train of thought ended up with this:(</del></p><p>Thinking more carefully, if we want to maxmize WT’s rank, we have to get other teams’ score as high as we can. So we can use a greedy way to construct it : Just let WT’s wins actually one more than others. At the same time let WT lose its other games. Also we let other teams won WT one time, and draw with each other. </p><p>Then we can find that $\forall a_2$ ，there is $a_1-a_2=1$, which means $(1)$ turned to be:</p><script type="math/tex; mode=display">b_2-b_1>3</script><p>And about $b_2$ , there will exists two teams who losed in the game with WT , which means the-two  has exactly $1$ win and $2n-4$ draws, while the rest teams has exactly $1$ win and $2n-3$ draws. </p><p>So we can cliam that when $n&gt;4$ , WT’s lowest rank can be $n$ ; when $n=4$, it can be $2$ ; otherwise it can only be $1$ 。 </p><h1 id="CCO-2017-Rainfall-Capture"><a href="#CCO-2017-Rainfall-Capture" class="headerlink" title="CCO 2017 Rainfall Capture"></a>CCO 2017 Rainfall Capture</h1><blockquote><p>Lucy 有 $n$ 个高度为 $h_1,h_2,…,h_n$ 的柱子。她想知道，在所有可能的摆放方案中，所有可能的雨滴量（以 $r$ 为单位）是多少。</p><p>柱子只能竖着摆。接雨滴的定义：满则溢。</p></blockquote><p>比较神仙的 dp，对着代码啃了很久…</p><p>考虑直接求雨滴量并不好求，因为要去考虑左右两边的柱子高度。考虑对于一个排布 $4,2,5$ ，那么中间 $=2$ 或者 $=1$ 时要分开考虑；但是我们发现无论怎样，中间在接完雨滴之后高度都会变成 $4$ ，所以考虑求<strong>所有可能的雨滴+柱子</strong>的体积和。由于每个柱子都要摆，所以最后只需要去 check 那些 $\sum h_i\sim max$ 的答案。</p><p>考虑定义 $f_{i,v}$ 表示用了 $i$ 个柱子之后能否凑出体积 $v$ 来。考虑一个比较常用的 trick，将所有 $h_i$ 从小到大排序之后，按顺序转移。这样就能保证每次加进来的柱子都是当前最高的(无中生有了一个很有用的性质)。考虑一个状态 $f_{i,v}$ ，他的转移应该为：</p><script type="math/tex; mode=display">f_{i,v}=\bigcup_{p_j\leq v} f_{i-1,v-p_j}</script><p>其中 $p_j$ 是每个柱子的高度，需要从小到大转移，且转移时需要严格按照先枚举 $p_j$ 再枚举 $1\sim i$ 的顺序。</p><p>考虑这个式子的意义。对于任何一个大小为  $i\in[1,n-1]\cap\mathbb{Z_+} $ 的柱子集合 $o$，按秩转移时每次加入一个 $\geq \max_{t\in o}p_t$ 的新柱子 $p’$，放在最左边（或者最右边），同时再加入一个按高度从小到大排序后，恰好排名比 $p’$ 大 $1$ 的柱子 $p’’$  放在 $p’$ 的同侧（即，如果 $p’$ 放在了整个序列的左边，$p’’$ 应该被放在 $p’$ 的左边）。那么此时考虑，每当加进来一个元素 $p_0$，集合大小从 $i-1$ 变成 $i$ ，$p’$ 就向右交换一个，这样新加进来的这个柱子上方水位高度一定会是 $p’$ 的高度（因为最左边有 $p’’$）， 所以体积的变化量是 $\Delta v=(p’-p_0)+p_0$，前一半是水，后一半是新的柱子，所以可以从 $i-1,v-p’$ 转移过来。</p><p>需要注意的是，这样转移一定是不包含最高那个柱子的，因为当最高的柱子为 $p’$ 不存在一个更高的 $p’’$ 。</p><p>于是最后复杂度 $O(n^2\sum h)$ ，当然可以用 bitset 优化成 $O(\frac{n^2\sum h}{w})$ 。但其实在注意到本题只关注可达性判断之后，就可以发现等高的柱子不用重复转移，就可以优化成 $O((\sum h)\cdot n\cdot \max\{h\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="comment">//bool f[N][M] ; </span></span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; f[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">base[i] = qr(), m = max(m, base[i]) ;</span><br><span class="line">sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">s += base[i] ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">f[j] |= (f[j - <span class="number">1</span>] &lt;&lt; base[i]) ; </span><br><span class="line"><span class="comment">//for (int k = base[i] ; k &lt;= n * m ; ++ k)</span></span><br><span class="line"><span class="comment">//f[j][k] |= f[j - 1][k - base[i]] ; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s ; i &lt;= n * m ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[n - <span class="number">1</span>][i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - s) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA1073-Glenbow-Museum"><a href="#UVA1073-Glenbow-Museum" class="headerlink" title="UVA1073 Glenbow Museum"></a><a href="https://www.luogu.com.cn/problem/UVA1073" target="_blank" rel="noopener">UVA1073 Glenbow Museum</a></h1><blockquote><p>对于一个各边长度任意且都平行于坐标轴的多边形，我们可以用这样的方式描述它：考虑它的每一个内角，如果这个内角为 $90$ 度，那么用 $R$ 代表它；如果这个内角为 $270$ 度，那么用 $O$ 代表它。从某个点开始，按照逆时针的顺序读取 $R$ 和 $O$，最后得到一个由 $O,R$ 组成的字符串。</p><p>给定整数 $n$，问有多少个长度为 $n$ 的 $O,R$ 组成的字符串，使得有一个或以上与之对应的多边形，满足这个多边形内部有一点，可以看到这个多边形的所有内角（即，这个点与多边形所有内角顶点的连线都不与多边形的边相交）。</p></blockquote><p>显然最后一定是 $\frac{n}{2}-2$ 个 $O$ 和 $\frac{n}{2}+2$ 个 $R$。同时显然不会有相邻的 $O$，证明大概是需要拐回来之类的。那么问题就是给你固定数量的 R 和 O ，O 和 O 之间不相邻的方案数。</p><p>第一种 $dp$ 就是 $f_{k_1,k_2,l,r}$ 表示用了 $k_1$ 个 O 和 $k_2$ 个 R，最左端的字母是 $l$，最右端是 $r$ 的方案数。转移的时候考虑新加入一个 $R$ 还是 $O$ 即可。</p><p>第二种 $dp$ 则是一个改进，因为显然我们不关心 $O$ 的数量，因为最后是一定的；只关心如何排列。所以令 $f_{k_1,k_2,c}$ 表示有 $k_1$ 个 R ，$k_2$ 对相邻的 RR，第一个字母是 $c$ 的方案数。转移的时候考虑向后加一个 R​ 还是 OR 即可 。</p><p>然而显然这种 dp 是有组合意义的。所以我们分类讨论：</p><p>1、尾部不是 O 的方案数，显然就是前面 $\frac{n}{2}+2$ 个空填 $\frac{n}{2}-2$ 个O的方案数。</p><p>2、尾部是 O 的方案数，此时第一个位置不能放  O。类似的组合一下就完了。</p><p>于是就可以组合数做。处理的时候因为答案过大，所以可以考虑取对数<del>（学到许多）</del>。</p><h1 id="CF340E-Iahub-amp-Permutations"><a href="#CF340E-Iahub-amp-Permutations" class="headerlink" title="CF340E Iahub &amp; Permutations"></a><a href="https://www.luogu.com.cn/problem/CF340E" target="_blank" rel="noopener">CF340E Iahub &amp; Permutations</a></h1><blockquote><p>有一个长度为 $n$ 的排列 $a$，其中有一些位置被替换成了 <code>-1</code>。你需要尝试恢复这个排列，将 <code>-1</code> 替换回数字。<br>求多少种可行方案使得得到的是一个排列且不存在 $a_i=i$ 的位置。</p><p>$n\leq 5000$ 。</p></blockquote><p>orz 一个十分巧妙的转化，大概就是对于这种带有<strong>放置限制</strong>的排列问题，比如某个下标不能放置某个数，那么可以将这个排列对应到一个 $n$ 阶摆 $rook$ （即 $n\times n$ 的棋盘上放 $n$ 个互不攻击的车）问题上。这样一方面可以把「位置 x 不能放 y」约束展开，抽象成一个二维约束点 $(x,y)$ 上不能放车的约束；另一方面可以知道这个对应一定是完备的。</p><p>那么就转化成了，有些行和列已经放了车，整个棋盘对角线不能放车，有多少种本质不同的放车方案数。首先可以发现，如果某行某列有车，这一行一列就可以删掉；同时如果对于某个 $-1$ ，他所在的这个位置对应的行/列恰好被删了（同时存在位于下标 $k$ 的 $-1$ 和一个 $pos$ 使得 $a_{pos}=k$ ），那么对于这个 $-1$ 而言就没有限制了。</p><p>这样考虑 $dp$ 。$f_{i,j}$ 表示 $i\times i$ 的方格里考虑 $j$ 个限制的方案数。那么 $f_{i,0}=i!$。同时注意到 $f_{i,j-1}$ 到 $f_{i,j}$ 恰好多了一个限制，这个限制对应的应该是 $f_{i-1,j-1}$ 的方案数。所以有转移</p><script type="math/tex; mode=display">f_{i,j}=f_{i,j-1}-f_{i-1,j-1}</script><p>复杂度 $n^2$ 。</p><h1 id="CF212D-Cutting-Fence"><a href="#CF212D-Cutting-Fence" class="headerlink" title="CF212D Cutting Fence"></a>CF212D Cutting Fence</h1><blockquote><p>给出 $a[1…n]$ 。<br>定义 $f$ ：</p><script type="math/tex; mode=display">f(i,k)=\min_{i\leq j\leq i+k-1}\{a[j]\}</script><p>之后有 $m$ 个询问，每个询问给出一个数 $k$，问所有 $f(j,k) (1\leq j\leq n-k+1)$ 的平均值。<br>$1\leq n,m\leq 10^6$.</p></blockquote><p>首先不难知道要求出每个 $a_i$ 对包含其区间的贡献，然后对于长度为 $1\sim n$ 的区间分别计算其和，最终除以 $n-k+1$ 即为答案。</p><p>考虑两遍单调栈求出每个元素 $x$ 左/右边第一个比他小的元素下标 $l,r$，可知 $x$ 的贡献区间即为 $[l+1,r-1]$。枚举 $x$ ，那么区间 $l+1,r-1$ 的所有跨过 $x$ 的子区间都会存在贡献。此处假设 $x-l&lt;r-x$，考虑分类讨论子区间长度 $L$ ： </p><p>1、 $1\leq L\leq x-l$ ，这种区间每个元素都可以是 $x$ ，所以贡献为 $L\cdot a_x$ 。</p><p>2、$x-l+1\leq L\leq r-x$ ，这种区间最多只能取到 $x-l$ 次 $x$ ，所以贡献为 $(x-l)\cdot a_x$ 。</p><p>3、$r-x+1\leq L\leq r-l-1$ ，这种区间最多只能取到 $r-l-L$ 次，故贡献为 $(r-l-L)\cdot a_x$ 。</p><p>然后观察这些修改，发现 $L\cdot a_x$ 这东西，对于一个区间是在加一个等差数列的形式，$(x-l)\cdot a_x$ 和 $(r-l)\cdot a_x$ 都是区间加一个常数的形式。于是可以维护二阶差分。复杂度线性。</p><h1 id="USACO12-Bovine-Alliance-G"><a href="#USACO12-Bovine-Alliance-G" class="headerlink" title="USACO12 Bovine Alliance G"></a><a href="https://www.luogu.com.cn/problem/P3043" target="_blank" rel="noopener">USACO12 Bovine Alliance G</a></h1><blockquote><p><del>给出 $n$ 个点 $m$ 条边的图，现把点和边分组，每条边只能和相邻两点之一分在一组，点可以单独一组，问分组方案数</del>.</p><p>以上是错误的题意，以下是正确的题意：</p><blockquote><p>题意是给每条边找一个配对的点，要求边 $(u,v)$ 配对的点是 $u$ 或 $v$ ，且每个点最多只能被一条边配对，求不同方案数。</p></blockquote><p>$1\leq m\leq n\leq 10^5$ 。</p></blockquote><p>对着错误的题意思考了半天也不会…觉得首先对于点分组可以直接跑一个第二类斯特林数，但是这样边就没法分配了，因为可能存在边的两个端点在同一个点集内，所以可能需要套一个容斥什么的。推容斥系数可能会很高妙<del>反正我不会</del>。</p><p>然后正确的题面的话，考虑问题可以转化成给每条边定向，使得最后整张图每个点的度数都 $\leq 1$ 的方案数。然后…然后就是考察对于图论模型的洞见性有多强了：</p><p>1、不难发现一个简单环的定向方式总共是 $2$ 。</p><p>2、考虑去计算一棵树的定向方式。发现随便找一个根，显然哪个点当根对于整棵树的方案数没有影响。考虑如果将所有边都向儿子定向，那么这样一定合法，这是第一种方案。同时，单独把某一条边取反，假设这条边连接的儿子是 $x$ ，那么同时需要把 $x\to fa_x,fa_x\to fa_{fa_x}, fa_{fa_x}\to fa_{fa_{fa_x}}$ 全部取反，那么最终会取反到根，根的入度会变成 $1$ ，这也就说明不能有 $&gt;1$ 条边同时取反。所以可以知道一棵树的定向方式为 $1+(n-1)=n$ 。</p><p>发现对于无向图，本质上就是树插环的形态。所以拿一个带权并查集维护即可。有一个坑点，就是如果两个点不在同一个即集合里，边数也要++。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是由于基础太差了，然后打算去做点题补一下基础和脑子…&lt;/p&gt;
&lt;p&gt;这个故事告诉我们，永远不要偷懒，有些力气，早晚是要出的。&lt;/p&gt;
&lt;p&gt;如果来看我 blog 的你有什么好题推荐，欢迎评论，其他博客也是可以评论的（疯狂暗示&lt;/p&gt;
&lt;p&gt;对了，像我这种明明要准备省选却在刷简单题补基础的人，是不是应该发一个「年度最佳人才」奖？&lt;/p&gt;
&lt;p&gt;争取一句话题解…先整理十道题吧…因为奇奇怪怪的事情浪费了不少时间。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="泛做" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E6%B3%9B%E5%81%9A/"/>
    
    
      <category term="动态规划/状压DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/构造" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
      <category term="动态规划/普通DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="有趣的二分答案" scheme="https://www.orchidany.cn/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="图论/并查集" scheme="https://www.orchidany.cn/tags/%E5%9B%BE%E8%AE%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="思维题/对应与转化" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AF%B9%E5%BA%94%E4%B8%8E%E8%BD%AC%E5%8C%96/"/>
    
      <category term="动态规划/状态合并" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6/"/>
    
      <category term="博弈论/对称博弈" scheme="https://www.orchidany.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E5%AF%B9%E7%A7%B0%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF671E] Organizing a Race</title>
    <link href="https://www.orchidany.cn/2020/04/17/CF671E/"/>
    <id>https://www.orchidany.cn/2020/04/17/CF671E/</id>
    <published>2020-04-17T08:24:56.000Z</published>
    <updated>2020-04-21T03:35:05.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>这题十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。</p><p>做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…</p><p>接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… </p><a id="more"></a><p>XXXXXXXXXXXX 正文 XXXXXXXXXXXX</p><p>首先考虑，对于一段区间而言，需要多少操作多少次，才能保证正着走完并且反着走完。那么也就是需要算出正着走和反着走都需要额外的多少代价。</p><p>这个地方有个贪心。考虑定「向右走」为正方向。那么假设从 $i$ 开始走，如果遇到某个 $j&gt;i$ 发现走不得，那么应该在何处加油？因为还要考虑反着走回来，所以必然是加在最靠右的地方最优，所以就会选择的在 $j-1$ 处加油。记 $i$ 向右走遇到的第一个这样的 $j$ 为 $stop_i$  。</p><p>于是根据这个贪心就可以求出 $need(i,j)$ ，表示从 $i$ 走到 $j$ 需要多少代价。但这样也是只是保证了正着可以走。不妨令 $p_{i}$ 表示从 $1$ 走到 $i$ 花费的油量，$q_i$ 表示从 $i$ 走到 $1$ 花费的油量。 那么可知有递推：</p><script type="math/tex; mode=display">\begin{aligned}p_i&=p_{i-1}+g_{i-1}-w_{i-1}\\q_i&=q_{i-1}+g_{i-1}-w_i\end{aligned}</script><p>那么可以知道，在走 $i\to j$ 这条路线时，同时也在进行对 </p><script type="math/tex; mode=display">g_{stop_i},g_{stop_{stop_i}},g_{stop_{stop_{stop_i}}}\cdots</script><p>这些位置进行单点加，那么对 $q$ 的影响就是一个后缀加。记后缀加完之后的 $\{q_n\}$ 为 $\{\tau_n\}$ 。则如果不能从 $j$ 回到 $i$ ，就意味着着存在一个 $i\leq k&lt;j$ ，使得 $q_{k}-q_{j}&lt;0$ 。怎么量化这个东西呢？考虑还是贪心，如果从 $j$ 到 $i$ 走不了，那么一定会要把贡献累加到 $j$ 上，那需要累加的量就是 $q_{j}-\min_{k=i}^{j-1}\{q_{k}\}$ 。这也就是如果想要 $[i,j]$ 这个区间变得合法的最小贡献。</p><p>考虑如何计算这个东西。比较暴力的解法那必然是枚举一个左端点，然后向右走更新右端点。这样是 $n^2$ 的。发现如果想要优化，只能选择加速寻找右端点这个过程。但是有个问题在于，对于固定的 $i$ ，和想要二分出的 $j’$，要经过不同的 $stop$ 集合，同时有着不同的 $q_{j’}-\min_{k=i}^{j’-1}\{q_{k}\}$ ，求一次是 $O(n)$ 的，反而把复杂度搞成了 $n^2\log n$ 。</p><p>分开考虑这两点。对于经过不同 $stop$ 集合这个问题，可以继续深入挖掘性质。发现对于一个 $j$，可能存在一个连续段 $[k_1,k_2]$ 满足 $\forall z\in[k_1,k_2]\cap\mathbb{Z_+}$ ，$stop_z=j$ 。这种一对多的逻辑结构不难想到要用森林去表征。那么这个问题比较好解决了。建出一棵森林 $T$ ，连边 $i\leftrightarrow stop_i$ 。再建立一个虚根 $root$ ，与所有 $stop_i$ 未定义的结点相连。这样只要从 $root$ 开始 dfs，用退栈的方式辅助二分即可快速修改。</p><p>对于第二点，考虑对于一个固定的 $i$ ，本质上是在维护这么一个式子：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=i}^{j'}\{\tau_k \}</script><p>首先变一下形：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=1}^{j'}\{\tau_k \}</script><p>这样做的正确性在于，只要每次将 $&lt;i$ 的那些 $k$ 的 $\tau_k$ 都置为 $+\infty$ 就可以了。</p><p>考虑到底要怎么维护这个东西。发现在查询的过程中，需要单点修改 $g_i$ ，那么也就是区间修改 $q_j$ 和 $\tau_k$ ，那么也就是说要支持：1、维护前缀最小值 2、区间加/减 3、查询出某个最小值的位置。那自然就是线段树了。</p><p>考虑后一半的前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $\tau_k$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{\tau_k\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $q_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{k=1}^{j’}\{\tau_k\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $\tau_k$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr firsr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-7</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Fni = -(<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * f ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = y ; val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll sp[N] ;</span><br><span class="line">ll ss[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)</span><br><span class="line"><span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(sa[rt] = sb[rt] = ss[l]) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">stk[++ top] = x ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, - sp[fa[x]] + sp[x]) ;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n)&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span>, r = top - <span class="number">1</span>, ans = <span class="number">1</span>, mid ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sp[stk[mid]] - sp[x] &gt; m)</span><br><span class="line">ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll tmp = Inf ; ans = stk[ans] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Inf) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Fni) ;</span><br><span class="line">res = max(res, query(<span class="number">1</span>, <span class="number">1</span>, n, tmp) - x + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Fni) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Inf) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">stk[top --] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, sp[fa[x]] - sp[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; w[n] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) w[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) g[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">sp[i] = sp[i - <span class="number">1</span>] - g[i - <span class="number">1</span>] + w[i - <span class="number">1</span>] ;</span><br><span class="line">ss[i] = ss[i - <span class="number">1</span>] - g[i] + w[i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = n + <span class="number">1</span> ;</span><br><span class="line">    sp[n + <span class="number">1</span>] = Inf ; fa[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">while</span> (top &amp;&amp; sp[stk[top]] &lt;= sp[i]) -- top ;</span><br><span class="line">fa[i] = stk[top] ; stk[++ top] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) add_e(fa[i], i) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; top = <span class="number">0</span> ; dfs(n + <span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。&lt;/p&gt;
&lt;p&gt;你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。&lt;/p&gt;
&lt;p&gt;你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。&lt;/p&gt;
&lt;p&gt;你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。&lt;/p&gt;
&lt;p&gt;做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…&lt;/p&gt;
&lt;p&gt;接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树模型" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】兔队线段树</title>
    <link href="https://www.orchidany.cn/2020/04/16/%E5%85%94%E9%98%9F%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/04/16/兔队线段树/</id>
    <published>2020-04-16T12:38:44.000Z</published>
    <updated>2020-04-29T01:00:00.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：<a href="https://www.luogu.com.cn/problem/U96354" target="_blank" rel="noopener">Luogu U96354</a> 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233</p><p>然后今天又看到了兔的博文：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html" target="_blank" rel="noopener">从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法</a>。 感觉很神仙，然后就打算把这三道题都整理一下。</p><p><del>所以就是类似于复刻了一下兔秒掉or推荐的题</del>。</p><p>分别是三道题：<code>LGU96354 魔能阵列</code>，<code>BZOJ2957 楼房重建</code> 和 <code>CF671E Organizing a Race</code> .</p><a id="more"></a><h1 id="LGU96354-魔能阵列"><a href="#LGU96354-魔能阵列" class="headerlink" title="LGU96354 魔能阵列"></a>LGU96354 魔能阵列</h1><blockquote><p>给定两个序列 $\{a_n\},\{b_n\}$，定义一段区间 $[l,r]$ 的权值为</p><script type="math/tex; mode=display">\sum_{i=l}^r[b_i>0]a_i</script><p>现在给定两种操作，对 $\{b_n\}$ 区间加 $x$ (可正可负) 和询问某个区间的权值。保证任何时刻 $b_i\geq 0$ 。</p><p>$1 \leq n,m\leq 2 \times 10^5$   </p></blockquote><p>一个比较自然的想法，是分别维护区间 $b_i=0$ 的和 and 区间 $b_i\not = 0$ 的和。但是这个东西维护起来复杂度并不对。所以考虑换一下，由于保证任意时刻 $b_i\geq 0$ ，所以维护区间最小值， 区间 $b_i$ 的值 = 最小值的权值 and 区间 $b_i$ 的值 $\not =$ 最小值的权值和。那么转移就分类讨论一下即可。回答询问的时候只需要再建立一个虚点，对询问区间进行合并，最后只需要判断该区间最小值是否是 $0$ 即可。</p><p>大概首先维护区间最小值是个 trick ，建一个虚点对 $\log n$ 个区间进行合并也是一个 trick 。但是这俩似乎我都不是很熟，导致我当时不太会做.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> cnt, _tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>], v[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], mnx[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ;  c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[x] == mnx[y])</span><br><span class="line">        s[x] = s[x] + s[y], v[x] = v[x] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[x] &lt; mnx[y]) s[x] = s[x] + s[y] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[x] = mnx[y], s[x] = s[x] + s[y] + v[x], v[x] = v[y] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> rt, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[ls] == mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs], v[rt] = v[ls] + v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[ls] &gt; mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[rs], s[rt] = s[ls] + s[rs] + v[ls], v[rt] = v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs] + v[rs], v[rt] = v[ls] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">pdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_tag[rt])&#123;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    _tag[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    mnx[rt] = Inf, s[rt] = <span class="number">0</span>, v[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(mnx[rt] += x, _tag[rt] += x) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; pdown(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, x) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, x) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) </span><br><span class="line"><span class="keyword">return</span> _merge(ans, rt), <span class="keyword">void</span>() ;</span><br><span class="line">    pdown(rt) ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, ans) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, ans) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, N) ; (cnt *= <span class="number">2</span>) += <span class="number">1</span> ; <span class="keyword">int</span> l, r, x, opt ;</span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        opt = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            l = qr(), r = qr(), x = qr(), update(<span class="number">1</span>, <span class="number">1</span>, N, l, r, x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++ cnt, l = qr(), r = qr() ;</span><br><span class="line">            init(cnt), query(<span class="number">1</span>, <span class="number">1</span>, N, l, r, cnt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mnx[cnt] ? s[cnt] + v[cnt] : s[cnt]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bzoj2957-楼房重建"><a href="#bzoj2957-楼房重建" class="headerlink" title="bzoj2957 楼房重建"></a>bzoj2957 楼房重建</h1><blockquote><p>单点修改，查询整个序列有多个前缀最大值。</p><p>$1\leq n,m\leq 10^5$</p></blockquote><p>sto 兔。</p><p>首先考虑这东西暴力做的话，就是在模拟一个单调栈的过程。带修的话就要考虑套一个 ds。考虑 ds 的作用，本质上是要在每次修改完 $x$ 之后，将 $[1,x-1]$ 和 $[x+1,n]$ 这两个区间的单调栈和 $x$ 放在一起合并。于是不难想到要用线段树。</p><p>但…线段树似乎也没法快速合并。考虑每次 <code>push_up</code> 暴力把右区间合并到左区间里面，这样做显然是单次 $O(n)$ 的。考虑发掘更深一些，每次合并左右区间时，左区间是不受影响的，只需要统计左区间最大值对右区间答案的贡献。考虑每次合并，左区间最大值对右区间的影响一定是一个右区间的一个前缀。所以只需要每次合并时，线段树上二分出这个前缀的位置来即可。</p><p>然后实现的时候需要注意，二分完前缀之后，前缀的贡献是 $1$ ，剩下的后缀贡献不是 $cnt_{rc}$ 而是 $cnt_{root}-cnt_{lc}$ 。因为此时需要加上的是<strong>合并之后</strong>右区间对整体有多少贡献。</p><p>这样线段树二分 $1$ 个 $\log $ ，本身 <code>update</code> 又是 $1$ 个 $\log $ 。复杂度 $m\log ^2 n$ 。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line">db base[N] ;</span><br><span class="line">db s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> cnt[N * <span class="number">3</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">s[rt] = <span class="number">0</span> ; </span><br><span class="line">cnt[rt] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ; </span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, db v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> (s[rt] &gt; v) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (s[ls] &gt; v) </span><br><span class="line"><span class="keyword">return</span> query(ls, l, mid, v) + cnt[rt] - cnt[ls] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(s[rt] = base[l]) ; </span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= p) </span><br><span class="line">update(ls, l, mid, p) ; </span><br><span class="line"><span class="keyword">else</span> update(rs, mid + <span class="number">1</span>, r, p) ; </span><br><span class="line">s[rt] = max(s[ls], s[rs]) ; </span><br><span class="line">cnt[rt] = cnt[ls] + query(rs, mid + <span class="number">1</span>, r, s[ls]) ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; <span class="keyword">int</span> x ; db y ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">x = qr(), y = qr(), base[x] = (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * x) ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, x) ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CF671E-Organizing-a-Race"><a href="#CF671E-Organizing-a-Race" class="headerlink" title="CF671E Organizing a Race"></a>CF671E Organizing a Race</h1><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。</p><p>第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。</p><p>车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。</p><p>问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>这个地方的转化会单独开一篇新的 $blog$，因为比较毒瘤。大概最后就是转化成了令</p><script type="math/tex; mode=display">t_i=suf_i-\min_{j=1}^i\{suf'_j\}</script><p>求最大的 $i$ 满足 $t_i\leq k$ 。然后要支持 $suf’_i$ 的区间加/减以及多次询问。</p><p>考虑后一半就是前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $suf’$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{suf_j’\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $a_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{j=1}^i\{suf’_j\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $suf’$ 。</p><p>这里就先只给出线段树部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &gt;= v)</span><br><span class="line">    <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">sa[rt] = ss[l] ; </span><br><span class="line">    sb[rt] = ss[l]</span><br><span class="line">    <span class="keyword">return</span>  ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：&lt;a href=&quot;https://www.luogu.com.cn/problem/U96354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu U96354&lt;/a&gt; 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233&lt;/p&gt;
&lt;p&gt;然后今天又看到了兔的博文：&lt;a href=&quot;https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法&lt;/a&gt;。 感觉很神仙，然后就打算把这三道题都整理一下。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所以就是类似于复刻了一下兔秒掉or推荐的题&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;分别是三道题：&lt;code&gt;LGU96354 魔能阵列&lt;/code&gt;，&lt;code&gt;BZOJ2957 楼房重建&lt;/code&gt; 和 &lt;code&gt;CF671E Organizing a Race&lt;/code&gt; .&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj2391 Cirno的忧郁</title>
    <link href="https://www.orchidany.cn/2020/04/15/Cirno-%E7%9A%84%E5%BF%A7%E9%83%81/"/>
    <id>https://www.orchidany.cn/2020/04/15/Cirno-的忧郁/</id>
    <published>2020-04-15T13:19:00.000Z</published>
    <updated>2020-04-16T01:34:32.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Cirno 闲着无事的时候喜欢冰冻青蛙。</p><p>雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。</p><p>Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。</p><p>因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。</p><p>对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&lt;v\leq 10^4$ 。</p></blockquote><p>不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。</p><p>紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。</p><a id="more"></a><p>大概考虑三角剖分本来是用于求多边形面积，方法是选择一个原点，按照逆时针或者顺时针的方式，把多边形顶点向量叉一圈的结果。形式化地讲，给定一个多边形 $A_1A_2A_3\ldots A_n$ ，那么这个多边形的面积就是</p><script type="math/tex; mode=display">\frac{\overrightarrow{O A_{n}}\times \overrightarrow{OA_1}}{2}+\sum_{i=1}^{n-1} \frac{\overrightarrow{O A_{i}}\times \overrightarrow{OA_{i+1}}}{2}</script><p>证明的话可能容斥可证，但我不会…我只知道两个向量的叉积是以这两个向量为临边的平行四边形的面积。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140847.png" alt="wjyyy的图"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140906.png" alt="wjyyy的图"></p><p>然后这里放了神仙 <code>wjyyy</code> 的图，看上去比较直观。</p><p>然后考虑这题怎么做。发现 $n+m$ 不大，于是考虑求一个 $f_{i,j}$ 表示向量 $\bf V_i$ 与 $\bf V_{j}$ 之间，$\bf V_{i}\to \bf V_{j}$ 需要逆时针旋转时，$i,j$ 之间的价值和。那么对于每一个询问 $\{s_n\}$ ，答案就是 $\sum f_{s_i,s_{i+1}}$ 。 </p><p>考虑如何预处理这个东西。首先对所有向量按照极角逆时针排序(相等则模长大者位次靠后)，枚举 $i$ ，之后就需要喜闻乐见的平衡树了。大概是这样：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>其中红色向量是题目所给的向量，蓝色向量是辅助线。因为一开始就已经是逆时针排序，所以只需要判断每个向量的中点是否落在向量 $\bf i,j,t_2$ 构成的三角形即可。观察落在三角形内部的向量 $\bf k$ 和落在外部的向量 $\bf p$ ，会发现有 </p><script type="math/tex; mode=display">\bf {\text{<}i,t_1\text{>} \geq \text{<}i,t_2\text{>}\geq \text{<}i,t_3\text{>}}</script><p>考虑向量夹角最大为 $\pi$ ，$y=\cos x$ 在 $[0,\pi]$ 上单调递减，于是可以知道要拿 $\cos x$ 作为键值，该向量的 $val$ 作为点值插入平衡树。其中 $\cos x$ 拿向量内积求即可。 </p><p>最终复杂度 $O(n^2\log n+ms)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pts</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; <span class="keyword">int</span> val ; db x, y ;</span><br><span class="line"><span class="function">il db <span class="title">mo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y) ; &#125;</span><br><span class="line">il <span class="keyword">friend</span> pts <span class="keyword">operator</span> - (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> (pts)&#123;<span class="number">0</span>, <span class="number">0</span>, p.x - q.x, p.y - q.y&#125; ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> * (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.y - p.y * q.x ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> + (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.x + p.y * q.y ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;v[N], org, calc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">cosi</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / (a.mo() * b.mo()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line">db ang = (a - org) * (b - org) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ang &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">if</span> (ang != eps) <span class="keyword">return</span> ang &gt; eps ;</span><br><span class="line"><span class="keyword">return</span> (a - org).mo() &lt; (b - org).mo() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _splay&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> val ;</span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> fa ;</span><br><span class="line"><span class="keyword">int</span> sz ;</span><br><span class="line">db key ;</span><br><span class="line">&#125;s[N] ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) s[x].sz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(x) s[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key(x) s[x].key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot(x) s[x].tot</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) s[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size ;</span><br><span class="line"><span class="keyword">int</span> root ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x == rc(fa(x))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size ; ++ i)&#123;</span><br><span class="line">sz(i) = lc(i) = rc(i) = fa(i) = <span class="number">0</span> ;</span><br><span class="line">tot(i) = val(i) = key(i) = sum(i) = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span> ; root = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz(x) = tot(x) ;</span><br><span class="line">sum(x) = val(x) ;</span><br><span class="line"><span class="keyword">if</span> (lc(x))&#123;</span><br><span class="line">sz(x) += sz(lc(x)) ;</span><br><span class="line">sum(x) += sum(lc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rc(x))&#123;</span><br><span class="line">sz(x) += sz(rc(x)) ;</span><br><span class="line">sum(x) += sum(rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = w(x) ;</span><br><span class="line"><span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line"><span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line"><span class="keyword">if</span> (!f2) root = x ;</span><br><span class="line"><span class="keyword">else</span> s[f2].son[w(f1)] = x ;</span><br><span class="line">fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">fa(s[x].son[c ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">s[f1].son[c] = s[x].son[c ^ <span class="number">1</span>] ;</span><br><span class="line">s[x].son[c ^ <span class="number">1</span>] = f1 ; upd(f1), upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (fa(x) != aim)&#123;</span><br><span class="line"><span class="keyword">if</span> (fa(fa(x)) != aim)</span><br><span class="line">rotate(w(x) == w(fa(x)) ? fa(x) : x) ;</span><br><span class="line">rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;x, db ky, <span class="keyword">int</span> v, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line">x = ++ size ;</span><br><span class="line">fa(x) = dad ;</span><br><span class="line">key(x) = ky ;</span><br><span class="line">val(x) = sum(x) = v ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ky &lt; key(x))</span><br><span class="line">Ins(lc(x), ky, v, x) ;</span><br><span class="line"><span class="keyword">else</span> Ins(rc(x), ky, v, x) ; upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> _splay ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">org.x = <span class="number">-100000</span> ;</span><br><span class="line">org.y = <span class="number">-100000</span> ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">db x, y, w ; <span class="keyword">int</span> z, h, r ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, v[++ cnt] = (pts)&#123;i, <span class="number">0</span>, x, y&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w, v[++ cnt] = (pts)&#123;i, w, x, y&#125; ;</span><br><span class="line">sort(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, comp) ; m = n ; n = cnt ; <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (v[i].id &gt; m) <span class="keyword">continue</span> ;</span><br><span class="line">clear() ; pts o = v[i] - org ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">pts z = v[j] - v[i] ; db ky = cosi(o, z) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; '\n' ;</span></span><br><span class="line">Ins(root, ky, v[j].val, <span class="number">0</span>) ; splay(size, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(v[j].id &lt;= m)&#123;</span><br><span class="line">            f[v[i].id][v[j].id] = sum(lc(root)) ;</span><br><span class="line">            f[v[j].id][v[i].id] = - sum(lc(root)) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n] ; */</span></span><br><span class="line"><span class="keyword">while</span> (q --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; L ; <span class="built_in">cin</span> &gt;&gt; h ; r = h ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; z, ans += f[h][z], h = z ;</span><br><span class="line">ans += f[h][r] ; <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(ans)) ; ans = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写了一遍 splay，发现是真的慢+维护的信息真的多…</p><p>并且发现递归式的 splay 插入是真的好写。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Cirno 闲着无事的时候喜欢冰冻青蛙。&lt;/p&gt;
&lt;p&gt;雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。&lt;/p&gt;
&lt;p&gt;Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。&lt;/p&gt;
&lt;p&gt;因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&amp;lt;v\leq 10^4$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。&lt;/p&gt;
&lt;p&gt;紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="计算几何/三角剖分" scheme="https://www.orchidany.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
    
      <category term="数据结构/平衡树/splay" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E6%A0%91-splay/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj3881[COCI2015] Divljak</title>
    <link href="https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/"/>
    <id>https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/</id>
    <published>2020-04-15T13:17:33.000Z</published>
    <updated>2020-04-29T13:12:21.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。</p><p>接下来会发生 $q$ 个操作，操作有两种形式：</p><ol><li><code>1 P</code> Bob 往自己的集合里添加了一个字符串 $\rm P$。</li><li><code>2 x</code> Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。</li></ol><p>对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。</p></blockquote><p>今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。</p><p>啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq</p><a id="more"></a><p>大概是考虑，反正是匹配问题——那么是对着 $\rm T$ 建自动机呢，还是对 $\rm \{S_n\}$ 建。 考虑 AC 自动机更适合做这种匹配题，于是大概想到要拿 AC 自动机做；考虑如果对着 $\rm T$ 建自动机，树的形态会变，$\rm S$ 的信息需要动态维护，并不很好做，于是考虑对 $\rm S$ 建自动机 $\rm AC_s$。</p><p>考虑这样做，就需要在已经建好的自动机上，对于每个新加进来的 $P$ 计算贡献。那么会被 $P$ 包含的字符串，一定是 $P$ 在 $\rm AC_s$ 里匹配的 $endpos$ 到根的路径上每个点，到根的链上的点集并。暴力是 $n^2$ 的，考虑如何快速计算这个贡献，发现能做到最快的，也就是通过维护 dfs 序的方式求出点集并。对于每一个这样的链的并打一个标记。询问的时候只需要回答一下子树内有多少个点被打了不同的标记。</p><p>发现「维护树链标记」+「子树求和」，最快速的方法是维护差分。同时由于是动态的，可以想到用线段树或者 BIT 快速维护。</p><p>考虑修改如何进行。发现为了保证 $\land$ 形态的链只会被计数一次，需要在 $lca$ 处差分。此处需要注意的是，要对 $dfs$ 序排序之后，再逐个差分，方法是 $(i,+1),(i+1,+1),(lca_{i,i+1},-1)$ 。</p><p>想了半天才大约明白为什么要按 dfs 序排一遍序。大概是如果不按 dfs 序的顺序枚举，可能会出现某个子树未被成功打上标记的情况。</p><p>最终复杂度是 $O(\rm |S|\log |S|)$ 的，跑的不是很快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigma 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2001010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> T, M, N, L[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], base[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> _ed[MAXN], dfn[MAXN], rgl[MAXN], rgr[MAXN], tp ;</span><br><span class="line"><span class="keyword">int</span> sz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN], val[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp,</span><br><span class="line">    dfn[u] = rgl[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">    rgr[u] = tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    val[rt] = val[rt &lt;&lt; <span class="number">1</span>] + val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= p)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; pr &gt;= r) <span class="keyword">return</span> val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, pl, pr) ;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pl, pr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> _size, fail[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L[n] ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trie[rt][x])</span><br><span class="line">                trie[rt][x] = ++ _size ;</span><br><span class="line">            rt = trie[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[n] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.front() ; add(fail[n], n), q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trie[n][i]) trie[n][i] = trie[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trie[n][i]] = trie[fail[n]][i], q.push(trie[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, rt = <span class="number">0</span> ; tp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            x = S[i] - <span class="string">'a'</span>, rt = trie[rt][x], base[++ tp] = rt ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + tp + <span class="number">1</span>, comp),</span><br><span class="line">        tp = unique(base + <span class="number">1</span>, base + tp + <span class="number">1</span>) - base - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tp ; ++ i)&#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[base[i]], <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[lca(base[i], base[i - <span class="number">1</span>])], <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">// freopen("1.ans", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> m, q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= T ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), L[i] = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.insert(S, i) ;</span><br><span class="line">    AC.build() ; <span class="built_in">cin</span> &gt;&gt; M ; dfs(<span class="number">0</span>), dfs2(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= T ; ++ i) cout &lt;&lt; rgl[i] &lt;&lt; " " &lt;&lt; rgr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        m = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.solve(S) ;</span><br><span class="line">        <span class="keyword">else</span> q = qr(),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgr[_ed[q]]) - query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgl[_ed[q]] - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。&lt;/p&gt;
&lt;p&gt;接下来会发生 $q$ 个操作，操作有两种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 P&lt;/code&gt; Bob 往自己的集合里添加了一个字符串 $\rm P$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x&lt;/code&gt; Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。&lt;/p&gt;
&lt;p&gt;啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="树上技巧/dfs序+树状数组" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串/AC自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="数据结构/树状数组" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF626F]Group Projects</title>
    <link href="https://www.orchidany.cn/2020/04/15/CF626F/"/>
    <id>https://www.orchidany.cn/2020/04/15/CF626F/</id>
    <published>2020-04-15T01:20:49.000Z</published>
    <updated>2020-04-15T02:33:02.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个学生，每个学生有一个能力值 $a_i$。现在要把这些学生分成一些(任意数量的)组，每一组的“不和谐度”是该组能力值最大的学生与能力值最小的学生的能力值的差。求所有不和谐度之和不超过 $k$ 的分组方案总数对 $10^9+7$ 取模。</p><p>$n\leq 200,k\leq 1000,0\leq a_i\leq 500$</p></blockquote><p>从头开始的计数生活.png</p><a id="more"></a><p>考虑暴力计数，大概就是 $f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了 $j$ 组，当前不和谐度总和为 $k$ 的方案数。发现这样没法转移，因为并不知道该怎么考虑插入一个元素时的贡献。考虑对于一种状态，如果钦定了其中某些集合的最大值或者最小值已经固定，如果当前元素超过了这个 bond，就不能再用当前元素更新。于是考虑另一种状态，$f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了不知道组，但是有 $j$ 组的最大值还没确定，当前不和谐度总和为 $k$ 的方案数 。这样显然是需要将所有权值排序之后再 $dp$ 的。</p><p>考虑转移。每次遇到一个新的元素，可以将其和之前的某一组合并，或者单独新开一组。记没确定最大值的集合为「未闭合集合」，那么就有四种情况：</p><p>1、合并，但是那个集合仍未闭合。</p><p>2、合并，那个集合闭合了。</p><p>3、不合并，新开的集合未闭合。</p><p>4、不合并，新开的集合闭合了。</p><p>于是转移就是</p><script type="math/tex; mode=display">f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k}\\ (j+1)\times f_{i-1,j+1,k+a_i}\\ f_{i-1,j-1,k-a_i}\\f_{i-1,j,k}\end{cases}</script><p>分别对应四种情况。</p><p>考虑这么做的复杂度，似乎是 $O(n^2k)$ ，但是由于中间转移过程的第三维可能会到 $\pm 10^4$ ，大小无法准确预估，所以时空复杂度都是 $O(n^2\sum a_i)$ 的。于是就 gg 。</p><p>考虑稍微抽象一下，每个集合的 $min/max$ 可以看做在一条值域轴上线段的左、右端点，对于每个时刻 $i$ ，未闭合的集合就是某些会被 $i$ 横切掉的线段。那么对于某条直线 $(l,r)$ ，满足 $l&lt;i&lt;r$ ，在第 $i$ 个时刻，记录的是代价是 $-a_l$，但这种方法并不聪明，因为只有当取到 $r$ 时，$-a_l$ 才会被用上，所以对于任意一个 $i,l&lt;i&lt;r$ 而言，$-a_l$ 都是没必要承载的空间。于是考虑怎么将一条线段的贡献平摊到每个点上，这样每一维转移就不再是 $O(\max\{\sum a_i,k\})$ 而是 $O(\max\{a_i,k\})$ 。</p><p>考虑平摊的话，即如何将 $a_r-a_l$ 展开成每一项都 $&lt;\max\{a_i,k\}$ 的这么一个数列。一个比较简单的方法就是：</p><script type="math/tex; mode=display">a_r-a_l=\sum_{i=l+1}^r(a_i-a_{i-1})</script><p><del>一看就是老分式裂项了</del></p><p>于是本质上只是优化了转移。令 $d=a_i-a_{i-1}$ 可以得到：</p><script type="math/tex; mode=display">f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k-j\times d}\\ (j+1)\times f_{i-1,j+1,k-(j+1)\times d}\\ f_{i-1,j-1,k-(j-1)\times d}\\f_{i-1,j,k-j \times d}\end{cases}</script><p>然后就没有然后了，复杂度 $O(n^2\max\{k,\max\{a_i\}\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line">LL dp[<span class="number">2</span>][MAXN][MAXK], ans ;</span><br><span class="line"><span class="keyword">int</span> N, K, M, base[MAXN], dif[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123; x -= y ; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += Mod ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL &amp;x, <span class="keyword">const</span> LL &amp;y)</span></span>&#123; x += y ; <span class="keyword">if</span> (x &gt; Mod) x %= Mod ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, k, d ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"> sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>), dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) dif[i] = base[i + <span class="number">1</span>] - base[i] ;</span><br><span class="line"><span class="keyword">for</span> (d = i = <span class="number">1</span> ; i &lt; N ; ++ i, d ^= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> o = d ^ <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line"><span class="keyword">int</span> op = dif[i] * j ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= K ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> val = k + op ;</span><br><span class="line">LL res = dp[o][j][k], v = res * j % Mod ;</span><br><span class="line">dp[o][j][k] = <span class="number">0</span> ; <span class="keyword">if</span> (val &gt; K) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (j) add(dp[d][j - <span class="number">1</span>][val], v) ; </span><br><span class="line">add(dp[d][j][val], v + res), add(dp[d][j + <span class="number">1</span>][val], res) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) </span><br><span class="line">add(ans, dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>][i]) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个学生，每个学生有一个能力值 $a_i$。现在要把这些学生分成一些(任意数量的)组，每一组的“不和谐度”是该组能力值最大的学生与能力值最小的学生的能力值的差。求所有不和谐度之和不超过 $k$ 的分组方案总数对 $10^9+7$ 取模。&lt;/p&gt;
&lt;p&gt;$n\leq 200,k\leq 1000,0\leq a_i\leq 500$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从头开始的计数生活.png&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[Ynoi2019]Yuno loves sqrt technology II</title>
    <link href="https://www.orchidany.cn/2020/04/12/Ynoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-II/"/>
    <id>https://www.orchidany.cn/2020/04/12/Ynoi2019模拟赛-Yuno-loves-sqrt-technology-II/</id>
    <published>2020-04-12T13:46:29.000Z</published>
    <updated>2020-04-14T00:18:16.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。</p><p>$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ 。</p></blockquote><p>这还是我第一次认真做了 lxl 的由乃 OI 题目，233.</p><a id="more"></a><p>还是考虑二次离线，那么需要预处理</p><script type="math/tex; mode=display">\sum_{i=1}^k (i,i)(1,i-1)\quad | \quad \sum_{i=1}^k (i,i)(1,i)</script><p>和</p><script type="math/tex; mode=display">\sum_{i=k+1}^n (i,i)(i+1,n)\quad | \quad \sum_{i=k+1}^n (i,i)(i,n)</script><p>这 $4$ 个信息，因为在计算逆序对的时候是有方向性的，$l$ 向左扩展/向右收缩对应的是 $(l+1,n)$ 之间的信息，$r$ 向右扩展/左收缩对应的是 $(1,r-1)$ 之间的信息。同时注意到由于 $(i,i)(1,i)=(i,i)(1,i-1)$ ，所以本质上是两个信息。这个可以 $O(n\log n)$ 预处理。</p><p>同理，对于不能预处理的区间，也是要分左边的贡献和右边的贡献来做。根据方向，可以方便地判断每种情况贡献应该怎么加，拿两种值域分块，分别维护前缀和&amp;后缀和就好了。</p><p>实现细节方面需要注意：</p><p>1、本题数据中存在 $a_i$ 相同的情况，这个地方会卡求逆序对时的边界，注意判一下即可。</p><p>2、值域分块需要注意，只需要修改整块的 <code>sum</code>，零散的点单独算贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ;</span><br><span class="line"><span class="keyword">int</span> V ;</span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll s1[N] ;</span><br><span class="line">ll s2[N] ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> sumb[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qrd</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qrd(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qrd;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ql[N], qr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= p &amp; -p) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= V ; p += p &amp; -p) _bit[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inssuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = blv[x] + <span class="number">1</span> ; i &lt;= blv[V] ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &lt;= V ; ++ i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Asksuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inspre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blv[x] - <span class="number">1</span> ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &gt;= <span class="number">1</span> ; -- i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Askpre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">qrd(n), qrd(m), B = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qrd(base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    L = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i] = lwb(tmp + <span class="number">1</span>, tmp + L + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">        V = max(base[i], V) ; bl[i] = i / B ;</span><br><span class="line">    &#125;</span><br><span class="line">    B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] + ask(base[i] - <span class="number">1</span>), add(base[i]) ;</span><br><span class="line">    fill(_bit, _bit + V + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + i - <span class="number">1</span> - ask(base[i]), add(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">qrd(q[i].l), qrd(q[i].r), q[i].id = i ;</span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l] + s1[r] ;<span class="comment">//l 的贡献变成了一个后缀，原来是 l'-(l-1),现在变成了 l-l'</span></span><br><span class="line">ans[i] += s2[newl] + s1[newr] ;<span class="comment">//l 和 r 要分开计算贡献</span></span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(newl, l - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(l, newl - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Inspre(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : ql[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Askpre(base[o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">memset</span>(sumb, <span class="number">0</span>, <span class="keyword">sizeof</span>(sumb)) ;</span><br><span class="line">    <span class="built_in">memset</span>(sump, <span class="number">0</span>, <span class="keyword">sizeof</span>(sump)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        Inssuf(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qr[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Asksuf(base[o] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line">qwa(res, n, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。&lt;/p&gt;
&lt;p&gt;$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这还是我第一次认真做了 lxl 的由乃 OI 题目，233.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】莫队二次离线</title>
    <link href="https://www.orchidany.cn/2020/04/11/%E8%8E%AB%E9%9A%8A%E4%BA%8C%E6%AC%A1%E9%9B%A2%E7%B7%9A/"/>
    <id>https://www.orchidany.cn/2020/04/11/莫隊二次離線/</id>
    <published>2020-04-11T03:47:01.000Z</published>
    <updated>2020-04-12T14:40:33.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。</p><p>另附 pks 词典：</p><blockquote><p>『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。</p><p>『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。</p><p>『 』(无评价) ：学会了。</p></blockquote><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。然后由于信息具有可减性(比如常见的「点对数」)，那么可以：</p><p>记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。 </p><p>1、如果 $[l,r]\to [l+t,r]$ ，那么可知 </p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l}^{l+t-1} (i,i)(i+1,r)=\sum_{i=l}^{l+t-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l,l+t-1)(1,r)-\sum_{i=l}^{l+t-1}(i,i)(1,i)</script><p>2、如果 $[l,r]\to [l-t,r]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l-t}^{l-1} (i,i)(i+1,r)=\sum_{i=l-t}^{l-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l-t,l-1)(1,r)-\sum_{i=l-t}^{l-1}(i,i)(1,i)</script><p>3、如果 $[l,r]\to [l,r+t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r+1}^{r+t}(i,i)(l,i-1)=\sum_{i=r+1}^{r+t}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r+1,r+t)+\sum_{i=r+1}^{r+t}(i,i)(1,i-1)</script><p>4、如果 $[l,r]\to [l,r-t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r-t+1}^{r}(i,i)(l,i-1)=\sum_{i=r-t+1}^{r}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r-t+1,r)+\sum_{i=r-t+1}^{r}(i,i)(1,i-1)</script><p>其中 $\sum$ 并不是真正的 $\sum$ ，不同情况下需要按顺序(即不再有交换律)，比如 $[l,r]\to [l,r-t]$ 时就需要从 $r-1$ 算到 $r-t$ 。</p><p>然后这样容斥之后，后面的 $\sum$ 就可以预处理了，前面的 $()()$ ，由于莫队的复杂度，可以知道至多有 $n\sqrt m$ 个不同的询问，这样就可以把每一组询问打标记，打到左端点是 $1$ 的那个询问上 (比如 $[l,r]\to [l,r-t]$ 就打到 $l-1$ 上)。最后扫一遍全部的 $i\in[1,n]\cap\mathbb{Z_+}$，这样最终复杂度 $O(n\sqrt m)$ 。可以看出比起普通的莫队，二次离线还有一个好处，就是只有 $O(n)$ 次插入，于是对于某些题就可以用值域分块的技巧做到 $O(n\sqrt m+n\sqrt n)$ 。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>LG 4887 第十四分块(前体)</p><p>珂朵莉给了你一个序列 $a$，每次查询给一个区间 $[l,r]$ </p><p>查询 $l \leq i&lt; j \leq r$ ,且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。</p></blockquote><p>似乎就是板子题，然后对于 $(i,i)(1,i-1)$ 和 $(i,i)(1,i)$ 这个东西的预处理可以拿一个桶来维护，$buc_x$ 表示有多少个数 $\oplus x$ 之后二进制位有 $k$ 个 $1$ ，剩下的就是比较典型的莫队二次离线了。</p><p>值得一提的是…$\binom{14}{7}=3432$ ，再乘上一个 $10^5$ ，时间根本承受不了…所以这就很神必…打算写完之后出个数据卡一卡，不知道能不能成功。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16385</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> cnt ;  </span><br><span class="line">ll s1[N] ; </span><br><span class="line">ll s2[N] ; </span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ; </span><br><span class="line"><span class="keyword">int</span> bu[N] ;</span><br><span class="line"><span class="keyword">int</span> len[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ; </span><br><span class="line"><span class="keyword">if</span> (!k) bu[++ cnt] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">len[i] = len[i - (i &amp; -i)] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (len[i] == k) bu[++ cnt] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bl[i] = i / B ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">s1[i] = s1[i - <span class="number">1</span>] + (ll)buc[base[i]] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">buc[base[i]  ^  bu[j]] += <span class="number">1</span> ; </span><br><span class="line">s2[i] = s2[i - <span class="number">1</span>] + (ll)buc[base[i]] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; s1[i] &lt;&lt; " " &lt;&lt; s2[i] &lt;&lt; '\n' ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="comment">//emplace_back </span></span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l - <span class="number">1</span>] + s1[r] ; </span><br><span class="line">ans[i] += s2[newl - <span class="number">1</span>] + s1[newr] ;</span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qs[newr].emplace_back(newl, l - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qs[newr].emplace_back(l, newl - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line">debug(ans, <span class="number">1</span>, m, <span class="string">'\n'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++ i) buc[i] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) </span><br><span class="line">buc[base[i] ^ bu[j]] += <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qs[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o) tmp += buc[base[o]] ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) ans[id * (<span class="number">-1</span>)] -= tmp ; <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便结束之后卡了一下，写了个觉得肯定可以卡的 gen：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16383</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">7</span> ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line"><span class="keyword">int</span> i = j ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = j ; (i - j) &lt; M &amp;&amp; p &lt;= n ; i ++, p += <span class="number">2</span>)</span><br><span class="line">base[p] = M - (i - j), base[p + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">j = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">srand(time(<span class="number">0</span>)) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="string">" "</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">gene_Array() ; <span class="keyword">int</span> B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, base[i], <span class="string">" \n"</span>[i == n]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; p) p += B ;</span><br><span class="line"><span class="keyword">int</span> l = p, r = n - p / <span class="number">2</span> ;</span><br><span class="line">        l %= n, r %= n ; <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += n ;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) swap(l, r) ;</span><br><span class="line">l += rand() % (r-l+<span class="number">1</span>) ;</span><br><span class="line">r += rand() % (n-r+<span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="233.jpeg" alt=""></p><p>其中第二行是我拿一个计数器，记了一下运算量。$7e8$ 能稳过 $1s$，这就很睿智，我果然跟时代脱节了。</p><h1 id="例题-amp-总结"><a href="#例题-amp-总结" class="headerlink" title="例题&amp;总结"></a>例题&amp;总结</h1><blockquote><p>由于个人感觉很有整理价值，于是决定新开一篇整理（</p></blockquote><p>之前一直觉得二次离线会很难，学了学觉得其实还可以。并且没准二次离线这个技巧可以利用到其它地方？或许吧。</p><p>莫队系列似乎是都学完了，爷的青春结束啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。&lt;/p&gt;
&lt;p&gt;另附 pks 词典：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。&lt;/p&gt;
&lt;p&gt;『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。&lt;/p&gt;
&lt;p&gt;『 』(无评价) ：学会了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj3730]震波</title>
    <link href="https://www.orchidany.cn/2020/04/09/%E9%9C%87%E6%B3%A2/"/>
    <id>https://www.orchidany.cn/2020/04/09/震波/</id>
    <published>2020-04-09T01:12:59.000Z</published>
    <updated>2020-04-09T15:46:31.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。</p><p>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。</p><p>接下来你需要在线处理 $m$ 次操作：</p><p><code>0 x k</code> 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</p><p><code>1 x y</code> 表示第 $x$ 个城市的价值变成了 $y$ 。</p><p>为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。</p></blockquote><p>這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…</p><p>不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。</p><p>upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。</p><a id="more"></a><p>大概就是如果沒有修改操作的話，就是比較裸的點分樹。於是先考慮沒有修改操作的情況。</p><p>考慮怎麼維護這個東西，自然是希望對每個點都記錄一個桶，但這樣顯然由於每個點的深度不可控，最終需要的空間代價是 $O(n^2)$ 的。於是考慮怎麼調整樹的高度使得最終總的空間複雜度可以接受，那自然就會想到點分治。注意到點分治時，每個點在分治過程中，『邏輯樹高』都只有 $\log n$ 。這大概就是為什麼用點分樹的原因。</p><p>所以就是建出點分樹來，每個點維護一個 <code>vector</code> 作為桶，維護點分樹上子樹內到當前點距離為 $k$ 的點權和。這樣對於詢問，每次只需要跳點分樹，然後對於每個 $fa$ 統計 $k-dis(fa,x)$ 的點對的數量就好了。但是還有一個問題，就是對於以當前 $fa$ 為根的那些子樹，在算下一個 $fa$ 的時候會被算重。於是就要再維護一個桶，表示 $x$ 子樹內的點，到點分樹上 $x$ 的父親的距離為 $k$ 的點權和。由於邊權都為 $1$ ，這個操作就會很方便。</p><p>考慮如果帶修改，那無非就是把桶換成樹狀數組即可。這樣複雜度就會是 $O(m\log ^2 n)$ 的了。可能我寫的比較醜？預處理是常數不小的 $O(n\log ^2 n)$ ，似乎比其他人都慢誒…</p><p>然後是 bug 集錦：</p><p>1、最開始的時候維護的是 <strong>點分樹</strong> 上距離為 $k$ 的點的點權和。</p><p>2、然後改了改，但是查詢的時候沒有維護兩個 BIT，只維護了一個，然後減去的是查詢 $x$ 的點分樹子樹內到 $x$ 距離 $\leq k-2\times dis(fa_x,x)$ 的點權和。看上去有點東西，但問題在於到 $x$ 距離和到 $fa_x$ 距離沒有本質上的關係…比如可以在樹的對側。</p><p>3、最後還是寫了兩個 BIT，但是調了很久，原因是向上跳遇到 $dis(fa_x,x)&gt;k$ 應該 <code>continue</code> 而不是 <code>break</code> ，因為這距離並是實際距離，在點分樹上沒有單調性。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> d[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> mx_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sub[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; buc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> findCG ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">buc[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = buc[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) buc[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= buc[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)buc[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">sub[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = sub[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) sub[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= sub[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)sub[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += sub[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">Id[root][x] = dep[x] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa)</span><br><span class="line">calc(to(i), x, root), size[x] += size[to(i)] ;</span><br><span class="line">mx_dep = max(dep[x], mx_dep) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root, <span class="keyword">int</span> frt)</span></span>&#123;</span><br><span class="line">add(root, dep[x], base[x]) ;</span><br><span class="line"><span class="keyword">if</span> (frt) add2(root, Id[frt][x], base[x]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa) calc2(to(i), x, root, frt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx ; vis[x] = <span class="number">1</span> ; mx_dep = <span class="number">0</span> ; </span><br><span class="line">calc(x, <span class="number">0</span>, x), init(x, mx_dep) ; </span><br><span class="line">init2(x, h) ; mx = mx_dep ; </span><br><span class="line">calc2(x, <span class="number">0</span>, x, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">num = size[to(k)] ; reset() ;</span><br><span class="line">dfs(to(k), x) ; f[grt] = x ;</span><br><span class="line">find_tree(grt, x, mx) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">char</span> c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> r ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">a = qr(), b = qr(), add(a, b), add(b, a) ;</span><br><span class="line">reset() ; num = n ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; find_tree(grt, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">a = qr() ; </span><br><span class="line">b = qr() ^ lans ; </span><br><span class="line">c = qr() ^ lans ;</span><br><span class="line"><span class="keyword">if</span> (!a)&#123;</span><br><span class="line"><span class="keyword">int</span> fb = f[b] ;</span><br><span class="line"><span class="keyword">int</span> ob, lb = b, df ;</span><br><span class="line">ans += ask(lb, c + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (fb)&#123;</span><br><span class="line">df = Id[fb][b] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (c - df &lt; <span class="number">0</span>)&#123;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ans += ask(fb, c - df + <span class="number">1</span>) ;</span><br><span class="line">ans -= ask2(lb, c - df + <span class="number">1</span>) ;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (lans = ans)) ; </span><br><span class="line">ans = <span class="number">0</span> ; <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ob = b ;</span><br><span class="line">add(b, <span class="number">1</span>, -base[b] + c) ;</span><br><span class="line"><span class="keyword">while</span> (f[b])&#123;</span><br><span class="line"><span class="keyword">int</span> df = Id[f[b]][ob] ;</span><br><span class="line">add(f[b], df, -base[ob] + c) ;</span><br><span class="line">add2(b, df, -base[ob] + c) ; b = f[b] ;</span><br><span class="line">&#125;</span><br><span class="line">base[ob] = c ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。&lt;/p&gt;
&lt;p&gt;不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。&lt;/p&gt;
&lt;p&gt;接下来你需要在线处理 $m$ 次操作：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0 x k&lt;/code&gt; 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 x y&lt;/code&gt; 表示第 $x$ 个城市的价值变成了 $y$ 。&lt;/p&gt;
&lt;p&gt;为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…&lt;/p&gt;
&lt;p&gt;不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。&lt;/p&gt;
&lt;p&gt;upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。&lt;/p&gt;
    
    </summary>
    
      <category term="題解" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/"/>
    
      <category term="BOZJ" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/BOZJ/"/>
    
    
      <category term="数据结构/点分树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj4182] Shopping</title>
    <link href="https://www.orchidany.cn/2020/04/09/shopping/"/>
    <id>https://www.orchidany.cn/2020/04/09/shopping/</id>
    <published>2020-04-09T01:01:10.000Z</published>
    <updated>2020-04-09T13:04:42.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。</p><p>第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。</p><p>这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？</p><p>对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。</p></blockquote><a id="more"></a><p>然後大概是整理過的題目，但個人感覺還是有必要再整理一遍的。</p><p>題意大概是說，在樹上做背包，但是不允許選不連通的點。据说是经典套路题，但我不是很会…</p><p>先考慮比較簡單的 $01$ 背包。考慮一般這種情況需要記錄一下每個點用沒用，所以比較直接的想法是枚舉每個點當根，然後求一個以該點為根時的連通塊出來。但問題就在於合併子樹的複雜度是 $O(V^2)$ （個人覺得存在某種方式的 $V\log V$ 合併，畢竟形式上十分的NTT）。但這樣就是 $n^2V^2$ 的了，所以考慮一個比較經典的優化，在 $dfs$ 序上做，記錄一下每個點子樹內 $dfs$ 序的最大值 $r_i$ 。定義 $f_{i,v}$ 表示 $i\sim n$ 都被考慮完了，代價為 $v$ 時的結果。轉移的話，如果選 $i$ 就從 $i+1$ 來轉移，不選 $i$ 那麼整棵子樹都不能選，從 $r_i+1$ 轉移。 </p><p>然後如果是多重背包的話，套一個單調隊列就可以做到 $n^2V$ 了，但是實際上這題很水，直接 $O(nV\max\{c_i\})$ 的多重背包也沒有問題。然後就是在寫多重背包的時候，發現了很弱智的一點，就是『物品個數』和『體積』哪一個先枚舉的問題…</p><p>顯然的是應該先枚舉體積，否則同一層的狀態會互相嵌套。所以應該這麼寫：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p><p>但是還有另一種寫法，用到了『狀態堆疊』這個 trick，雖然複雜度不變但是看起來更帥一點</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.jpg" alt=""></p><p>然後考慮如何消掉一個 $n$ ，發現這個 $dp$ 很符合點分治的特點，每次將分治中心作為根，那麼選了根就是經過分治中心，不經過跟就是沒經過分治中心。於是最後的複雜度是 $nV\max\{c_i\}\log n $ 。</p><p>然後就是單調隊列優化多重背包，感覺這個東西很玄妙，十分深刻<del>（被 uoj 群友提醒之後發現似乎不是很深刻，只是自己做題少）</del>：</p><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知對於一個相同的 $i$，不同的 $j$ ，轉移區間的左端點是不降的，于是就对每个 $d$ 用单调队列即可。</p><p>仔細想了想，大概是這麼一個思考過程：觀察上面那個式子可以知道，每次枚舉的會是一些 $w_i$ 的倍數，那麼對於任意一個 $j$ ，轉移路徑裡最初的轉移點就一定在 $0\sim w_i-1$ 中進行，注意到這一點之後自然考慮對於每一個 $d$ 分別做。那麼可以發現，對於每個 $d$ 而言，$d+k<em>w$ 的轉移點都是固定的，比如 $d+7</em>w$ 就只能從 $d+w,d+2\cdot w,\cdots ,d+6*w$ 來轉移，同時由於數量 $c_i$ 的限制，可以知道對於每個 $j$ 只能從 $\geq \lfloor\frac{j}{w_i}\rfloor-c_i$ 的其它 $j$ 來轉移，就變成了一個區間彼此不包含的轉移問題，顯然可以用單調隊列來優化。</p><p>然後最後複雜度就變成了 $O(nV\log n )$ 。</p><p>感覺這個單調隊列的實現有億點細節，可能需要再琢磨一下。</p><hr><p>思考了一下，順便去問了 zay，發現這個轉移有點東西：</p><p>1、由於轉移時是要從 $i-1$ 的狀態轉移，一開始初始賦值完畢之後 $i$ 就是 $i-1$ 的狀態了。那麼每次入隊的時候要保證把 $i-1,j$ 入隊而不是 $i,j$ 。所以入隊的時候要是轉移前的結果。</p><p>2、注意到單調隊列有個問題，就是兩個端點『左閉右閉』和『左閉右開』。左閉右閉的時候需要注意判斷 <code>while (h &lt;= t)</code>，因為當 $h=t$ 的時候還會有元素在隊伍當中。</p><p>3、很 sb 的一點，就是手寫隊列，如果不能保證每次 $dp$ 前隊列都是空的，那麼轉移的時候就需要判斷是否為空，不然會從不合法的狀態點轉移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[t] &lt;= o) q[t --] = <span class="number">0</span> ; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">if</span> (h &lt;= t) dp[j * w[x] + d] = q[h] + v[x] * j ;<span class="comment">//3 </span></span><br><span class="line">q[++ t] = o ; q2[t] = j ; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感覺自己真的沒怎麼寫過單調隊列，同時也對單調隊列理解的不是很好的樣子。</p><p>總代碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> u[N] ;</span><br><span class="line"><span class="keyword">int</span> v[N] ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> q[V] ;</span><br><span class="line"><span class="keyword">int</span> q2[V] ;</span><br><span class="line"><span class="keyword">int</span> rg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][V] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">findCG :: size[x] = <span class="number">1</span> ;</span><br><span class="line">dfn[x] = ++ id ; rev[id] = x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">dfs(to(k), x), findCG :: size[x] += findCG :: size[to(k)] ;</span><br><span class="line">rg[x] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; q[t - <span class="number">1</span>] &lt;= o) q[t --] = <span class="number">0</span> ;</span><br><span class="line">q[t] = o ; q2[t ++] = j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;</span><br><span class="line">dp[j * w[x] + d] = max(dp[j * w[x] + d], q[h] + v[x] * j) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span> ;</span><br><span class="line">id = <span class="number">0</span> ; dfs(x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= id + <span class="number">1</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j) f[i][j] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = id ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">int</span> ii = rev[i] ;</span><br><span class="line"><span class="comment">//if(x == 2) cout &lt;&lt; w[ii] &lt;&lt; " " &lt;&lt; v[ii] &lt;&lt; " " &lt;&lt; ii &lt;&lt; " " &lt;&lt; rg[ii] + 1 &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= w[ii] ; -- j) f[i][j] = f[i + <span class="number">1</span>][j - w[ii]] + v[ii] ;</span><br><span class="line">calc(f[i], ii) ; <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j) f[i][j] = max(f[i][j], f[rg[ii] + <span class="number">1</span>][j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; f[1][m] &lt;&lt; endl ;</span></span><br><span class="line">ans = max(f[<span class="number">1</span>][m], ans) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">findCG :: reset() ;</span><br><span class="line">findCG :: num = findCG :: size[to(k)] ;</span><br><span class="line">findCG :: dfs(to(k), <span class="number">0</span>) ; solve(findCG :: grt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> a, b ; findCG :: num = n ;</span><br><span class="line">fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">fill(head, head + n + <span class="number">1</span>, ans = cnt = <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; w[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; u[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b, add(a, b), add(b, a) ;</span><br><span class="line">findCG :: reset() ; findCG :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">solve(findCG :: grt) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最終被 zay 的二進制分組吊著錘，感覺很不爽 QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。&lt;/p&gt;
&lt;p&gt;第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。&lt;/p&gt;
&lt;p&gt;这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？&lt;/p&gt;
&lt;p&gt;对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/数据结构方法/点分治" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】分块&amp;莫队&amp;根号分治</title>
    <link href="https://www.orchidany.cn/2020/04/08/%E5%88%86%E5%9D%97%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/04/08/分块听课笔记/</id>
    <published>2020-04-08T03:49:07.000Z</published>
    <updated>2020-04-14T04:39:05.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…</p><p>话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…</p><p>日常不想写数据结构(1/1) 。</p><p>然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭</p><a id="more"></a><p>不做說明的話，全部數據的 $n,m$ 都是 $10^5$ 的。块大小记作 $B$ .</p><h1 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>维护一个序列，支持</p><p>1.区间加。</p><p>2.查询区间小于 $x$ 的数个数。</p></blockquote><p>对于询问操作而言，可以发现区间加不影响块内部的顺序，所以考虑对于每个块维护块内元素排完序之后的结果，存在一个容器里，记为 $ov_x$ 。</p><p>对于修改操作，整块就直接打一个 $tag_x$ ，零散块由于至多有两块受影响，于是考虑暴力重构。暴力重构的方法大概是按顺序将 $ov_x$ 里那些要被加的元素取出，可以知道这样 $ov_x$ 和被取出的那些元素就都是有序的了，可以归并排序做到线性。所以修改复杂度是 $O(B)+O(\frac{n}{B})$ 的。</p><p>查询操作，零散块当然是暴力 for​ ，整块的话可以二分，查询复杂度 $O(B)+O(\frac{n}{B}\log B)$ 。发现如果令 $B = \sqrt{n\log B}$ ，那么总复杂度会变成 $O(m\sqrt{n\log B})$ ，可能会更优。</p><p>同时也可以把询问对于每一块都离线下来，对于每个块，在每次重构之前可以回答上一次重构之后的问题，用基数排序把这些询问排序之后，和块内元素一起归并可以做到线性。于是就可以离线 $O(m\sqrt n)$ 了。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>维护一个序列，支持查询</p><p>1.区间加</p><p>2.查询区间k小</p></blockquote><p>考虑和上一道题一样的做法，每次外层套一个二分，那么就是查询每个块内 $&lt;x$ 的数的个数，这样还需要再二分，询问复杂度变成了 $O(\frac{n}{B}\log B\log V)$ ，平衡之后就是 $O(\sqrt{n\log B}\log V)$。</p><p>……然而 lxl 出的 YNOI 把这个 Sol 给卡了。</p><p>考虑一个 $trick$ ，就是调整块的大小。令 $B=\sqrt n \log n$ ，那么每次修改显然还是 $O(B)&gt;O(\frac{n}{B})$ 的，查询还是用二分，但是由于整块的数量下降到了 $O(\frac{n}{\sqrt n \log n})=O(\frac{\sqrt n}{\log n})$ ，那么这部分复杂度就变成了 $O(\sqrt n\log n)$ 。看上去很不错？但是零散块查询的时候，由于有 $O(\sqrt  n\log n)$ 的零散点，所以如果暴力二分就又变成俩 $\log $ 了。不过显然这些零散点是可以归并的，于是这部分的复杂度就变成了 $O(\sqrt n\log n+\log n)$ 。</p><p>最终总复杂度 $O(m\sqrt n\log n)$ 。</p><h1 id="根号平衡"><a href="#根号平衡" class="headerlink" title="根号平衡"></a>根号平衡</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><blockquote><p>维护序列，要求 $O(1)$ 修改， $O(\sqrt n)$ 求区间和。</p></blockquote><p>似乎就是最水的分块题。考虑分块维护块内和，修改的时候 $O(1)$ 修改点值和块值，询问就是朴素询问即可。</p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><blockquote><p> 维护序列，要求 $O(\sqrt n)$  修改， $O(1)$ 求区间和。</p></blockquote><p>这个比较有意思。发现要求 $O(1)$ 求区间和，那自然就是要维护前缀和。于是就分别维护块的前缀和 and 块内部的前缀和，每次修改就是要修改之后的块的前缀和 and 散点所在块内部的前缀和，查询作差即可。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>维护序列，要求 $O(\sqrt n)$ 区间加，$O(1)$ 询问单点。</p></blockquote><p>改成维护差分就变成 B 的内容了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>维护序列，要求 $O(1)$ 区间加，$O(\sqrt n)$ 询问单点。</p></blockquote><p>维护差分，就变成 A 了…这一波，这一波整理顺序没有决策单调性（雾）。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>维护一个集合，支持 $O(1)$ 插入一个数，$O(\sqrt n)$ 查询 $k$ 小。</p></blockquote><p>大概就是考虑值域分块。考虑把所有数字离散化之后是 $1\sim m$ ，然后按照值域分块，对于每个块记录一下这段值域出现了多少个数，每个位置出现了多少个数。插入就是在对应位置 $+1$，这个块 $+1$，询问就是 forforfor。</p><p>似乎有个小问题，就是如果值域 $1e9$ 可能要多一个二分的 log。如果不强制在线可以把询问一起离散化，但是如果强制在线可能就必须要二分了。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>维护一个集合，支持 $O(\sqrt n)$ 插入一个数，$O(1)$ 查询 $k$ 小。</p></blockquote><p>还是按值域分块。同时维护每个块的 $ov$。</p><p>那么如果要插入一个数，那么那个块本身需要重构，然后对于这之后的所有数都需要后移一位，相当于每次每个块头部删一个元素，尾部加入一个元素。查询的时候直接定位到那个块即可。</p><p>实现方面，每个块的 $ov$ 拿一个支持双端删插的容器即可。这题的关键点就在于要保证前 $k$ 个块的大小可以快速查询，那么令每个块的大小相同就是不错的选择。</p><h2 id="CodeChef-Chef-and-Churu"><a href="#CodeChef-Chef-and-Churu" class="headerlink" title="[CodeChef] Chef and Churu"></a>[CodeChef] Chef and Churu</h2><blockquote><p>给 $n$ 个数，给定 $m$ 个函数，每个函数为序列中第 $l_i$ 到第 $r_i$ 个数的和。有 $q$ 个询问，两种类型的操作：</p><p><code>1 x y</code> 把序列中的第 $x$ 个数改为 $y$ 。</p><p><code>2 x y</code> 求第 $x$ 个函数到第 $y$ 个函数的和。</p></blockquote><p>一眼感觉是什么 CDQ 🐂🍺题.jpg</p><p>草，知道正解的我眼淚掉下來，感覺好神仙啊。大概就是考虑这些函数都是静态的，所以可以对函数分块，然后维护前 $i$ 个函数里面，序列上每个元素要被算多少次，并且维护前缀函数的答案和。那么每次修改只需要 $\frac{n}{B}$ 地修改每个前缀和即可。询问的时候，整块就是直接拿前缀和作差，对于散点而言，考虑至多是 $O(B)$ 次查询，每次查询本质上是对序列上一个区间的查询。所以用那个 $O(\sqrt n)$ 单点修改 $O(1)$ 查询区间和的方式，即 B 中的技巧就好了。</p><p>最终复杂度 $O(m\sqrt n)$ 。 </p><h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h2 id="AHOI2013-作业"><a href="#AHOI2013-作业" class="headerlink" title="[AHOI2013]作业"></a>[AHOI2013]作业</h2><blockquote><p>查询区间 $[l,r]$ 中值在 $[a,b]$ 内的不同数个数</p><p>$n \leq 10^5 , m \leq 10^5$</p></blockquote><p>考虑直接莫队的话，需要支持查询某个值域中的数，需要上树状数组，但这样带 $\log$ 。</p><p>于是考虑一下莫队的本质，即莫队的复杂度分析，本质上分析的是 $l,r$ 移动的复杂度，也就是修改的复杂度。所以莫队可以本质上看成一个 $O(n\sqrt m)$ 修改，$O(m)$ 询问的数据结构，也就是可以用一个可以快速修改，低速查询的 ds 来维护值域，那这自然就是值域分块，最终复杂度 $O(n\sqrt m+m\sqrt n)$ 。</p><p>然后本题需要分别维护出现次数和是否出现，分别维护即可。</p><p>不过话说回来，这东西本质上等价于查询 $pre_x&lt;l,pos_x\in[l,r],x\in[a,b]$ 的这样的 $x$ 的个数。那么这就是一个三维数点，CDQ 套树状数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> sumr[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; </span><br><span class="line"><span class="keyword">int</span> l, r ; </span><br><span class="line"><span class="keyword">int</span> a, b ; </span><br><span class="line">&#125;q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] -- ; </span><br><span class="line">sumr[blv[base[p]]] -- ;</span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">0</span>) -- sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] ++ ; </span><br><span class="line">sumr[blv[base[p]]] ++ ; </span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">1</span>) ++ sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += (<span class="keyword">bool</span>)sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sum[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_res</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sumr[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), V = max(V, base[i]), bl[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].a, &amp;q[i].b), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> a = q[i].a, b = q[i].b ; </span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">res[q[i].id] = get_res(a, b) ;</span><br><span class="line">ans[q[i].id] = get_ans(a, b) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h2><blockquote><p>給定序列，定义 $v_x$ 为 $x$ 在区间 $[l,r]$ 中的出现次数，查询一个区间中最大的 $x\times v_x$ 。</p></blockquote><p>發現就是莫隊，然後要求查詢某個數的出現次數，跟上面『作業』那個題一樣，直接對值域分塊就好了。</p><p>預處理起來似乎也不是很難的樣子，對每個 $k\times x~(k=1,2,3,\cdots,cnt_x)$ 放到一起離散化就好了。 于是最后复杂度是 $O(n\sqrt m+m\sqrt n)$ 。因为滥用 <code>vector</code> 以及 cache 十分不友好导致慢的一匹，用了 zay 的快读也毛用没有/dk。</p><p>实现细节：</p><p>1、按照平常莫队的写法，如果先 <code>del</code> 再 <code>add</code> 会出现某些数出现了负数次，解决方法比较简单，判一下就好了。</p><p>2、十分神必的一点，一开始我把对每个点标号放到了对询问排序的后面，所以 T 了半天，并且自己以为是缓冲区溢出的锅…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector <span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mint map <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minttoll map <span class="meta-string">&lt;int, ll&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qr(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qr;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> L ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line">ll res ;</span><br><span class="line">ll t[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line"><span class="keyword">int</span> vl[N] ; </span><br><span class="line"><span class="keyword">int</span> vr[N] ; </span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ; </span><br><span class="line"><span class="keyword">int</span> blv[N] ; </span><br><span class="line"><span class="keyword">int</span> sumb[N] ; </span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line">minttoll su ;</span><br><span class="line">mint bu, vu ;</span><br><span class="line">vint base[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; </span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;  </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[tmp[p]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">++ buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line"><span class="keyword">int</span> val = base[tmp[p]][++ buc[tmp[p]]] ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; val &lt;&lt; " " &lt;&lt; lval &lt;&lt; endl ; </span></span><br><span class="line">sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[tmp[p]] &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">-- buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (buc[tmp[p]] + 1 &gt;= base[tmp[p]].size()) cout &lt;&lt; base &lt;&lt;buc[tmp[p]] &lt;&lt; " " &lt;&lt; p &lt;&lt; ' ' &lt;&lt; tmp[p] &lt;&lt;'\n', exit(0) ; </span></span><br><span class="line"><span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line"><span class="keyword">int</span> val = base[tmp[p]][-- buc[tmp[p]]] ; </span><br><span class="line">sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ob = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = blv[V] ; b &gt;= <span class="number">0</span> ; -- b)</span><br><span class="line"><span class="keyword">if</span> (sumb[b] &gt; <span class="number">0</span>) &#123; ob = b ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span> (!ob) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = vr[ob] ; p &gt;= vl[ob] ; -- p) <span class="keyword">if</span> (sump[p]) <span class="keyword">return</span> p ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ; qr(m) ; B = n / <span class="built_in">sqrt</span>(m) ;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) qr(g[i]) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">bu[g[i]] ++, t[++ cnt] = <span class="number">1l</span>l * g[i] * bu[g[i]] ;</span><br><span class="line"><span class="comment">//debug(t, 1, cnt, ' ', '\n') ;</span></span><br><span class="line">sort(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>) ; bu.clear() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">bl[i] = i / B ; bu[g[i]] ++ ; <span class="keyword">int</span> w ; </span><br><span class="line">w = upb(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>, <span class="number">1l</span>l * g[i] * bu[g[i]]) - t - <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; w &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">if</span> (bu[g[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">base[w].push_back(<span class="number">0</span>) ; </span><br><span class="line">base[w].push_back(w) ; vu[g[i]] = w ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> base[vu[g[i]]].push_back(w) ; V = max(V, w) ;  </span><br><span class="line">su[w] = <span class="number">1l</span>l * g[i] * bu[g[i]] ; t[w] ++ ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(q[i].l), qr(q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) tmp[i] = vu[g[i]] ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) if(buc[tmp[i]]) return 0 ; else buc[tmp[i]] ++ ; </span></span><br><span class="line"><span class="comment">/*for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; tmp[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">debug(base[tmp[i]], 0, base[tmp[i]].size() - 1, ' ', '\n') ;</span></span><br><span class="line"><span class="comment">&#125;return 0 ; */</span></span><br><span class="line"><span class="comment">//debug(tmp, 1, n, ' ', '\n') ;</span></span><br><span class="line">B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= V ; ++ i)&#123;</span><br><span class="line">blv[i] = i / B + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (blv[i] != blv[i - <span class="number">1</span>])</span><br><span class="line">vr[blv[i - <span class="number">1</span>]] = i - <span class="number">1</span>, vl[blv[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; vr[blv[V]] = V ;</span><br><span class="line"><span class="comment">//debug(blv, 1, V, ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//debug(vl, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//debug(vr, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//while (l &lt;= n) add(l ++) ;// cout &lt;&lt; l &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">ans[q[i].id] = su[ ask() ] ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qw(ans[i], <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SNOI2017-一个简单的询问"><a href="#SNOI2017-一个简单的询问" class="headerlink" title="[SNOI2017] 一个简单的询问"></a>[SNOI2017] 一个简单的询问</h2><blockquote><p>给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出</p><script type="math/tex; mode=display">\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)</script><p>$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。</p></blockquote><p>首先可以發現這東西就是在求 $\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]$ 。由於是 $\sum $ 的形式，那麼自然可以拆成四個詢問，即詢問</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]\\=&\sum_{i=1}^{r_1}\sum_{j=1}^{r_2}[a_i=a_j]-\sum_{i=1}^{r_1}\sum_{j=1}^{l_2-1}[a_i=a_j]-\sum_{i=1}^{l_1-1}\sum_{j=1}^{r_2}[a_i=a_j]+\sum_{i=1}^{l_1-1}\sum_{j=1}^{l_2-1}[a_i=a_j]\end{aligned}</script><p>那麼就變成了四個雙端點詢問的問題了。注意到每多一個元素 $x$，就會多 $buc_x$ 個 <code>pair</code>，莫隊即可。</p><h2 id="Ynoi2016-这是我自己的发明"><a href="#Ynoi2016-这是我自己的发明" class="headerlink" title="[Ynoi2016]这是我自己的发明"></a>[Ynoi2016]这是我自己的发明</h2><blockquote><p>给一个树，$n$ 个点，有点权，初始根是 $1$ 。$m$ 个操作，每次操作：</p><ol><li>将树根换为 $x$ 。</li><li>给出两个点 $x$，$y$，从 $x$ 的子树中选一个点，$y$ 的子树中选一个点，如果两个点点权相等，<code>ans++</code>，求 ans。</li></ol><p>$n\leq 10^5,m\leq 5\times 10^5$。</p></blockquote><p>發現…似乎本質上就是上面那個題。因為換根這個地方，對於某個點至多有兩種可能，就是子樹內的點為根、子樹外的點為根和自己為根。然後就可以一開始先按照操作，把所有詢問轉化成以 $1$ 為根，$dfs$ 序上的操作。然後大概就和上一道題一樣了。</p><p>需要注意的是，如果是遇到子樹內的點作為根，那麼本身就要兩個詢問，一個詢問全局的，一個減去這個子樹的，注意到詢問全局的並不需要拆，所以一個詢問最多會被拆分成 $(2+1)\times (2+1)=9$ 個詢問，最後 $m$ 可以到 $5\times 10^6$ 左右。雖然莫隊的複雜度可以接受 $m$ 比較大，但是一開始排序的 $m\log m$ 就會很慢。所以可以用基數排序來實現這個過程。</p><h2 id="BZOJ3920-Yunna-的禮物"><a href="#BZOJ3920-Yunna-的禮物" class="headerlink" title="[BZOJ3920] Yunna 的禮物"></a>[BZOJ3920] Yunna 的禮物</h2><blockquote><p>給定序列，每次查询区间中出现次数 $k_1$ 小的数里面的 $k_2$ 小的数。</p></blockquote><p>靠，一開始沒看見『區間』這個限制，還很好奇為什麼要上莫隊…老了老了。</p><p>看了半天題解才大概看明白，似乎是個什麼分塊套分塊的操作。大概就是對於『出現次數』的出現次數開一個桶，然後拿值域分塊來維護這個東西，但是對於每個『次數』還是需要查詢第 $k_2$ 小的數，於是就對於這個塊內的每個『次數』，外面再套一層值域分塊來維護一個固定次數處的數的排序。</p><p>這樣插入就是 $O(1)+O(1)$ ，查詢就是 $O(\sqrt n) +O(\sqrt n)$ 。看上去很棒，但是空間上會被卡…</p><p>這個地方我就很不理解…不知道為啥會被卡…不過那個什麼『分段離散化』的 trick 大概是预处理出对于某一种出现次数，所有可能的数，再将其离散化，对于离散化后的数再來值域分塊维护。這樣複雜度就是線性了。大概是什麼 vector 保存某個數出現 $k$ 次之後的新權值？大概過程就和其他博客講的，如果某個數的總出現次數 $cnt_x&gt;i$ ，那麼就要用 $x$ 預處理 $i$ ，這是顯然的。</p><p>似乎空間被卡的原因是值域分塊的 size 要預先確定，所以不二次離散化，複雜度就會是 $n^2$ 的了。</p><h1 id="根号分治"><a href="#根号分治" class="headerlink" title="根号分治"></a>根号分治</h1><h2 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h2><blockquote><p>给个图</p><ol><li>把 $x$ 点权加 $y$ 。</li></ol><p>2.查询 $x$ 相邻的点权和。</p></blockquote><p>经 典 套 路 . 总结一下的话，大概就是「小的直接做，大的打标记」这么一个套路。</p><p>具体一点，每个点维护一下询问的 $ans$，对每个点展开关于度数的根号分治，$&lt;\sqrt m$ 的点直接加，$&gt;\sqrt m$ 的点打标记。每次询问到一个点 $x$，由于 $\deg &gt; \sqrt m$ 的点不超过 $\sqrt m$ 个，所以可以直接 $for$ 过去判断是否与 $x$ 相邻。</p><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><blockquote><p>规定序列 $a_n$，每次给定 $x$ 和 $y$ ：</p><p>查询一个区间中最小的 $|i-j|$，使得 $a_i=x,a_j=y$。</p></blockquote><p>有趣的题。</p><p>考虑对于每种颜色按照出现次数分治。某个颜色 $x$ 的出现次数记作 $cnt_x$。对于 $cnt_x\leq \sqrt n$ 的可以预处理所有位置，这一部分时 $O(n)$ 空 $O(n\sqrt n)$ ，对于 $cnt_x&gt;\sqrt n$  的可以预处理到所有颜色的最小距离（由于是最小距离所以可以忽略区间长度的限制），这部分时 $O(n\sqrt n)$ 空 $O(n \sqrt n)$ 。</p><p>考虑询问 $(x,y)$，如果至少一个颜色的 $cnt&gt;\sqrt n$ 那么就可以直接做，否则考虑由于两个颜色的位置都已知且数量 $&lt;\sqrt n$，所以按顺序拿出来，对这两个序列归并一下就做完了，复杂度 $O(m\sqrt n+n\sqrt n)$ 。</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><blockquote><p>[Ynoi2015]いまこの時の輝きを</p><p>查询一个区间乘积的约数个数。</p><p>值域 $v\leq 10^9$。</p></blockquote><p>考虑 $\tau(x)=\prod (a_x+1)$ ， 同时对于某个 $v$ ，素因数个数是 $\frac{\log v}{\log \log v}$ 的，所以如果暴力莫队转移的话，每次转移的复杂度是 $O(\frac{\log v}{\log \log v})$，这样最后复杂度是 $O(nv^{\frac{1}{4}}+n\sqrt m\frac{\log v}{\log \log v})$，不过被 lxl 给卡掉了。</p><p>考虑一个神奇的根号分治。对于每个数 $v$ 而言， $&gt;\sqrt[3]v$ 的素因子至多只会有两个，在 $v=10^9$ 时，$&lt;10^3$ 的素数也只有 $168$ 个。所以可以暴力转移这些大素数的贡献，这样转移就是 $O(1)$ 的；然后对于每次询问，只需要再暴力统计小素数的贡献即可。最终复杂度 $O(nv^{\frac{1}{4}}+m\frac{3\cdot v^{\frac{1}{3}}}{\ln v}+n\sqrt m)$ 。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><blockquote><p>POI2015 Odwiedziny</p><p>树，点权，多次查询，每次给 <code>x,y,k</code>。</p><p>求从 $x$ 开始，每次跳过 $k$ 个节点跳到 $y$ 所经过节点的和。</p></blockquote><p>还是根号分治。考虑对于 $k\leq \sqrt n$ ，可以预处理出 $k=1,2,3\cdots \sqrt n$ 然后每次暴力向上跳，对于 $k&gt;\sqrt n$ ，至多需要跳 $\sqrt n$ 次，那么可以倍增求出 k 级祖先做到 $O(m\sqrt n\log n)$ ，或者长剖做到 $O(m\sqrt n)$ 。当然也可以轻重链剖，维护每条重链上深度从大到小的点的序列，这样单次复杂度就是 $O(\log k+\frac{n}{k})$ 了。</p><p>还有一种 zz 做法，记录每个点的 $1,2,3\cdots\sqrt n,2\sqrt n,3\sqrt n$ 级祖先，这样也是 $n\sqrt n + m\sqrt n$ 的了。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><blockquote><p>Bzoj4320 ShangHai2006 Homework</p><p>1.在人物集合 S 中加入一个 X，保证 X 在当前集合中不存在。</p><p>2.在当前的人物集合中询问所有X mod Y 最小的值</p><p>值域 $&lt;300000$ 。 </p></blockquote><p>考虑对于 $&lt;\sqrt V$ 的所有 Y ，令 $f_k$ 表示 Y = $k$ 时的答案，每次修改可以暴力维护所有 $f$，查询时 $O(1)$ 。这一部分复杂度为 $m\sqrt V$。</p><p>考虑对于 $&gt;\sqrt V$ 的所有 Y，发现 $V$ 以内至多有 $\sqrt V$ 个 Y 的倍数，那么每次查询相当于在两个相邻的 Y 的倍数之间查询区间最小值。注意到这样最多有 $m\sqrt V$ 次查询，$m$ 次修改，所以根号平衡一下，拿一个值域分块来维护即可。</p><p>总复杂度 $O(m\sqrt V)$ 。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>lxl 的课件确实都是比较有意思的题目，也确实开了眼界。</p><p>想继续学啊…可惜实力不允许啊…</p><p>不知道退役之前能不能完整地把这个课件看一遍了233</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…&lt;/p&gt;
&lt;p&gt;话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…&lt;/p&gt;
&lt;p&gt;日常不想写数据结构(1/1) 。&lt;/p&gt;
&lt;p&gt;然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
      <category term="技巧/根号分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
      <category term="数据结构/数据结构方法/分块" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
</feed>
