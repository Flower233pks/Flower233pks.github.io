<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰</title>
  
  <subtitle>A Soul Tune against Fate Should Be Played, now.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.orchidany.cn/"/>
  <updated>2020-02-08T03:43:10.984Z</updated>
  <id>https://www.orchidany.cn/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想 · 目次表</title>
    <link href="https://www.orchidany.cn/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://www.orchidany.cn/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2020-02-08T03:43:10.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><a id="more"></a><p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-WwwbwDOP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-WwwbwDOP"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><div class="table-container"><table><thead><tr><th style="text-align:center">篇目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 山丘</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人</td><td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 逃吧</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td></tr><tr><td style="text-align:center">随想十 · 繁星</td><td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td></tr></tbody></table></div><p>第一篇大概是开始？</p><p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p><p>第三篇就是2018考完NOIP写的啦。</p><p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p><p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p><p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p><p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p><p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p><p>第九篇大概是「奇异人生」的读/观后感？</p><p>最后一篇…是秘密！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于又开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://www.orchidany.cn/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【公告】关于这个blog</title>
    <link href="https://www.orchidany.cn/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.orchidany.cn/2050/02/05/【公告】博客使用指南/</id>
    <published>2050-02-05T09:51:27.000Z</published>
    <updated>2020-04-16T11:37:33.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？<del>虽然可能并没有人来逛QAQ</del></p><p>如果可以的话，谢谢你喜欢我！</p><p>2020.3.25 upd: 最近因为有新的东西想置顶，于是就把留言板换下来了，但是还是欢迎大家来留言：<a href="https://www.orchidany.cn/2019/08/09/留言板/#more">戳我</a> ！</p><a id="more"></a><h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p><p>CSP-2019考的太菜，导致现在十分被动。</p><p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p><p>其实挺热爱算法的吧？</p><p>CF平时真的不是很常打，所以并不想给CF的ID。sorry啦。</p><p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p><p>QQ:2836531293</p><h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p><p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p><p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p><p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p><p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p><p>3.22upd: 最近又把曾经连续记了好长一段时间、原来是置顶的「闲扯」给归档了：<a href="[https://www.orchidany.cn/2019/12/15/%E9%97%B2%E6%89%AF/](https://www.orchidany.cn/2019/12/15/闲扯/">戳</a>)</p><h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p><p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p><h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p><p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p><h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p><p>我一个人很无聊的说QAQ</p><h1 id="关于缺省源"><a href="#关于缺省源" class="headerlink" title="关于缺省源"></a>关于缺省源</h1><p>这一部分更新于 2020.4.16</p><p>想了想其实自己也没啥缺省的，于是似乎缺省源也不长的样子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr firsr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-7</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是一个本blog的观光指南？&lt;del&gt;虽然可能并没有人来逛QAQ&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;如果可以的话，谢谢你喜欢我！&lt;/p&gt;
&lt;p&gt;2020.3.25 upd: 最近因为有新的东西想置顶，于是就把留言板换下来了，但是还是欢迎大家来留言：&lt;a href=&quot;https://www.orchidany.cn/2019/08/09/留言板/#more&quot;&gt;戳我&lt;/a&gt; ！&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://www.orchidany.cn/categories/Life/"/>
    
    
      <category term="笔尖生花" scheme="https://www.orchidany.cn/tags/%E7%AC%94%E5%B0%96%E7%94%9F%E8%8A%B1/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF671E] Organizing a Race</title>
    <link href="https://www.orchidany.cn/2020/04/17/CF671E/"/>
    <id>https://www.orchidany.cn/2020/04/17/CF671E/</id>
    <published>2020-04-17T08:24:56.000Z</published>
    <updated>2020-04-17T11:09:30.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>再 放 送 </p><p>这题是十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。</p><p>做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…</p><p>接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… </p><a id="more"></a><p>XXXXXXXXXXXX 正文 XXXXXXXXXXXX</p><p>首先考虑，对于一段区间而言，需要多少操作多少次，才能保证正着走完并且反着走完。那么也就是需要算出正着走和反着走都需要额外的多少代价。</p><p>这个地方有个贪心。考虑定「向右走」为正方向。那么假设从 $i$ 开始走，如果遇到某个 $j&gt;i$ 发现走不得，那么应该在何处加油？因为还要考虑反着走回来，所以必然是加在最靠右的地方最优，所以就会选择的在 $j-1$ 处加油。记 $i$ 向右走遇到的第一个这样的 $j$ 为 $stop_i$  。</p><p>于是根据这个贪心就可以求出 $need(i,j)$ ，表示从 $i$ 走到 $j$ 需要多少代价。但这样也是只是保证了正着可以走。不妨令 $p_{i}$ 表示从 $1$ 走到 $i$ 花费的油量，$q_i$ 表示从 $i$ 走到 $1$ 花费的油量。 那么可知有递推：</p><script type="math/tex; mode=display">\begin{aligned}p_i&=p_{i-1}+g_{i-1}-w_{i-1}\\q_i&=q_{i-1}+g_{i-1}-w_i\end{aligned}</script><p>那么可以知道，在走 $i\to j$ 这条路线时，同时也在进行对 </p><script type="math/tex; mode=display">g_{stop_i},g_{stop_{stop_i}},g_{stop_{stop_{stop_i}}}\cdots</script><p>这些位置进行单点加，那么对 $q$ 的影响就是一个后缀加。记后缀加完之后的 $\{q_n\}$ 为 $\{\tau_n\}$ 。则如果不能从 $j$ 回到 $i$ ，就意味着着存在一个 $i\leq k&lt;j$ ，使得 $q_{k}-q_{j}&lt;0$ 。怎么量化这个东西呢？考虑还是贪心，如果从 $j$ 到 $i$ 走不了，那么一定会要把贡献累加到 $j$ 上，那需要累加的量就是 $q_{j}-\min_{k=i}^{j-1}\{q_{k}\}$ 。这也就是如果想要 $[i,j]$ 这个区间变得合法的最小贡献。</p><p>考虑如何计算这个东西。比较暴力的解法那必然是枚举一个左端点，然后向右走更新右端点。这样是 $n^2$ 的。发现如果想要优化，只能选择加速寻找右端点这个过程。但是有个问题在于，对于固定的 $i$ ，和想要二分出的 $j’$，要经过不同的 $stop$ 集合，同时有着不同的 $q_{j’}-\min_{k=i}^{j’-1}\{q_{k}\}$ ，求一次是 $O(n)$ 的，反而把复杂度搞成了 $n^2\log n$ 。</p><p>分开考虑这两点。对于经过不同 $stop$ 集合这个问题，可以继续深入挖掘性质。发现对于一个 $j$，可能存在一个连续段 $[k_1,k_2]$ 满足 $\forall z\in[k_1,k_2]\cap\mathbb{Z_+}$ ，$stop_z=j$ 。这种一对多的逻辑结构不难想到要用森林去表征。那么这个问题比较好解决了。建出一棵森林 $T$ ，连边 $i\leftrightarrow stop_i$ 。再建立一个虚根 $root$ ，与所有 $stop_i$ 未定义的结点相连。这样只要从 $root$ 开始 dfs，用退栈的方式辅助二分即可快速修改。</p><p>对于第二点，考虑对于一个固定的 $i$ ，本质上是在维护这么一个式子：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=i}^{j'}\{\tau_k \}</script><p>首先变一下形：</p><script type="math/tex; mode=display">t_{j'}=q_{j'}-\min_{k=1}^{j'}\{\tau_k \}</script><p>这样做的正确性在于，只要每次将 $&lt;i$ 的那些 $k$ 的 $\tau_k$ 都置为 $+\infty$ 就可以了。</p><p>考虑到底要怎么维护这个东西。发现在查询的过程中，需要单点修改 $g_i$ ，那么也就是区间修改 $q_j$ 和 $\tau_k$ ，那么也就是说要支持：1、维护前缀最小值 2、区间加/减 3、查询出某个最小值的位置。那自然就是线段树了。</p><p>考虑后一半的前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $\tau_k$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{\tau_k\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $q_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{k=1}^{j’}\{\tau_k\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $\tau_k$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr firsr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-7</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Fni = -(<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * f ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = y ; val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll sp[N] ;</span><br><span class="line">ll ss[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)</span><br><span class="line"><span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(sa[rt] = sb[rt] = ss[l]) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">stk[++ top] = x ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, - sp[fa[x]] + sp[x]) ;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n)&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span>, r = top - <span class="number">1</span>, ans = <span class="number">1</span>, mid ;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sp[stk[mid]] - sp[x] &gt; m)</span><br><span class="line">ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll tmp = Inf ; ans = stk[ans] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Inf) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Fni) ;</span><br><span class="line">res = max(res, query(<span class="number">1</span>, <span class="number">1</span>, n, tmp) - x + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Fni) ;</span><br><span class="line"><span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Inf) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">stk[top --] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, sp[fa[x]] - sp[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; w[n] = Inf ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) w[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) g[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">sp[i] = sp[i - <span class="number">1</span>] - g[i - <span class="number">1</span>] + w[i - <span class="number">1</span>] ;</span><br><span class="line">ss[i] = ss[i - <span class="number">1</span>] - g[i] + w[i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = n + <span class="number">1</span> ;</span><br><span class="line">    sp[n + <span class="number">1</span>] = Inf ; fa[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">while</span> (top &amp;&amp; sp[stk[top]] &lt;= sp[i]) -- top ;</span><br><span class="line">fa[i] = stk[top] ; stk[++ top] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) add_e(fa[i], i) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; top = <span class="number">0</span> ; dfs(n + <span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。&lt;/p&gt;
&lt;p&gt;你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。&lt;/p&gt;
&lt;p&gt;你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。&lt;/p&gt;
&lt;p&gt;你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再 放 送 &lt;/p&gt;
&lt;p&gt;这题是十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。&lt;/p&gt;
&lt;p&gt;做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…&lt;/p&gt;
&lt;p&gt;接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… &lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
      <category term="树模型" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="贪心" scheme="https://www.orchidany.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="单调队列/单调栈" scheme="https://www.orchidany.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】兔队线段树</title>
    <link href="https://www.orchidany.cn/2020/04/16/%E5%85%94%E9%98%9F%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://www.orchidany.cn/2020/04/16/兔队线段树/</id>
    <published>2020-04-16T12:38:44.000Z</published>
    <updated>2020-04-17T08:17:06.009Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：<a href="https://www.luogu.com.cn/problem/U96354" target="_blank" rel="noopener">Luogu U96354</a> 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233</p><p>然后今天又看到了兔的博文：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html" target="_blank" rel="noopener">从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法</a>。 感觉很神仙，然后就打算把这三道题都整理一下。</p><p><del>所以就是类似于复刻了一下兔秒掉or推荐的题</del>。</p><p>分别是三道题：<code>LGU96354 魔能阵列</code>，<code>BZOJ2957 楼房重建</code> 和 <code>CF671E Organizing a Race</code> .</p><a id="more"></a><h1 id="LGU96354-魔能阵列"><a href="#LGU96354-魔能阵列" class="headerlink" title="LGU96354 魔能阵列"></a>LGU96354 魔能阵列</h1><blockquote><p>给定两个序列 $\{a_n\},\{b_n\}$，定义一段区间 $[l,r]$ 的权值为</p><script type="math/tex; mode=display">\sum_{i=l}^r[b_i>0]a_i</script><p>现在给定两种操作，对 $\{b_n\}$ 区间加 $x$ (可正可负) 和询问某个区间的权值。保证任何时刻 $b_i\geq 0$ 。</p><p>$1 \leq n,m\leq 2 \times 10^5$   </p></blockquote><p>一个比较自然的想法，是分别维护区间 $b_i=0$ 的和 and 区间 $b_i\not = 0$ 的和。但是这个东西维护起来复杂度并不对。所以考虑换一下，由于保证任意时刻 $b_i\geq 0$ ，所以维护区间最小值， 区间 $b_i$ 的值 = 最小值的权值 and区间 $b_i$ 的值 $\not =$ 最小值的权值和。那么转移就分类讨论一下即可。回答询问的时候只需要再建立一个虚点，对询问区间进行合并，最后只需要判断该区间最小值是否是 $0$ 即可。</p><p>大概首先维护区间最小值是个 trick ，建一个虚点对 $\log n$ 个区间进行合并也是一个 trick 。但是这俩似乎我都不是很熟，导致我当时不太会做.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> cnt, _tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>], v[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], mnx[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ;  c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[x] == mnx[y])</span><br><span class="line">        s[x] = s[x] + s[y], v[x] = v[x] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[x] &lt; mnx[y]) s[x] = s[x] + s[y] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[x] = mnx[y], s[x] = s[x] + s[y] + v[x], v[x] = v[y] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> rt, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[ls] == mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs], v[rt] = v[ls] + v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[ls] &gt; mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[rs], s[rt] = s[ls] + s[rs] + v[ls], v[rt] = v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs] + v[rs], v[rt] = v[ls] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">pdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_tag[rt])&#123;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    mnx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    _tag[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   _tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    mnx[rt] = Inf, s[rt] = <span class="number">0</span>, v[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(mnx[rt] += x, _tag[rt] += x) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; pdown(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, x) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, x) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) </span><br><span class="line"><span class="keyword">return</span> _merge(ans, rt), <span class="keyword">void</span>() ;</span><br><span class="line">    pdown(rt) ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, ans) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, ans) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, N) ; (cnt *= <span class="number">2</span>) += <span class="number">1</span> ; <span class="keyword">int</span> l, r, x, opt ;</span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        opt = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            l = qr(), r = qr(), x = qr(), update(<span class="number">1</span>, <span class="number">1</span>, N, l, r, x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++ cnt, l = qr(), r = qr() ;</span><br><span class="line">            init(cnt), query(<span class="number">1</span>, <span class="number">1</span>, N, l, r, cnt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mnx[cnt] ? s[cnt] + v[cnt] : s[cnt]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bzoj2957-楼房重建"><a href="#bzoj2957-楼房重建" class="headerlink" title="bzoj2957 楼房重建"></a>bzoj2957 楼房重建</h1><blockquote><p>单点修改，查询整个序列有多个前缀最大值。</p><p>$1\leq n,m\leq 10^5$</p></blockquote><p>sto 兔。</p><p>首先考虑这东西暴力做的话，就是在模拟一个单调栈的过程。带修的话就要考虑套一个 ds。考虑 ds 的作用，本质上是要在每次修改完 $x$ 之后，将 $[1,x-1]$ 和 $[x+1,n]$ 这两个区间的单调栈和 $x$ 放在一起合并。于是不难想到要用线段树。</p><p>但…线段树似乎也没法快速合并。考虑每次 <code>push_up</code> 暴力把右区间合并到左区间里面，这样做显然是单次 $O(n)$ 的。考虑发掘更深一些，每次合并左右区间时，左区间是不受影响的，只需要统计左区间最大值对右区间答案的贡献。考虑每次合并，左区间最大值对右区间的影响一定是一个右区间的一个前缀。所以只需要每次合并时，线段树上二分出这个前缀的位置来即可。</p><p>然后实现的时候需要注意，二分完前缀之后，前缀的贡献是 $1$ ，剩下的后缀贡献不是 $cnt_{rc}$ 而是 $cnt_{root}-cnt_{lc}$ 。因为此时需要加上的是<strong>合并之后</strong>右区间对整体有多少贡献。</p><p>这样线段树二分 $1$ 个 $\log $ ，本身 <code>update</code> 又是 $1$ 个 $\log $ 。复杂度 $m\log ^2 n$ 。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line">db base[N] ;</span><br><span class="line">db s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> cnt[N * <span class="number">3</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">s[rt] = <span class="number">0</span> ; </span><br><span class="line">cnt[rt] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ; </span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, db v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> (s[rt] &gt; v) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (s[ls] &gt; v) </span><br><span class="line"><span class="keyword">return</span> query(ls, l, mid, v) + cnt[rt] - cnt[ls] ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">void</span>(s[rt] = base[l]) ; </span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= p) </span><br><span class="line">update(ls, l, mid, p) ; </span><br><span class="line"><span class="keyword">else</span> update(rs, mid + <span class="number">1</span>, r, p) ; </span><br><span class="line">s[rt] = max(s[ls], s[rs]) ; </span><br><span class="line">cnt[rt] = cnt[ls] + query(rs, mid + <span class="number">1</span>, r, s[ls]) ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) ; <span class="keyword">int</span> x ; db y ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">x = qr(), y = qr(), base[x] = (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * x) ; </span><br><span class="line">update(<span class="number">1</span>, <span class="number">1</span>, n, x) ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CF671E-Organizing-a-Race"><a href="#CF671E-Organizing-a-Race" class="headerlink" title="CF671E Organizing a Race"></a>CF671E Organizing a Race</h1><blockquote><p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。</p><p>第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p><p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。</p><p>车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p><p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p><p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。</p><p>问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p></blockquote><p>这个地方的转化会单独开一篇新的 $blog$，因为比较毒瘤。大概最后就是转化成了令</p><script type="math/tex; mode=display">t_i=suf_i-\min_{j=1}^i\{suf'_j\}</script><p>求最大的 $i$ 满足 $t_i\leq k$ 。然后要支持 $suf’_i$ 的区间加/减以及多次询问。</p><p>考虑后一半就是前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p><p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $suf’$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p><p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p><p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p><p>1、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p><p>2、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{suf_j’\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $a_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p><p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{j=1}^i\{suf’_j\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $suf’$ 。</p><p>这里就先只给出线段树部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">s[ls] -= tag[rt] ;</span><br><span class="line">s[rs] -= tag[rt] ;</span><br><span class="line">sb[ls] += tag[rt] ;</span><br><span class="line">sb[rs] += tag[rt] ;</span><br><span class="line">tag[ls] += tag[rt] ;</span><br><span class="line">tag[rs] += tag[rt] ;</span><br><span class="line">tag[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> sa[rt] - v ; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &gt;= v)</span><br><span class="line">    <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">sa[rt] = ss[l] ; </span><br><span class="line">    sb[rt] = ss[l]</span><br><span class="line">    <span class="keyword">return</span>  ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(ls, l, mid) ;</span><br><span class="line">build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">tag[rt] += v ;</span><br><span class="line">sb[rt] += v ;</span><br><span class="line">s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">_down(rt, l, r) ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">update(ls, l, mid, ul, ur, v) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line"><span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line"><span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">v = min(v, sb[rt]) ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line"><span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">v = sb[ls] ;</span><br><span class="line"><span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret ;</span><br><span class="line">ret = query(ls, l, mid, v) ;</span><br><span class="line">v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">ret = ask(ls, l, mid, m + v) ;</span><br><span class="line"><span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：&lt;a href=&quot;https://www.luogu.com.cn/problem/U96354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu U96354&lt;/a&gt; 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233&lt;/p&gt;
&lt;p&gt;然后今天又看到了兔的博文：&lt;a href=&quot;https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法&lt;/a&gt;。 感觉很神仙，然后就打算把这三道题都整理一下。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所以就是类似于复刻了一下兔秒掉or推荐的题&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;分别是三道题：&lt;code&gt;LGU96354 魔能阵列&lt;/code&gt;，&lt;code&gt;BZOJ2957 楼房重建&lt;/code&gt; 和 &lt;code&gt;CF671E Organizing a Race&lt;/code&gt; .&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数据结构/线段树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj2391 Cirno的忧郁</title>
    <link href="https://www.orchidany.cn/2020/04/15/Cirno-%E7%9A%84%E5%BF%A7%E9%83%81/"/>
    <id>https://www.orchidany.cn/2020/04/15/Cirno-的忧郁/</id>
    <published>2020-04-15T13:19:00.000Z</published>
    <updated>2020-04-16T01:34:32.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Cirno 闲着无事的时候喜欢冰冻青蛙。</p><p>雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。</p><p>Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。</p><p>因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。</p><p>对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&lt;v\leq 10^4$ 。</p></blockquote><p>不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。</p><p>紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。</p><a id="more"></a><p>大概考虑三角剖分本来是用于求多边形面积，方法是选择一个原点，按照逆时针或者顺时针的方式，把多边形顶点向量叉一圈的结果。形式化地讲，给定一个多边形 $A_1A_2A_3\ldots A_n$ ，那么这个多边形的面积就是</p><script type="math/tex; mode=display">\frac{\overrightarrow{O A_{n}}\times \overrightarrow{OA_1}}{2}+\sum_{i=1}^{n-1} \frac{\overrightarrow{O A_{i}}\times \overrightarrow{OA_{i+1}}}{2}</script><p>证明的话可能容斥可证，但我不会…我只知道两个向量的叉积是以这两个向量为临边的平行四边形的面积。</p><p><img src="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140847.png" alt="wjyyy的图"></p><p><img src="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140906.png" alt="wjyyy的图"></p><p>然后这里放了神仙 <code>wjyyy</code> 的图，看上去比较直观。</p><p>然后考虑这题怎么做。发现 $n+m$ 不大，于是考虑求一个 $f_{i,j}$ 表示向量 $\bf V_i$ 与 $\bf V_{j}$ 之间，$\bf V_{i}\to \bf V_{j}$ 需要逆时针旋转时，$i,j$ 之间的价值和。那么对于每一个询问 $\{s_n\}$ ，答案就是 $\sum f_{s_i,s_{i+1}}$ 。 </p><p>考虑如何预处理这个东西。首先对所有向量按照极角逆时针排序(相等则模长大者位次靠后)，枚举 $i$ ，之后就需要喜闻乐见的平衡树了。大概是这样：</p><p><img src="1.png" alt></p><p>其中红色向量是题目所给的向量，蓝色向量是辅助线。因为一开始就已经是逆时针排序，所以只需要判断每个向量的中点是否落在向量 $\bf i,j,t_2$ 构成的三角形即可。观察落在三角形内部的向量 $\bf k$ 和落在外部的向量 $\bf p$ ，会发现有 </p><script type="math/tex; mode=display">\bf {\text{<}i,t_1\text{>} \geq \text{<}i,t_2\text{>}\geq \text{<}i,t_3\text{>}}</script><p>考虑向量夹角最大为 $\pi$ ，$y=\cos x$ 在 $[0,\pi]$ 上单调递减，于是可以知道要拿 $\cos x$ 作为键值，该向量的 $val$ 作为点值插入平衡树。其中 $\cos x$ 拿向量内积求即可。 </p><p>最终复杂度 $O(n^2\log n+ms)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pts</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; <span class="keyword">int</span> val ; db x, y ;</span><br><span class="line"><span class="function">il db <span class="title">mo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y) ; &#125;</span><br><span class="line">il <span class="keyword">friend</span> pts <span class="keyword">operator</span> - (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> (pts)&#123;<span class="number">0</span>, <span class="number">0</span>, p.x - q.x, p.y - q.y&#125; ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> * (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.y - p.y * q.x ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">friend</span> db <span class="keyword">operator</span> + (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line"><span class="keyword">return</span> p.x * q.x + p.y * q.y ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;v[N], org, calc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">cosi</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / (a.mo() * b.mo()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line">db ang = (a - org) * (b - org) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ang &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">if</span> (ang != eps) <span class="keyword">return</span> ang &gt; eps ;</span><br><span class="line"><span class="keyword">return</span> (a - org).mo() &lt; (b - org).mo() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _splay&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">splay</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> val ;</span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> fa ;</span><br><span class="line"><span class="keyword">int</span> sz ;</span><br><span class="line">db key ;</span><br><span class="line">&#125;s[N] ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) s[x].sz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(x) s[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key(x) s[x].key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot(x) s[x].tot</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) s[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size ;</span><br><span class="line"><span class="keyword">int</span> root ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x == rc(fa(x))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size ; ++ i)&#123;</span><br><span class="line">sz(i) = lc(i) = rc(i) = fa(i) = <span class="number">0</span> ;</span><br><span class="line">tot(i) = val(i) = key(i) = sum(i) = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span> ; root = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz(x) = tot(x) ;</span><br><span class="line">sum(x) = val(x) ;</span><br><span class="line"><span class="keyword">if</span> (lc(x))&#123;</span><br><span class="line">sz(x) += sz(lc(x)) ;</span><br><span class="line">sum(x) += sum(lc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rc(x))&#123;</span><br><span class="line">sz(x) += sz(rc(x)) ;</span><br><span class="line">sum(x) += sum(rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = w(x) ;</span><br><span class="line"><span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line"><span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line"><span class="keyword">if</span> (!f2) root = x ;</span><br><span class="line"><span class="keyword">else</span> s[f2].son[w(f1)] = x ;</span><br><span class="line">fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">fa(s[x].son[c ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">s[f1].son[c] = s[x].son[c ^ <span class="number">1</span>] ;</span><br><span class="line">s[x].son[c ^ <span class="number">1</span>] = f1 ; upd(f1), upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (fa(x) != aim)&#123;</span><br><span class="line"><span class="keyword">if</span> (fa(fa(x)) != aim)</span><br><span class="line">rotate(w(x) == w(fa(x)) ? fa(x) : x) ;</span><br><span class="line">rotate(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;x, db ky, <span class="keyword">int</span> v, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line">x = ++ size ;</span><br><span class="line">fa(x) = dad ;</span><br><span class="line">key(x) = ky ;</span><br><span class="line">val(x) = sum(x) = v ;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ky &lt; key(x))</span><br><span class="line">Ins(lc(x), ky, v, x) ;</span><br><span class="line"><span class="keyword">else</span> Ins(rc(x), ky, v, x) ; upd(x) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> _splay ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">org.x = <span class="number">-100000</span> ;</span><br><span class="line">org.y = <span class="number">-100000</span> ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">db x, y, w ; <span class="keyword">int</span> z, h, r ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, v[++ cnt] = (pts)&#123;i, <span class="number">0</span>, x, y&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w, v[++ cnt] = (pts)&#123;i, w, x, y&#125; ;</span><br><span class="line">sort(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, comp) ; m = n ; n = cnt ; <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (v[i].id &gt; m) <span class="keyword">continue</span> ;</span><br><span class="line">clear() ; pts o = v[i] - org ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">pts z = v[j] - v[i] ; db ky = cosi(o, z) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; '\n' ;</span></span><br><span class="line">Ins(root, ky, v[j].val, <span class="number">0</span>) ; splay(size, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(v[j].id &lt;= m)&#123;</span><br><span class="line">            f[v[i].id][v[j].id] = sum(lc(root)) ;</span><br><span class="line">            f[v[j].id][v[i].id] = - sum(lc(root)) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n] ; */</span></span><br><span class="line"><span class="keyword">while</span> (q --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; L ; <span class="built_in">cin</span> &gt;&gt; h ; r = h ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; z, ans += f[h][z], h = z ;</span><br><span class="line">ans += f[h][r] ; <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(ans)) ; ans = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写了一遍 splay，发现是真的慢+维护的信息真的多…</p><p>并且发现递归式的 splay 插入是真的好写。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Cirno 闲着无事的时候喜欢冰冻青蛙。&lt;/p&gt;
&lt;p&gt;雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。&lt;/p&gt;
&lt;p&gt;Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。&lt;/p&gt;
&lt;p&gt;因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&amp;lt;v\leq 10^4$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。&lt;/p&gt;
&lt;p&gt;紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="计算几何/三角剖分" scheme="https://www.orchidany.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
    
      <category term="数据结构/平衡树/splay" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E6%A0%91-splay/"/>
    
  </entry>
  
  <entry>
    <title>【题解】bzoj3881[COCI2015] Divljak</title>
    <link href="https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/"/>
    <id>https://www.orchidany.cn/2020/04/15/COCI2015-Divljak/</id>
    <published>2020-04-15T13:17:33.000Z</published>
    <updated>2020-04-16T00:22:25.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。</p><p>接下来会发生 $q$ 个操作，操作有两种形式：</p><ol><li><code>1 P</code> Bob 往自己的集合里添加了一个字符串 $\rm P$。</li><li><code>2 x</code> Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。</li></ol><p>对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。</p></blockquote><p>今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。</p><p>啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq</p><a id="more"></a><p>大概是考虑，反正是匹配问题——那么是对着 $\rm T$ 建自动机呢，还是对 $\rm \{S_n\}$ 建。 考虑 AC 自动机更适合做这种匹配题，于是大概想到要拿 AC 自动机做；考虑如果对着 $\rm T$ 建自动机，树的形态会变，$\rm S$ 的信息需要动态维护，并不很好做，于是考虑对 $\rm S$ 建自动机 $\rm AC_s$。</p><p>考虑这样做，就需要在已经建好的自动机上，对于每个新加进来的 $P$ 计算贡献。那么会被 $P$ 包含的字符串，一定是 $P$ 在 $\rm AC_s$ 里匹配的 $endpos$ 到根的路径上每个点，到根的链上的点集并。暴力是 $n^2$ 的，考虑如何快速计算这个贡献，发现能做到最快的，也就是通过维护 dfs 序的方式求出点集并。对于每一个这样的链的并打一个标记。询问的时候只需要回答一下子树内有多少个点被打了不同的标记。</p><p>发现「维护树链标记」+「子树求和」，最快速的方法是维护差分。同时由于是动态的，可以想到用线段树或者 BIT 快速维护。</p><p>考虑修改如何进行。发现为了保证 $\land$ 形态的链只会被计数一次，需要在 $lca$ 处差分。此处需要注意的是，要对 $dfs$ 序排序之后，再逐个差分，方法是 $(i,+1),(i+1,+1),(lca_{i,i+1},-1)$ 。</p><p>想了半天才大约明白为什么要按 dfs 序排一遍序。大概是如果不按 dfs 序的顺序枚举，可能会出现某个子树未被成功打上标记的情况。</p><p>最终复杂度是 $O(\rm |S|\log |S|)$ 的，跑的不是很快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigma 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2001010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> T, M, N, L[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], base[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> _ed[MAXN], dfn[MAXN], rgl[MAXN], rgr[MAXN], tp ;</span><br><span class="line"><span class="keyword">int</span> sz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN], val[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp,</span><br><span class="line">    dfn[u] = rgl[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">    rgr[u] = tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    val[rt] = val[rt &lt;&lt; <span class="number">1</span>] + val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= p)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; pr &gt;= r) <span class="keyword">return</span> val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, pl, pr) ;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pl, pr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> _size, fail[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L[n] ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trie[rt][x])</span><br><span class="line">                trie[rt][x] = ++ _size ;</span><br><span class="line">            rt = trie[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[n] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.front() ; add(fail[n], n), q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trie[n][i]) trie[n][i] = trie[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trie[n][i]] = trie[fail[n]][i], q.push(trie[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, rt = <span class="number">0</span> ; tp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            x = S[i] - <span class="string">'a'</span>, rt = trie[rt][x], base[++ tp] = rt ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + tp + <span class="number">1</span>, comp),</span><br><span class="line">        tp = unique(base + <span class="number">1</span>, base + tp + <span class="number">1</span>) - base - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tp ; ++ i)&#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[base[i]], <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[lca(base[i], base[i - <span class="number">1</span>])], <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">// freopen("1.ans", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> m, q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= T ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), L[i] = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.insert(S, i) ;</span><br><span class="line">    AC.build() ; <span class="built_in">cin</span> &gt;&gt; M ; dfs(<span class="number">0</span>), dfs2(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= T ; ++ i) cout &lt;&lt; rgl[i] &lt;&lt; " " &lt;&lt; rgr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        m = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.solve(S) ;</span><br><span class="line">        <span class="keyword">else</span> q = qr(),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgr[_ed[q]]) - query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgl[_ed[q]] - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。&lt;/p&gt;
&lt;p&gt;接下来会发生 $q$ 个操作，操作有两种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 P&lt;/code&gt; Bob 往自己的集合里添加了一个字符串 $\rm P$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x&lt;/code&gt; Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。&lt;/p&gt;
&lt;p&gt;啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="树上技巧/dfs序+树状数组" scheme="https://www.orchidany.cn/tags/%E6%A0%91%E4%B8%8A%E6%8A%80%E5%B7%A7-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串/AC自动机" scheme="https://www.orchidany.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[CF626F]Group Projects</title>
    <link href="https://www.orchidany.cn/2020/04/15/CF626F/"/>
    <id>https://www.orchidany.cn/2020/04/15/CF626F/</id>
    <published>2020-04-15T01:20:49.000Z</published>
    <updated>2020-04-15T02:33:02.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>有 $n$ 个学生，每个学生有一个能力值 $a_i$。现在要把这些学生分成一些(任意数量的)组，每一组的“不和谐度”是该组能力值最大的学生与能力值最小的学生的能力值的差。求所有不和谐度之和不超过 $k$ 的分组方案总数对 $10^9+7$ 取模。</p><p>$n\leq 200,k\leq 1000,0\leq a_i\leq 500$</p></blockquote><p>从头开始的计数生活.png</p><a id="more"></a><p>考虑暴力计数，大概就是 $f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了 $j$ 组，当前不和谐度总和为 $k$ 的方案数。发现这样没法转移，因为并不知道该怎么考虑插入一个元素时的贡献。考虑对于一种状态，如果钦定了其中某些集合的最大值或者最小值已经固定，如果当前元素超过了这个 bond，就不能再用当前元素更新。于是考虑另一种状态，$f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了不知道组，但是有 $j$ 组的最大值还没确定，当前不和谐度总和为 $k$ 的方案数 。这样显然是需要将所有权值排序之后再 $dp$ 的。</p><p>考虑转移。每次遇到一个新的元素，可以将其和之前的某一组合并，或者单独新开一组。记没确定最大值的集合为「未闭合集合」，那么就有四种情况：</p><p>1、合并，但是那个集合仍未闭合。</p><p>2、合并，那个集合闭合了。</p><p>3、不合并，新开的集合未闭合。</p><p>4、不合并，新开的集合闭合了。</p><p>于是转移就是</p><script type="math/tex; mode=display">f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k}\\ (j+1)\times f_{i-1,j+1,k+a_i}\\ f_{i-1,j-1,k-a_i}\\f_{i-1,j,k}\end{cases}</script><p>分别对应四种情况。</p><p>考虑这么做的复杂度，似乎是 $O(n^2k)$ ，但是由于中间转移过程的第三维可能会到 $\pm 10^4$ ，大小无法准确预估，所以时空复杂度都是 $O(n^2\sum a_i)$ 的。于是就 gg 。</p><p>考虑稍微抽象一下，每个集合的 $min/max$ 可以看做在一条值域轴上线段的左、右端点，对于每个时刻 $i$ ，未闭合的集合就是某些会被 $i$ 横切掉的线段。那么对于某条直线 $(l,r)$ ，满足 $l&lt;i&lt;r$ ，在第 $i$ 个时刻，记录的是代价是 $-a_l$，但这种方法并不聪明，因为只有当取到 $r$ 时，$-a_l$ 才会被用上，所以对于任意一个 $i,l&lt;i&lt;r$ 而言，$-a_l$ 都是没必要承载的空间。于是考虑怎么将一条线段的贡献平摊到每个点上，这样每一维转移就不再是 $O(\max\{\sum a_i,k\})$ 而是 $O(\max\{a_i,k\})$ 。</p><p>考虑平摊的话，即如何将 $a_r-a_l$ 展开成每一项都 $&lt;\max\{a_i,k\}$ 的这么一个数列。一个比较简单的方法就是：</p><script type="math/tex; mode=display">a_r-a_l=\sum_{i=l+1}^r(a_i-a_{i-1})</script><p><del>一看就是老分式裂项了</del></p><p>于是本质上只是优化了转移。令 $d=a_i-a_{i-1}$ 可以得到：</p><script type="math/tex; mode=display">f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k-j\times d}\\ (j+1)\times f_{i-1,j+1,k-(j+1)\times d}\\ f_{i-1,j-1,k-(j-1)\times d}\\f_{i-1,j,k-j \times d}\end{cases}</script><p>然后就没有然后了，复杂度 $O(n^2\max\{k,\max\{a_i\}\})$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line">LL dp[<span class="number">2</span>][MAXN][MAXK], ans ;</span><br><span class="line"><span class="keyword">int</span> N, K, M, base[MAXN], dif[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123; x -= y ; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += Mod ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL &amp;x, <span class="keyword">const</span> LL &amp;y)</span></span>&#123; x += y ; <span class="keyword">if</span> (x &gt; Mod) x %= Mod ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, k, d ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"> sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>), dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) dif[i] = base[i + <span class="number">1</span>] - base[i] ;</span><br><span class="line"><span class="keyword">for</span> (d = i = <span class="number">1</span> ; i &lt; N ; ++ i, d ^= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> o = d ^ <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line"><span class="keyword">int</span> op = dif[i] * j ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= K ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> val = k + op ;</span><br><span class="line">LL res = dp[o][j][k], v = res * j % Mod ;</span><br><span class="line">dp[o][j][k] = <span class="number">0</span> ; <span class="keyword">if</span> (val &gt; K) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span> (j) add(dp[d][j - <span class="number">1</span>][val], v) ; </span><br><span class="line">add(dp[d][j][val], v + res), add(dp[d][j + <span class="number">1</span>][val], res) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) </span><br><span class="line">add(ans, dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>][i]) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有 $n$ 个学生，每个学生有一个能力值 $a_i$。现在要把这些学生分成一些(任意数量的)组，每一组的“不和谐度”是该组能力值最大的学生与能力值最小的学生的能力值的差。求所有不和谐度之和不超过 $k$ 的分组方案总数对 $10^9+7$ 取模。&lt;/p&gt;
&lt;p&gt;$n\leq 200,k\leq 1000,0\leq a_i\leq 500$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从头开始的计数生活.png&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="动态规划/有技巧的DP" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/"/>
    
      <category term="思维题/计数" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AE%A1%E6%95%B0/"/>
    
      <category term="思维题/找性质" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[Ynoi2019]Yuno loves sqrt technology II</title>
    <link href="https://www.orchidany.cn/2020/04/12/Ynoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-II/"/>
    <id>https://www.orchidany.cn/2020/04/12/Ynoi2019模拟赛-Yuno-loves-sqrt-technology-II/</id>
    <published>2020-04-12T13:46:29.000Z</published>
    <updated>2020-04-14T00:18:16.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。</p><p>$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ 。</p></blockquote><p>这还是我第一次认真做了 lxl 的由乃 OI 题目，233.</p><a id="more"></a><p>还是考虑二次离线，那么需要预处理</p><script type="math/tex; mode=display">\sum_{i=1}^k (i,i)(1,i-1)\quad | \quad \sum_{i=1}^k (i,i)(1,i)</script><p>和</p><script type="math/tex; mode=display">\sum_{i=k+1}^n (i,i)(i+1,n)\quad | \quad \sum_{i=k+1}^n (i,i)(i,n)</script><p>这 $4$ 个信息，因为在计算逆序对的时候是有方向性的，$l$ 向左扩展/向右收缩对应的是 $(l+1,n)$ 之间的信息，$r$ 向右扩展/左收缩对应的是 $(1,r-1)$ 之间的信息。同时注意到由于 $(i,i)(1,i)=(i,i)(1,i-1)$ ，所以本质上是两个信息。这个可以 $O(n\log n)$ 预处理。</p><p>同理，对于不能预处理的区间，也是要分左边的贡献和右边的贡献来做。根据方向，可以方便地判断每种情况贡献应该怎么加，拿两种值域分块，分别维护前缀和&amp;后缀和就好了。</p><p>实现细节方面需要注意：</p><p>1、本题数据中存在 $a_i$ 相同的情况，这个地方会卡求逆序对时的边界，注意判一下即可。</p><p>2、值域分块需要注意，只需要修改整块的 <code>sum</code>，零散的点单独算贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ;</span><br><span class="line"><span class="keyword">int</span> V ;</span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll s1[N] ;</span><br><span class="line">ll s2[N] ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> sumb[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qrd</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qrd(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qrd;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ql[N], qr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= p &amp; -p) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= V ; p += p &amp; -p) _bit[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inssuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = blv[x] + <span class="number">1</span> ; i &lt;= blv[V] ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &lt;= V ; ++ i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Asksuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inspre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blv[x] - <span class="number">1</span> ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &gt;= <span class="number">1</span> ; -- i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Askpre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">qrd(n), qrd(m), B = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qrd(base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    L = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i] = lwb(tmp + <span class="number">1</span>, tmp + L + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">        V = max(base[i], V) ; bl[i] = i / B ;</span><br><span class="line">    &#125;</span><br><span class="line">    B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] + ask(base[i] - <span class="number">1</span>), add(base[i]) ;</span><br><span class="line">    fill(_bit, _bit + V + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + i - <span class="number">1</span> - ask(base[i]), add(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">qrd(q[i].l), qrd(q[i].r), q[i].id = i ;</span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l] + s1[r] ;<span class="comment">//l 的贡献变成了一个后缀，原来是 l'-(l-1),现在变成了 l-l'</span></span><br><span class="line">ans[i] += s2[newl] + s1[newr] ;<span class="comment">//l 和 r 要分开计算贡献</span></span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(newl, l - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qr[newr + <span class="number">1</span>].emplace_back(l, newl - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r)</span><br><span class="line">ql[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Inspre(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : ql[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Askpre(base[o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">memset</span>(sumb, <span class="number">0</span>, <span class="keyword">sizeof</span>(sumb)) ;</span><br><span class="line">    <span class="built_in">memset</span>(sump, <span class="number">0</span>, <span class="keyword">sizeof</span>(sump)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        Inssuf(base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qr[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Asksuf(base[o] - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line">qwa(res, n, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。&lt;/p&gt;
&lt;p&gt;$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这还是我第一次认真做了 lxl 的由乃 OI 题目，233.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】莫队二次离线</title>
    <link href="https://www.orchidany.cn/2020/04/11/%E8%8E%AB%E9%9A%8A%E4%BA%8C%E6%AC%A1%E9%9B%A2%E7%B7%9A/"/>
    <id>https://www.orchidany.cn/2020/04/11/莫隊二次離線/</id>
    <published>2020-04-11T03:47:01.000Z</published>
    <updated>2020-04-12T14:40:33.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。</p><p>另附 pks 词典：</p><blockquote><p>『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。</p><p>『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。</p><p>『 』(无评价) ：学会了。</p></blockquote><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。然后由于信息具有可减性(比如常见的「点对数」)，那么可以：</p><p>记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。 </p><p>1、如果 $[l,r]\to [l+t,r]$ ，那么可知 </p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l}^{l+t-1} (i,i)(i+1,r)=\sum_{i=l}^{l+t-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l,l+t-1)(1,r)-\sum_{i=l}^{l+t-1}(i,i)(1,i)</script><p>2、如果 $[l,r]\to [l-t,r]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=l-t}^{l-1} (i,i)(i+1,r)=\sum_{i=l-t}^{l-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l-t,l-1)(1,r)-\sum_{i=l-t}^{l-1}(i,i)(1,i)</script><p>3、如果 $[l,r]\to [l,r+t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r+1}^{r+t}(i,i)(l,i-1)=\sum_{i=r+1}^{r+t}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r+1,r+t)+\sum_{i=r+1}^{r+t}(i,i)(1,i-1)</script><p>4、如果 $[l,r]\to [l,r-t]$ ，那么可知</p><script type="math/tex; mode=display">\Delta ans=\sum_{i=r-t+1}^{r}(i,i)(l,i-1)=\sum_{i=r-t+1}^{r}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r-t+1,r)+\sum_{i=r-t+1}^{r}(i,i)(1,i-1)</script><p>其中 $\sum$ 并不是真正的 $\sum$ ，不同情况下需要按顺序(即不再有交换律)，比如 $[l,r]\to [l,r-t]$ 时就需要从 $r-1$ 算到 $r-t$ 。</p><p>然后这样容斥之后，后面的 $\sum$ 就可以预处理了，前面的 $()()$ ，由于莫队的复杂度，可以知道至多有 $n\sqrt m$ 个不同的询问，这样就可以把每一组询问打标记，打到左端点是 $1$ 的那个询问上 (比如 $[l,r]\to [l,r-t]$ 就打到 $l-1$ 上)。最后扫一遍全部的 $i\in[1,n]\cap\mathbb{Z_+}$，这样最终复杂度 $O(n\sqrt m)$ 。可以看出比起普通的莫队，二次离线还有一个好处，就是只有 $O(n)$ 次插入，于是对于某些题就可以用值域分块的技巧做到 $O(n\sqrt m+n\sqrt n)$ 。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>LG 4887 第十四分块(前体)</p><p>珂朵莉给了你一个序列 $a$，每次查询给一个区间 $[l,r]$ </p><p>查询 $l \leq i&lt; j \leq r$ ,且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。</p></blockquote><p>似乎就是板子题，然后对于 $(i,i)(1,i-1)$ 和 $(i,i)(1,i)$ 这个东西的预处理可以拿一个桶来维护，$buc_x$ 表示有多少个数 $\oplus x$ 之后二进制位有 $k$ 个 $1$ ，剩下的就是比较典型的莫队二次离线了。</p><p>值得一提的是…$\binom{14}{7}=3432$ ，再乘上一个 $10^5$ ，时间根本承受不了…所以这就很神必…打算写完之后出个数据卡一卡，不知道能不能成功。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16385</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> cnt ;  </span><br><span class="line">ll s1[N] ; </span><br><span class="line">ll s2[N] ; </span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ; </span><br><span class="line"><span class="keyword">int</span> bu[N] ;</span><br><span class="line"><span class="keyword">int</span> len[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ; </span><br><span class="line"><span class="keyword">if</span> (!k) bu[++ cnt] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">len[i] = len[i - (i &amp; -i)] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (len[i] == k) bu[++ cnt] = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bl[i] = i / B ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">s1[i] = s1[i - <span class="number">1</span>] + (ll)buc[base[i]] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">buc[base[i]  ^  bu[j]] += <span class="number">1</span> ; </span><br><span class="line">s2[i] = s2[i - <span class="number">1</span>] + (ll)buc[base[i]] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; s1[i] &lt;&lt; " " &lt;&lt; s2[i] &lt;&lt; '\n' ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="comment">//emplace_back </span></span><br><span class="line"><span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line"><span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line"><span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line"><span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">ans[i] -= s2[l - <span class="number">1</span>] + s1[r] ; </span><br><span class="line">ans[i] += s2[newl - <span class="number">1</span>] + s1[newr] ;</span><br><span class="line"><span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">qs[newr].emplace_back(newl, l - <span class="number">1</span>, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">qs[newr].emplace_back(l, newl - <span class="number">1</span>, -i) ;</span><br><span class="line"><span class="keyword">if</span> (newr &lt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r) </span><br><span class="line">qs[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">&#125;</span><br><span class="line">debug(ans, <span class="number">1</span>, m, <span class="string">'\n'</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++ i) buc[i] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) </span><br><span class="line">buc[base[i] ^ bu[j]] += <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qs[i])&#123;</span><br><span class="line"><span class="keyword">int</span> l, r, id ;</span><br><span class="line">tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o) tmp += buc[base[o]] ;</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) ans[id * (<span class="number">-1</span>)] -= tmp ; <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便结束之后卡了一下，写了个觉得肯定可以卡的 gen：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16383</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">7</span> ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line"><span class="keyword">int</span> i = j ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = j ; (i - j) &lt; M &amp;&amp; p &lt;= n ; i ++, p += <span class="number">2</span>)</span><br><span class="line">base[p] = M - (i - j), base[p + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">j = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">srand(time(<span class="number">0</span>)) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="string">" "</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">gene_Array() ; <span class="keyword">int</span> B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, base[i], <span class="string">" \n"</span>[i == n]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; p) p += B ;</span><br><span class="line"><span class="keyword">int</span> l = p, r = n - p / <span class="number">2</span> ;</span><br><span class="line">        l %= n, r %= n ; <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += n ;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) swap(l, r) ;</span><br><span class="line">l += rand() % (r-l+<span class="number">1</span>) ;</span><br><span class="line">r += rand() % (n-r+<span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="233.jpeg" alt></p><p>其中第二行是我拿一个计数器，记了一下运算量。$7e8$ 能稳过 $1s$，这就很睿智，我果然跟时代脱节了。</p><h1 id="例题-amp-总结"><a href="#例题-amp-总结" class="headerlink" title="例题&amp;总结"></a>例题&amp;总结</h1><blockquote><p>由于个人感觉很有整理价值，于是决定新开一篇整理（</p></blockquote><p>之前一直觉得二次离线会很难，学了学觉得其实还可以。并且没准二次离线这个技巧可以利用到其它地方？或许吧。</p><p>莫队系列似乎是都学完了，爷的青春结束啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。&lt;/p&gt;
&lt;p&gt;另附 pks 词典：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。&lt;/p&gt;
&lt;p&gt;『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。&lt;/p&gt;
&lt;p&gt;『 』(无评价) ：学会了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="莫队" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%AB%E9%98%9F/"/>
    
    
      <category term="技巧/二次离线" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj3730]震波</title>
    <link href="https://www.orchidany.cn/2020/04/09/%E9%9C%87%E6%B3%A2/"/>
    <id>https://www.orchidany.cn/2020/04/09/震波/</id>
    <published>2020-04-09T01:12:59.000Z</published>
    <updated>2020-04-09T15:46:31.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。</p><p>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。</p><p>接下来你需要在线处理 $m$ 次操作：</p><p><code>0 x k</code> 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</p><p><code>1 x y</code> 表示第 $x$ 个城市的价值变成了 $y$ 。</p><p>为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。</p></blockquote><p>這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…</p><p>不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。</p><p>upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。</p><a id="more"></a><p>大概就是如果沒有修改操作的話，就是比較裸的點分樹。於是先考慮沒有修改操作的情況。</p><p>考慮怎麼維護這個東西，自然是希望對每個點都記錄一個桶，但這樣顯然由於每個點的深度不可控，最終需要的空間代價是 $O(n^2)$ 的。於是考慮怎麼調整樹的高度使得最終總的空間複雜度可以接受，那自然就會想到點分治。注意到點分治時，每個點在分治過程中，『邏輯樹高』都只有 $\log n$ 。這大概就是為什麼用點分樹的原因。</p><p>所以就是建出點分樹來，每個點維護一個 <code>vector</code> 作為桶，維護點分樹上子樹內到當前點距離為 $k$ 的點權和。這樣對於詢問，每次只需要跳點分樹，然後對於每個 $fa$ 統計 $k-dis(fa,x)$ 的點對的數量就好了。但是還有一個問題，就是對於以當前 $fa$ 為根的那些子樹，在算下一個 $fa$ 的時候會被算重。於是就要再維護一個桶，表示 $x$ 子樹內的點，到點分樹上 $x$ 的父親的距離為 $k$ 的點權和。由於邊權都為 $1$ ，這個操作就會很方便。</p><p>考慮如果帶修改，那無非就是把桶換成樹狀數組即可。這樣複雜度就會是 $O(m\log ^2 n)$ 的了。可能我寫的比較醜？預處理是常數不小的 $O(n\log ^2 n)$ ，似乎比其他人都慢誒…</p><p>然後是 bug 集錦：</p><p>1、最開始的時候維護的是 <strong>點分樹</strong> 上距離為 $k$ 的點的點權和。</p><p>2、然後改了改，但是查詢的時候沒有維護兩個 BIT，只維護了一個，然後減去的是查詢 $x$ 的點分樹子樹內到 $x$ 距離 $\leq k-2\times dis(fa_x,x)$ 的點權和。看上去有點東西，但問題在於到 $x$ 距離和到 $fa_x$ 距離沒有本質上的關係…比如可以在樹的對側。</p><p>3、最後還是寫了兩個 BIT，但是調了很久，原因是向上跳遇到 $dis(fa_x,x)&gt;k$ 應該 <code>continue</code> 而不是 <code>break</code> ，因為這距離並是實際距離，在點分樹上沒有單調性。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> d[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> mx_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sub[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; buc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> findCG ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">buc[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = buc[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) buc[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= buc[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)buc[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">sub[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = sub[root].size() ;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) sub[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= sub[root].size())</span><br><span class="line">x = (<span class="keyword">int</span>)sub[root].size() - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += sub[root][x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">Id[root][x] = dep[x] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa)</span><br><span class="line">calc(to(i), x, root), size[x] += size[to(i)] ;</span><br><span class="line">mx_dep = max(dep[x], mx_dep) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root, <span class="keyword">int</span> frt)</span></span>&#123;</span><br><span class="line">add(root, dep[x], base[x]) ;</span><br><span class="line"><span class="keyword">if</span> (frt) add2(root, Id[frt][x], base[x]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa) calc2(to(i), x, root, frt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx ; vis[x] = <span class="number">1</span> ; mx_dep = <span class="number">0</span> ; </span><br><span class="line">calc(x, <span class="number">0</span>, x), init(x, mx_dep) ; </span><br><span class="line">init2(x, h) ; mx = mx_dep ; </span><br><span class="line">calc2(x, <span class="number">0</span>, x, fa) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">num = size[to(k)] ; reset() ;</span><br><span class="line">dfs(to(k), x) ; f[grt] = x ;</span><br><span class="line">find_tree(grt, x, mx) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">char</span> c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line"><span class="keyword">return</span> r ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">a = qr(), b = qr(), add(a, b), add(b, a) ;</span><br><span class="line">reset() ; num = n ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; find_tree(grt, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">a = qr() ; </span><br><span class="line">b = qr() ^ lans ; </span><br><span class="line">c = qr() ^ lans ;</span><br><span class="line"><span class="keyword">if</span> (!a)&#123;</span><br><span class="line"><span class="keyword">int</span> fb = f[b] ;</span><br><span class="line"><span class="keyword">int</span> ob, lb = b, df ;</span><br><span class="line">ans += ask(lb, c + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">while</span> (fb)&#123;</span><br><span class="line">df = Id[fb][b] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (c - df &lt; <span class="number">0</span>)&#123;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ans += ask(fb, c - df + <span class="number">1</span>) ;</span><br><span class="line">ans -= ask2(lb, c - df + <span class="number">1</span>) ;</span><br><span class="line">lb = fb, fb = f[fb] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (lans = ans)) ; </span><br><span class="line">ans = <span class="number">0</span> ; <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ob = b ;</span><br><span class="line">add(b, <span class="number">1</span>, -base[b] + c) ;</span><br><span class="line"><span class="keyword">while</span> (f[b])&#123;</span><br><span class="line"><span class="keyword">int</span> df = Id[f[b]][ob] ;</span><br><span class="line">add(f[b], df, -base[ob] + c) ;</span><br><span class="line">add2(b, df, -base[ob] + c) ; b = f[b] ;</span><br><span class="line">&#125;</span><br><span class="line">base[ob] = c ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。&lt;/p&gt;
&lt;p&gt;不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。&lt;/p&gt;
&lt;p&gt;接下来你需要在线处理 $m$ 次操作：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0 x k&lt;/code&gt; 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 x y&lt;/code&gt; 表示第 $x$ 个城市的价值变成了 $y$ 。&lt;/p&gt;
&lt;p&gt;为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…&lt;/p&gt;
&lt;p&gt;不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。&lt;/p&gt;
&lt;p&gt;upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。&lt;/p&gt;
    
    </summary>
    
      <category term="題解" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/"/>
    
      <category term="BOZJ" scheme="https://www.orchidany.cn/categories/%E9%A1%8C%E8%A7%A3/BOZJ/"/>
    
    
      <category term="数据结构/点分树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【題解】[bzoj4182] Shopping</title>
    <link href="https://www.orchidany.cn/2020/04/09/shopping/"/>
    <id>https://www.orchidany.cn/2020/04/09/shopping/</id>
    <published>2020-04-09T01:01:10.000Z</published>
    <updated>2020-04-09T13:04:42.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。</p><p>第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。</p><p>这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？</p><p>对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。</p></blockquote><a id="more"></a><p>然後大概是整理過的題目，但個人感覺還是有必要再整理一遍的。</p><p>題意大概是說，在樹上做背包，但是不允許選不連通的點。据说是经典套路题，但我不是很会…</p><p>先考慮比較簡單的 $01$ 背包。考慮一般這種情況需要記錄一下每個點用沒用，所以比較直接的想法是枚舉每個點當根，然後求一個以該點為根時的連通塊出來。但問題就在於合併子樹的複雜度是 $O(V^2)$ （個人覺得存在某種方式的 $V\log V$ 合併，畢竟形式上十分的NTT）。但這樣就是 $n^2V^2$ 的了，所以考慮一個比較經典的優化，在 $dfs$ 序上做，記錄一下每個點子樹內 $dfs$ 序的最大值 $r_i$ 。定義 $f_{i,v}$ 表示 $i\sim n$ 都被考慮完了，代價為 $v$ 時的結果。轉移的話，如果選 $i$ 就從 $i+1$ 來轉移，不選 $i$ 那麼整棵子樹都不能選，從 $r_i+1$ 轉移。 </p><p>然後如果是多重背包的話，套一個單調隊列就可以做到 $n^2V$ 了，但是實際上這題很水，直接 $O(nV\max\{c_i\})$ 的多重背包也沒有問題。然後就是在寫多重背包的時候，發現了很弱智的一點，就是『物品個數』和『體積』哪一個先枚舉的問題…</p><p>顯然的是應該先枚舉體積，否則同一層的狀態會互相嵌套。所以應該這麼寫：</p><p><img src="1.png" alt></p><p>但是還有另一種寫法，用到了『狀態堆疊』這個 trick，雖然複雜度不變但是看起來更帥一點</p><p><img src="2.jpg" alt></p><p>然後考慮如何消掉一個 $n$ ，發現這個 $dp$ 很符合點分治的特點，每次將分治中心作為根，那麼選了根就是經過分治中心，不經過跟就是沒經過分治中心。於是最後的複雜度是 $nV\max\{c_i\}\log n $ 。</p><p>然後就是單調隊列優化多重背包，感覺這個東西很玄妙，十分深刻<del>（被 uoj 群友提醒之後發現似乎不是很深刻，只是自己做題少）</del>：</p><p>考虑原本的转移</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p><p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p><script type="math/tex; mode=display">f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知對於一個相同的 $i$，不同的 $j$ ，轉移區間的左端點是不降的，于是就对每个 $d$ 用单调队列即可。</p><p>仔細想了想，大概是這麼一個思考過程：觀察上面那個式子可以知道，每次枚舉的會是一些 $w_i$ 的倍數，那麼對於任意一個 $j$ ，轉移路徑裡最初的轉移點就一定在 $0\sim w_i-1$ 中進行，注意到這一點之後自然考慮對於每一個 $d$ 分別做。那麼可以發現，對於每個 $d$ 而言，$d+k<em>w$ 的轉移點都是固定的，比如 $d+7</em>w$ 就只能從 $d+w,d+2\cdot w,\cdots ,d+6*w$ 來轉移，同時由於數量 $c_i$ 的限制，可以知道對於每個 $j$ 只能從 $\geq \lfloor\frac{j}{w_i}\rfloor-c_i$ 的其它 $j$ 來轉移，就變成了一個區間彼此不包含的轉移問題，顯然可以用單調隊列來優化。</p><p>然後最後複雜度就變成了 $O(nV\log n )$ 。</p><p>感覺這個單調隊列的實現有億點細節，可能需要再琢磨一下。</p><hr><p>思考了一下，順便去問了 zay，發現這個轉移有點東西：</p><p>1、由於轉移時是要從 $i-1$ 的狀態轉移，一開始初始賦值完畢之後 $i$ 就是 $i-1$ 的狀態了。那麼每次入隊的時候要保證把 $i-1,j$ 入隊而不是 $i,j$ 。所以入隊的時候要是轉移前的結果。</p><p>2、注意到單調隊列有個問題，就是兩個端點『左閉右閉』和『左閉右開』。左閉右閉的時候需要注意判斷 <code>while (h &lt;= t)</code>，因為當 $h=t$ 的時候還會有元素在隊伍當中。</p><p>3、很 sb 的一點，就是手寫隊列，如果不能保證每次 $dp$ 前隊列都是空的，那麼轉移的時候就需要判斷是否為空，不然會從不合法的狀態點轉移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[t] &lt;= o) q[t --] = <span class="number">0</span> ; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">if</span> (h &lt;= t) dp[j * w[x] + d] = q[h] + v[x] * j ;<span class="comment">//3 </span></span><br><span class="line">q[++ t] = o ; q2[t] = j ; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感覺自己真的沒怎麼寫過單調隊列，同時也對單調隊列理解的不是很好的樣子。</p><p>總代碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> u[N] ;</span><br><span class="line"><span class="keyword">int</span> v[N] ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> q[V] ;</span><br><span class="line"><span class="keyword">int</span> q2[V] ;</span><br><span class="line"><span class="keyword">int</span> rg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][V] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to ;</span><br><span class="line"><span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">to(++ cnt) = b ;</span><br><span class="line">next(cnt) = head[a] ;</span><br><span class="line">head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line"><span class="keyword">int</span> grt ;</span><br><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a = b &lt;= a ? a : b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">dfs(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chk(g[x], num - size[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">findCG :: size[x] = <span class="number">1</span> ;</span><br><span class="line">dfn[x] = ++ id ; rev[id] = x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">dfs(to(k), x), findCG :: size[x] += findCG :: size[to(k)] ;</span><br><span class="line">rg[x] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line"><span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">h = <span class="number">1</span> ; t = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">o = dp[j * w[x] + d] - v[x] * j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; q[t - <span class="number">1</span>] &lt;= o) q[t --] = <span class="number">0</span> ;</span><br><span class="line">q[t] = o ; q2[t ++] = j ;</span><br><span class="line"><span class="keyword">while</span> (h &lt; t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;</span><br><span class="line">dp[j * w[x] + d] = max(dp[j * w[x] + d], q[h] + v[x] * j) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span> ;</span><br><span class="line">id = <span class="number">0</span> ; dfs(x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= id + <span class="number">1</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j) f[i][j] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = id ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line"><span class="keyword">int</span> ii = rev[i] ;</span><br><span class="line"><span class="comment">//if(x == 2) cout &lt;&lt; w[ii] &lt;&lt; " " &lt;&lt; v[ii] &lt;&lt; " " &lt;&lt; ii &lt;&lt; " " &lt;&lt; rg[ii] + 1 &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= w[ii] ; -- j) f[i][j] = f[i + <span class="number">1</span>][j - w[ii]] + v[ii] ;</span><br><span class="line">calc(f[i], ii) ; <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j) f[i][j] = max(f[i][j], f[rg[ii] + <span class="number">1</span>][j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; f[1][m] &lt;&lt; endl ;</span></span><br><span class="line">ans = max(f[<span class="number">1</span>][m], ans) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">findCG :: reset() ;</span><br><span class="line">findCG :: num = findCG :: size[to(k)] ;</span><br><span class="line">findCG :: dfs(to(k), <span class="number">0</span>) ; solve(findCG :: grt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line"><span class="keyword">int</span> a, b ; findCG :: num = n ;</span><br><span class="line">fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">fill(head, head + n + <span class="number">1</span>, ans = cnt = <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; w[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; u[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b, add(a, b), add(b, a) ;</span><br><span class="line">findCG :: reset() ; findCG :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">solve(findCG :: grt) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最終被 zay 的二進制分組吊著錘，感覺很不爽 QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。&lt;/p&gt;
&lt;p&gt;第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。&lt;/p&gt;
&lt;p&gt;这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？&lt;/p&gt;
&lt;p&gt;对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="动态规划/单调队列" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="动态规划/背包模型" scheme="https://www.orchidany.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据结构/数据结构方法/点分治" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】分块&amp;莫队&amp;根号分治</title>
    <link href="https://www.orchidany.cn/2020/04/08/%E5%88%86%E5%9D%97%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/04/08/分块听课笔记/</id>
    <published>2020-04-08T03:49:07.000Z</published>
    <updated>2020-04-14T04:39:05.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…</p><p>话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…</p><p>日常不想写数据结构(1/1) 。</p><p>然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭</p><a id="more"></a><p>不做說明的話，全部數據的 $n,m$ 都是 $10^5$ 的。块大小记作 $B$ .</p><h1 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>维护一个序列，支持</p><p>1.区间加。</p><p>2.查询区间小于 $x$ 的数个数。</p></blockquote><p>对于询问操作而言，可以发现区间加不影响块内部的顺序，所以考虑对于每个块维护块内元素排完序之后的结果，存在一个容器里，记为 $ov_x$ 。</p><p>对于修改操作，整块就直接打一个 $tag_x$ ，零散块由于至多有两块受影响，于是考虑暴力重构。暴力重构的方法大概是按顺序将 $ov_x$ 里那些要被加的元素取出，可以知道这样 $ov_x$ 和被取出的那些元素就都是有序的了，可以归并排序做到线性。所以修改复杂度是 $O(B)+O(\frac{n}{B})$ 的。</p><p>查询操作，零散块当然是暴力 for​ ，整块的话可以二分，查询复杂度 $O(B)+O(\frac{n}{B}\log B)$ 。发现如果令 $B = \sqrt{n\log B}$ ，那么总复杂度会变成 $O(m\sqrt{n\log B})$ ，可能会更优。</p><p>同时也可以把询问对于每一块都离线下来，对于每个块，在每次重构之前可以回答上一次重构之后的问题，用基数排序把这些询问排序之后，和块内元素一起归并可以做到线性。于是就可以离线 $O(m\sqrt n)$ 了。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>维护一个序列，支持查询</p><p>1.区间加</p><p>2.查询区间k小</p></blockquote><p>考虑和上一道题一样的做法，每次外层套一个二分，那么就是查询每个块内 $&lt;x$ 的数的个数，这样还需要再二分，询问复杂度变成了 $O(\frac{n}{B}\log B\log V)$ ，平衡之后就是 $O(\sqrt{n\log B}\log V)$。</p><p>……然而 lxl 出的 YNOI 把这个 Sol 给卡了。</p><p>考虑一个 $trick$ ，就是调整块的大小。令 $B=\sqrt n \log n$ ，那么每次修改显然还是 $O(B)&gt;O(\frac{n}{B})$ 的，查询还是用二分，但是由于整块的数量下降到了 $O(\frac{n}{\sqrt n \log n})=O(\frac{\sqrt n}{\log n})$ ，那么这部分复杂度就变成了 $O(\sqrt n\log n)$ 。看上去很不错？但是零散块查询的时候，由于有 $O(\sqrt  n\log n)$ 的零散点，所以如果暴力二分就又变成俩 $\log $ 了。不过显然这些零散点是可以归并的，于是这部分的复杂度就变成了 $O(\sqrt n\log n+\log n)$ 。</p><p>最终总复杂度 $O(m\sqrt n\log n)$ 。</p><h1 id="根号平衡"><a href="#根号平衡" class="headerlink" title="根号平衡"></a>根号平衡</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><blockquote><p>维护序列，要求 $O(1)$ 修改， $O(\sqrt n)$ 求区间和。</p></blockquote><p>似乎就是最水的分块题。考虑分块维护块内和，修改的时候 $O(1)$ 修改点值和块值，询问就是朴素询问即可。</p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><blockquote><p> 维护序列，要求 $O(\sqrt n)$  修改， $O(1)$ 求区间和。</p></blockquote><p>这个比较有意思。发现要求 $O(1)$ 求区间和，那自然就是要维护前缀和。于是就分别维护块的前缀和 and 块内部的前缀和，每次修改就是要修改之后的块的前缀和 and 散点所在块内部的前缀和，查询作差即可。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>维护序列，要求 $O(\sqrt n)$ 区间加，$O(1)$ 询问单点。</p></blockquote><p>改成维护差分就变成 B 的内容了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>维护序列，要求 $O(1)$ 区间加，$O(\sqrt n)$ 询问单点。</p></blockquote><p>维护差分，就变成 A 了…这一波，这一波整理顺序没有决策单调性（雾）。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>维护一个集合，支持 $O(1)$ 插入一个数，$O(\sqrt n)$ 查询 $k$ 小。</p></blockquote><p>大概就是考虑值域分块。考虑把所有数字离散化之后是 $1\sim m$ ，然后按照值域分块，对于每个块记录一下这段值域出现了多少个数，每个位置出现了多少个数。插入就是在对应位置 $+1$，这个块 $+1$，询问就是 forforfor。</p><p>似乎有个小问题，就是如果值域 $1e9$ 可能要多一个二分的 log。如果不强制在线可以把询问一起离散化，但是如果强制在线可能就必须要二分了。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>维护一个集合，支持 $O(\sqrt n)$ 插入一个数，$O(1)$ 查询 $k$ 小。</p></blockquote><p>还是按值域分块。同时维护每个块的 $ov$。</p><p>那么如果要插入一个数，那么那个块本身需要重构，然后对于这之后的所有数都需要后移一位，相当于每次每个块头部删一个元素，尾部加入一个元素。查询的时候直接定位到那个块即可。</p><p>实现方面，每个块的 $ov$ 拿一个支持双端删插的容器即可。这题的关键点就在于要保证前 $k$ 个块的大小可以快速查询，那么令每个块的大小相同就是不错的选择。</p><h2 id="CodeChef-Chef-and-Churu"><a href="#CodeChef-Chef-and-Churu" class="headerlink" title="[CodeChef] Chef and Churu"></a>[CodeChef] Chef and Churu</h2><blockquote><p>给 $n$ 个数，给定 $m$ 个函数，每个函数为序列中第 $l_i$ 到第 $r_i$ 个数的和。有 $q$ 个询问，两种类型的操作：</p><p><code>1 x y</code> 把序列中的第 $x$ 个数改为 $y$ 。</p><p><code>2 x y</code> 求第 $x$ 个函数到第 $y$ 个函数的和。</p></blockquote><p>一眼感觉是什么 CDQ 🐂🍺题.jpg</p><p>草，知道正解的我眼淚掉下來，感覺好神仙啊。大概就是考虑这些函数都是静态的，所以可以对函数分块，然后维护前 $i$ 个函数里面，序列上每个元素要被算多少次，并且维护前缀函数的答案和。那么每次修改只需要 $\frac{n}{B}$ 地修改每个前缀和即可。询问的时候，整块就是直接拿前缀和作差，对于散点而言，考虑至多是 $O(B)$ 次查询，每次查询本质上是对序列上一个区间的查询。所以用那个 $O(\sqrt n)$ 单点修改 $O(1)$ 查询区间和的方式，即 B 中的技巧就好了。</p><p>最终复杂度 $O(m\sqrt n)$ 。 </p><h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h2 id="AHOI2013-作业"><a href="#AHOI2013-作业" class="headerlink" title="[AHOI2013]作业"></a>[AHOI2013]作业</h2><blockquote><p>查询区间 $[l,r]$ 中值在 $[a,b]$ 内的不同数个数</p><p>$n \leq 10^5 , m \leq 10^5$</p></blockquote><p>考虑直接莫队的话，需要支持查询某个值域中的数，需要上树状数组，但这样带 $\log$ 。</p><p>于是考虑一下莫队的本质，即莫队的复杂度分析，本质上分析的是 $l,r$ 移动的复杂度，也就是修改的复杂度。所以莫队可以本质上看成一个 $O(n\sqrt m)$ 修改，$O(m)$ 询问的数据结构，也就是可以用一个可以快速修改，低速查询的 ds 来维护值域，那这自然就是值域分块，最终复杂度 $O(n\sqrt m+m\sqrt n)$ 。</p><p>然后本题需要分别维护出现次数和是否出现，分别维护即可。</p><p>不过话说回来，这东西本质上等价于查询 $pre_x&lt;l,pos_x\in[l,r],x\in[a,b]$ 的这样的 $x$ 的个数。那么这就是一个三维数点，CDQ 套树状数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> sumr[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; </span><br><span class="line"><span class="keyword">int</span> l, r ; </span><br><span class="line"><span class="keyword">int</span> a, b ; </span><br><span class="line">&#125;q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] -- ; </span><br><span class="line">sumr[blv[base[p]]] -- ;</span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">0</span>) -- sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">sump[base[p]] ++ ; </span><br><span class="line">sumr[blv[base[p]]] ++ ; </span><br><span class="line"><span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">1</span>) ++ sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += (<span class="keyword">bool</span>)sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sum[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_res</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">r = min(r, V) ; </span><br><span class="line"><span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">ret += sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sumr[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += sump[i] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), V = max(V, base[i]), bl[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].a, &amp;q[i].b), q[i].id = i ; </span><br><span class="line">sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> a = q[i].a, b = q[i].b ; </span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">res[q[i].id] = get_res(a, b) ;</span><br><span class="line">ans[q[i].id] = get_ans(a, b) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h2><blockquote><p>給定序列，定义 $v_x$ 为 $x$ 在区间 $[l,r]$ 中的出现次数，查询一个区间中最大的 $x\times v_x$ 。</p></blockquote><p>發現就是莫隊，然後要求查詢某個數的出現次數，跟上面『作業』那個題一樣，直接對值域分塊就好了。</p><p>預處理起來似乎也不是很難的樣子，對每個 $k\times x~(k=1,2,3,\cdots,cnt_x)$ 放到一起離散化就好了。 于是最后复杂度是 $O(n\sqrt m+m\sqrt n)$ 。因为滥用 <code>vector</code> 以及 cache 十分不友好导致慢的一匹，用了 zay 的快读也毛用没有/dk。</p><p>实现细节：</p><p>1、按照平常莫队的写法，如果先 <code>del</code> 再 <code>add</code> 会出现某些数出现了负数次，解决方法比较简单，判一下就好了。</p><p>2、十分神必的一点，一开始我把对每个点标号放到了对询问排序的后面，所以 T 了半天，并且自己以为是缓冲区溢出的锅…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector <span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mint map <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minttoll map <span class="meta-string">&lt;int, ll&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qr(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qr;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> L ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line">ll res ;</span><br><span class="line">ll t[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line"><span class="keyword">int</span> vl[N] ; </span><br><span class="line"><span class="keyword">int</span> vr[N] ; </span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ; </span><br><span class="line"><span class="keyword">int</span> blv[N] ; </span><br><span class="line"><span class="keyword">int</span> sumb[N] ; </span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line">minttoll su ;</span><br><span class="line">mint bu, vu ;</span><br><span class="line">vint base[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id ; </span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;  </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[tmp[p]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">++ buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line"><span class="keyword">int</span> val = base[tmp[p]][++ buc[tmp[p]]] ; </span><br><span class="line"><span class="comment">//cout &lt;&lt; val &lt;&lt; " " &lt;&lt; lval &lt;&lt; endl ; </span></span><br><span class="line">sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[tmp[p]] &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">-- buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (buc[tmp[p]] + 1 &gt;= base[tmp[p]].size()) cout &lt;&lt; base &lt;&lt;buc[tmp[p]] &lt;&lt; " " &lt;&lt; p &lt;&lt; ' ' &lt;&lt; tmp[p] &lt;&lt;'\n', exit(0) ; </span></span><br><span class="line"><span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line"><span class="keyword">int</span> val = base[tmp[p]][-- buc[tmp[p]]] ; </span><br><span class="line">sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ob = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = blv[V] ; b &gt;= <span class="number">0</span> ; -- b)</span><br><span class="line"><span class="keyword">if</span> (sumb[b] &gt; <span class="number">0</span>) &#123; ob = b ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span> (!ob) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = vr[ob] ; p &gt;= vl[ob] ; -- p) <span class="keyword">if</span> (sump[p]) <span class="keyword">return</span> p ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ; qr(m) ; B = n / <span class="built_in">sqrt</span>(m) ;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) qr(g[i]) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">bu[g[i]] ++, t[++ cnt] = <span class="number">1l</span>l * g[i] * bu[g[i]] ;</span><br><span class="line"><span class="comment">//debug(t, 1, cnt, ' ', '\n') ;</span></span><br><span class="line">sort(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>) ; bu.clear() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">bl[i] = i / B ; bu[g[i]] ++ ; <span class="keyword">int</span> w ; </span><br><span class="line">w = upb(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>, <span class="number">1l</span>l * g[i] * bu[g[i]]) - t - <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; w &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="keyword">if</span> (bu[g[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">base[w].push_back(<span class="number">0</span>) ; </span><br><span class="line">base[w].push_back(w) ; vu[g[i]] = w ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> base[vu[g[i]]].push_back(w) ; V = max(V, w) ;  </span><br><span class="line">su[w] = <span class="number">1l</span>l * g[i] * bu[g[i]] ; t[w] ++ ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(q[i].l), qr(q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) tmp[i] = vu[g[i]] ;</span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) if(buc[tmp[i]]) return 0 ; else buc[tmp[i]] ++ ; </span></span><br><span class="line"><span class="comment">/*for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; tmp[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">debug(base[tmp[i]], 0, base[tmp[i]].size() - 1, ' ', '\n') ;</span></span><br><span class="line"><span class="comment">&#125;return 0 ; */</span></span><br><span class="line"><span class="comment">//debug(tmp, 1, n, ' ', '\n') ;</span></span><br><span class="line">B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= V ; ++ i)&#123;</span><br><span class="line">blv[i] = i / B + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (blv[i] != blv[i - <span class="number">1</span>])</span><br><span class="line">vr[blv[i - <span class="number">1</span>]] = i - <span class="number">1</span>, vl[blv[i]] = i ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; vr[blv[V]] = V ;</span><br><span class="line"><span class="comment">//debug(blv, 1, V, ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//debug(vl, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//debug(vr, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//while (l &lt;= n) add(l ++) ;// cout &lt;&lt; l &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line"><span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line"><span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">ans[q[i].id] = su[ ask() ] ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qw(ans[i], <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SNOI2017-一个简单的询问"><a href="#SNOI2017-一个简单的询问" class="headerlink" title="[SNOI2017] 一个简单的询问"></a>[SNOI2017] 一个简单的询问</h2><blockquote><p>给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出</p><script type="math/tex; mode=display">\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)</script><p>$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。</p></blockquote><p>首先可以發現這東西就是在求 $\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]$ 。由於是 $\sum $ 的形式，那麼自然可以拆成四個詢問，即詢問</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]\\=&\sum_{i=1}^{r_1}\sum_{j=1}^{r_2}[a_i=a_j]-\sum_{i=1}^{r_1}\sum_{j=1}^{l_2-1}[a_i=a_j]-\sum_{i=1}^{l_1-1}\sum_{j=1}^{r_2}[a_i=a_j]+\sum_{i=1}^{l_1-1}\sum_{j=1}^{l_2-1}[a_i=a_j]\end{aligned}</script><p>那麼就變成了四個雙端點詢問的問題了。注意到每多一個元素 $x$，就會多 $buc_x$ 個 <code>pair</code>，莫隊即可。</p><h2 id="Ynoi2016-这是我自己的发明"><a href="#Ynoi2016-这是我自己的发明" class="headerlink" title="[Ynoi2016]这是我自己的发明"></a>[Ynoi2016]这是我自己的发明</h2><blockquote><p>给一个树，$n$ 个点，有点权，初始根是 $1$ 。$m$ 个操作，每次操作：</p><ol><li>将树根换为 $x$ 。</li><li>给出两个点 $x$，$y$，从 $x$ 的子树中选一个点，$y$ 的子树中选一个点，如果两个点点权相等，<code>ans++</code>，求 ans。</li></ol><p>$n\leq 10^5,m\leq 5\times 10^5$。</p></blockquote><p>發現…似乎本質上就是上面那個題。因為換根這個地方，對於某個點至多有兩種可能，就是子樹內的點為根、子樹外的點為根和自己為根。然後就可以一開始先按照操作，把所有詢問轉化成以 $1$ 為根，$dfs$ 序上的操作。然後大概就和上一道題一樣了。</p><p>需要注意的是，如果是遇到子樹內的點作為根，那麼本身就要兩個詢問，一個詢問全局的，一個減去這個子樹的，注意到詢問全局的並不需要拆，所以一個詢問最多會被拆分成 $(2+1)\times (2+1)=9$ 個詢問，最後 $m$ 可以到 $5\times 10^6$ 左右。雖然莫隊的複雜度可以接受 $m$ 比較大，但是一開始排序的 $m\log m$ 就會很慢。所以可以用基數排序來實現這個過程。</p><h2 id="BZOJ3920-Yunna-的禮物"><a href="#BZOJ3920-Yunna-的禮物" class="headerlink" title="[BZOJ3920] Yunna 的禮物"></a>[BZOJ3920] Yunna 的禮物</h2><blockquote><p>給定序列，每次查询区间中出现次数 $k_1$ 小的数里面的 $k_2$ 小的数。</p></blockquote><p>靠，一開始沒看見『區間』這個限制，還很好奇為什麼要上莫隊…老了老了。</p><p>看了半天題解才大概看明白，似乎是個什麼分塊套分塊的操作。大概就是對於『出現次數』的出現次數開一個桶，然後拿值域分塊來維護這個東西，但是對於每個『次數』還是需要查詢第 $k_2$ 小的數，於是就對於這個塊內的每個『次數』，外面再套一層值域分塊來維護一個固定次數處的數的排序。</p><p>這樣插入就是 $O(1)+O(1)$ ，查詢就是 $O(\sqrt n) +O(\sqrt n)$ 。看上去很棒，但是空間上會被卡…</p><p>這個地方我就很不理解…不知道為啥會被卡…不過那個什麼『分段離散化』的 trick 大概是预处理出对于某一种出现次数，所有可能的数，再将其离散化，对于离散化后的数再來值域分塊维护。這樣複雜度就是線性了。大概是什麼 vector 保存某個數出現 $k$ 次之後的新權值？大概過程就和其他博客講的，如果某個數的總出現次數 $cnt_x&gt;i$ ，那麼就要用 $x$ 預處理 $i$ ，這是顯然的。</p><p>似乎空間被卡的原因是值域分塊的 size 要預先確定，所以不二次離散化，複雜度就會是 $n^2$ 的了。</p><h1 id="根号分治"><a href="#根号分治" class="headerlink" title="根号分治"></a>根号分治</h1><h2 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h2><blockquote><p>给个图</p><ol><li>把 $x$ 点权加 $y$ 。</li></ol><p>2.查询 $x$ 相邻的点权和。</p></blockquote><p>经 典 套 路 . 总结一下的话，大概就是「小的直接做，大的打标记」这么一个套路。</p><p>具体一点，每个点维护一下询问的 $ans$，对每个点展开关于度数的根号分治，$&lt;\sqrt m$ 的点直接加，$&gt;\sqrt m$ 的点打标记。每次询问到一个点 $x$，由于 $\deg &gt; \sqrt m$ 的点不超过 $\sqrt m$ 个，所以可以直接 $for$ 过去判断是否与 $x$ 相邻。</p><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><blockquote><p>规定序列 $a_n$，每次给定 $x$ 和 $y$ ：</p><p>查询一个区间中最小的 $|i-j|$，使得 $a_i=x,a_j=y$。</p></blockquote><p>有趣的题。</p><p>考虑对于每种颜色按照出现次数分治。某个颜色 $x$ 的出现次数记作 $cnt_x$。对于 $cnt_x\leq \sqrt n$ 的可以预处理所有位置，这一部分时 $O(n)$ 空 $O(n\sqrt n)$ ，对于 $cnt_x&gt;\sqrt n$  的可以预处理到所有颜色的最小距离（由于是最小距离所以可以忽略区间长度的限制），这部分时 $O(n\sqrt n)$ 空 $O(n \sqrt n)$ 。</p><p>考虑询问 $(x,y)$，如果至少一个颜色的 $cnt&gt;\sqrt n$ 那么就可以直接做，否则考虑由于两个颜色的位置都已知且数量 $&lt;\sqrt n$，所以按顺序拿出来，对这两个序列归并一下就做完了，复杂度 $O(m\sqrt n+n\sqrt n)$ 。</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><blockquote><p>[Ynoi2015]いまこの時の輝きを</p><p>查询一个区间乘积的约数个数。</p><p>值域 $v\leq 10^9$。</p></blockquote><p>考虑 $\tau(x)=\prod (a_x+1)$ ， 同时对于某个 $v$ ，素因数个数是 $\frac{\log v}{\log \log v}$ 的，所以如果暴力莫队转移的话，每次转移的复杂度是 $O(\frac{\log v}{\log \log v})$，这样最后复杂度是 $O(nv^{\frac{1}{4}}+n\sqrt m\frac{\log v}{\log \log v})$，不过被 lxl 给卡掉了。</p><p>考虑一个神奇的根号分治。对于每个数 $v$ 而言， $&gt;\sqrt[3]v$ 的素因子至多只会有两个，在 $v=10^9$ 时，$&lt;10^3$ 的素数也只有 $168$ 个。所以可以暴力转移这些大素数的贡献，这样转移就是 $O(1)$ 的；然后对于每次询问，只需要再暴力统计小素数的贡献即可。最终复杂度 $O(nv^{\frac{1}{4}}+m\frac{3\cdot v^{\frac{1}{3}}}{\ln v}+n\sqrt m)$ 。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><blockquote><p>POI2015 Odwiedziny</p><p>树，点权，多次查询，每次给 <code>x,y,k</code>。</p><p>求从 $x$ 开始，每次跳过 $k$ 个节点跳到 $y$ 所经过节点的和。</p></blockquote><p>还是根号分治。考虑对于 $k\leq \sqrt n$ ，可以预处理出 $k=1,2,3\cdots \sqrt n$ 然后每次暴力向上跳，对于 $k&gt;\sqrt n$ ，至多需要跳 $\sqrt n$ 次，那么可以倍增求出 k 级祖先做到 $O(m\sqrt n\log n)$ ，或者长剖做到 $O(m\sqrt n)$ 。当然也可以轻重链剖，维护每条重链上深度从大到小的点的序列，这样单次复杂度就是 $O(\log k+\frac{n}{k})$ 了。</p><p>还有一种 zz 做法，记录每个点的 $1,2,3\cdots\sqrt n,2\sqrt n,3\sqrt n$ 级祖先，这样也是 $n\sqrt n + m\sqrt n$ 的了。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><blockquote><p>Bzoj4320 ShangHai2006 Homework</p><p>1.在人物集合 S 中加入一个 X，保证 X 在当前集合中不存在。</p><p>2.在当前的人物集合中询问所有X mod Y 最小的值</p><p>值域 $&lt;300000$ 。 </p></blockquote><p>考虑对于 $&lt;\sqrt V$ 的所有 Y ，令 $f_k$ 表示 Y = $k$ 时的答案，每次修改可以暴力维护所有 $f$，查询时 $O(1)$ 。这一部分复杂度为 $m\sqrt V$。</p><p>考虑对于 $&gt;\sqrt V$ 的所有 Y，发现 $V$ 以内至多有 $\sqrt V$ 个 Y 的倍数，那么每次查询相当于在两个相邻的 Y 的倍数之间查询区间最小值。注意到这样最多有 $m\sqrt V$ 次查询，$m$ 次修改，所以根号平衡一下，拿一个值域分块来维护即可。</p><p>总复杂度 $O(m\sqrt V)$ 。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>lxl 的课件确实都是比较有意思的题目，也确实开了眼界。</p><p>想继续学啊…可惜实力不允许啊…</p><p>不知道退役之前能不能完整地把这个课件看一遍了233</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…&lt;/p&gt;
&lt;p&gt;话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…&lt;/p&gt;
&lt;p&gt;日常不想写数据结构(1/1) 。&lt;/p&gt;
&lt;p&gt;然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构/数据结构方法/莫队" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E8%8E%AB%E9%98%9F/"/>
    
      <category term="技巧/根号分治" scheme="https://www.orchidany.cn/tags/%E6%8A%80%E5%B7%A7-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
    
      <category term="数据结构/数据结构方法/分块" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】点分治/点分树相关</title>
    <link href="https://www.orchidany.cn/2020/04/03/%E5%88%86%E6%B2%BB%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://www.orchidany.cn/2020/04/03/分治听课笔记-1/</id>
    <published>2020-04-03T02:50:31.000Z</published>
    <updated>2020-04-09T01:42:55.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>似乎主要是点分治的相关内容？</p><a id="more"></a><h1 id="简单的前言"><a href="#简单的前言" class="headerlink" title="简单的前言"></a>简单的前言</h1><p>首先对于树的点分治所要解决的问题和普通分治一样，只需要统计经过分治中心的信息，假设对于 $k$ 个点而言，统计经过分治中心的信息复杂度是 $O(\gamma(k))$ 的，那么最后的总复杂度就是 $\gamma(n)\log n $ 。</p><p>对于树的边分治而言，遇到菊花就会崩掉。于是考虑对每个点进行<strong>三度化</strong> ，意即建立虚点使得每个点的度数都不超过 $3$ （二度化之后要么是链要么是环）。这样最终的 $size=k$ 的一层至多会分成一个  $size=\frac{1}{3}k$ 的和一个 $size=\frac{2}{3}k$ 的，可以知道如果度数 $\leq 3$ ，这就是能做到的最佳上界。于是最后的复杂度大概是 $\gamma(k)\log _{\frac{3}{2}}k$ 。</p><p>嗯，可能边分治就只用来分析个复杂度，好像几乎没人用的样子。不过也有个好处吧，就是不用考虑可能存在的分治中心的边界问题。</p><h1 id="常见点分治"><a href="#常见点分治" class="headerlink" title="常见点分治"></a>常见点分治</h1><h2 id="比较常见的数据结构"><a href="#比较常见的数据结构" class="headerlink" title="比较常见的数据结构"></a>比较常见的数据结构</h2><p>一般这个东西都比较显然…就题论题吧。</p><h2 id="如果信息可以容斥"><a href="#如果信息可以容斥" class="headerlink" title="如果信息可以容斥"></a>如果信息可以容斥</h2><p>这一类比较常见的是统计满足某个有可减性的点对数，比如统计路径长度/点权和 $&lt;k$ 的路径。常规的容斥做法是考虑对于每一层，计算出所有可能的点对，并且减去那些 <code>belong(x)=belong(y)</code> 的点对 $(x,y)$ 。</p><h2 id="类哈夫曼树合并"><a href="#类哈夫曼树合并" class="headerlink" title="类哈夫曼树合并"></a>类哈夫曼树合并</h2><p>每次选择两个size最小的子树进行合并，这样最后合并的总复杂度摊下来也是 $n \log n$ 的。这个主要用于那些不容易插入删除但是容易合并/重构的信息统计。注意到必须是从小合并到大，这样每次已合并的两个集合 $size$ 至少是较小的那个的两倍，所以每个点至多合并 $\log n$ 次……</p><p>以上复杂度分析似乎很有问题。我也不知道该怎么去定量分析这个问题。</p><p>不过uoj群给了一种很妙的证法。就是考虑每次选两个最小的合并一定可以达到复杂度的下界，因为对于一个合并顺序 $a&lt;b&lt;c$，<code>merge(a,b)</code> 再 <code>merge(b,c)</code> 的复杂度是 $O(2(a+b)+c)$ ，改变合并顺序，<code>merge(a,c)</code> 再 <code>merge(b,c)</code>的 复杂度是 $O(2(a+c)+b)$，也就是改变这个顺序至少不会更优。所以如果想要证明这种合并方式优于某个复杂度，那么只需要随便构造一个这种复杂度的合并方式即可。</p><p>那么问题转化到了如何构造一种 $n\log n$ 的合并。发现如果每次分成差不多大小的两堆，那么复杂度的递推式就是</p><script type="math/tex; mode=display">T(n)=T(pn)+T(qn) + O(n)\quad (p+q=1,0<p,q<1)</script><p>但是这种分析的方式存在一定的问题，就是单纯这么写很容易构造出 $O(n)$ 层，但是 $O(n)$ 层是不符合「每次分成差不多两堆递归」这种情况的。</p><p>然后 uoj (没错我啥都不会只能到处问)里的神仙定量分析了一波，感觉十分有道理。大概就是考虑如果存在某个物品的大小 $\geq \frac{1}{3}$，那么直接把这个物品单独拿出来分成一部分，剩下的分成一部分；否则如果全部的物品的 $size$ 都 $&lt;\frac{1}{3}$ ，那么必定可以分出一堆 $\frac{n}{3}\leq size&lt;\frac{2n}{3}$ 的物品，原因在于这种情况下至少有 $&gt;3$ 种物品，那么如果物品再多的话，只能是类似于把之前的某个物品拆分(总体积不变且每个物品至多大小为 $\frac{1}{3}$)。而在三个物品的时候，是一定可以划分出 $\frac{n}{3}$ 来的，并且物品数如果增多，那么由于体积减小一定可以让划分更平均。所以上界是</p><script type="math/tex; mode=display">T(n)=T(\frac{1}{3}n)+T(\frac{2}{3}n)+O(n)</script><p>算出来复杂度就是 $O(n\log_{\frac{3}{2}} n)$ 。</p><p>嗯，但是这样似乎并不能证明随机选两堆合并的复杂度…那就期望 log 吧！</p><h1 id="一堆题"><a href="#一堆题" class="headerlink" title="一堆题"></a>一堆题</h1><h2 id="限制距离的点对数"><a href="#限制距离的点对数" class="headerlink" title="限制距离的点对数"></a>限制距离的点对数</h2><blockquote><p>求距离不超过 $k$ 的点对数。</p></blockquote><p>注意到可以用点分治，分治的时候只需要考虑经过分治中心的路径，这就显然是枚举每棵子树，套一个树状数组就做完了。直接合并似乎不是很简单。所以还是一个点一个点地插入写起来比较简单一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">size[x] = g[x] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">make_root(to(k), x) ;</span><br><span class="line">size[x] += size[to(k)] ;</span><br><span class="line">g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line">chkmax(g[x], num - g[x]) ;</span><br><span class="line"><span class="keyword">if</span> (g[x] &lt; g[rt]) rt = x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (fa == rt)</span><br><span class="line">son[++ cnt] = x, lst[x] = v ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])</span><br><span class="line">dfs(to(k), x, val(k)), size[x] += size[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; (-x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt;= k ; x += low(x)) buc[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; k) <span class="keyword">return</span> ; d[++ tot] = dx ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">cnt = <span class="number">0</span> ;</span><br><span class="line">vis[root] = <span class="number">1</span> ; tot = <span class="number">0</span> ;</span><br><span class="line">rt = root ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; '\n' ; debug(son, 1, cnt, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> otot = tot ; calc(son[i], <span class="number">0</span>, lst[son[i]]) ;</span><br><span class="line"><span class="comment">//for (int j = otot + 1 ; j &lt;= tot ; ++ j) cout &lt;&lt; d[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) ans += (ll)ask(k - d[j]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) add(d[j], <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">ans += ask(k) ; <span class="comment">// cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) add(d[i], <span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)]) num = size[to(k)], make_root(to(k), rt), solve(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n ; g[<span class="number">0</span>] = n ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w ;</span><br><span class="line">add(u, v, w), add(v, u, w) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k ; num = n ;</span><br><span class="line">make_root(<span class="number">1</span>, <span class="number">0</span>) ; solve(rt) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没写了，感觉写起来还可以。</p><h2 id="括号序列问题"><a href="#括号序列问题" class="headerlink" title="括号序列问题"></a>括号序列问题</h2><blockquote><p> 树上每条边有一个括号，统计有多少合法的括号序列路径。</p></blockquote><p>还是直接点分，之后将从 $root$ 延伸出的链中，左括号未匹配的和右括号未匹配的个数相同的可以配对。于是就记一下当前分治中心到各个子树内每个点路径上的匹配值( <code>(</code> 贡献为1, <code>)</code> 为 -1)。然后拿个桶维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">d[++ tot] = dx ; q[tot] = x ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line"><span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) </span><br><span class="line">calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">vis[root] = <span class="number">1</span> ; </span><br><span class="line">tot = <span class="number">0</span> ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[root] ; i ; i = next(i))&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[to(i)]) <span class="keyword">continue</span> ; </span><br><span class="line"><span class="keyword">int</span> ot = tot ; calc(to(i), root, val(i)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">ans += (ll)buc[- d[j] + M / <span class="number">2</span>] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">buc[d[j] + M / <span class="number">2</span>] ++ ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line"><span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//cout &lt;&lt; d[i] &lt;&lt; " " &lt;&lt; q[i] &lt;&lt; " &amp; " &lt;&lt; endl, </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) buc[d[i] + M / <span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">num = size[to(k)] ; rt = <span class="number">0</span> ;</span><br><span class="line">make_root(to(k), rt) ; solve(rt) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径数量问题"><a href="#路径数量问题" class="headerlink" title="路径数量问题"></a>路径数量问题</h2><blockquote><p>给定一棵树，求长度分别为 $1,2,3\ldots n$ 的路径数量。</p></blockquote><p>发现可以对每个子树记一下 $buc_i$ 表示深度为 $i$ 的点的数量，发现两棵子树的 $buc$ 对答案的贡献是一个卷积的形式。那么考虑直接枚举每棵子树，计算贡献时对当前桶和前缀桶用 $\rm NTT$ 来合并即可。</p><p>值得注意的是，这东西必须要从小到大枚举每个子树进行合并，复杂度才是对的（证明就是上面那个类哈夫曼树合并的证明）</p><p>最终复杂度 $n\log ^2 n$ 。代码就不写了，就是死亡二合一罢了。</p><h2 id="树上背包问题"><a href="#树上背包问题" class="headerlink" title="树上背包问题"></a>树上背包问题</h2><blockquote><p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>连通子树</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p><p>$n\leq 5000,V\leq 3000$ </p></blockquote><p>据说是经典套路题，但我不会…</p><p>考虑强制选根怎么做。考虑直接树形dp，合并两个子树的背包复杂度是 $V^2$ 的。于是考虑换一种可以不去合并子树的 $dp$ 方式。考虑在 dfs 序上对这个东西进行dp，设一个点 $u$ 子树的范围是 $p_u\sim r_{u}$ ，那么就可以设 $f_{i,v}$ 表示考虑了 $i\sim n$ 的物品，根必选且容积为 $v$ 的最大价值。考虑转移，对于一个 $i$ 而言，如果选了他，就可以从 $i+1$ 转移，否则由于根必须被选，$i$ 不选，整棵子树都不能选，所以只能从 $r_i+1$ 转移过来。于是这样的复杂度就是 $O(nv)$ 的了。 </p><p>暴力做是 $O(n^2v)$ 的，复杂度瓶颈在于枚举根。考虑一个性质，就是如果点 $v$ 不在答案中，那么与其相邻的连通块不会互相通达，因为树上路径唯一。于是就可以考虑点分，经过/不经过根分别对应分治下去和跨过分治中心两种情况。最终复杂度 $nv\log n$ 。</p><p>在合并的时候可能有亿点细节需要去写…233</p><h1 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于点分树，有一个很优秀的性质，就是树高不超过 $\log n$ ，对于一些题目可以用这个性质进行转化。</p><blockquote><p>给定一棵无权树，单点修改，求距离 $x$ 不超过 $r$ 的点权和。</p></blockquote><p>考虑如果没有修改操作时，直接求也是不太好求的。于是考虑点分治，对于每个分治中心，预处理记录一下子树中距离 $\leq k\quad (k=1,2,3\cdots )$ 的点权和。 注意到这最多需要 $n \log n$ 的空间，拿 <code>vector</code> 实现即可。</p><p>那么对于询问而言，直接从点分树上暴跳，每跳到一个点分中心 $p$，就可以加上这个点记录的 $\leq r-(dep_p-dep_x)$ 的点权和，并且减去上一个点分中心子树内部 $\leq r-(dep_p-dep_x)$ 的点权和。由于点分树树高的限制，这个过程是 $\log n$ 的。</p><p>考虑如何修改，发现本质上修改+询问是一个单点修改，前缀查询的过程，于是就可以换用树状数组来维护，修改时只需要暴力跳即可，这样最终复杂度就是 $m\log ^2 n$ 的了。</p><h2 id="树上背包问题2"><a href="#树上背包问题2" class="headerlink" title="树上背包问题2"></a>树上背包问题2</h2><blockquote><p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>独立集</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p><p>$n\leq 100,V\leq 30000$ </p></blockquote><p>考虑一个比较 <code>general</code> 的 $dp$ ，还是跟上个题一样，直接合并背包是 $V^2$ 的，所以考虑把这棵树的 $dfs$ 序写下来，然后 $f_{i,j,s}$ 表示考虑了前 $i$ 个点，容量为 $j$ ，每个点选不选表示为集合 $s$ ，最终复杂度就是 $nv2^n$ 。</p><p>考虑如何少记一点东西，似乎需要把这个 $2^n$ 给降下来。于是考虑点分治。发现点分治的每一层，子树之间都是互不影响的，所以只需要把点分树找出来，对点分树进行树形 $dp$ ，记 $s$ 时只需要记每一层的点分中心的状态即可。这样由于点分树高是 $O(\log n)$ 的，所以最终复杂度是 $O(nv2^{\log n})=O(n^2v)$ 。</p><h2 id="ZJOI-2007-捉迷藏"><a href="#ZJOI-2007-捉迷藏" class="headerlink" title="ZJOI 2007 捉迷藏"></a>ZJOI 2007 捉迷藏</h2><blockquote><p>修改⼀个点的⿊白，求最远⿊点之间距离。</p></blockquote><p>考虑大致思路和「引入」中差不多，但是需要注意的是由于是统计最长的点对间距离，所以用边分治会好做一些。那么分治的时候还是需要按是否经过分治中心来分类。之后拿一个 multiset 来维护就好了。</p><p>嗯，除了边分不会写之外，没啥可说的。</p><p>据说还有 $1$ 个 $\log $ 的做法，那必然是鸽了。</p><h1 id="补充题目"><a href="#补充题目" class="headerlink" title="补充题目"></a>补充题目</h1><h2 id="某不知名CF题"><a href="#某不知名CF题" class="headerlink" title="某不知名CF题"></a>某不知名CF题</h2><blockquote><p>给一棵树，点、边均有权，求点 $x$，最小化 $\sum_{i=1}^{n} a_{i} \cdot \operatorname{dis}^{1.5}(i, x)$ 。  $n \leq 10^{5}$ 。</p></blockquote><p>事实上是 CF566C (雾</p><p>首先对于 $1.5$ 次方的 $\sum $，由于相加之后二阶导依旧 $&gt;0$ ，所以相加之后依旧是凸函数。那么也就是说，假设 $x$ 可以在边上随便取，那么对于一条固定的路径 $x\in(u,v)$ ， $\mathrm{dis}(x,u)^{1.5}$ 必定是一个下凸函数。</p><p>考虑在链上必然是二分，那么调整到树上就可以进行点分。考虑对于每个点分中心，都应该找可以使答案变小的那个儿子所在子树点作为下一个进行点分的连通块。考虑如何去实现判断这个过程。如果答案变小，那么一定是导数减小，于是可以求出子树中每个点对应值的导数 $df_x$，那么总体的导数就是 $\sum df_x-2\cdot df_v&lt;0$ ，$v$ 是下一个要进行点分的子树，原因是通过计算偏移量，剩余的点的 $f$ 都会变大，当前点会变小。这个求导的过程本质上是在模拟，我向每条边移动一个 $\epsilon$ 之后的结果。</p><p>于是就点分进行这个过程即可，点分是为了加速计算每个子树的 $df$ ，保证最终这一部分的计算量是 $n\log n$ 的。</p><h2 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h2><blockquote><p>给定一个有向图，每次加入一条边 $(u,v)$，或者询问有多少点对两两可达。</p></blockquote><p>考虑一个<del>深刻的</del>单调性，如果在某一时刻出现了一个SCC，把它缩起来，那么之后它也会一直被缩起来。</p><p>于是考虑整体二分，<code>solve(l,r,E)</code> 表示 $E$ 中的边会在时刻 $l\sim r$ 中被缩起来。于是每次把 $[l,mid]$ 这些边跑一个强连通分量，那么被缩起来的边递归到 <code>solve(l,mid,E1)</code> 里面，没被缩起来的边递归到 <code>solve(mid+1,r,E2)</code> 里面。同时为了让分治的复杂度是对的，每次点集大小不能跟 $n$ 有关，于是就需要每次在 <code>solve(l,mid,E1)</code> 之后把 E1里的点拿并查集给缩起来，这样才能保证 <code>solve(mid+1,r,E2)</code> 的复杂度只跟边数有关。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态点分治是不可能的，这辈子都不可能的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似乎主要是点分治的相关内容？&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构/点分树" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
      <category term="数据结构/数据结构方法/点分治" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】从剩余类到欧拉定理</title>
    <link href="https://www.orchidany.cn/2020/04/02/%E5%89%A9%E4%BD%99%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>https://www.orchidany.cn/2020/04/02/剩余类相关内容/</id>
    <published>2020-04-02T14:17:44.000Z</published>
    <updated>2020-04-02T16:49:26.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「重学4-6」系列的最后一篇文章。</p><p>感觉剩余类这部分内容，以纯数论的眼光去看待，是十分优美的。</p><p>嗯，将来自己抽代真正入门之后，可能就会多一点别的角度了吧。</p><a id="more"></a><h1 id="剩余类相关定义"><a href="#剩余类相关定义" class="headerlink" title="剩余类相关定义"></a>剩余类相关定义</h1><h2 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h2><p>定义 1.1</p><blockquote><p>记在模 $m$ 意义下，全部对 $m$ 同余的整数组成的集合，叫做 $m$ 的一个剩余类。</p></blockquote><p>那么显然对于一个固定的模 $m$，有 $m$ 个剩余类，分别同余 $0,1,2\cdots m-1$，分别记作 $\mathrm{ Z}_{m,0},\mathrm{ Z}_{m,1},\mathrm{ Z}_{m,2}\cdots,\mathrm{ Z}_{m,m-1}$ 。记所以剩余类组成的集合是 $\mathrm{ Z}_{m}$ 。</p><p>考虑定义剩余类之间的运算 $+$ 和 $\times $ ：</p><script type="math/tex; mode=display">\mathrm{ Z}_{m,a}+\mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a+b}\\\mathrm{ Z}_{m,a}\times \mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a\times b}</script><p>其中 $a+b$ 和 $a\times b$ 是在模 $m$ 意义下的数加和数乘。并且可以知道，对于全体模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m}$ 而言，$&lt;\mathrm{ Z}_{m},+,\times&gt;$ 本身是一个环。考虑如下：</p><p>1、首先 $(\mathrm{ Z}_{m},+)$ 显然是一个阿贝尔群。</p><p>2、其次 $(\mathrm{ Z}_{m},\times )$ 显然具有结合律，但是如果对于某个剩余类 $\mathrm{ Z}_{m,p}$ $(p,m)&gt;1$ ，就说明了 $\mathrm{ Z}_{m,p}$ 本身不存在逆元 ，所以可知道 $(\mathrm{ Z}_{m},\times )$ 是一个半群。</p><p>3、同时可知在 $(\mathrm{ Z}_{m},\times )$ 中，高优先级运算 $\times $ 对低优先级运算 $+$ 有分配律。</p><p>综上，$(\mathrm{ Z}_{m},+,\times )$ 是一个环。并且不难知道 $\mathrm{ Z}_{m,0}$ 就是这个环中的零元。</p><p>但是这个环并不是正则环。考虑我们熟知的正则环 $&lt;\mathbb Z,+,\times&gt;$ 和 $&lt;\mathbb R,+,\times &gt;$ 内都不存在零因子 $a,b$ 使得 $a\not =0,b\not = 0$ 且 $a\times b=0$ 。但是在模运算下这是可能成立的，比如可以设 $m=pq$ ，其中 $p\not \equiv q\pmod m$，那么就有 $\mathrm{ Z}_{m,p} \times \mathrm{ Z}_{m,q}=\mathrm{ Z}_{m,0}$ ，此时 $p,q$ 就均为 $\mathrm{ Z}_{m}$ 的零因子。所以可知剩余类环并不是正则的。</p><h2 id="互素剩余类"><a href="#互素剩余类" class="headerlink" title="互素剩余类"></a>互素剩余类</h2><h3 id="定义1-2"><a href="#定义1-2" class="headerlink" title="定义1.2"></a>定义1.2</h3><blockquote><p>若对于一个模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m,k}$ 满足 $(m,k)=1$ ，那么称 $\mathrm{ Z}_{m,k}$ 为模 $m$ 的一个互素剩余类。</p></blockquote><p>为了方便起见，记某个互素剩余类 $\mathrm{ Z}_{m,k}$ 为 $\mathrm{\zeta}_{m,k}$ 。同时可知这样的 $\mathrm{\zeta}_{m,k}$ 共有 $\varphi(m)$ 个。</p><h1 id="剩余系"><a href="#剩余系" class="headerlink" title="剩余系"></a>剩余系</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义2-1"><a href="#定义2-1" class="headerlink" title="定义2.1"></a>定义2.1</h3><blockquote><p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p><script type="math/tex; mode=display">i\in\mathrm{ Z}_{m,p}, j \in \mathrm{ Z}_{m,q}, \mathrm{ Z}_{m,p}\not=\mathrm{ Z}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个完全剩余系。</p></blockquote><h3 id="定义2-2"><a href="#定义2-2" class="headerlink" title="定义2.2"></a>定义2.2</h3><blockquote><p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p><script type="math/tex; mode=display">i\in\mathrm{ \zeta}_{m,p}, j \in \mathrm{ \zeta}_{m,q}, \mathrm{ \zeta}_{m,p}\not=\mathrm{ \zeta}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个简化剩余系。</p></blockquote><p>可知模 $m$ 的一个完全剩余系的大小是 $m$ ，一个简化剩余系的大小是 $\varphi(m)$ 。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2.1"></a>定理2.1</h3><blockquote><p>设 $m\in \mathbb Z_+$，$k,p\in \mathbb Z$ 且 $(k,m)=1$ ，则</p><p>（1）当 $x$ 遍历模 $m$ 的一个完全剩余系 $\mathrm{S}$ 时，$kx+p$ 也遍历模 $m$ 的一个完全剩余系 $\mathrm{S’}$ 。</p><p>（2）当 $x$ 遍历模 $m$ 的一个简化剩余系 $\mathrm{T}$ 时，$kx$ 也遍历模 $m$ 的一个简化剩余系 $\mathrm{T’}$ 。</p></blockquote><p>证：</p><p>（1）考虑只需要证对于任意两个模 $m$ 下不同余的 $x_i,x_j$ ， $kx_i+p,kx_j+p$ 也是不同余的，那么就可以得证。</p><p>考虑反证法。若 $kx_i+p\equiv kx_j+p\pmod m$，则有</p><script type="math/tex; mode=display">kx_i\equiv kx_j\pmod m</script><p>那么由于 $(k,m)=1$ 且根据定理</p><blockquote><p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p></blockquote><p>可知 $x_i\equiv x_j\pmod m$ 。矛盾。</p><p>（2）由（1）可以知道 $kx_i$ 彼此之间不同余，且因为 $(k,x_i)=(k,m)=1$ ，所以可知遍历的是一个简化剩余系。</p><h3 id="定理2-2"><a href="#定理2-2" class="headerlink" title="定理2.2"></a>定理2.2</h3><blockquote><p>设 $(m_1,m_2)=1$ ，则：</p><p>（1）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个完全剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个完全剩余系。</p><p>（2）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个简化剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个简化剩余系。</p></blockquote><p>证：</p><p>（1）</p><p>还是从证明互不同余这方面来考虑。如果存在 $x_1,x_2,y_1,y_2$ 使得</p><script type="math/tex; mode=display">m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1} m_{2}}</script><p>那么首先有</p><script type="math/tex; mode=display">m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1}}</script><p>即</p><script type="math/tex; mode=display">m_{2} x_{1} \equiv m_{2} x_{2}\pmod {m_{1}}</script><p>那么因为 $(m_1,m_2)=1$ ，所以有</p><script type="math/tex; mode=display">x_{1} \equiv x_{2}\pmod {m_{1}}</script><p>同理可知</p><script type="math/tex; mode=display">y_{1} \equiv y_{2}\pmod {m_{1}}</script><p>那么就可以知道，当 $x_1,x_2$ 不同余，$y_1,y_2$ 不同余的时候，$m_2x+m_1y$ 也是不同余的。</p><p>（2）</p><p>首先由于 $(x,m_1)=(y,m_2)=1$ ，所以 $(m_2x+m_1y,m_1)=1$ 且 $(m_2x+m_1y,m_2)=1$，所以可知 $m_2x+m_1y$ 一定会属于 $m_1m_2$ 的简化剩余系。同时由（1）中的结论可知这 $\varphi(n)\varphi(m)$ 个结果是两两不同余的。于是就只需要证明 $m_1m_2$ 的简化剩余系中，均属于这 $\varphi(n)\varphi(m)$ 个元素组成的集合即可。</p><p>对于任意一个与 $m_1m_2$ 互质的元素 $q$，由（1）可知必定存在一组 $(s,t)$ 使得</p><script type="math/tex; mode=display">q\equiv m_2s+m_1t\pmod {m_1m_2}</script><p>考虑若 $(s,m_1)&gt;1$ ，则有某个$d&gt;1,d|s$ 满足 $d|m_1\Longrightarrow d|m_1m_2$ 的同时 $d|q$ ，那么 $(m_1m_2,q)\geq d$ ，不符合互质的假设。故可知 $(s,m_1)=1$ ，同理 $(t,m_2)=1$ ，故证毕。</p><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>由定理 2.2(2) 可知，分别遍历模 $m_1$ 和 $m_2$ 的简化剩余系的 $x$ 和 $y$ ，在 $(m_1,m_2)=1$ 时，$m_1y+m_2x$ 遍历模 $m_1m_2$ 的一个简化剩余系。 根据乘法原理，可以得到 $\varphi(m_1)\cdot \varphi(m_2)=\varphi(m_1m_2)$ 。</p><p>这也就证明了欧拉函数 $\varphi(x)$ 是积性函数。</p><h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><blockquote><p>若 $(a,m)=1$ ，则有 $a^{\varphi(m)}\equiv 1\pmod m$ .</p></blockquote><p>若设 $(x_1,x_2,x_3\cdots x_{\varphi(m)})$ 是模 $m$ 的一个简化剩余系，那么由定理2.1(2)可知 $(ax_1,ax_2,ax_3\cdots ax_{\varphi(m)})$ 也是模 $m$ 的一个简化剩余系。所以有</p><script type="math/tex; mode=display">\prod_{i=1}^{\varphi(m)} x_i\equiv \prod_{i=1}^{\varphi(m)} ax_i\pmod m</script><p>那么由于 $\forall i,(x_i,m)=1$，所以 $(\prod x_i,m)=1$ 。于是消一下可以得到</p><script type="math/tex; mode=display">1\equiv a^{\varphi(m)}\pmod m</script><p>证毕。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人感觉剩余类这部分是很有趣的，虽然以上内容大部分都是4-6里面提炼出来的。对于欧拉定理，用群论知识证明同样十分简洁。</p><p>总之，完结啦，撒花花。</p><p>数论4-6，也算是我的一场持续了三年的春花旧梦了吧。</p><p>不知道啥时候能和EI和rqy一样有对数学知识的深刻认识。慢慢来吧。只有站在越高处，才能看到越广的风景，不是吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「重学4-6」系列的最后一篇文章。&lt;/p&gt;
&lt;p&gt;感觉剩余类这部分内容，以纯数论的眼光去看待，是十分优美的。&lt;/p&gt;
&lt;p&gt;嗯，将来自己抽代真正入门之后，可能就会多一点别的角度了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/抽象代数/环论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E7%8E%AF%E8%AE%BA/"/>
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[湖北省队互测2014week1 B] 一个人的数论</title>
    <link href="https://www.orchidany.cn/2020/04/01/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%95%B0%E8%AE%BA/"/>
    <id>https://www.orchidany.cn/2020/04/01/一个人的数论/</id>
    <published>2020-04-01T14:26:51.000Z</published>
    <updated>2020-04-02T17:38:01.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n$ 的质因数分解 $n= \prod _{i=1}^kp^{a_{i}}$，求所有小于 $n$ 且与 $n$ 互质的正整数的 $m$ 次方之和模 $10^9 +7$ 的值。其中 $p_i$ 为质数且不超过 $10^9$ 。</p><p>$a_i ≤ 10^9,k ≤ 1000,m ≤ 100$。</p></blockquote><a id="more"></a><p>写出式子来</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^n[(i,n)=1]i^m\\=&\sum_{i=1}^ni^m\sum_{d|i,d|n}\mu(d)\\=&\sum_{d|n}d^m\mu(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}  i^m\end{aligned}</script><p>然后发现这东西好像不是容易提前预处理。根据伯努利数的推论，可以知道 $\sum i^m$ 这东西是一个关于上界 $n$ 的 $m+1$ 次多项式。发现 $m$ 并不大于是可以 $O(m^2)$ 插出来。 若记这个多项式是 $f$ ，那么原式就等价于</p><script type="math/tex; mode=display">\sum_{d|n}d^m\mu(d)\sum_{i=1}^{m+1} f_i\left(\lfloor\frac{n}{d}\rfloor\right) ^ i</script><p>稍微化一下就是</p><script type="math/tex; mode=display">=\sum_{i=0}^{m+1} f_{i} \sum_{d | n} d^{m} \mu(d)\left(\frac{n}{d}\right)^{i}</script><p>发现对于后面的 $\sum $ 只需要求出每个 $p_i^{a_i}$ 处的值，然后每次 $O(k)$ 暴力合并，似乎也没啥问题。考虑对于每个 $p_i^{a_{i}}$ 怎么求。这个地方大概需要涨个经验，就是 $\mu(d)$ 这东西只有当 $d=1$ 和 $d=p_i$ 的时候才有值(无平方因子,剩下的因子都是 $p_i$ 的某个次数 $&gt;2$ 的幂)，所以每个只需要算两次，是 $O(1)$ 的。于是最后的复杂度 $O(m(m+k))$ 。</p><p>好神啊好神啊。</p><p>哈哈哈哈哈草这个题居然允许用高斯消元来代替插值。毕竟 $m$ 只有 $100$ 。</p><p>然后关于拉插，感觉很gg，因为一共有三个版本的拉插，求值和求系数，求值的又分为 $x$ 连续/不连续的。于是今天就把三个版本都写了一遍……</p><p>不过有一说一，求系数的拉插感觉就是在模拟。然后我还对着多项式除法(整除以一个形如 $(x+t)$ 的多项式)摸了好久，一直感觉很迷乱，后来用了用大除法，发现就是在模拟大除法的过程罢了。</p><p>然后一开始我还憨憨的写了个线性筛，然后发现 $\mu(d)$ 的 $d$ 是 $1e9$ 的，就懵圈了，然后又发现 $\mu(d)$ 只会是 $1/-1$ 并且很好判断，于是感觉自己是个sb。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Interpolation&#123;</span><br><span class="line"><span class="keyword">int</span> ans ; </span><br><span class="line"><span class="keyword">int</span> now ; </span><br><span class="line"><span class="keyword">int</span> x[N] ;</span><br><span class="line"><span class="keyword">int</span> y[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ; </span><br><span class="line"><span class="keyword">int</span> inv[N] ; </span><br><span class="line"><span class="keyword">int</span> pres[N] ; </span><br><span class="line"><span class="keyword">int</span> sufs[N] ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">a = (a % P + P) % P ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">res = (ll)res * a % P ; </span><br><span class="line">a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fz[N] ;</span><br><span class="line"><span class="keyword">int</span> fm[N] ; </span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a += b ;</span><br><span class="line"><span class="keyword">if</span> (a &gt; P) a -= P ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">(a -= b) %= P ;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmul</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = deg + <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">tmp[i] = t[i], t[i] = t[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg + <span class="number">1</span> ; ++ i)</span><br><span class="line">add(t[i], (ll)opt * tmp[i] % P) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdiv</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> *ret, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg ; ++ i) tmp[i] = t[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = deg - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">ret[i] = tmp[i + <span class="number">1</span>], dec(tmp[i], (ll)tmp[i + <span class="number">1</span>] * opt % P) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_xs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">fz[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">fmul(fz, i, (-x[i] + P) % P) ;</span><br><span class="line"><span class="comment">//debug(fz, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line"><span class="keyword">int</span> fenmu = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) fenmu = (ll)fenmu * (x[i] - x[j] + P) % P ;</span><br><span class="line">fdiv(fz, fm, n + <span class="number">1</span>, -x[i]) ; </span><br><span class="line">fenmu = (ll)y[i] * expow(fenmu, P - <span class="number">2</span>) % P ;</span><br><span class="line"><span class="comment">//cout &lt;&lt; fenmu &lt;&lt; endl ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">add(res[j], (ll)fenmu * fm[j] % P) ;</span><br><span class="line"><span class="comment">//debug(res, 1, n, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">inv[U] = expow(fac[U], P - <span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = (ll)inv[i] * i % P ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evenmark</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dnx</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m)&#123;</span><br><span class="line">pre_do(n) ;</span><br><span class="line">pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line">now = (ll)now * expow((ll)fac[i - <span class="number">1</span>] * fac[n - i] % P, P - <span class="number">2</span>) % P ;</span><br><span class="line">now = (ll)evenmark(n - i) * y[i] % P * now % P ; ans = (ll)(ans + now) % P ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> inow = <span class="number">1</span> ;</span><br><span class="line">pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">inow = <span class="number">1</span>, now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) inow = (ll)inow * ((x[i] - x[j]) % P + P) % P ; </span><br><span class="line">ans = (ans + (ll)now * expow(inow, P - <span class="number">2</span>) % P * y[i] % P) % P ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">namespace Linear_sieve&#123;</span></span><br><span class="line"><span class="comment">int cnt ;</span></span><br><span class="line"><span class="comment">int pr[N] ; </span></span><br><span class="line"><span class="comment">int mu[N] ;</span></span><br><span class="line"><span class="comment">int vis[N] ;</span></span><br><span class="line"><span class="comment">void sieve(int U)&#123;</span></span><br><span class="line"><span class="comment">mu[1] = 1 ;</span></span><br><span class="line"><span class="comment">for (int i = 2 ; i &lt;= U ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">if (!vis[i]) mu[i] = -1, pr[++ cnt] = i ; </span></span><br><span class="line"><span class="comment">for (int j = 1 ; j &lt;= cnt ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">if (i * pr[j] &gt; U) break ; </span></span><br><span class="line"><span class="comment">vis[i * pr[j]] = 1 ; </span></span><br><span class="line"><span class="comment">if (i % pr[j] == 0) break ; </span></span><br><span class="line"><span class="comment">mu[i * pr[j]] = -mu[i] ; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">int</span> d, w, num ;</span><br><span class="line"><span class="keyword">int</span> base[N], cs[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d &gt;&gt; w ; n = d + <span class="number">2</span> ; </span><br><span class="line"><span class="comment">//using namespace Linear_sieve ; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Interpolation ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">x[i] = i, y[i] = (y[i - <span class="number">1</span>] + expow(x[i], d)) % P ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= w ; ++ i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i] &gt;&gt; cs[i] ; get_xs(n) ; </span><br><span class="line"><span class="comment">//debug(y, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(res, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">now = <span class="number">0</span>, num = <span class="number">1</span> ;   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= w ; ++ j)&#123;</span><br><span class="line">now = expow(expow(base[j], cs[j] - <span class="number">1</span>), i - <span class="number">1</span>) ;</span><br><span class="line">now = ((<span class="number">-1l</span>l * now * expow(base[j], d) % P) + P) % P ; </span><br><span class="line">now = (now + expow(expow(base[j], cs[j]), i - <span class="number">1</span>)) % P ; </span><br><span class="line">num = <span class="number">1l</span>l * num * now % P ; </span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + (ll)num * res[i] % P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n$ 的质因数分解 $n= \prod _{i=1}^kp^{a_{i}}$，求所有小于 $n$ 且与 $n$ 互质的正整数的 $m$ 次方之和模 $10^9 +7$ 的值。其中 $p_i$ 为质数且不超过 $10^9$ 。&lt;/p&gt;
&lt;p&gt;$a_i ≤ 10^9,k ≤ 1000,m ≤ 100$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="多项式的应用" scheme="https://www.orchidany.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[bzoj3853] GCD Array</title>
    <link href="https://www.orchidany.cn/2020/03/31/GCD-Array/"/>
    <id>https://www.orchidany.cn/2020/03/31/GCD-Array/</id>
    <published>2020-03-31T14:18:24.000Z</published>
    <updated>2020-04-02T16:52:53.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>维护一个序列，支持以下操作：</p><p>1、给定 $n,d,v$ ，对每个 $(x,n)=d$ 的 $a_x\text{+=}v$ 。</p><p>2、询问 $\sum _{i=1}^k a_i$</p><p>$n\leq 10^5$</p></blockquote><p>很有意思的题目，解法也很简洁。</p><a id="more"></a><hr><p>妙妙题，建立一个辅助数组 $f$，让 $a_i=\sum _{d|i}f_d$ 。</p><p>考虑每次加的操作，对于每个 $i$ 实际上是加上这个东西：</p><script type="math/tex; mode=display">\begin{align*}&[(n,i)=d]v\\= &[(\frac{n}{d},\frac{n}{i})=1]v\\= &\sum_{k|\frac{n}{d},k|\frac{n}{i}}\mu(k)v\end{align*}</script><p>考虑对 $f$ 反演:</p><script type="math/tex; mode=display">f_d=\sum_{k|d}\mu(k)a_{\frac{d}{k}}</script><p>那么可以看出，其实每次操作就是对所有的 $k | \frac{n}{d}$ 的 $f_{kd}$ 加上了 $\mu(k)\cdot v$ .</p><p>考虑询问操作就是在询问</p><script type="math/tex; mode=display">\sum_{i=1}^x\sum_{d|i}f_d=\sum_{d=1}^{x}\left[\frac{x}{d}\right] f_d</script><p>这个可以 $\sqrt n$ 分块来做。于是最后修改复杂度 $\sqrt[3] n\log n$，询问复杂度 $\sqrt n\log n$ 。 注意到可以调整块的大小，对于所有 $&lt;\sqrt {x\log x}$ 的位置暴力加，对于所有 $&gt;\sqrt {x\log x}$ 的位置，至多有 $\sqrt \frac{x}{\log x}$ 个。所以可以把 $\log $ 放到里面去。</p><p>当然我肯定是写 $\sqrt n\log n$ 的啦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200110</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> L_s&#123;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ; </span><br><span class="line"><span class="keyword">int</span> mu[N] ;</span><br><span class="line"><span class="keyword">int</span> smu[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ; </span><br><span class="line">vis[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">mu[i * pr[j]] = -mu[i] ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">smu[i] = smu[i - <span class="number">1</span>] + mu[i] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">fc[i * j].push_back(i) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ; </span><br><span class="line">ll _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; (-x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; x &lt;= n ; x += low(x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> ( ; x ; x -= low(x)) ret += (ll)_bit[x] ;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, d, v ; </span><br><span class="line">L_s :: sieve(N - <span class="number">10</span>) ; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ++ T ;</span><br><span class="line"><span class="keyword">if</span> (!(m + n)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; T &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">fill(_bit + <span class="number">1</span>, _bit + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x) ; </span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;d, &amp;v) ; <span class="keyword">if</span> (x % d != <span class="number">0</span>) <span class="keyword">continue</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L_s :: fc[x / d].size() ; ++ i)</span><br><span class="line">add(L_s :: fc[x / d][i] * d, L_s :: mu[L_s :: fc[x / d][i]] * v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)</span><br><span class="line">r = x / (x / l), ans += (ask(r) - ask(l - <span class="number">1</span>)) * (ll)(x / l) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;维护一个序列，支持以下操作：&lt;/p&gt;
&lt;p&gt;1、给定 $n,d,v$ ，对每个 $(x,n)=d$ 的 $a_x\text{+=}v$ 。&lt;/p&gt;
&lt;p&gt;2、询问 $\sum _{i=1}^k a_i$&lt;/p&gt;
&lt;p&gt;$n\leq 10^5$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很有意思的题目，解法也很简洁。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="数学/观察性质,结论与构造" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E8%A7%82%E5%AF%9F%E6%80%A7%E8%B4%A8-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="分治" scheme="https://www.orchidany.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[UR#5 C]怎样跑的更快</title>
    <link href="https://www.orchidany.cn/2020/03/31/UR5-%E6%80%8E%E6%A0%B7%E8%B7%91%E7%9A%84%E6%9B%B4%E5%BF%AB/"/>
    <id>https://www.orchidany.cn/2020/03/31/UR5-怎样跑的更快/</id>
    <published>2020-03-31T14:14:34.000Z</published>
    <updated>2020-04-02T16:53:03.859Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>给定 $n ≤ 10^5;c,d ≤ 10^9$ 。</p><p>现有长度为 $n$ 的序列 $b$ 满足 $b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c}  \mathrm{lcm}(i, j)^{d} z_{j}(\bmod 998244353)$ 。</p><p>求 $\{z_n\}$ 。</p></blockquote><p>草，这真是一道神仙题。钛钛钛钛有趣辣！sto vfk .</p><a id="more"></a><p>先转化一下：</p><script type="math/tex; mode=display">b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c-d}\cdot i^d\cdot j^d\cdot  z_{j}(\bmod 998244353)</script><p>考虑形如 $\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j$ 等于某个值的东西，大概都是可做的。考虑先构造一个 $f’$ 满足</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}f'(d)</script><p>那么就可以化一下</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{j=1}^n\sum_{d}[d|i]\cdot [d|j]\cdot f'(d)\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot g(i)\cdot h(j)\cdot z_j\end{aligned}</script><p>那么就相当于要验证</p><script type="math/tex; mode=display">\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j =\frac{b_i}{g(i)}</script><p>如果能快速算 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 的话，那么有</p><script type="math/tex; mode=display">\sum_{d|i}f'(d)\zeta(d)=\frac{b_i}{g(i)}</script><p>考虑对于一个二元关系</p><script type="math/tex; mode=display">\sum_{d|n} p(d)=q(n)</script><p>这东西，知道 $q$ 之后是可以很容易地容斥出 $p$ 的。那么也就是说可以很容易地得到 $f’(k)\zeta(k)$ 。那么同时由于知道了 $f(k)=k^{c-d}$ ，是很容易直接容斥出 $f’(k)$ 的。也就是现在 $\zeta$ 变成了已知。</p><p>考虑如何从 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 反推出 $z_j$ 来，发现本质上是这样的：</p><script type="math/tex; mode=display">\zeta(d)=\sum_{d|j} h(j)z_j</script><p>根据莫比乌斯反演的另一种形式</p><script type="math/tex; mode=display">F(n)=\sum_{n | d} f(d)\Longrightarrow f(n)=\sum_{n | d} \mu\left(\frac{d}{n}\right) F(d)</script><p>反演一下变成</p><script type="math/tex; mode=display">h(d)z_d=\sum_{d|j} \mu(\frac{j}{d})\zeta_j</script><p>然后就可以直接做了。</p><p>注意到以上每个推完的式子，求的时候都是 $nH(n)$ 的复杂度，$O(n\ln n)$ 。</p><p>神题神题，可能这是我接触过的最像莫比乌斯反演的莫比乌斯题。并且把反演的容斥作用很好地诠释了出来。</p><p>还有注意无解的情况，由于 $0$ 不存在逆元，所以在求逆元的时候需要判一下是否存在「求了0的逆元」这种情况，有就输出无解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> hz[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, c, d ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> zeta[N] ;</span><br><span class="line"><span class="keyword">int</span> fzeta[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">a += b ;</span><br><span class="line"><span class="keyword">if</span> (a &gt; P) a -= P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">(a -= b) %= P ;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b += (P - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Linear_s&#123;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ;</span><br><span class="line"><span class="keyword">int</span> mu[N] ;</span><br><span class="line"><span class="keyword">int</span> smu[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ;</span><br><span class="line">vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">fc[i * j].push_back(i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Linear_s ; </span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d &gt;&gt; q ; sieve(n + <span class="number">10</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        g[i] = expow(i, d), f[i] = expow(i, c - d) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">            dec(f[i * j], f[i]) ;</span><br><span class="line"><span class="keyword">while</span> (q --)&#123;</span><br><span class="line"><span class="keyword">int</span> hasans = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i], hz[i] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">base[i] = (ll)expow(g[i], P - <span class="number">2</span>) * b[i] % P ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fzeta[i] = base[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">dec(fzeta[i * j], fzeta[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!f[i] &amp;&amp; fzeta[i]) &#123; hasans = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span> (!hasans) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line"><span class="comment">//debug(fzeta, 1, n, '\n') ; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            zeta[i] = (ll)fzeta[i] * expow(f[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">                add(hz[i], (mu[j] * zeta[i * j] % P + P) % P) ;</span><br><span class="line"><span class="comment">//debug(zeta, 1, n, '\n') ; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans[i] = (ll)hz[i] * expow(g[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n] ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 $n ≤ 10^5;c,d ≤ 10^9$ 。&lt;/p&gt;
&lt;p&gt;现有长度为 $n$ 的序列 $b$ 满足 $b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c}  \mathrm{lcm}(i, j)^{d} z_{j}(\bmod 998244353)$ 。&lt;/p&gt;
&lt;p&gt;求 $\{z_n\}$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;草，这真是一道神仙题。钛钛钛钛有趣辣！sto vfk .&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="uoj" scheme="https://www.orchidany.cn/categories/%E9%A2%98%E8%A7%A3/uoj/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/数值分析/调和级数" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/"/>
    
      <category term="思维题/容斥" scheme="https://www.orchidany.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】Mobiüs反演听课笔记</title>
    <link href="https://www.orchidany.cn/2020/03/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/30/莫比乌斯反演听课笔记/</id>
    <published>2020-03-30T10:44:57.000Z</published>
    <updated>2020-04-01T14:37:18.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是莫比乌斯反演这一块的听课笔记，由于记录的太长了<del>(不会的太多了)</del> 所以就分了一下。</p><p>反演好啊，有趣啊，不会啊！</p><a id="more"></a><h1 id="关于-mu-的有趣证明"><a href="#关于-mu-的有趣证明" class="headerlink" title="关于 $\mu$ 的有趣证明"></a>关于 $\mu$ 的有趣证明</h1><p>思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p><p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{d|n}\mu(d)\\ = &\sum_{d|n'}\mu(d)\\= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\= & ~(1+(-1))^k\\= & ~[k=0]\end{aligned}</script><h1 id="瞎反演记录"><a href="#瞎反演记录" class="headerlink" title="瞎反演记录"></a>瞎反演记录</h1><p>那大概使用来热身的。</p><ul><li>反演1</li></ul><script type="math/tex; mode=display">\begin{aligned}&\sum _{i=1}^n\sum_{j=1}^m[i,j]\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) \\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j\end{aligned}</script><ul><li>反演2</li></ul><script type="math/tex; mode=display">\sum [n,i]\\= \sum \frac{n\cdot i}{(n,i)}\\= \sum_{d=1}^n\sum\frac{n\cdot i}{d}\cdot [(n,i)=d]\\= \sum_{d=1}^n n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} i \sum \mu(k)\\= \sum_{d=1}^nn\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\cdot k\cdot \sum_{i=1}^{\lfloor\frac{n}{dk}\rfloor} i</script><h1 id="各种题"><a href="#各种题" class="headerlink" title="各种题"></a>各种题</h1><h2 id="SPOJ-LCMSUM"><a href="#SPOJ-LCMSUM" class="headerlink" title="SPOJ LCMSUM"></a>SPOJ LCMSUM</h2><blockquote><p>求 $\sum _{i=1}^n \mathrm{lcm}(n,i)$ .</p><p>$n\leq 10^6,T\leq 10^5$ </p></blockquote><p>草，这真是个神仙题。考虑 $\rm lcm$ 自然是要转化成</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \operatorname{lcm}(i, n)=\sum_{i=1}^{n} \frac{i\cdot n}{\operatorname{gcd}(i, n)}</script><p>那么考虑快速计算这个东西。一个自然的想法考虑能不能筛，筛就要求必须要是狄利克雷卷积的形似。想要转化过去的话必须是对 $n$ 的因子求和，于是想到要按照 $\gcd $ 分类，那么 $\gcd(n,i)=d$ 的 $i$ 总共有 $\varphi(\frac{n}{d})$ 个。</p><p>但是注意到分类之后，由于每一项都带有 $i$ 所以无法快速计算。考虑一个性质，$\gcd(n,k)=\gcd(n,n- k)$ 。那么就是：</p><script type="math/tex; mode=display">n\sum_{i=1}^n\frac{i}{\gcd(i,n)}=n\cdot \frac{1}{2}\left(\sum_{i=1}^n\frac{i}{\gcd(i,n)}+\sum_{i=1}^n\frac{n-i}{\gcd(n-i,n)}\right)=\frac{n}{2}\left(\sum_{i=1}^n\frac{i+(n-i)}{\gcd(i,n)}\right)=\frac{n^2}{2}\left(\sum_{i=1}^n\frac{1}{\gcd(i,n)}\right)</script><p>发现后面那一项就可以快速求和了：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \frac{1}{\operatorname{gcd}(i, n)}=\sum_{d|n} \frac{\varphi(\frac{n}{d})}{d}</script><p>那么答案就是</p><script type="math/tex; mode=display">\frac{n}{2}\left(\sum_{d|n} \frac{n\cdot\varphi(\frac{n}{d})}{d}\right)=\frac{n}{2}\left(\sum_{d|n} d\cdot\varphi(d)\right)</script><p>就可以快速筛出来了。复杂度 $O(n)-O(1)$ 。</p><h2 id="HDU-4944"><a href="#HDU-4944" class="headerlink" title="HDU 4944"></a>HDU 4944</h2><blockquote><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}</script><p>$n,T\leq 5\times 10^5$</p></blockquote><p>首先看到 $d$ 知道要提出来</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}\\=&\sum_{i=1}^{n} \sum_{j=i}^{n} \mathrm{lcm}(i,j)\sum_{d|i,d|j}d\\=&\sum_{d=1}^{n}d^2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=i}^{\lfloor\frac{n}{d}\rfloor} \mathrm{lcm}(i,j)\end{aligned}</script><p>发现对于 $f(n)=\sum_{i=1}^n\sum_{j=i}^n \mathrm{lcm}(i,j)$ 可以转化成</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^i \mathrm{lcm}(i,j)</script><p> 也就是上面LCMSUM里面求得的东西。于是就可以整除分块做了。复杂度 $O(n+T\sqrt n)$ 。</p><p>注意到，预处理的时候还可以计算每个 $d$ 对于每个 $n$ 的贡献。具体一点，考虑本质上对于每个 $n$，$d$ 的贡献都是 $d^{2} f\left(\left\lfloor\frac{n}{d}\right\rfloor\right)$ ，至多有 $\left\lfloor\frac{n}{d}\right\rfloor$ 种不同的取值，且每个取值对应的 $n$ 的区间是连续的。于是就用一些差分技巧差分一下这个修改。注意到这个的复杂度是调和级数的，所以总复杂度 $O(n\ln n)-O(1)$ 。</p><p>其实这里还有一点题，但是因为觉得很有趣就单拿出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是莫比乌斯反演这一块的听课笔记，由于记录的太长了&lt;del&gt;(不会的太多了)&lt;/del&gt; 所以就分了一下。&lt;/p&gt;
&lt;p&gt;反演好啊，有趣啊，不会啊！&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/积性函数/莫比乌斯反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="数学/积性函数/欧拉反演" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】同余</title>
    <link href="https://www.orchidany.cn/2020/03/29/%E6%95%B0%E8%AE%BA%E5%90%8C%E4%BD%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/29/数论同余学习笔记/</id>
    <published>2020-03-29T02:09:56.000Z</published>
    <updated>2020-04-02T14:17:02.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发现当年学数论，4-6那本书第二三章基本上就是没学会，于是今天打算重学一遍。</p><p>发现还是很有意思的。并且发现读过的MO📚越多，这种东西就越好理解。</p><p>嗯，寓快于慢，藏巧于拙。</p><a id="more"></a><p>先定义一下解的「本质相同」：通常认为在模 $m$ 意义下的同余方程中 $x$ 和 $x+km(k\in\mathbb{Z_+})$ 是本质相同的。 </p><h1 id="同余的基本性质"><a href="#同余的基本性质" class="headerlink" title="同余的基本性质"></a>同余的基本性质</h1><p>1.</p><blockquote><p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p></blockquote><script type="math/tex; mode=display">ac\equiv bc\pmod m\Longrightarrow m|c(a-b)\Longrightarrow \frac{m}{d}|\frac{c}{d}(a-b)</script><p>因为 $(\frac{m}{d},\frac{c}{d})=1$ ，所以 $\frac{m}{d}|(a-b)$ 。</p><p>2、</p><blockquote><p>若给定 $m_i(i=1,2,3\cdots)$ ，且 $\forall i$ 有 $a\equiv b\pmod {m_i}$，则有</p><script type="math/tex; mode=display">a\equiv b\pmod {[m_1,m_2,m_3\cdots ]}</script></blockquote><p>由 $\forall i,m_i|(a-b)$ 可知 $(a-b)$ 是 $m_1,m_2,m_3\cdots$ 的一个公倍数。所以 ${[m_1,m_2,m_3\cdots ]} |(a-b)$ 。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、证明</p><blockquote><p> $11$ 整除 $a$ 的充分必要条件是 $a$ 写成十进制表示后，从低位到高位，奇数位数字和减去偶数位数字和内被 $11$ 整除。</p></blockquote><p>我也不知道有啥好方法，编了一会儿觉得似乎 $100$ 进制的证法比较简单。就是考虑写成百进制的话会是这样：</p><script type="math/tex; mode=display">\sum _{i=1}^ka_{i}100^{k-1}\equiv 0\pmod {11}</script><p>发现 $100 \bmod 11$ 是 $1$ ，就很快乐：</p><script type="math/tex; mode=display">\sum_{i=1}^ka_i\equiv 0\pmod {11}</script><p>然后考虑百进制转10进制，发现有</p><script type="math/tex; mode=display">a_{i}=b^{2i-1}+10\cdot b^{2i}</script><p>那么考虑 $10$ 在 $\pmod {11}$ 时等价于 $-1$ ，于是就可以知道</p><script type="math/tex; mode=display">\sum_{i=1}^ka_i=\sum_{i=1}^k(b^{2i-1}- b^{2i})\equiv 0 \pmod {11}</script><p>于是得证。</p><p>2、证明</p><blockquote><p>$7/11/13$ 整除 $a$ 的充分必要条件是，最后三位数字与删去最后三位以后组成的数，所作之差被 $7/11/13$ 整除。</p></blockquote><p>证明方法差不多？设后三位组成的数是 $b$ ，删去最后三位以后组成的数是 $c$ ，那么有</p><script type="math/tex; mode=display">a=b+c\times 1000</script><p>若</p><script type="math/tex; mode=display">a\equiv 0\pmod k</script><p>那么一定有</p><script type="math/tex; mode=display">b+c\times (1000\bmod k)\equiv 0\pmod k</script><p>考虑 $1001=7\times 11\times 13$ ，所以可以知道 $1000 \bmod k\equiv -1 \pmod k$ 。于是得证。</p><h1 id="剩余类相关理论"><a href="#剩余类相关理论" class="headerlink" title="剩余类相关理论"></a>剩余类相关理论</h1><p>草，我是真觉得抽代入完门再来学这个比较合适。</p><p>于是因为内容太多了我就另开了一篇，想不到了吧？<del>机智如我</del></p><h1 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h1><blockquote><p>形如</p><script type="math/tex; mode=display">ax\equiv b\pmod m\qquad (1)</script><p>的方程。</p></blockquote><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote><p>若 $(a,m)=1$ ，则该式只有 $1$ 解。</p></blockquote><p>这是不难理解的。因为可以知道 $(1,2,3,\cdots m)$ 构成了模 $m$ 的一个完全剩余系，同时 $(a,2\cdot a,3\cdot a\cdots m\cdot a)$ 同样构成了模 $m$ 的一个完全剩余系。那么显然恰好一个整数使得 $aq\equiv b\pmod m$ . 所以解唯一。</p><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote><p>(2.1) 若记 $(a,m)=d$ ，且 $d|b$ ，那么(1)式存在解。</p><p>(2.2) 在(2.1)的假设下，若(1)式存在解，那么解的个数为 $d$ 个。</p></blockquote><p>首先不难知道(1)等价于 $ax+my=b$ 这个不定方程。那么(2.1)是显然的。</p><p>对于(2.2)，考虑将(1)转化成</p><script type="math/tex; mode=display">\begin{aligned}\frac{a}{d}x+\frac{m}{d}y&=\frac{b}{d}\\\frac{a}{d}x&\equiv\frac{b}{d}\pmod {\frac{m}{d}}\qquad (2)\\\end{aligned}</script><p>可知(1)和(2)的解是相同的。由定理1，且 $(\frac{a}{(a,m)},\frac{m}{(a,m)})=1$ 可知(2)的解是唯一的，设为 $t_0$</p><script type="math/tex; mode=display">x_0\equiv t_0\pmod{\frac{m}{d}}</script><p>可知一定有 $0\leq t_0&lt;\frac{m}{d}$ 。</p><p>因此(1)的全部解一定都是 $t_0+k\frac{m}{d} (k\in \mathbb{Z_+})$ 的形式。考虑 $k=0,1,2\cdots d-1$ 的时候，有</p><script type="math/tex; mode=display">t_0+k\frac{m}{d}<\frac{m}{d}</script><p>且由于其单调性可知这几个解互异。因此这 $d$ 个数在模 $m$ 下不同余。（证明了解至少有 $d$ 个）</p><p>另一方面，对(1)的任意一解 $t_0+k_0\frac{m}{d}$ ，令 $k_0=qd+r,0\leq r&lt;d$ 代入得：</p><script type="math/tex; mode=display">t_0+k_0\frac{m}{d}\equiv t_0+(qd+r)\frac{m}{d}\equiv t_0+r\frac{m}{d} \pmod m</script><p>可知对于每个 $k_0$，均与某个 $0\leq k&lt;d$ 时的解本质相同。（证明了解至多有 $d$ 个）。</p><p>因此，该式共有恰好 $d$ 个解。</p><h2 id="一般解法技巧"><a href="#一般解法技巧" class="headerlink" title="一般解法技巧"></a>一般解法技巧</h2><p>有两种常用的技巧，都是基于将 $ax\equiv b\pmod m$ 转化为形式分式 $x\equiv \frac{b}{a}\pmod m$ 的基础上： </p><blockquote><p>1、分子分母同乘一个与 $m$ 互质的数。</p><p>2、当 $(a,m)=1$ 时，分子可以加上 $m$ 的倍数。</p></blockquote><p>注意到，限制「与 $m$ 互质」的目的是为了保证形式分式有意义，即只有 $(a,m)=1$，$a$ 在模 $m$ 意义下的逆元才有意义。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一道毒瘤题</p><blockquote><p> 设 $p$ 为奇素数，$1&lt;a&lt;p$，则 $ax\equiv b\pmod p$ 的解为</p><script type="math/tex; mode=display">x\equiv b (-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\pmod p</script></blockquote><p>考虑把 $(-1)^{a-1}$ 乘到上面的括号里去</p><script type="math/tex; mode=display">\begin{aligned}&(-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\\ \equiv&\frac{(1-p)(2-p)\cdots (a-1-p)}{a!}\\\equiv&\frac{(1)\cdot (2)\cdots (a-1)}{a!} \equiv\frac{1}{a}\pmod p\end{aligned}</script><p>然后就证完了。毒瘤就毒瘤在…我太不会…/dk</p><p>个人认为写成这样帅一点</p><script type="math/tex; mode=display">x\equiv b (-1)^{a-1} \binom{p}{a}\pmod p</script><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><blockquote><p>若 $m_1,m_2\cdots m_k$ 为两两互素的正整数，记 $M=\prod m$ ，$r_i=\frac{M}{m_i}$ ，则一次同余方程</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}x \equiv a_{1} & \left(\bmod m_{1}\right) \\x \equiv a_{2} & \left(\bmod m_{2}\right) \\\vdots \\x \equiv a_{k} & \left(\bmod m_{k}\right)\end{array}\right.</script><p>有唯一解 $x\equiv t$ ，且</p><script type="math/tex; mode=display">t\equiv\sum _{i=1}^ka_ir_iq_i\pmod M</script><p>其中 $q_i=\frac{1}{r_i}\pmod {m_i}$ 。</p></blockquote><p><del>好难背啊</del></p><p>不过构造方式是很有趣的。大概就是考虑类似拉格朗日插值的构造方法，要找一堆 $\zeta_i$ 满足：</p><script type="math/tex; mode=display">\zeta_i\equiv\left\{\begin{array}{cc}1\pmod {m_j},\qquad j=i\\0\pmod {m_j},\qquad j\not=i\\\end{array}\right.</script><p>则可取</p><script type="math/tex; mode=display">x_0=\sum_{i=1}^k\zeta_ia_i</script><p>作为一组解。那么显然据此构造的方案满足这个条件。</p><p>另一方面，对于另一个解 $x_1$ 有</p><script type="math/tex; mode=display">\left\{\begin{array}{cc}x_0 \equiv x_{1} & \left(\bmod m_{1}\right) \\x_0 \equiv x_{1} & \left(\bmod m_{2}\right) \\\vdots \\x_0 \equiv x_{1} & \left(\bmod m_{k}\right)\end{array}\right.</script><p>由于 $m_1,m_2\cdots m_k$ 两两互素，可知 $x_1\equiv x_0\pmod M$。即全部的解都可以表示成</p><script type="math/tex; mode=display">x\equiv x_0\pmod M</script><p>​                                                                              </p><h1 id="exCRT"><a href="#exCRT" class="headerlink" title="exCRT"></a>exCRT</h1><blockquote><p>大概就是给出的 $m_i$ 不再互质的情况。</p></blockquote><p>考虑此时普通的crt会出现什么问题。在 $m_i$ 彼此互质的情况下，可以知道 $r_i=\frac{M}{m_i}$ 保证 $(m_i,r_i)=1$，那也就保证了 $r_i$ 在模 $m_i$ 意义下存在逆元。但是当 $(m_i,r_i)&gt;1$ 时，$q_i$ 就没有意义了。</p><p>考虑增量法。一开始有两个方程</p><script type="math/tex; mode=display">x\equiv a\pmod b\\x\equiv c\pmod d \\</script><p>那么有 $bt+a≡c \pmod d$ 用 exgcd 解出 $t≡t_0 \pmod{\frac{d}{(b,d)}}$</p><p>代回得 $x ≡ x_0 \pmod{[b, d]} $。这样迭代做下去就好了。感觉写这种代码还是要把变量分清，尽量写的清楚、松散一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll A[N] ;</span><br><span class="line">ll m[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">    ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">    x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(res += a) %= mod ;</span><br><span class="line">(a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res, mod ;</span><br><span class="line">    ll a, b, c, d, M ;</span><br><span class="line">    ll x, y, t0, t, g, z ;</span><br><span class="line">    res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        a = res, b = mod ;</span><br><span class="line">        c = A[i], d = m[i] ;</span><br><span class="line">        g = exgcd(x, y, b, d) ;</span><br><span class="line">z = ((c - a) % d + d) % d ;</span><br><span class="line">M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">        res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; m[i] &gt;&gt; A[i] ;</span><br><span class="line">    ll op = excrt() ; <span class="keyword">if</span> (op &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"hahaha"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; op ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="神奇的例题"><a href="#神奇的例题" class="headerlink" title="神奇的例题"></a>神奇的例题</h1><h2 id="CF338D"><a href="#CF338D" class="headerlink" title="CF338D"></a>CF338D</h2><blockquote><p>给出一个 $n × m$ 的数表, 其中第 $i$ 行第 $j$ 个数是 $\gcd(i, j)$，再给定一个长度为 $k$ 的数列 $\{a_n\}$, 判断其是否在数表的某一行出现过。</p><p>$n,m ≤ 10^{12},k ≤ 10^4$</p></blockquote><p>一道有意思的题。考虑由于是要去寻找一行，所以行号是固定的。那么必须要有 $\mathrm{lcm}(a_1,a_2\cdots a_k)|x$ 。</p><p>考虑是否可以选用 $x=\mathrm{lcm}(a_1,a_2\cdots a_k)$ 做答案。注意到如果 $x=p\cdot \mathrm{lcm}(a_1,a_2\cdots a_k)$ 可行，那么一定有</p><script type="math/tex; mode=display">\gcd(p,y) = 1</script><p>那么发现，对于 $p$ 的任意一个因子，都满足该性质。所以取 $p=1$ 完全没有问题。</p><p>之后考虑去检验 $y$ 的合法性。令第一个元素之前的那个元素(跟答案没关系的)为 $(x,y)$ 。发现 $y$ 需要满足</p><script type="math/tex; mode=display">\gcd(y+1,x)=a_1,\gcd(y+2,x)=a_2,\gcd(y+3,x)=a_3\cdots</script><p>注意到 $x$ 是所有 $a_i$ 的 $\rm lcm$ 。那么可以知道 $y+i$ 一定需要是 $a_i$ 的倍数，也就是</p><script type="math/tex; mode=display">\left\{\begin{array}{l}y+1\equiv 0\left(\bmod a_{1}\right) \\y+2\equiv 0\left(\bmod a_{2}\right) \\\vdots \\y+k\equiv 0\left(\bmod a_{k}\right)\end{array}\right.</script><p>那么用 excrt 求出这个 $y$ 来即可。需要注意的是，这样并不代表 $y$ 合法，因为 $y+i$ 是 $a_i$ 的倍数等价于 $\gcd(y+i,x)=a_i\cdot q$ 。 所以为了验证是否合法，需要再从头判一遍。</p><p>注意到如果此时不存在答案，那么也一定不存在其他的答案。这一点是比较显然的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N] ;</span><br><span class="line">    ll m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">    (res += a) %= mod ;</span><br><span class="line">    (a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">    z = ((c - a) % d + d) % d ;</span><br><span class="line">    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Sunzi ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k ; ll t = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), m[i] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) A[i] = -i ; lcm = m[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">t = m[i] * lcm, lcm = __gcd(lcm, m[i]), lcm = t / lcm  ;</span><br><span class="line"><span class="keyword">if</span> (lcm &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; lcm &lt;&lt; " " &lt;&lt; t &lt;&lt; endl ; </span></span><br><span class="line">    t = excrt() ; <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = t + <span class="number">1</span> ; i &lt;= t + k ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (__gcd(i, lcm) != base[i - t]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t + k &lt;= p) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>), <span class="number">0</span> ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现当年学数论，4-6那本书第二三章基本上就是没学会，于是今天打算重学一遍。&lt;/p&gt;
&lt;p&gt;发现还是很有意思的。并且发现读过的MO📚越多，这种东西就越好理解。&lt;/p&gt;
&lt;p&gt;嗯，寓快于慢，藏巧于拙。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【听课笔记】数论听课笔记</title>
    <link href="https://www.orchidany.cn/2020/03/28/%E6%95%B0%E8%AE%BA%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.orchidany.cn/2020/03/28/数论听课笔记/</id>
    <published>2020-03-28T14:29:00.000Z</published>
    <updated>2020-04-16T07:45:53.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听斯给普讲的有趣的数论问题，感觉海星？</p><p>顺便加上了一点自己之前随便整理的东西。</p><a id="more"></a><h1 id="瞎整理系列"><a href="#瞎整理系列" class="headerlink" title="瞎整理系列"></a>瞎整理系列</h1><h2 id="gcd-的实现"><a href="#gcd-的实现" class="headerlink" title="gcd 的实现"></a>gcd 的实现</h2><h3 id="一个必要的式子"><a href="#一个必要的式子" class="headerlink" title="一个必要的式子"></a>一个必要的式子</h3><blockquote><p> $a\geq b\to (a,b)=(b,a \bmod ~b)$</p></blockquote><p>令$a=bp+q~(0\leq 1&lt;b)$ 。若 $\exists d|a,d|b$，则有 $da’=db’p+q$，移项得 $q=d(a’-b’p)$，故$d|q\Longrightarrow d|(a\bmod~b)$。</p><p>考虑最后，$b’=0$，此时有 $a’=q’$，又因为 $\forall d$ 满足 $d|a,d|b$, $\exists d|q’\to d|a’$，即此时 $a’$ 是所有因子的倍数，故 $a’$ 为最大公因数。</p><p>说白了就是到最后有任意满足 $d|a,d|b$ 的 $d$ 都整除 $ans$ ，所以 $ans$ 是最大公因数。 </p><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>考虑分类讨论，不妨令 $a&gt;b$.</p><ul><li>当 $\frac{a}{2}&gt;b$ 时，有 $a\bmod b&lt;b&lt;\frac{a}{2}$</li><li>当 $\frac{a}{2}\leq b$ 时，有 $a\bmod ~b=a-b&lt;\frac{a}{2}$</li></ul><p>所以复杂度是 $\log(\max(a,b))$ 的。</p><h2 id="exgcd-的实现"><a href="#exgcd-的实现" class="headerlink" title="exgcd 的实现"></a>exgcd 的实现</h2><p>考虑丢番图方程 $ax+by=(a,b)$ 。</p><p>发现迭代到 $x=1,y=0$ 时，上式依旧成立。因为迭代到此时 $a’=(a,b),b’=0$ 。</p><p>同时因为 $(a,b)=(b,a\bmod b)$，所以有 $bx+y\cdot (a\bmod ~b)=(a,b)$ ，化简：</p><script type="math/tex; mode=display">\begin{aligned}bx+y\cdot (a-b\cdot \lfloor \frac{a}{b}\rfloor)&= (a,b)\\ay+b(x-y\cdot \lfloor \frac{a}{b}\rfloor) &=(a,b)\end{aligned}</script><p>按照这种形式向上递归后，就会少一层$\bmod$ 然后就没有然后了。 </p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><blockquote><p>使得</p><script type="math/tex; mode=display">a^x\equiv 1(\bmod p)</script><p>的最小的 $x$ 称为 $a$ 关于 $p$ 的<strong>阶</strong>。</p></blockquote><p>那么有结论 $x|\varphi(p)$ 。</p><p>考虑反证法。因为</p><script type="math/tex; mode=display">a^x\equiv 1(\bmod p)\\a^{\varphi(p)} \equiv 1(\bmod p)</script><p>且 $x$ 最小，故 $x&lt;\varphi(p)$ ，又因为假设 $x$ 不是 $\varphi(p)$ 的约数。那么不妨令 $\varphi(p)\equiv kx+q(0\leq q&lt;x)$ ，则有</p><script type="math/tex; mode=display">\begin{aligned}\frac{a^{\varphi(p)}}{(a^{x})^k}& \equiv a^q\\&\equiv 1(\bmod p)\end{aligned}</script><p>但这显然不合理，因为 $x&gt;q$ 但根据定义 $x$ 应该是最小的满足 $a^o\equiv 1(\bmod p)$ 的数，QED。</p><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><blockquote><p>对于素数 $p$，有</p><script type="math/tex; mode=display">(p-1)!\equiv -1 (\bmod p)</script></blockquote><p>证明大概就是考虑，在$2,3,…,n-3,n-2$中，每个数有且仅有一个逆元，不会 $\geq p$ 且唯一，所以会互相抵消。</p><h1 id="exgcd的应用"><a href="#exgcd的应用" class="headerlink" title="exgcd的应用"></a>exgcd的应用</h1><h2 id="类欧几里得问题"><a href="#类欧几里得问题" class="headerlink" title="类欧几里得问题"></a>类欧几里得问题</h2><script type="math/tex; mode=display">\sum_{x=1}^{n}\lfloor \frac{ax+b}{c}\rfloor</script><p>发现其实本质上求的是一条直线在 $x$ 正半轴和 $y$ 的正半轴的整点数量。那么考虑对于矩形区域可以随便求，对于三角形区域，可以让 $a$ 对 $c$ 取模之后依旧不影响结果，所以考虑沿着 $y=x$ 对称，那么会使得 $\frac{a}{c}$ 变成 $\frac{c}{a}$ ，这样就可以达到一个辗转相除的效果，复杂度 $\log n$ 。</p><h2 id="杂题1"><a href="#杂题1" class="headerlink" title="杂题1"></a>杂题1</h2><p>已知 $a_x=a_{x-1}+a_{x-2}$ ，给定 $a_1$, 求有多少个 $a_2\in[l,r]$ 使得 $a_k=b~(\bmod p)$. $k,p=O(10^9)$ 。</p><p>发现最后的 $a_k$ 一定可以写成 $ca_1+da_2=a_k=b(\mod p)$ ，然后就转化成一个瞎 $exgcd$ 问题了。</p><h1 id="多项式复合"><a href="#多项式复合" class="headerlink" title="多项式复合"></a>多项式复合</h1><blockquote><p> 已知 $f(x), g(x)$，求 $f(g(x))\mod x^n$ ，$1\leq n,m\leq 4000$。</p></blockquote><p>因为</p><script type="math/tex; mode=display">f(g(x))=\sum_{i=0}^{n} f_{i} g(x)^{i}</script><p>于是考虑预处理 $g(x),g^2(x)\cdots g^p(x)$ ，和 $g^{2p}(x),g^{3p}(x)\cdots$ 这样，每块先对 $f_{i+kp}g(x)^i$ 求和再做多项式乘法。</p><p>最后复杂度就是 $O(nm+\sqrt mn\log n)$</p><h1 id="Stern-brocot-Tree"><a href="#Stern-brocot-Tree" class="headerlink" title="Stern-brocot Tree"></a>Stern-brocot Tree</h1><p>大概是把 $\frac{0}{1}$ 和 $\frac{1}{0}$ 当做两个虚根。然后每次在两个点 $\frac{n}{m}$ 和 $\frac{n’}{m’}$ 中间插入一个 $\frac{n’+n}{m’+m}$ 。之后大概是这样的：</p><p><img src="1.png" alt></p><blockquote><p>bzoj 2852</p><p>给两个有理数 $a,b$，求最小的正整数 $k$, 使得 $(ak,bk)$ 里有整数。</p><p>$a$, $b$ 整数部分不超过 $2^{31}$ , 小数位数不超过 $300$ 位。</p></blockquote><p>发现 $(a,b)$ 的答案和 $(a-1,b-1)$ 的答案一样。所以考虑将 $(ak,bk)$ 移动到 $[0,1)$ 这个区间。此时如果 $b\geq 1$ 或者 $a=0$ 那么就可以找 $0/1$ 。否则就变成了解这样一个不等式：</p><script type="math/tex; mode=display">a \times k \leq t \leq b \times k</script><p>也就是</p><script type="math/tex; mode=display">a \leq \frac{t}{k} \leq b</script><p>那么就是找一个分母最小的夹在 $a,b$ 之间的分数。并且由于 $b&lt;1$ 所以一定是个真分数。那么就可以在stern-brocot Tree树上找LCA即可。</p><p>这个地方似乎是不用真的建出来树，因为存在某种神秘的树上二分方式，十分高妙。</p><h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><script type="math/tex; mode=display">\left(\begin{array}{l}n \\m\end{array}\right) \equiv\left(\begin{array}{l}n \bmod p \\m \bmod p\end{array}\right) \times\left(\begin{array}{l}\left\lfloor\frac{n}{p}\right\rfloor \\\left\lfloor\frac{m}{p}\right\rfloor\end{array}\right) \quad(\bmod p)</script><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>今天重学了一遍，发现证明好简单？</p><p>对于 $p$ 是质数而言，根据费马小定理一定有</p><script type="math/tex; mode=display">(1+x)^p\equiv (1+x) \pmod p</script><p>和</p><script type="math/tex; mode=display">x\equiv x^p  \pmod p</script><p>所以有</p><script type="math/tex; mode=display">(1+x)^p\equiv 1+x^p \pmod p</script><p>如果设 $n=sp+t,~0\leq t&lt;p$ 。那么就有</p><script type="math/tex; mode=display">\begin{aligned}(1+x)^n\equiv &(1+x)^{sp+t}\\\equiv &(1+x)^{sp}\cdot (1+x)^t\\\equiv &(1+x^p)^s\cdot (1+x)^t\\\equiv &(1+x^p)^{\left\lfloor\frac{n}{p}\right\rfloor}\cdot (1+x)^{x\bmod p}\end{aligned}\pmod p</script><p>考虑两边都暴力二项式展开</p><script type="math/tex; mode=display">\sum_{i=0}^n\binom{n}{i}x^i=\left(\sum_{j=0}^{\left\lfloor\frac{n}{p}\right\rfloor}\binom{n}{j}x^{j\cdot p}\right)\times \left(\sum_{k=0}^{n\bmod p}\binom{n}{k}x^{k}\right)\pmod p</script><p>观察右边。发现因为后面那个括号里 $x$ 的次数 $&lt;p$，前面一个括号内 $x$ 的次数一定是 $p$ 的倍数 。所以对于每个 $i$ ，都有唯一的 $j\cdot p+k=i$ （带余除法的唯一性）。所以可知</p><script type="math/tex; mode=display">\left(\begin{array}{l}n\\m\end{array}\right) \equiv\left(\begin{array}{l}n \bmod p \\m \bmod p\end{array}\right) \times\left(\begin{array}{l}\left\lfloor\frac{n}{p}\right\rfloor \\\left\lfloor\frac{m}{p}\right\rfloor\end{array}\right) \quad(\bmod p)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line">ll ans, tn, tm, tp, fac[N], inv[N] ;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= a) %= mod ;</span><br><span class="line">(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">tn = x ; tm = y ; tp = z ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ; </span><br><span class="line"><span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lucas</span><span class="params">()</span></span>&#123;</span><br><span class="line">my_assign(n + m, n, p) ; </span><br><span class="line">pre_do(tp - <span class="number">1</span>) ; ans = do_do(tn, tm) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道的是，Lucas定理还有另一种表示方式。如果把 $m,n$ 都看作 $p$ 进制数的话，即</p><script type="math/tex; mode=display">m=(\overline{m_1m_2\cdots m_k})_p\\n=(\overline{n_1n_2n_3\cdots n_k})_p</script><p>那么有</p><script type="math/tex; mode=display">\binom{n}{m}\equiv\prod _{i=1}^k \binom{n_i}{m_i} \pmod p</script><p>其实不难理解，可以联想十进制数拆分出每一位的过程，也是 $\bmod 10$ 之后再除以 $10$ 。</p><h2 id="例题：古代猪文"><a href="#例题：古代猪文" class="headerlink" title="例题：古代猪文"></a>例题：古代猪文</h2><blockquote><p>求 $g^\sum\textstyle_{d|n}\binom{n}{d}\bmod 999911659$ 。</p></blockquote><p>发现 $999911658=2\times 3\times 4679\times 35617$ ，然后分别做 Lucas 再拿crt合并起来就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">999911659</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000110</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line">ll ans ;</span><br><span class="line">    ll tp, tn, tm ;</span><br><span class="line">    ll fac[N], inv[N] ;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">ll ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">(ret *= a) %= mod ;</span><br><span class="line">(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">tn = x ; tm = y ; tp = z ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line"><span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line"><span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ;</span><br><span class="line"><span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">        my_assign(x, y, z) ;</span><br><span class="line">        ans = do_do(tn, tm) ; <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N], m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">    (res += a) %= mod ;</span><br><span class="line">    (a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> pn)</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= pn ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">    z = ((c - a) % d + d) % d ;</span><br><span class="line">    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll n, g ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line">ll p[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; g ;</span><br><span class="line">    <span class="keyword">if</span> (g % P == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="built_in">sqrt</span>(n) ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) base[++ cnt] = i ;</span><br><span class="line">    <span class="keyword">int</span> t = cnt ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n / base[i] &gt; <span class="built_in">sqrt</span>(n))</span><br><span class="line">            base[++ cnt] = n / base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)&#123;</span><br><span class="line">        Lucas_T :: tp = p[i] ;</span><br><span class="line">Lucas_T :: pre_do(p[i] - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">            (res[i] += Lucas_T :: Lucas(n, base[j], p[i])) %= (P - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)</span><br><span class="line">        Sunzi :: A[i + <span class="number">1</span>] = res[i], Sunzi :: m[i + <span class="number">1</span>] = p[i] ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Lucas_T :: expow(g, Sunzi :: excrt(<span class="number">4</span>), P) &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：组合数问题"><a href="#例题：组合数问题" class="headerlink" title="例题：组合数问题"></a>例题：组合数问题</h2><blockquote><p>求 $0≤j≤i≤n$ 且 $j≤m$ 的数对 $(i,j)$ 里有多少满足 $\binom{i}{j}≡0 \pmod p$</p><p>$T ≤ 100,n,m ≤ 10^{18},p ≤ 100$ 且是一个质数.</p></blockquote><p>根据上面那个性质，只要 $p$ 进制下 $i$ 的任何一位 $&lt;j$ 就 $\equiv 0$ 。然后就直接数位dp就完了。</p><h2 id="小-Q-的集合"><a href="#小-Q-的集合" class="headerlink" title="小 Q 的集合"></a>小 Q 的集合</h2><blockquote><p>求从 $n$ 元集合 $\rm S$ 中随机选择一个子集 $\rm T$ 。求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的方差。</p><p>$n≤10^{10^6},k≤10$，答案对质数 $m≤10^6$ 取模。</p></blockquote><p>嗯，学习了一下方差的定义。记这个东西的期望是 $E(x)$ ，那么方差就是 $E([x-E(x)]^2)=E(x^2)-E^2(x)$。</p><p>嗯，得出结论，概率论这一套是学不懂的。</p><p>说做法吧。根据期望的线性性，可以得到这个东西的期望是</p><script type="math/tex; mode=display">E(|\mathrm{S−T}|^k −|\mathrm{T}|^k)= E(|\mathrm{S−T}|^k)-E(|\mathrm{T}|^k)</script><p>那么显然这两项是对称的，所以这个东西的期望就是 $0$ 。所以就只需要求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的平方的期望就可以了。那么答案也就是</p><script type="math/tex; mode=display">\frac{\sum\limits_{i=0}^{n}\binom{n}{i}\left(i^{k}-(n-i)^{k}\right)^{2}}{2^n}</script><p>emmm然而并不可以直接做。然后有个很神仙的点就是考虑拿Lucas定理来展开一层得到：</p><script type="math/tex; mode=display">\sum_{i=0}^{\lfloor \frac{n}{m}\rfloor}\left(\begin{array}{c}\left\lfloor\frac{n}{m}\right\rfloor \\i\end{array}\right) \sum_{j=0}^{n \bmod m}\left(\begin{array}{c}n \bmod m \\j\end{array}\right)\left(j^{k}-(n-j)^{k}\right)^{2}</script><p>这么做是对的就在于每个 $\binom{n}{j}$ 都被分解成了唯一的 $\binom{\lfloor \frac{n}{m}\rfloor}{i}\cdot \binom{n\bmod m}{j}$ ，那么这两部分就可以<strong>分别算了</strong>。第一部分很显然就是 $2^n$ ，第二部分直接做就可以了。</p><p>嗯，这题真是十分高妙。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数论有意思！</p><p>exLucas是不可能学的…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听斯给普讲的有趣的数论问题，感觉海星？&lt;/p&gt;
&lt;p&gt;顺便加上了一点自己之前随便整理的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.orchidany.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学/扩展欧几里德" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="数学/数论" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学/阶与原根" scheme="https://www.orchidany.cn/tags/%E6%95%B0%E5%AD%A6-%E9%98%B6%E4%B8%8E%E5%8E%9F%E6%A0%B9/"/>
    
  </entry>
  
</feed>
