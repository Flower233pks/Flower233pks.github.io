<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随想·目次表]]></title>
    <url>%2F2050%2F12%2F31%2F%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[终于又开始了。 换了新的博客，把之前博客园里的三篇搬了下来。 每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。 时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。 读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。 读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。 是的，我是花，一个不理智的$Oier$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。 在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。 是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。 var ap = new APlayer({ element: document.getElementById("aplayer-xStSWKNI"), narrow: false, autoplay: false, showlrc: false, music: { title: "花", author: "Hello Nico", url: "Hello Nico-花.flac", pic: "/2050/12/31/随想·目次表/qwq.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 以下是目录： 题目 链接（点击即可） 随想一 · 杨柳岸晓风残月 $Link$ 随想二 · 丘吉尔 $Link$ 随想三 · 本赛季最后的随想/启示录 $Link$ 随想四 · 故人今安否？ $Link$ 随想五 · 手中没有红玫瑰 $Link$ 随想六 · 难 $Link$ $\rm{empty}$ $\rm{empty}$ $\rm{empty}$]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想七·言叶之庭]]></title>
    <url>%2F2019%2F03%2F28%2F%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD%2F</url>
    <content type="text"><![CDATA[​ Hello darkness my old friend. 黯淡如旧，今时重逢。​ I’ve come to talk with you again. 阔别久日，可赴低叙？​ Because a vision softly creeping. 如梦如幻，于我心萦。​ Left its seeds while I was sleeping. 遗之入梦，齐我心同。​ And the vision that was planted in my brain. 不知归处，不知归处。​ Still remains with the sound of silence. 行舟如风，遣舟迟暮。​ In restless dreams I walk alone. 吾心独行，兰皋止息。​ Narrow streets of cobble stone. 越陌度阡，可有一醉？​ Beneath the hallo of a street lamp’, 如光化影，于我心寂。​ I turned my collar to the cold and damp. 浊寒入襟，刺我心底。​ When my eyes were stabbled. 所见皆幻，所见皆明。​ By the flash of a neon light. 万物皆虚，万物皆允。​ That split the night. 不知归处，不知归处。​ And touched the sound of silence 星瀚灿漫，行人慢走。 ​ ——『$\rm{The ~Sound~of~Silence}$』寂静之声 随想系列目次表：戳我 这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。 $\rm{Part~1}$月考结束了。我终于有时间把这本书读完。 之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。 我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。 但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。 《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。 那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。 并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。 或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。 $\rm{Part~2}$感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。 连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。 我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。 所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。 …… 说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如…… 但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。 现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套…… 我不知道为什么。 总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。 我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了…… 突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。 这绝对是我读过的最美的故事了。 $\rm{Part3}$现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。 “这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。 但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。 我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。 …… 读完之后，后记里面新海诚是这么描述的： 我一直单恋着小说。不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。 …… 写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到耳机声音外溢云云。我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。 …… 写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物的心编织出这个世界。而本书想要描述的就是这点。在「爱」以前，这是段「孤独希求」的故事。这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。 我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。 $\rm{Part~4}$选了几段放到这里，留作纪念。 首先是最后，孝雄和雪野重逢的情景： 走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带上缝着枫叶的形状。这双鞋是为了那个人打造，一定可以走得更长更远。不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。——隐约雷鸣。孝雄脱口而出这句话。一股预感充满全身。已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼帘。那是一位穿着浅绿色裙子的女人。孝雄停下脚步。有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。孝雄心想，雨好像停了。 然后是孝雄表白完、雪野拒绝后，雪野的心声： 「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光是不让自己蹲下，就必须耗费莫大的力气。听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干的制服。「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便朝着玄关走去。「啊！」雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的声音，转开门把的声音。然后—— 啪嗒。关门的声音。那一瞬间，雪野突然感到很气愤。「笨蛋！」她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时泄气地慢慢放下椅子，再次坐了下来。「……笨蛋。」她小声地又说了一次。秋月那个笨蛋。一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续冷却着。——结束这段时光的人，是你啊！雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，静静地结束我们的关系。其实我一直在忍耐。其实我一直没有说出口。其实我一直没有说出来过—— 我喜欢你。 还有两段段很有名的摘录下来： 二十七岁的我，丝毫不比十五岁时候的我聪明。雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想着。 还有孝雄的情感爆发： 孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才露出这副表情的她。「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和歌。」孝雄说着。过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑鄙！」讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知道！」我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我讨厌你！「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更加喜欢你。「你就一直那样……」——开什么玩笑，怎么连你也哭了？「你就一直那样，摆出若无其事的表情……」秋月的泪水滴滴答答滑落，大吼着。「——一直孤单一人，度过一生吧！」 …… 今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。 孤独。 对，就是这个词，孤独。 无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。 总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。 或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。 或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许…… 但我没有啊，哈。 但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。 天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。 $\rm{Part~5/Ending}$今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。 我一直在想，这本书到底能带给我什么。 是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？…… 我不知道，但我觉得我列举的每个目的都太肤浅。 或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。 说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？ 我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。 $\mathfrak{Orchidany, 3,31,2019}$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式2·NTT以及任意模数NTT]]></title>
    <url>%2F2019%2F03%2F17%2FNTT1-2%2F</url>
    <content type="text"><![CDATA[$0x01\quad \rm{Preface}$无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。 我们知道，对于$FFT​$而言，其得以优化成$\log​$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。 $\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，快速数论变换。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$： $\omega_n^n = 1$。 $\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。 {$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}​$}，这使得问题规模可以在计算的时候减半。 $$\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k = \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}$$ 这样可以保证我们能够使用相同的方法进行逆变换。 首先，原根的基本定义：设$g$为$p$的一个原根，则满足：$$𝑔^{𝑝−1} \equiv 1(\mod p) \\∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。 同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过$$g^{p-1} \equiv1(\bmod~p) \ \omega_n^n=1$$而已。于是就满足性质一。 而对于性质三，我们先考虑一个转化。我们如果要将$g​$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}​$。换句话说，$N | (p-1)​$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)​$，得到一个和单位根相似的形式。 那么接下来，因为$p​$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)​$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)​$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：$$ g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)$$ 再结合显而易证的消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。 至于性质四，证明的大体相似于单位单位复根。即：$$ \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow \frac{(g_n^n)^k -1}{g_n^k -1} \equiv \frac{(1)^k -1}{g_n^k -1} = 0$$ 而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。 $0x02\quad \rm{Codes}$呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且$N$是$2$的幂次，所以素数$p$一定要是$2^j+1$的形式。 至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int N, M, K, qaq ;const int MAXN = 3000010 ;LL A[MAXN], B[MAXN], Inv ;const double Pi = acos(-1.0) ;int i, j, k, l, Lim = 1, L, R[MAXN] ; const int P = 998244353, G = 3, Gi = 332748118 ; namespace IO&#123; const int ch_top=4e7+3; char ch[ch_top],*now_r=ch-1,*now_w=ch-1; inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x; &#125; inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w=' '; &#125;&#125;inline LL expow(LL a, LL b)&#123; register LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= P ; (a *= a) %= P, b &gt;&gt;= 1 ; &#125; return res ;&#125;void NTT(LL *J, int flag)&#123; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; LL Gn = expow(flag == 1 ? G : Gi, (P - 1) / (j &lt;&lt; 1)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; LL g = 1 ; for(l = 0 ; l &lt; j ; l ++, g = (g * Gn) % P)&#123; LL Nx = J[k + l], Ny = g * J[k + j + l] % P ; J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ; &#125; &#125; &#125;&#125;using namespace IO ;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt;= N; i ++) A[i] = (read() + P) % P ; for(i = 0; i &lt;= M; i ++) B[i] = (read() + P) % P ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; NTT(A, 1), NTT(B, 1);for(i = 0; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - 2) ; NTT(A, -1) ; for(i = 0; i &lt;= N + M; i ++) write((long long) (A[i] * Inv + P) % P) ; fwrite(ch, 1, now_w - ch, stdout) ; return 0 ;&#125; 其中Gi表示$998244353$的原根的逆元。 $0x03\quad \rm{Extending}$接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。 先咕着qwq……]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式-NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的数学题 · [NOI2002]Savage/[Violet · 5]樱花]]></title>
    <url>%2F2019%2F03%2F17%2FMath1%2F</url>
    <content type="text"><![CDATA[$\rm{[NOI2002]}$ Savage链接：$\color{violet}{Link}​$ $\rm{Sol}$不算特别难…其实就是求方程$$C_{i}+P_{i}x \equiv C_j+P_jx ~(\bmod ~M)$$不存在一个解使得$x \leq min(L_i,L_j)$时，$M$的最小值。然后因为题目中的数据，假设我们令每个野人都只是绕着圈走而不重复经过对方的路径——即$M$的最大值，也不过是$100\times 106\times 100 = O(1e6)$的级别，于是考虑直接枚举$M$, 然后check。由于最多共有$15$个野人，且单次exgcd是$\log n $级别的，所以复杂度上限是$O (Mn^2 \log C_{max}) &lt; \Omega(1e8)$级别的。如果不是精心构造数据的话，可以直接艹过去。 喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的： 123456789inline bool check()&#123; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j)&#123; int a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ; int qwq = exgcd(x, y, a, b) ; if (w % qwq) continue ; x = x * w / qwq ; while (x &lt;= 0) x += M ; if (x &lt;= min(L[i], L[j])) return 0 ; &#125; return 1 ;&#125; 然后觉得一点问题都没有，$40pts$之后愣了大半天。 而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的$x$，应该不断取模$b/ \gcd(a,b)$ 为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解： _这是上面这个式子为什么可以这么做的证明：_ 若有$ax+by=c$且$a_0x+b_0y=c$ 那么便有$a(x-x_0)+b(y-y_0)=0$两边同时除以$gcd(a,b)$可得：$\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)$ $ \quad$ $(1)$ 而因为 $(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$ 所以由$(1)$可得$\frac{b}{gcd(a,b)}$整除$(x-x_0)$ 所以很显然有$\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in Z$ 那么就有对于任意一个$x_i$，有 $ x_i=x_0+\frac{b}{gcd(a,b)} \times{t} $ 我特么…智商已经回退到上个世纪了吧$\rm{qaq}$，自闭了。 这就是我整理这道题的原因……还有，上面$P_i-P_j$似乎需要取模并使其变成正的，因为好像我的$exgcd$里面限制了$A&gt;0$的缘故。 心得：我退役吧嘤。 1234567891011121314151617181920int i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;int exgcd(int &amp;x, int &amp;y, int A, int B)&#123; if (!B) &#123; x = 1, y = 0 ; return A ;&#125; int t = exgcd(y, x, B, A % B) ; y -= A / B * x ; return t ; &#125;inline bool check()&#123; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j)&#123; int a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; if (w % qwq) continue ; x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; if (!x) x += (M / qwq) ; if (x &lt;= min(L[i], L[j])) return 0 ; &#125; return 1 ;&#125;signed main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d%d%d", &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ; for ( M ; ; ++ M) if (check()) &#123; cout &lt;&lt; M &lt;&lt; endl ; return 0 ; &#125; &#125; $\rm{[Violet～5]}$ 樱花链接：$\color{violet}{Link}​$ 这是好久之前做的一道题，突然被我发现了。大概就是求方程$$\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 1e6)$$的解的组数。 $\rm{Sol}$不想思考系列问题，我这么懒还是退役吧。(sigh) 我们将柿子变个形：$$\frac{x+y}{xy} = \frac{1}{n!} \\n!x + n!y = xy$$然后我就不会了，此题完结 然后有一步很妙的是两边同时$+(n!)^2$得到：$$(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\(n!-x)(n!-y)=(n!)^2$$然后就会发现我们只需要找出$(n!)^2$的因子个数就好了… 好像我从来没有写过$\tau$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）$$x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)$$其实就是为了水字数 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#define ll long long#define MAXN 10000100#define Mod 1000000007int Prime[MAXN] ;std :: bitset &lt;MAXN&gt; vis ; long long N, i, j, cnt, Ans, Cnt[MAXN] ;void Ego()&#123; vis[1] = vis[0] = 1 ; for (i = 2 ; i &lt;= N ; ++ i)&#123; if (!vis[i]) Prime[++ cnt] = i ; for (j = 1 ; j &lt;= cnt ; ++ j)&#123; if (i * Prime[j] &gt; N) break ; vis[i * Prime[j]] = 1 ; if (!(i % Prime[j])) break ; &#125; &#125; for (i = 1 ; i &lt;= cnt ; ++ i) for (j = Prime[i] ; j &lt;= N ; j *= Prime[i]) ( Cnt[i] += (N / j) ) %= Mod ; &#125;int main()&#123; std :: cin &gt;&gt; N ; Ans = 1ll, Ego() ; for (i = 1 ; i &lt;= cnt ; ++ i) (Ans *= (Cnt[i] &lt;&lt; 1) + 1) %= Mod ; std :: cout &lt;&lt; Ans % Mod &lt;&lt; std :: endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学/扩展欧几里德</tag>
        <tag>数学/素数/素数筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇奇怪怪的线段树1（子段和+最长连续）]]></title>
    <url>%2F2019%2F03%2F17%2FSegment-Tree1%2F</url>
    <content type="text"><![CDATA[最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$ $\rm{Task1} $子段和其实这个算是比较简单的了，毕竟$qyf​$曾经给我们讲过，当时我就觉得十分的……麻烦233. 那么例题其实就是$\rm{SPOJ}$的$GSS$系列——的前三道题(后几道题都不会做) $GSS1$区间求最大子段和(不带修)$\color{violet}{Link}​$ $2333$应该算是比较简单的了。我们对于每个区间维护一个区间和，维护一个从最左端开始且必须包含最左端元素的最大子段和，再维护一个从最右端开始且必须包含最右端元素的最大子段和，最后维护一个区间最大子段和。 那么转移($push$_$up$)时就显得十分方便。我们的父区间的$Lmax$只取决于左子区间的$Lmax$和当左区间的$Sum$等于$Max$时（即左区间全部都要纳入到其最大子段和中时），左区间的$Sum$与右区间的$Lmax$的和。那么对于区间的$Rsum$，也是一个道理。最终对于该区间的最大子段和，我们不考虑从已经转移来的$Lmax/Rmax$，而是考虑从左右区间的$Max$以及左右区间的和来转移。大体代码： 123456inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125; 还有值得注意的一点：在询问的时候，它比较膈应……就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来……所以所就要类似于边询问，边$push_up$这种感觉。 123456789Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125; 然后总代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 200010#define LL long long#define max my_Fuckmax#define ls(rt) rt &lt;&lt; 1#define rs(rt) rt &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)using namespace std ;struct Tree&#123; LL S, Sum, Lsum, Rsum ;&#125;T[MAXN &lt;&lt; 1] ; int N, M, L, R, base[MAXN] ; #define S(x) T[x].S#define Sum(x) T[x].Sum#define Lsum(x) T[x].Lsum#define Rsum(x) T[x].Rsuminline LL my_Fuckmax(LL A, LL B)&#123; return A &amp; ((B - A) &gt;&gt; 63) | B &amp; ((~(B - A)) &gt;&gt; 63) ;&#125;inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125;inline void build(int rt, int l, int r)&#123; if (l == r)&#123; T[rt].Lsum = T[rt].Rsum = T[rt].S = T[rt].Sum = base[l] ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), P_u(rt) ;&#125;Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; cin &gt;&gt; M ; while (M --) scanf("%d%d", &amp;L, &amp;R), printf("%lld\n", query(1, 1, N).Sum) ; return 0 ;&#125; $GSS3$ 区间求最大子段和(带修)$\color{violet}{Link}$ ……其实吧，这个带修不带修……好像影响并不大？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 200010#define LL long long#define max my_Fuckmax#define ls(rt) rt &lt;&lt; 1#define rs(rt) rt &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)using namespace std ;bool MArk ;struct Tree&#123; LL S, Sum, Lsum, Rsum ;&#125;T[MAXN &lt;&lt; 1] ; int N, M, L, R, base[MAXN] ; #define S(x) T[x].S#define Sum(x) T[x].Sum#define Lsum(x) T[x].Lsum#define Rsum(x) T[x].Rsuminline LL my_Fuckmax(LL A, LL B)&#123; return A &amp; ((B - A) &gt;&gt; 63) | B &amp; ((~(B - A)) &gt;&gt; 63) ;&#125;inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125;inline void build(int rt, int l, int r)&#123; if (l == r)&#123; T[rt].Lsum = T[rt].Rsum = T[rt].S = T[rt].Sum = base[l] ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), P_u(rt) ;&#125;Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;inline void change(int rt, int l, int r, int k)&#123; if (L == l &amp;&amp; L == r)&#123; T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; return ; &#125; if (L &lt;= mid) change(ls(rt), l, mid, k) ; else change(rs(rt), mid + 1, r, k ) ; P_u(rt) ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; cin &gt;&gt; M ; while (M --) &#123; scanf("%d%d%d", &amp;MArk, &amp;L, &amp;R) ; if (!MArk) change(1, 1, N, R) ; else printf("%lld\n", query(1, 1, N).Sum) ; &#125;&#125; $GSS4$ 区间开根问题$\color{violet}{Link}$ 这个和子段和一点儿关系都没有，顺便整一下233. 就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个$2^{63}$内的数值$N$，我们假设其开根$k$次可以得到$N &lt; 2$——只要$N &lt; 2$之后的计算就会集中在一个紧确的范围$(1,2)$内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。 那么现在，我们致力于去确定$k$的值域。我们不得不承认，$\sqrt n$在$[0,+\infty]$是单调递增的，同理三次方根也是，四次方根也是……所以我们不妨取最大值，考虑$N=2^{63}$时，$k$值的大小。而很显然，此时的$k$应该为$\log _263+1 ≈ 6.978$——这似乎是十分平凡的结论。 总之，我们得出，似乎运算次数的上界就是$k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是$\Omega(7n)$的样子，无非就是多几个常数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ll N, M, K, i, L, R ; ll base[MAXN], T[MAXN], tot ;inline void p_u(ll rt)&#123; ;&#125;void _Build(ll rt, ll l, ll r)&#123; if (l == r)&#123;T[rt] = base[l] ; return ;&#125; _Build(ls(rt), l, mid) ; _Build(rs(rt), mid + 1, r) ; T[rt] = T[ls(rt)] + T[rs(rt)] ;&#125;inline ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123; if (l &gt;= sl &amp;&amp; r &lt;= sr) return T[rt] ; ll ret = 0 ; if (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ; if (mid &lt; sr) ret += _query(rs(rt), mid + 1, r, sl, sr) ; return ret ;&#125;inline void _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123; if (l &gt;= sl &amp;&amp; r &lt;= sr)&#123; if (T[rt] &lt;= (r - l + 1)) return ; else &#123; if (l == r)&#123; T[rt] = (int)(pow((double)T[rt], 0.5)) ; return ; &#125; &#125; &#125; if (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), T[rt] = T[ls(rt)] + T[rs(rt)] ; if (mid &lt; sr) _Sqrt(rs(rt), mid + 1, r, sl, sr), T[rt] = T[ls(rt)] + T[rs(rt)] ;&#125;int main()&#123; while(cin &gt;&gt; N)&#123; ++ tot, printf("Case #%d:\n", tot) ; for (i = 1; i &lt;= N ; ++ i) base[i] = qr() ; _Build(1, 1, N) ; cin &gt;&gt; M ; for (i = 1; i &lt;= M ; ++ i)&#123; K = qr(), L = qr(), R = qr() ; if (L &gt; R) swap(L, R) ; if (K)&#123; printf("%lld\n", _query(1, 1, N, L, R)) ; continue ; &#125; _Sqrt(1, 1, N, L, R) ; &#125; printf("\n") ; &#125; return 0 ;&#125; $\rm{Task2}$ 最长连续问题这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括连续字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断$push_up$即可。 $emmm$在这边整理几道思路不错的题吧： $\rm{USACO}$ 酒店($hotel$)$\color{violet}{Link}$ 初始的一个全零的序列，我们对它准确来说有以下三个操作： 区间置$0$ 区间置$1$ 询问是否有一段长度为$k$的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作② 这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。 但事实上……这就是学数据结构学傻了的后果……毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。 唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于$NOI2005$维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。 诶，好像扯了什么奇怪的东西…… 回到正题，我们不考虑直接维护这个东西，而是通过维护区间内的最长连续$0$的个数，达到辅助查找区间的目的。那么我们查找区间的时候，就直接**择最左边的区间优先，并$check$其是否有足够的$0$。 对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Tree&#123; int Sum, Len, Lsum, Rsum, tag ; &#125;T[MAXN &lt;&lt; 1] ; int A, B, N, M, MArk, i, t ;inline void push_down(int rt)&#123; if (T[rt].tag == -1) return ; else if (T[rt].tag == 0)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 0 ; T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = 0 ; T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = 0 ; &#125; else&#123; T[ls(rt)].tag = T[rs(rt)].tag = 1 ; T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ; T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ; &#125; T[rt].tag = -1 ;&#125;inline void push_up(int rt)&#123; if (T[ls(rt)].Sum == T[ls(rt)].Len) T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ; else T[rt].Lsum = T[ls(rt)].Lsum ; if (T[rs(rt)].Sum == T[rs(rt)].Len) T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ; else T[rt].Rsum = T[rs(rt)].Rsum ; T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;&#125; void build(int rt, int l, int r)&#123; T[rt].tag = -1, T[rt].Len = T[rt].Lsum = T[rt].Rsum = T[rt].Sum = r - l + 1 ; if (l == r)&#123; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r) ;&#125;void update(int rt, int l, int r, int ul, int ur, int k)&#123; if (ul &lt;= l &amp;&amp; ur &gt;= r)&#123; T[rt].tag = k ; if (k == 0) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = 0 ; else T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ; return ; &#125; push_down(rt) ; if (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ; if (ur &gt; mid) update(rs(rt), mid + 1, r, ul, ur, k) ; push_up(rt) ;&#125;int query(int rt, int l, int r)&#123; push_down(rt) ; if (l == r) return l ; if (T[ls(rt)].Sum &gt;= A) return query(ls(rt), l, mid) ; else if (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) return mid - T[ls(rt)].Rsum + 1 ; return query(rs(rt), mid + 1, r) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; build(1, 1, N) ; while(M --)&#123; scanf("%d", &amp;MArk) ; if (MArk == 2) scanf("%d%d", &amp;A, &amp;B), update(1, 1, N, A, A + B - 1, 1) ; else &#123; scanf("%d", &amp;A) ; if (T[1].Sum &gt;= A) printf("%d\n", t = query(1, 1, N)), update(1, 1, N, t, t + A - 1, 0) ; else putchar('0'), putchar('\n') ; &#125; &#125; return 0 ;&#125; $emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。 $\rm{SCOI}$ 序列操作$\color{violet}{Link}$ 对于一个$01$序列，大体是这几种操作： 区间清零 区间置为$1$ 区间全部取非 区间查询$1$的个数 区间查询最长连续的$1$的长度 好的，这道题被我秒了，爽啊……不过秒是秒了，对拍调试法调了好久$233$。 其实对于$1,2,4,5$都好说，只是第$3$个操作，需要再另维护区间最长连续的$0$的长度，如果存在取非标记生效，就交换一下就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127struct Tree&#123; int OS, OL, OR ; int Sum, Lsum, Len, Rsum, S, tag, t ; //tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor&#125;T[MAX &lt;&lt; 1] ; int N, M, MArk, L, R, base[MAX], i ;inline void up(int rt)&#123;// T[rt].S = T[ls(rt)].S + T[rs(rt)].S ; //1 if (T[ls(rt)].S == T[ls(rt)].Len) T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ; else T[rt].Lsum = T[ls(rt)].Lsum ; if (T[rs(rt)].S == T[rs(rt)].Len) T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ; else T[rt].Rsum = T[rs(rt)].Rsum ; T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ; //0 if (!T[ls(rt)].S) T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ; else T[rt].OL = T[ls(rt)].OL ; if (!T[rs(rt)].S) T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ; else T[rt].OR = T[rs(rt)].OR ; T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;&#125;inline void down(int rt)&#123;// if (T[rt].tag == -1) return ; if (T[rt].t == 1)&#123; T[ls(rt)].tag ^= 1, T[rs(rt)].tag ^= 1 ; T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ; T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ; //l T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ; T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ; T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ; //r T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ; T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ; T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ; &#125; if (T[rt].tag == 0)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 0 ; T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ; T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ; T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = 0 ; T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = 0 ; &#125; if (T[rt].tag == 1)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 1 ; T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = 0 ; T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = 0 ; T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ; T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ; &#125; T[rt].tag = -1, T[rt].t = 0 ; &#125;void _change(int rt, int l, int r, int k)&#123;// if (L &lt;= l &amp;&amp; r &lt;= R)&#123; T[rt].tag = k ; if (!k) T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = 0 ; else T[rt].OL = T[rt].OR = T[rt].OS = 0, T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ; return ; &#125; down(rt) ; if (L &lt;= mid) _change(ls(rt), l, mid, k) ; if (R &gt; mid) _change(rs(rt), mid + 1, r, k) ; up(rt) ; &#125;void _reverse(int rt, int l, int r)&#123;// if (L &lt;= l &amp;&amp; r &lt;= R)&#123; T[rt].t = 1 ; T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ; T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ; T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ; return ; &#125; down(rt) ; if (L &lt;= mid) _reverse(ls(rt), l, mid) ; if (R &gt; mid) _reverse(rs(rt), mid + 1, r) ; up(rt) ; &#125;inline int Sum(int rt, int l, int r)&#123;// if (L &lt;= l &amp;&amp; R &gt;= r) return T[rt].S ; down(rt) ; int res = 0 ; if (L &lt;= mid) res += Sum(ls(rt), l, mid) ; if (R &gt; mid) res += Sum(rs(rt), mid + 1, r) ; return res ;&#125;inline void build(int rt, int l, int r)&#123;// T[rt].tag = -1 ; T[rt].Len = r - l + 1 ; if (l == r)&#123; if (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = 1 ; else T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = 1 ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), up(rt) ;&#125;inline Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; R &gt;= r) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; while (M --)&#123;// cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ; scanf("%d%d%d", &amp;MArk, &amp;L, &amp;R), ++ L, ++ R ; if (MArk == 0) _change(1, 1, N, 0) ; else if (MArk == 1) _change(1, 1, N, 1) ; else if (MArk == 2) _reverse(1, 1, N) ; else if (MArk == 3) printf("%d\n", Sum(1, 1, N)) ; else printf("%d", query(1, 1, N).Sum), putchar('\n') ;// cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ; &#125;&#125; $push_up$真长啊$233$ 艹完这个题是真的爽啊~ $Task3~$ 总结一下其实这东西和$DP$是一样的吧？你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。 嗯，万物相同。 野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？ 不知为什么，突然想到了这句话。 $\mathscr{The~End}$]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应Simpson法入门]]></title>
    <url>%2F2019%2F03%2F17%2FSimpson1%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ 前言首先阐明一点，自适应辛普森算法($\rm{Adaptive ~Simpson’s~ rule}$ )是一类近似算法($\rm{Approximation ~algorithm}$)，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？ 其思想是利用二次函数来不断拟合($\rm{Overfitting}$)所求曲线，而所谓的$Adapative$（自适应）则是用于优化时间复杂度的方法。 嗝…总之…比较简单？ 表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。 $\rm{0x02}$ $\mathcal{Simpson~Formula}$ 辛普森公式稍等，这个跟算法的关系不大，主要是公式：$$\rm{\int _{l}^{r} f(x) \rm{dx}\approx \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}} \,$$ 事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大$233​$ 这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$： 因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：$$\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx$$求 $g(x)​$ 的不定积分为：$$\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C$$然后再带入 RR 和 LL ：$$\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)$$然后提公因式，原式为：$$\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)$$把里面展开来：$$\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)$$重新整理一下式子：$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)$$再整理：$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))$$代换可得：$$aR^2+bR+c\approx f(R)$$$$aL^2+bL+c\approx f(L)$$$$4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})$$把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：$\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))$ 于是我们就得到了所谓的$\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是—— $\rm{0x03}$ $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑定向二分。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。 于是考虑自适应。 所谓自适应，说的直白点，无非就是需要多分治几次的地方，多分治几次；不需要的则可以少分治几次 你会发现，其实他节约的就是一个点——时间效率。 举个栗子$^{[2]}$： 比如有这么个函数$\rm{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }$，我们要求$\int_{0}^{4}f(x) \rm{~dx}$ 并要求精度误差在$1e-5$ 以内。而我们有两种方法去解决： 以固定的比例以及约束二分。 运用自适应策略分配 那么我们首先要知道他真正的$value:$ 看起来好像海星？然后我们用两种方法都试一试： 首先是自适应法，我们发现最后只需要求$20$段区间。表中的$a_k \&amp; b_k$表示左右区间，$S(l,r)$表示$[l,r]$内、运用$0x01$中的公式计算的，$\rm{Error~Bound}$表示误差界，$\rm{Tolerance}$表示计算时需要的误差(程序设计时会讲)。 那么最后算出来的值是$ −1.54878823413$ ，与真实值误差为$0.00000013840 $，一共调用了$79$次函数估值（留个坑，后文会讲）。 那么绘制出来的函数图像大概长这样： 好像很流畅？$233$ 那么第二种方法是定值分段。我们考虑分成区间$[0,4]$分为长度为$0.03125$的$128$段，并运用$0x01$的$Formula$，最后得出的结果为$−1.54878844029$，误差为$0.00000006776$…… 好像是第一个误差的二分之一？听起来好像误差小了，但是却需要$257$次函数估值的调用……相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦的啦～ 但是比起$1e-5$精度来说……这波稳赚啊$233$ $\rm{0x04}$ $\mathcal{About~Code~}$ 代码实现首先是$LuoguP4525$的暴力解法： 12345678910111213141516171819202122232425#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define mid (l + r) / 2using namespace std ;const double Eps = 5e-8 ;double Ans, A, B, C, D, L, R ;inline double F(double x)&#123; return (C * x + D) / (A * x + B) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) / 6 * (F(l) + F(r) + 4 * F(mid)) ;&#125;inline double do_divide(double l, double r)&#123; double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Simp_calc(l, r) ; if (fabs(t = (Lv + Rv - v)) &lt;= Eps) return Lv + Rv ; return do_divide(l, mid) + do_divide(mid, r) ;&#125;int main()&#123; scanf("%lf%lf%lf%lf%lf%lf", &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ; Ans = do_divide(L, R) ; printf("%.6lf", Ans) ; return 0 ; &#125; 这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是……他对的很？ 至于进化版$LuoguP4526$，也是完全可以violently艹过去的：1234567891011121314151617181920212223242526#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define mid (l + r) / 2using namespace std ;const double Eps = 5e-8 ;double Ans, A, B, C, D, L, R ;inline double F(double x)&#123; return pow(x, A / x - x) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) / 6 * (F(l) + F(r) + 4 * F(mid)) ;&#125;inline double do_divide(double l, double r, double Lans)&#123; double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ; if (fabs(t = (Lv + Rv - v)) &lt;= Eps) return Lv + Rv ; return do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;&#125;int main()&#123; scanf("%lf", &amp;A) ; L = Eps, R = 23.3 ; if (A &lt; 0) &#123; puts("orz"), cout &lt;&lt; endl ; return 0 ;&#125; Ans = do_divide(L, R, Simp_calc(L, R)) ; printf("%.5lf", Ans) ; return 0 ; &#125; 但是，其真正的实现应该是这样： 123456789101112131415161718192021222324252627282930#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define v Lans#define hps eps * 0.5#define mid (l + r) * 0.5using namespace std ;double Ans, A, L, R ;const double Eps = 1e-7 ;const double Liu = 1.0 / 6 ;inline double F(double x)&#123; return pow(x, A / x - x) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) * Liu * (F(l) + F(r) + 4.0 * F(mid)) ;&#125;inline double do_divide(double l, double r, double Lans, double eps)&#123; double Lv, Rv, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ; if (fabs(t = (Lv + Rv - v)) &lt;= eps * 15) return Lv + Rv + t / 15 ; return do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; //据说eps×15来自于Wiki……&#125;int main()&#123; scanf("%lf", &amp;A) ; L = Eps, R = 30 ; if (A &lt; 0) &#123; puts("orz"), cout &lt;&lt; endl ; return 0 ;&#125; Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; printf("%.5lf", Ans) ; return 0 ; &#125; 然后我们发现这就可以跟文章上面$0x03$中的例子呼应了：每次分治时计算两次，总共分治了$39$次，最终一共计算了$78+1=79$次，而二分则是一棵有$128$个叶子节点的递归树，总共计算了$256 +1=257$次。 好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断$check\&amp;calc$, 而$check$的方式也很简单，只需要判断一下两段子区间的函数值之和与整个区间的函数值之和的差值是否在精度要求范围之内，之后如果满足精度误差就直接$return$，否则对于这段区间继续递归下去。 而这个地方有个要求，就是对于$eps$，你需要不断$half$他，原因很简单，对于一整段区间$U$，要求他的返回值的$|eps(U)| \leq k$的话，那么对于其作为子集两个连续区间$A,B$，当$A \bigcup B = U$时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq \frac{k}{2}$，才能保证$|eps(U) = eps(A) + eps(B)| \leq k$，所以要： 123#define hps eps * 0.5....................return do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; 好了，唯一的问题在于有句话迷的很： 1if (fabs(t = (Lv + Rv - v)) &lt;= eps * 15) return Lv + Rv + t / 15 ; 这个$\leq 15 \cdot eps$是什么意思？ 好吧，笔者也不清楚，但是有个结论是长这样的： 什么？你说推什么倒？小小年纪整天想着推倒学姐可不好啊$233$ 什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～ 好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了…… 于是结束，撒花花…（不是撒博主x） $\rm{Referance}$ $[1]$ :$NaCly_Fish$的$blog$ $^{^{[\nearrow]}}$ $[2]$ :某篇论文 $^{^{[\nearrow]}}$ 对于第二篇$refer$，借鉴的比较多（读书人的事……咳咳……），但是改了一个数据，就是$81 \to 79$，因为代码需要$233$ $Ps:$史上最不正经的$reference$诞生了……]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>积分/积分近似</tag>
        <tag>计算几何-Simpson积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calc on Trees (1)]]></title>
    <url>%2F2019%2F03%2F16%2FCal-on-Tree1%2F</url>
    <content type="text"><![CDATA[好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。 问题大概有两类：只有查询$\&amp;​$修改查询都有 $\mathscr{Task1}$普通的查询问题大概问题就类似于这个典型的$XOR$问题 其实说白了，这个题的解法十分简单——$LCA$ 但其实……我一开始考虑$LCA$，没有细致考虑，只是觉得如果从$u,v$分别向$LCA$跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。 但是这个地方，$LCA$的作用十分巧妙——我们试图去拓展这个题。我们定义$D(\bigodot,r,u)$表示在运算$\bigodot$下，从根$r$到某一固定点$u$的边权运算结果，其中限定了运算$\bigodot$必须为可逆运算，比如说异或、加法、减法——注意，此时的可逆运算，可以是自可逆（自己对自己运算是逆运算，比如$A~XOR ~A = 0$）或者他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法），那么我们就可以很方便地得出它的一般形式$$D(\bigodot,u,v) = D(\bigodot,r,u) \bigodot D(\bigodot,r,v) ~\bigoplus ~(~2 \cdot D(\bigodot,r,LCA(u,v)~)~)$$ ，其中我们假设运算$\bigodot$与$\bigoplus$互逆。树上前缀和大抵上就是这个意思。 那么回到这个题，我们对于每一个点的$D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$是一个相当平凡的结论；有权时，则直接$dfs$一遍即可。每次查询是$log$级别的，所以时间复杂度的渐进上界就是比较显然的$O(\max(m \log_2n,n))$。 代码大概是这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354il int qr()&#123; int k = 0; char c = getchar() ; while(!isdigit(c)) c = getchar() ; while(isdigit(c)) k = (k &lt;&lt; 1 )+ (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;il void add(int u, int v, int w)&#123; e[++cnt].t = v ; e[cnt].next = head[u] ; e[cnt].v = w ; head[u] = cnt ; e[++cnt].t = u ; e[cnt].next = head[v] ; e[cnt].v = w ; head[v] = cnt ;&#125;void _build(int deep, int now, int f, int _xor)&#123; fa[now][0] = f, dep[now] = deep, XOR[now] = _xor ; for(int k = head[now]; k ;k = e[k].next)&#123; if(e[k].t == f) continue ; _build(deep + 1, e[k].t, now, _xor ^ e[k].v) ; &#125;&#125;il void init()&#123; Up = log(N) / log(2) + 1 ; for(i = 1; i &lt;= Up; i ++) for(j = 1; j &lt;= N; j ++) fa[j][i] = fa[fa[j][i - 1]][i - 1] ;&#125;il int LCA(int u, int v)&#123; if(dep[u] &lt; dep[v]) swap(u, v) ; pre = dep[u] - dep[v] ; for(j = 0; j &lt;= Up; j ++) if((1 &lt;&lt; j) &amp; pre) u = fa[u][j] ; if(u == v) return u ; for(j = Up; j &gt;= 0; j --) if(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ; return fa[v][0] ;&#125;int main()&#123; N = qr() ; for(i = 1; i &lt; N; i ++)&#123; in1 = qr(), in2 = qr(), in3 = qr(); add(in1, in2, in3) ; &#125; M = qr() ; _build(1, 1, 0, 0), init( ); for(i = 1; i &lt;= M; i ++)&#123; in1 = qr(), in2 = qr() ; f1 = LCA(in1, in2) ; int t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ; cout &lt;&lt; t &lt;&lt; endl ; &#125; return 0 ;&#125; $\mathscr{Task~2}$带有修改的查询问题：之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是某年国家集训队的板子题和一道经典的边权修改启蒙题 我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然只能转移到深度大的点上，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。 所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要忽略$LCA(u,v)$，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句： 12_query(1, 1, N, Id[u], Id[v]) ; _update(1, 1, N, Id[u], Id[v], d) ; 改成 12_query(1, 1, N, Id[u] + 1, Id[v]) ; _update(1, 1, N, Id[u] + 1, Id[v], d) ; 即可。 而对于如何边权转点权，我用的总时间复杂度大约$O(n)$的区间赋值函数，好像比较方便： 1234567for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ;for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c);&#125; 嗯，题解好啊 那么上面两个题就比较简单了： $\mathscr{T1 ~\text{の} ~code}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162struct Node&#123; int u, v, c ;&#125;n[MAX &lt;&lt; 1] ;struct Edge&#123; int v, next, to ;&#125;e[MAX &lt;&lt; 1] ; int Id[MAX], M, N, tot, A, B, C, i ; char STR[50] ;int Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;int Max[MAX &lt;&lt; 1], Min[MAX &lt;&lt; 1], S[MAX &lt;&lt; 1], T[MAX &lt;&lt; 1], cnt ;inline int qr()&#123; int res = 0, f = 1 ; char c = getchar() ; while (!isdigit(c)) &#123;if (c == '-') f = -1 ; c = getchar() ;&#125; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res * f ;&#125;inline void _Add(int u, int v, int c)&#123; e[++ cnt].v = c, e[cnt].to = v ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].v = c, e[cnt].to = u ; e[cnt].next = head[v], head[v] = cnt ;&#125;void dfs1(int F, int now)&#123; Sum[now] = 1, Fa[now] = F, Dep[now] = Dep[F] + 1 ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == F) continue ; dfs1(now, e[k].to) ; Sum[now] += Sum[e[k].to] ; if (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ; &#125;&#125;void dfs2(int now, int Tp)&#123; Id[now] = ++ tot, Top[now] = Tp ; if (Son[now]) dfs2(Son[now], Tp) ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == Fa[now] || e[k].to == Son[now]) continue ; dfs2(e[k].to, e[k].to) ; &#125;&#125;inline void P_u(int rt)&#123; Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ; Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ; S[rt] = S[Ls(rt)] + S[Rs(rt)] ;&#125;inline void P_d(int rt, int L, int R)&#123; if (T[rt])&#123; int t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ; T[Ls(rt)] ^= 1, T[Rs(rt)] ^= 1 ; Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ; Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ; T[rt] = 0 ; &#125;&#125;void _build(int rt, int L, int R)&#123; if (L == R) return ; _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + 1, R) ; P_u(rt) ;&#125;void _change(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123; S[rt] = Max[rt] = Min[rt] = k, T[rt] = 0 ; return ; &#125; P_d(rt, L, R) ; if (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _change(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ;&#125;void _update(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123; int t = Max[rt] ; Max[rt] = -Min[rt], Min[rt] = -t ; T[rt] ^= 1, S[rt] = -S[rt] ; return ; &#125; P_d(rt, L, R) ; if (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ; if (Mid &lt; r) _update(Rs(rt), Mid + 1, R, l, r) ; P_u(rt) ; &#125;int _query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return Max[rt] ; P_d(rt, L, R) ; int Maxxxxx = -Inf ; if (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + 1, R, l, r)) ; return Maxxxxx ;&#125;int __query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return Min[rt] ; P_d(rt, L, R) ; int Minnnnn = Inf ; if (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + 1, R, l, r)) ; return Minnnnn ;&#125;int ___query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return S[rt] ; P_d(rt, L, R) ; int Ssssss = 0 ; if (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ; if (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + 1, R, l, r) ; return Ssssss ;&#125;inline void _Update(int u, int v)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _update(1, 1, N, Id[Top[u]], Id[u]) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _update(1, 1, N, Id[u] + 1, Id[v]) ;&#125;inline int Get_Max(int u, int v)&#123; int ret = -Inf ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline int Get_Min(int u, int v)&#123; int ret = Inf ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = min(ret, __query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = min(ret, __query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline int Get_Sum(int u, int v)&#123; int ret = 0 ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret += ___query(1, 1, N, Id[Top[u]], Id[u]) ; u = Fa[Top[u]] ; &#125; if (u == v) return ret ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret += ___query(1, 1, N, Id[u] + 1, Id[v]) ; return ret ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr() + 1, n[i].v = qr() + 1, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ; dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ; for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c); &#125; cin &gt;&gt; M ; for (i = 1 ; i &lt;= M ; ++ i)&#123; scanf("%s", STR) ; if (STR[0] == 'N') A = qr() + 1, B = qr() + 1, _Update(A, B) ; if (STR[0] == 'S') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Sum(A, B)) ; if (STR[0] == 'M' &amp;&amp; STR[1] == 'A') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Max(A, B)) ; if (STR[0] == 'M' &amp;&amp; STR[1] == 'I') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Min(A, B)) ; if (STR[0] == 'C') A = qr(), B = qr(), n[A].c = B, _change(1 ,1, N, Id[n[A].v], Id[n[A].v], B) ; &#125; return 0 ;&#125; 这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$一定是异或而不是覆盖 ……是一个坑点 $\mathscr{T2 ~\text{の} ~code}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132using namespace std ;struct Node&#123; int u, v, c ;&#125;n[MAX &lt;&lt; 1] ;struct Edge&#123; int v, next, to ; //0 = Change, 1 = Add .&#125;e[MAX &lt;&lt; 1] ; char STR[50] ; int A, B, C ;int Rec[MAX], Id[MAX], Aft[MAX] ;int N, tot ;int M[MAX &lt;&lt; 1], T[MAX &lt;&lt; 1][2], head[MAX], cnt, i ;int Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];inline int qr()&#123; int res = 0, f = 1 ; char c = getchar() ; while (!isdigit(c)) &#123;if (c == '-') f = -1 ; c = getchar() ;&#125; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res * f ;&#125;inline void _Add(int u, int v, int c)&#123; e[++ cnt].v = c, e[cnt].to = v ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].v = c, e[cnt].to = u ; e[cnt].next = head[v], head[v] = cnt ;&#125;void dfs1(int F, int now)&#123; Sum[now] = 1, Fa[now] = F, Dep[now] = Dep[F] + 1 ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == F) continue ; dfs1(now, e[k].to) ; Sum[now] += Sum[e[k].to] ; if (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ; &#125;&#125;void dfs2(int now, int Tp)&#123; Id[now] = ++ tot, Top[now] = Tp ; if (Son[now]) dfs2(Son[now], Tp) ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == Fa[now] || e[k].to == Son[now]) continue ; dfs2(e[k].to, e[k].to) ; &#125;&#125;inline void P_u(int rt)&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;void P_d(int rt, int L, int R)&#123; if(L == R) return; if (T[rt][0] != -1)&#123; M[Ls(rt)] = T[rt][0], M[Rs(rt)] = T[rt][0] ; T[Rs(rt)][0] = T[rt][0], T[Ls(rt)][0] = T[rt][0]; T[rt][0] = -1, T[Rs(rt)][1] = 0, T[Ls(rt)][1] = 0 ; &#125; if (T[rt][1])&#123; M[Ls(rt)] += T[rt][1], M[Rs(rt)] += T[rt][1] ; T[Rs(rt)][1] += T[rt][1], T[Ls(rt)][1] += T[rt][1] ; T[rt][1] = 0 ; &#125;&#125;void _build(int rt, int L, int R)&#123; T[rt][0] = -1 ; if (L == R) &#123;M[rt] = 0 ; return ;&#125; _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + 1, R) ; P_u(rt) ;&#125;void _change(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][0] = M[rt] = k, T[rt][1] = 0 ; return ;&#125; P_d(rt, L, R) ; if (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _change(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ;&#125;void _update(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][1] += k, M[rt] += k ; return ;&#125; P_d(rt, L, R) ; if (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _update(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ; &#125;int _query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return M[rt] ; P_d(rt, L, R) ; int Maxxxxx = -1 ; if (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + 1, R, l, r)) ; return Maxxxxx ;&#125;inline void _Update(int u, int v, int d)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _update(1, 1, N, Id[Top[u]], Id[u], d) ; u = Fa[Top[u]] ; &#125; if (u == v) return ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _update(1, 1, N, Id[u] + 1, Id[v], d) ;&#125;inline int Get_Max(int u, int v)&#123; int ret = -1 ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (u == v) return ret ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline void _Cover(int u, int v, int d)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _change(1, 1, N, Id[Top[u]], Id[u], d) ; u = Fa[Top[u]] ; &#125; if (u == v) return ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _change(1, 1, N, Id[u] + 1, Id[v], d) ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ; dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ; for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c); &#125; cin &gt;&gt; STR ; while(STR[0] != 'S')&#123; if (STR[0] == 'A') A = qr(), B = qr(), C = qr(), _Update(A, B, C) ; if (STR[0] == 'M') A = qr(), B = qr(), printf("%d\n", Get_Max(A, B)) ; if (STR[0] == 'C' &amp;&amp; STR[1] == 'o') A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ; if (STR[0] == 'C' &amp;&amp; STR[1] == 'h') A = qr(), B = qr(), n[A].c = B, _change(1 ,1, N, Id[n[A].v], Id[n[A].v], B) ; scanf("%s", STR) ; &#125; return 0 ;&#125; 这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。 与树形$\mathbb{DP}$ 的巧妙结合这个地方其实说的是一类问题。。。比如一道我根本不会的 经典题： $Description$ 一棵带权树，$n$个点$q$次询问，每次询问一个点的$\sum dis_{odd}$和$\sum dis_{even}$。 $\mathcal{Solution}$ 其实这个题的题目意思是让我们求： $R$君想知道对于每个点来说，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。 那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？ 这个东西比较简单，因为我们可以直接$dfs$。 那么如果是求所有点到所有点的距离和呢？ 换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。 我首先忽略边权，令边权都是$1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道根节点到所有点的距离之和，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？ 我们会发现，此时我们知道的量，同一般的树形$DP$或者说树形结构不同，我们现在已经知道了每一个子树的根节点的讯息；而平常的树形结构，我们知道的则是子节点的讯息$or$子树的讯息，这一点提示我们：反向$DP$ 我们不妨设$dp_u$表示$\sum \limits_{i \in T}^{}{dist(i,u)}$ 那么我们思考如何构造相邻两层的状态转移方程： 首先，我们已经决定反向$DP$，换句话说就是用父亲推出儿子；并且我们了解到，对于某一个点$u$，他的所有子节点到他的距离要比到他的父亲的距离少$1$（假设边权$=1$），同时所有除其子树之外的所有点到他的距离会多$1$.那么转移方程旧顺水推舟地： $dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$那么接下来我们思考，当边权不为$1$的时候呢？我们可以稍微魔改一下上式，于是就得到 $dp_v = dp_u - 2 \cdot pre_v \cdot subsize_v + N \cdot pre_v$其中$pre_i$表示节点$i$的上行边，即父亲与它相连的那条边。 那么以上简单版本的代码： 123456789101112131415161718192021222324252627282930313233using namespace std ;struct Edge&#123; int to, next ;&#125;E[MAX] ; int head[MAX], cnt ; int N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; inline void _Add(int u, int v)&#123; E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;&#125;void build(int now, int f)&#123; sub[now] = 1 ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; build(to(k), now) ; sub[now] += sub[E[k].to], dp[1] += sub[E[k].to] ; &#125; return ;&#125;void fwork(int now, int f)&#123; for (int k = head[now] ; k ; k = E[k].next)&#123; if (E[k].to == f) continue ; dp[E[k].to] = dp[now] - 2 * sub[E[k].to] + N ; fwork(to(k), now) ; &#125;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d", &amp;A, &amp;B), _Add(A, B) ; build(1, 0) ; fwork(1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) printf("%d\n", dp[i]) ;&#125; 唯一值得注意的地方就是其中$dp_1$或者说$dp_{root}$的处理。那么其实这个地方我们只需要不断加$size$即可。 高端版本的问题，代码类似： 12345678910111213141516171819202122232425262728293031struct Edge&#123; int to, next, v ;&#125;E[MAX &lt;&lt; 1] ; int head[MAX], cnt, i ;int N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;void build(int now, int f)&#123; Sub[now] = 1 ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; build(to(k), now) ; Pre[to(k)] = E[k].v ; Sub[now] += Sub[to(k)], dp[1] += Pre[to(k)] * Sub[to(k)] ; &#125; return ;&#125;void dp_work(int now, int f)&#123; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; dp[to(k)] = dp[now] - 2 * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ; &#125;&#125;inline void Add(int u, int v, int w)&#123; E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d%d", &amp;A, &amp;B, &amp;C), Add(A, B, C) ;; build(1, 0) ; dp_work(1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; dp[i] &lt;&lt; endl ;&#125; 那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。 我们致力于维护这样一个东西：对于每个$u \in T$， 我们试图确定除$u$及其子树外，到$u$点距离是奇数的点的个数$S0$$\&amp;$距离是偶数的点的个数$S1$，以便于状态转移时，作为第二部分。那么平均树高下，直接在$dfs/bfs$里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要$swap$一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）： $$dp[to(k)][0] = dp[now][1] - Sub[to(k)][0] Pre[to(k)] \ dp[to(k)][1] = dp[now][0] - Sub[to(k)][1] Pre[to(k)] ，\ dp[to(k)][0] += S0 Pre[to(k)] , \ dp[to(k)][1] += S1 Pre[to(k)] ;$$ 其中$to(k) \in son_{now}$ 而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）： $$dp[to(k)][1] = dp[now][1] - Sub[to(k)][1] Pre[to(k)] ;\ dp[to(k)][0] = dp[now][0] - Sub[to(k)][0] Pre[to(k)] ;\ dp[to(k)][1] += S1 Pre[to(k)],\ dp[to(k)][0] += S0 Pre[to(k)] ;$$ 于是就结束了。其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句： $dp_v = dp_u - 2 \cdot pre_v \cdot subsize_v + Count \cdot pre_v$其中$Count$表示某种神秘的计数。。。。 那么其实这种问题还可以拓展到“求对于每一个点$u$，$dist(u,v) \mod n =k$的点的个数，其中$k \in [0,k-1]$，我感觉做法应该会类似吧（但是我肯定不会做因为根本不可能调的出来） 结语 没啥好说的，只觉得第三模块的例题十分难调！十分难调！！！并且……我一开始没用$S0$或者$S1$，直接用的根节点的$sub_0$和$sub_1$，最后才法案根本不和逻辑。。。但他居然过样例了。。。 转移的时候还是需要有一个清醒的思路再code啊！ $DP$好啊！]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>树模型</tag>
        <tag>轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性规划入门·单纯形]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[许久之前开始学的算法了…今天终于学完了。主要参考的材料是董克凡的$2016$集训队论文和$\rm{Candy?}$的代码整理，在此处致以敬意。 $\rm{0x01\quad Preface}$首先明确，线性规划主要解决的问题是： $$\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=1,2,3\cdots n)$$不失一般性的，我们定义最大化的函数为目标函数($\rm{Aim-Func}$) ，定义约束函数的集合为约束函数集($\rm{Constraint-Set}$)。那么朴素的线性规划可以看求一组向量{$x_1,x_2\cdots x_n$}，使之既可以做约束函数的因变量，又满足其目标函数的值为$max​$。 同时，规定所有的$x$均满足$x&gt;0$。 当然，存在一种更加赏心悦目的矩阵表示方式：$$\text{最大化}\quad \boldsymbol{c^Tx} \\\text{满足约束} \quad A\boldsymbol{x\leq b} \\\\it{\qquad \qquad \quad} \boldsymbol {x} \geq 0$$其中$\boldsymbol{c,x,b}$均为一维向量，$A$为系数矩阵。 那么我们在高中数学必修五里面运用的智障做法是，通过每个约束确定一个凸包，再用目标函数不断平移以求得与凸包的切点/切线来达到最大值，但是这样的做法通常不具有一般性。所以需要引入一种更常用的方法来解决这类问题。 $\rm{0x02\quad}$ 松弛型矩阵与$\rm{Pivot}$操作我们考虑一种更加友好的线性规划方式——松弛型矩阵，即将原来的矩阵添加几个无实际作用的新变量$x_i$，使之换一个样子：$$\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} \quad (i = 1,2,3\cdots m) \\ \qquad\quad x_j \geq 0\quad (j=1,2,3\cdots n+m)$$两种表示是等价的，但是我们更倾向于松弛型这种简洁的表述方式。 同时我们规定以下： $1.$基变量：在松弛型约束中，等式左边的变量。 $2.$非基变量：在松弛型约束中，等式右边的变量。 那我们定义一次转轴操作$(pivot)$为将一个基变量换进等式右边，换出一个非基变量的过程。 假设我们在第$i$组约束中，有一个变量$x_k~(k&gt;n)$是基变量，我们要换出一个非基变量$x_p~(1\leq p\leq n)$，那么就会由：$$x_k= b_i -\sum \limits_{j=1}^{n} a_{i,j}x_{j}$$变成$$x_p = \frac{b_i - \sum \limits_{j\neq p}a_{i,j}x_j -x_k}{a_{i,p}}$$而单纯性做法的本质就是通过不断转轴，实现目标函数不断变大。 看上去似乎比较抽象？我们考虑对一次转轴操作，我们需要在转轴之后将原来目标函数里的非基变量代入，即用$(b_i - \sum _{j\neq p}a_{i,j}x_j -x_k)/a_{i,p}$这个东西去替换掉$x_p$，那么其中的常数项$\frac{b_i}{a_{i,p}}$就可以作为目标函数中的一个常数值，当$x_i~(i=1,2,3\cdots n)$均为$0$时，目标函数的值即为此。那么转轴操作就是通过这样的操作使得目标函数里的常数值不断增大，达到最优解。 注意，转轴之后的得到的$x_p$的表达式，不仅要代入目标函数，也要代入其余的约束。 $\rm{0x03}\quad \rm{Simplex}$那么接下来，我们考虑单纯性做法的完整过程。 不失一般性的，我们假设所有$b_i\geq 0$ 首先，我们对于转轴操作结束，回代一次之后，会发现目标函数中肯定会有至少一项系数变为负值，即转进来的前·基变量$x_k$，那么增大$x_k$一定会让结果目标函数变小。所以我们可以断言，当目标函数里的所有变量系数均为负值时，目标函数的最优值就会是现在目标函数中的常数值——因为我们在前文已经假定$x_i\geq 0$了。 同样，我们每次转轴操作需要保持原来线性规划的不变性，换句话说就是我们每次转轴时都需要找一个对与某个非基变量限制最紧的约束，将其换出。原因是我们考虑目标函数中的$x_i$，当其系数$\geq 0$时，$\rm{Aim }\propto x_i$，所以我们需要找一个最紧的约束遏止$x_i​$的增长(即使我们不想)。 那么伪代码如下，$A,\boldsymbol{b,c}$的定义一开始已给出： Simplex(A, b, c){$\qquad$ initialization(A,b,c) ; $\qquad$ while $∃e$ that $c_e&gt;0${$\qquad$$\qquad$find the index $l$ that $A_{l,e}$ $&gt; 0$ and minimizes $b_l/A_{l,e}$$\qquad$$\qquad$if $∀l, A_{l,e} ≤ 0$$\qquad$$\qquad$$\qquad$return Unbounded ;$\qquad$$\qquad$else$\qquad$$\qquad$$\qquad$pivot(A, b, c, l, e)；} 值得注意的是，如果在寻找完最紧约束后，存在一个$A_{l,e} \leq 0$，那么我们在这组约束里无论怎么增大$x_e$都会使得目标函数增大，所以直接return Unbounded。 此时我们还需要进行额外的操作，即初始化。因为我们转轴操作的目的是使目标函数增大，所以我们需要保证所有的$b_i\geq 0$，但一开始给定的$b_i$很可能不满足这一约束，所以我们需要进行一次初始化。那么对于初始化，我们的思想是做另一次线性规划。鬼知道那些发明这玩意儿的神仙怎么构造出的这个线性规划。 我们考虑一个这样的线性规划：$$\text{最大化}\quad -x_0 \\\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} +x_0\quad (i = 1,2,3\cdots m)\\\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=0,1,2,3\cdots n)$$首先，无论怎样，先思考他会不会对原来的线性规划产生什么影响——答案是：不会。因为我们考虑当$-x_0$最大时，一定是$x_0=0$的时候。所以对于约束中的$x_{n+i}$，大小不会变化。 那么我们考虑这种初始化方式的正确性。我们考虑每次都将$x_0$作为换入变量(即我们一开始将$x_0$视作非基变量)，那么$pivot$之后就会有$$x_0 = -b_i+x_{i+n}+\sum\limits_{j=1}^{n}a_{i,j}x_j$$由于我们一定找的时限制最小的，那么$b_i&lt;0\Longrightarrow-b_i &gt;0$，这组约束合法。 对于其余的约束，我们考虑代入之后，会有：$$x_{n+k}= b_k-b_i+\sum\limits_{j=1}^{n}(a_{k,j}-a_{i,j})x_j+x_{i+n}$$由于$b_i$最小，那么$b_k\geq b_i \Longrightarrow b_k-b_i\geq 0$。任务完成。 那么就可以愉快地上代码辣(≧▽≦)/！题目来自于$\rm{UOJ179}​$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#define MAXN 1010using namespace std ;const double eps = 1e-8, INF = 1e15 ;int N, M, T, Id[MAXN], i, j ; double A[MAXN][MAXN], Get[MAXN] ;void Pivot(int l, int e)&#123; swap(Id[N + l], Id[e]) ;//交换两个变量 double t = A[l][e] ; A[l][e] = 1.0 ; for(i = 0 ; i &lt;= N ; ++ i) A[l][i] /= t ;//类似于高斯消元的第一步，把这一项挪到等式右边，所以要先都除以系数 for(i = 0 ; i &lt;= M ; ++ i) if(i != l &amp;&amp; fabs(A[i][e]) &gt; eps) for(t = A[i][e], A[i][e] = j = 0 ; j &lt;= N ; ++ j) A[i][j] -= A[l][j] * t ;//此处则是代换。而由于代数式中肯定不会出现我们的A_&#123;i,e&#125;(毕竟是换到了等式右边)，所以对于这一项的系数要特殊处理成0&#125;bool Init()&#123; while(true)&#123; int e = 0, l = 0 ; double t = -eps ; for (i = 1 ; i &lt;= M ; ++ i) if (A[i][0] &lt; t) l = i, t = A[i][0] ; if(!l) return 1 ;//找系数最小的负值项 for (j = 1 ; j &lt;= N ; ++ j) if (A[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; 1))) e = j ; if (!e) return puts("Infeasible"), false ; Pivot(l, e) ; &#125;//不合法的线性规划，因为我们假设全部的系数都为正，且我们前面已经假定了全部x_i为正，那么不可能满足标准型里面的小于b_l——此时b_l为负值。 return 1 ;&#125;bool Simplex()&#123; while(1)&#123; int l = 0, e = 0 ; double MAX = INF ; for(j = 1 ; j &lt;= N ; ++ j) if (A[0][j] &gt; eps) &#123; e = j ; break ; &#125; if(!e) break ; for(i = 1 ; i &lt;= M ; ++ i) if (A[i][e] &gt; eps &amp;&amp; A[i][0] / A[i][e] &lt; MAX) MAX = A[i][0] / A[i][e], l = i ;//选个最紧的约束 if (!l) return puts("Unbounded"), false ; Pivot(l,e) ; &#125; return 1 ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; T ; srand(19260817) ; for (i = 1 ; i &lt;= N ; ++ i) Id[i] = i ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; A[0][i] ; for (i = 1 ; i &lt;= M ; cin &gt;&gt; A[i ++][0]) for (j = 1 ; j &lt;= N ; ++ j) cin &gt;&gt; A[i][j] ; if (!(Init() &amp;&amp; Simplex())) return 0 ; printf("%.8lf\n", -A[0][0]) ; if(T)&#123; for(i = 1 ; i &lt;= M ; ++ i) Get[Id[N + i]] = A[i][0] ; for(i = 1 ; i &lt;= N ; ++ i) printf("%.8lf ",Get[i]) ; &#125; return 0 ;&#125; 然鹅事实上这份代码只有$97pts​$…好像剩下3分就几乎没有人得过，除了kcz和std…… 至于中间的srand，是由于我们随便$pivot$一个$e$就好，于是就听长者的。 $\rm{0x04}\quad Afterwords$一直想学，一直没有机会学。 说起来确实有点儿小激动。第一次写单纯型的代码是前不久的一次周末，早上点起来之后头昏脑涨地扑向Candy?的博客，学了起来。在那之后才发现原来线性规划并不常考，甚至说，不考。但是我挺喜欢这种感觉，感觉自己仿佛比出题人会的还多 $\rm{Reference}$ $[1]$ :$Candy?$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <categories>
        <category>-学习笔记 -线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想六·难]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard%2F</url>
    <content type="text"><![CDATA[《随想》系列目次表：$Link$ $\text{Part0}$不知道为什么，最近的心绪颇不宁静。 那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。 我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。 这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。 毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。 就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。 $\text{Part1}\cdot Her$“她”是谁？ 我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系： 头一次清晨在无人的校园里闲逛，耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光—— 最后一句本来是但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。 我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。 我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？…… 以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说： 大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。 她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。 $\rm{Part3}$我很烦。 机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。 我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年NOIP考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？ 好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊… 最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了…… $\rm{Part4}$不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。 其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望： 我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。 同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。 如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。 没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。 保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙—— 你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？ 你知道每年有多少初中生在NOIp中碾压高中生吗？ 你不知道。 每天几个小时？ 做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。 你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。 我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。 看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。 为什么会这么难呢？我不知道啊。 我只知道我的机会确乎是不多了。 今年省选还有没有戏呢？我也不知道。 我只知道我的时间不多了。 不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。 呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。 这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS-Senior·扩展的BSGS]]></title>
    <url>%2F2019%2F02%2F22%2FexBSGS%2F</url>
    <content type="text"><![CDATA[$\rm{0x01\quad Preface}$$emmm$严格来讲，不应该被算到一个模板里面。因为在我看来模板是人构造出来的，但是这个算法应该是一个解决问题的$process$…更像是在解一道数学题，如果$BSGS$是定理的话，$exBSGS$更像是一个不断转化的过程233（手动@lxa并且溜 $\rm{0x02\quad Algorithm~Process}$今天才发现原来$\rm{BSGS}$有两种写法……并且觉得剩下的题解讲的都讲的不是很全的样子233。 其实本质上，当$p$不为素数时，我们无法进行朴素$\rm{BSGS}$的原因是我们的欧拉定理$a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理$(a,p)=1$的情况。那么我们知道，朴素的$\rm{BSGS}$的关键在于，可以保证最小解是有界的——$x$一定在$[1,\varphi(p)]$中。所以最后$BSGS$的复杂度才会是$\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的$p$是素数的情况下，时间复杂度为$\Theta(p)$。 那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。 我们思考，对于同余式$a^x\equiv b~(\bmod p)​$而言，我们先假定$(a,p)&gt;1 ​$。而此时如果有$((a,p), b)=1​$，那么说明此式只有可能在$x=0,b=1 ​$的时候有解——这个结论是平凡的。因为假设我们把它展开成$a\cdot a^{x-1} +kp=b ​$的形式，必须要有$(a,p) ~|~ b​$的情况下，才能保证$a^{x-1}​$和$k ​$都是整数。 那么对于$(a,p)&gt;1$且$(a,p)~|~b $，我们令原式变成 $$a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} (\bmod \frac{p}{(a,p)})$$的样子，如果此时$(a^{x-1},\frac{p}{(a,p)})=1$ 的话，我们就直接解 $$a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }(\bmod \frac{p}{(a,p)})$$这个方程即可。否则我们继续分解直至$(p’,a)=1$。 那么此时有个问题需要注意，就是如果们在解这个方程时，出现了 $$(a^{x-1}, \frac{p}{(a,p)})\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }$$的情况，那我们需要特判并return -1 ；另一种情况，如果我们出现了 $$a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1(\bmod \frac{p}{(a,p)})$$的情况，也需要特判并输出此$k$（此时同余式左边是$a^{x-k}$，因为$a^{x-k}\equiv1~(\bmod p)$所以直接输出$k$），不过也有可能不需要，完全看你写的$BSGS$能不能判断$x=0$的情况……一般情况下不能。 此时由于$\boldsymbol{p}$不再是素数，所以不能用费马小定理，需要我们用$exgcd$的方法求逆元，包括但不限于$\frac{b}{(a,p)}$的逆元和$a^{-im}$。 以下是完整版代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#define ll long longusing namespace std ; unordered_map&lt;ll, int&gt; H ;int N, M, P, ans ; // N ^x = M (mod P)inline ll gcd(ll a, ll b)&#123; if (!b) return a ; return gcd(b, a % b) ;&#125;inline ll expow(ll a, ll b, ll mod)&#123; ll res = 1 ; while (b) res = ((b &amp; 1)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= 1 ; return res ;&#125;inline ll exgcd(ll &amp;x, ll &amp;y, ll a, ll b)&#123; if (!b)&#123; x = 1, y = 0 ; return a ; &#125; ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; return t ;&#125;inline ll BSGS(ll a, ll b, ll mod, ll qaq)&#123; H.clear() ; ll Q, p = ceil(sqrt(mod)), x, y ; exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ; for (ll i = 1, j = 0 ; j &lt;= p ; ++ j, i = i * a % mod) if (!H.count(i)) H[i] = j ; for (ll i = b, j = 0 ; j &lt;= p ; ++ j, i = i * Q % mod) if (H[i]) return j * p + H[i] ; return -1 ;&#125;inline ll exBSGS()&#123; ll qaq = 1 ; ll k = 0, qwq = 1 ; if (M == 1) return 0 ; while ((qwq = gcd(N, P)) &gt; 1)&#123; if (M % qwq) return -1 ; ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ; if (qaq == M) return k ; &#125; return (qwq = BSGS(N, M, P, qaq)) == -1 ? -1 : qwq + k ;&#125; int main()&#123; while(cin &gt;&gt; N)&#123; scanf("%d%d", &amp;P, &amp;M); if (!N &amp;&amp; !M &amp;&amp; !P) return 0 ; N %= P, M %= P, ans = exBSGS() ; if (ans &lt; 0) puts("No Solution") ; else cout &lt;&lt; ans &lt;&lt; '\n' ; &#125;&#125; $\rm{0x03\quad Afterword}$今天才知道原来$BSGS$有两种写法qaq $zyf2000$好像和我写的$BSGS$对“大步”和“小步”的定义不是很一样…于是最后还是自己$\rm{yy}$的233 $\rm{Reference}$ $[1]$ :$zyf2000$的$blog$ $^{^{[\nearrow ]}}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式1.5·拆系数FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT2%2F</url>
    <content type="text"><![CDATA[上一篇多项式：多项式1·普通的FFT $\rm{0x01\quad Preface}$今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。 由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做抄完，所以就先整理地仓促一点。 首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接long long爆艹。 $\rm{0x02~Normal-Coefficient-Spliting~FFT}$首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成$$A_i = a_iM+b_i~(0\leq b_i &lt;a_i) \\B_i = c_iM+d_i~(0\leq d_i &lt;c_i)$$的形式。然后我们做乘法的话，会有$$A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i$$那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。 那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$ $$b_i\cdot d_i \approx \Theta(M^2)$$ $$a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)$$ $$(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor) $$ 那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 423333#define rr register #define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;const long double Pi = acos(-1) ;int R[MAXN], L, x ; long long Ans[MAXN] ;struct node&#123; long double x, y ; node (long double xx = 0, long double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;node H1[MAXN], H2[MAXN], H3[MAXN] ; int L1, L2, P, N, M ;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y); &#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y); &#125;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;void FFT(node *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; N; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; N; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125; if (flag &lt; 0) for (i = 0 ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + 0.5 ;&#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;signed main()&#123; rr int i, t ; cin &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = 32767 ; N = 1, t = L1 + L2 ; for (i = 0 ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ; for (i = 0 ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; while(N &lt;= t) N &lt;&lt;= 1, ++ L ; rep(i, 0, N) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1), FFT(C, 1), FFT(D, 1) ; rep(i, 0, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; FFT(H1, -1), FFT(H2, -1), FFT(H3, -1) ; for (i = 0 ; i &lt;= N ; ++ i) Ans[i] = ((long long)H1[i].x * M % P * M % P + (long long)H2[i].x % P + (long long)H3[i].x * M % P) % P ; for (i = 0 ; i &lt;= L1 + L2 ; ++ i) printf("%lld ", Ans[i]) ; return 0 ;&#125; 所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。 但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是—— $\rm{0x03~Conjugate~Optimization}$源自毛啸的《再探快速傅立叶变换》。 我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$$$\rm{P(x) = A(x) + iB(x)} \\\rm{Q(x) = A(x) - iB(x)}$$我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。 同时，令$\text{conj(x)}$表示对$x$取共轭。 那么会有$^{[5]}$：$$\begin{align}P’[k] &amp;= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}\\Q’[k] &amp;= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\&amp; = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\&amp; = \text{conj} \left( P’[n-k] \right)\end{align}$$好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。 那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：$$A’[k] = \frac{P’[k] + Q’[k]}{2} \\B’[k] = \frac{P’[k] - Q’[k]}{2i}$$哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$. 以下是共轭优化$FFT$的初号机： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 423333#define rr register #define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;int f[MAXN], g[MAXN] ;int R[MAXN], Len, x, Ans[MAXN] ;const long double Pi = acos(-1) ;struct node&#123; long double r, i ; inline node (long double xx = 0, long double yy = 0)&#123; r = xx, i = yy ; &#125; inline node Conj() &#123; return node(r, -i); &#125;&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;node H1[MAXN], H2[MAXN], H3[MAXN] ; int L1, L2, P, N, M ;node operator + (node J, node Q)&#123; return node(J.r + Q.r , J.i + Q.i); &#125;node operator - (node J, node Q)&#123; return node(J.r - Q.r , J.i - Q.i); &#125;node operator * (node J, node Q)&#123; return node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;void FFT(node *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; N; j &lt;&lt;= 1) for(k = 0; k &lt; N; k += (j &lt;&lt; 1)) for(l = 0 ; l &lt; j; ++ l)&#123; node T = w[N / j * l] ; T.i *= flag ; node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ; &#125;&#125;inline void Init(int L)&#123; rr int i ; while (N &lt;= L) N &lt;&lt;= 1, ++ Len ; for (i = 0 ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; 32767, f[i] &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; 32767, g[i] &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) w[i] = node(cos(Pi * i / N), sin(Pi * i / N)) ; for (i = 0 ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (Len - 1)) ;&#125;void MTT()&#123; node ia, ib, a1, a2, b1, b2 ; rr int i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ; FFT(A, 1), FFT(B, 1) ; for (i = 0 ; i &lt; N ; ++ i)&#123; k = (N - i) &amp; (N - 1), ia = A[k].Conj(), ib = B[k].Conj() ;//(ia,ib) = Q a1 = (ia + A[i]) * node(0.5, 0), a2 = (A[i] - ia) * node(0, -0.5) ; b1 = (ib + B[i]) * node(0.5, 0), b2 = (B[i] - ib) * node(0, -0.5) ; t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(0, 1), t2[i] = a2 * b2 ; &#125; FFT(t1, -1), FFT(t2, -1) ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ; for (i = 0 ; i &lt; N ; ++ i)&#123; q1 = (long long)(t1[i].r / N + 0.5) % P, q2 = (long long)(t1[i].i / N + 0.5) % P ; q3 = (long long)(t2[i].r / N + 0.5) % P, Ans[i] = ((((long long)q3 &lt;&lt; 30) % P + ((long long)q2 &lt;&lt; 15) % P + q1) % P + P) % P ; &#125;&#125;signed main()&#123; rr int i ; cin &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = 1 ; for (i = 0 ; i &lt;= L1 ; ++ i) f[i] = qr() % P ; for (i = 0 ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ; for (i = 0 ; i &lt;= L1 + L2 ; ++ i) printf("%d ", Ans[i]) ; return 0 ;&#125; $\rm{0x04\quad}$拼命卡常好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$） 然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）： 特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$: 好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点…… 于是考虑对共轭优化的进行大力卡常： 多次使用的非全局变量。使用register修饰符。 将$double$转换成为$long~double$ 。 减少取模次数。 从yjk那里偷来的$\rm{fread/fwrite}$ 一番操作之后，我们成功地卡到了第五页上…… 最后奉上最快的代码qwq： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// luogu-judger-enable-o2#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;#define MAXN 102333#define MAXM 272333#define rr register #define ll long long#define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;namespace IO&#123; const int ch_top=4e7+3; char ch[ch_top],*now_r=ch-1,*now_w=ch-1; inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x; &#125; inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w=' '; &#125;&#125;int R[MAXM], Len, x, Ans[MAXN &lt;&lt; 1] ;const double Pi = acos(-1) ;struct node&#123; double r, i ; inline node Conj() &#123; return node(r, -i); &#125; inline node (double xx = 0, double yy = 0)&#123; r = xx, i = yy ; &#125;//定义的Complex型是用来进行复数运算的 &#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; int L1, L2, P, N, M ;inline node operator + (const node &amp;J, const node &amp;Q) &#123; return node(J.r + Q.r , J.i + Q.i); &#125;inline node operator - (const node &amp;J, const node &amp;Q) &#123; return node(J.r - Q.r , J.i - Q.i); &#125;inline node operator * (const node &amp;J, const double &amp;Q) &#123; return (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;inline node operator * (const node &amp;J, const node &amp;Q) &#123; return node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;inline void FFT(node *J)&#123; rr node t ; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ; for(j = 1; j &lt; N; j &lt;&lt;= 1) for(k = 0; k &lt; N; k += (j &lt;&lt; 1)) for(l = 0 ; l &lt; j; ++ l)&#123; rr node T = w[N / j * l] ; rr node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ; &#125;&#125;inline void IFFT(node *J)&#123; reverse(J + 1, J + N), FFT(J) ; rr int i ; rr double qwq = 1.0 / N ; rep(i, 0, N - 1) J[i] = J[i] * qwq ;&#125;using namespace IO ;int main()&#123; fread(ch,1,ch_top,stdin); rr int i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; t = ((L1 = read()) + (L2 = read())), P = read(), N = 1 ; while (N &lt;= t) N &lt;&lt;= 1, ++ Len ; for (i = 0 ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; 32767, x &gt;&gt; 15) ; for (i = 0 ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; 32767, x &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) w[i] = node(cos(Pi * i / N), sin(Pi * i / N)), R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (Len - 1)) ; FFT(A), FFT(B) ; for (i = 0 ; i &lt; N ; ++ i)&#123; k = (N - i) &amp; (N - 1), ia = A[k].Conj(), ib = B[k].Conj() ;//(ia,ib) = Q a1 = (ia + A[i]) * node(0.5, 0), a2 = (A[i] - ia) * node(0, -0.5) ; b1 = (ib + B[i]) * node(0.5, 0), b2 = (B[i] - ib) * node(0, -0.5) ; t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(0, 1), t2[i] = a2 * b2 ; &#125; IFFT(t1), IFFT(t2) ; for (i = 0 ; i &lt;= t ; ++ i) write(((ll)(t1[i].r + 0.5) + ((ll)(t1[i].i + 0.5) % P &lt;&lt; 15) + ((ll)(t2[i].r + 0.5) % P &lt;&lt; 30)) % P) ; fwrite(ch,1,now_w-ch,stdout); return 0 ;&#125; 实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！ $\rm{0x00\quad Afterword}$嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？ 但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢…… 并且在学的过程中顺便认识了一个巨佬CMXRYNP，嘿嘿，也算不亏啦。 本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$. $\rm{Reference}$ $[1]$ :$lvzelong2014$的$blog$ $^{^{[\nearrow ]}}​$ $[2]$:无梦之梦的$blog$ $^{^{[\nearrow ]}}​$ $[3]$:$Cyhlnj$的$blog$ $^{^{[\nearrow ]}}​$ $[4]$:$litble$的$blog$ $^{^{[\nearrow ]}}​$ $[5]​$:$CMXRYNP​$的$blog​$ $^{^{[\nearrow ]}}​$ $[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式-FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式1·普通的FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT1%2F</url>
    <content type="text"><![CDATA[$\rm{0x01\quad Preface}$这篇文章初写于$7/1/2018$，是在陪同好友$yjk$与$wx$以及学长$rqy$一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍$FFT$并且写$MTT$，于是便有了这篇文章。 其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的orchidany特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。 但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。 $\rm{0x02\quad Convolution}$卷积$\boldsymbol{(Convolution)}$，准确来说是一种通过两个函数$\boldsymbol f$ 和$\boldsymbol g​$ 生成第三个函数的一种数学算子. 而广义上其定义为：$$\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}$$ 我们称$h(x)$是$g(x)$与$f(x)$的卷积。 而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到 $$A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}} $$其中$A(x)$和$B(x)$均为$N-1$次多项式比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有$2n+1$项。 $\rm{0x03\quad Dot~Method}$我们知道，原本的多项式是系数表示法，现在我们将其转化为点值表示法$(\boldsymbol{dot~method} )$。即我们可以把多项式$F(x)$转化为多项式函数$f(x)$，那么这个$n$阶函数就可以由$n+1$个点唯一确定。即$$f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)….(x_n,y_n)}$$那么$$\forall k,y_k = f(x_k)$$这是很显然的，并且这$n+$个点是随意选取的——只要求它们相异即可。 $\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$ 假设我们有两个关于$x$的$n+1$次多项式$A(x)$和$B(x)$，我们要对它的点值表达式进行乘法操作。由于结果有$2n+1$项，我们考虑补上一堆项，并对$$A(x) = {(x_0,y_0),(x_1,y_1)….(x_{2n},y_{2n})}$$ $$B(x) = {(x_0,y_0’),(x_1,y_1’)….(x_{2n},y_{2n})}$$ 做乘法可得 $$A(x)B(x) = {(x_0,y_0y_0’),(x_1,y_1y_1’)(x_{2n},y_{2n}y_{2n}’)}$$ 我们观察点乘法，它的时间复杂度达到了$\Theta(n)$，完全可以接受。那么不妨先看一下算法的大体思路： 对于每个因子多项式，选取$n+1$个点，得出点值表达式（复杂度$\Theta(n^2)$） $\longrightarrow$点乘法(时间复杂度$\Theta(n)$)——&gt;将得出来的$C(x)$的点值表达式再转换成系数表达式(复杂度$\Theta(n^2)$) 这就是$FFT$的大体流程。转化之后怎么没多快常数还大了 虽然其余部分的时间复杂度还是很麻烦的$O(n^2)$，但是都是可以优化成$O(nlogn)$的。 本质上的$FFT$包含$\boldsymbol{DFT}$（离散傅立叶变换）和$\boldsymbol{IDFT}$（逆离散傅立叶变换）实际上，$DFT$对应着的就是把系数表达式映射到点值表达式的过程，$IDFT$对应着的就是我们把点值表达式映射到系数表达式的过程。 $\rm{0x04~Base ~of~Optimization}$因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到$nlogn$的，那么总的时间复杂度，渐进意义下就是$O(nlogn)$的。 下面就让我们来看看如何优化： $\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$ $n$次单位复根是满足$\omega^n = 1$ 的复数$\omega$，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出$n$次单位根有$n$个这个结论——亦或者是用代数基本定理证，都可以。而又因为复数$\omega^n$在复数平面上的模都是一，所以相乘之后还会是一，那么所有的$\omega_i,1 \leq i \leq n$就会均匀分布在单位圆上，类似当$n = 8​$时它是这样的： 我们考虑欧拉公式： $$e^{ix} = cosx + isinx$$ 我们取$x =2\pi$，可以得到如下关系式：$$e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}$$ 们把此时的单位根称之为主次单位根，记作$$\omega_n = e^{\frac{2\pi i}{n}} $$ 那么对于其他的单位根，记作$$\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k &lt; n$$都是主次单位根的整次幂，也就是上图中的一圈。 诶，这个有啥用啊$QAQ$? 那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到$nlogn$的复杂度…… 那么我们先来看其支持其规模减半的引理： $\frak{Elimination ~Lemma\quad}$消去引理 引理：对任何整数$n \geq 0,k \geq 0,d &gt;0$,有$$\omega_{dn}^{dk} = \omega_n^k$$ $\mathcal{Proof.}$ 这个好像很好证的样子……代入定义可以获得$$\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k$$$\mathcal{Q.E.D.}$ $\frak{Binary~Lemma\quad}$ 折半引理 引理：对于任何大于$0$的偶数$n$，都有$n$个$n$次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合。 $\mathcal{Proof.}$ 我们可以由消去引理得到$$(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k$$那么 $$(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2​$$ $\mathcal{Q.E.D.}$ 那么接下来，如果对所有的$n$次单位跟平方一下，我们会发现$\frac{n}{2}$次单位根每个都恰好出现了两次——也就是说，在$n$个$n$此单位复数根的集合（朴素的集合，即不可重集）里，只有$\frac{n}{2}$个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。 那么把所有$n$单位根的平方画到一个数列上就是这样。 这个引理直接保证了我们求值的复杂度为$\Theta(n \log n)$ 而我们在代码实现中，不能直接得到$e$或者虚数$i$，所以这个时候求单位根的任务就交给了我们上文中提到过的欧拉公式。 $\frak{Sum~Lemma\quad}$求和引理 引理：对于任意$n&gt;0$且$k$不能整除$n$，我们都有$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0$$ $Proof.$ 由几何级数的求和公式（等比数列求和公式)$$\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}$$可得$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow \frac{(\omega_n^n)^k -1}{\omega_n^k -1} = \frac{(1)^k -1}{\omega_n^k -1}$$由于保证了$k$不可整除$n$所以分母一定不为$0.$ $\mathcal{Q.E.D}$ $\rm{0x05\quad DFT \to FFT}$那么我们在了解完单位复数根之后，便可以正式地对$DFT$给出定义与操作方案了。 $DFT$ 对于我们已知的一个多项式$$A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}$$在$\omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1}$处的取值，我们可以假定$n$是$2$的幂，因为即使它本身不是$2$的幂，我们也可以通过向高次幂补值为$0$的项来解决这个问题。而补足$2$的幂的目的，就是为了在$FFT$分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。 那我们现在会有一个$A$的向量组$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$，对于$k = 0, 1, 2, \cdots n -1$，定义$y_k$如下：$$y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}$$，那么向量$$\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}$$就称作系数向量$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$的离散型傅立叶变换（$\boldsymbol{Discrete Fourier Transformation}$）。 嗯，这个离散型我们可以由点乘法联想意会一下：本来$A(x)$是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容$qwq$），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。 $FFT$优化$DFT$ 在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为$O(n^2)$，这是朴素算法。而我们只需要用一种被称作快速傅立叶变换（$\boldsymbol{Fast Fourier Transformation}$）的方式，就可以将其时间复杂度压缩成$O(nlogn)$。而在这里我们就用到了刚才证明的引理——折半引理。 我们考虑将原来的多项式$$A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}$$重定义成两个次数为$\frac{n}{2}$的小多项式$A^{[0]}(x)$和$A^{[1]}(x)$： $$A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1}$$ $$ A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1}$$ 那么也就是说，$A^{[0]}(x)$存储的是所有偶数位（二进制位最后一位是$0$），而$A^{[1]}(x)$存储的是所有的奇数位（二进制位最后一位是$1$），那么有下式：$$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$$那我们求$A(x)$在单位根们$\omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1}$处的值，就变成了先求出$A^{[0]}(x^2)$和$A^{[1]}(x^2)$的值，然后根据上式进行合并即可。 而显然的是，根据折半引理，我们根本不需要$O(n)$求，而是通过数据规模不断减小使之成为$O(\log n)$。于是，我们成功通过$FFT$优化了求值的复杂度。 那么同时对于另一边，我们可以根据 $$A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})$$ 得到 $$A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})$$ 从而有伪代码： 1234567891011121314151617181920212223int Lim = 1, N, M ;function FFT(int lenth, complex *A, int flag)&#123; IF (Lim == 1) return ; complex A0[lenth &gt;&gt; 1], A1[lenth &gt;&gt; 1] ;//分成两部分 for(int j : 0 to lenth by_grow 2) A0[j &gt;&gt; 1] = A[j], A1[j &gt;&gt; 1] = A[j + 1] ; FFT(lenth &gt;&gt; 1, A0, flag) ; FFT(lenth &gt;&gt; 1, A1, flag) ; complex Wn = unit(,) , w = (1, 0) ;//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂 /*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/ for(int j : 0 to (lenth &gt;&gt; 1) by_grow 1 with w = w * Wn)&#123; A[i] = A0[i] + A1[i] * w ;//应用公式，下同 A[i + (lenth &gt;&gt; 1)] = A0[i] - A1[i] * w ; //顺便求出另一半，由折半引理可显然。 &#125; &#125; function Main&#123; input(N), input(M) ; for(i : 0 to N by_grow 1) =&gt; input(A) ; for(i : 0 to M by_grow 1) =&gt; input(B) ; while(Lim &lt; N + M) Lim &lt;&lt;= 1 ;//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分） FFT(Lim, A, 1) ;//两遍FFT表示从系数化为点值 FFT(Lim, B, 1) ; for(i : 0 to Lim by_grow 2) =&gt; A[i] *= B[i] ;//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq &#125; 以上是基于$pks$标准下的伪代码你可以试试在c++标准下运行，其中$for$循环部分，$grow$表示当前循环变量的单次增量，之后带有$with$表示每次循环结束都会进行的运算（下同 嗯，这就是求值的方法，好像很$nice$地达到了$O(n \log n)$ $FFT$优化$IDFT$ 上文中我们曾经提及过的范德蒙德矩阵可以放到这儿用： $\begin{vmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \newline 1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; w_n^{n-1} \\newline1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n-1)} \newline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)(n-1)} \newline \end{vmatrix}$ $\begin{vmatrix} a_0 \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix}$ = $\begin{vmatrix} y_0 \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix}$ 那为了求出我们的$\vec{a} = {a_0, a_1 \cdots ,a_{n-1}}$我们应该让刚刚求值算出的$\vec{y}$乘上我们$\vec{V}^{~-1}$（$\vec{V}$的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下： 推论：对于$j,k = 0,1, 2 \cdots n-1,V_n^{-1}$的$(j, k)$处的值为$\omega_n^{-kj}/n$ $Proof.$ 我们考虑反向证明，已知$V_n’$是一个$(j,k)$处值为$\omega_n^{-kj}/n$的、与$V$形态相同的矩阵，那我们只需要证明$V’ \cdot V = I_n$即可，其中$I_n$是$n$阶单位矩阵，即主对角线都是$1$，其余位置上是$0$的矩阵。 那么我们考察$V’ V$中的元素$(i, j)$，有如下的式子$$V’V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}$$ 由求和引理当且仅当$i=j$时其值为一，其余的时刻均为零，所以有$V’V = I_n$ $\mathcal{Q.E.D}$ 那么我们把我们刚刚求出来的逆矩阵$V^{-1}$美化一下，提出每一项所除的$n$，可以得到$IDFT$可以如此计算：$$IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]$$诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当$flag=1$时，他是正向$DFT$；当它等于$-1$时，它是逆向的$ IDFT$。这可以让我们通过这一个函数解决两个过程。我们只需要用$y$替换$a$，用$\omega_n^{-1}$替换$\omega_n$，其余的没什么差别，于是……时间复杂度还是$O(n \log n)$的! 123456789101112131415161718192021void FFT(int Lim,complex *A,int flag)&#123; if(Lim == 1) return ; complex A0[Lim &gt;&gt; 1], A1[Lim &gt;&gt; 1] ; for(int i = 0; i &lt;= Lim ; i += 2) A0[i &gt;&gt; 1] = A[i], A1[i &gt;&gt; 1] = A[i+1] ; FFT(Lim &gt;&gt; 1, A0, flag) ; FFT(Lim &gt;&gt; 1, A1, flag) ; complex unit = (complex)&#123;cos(2.0 * Pi / Lim) , flag * sin(2.0 * Pi / Lim)&#125;, w = complex(1, 0) ;//欧拉公式 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; A[i] = A0[i] + w * A1[i] ; A[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i]; &#125;&#125;int main()&#123;......................FFT(A, 1), FFT(B, 1) ;for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;FFT(A, -1) ;......................&#125; 好的，现在嘛……可以考虑撒花花啦！因为我们的$FFT$实际上已经结束了！$But$，这个递归版本的$FFT$由于牵扯到$sin/cos$的运算、$double$、递归时的入栈出栈（底层），所以常数特别的大$emmmmm$，那么—— $\rm{0x06~Iterative~ Optimization}$我们现在要引出的就是迭代版的$FFTqwq$ · $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$$emmm$先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：1234 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; a[i] = A0[i] + w * A1[i] ; a[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i];&#125; 我们会发现……$\omega \cdot A^{[1]}[i]$被执行了两次，所以我们不妨用个变量记录它：12345 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; int temp = w * A1[i] ; a[i] = A0[i] + t ; a[i + (Lim&gt;&gt;1)] = A0[i] - t ;&#125; 嗯，这就是全部的优化啦！那么，FFT，完！ $qwq$这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好$\mathcal{QAQ}$。好吧，说这个的原因，只是为了引出我们关于蝴蝶操作的定义： 我们定义$\omega_n^k$为旋转因子，那么每一次我们先将$y_k^{[1]}$与旋转因子的乘积存储在一个变量$t$里，并在$y_k^{[0]}$增加、减去$t$的操作称为一次蝴蝶操作。 说白了，蝴蝶操作是一次$O(2)$的求出$A^{[0]}_k$与$A^{[1]}_k$的操作。 我们首先考虑按照递归的思路，将$FFT$的分治流程刻画一下： 我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下： $step 1$ 成对地取出儿子节点，用蝴蝶操作计算出其$DFT$。$step 2$ 用这一步的$DFT$替换之前的；$step 3$ 直到我们迭代到根节点为止，否则返回$step 1$ 而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层$for$，先枚举区间长度（1，2，4，8……），第二层枚举长度为$j*2$的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间$DFT$的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并： 12345678910for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123;//枚举区间长度，从小区间到大区间依次合并。 node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123;//两段区间两段区间的枚举，用于合并 node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123;//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。 node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;//一次蝴蝶操作 &#125; &#125; &#125; 嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在$DFT$的时候，为了保证时间复杂度是$\Theta(\log n)$，我们曾经进行过一次$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是$0,1,2,3,4,5,6,7$，但是迭代版的$FFT$却需要的顺序应该跟叶子结点的顺序吻合，即$0, 4, 2, 6, 1, 5,3,7$。所以—— · $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$ 这个嘛……我们可以选择打个表观察：原来的序号 $0 1 2 3 4 5 6 7$现在的序号 $0 4 2 6 1 5 3 7$原来的二进制表示 $000 001 010 011 100 101 110 111$现在的二进制表示 $000 100 010 110 100 101 011 111$ 诶，二进制好像是反序的嗷~~这便是我们的最后一个$trick$，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在$FFT$之前$swap$一遍即可。 嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：1for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; 呃，这个二进制计算自己推一下就好。 那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。真开森啊 最后附迭代版的代码(我写的常数好像有点儿大$QAQ$) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define il inlineusing namespace std ;int N, M, K ;const int MAXN = 3000100 ;const double Pi = acos(-1.0) ;int i, j, k, l, Lim = 1, L, R[MAXN] ; struct node&#123; double x, y ; node (double xx = 0, double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN] ;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);&#125;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y);&#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y );&#125;il int qr()&#123; int k = 0, f = 1 ; char c = getchar() ; while(!isdigit(c))&#123;if(c == '-') f = -1 ;c = getchar() ;&#125; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48 ,c = getchar() ; return k * f ;&#125;void FFT(node *J, int flag)&#123; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ;//前面的if保证只换一次 for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125;&#125;int main()&#123; N = qr(), M = qr() ; for(i = 0; i &lt;= N; i ++) A[i].x = qr() ; for(i = 0; i &lt;= M; i ++) B[i].x = qr() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1) ; for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ; FFT(A, -1) ; for(i = 0; i &lt;= N + M; i ++) printf("%d ", (int)(A[i].x / Lim + 0.5)) ;//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 return 0 ;&#125; 啊……那就撒花花吧！！ $\rm{0x00\quad Afterword}$以下是原尾语，保留了下来： 嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短这么容易背过。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天$qwq$，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他$DALAO$比对审核、或者缠着$rqy$问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。 以下是温馨提示： 好多自己当初不理解的地方在代码里就只有半行qaq 三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的 真 · 结束语： 其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去现在看这个算法，真是简单的一匹啊，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。 $\rm{Reference}$ $[1]$ :$rvalue$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :算法导论 $^{^{[\nearrow]}}$ 提取码: txs2 [3]*：鸣谢rqy $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式-FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想五·手中没有红玫瑰]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 今天下了一天的雪。 我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。 “情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。 雪真美啊。 var ap = new APlayer({ element: document.getElementById("aplayer-zyUKntos"), narrow: false, autoplay: false, showlrc: false, music: { title: "空も飞べるはず", author: "定能飞向天空", url: "古谷拳-空も飛べるはず (定能飞向天空).mp3", pic: "/2019/02/14/随想五·情人节/ggq.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 早恋？ “严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”…… 说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。 直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了： 小学五年级的时候，我喜欢班上的一个女孩子。那时候想的很多。比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。 如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。 我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。 于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。 后来初三开学，我收到了一封信。来自那个小学时候喜欢的女孩子。信的末尾有一句话：我准备报考X中，你要不要一起？ 我的手不受控制地颤抖。烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。 为什么要读书呢？16岁的我获得了唯一的答案——为了和喜欢的人在一起。我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。是啦，他们总以为自己很懂。 很多人说，小孩子不要谈感情，因为反正不会有结果。是，的确不会有结果。就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。 可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。爱过一个人，是我少年时最大的幸运。 所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。 有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。 我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。 他们轻蔑地说，小孩子懂什么恋爱。好，那我们来看看大人们有多么懂爱情。相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。 所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？ 还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。 可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？你们是真的有的是以后，还是早已离散在人海？而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？ 很久以后我们终于知道，大人都在说谎。少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。 如果有还在上学的读者看到这里，请记住，人生没有那么多以后。有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。 至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。 我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。 ” 很多人即使只见过一面，已经算见过了最后一面。“ 十八岁前不早恋，这辈子都来不及早恋。你的人生看起来很长，每一秒都无法挽回。 虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。 我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。 当然，也是给我自己讲。 关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。 现在不一样了吧，一生，多长啊。 我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。 没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。 等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？ 不，我觉得不是。 我是在亵渎一种感情，是在侮辱一个人。 爱从来都是无私地付出，而不是拼命的占有啊。 我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。 你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊， 都不过是拼命地想被爱而已。 var ap = new APlayer({ element: document.getElementById("aplayer-vbPwgLwu"), narrow: false, autoplay: false, showlrc: false, music: { title: "clammbon-ソナタ", author: "(奏鸣曲)", url: "clammbon-ソナタ (奏鸣曲).mp3", pic: "/2019/02/14/随想五·情人节/zmq.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊…… 孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。 我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。 下面是歌词： 我喜欢暖冬的太阳我喜欢初春的青草我喜欢午后的庭院和一旁发呆的秋千我喜欢仲夏的冰沙我喜欢清秋的明月良宵的夜空 漫天星辰我喜欢雨后的青蛙我喜欢山前的杏我喜欢周三的傍晚被霞光亲吻的水族馆我喜欢成群的野我喜欢凌乱的书架清风的露台远处的灯海我喜欢 走在无人的九十六号公路我喜欢 木村拓哉长长的头发我喜欢 无尽田野上奔跑的麋鹿我喜欢 外婆门前的榕树我喜欢母亲的便当喜欢父亲的胡渣我喜欢八月的夜晚还在营业的游乐场我喜欢放学的铃铛我喜欢停电的夜晚点一对蜡烛 在幽静的玄关我喜欢 城市尽头那远远的青山我喜欢 热气球飞上西边的天空我喜欢 清晨的石板路雾腾腾的早餐店 阿公的桂花糕我喜欢 每一朵暮云 每一株绿树我喜欢你，你应该，也知道我喜欢你，你应该，也知道 优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句—— 我喜欢你，你应该，也知道. 我喜欢你，你应该，也知道。 很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。 你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。 有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。 我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。 我喜欢你，你应该，也知道。 var ap = new APlayer({ element: document.getElementById("aplayer-BTMHwKNT"), narrow: false, autoplay: false, showlrc: false, music: { title: "我喜欢", author: "彩虹合唱团", url: "上海彩虹室内合唱团-我喜欢 (合唱版).flac", pic: "/2019/02/14/随想五·情人节/wxh.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？ 如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。 我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。 相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。 $19/2/14$ 本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。 那么就补一个深沉一点的结尾吧。 我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。 但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧…… 路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。 可是面对着无奈的明天的我，什么都不能做。 雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。 var ap = new APlayer({ element: document.getElementById("aplayer-NHHkvBnJ"), narrow: false, autoplay: false, showlrc: false, music: { title: "遇见", author: "孙燕姿", url: "孙燕姿-遇见.flac", pic: "/2019/02/14/随想五·情人节/yj.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019赛季最后的随想/NOIP2018游记·启示录]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 他看着眼前的屏幕，静静地发呆。 他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。 刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。 “希望别考期望吧，嘿嘿……”他心里这么想着。 晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。 他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。 从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。 早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$Mac$版，连硕鼠也不能用了，便只得作罢。 终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。 “大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。 看了看天空，他上了大巴车。 ”昌邑一中真大啊“这是他到这儿后的第一想法。 到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。 宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。 他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。 $\rm{Day~1}$突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。 考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。 入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。 $T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。 $T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。 $T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。 期望得分$100pts + random(0,100)+random(10,20) $ $Luogu$数据$100pts + 65pts + 15pts = 180pts$ 听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。 下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。 考挂了，他想到。 这世界上似乎就他一个不会$T2$的人。 他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。 虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。 或许他期望着明天能翻盘？ 晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。 $\rm{Day~2}$今天他没有带什么吃的。 $T1$只会$60$分，转眼去看$T2$ 写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。 $T3$连想的时间都没有。 退役了。 他很伤心。 回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。 他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。 他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。 其余的都考炸了。 初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。 他一开始也并不怎样，没啥感觉。 直到那天下午。 他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。 兴奋的他去奥赛室看成绩。 学长看错了。 他的两个同僚都是$370/380+$的样子。 只有他不到. 其他人的分数也比他高。 他大概全校第十几吧。 他感到了绝望。 本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。 他注定是失败者。 他伤心极了。 他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。 他觉得一年来，他一事无成。 或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。 他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。 他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。 期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。 这似乎是实验部该有的成绩。可是跟他没有关系。 特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。 太失败了。 太失败了。 大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。 我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。 这真是从未有过的轻松的感觉。 或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。 我感到无比的轻松。 以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。 我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。 嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。 但是其实山东没有开展$AO$的，不过我想当这个第一人。 我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。 到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。 在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。 没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。 我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好的话+强大的理解能力=rqy这个等式也是成立的。 当然，不属于我啦。 虽然现在很不甘……但是没有办法，大概这就是人生吧。 如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。 听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。 总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么： 做什么事情，都要先从自己的灵魂出发，而不是从利益出发。之类的吧。 我想引用一句（段）话，来自《本杰明巴顿奇事》： 有些人，注定可以于河边闲坐。有些人被闪电击中过七次。有些人对音乐有着非凡的天赋。有些人是艺术家。有些人是游泳健将。有些人懂得制作纽扣。有些人懂莎士比亚。有些人是妈妈。还有些人，是舞者。我们注定要失去我们所爱的人，要不然我们怎么知道他们对我们有多么的重要。 后会有期。 $\mathscr{THE~~~END}$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笙上月Project]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%99%E4%B8%8A%E6%9C%88%2F</url>
    <content type="text"><![CDATA[准确来说这是一个$project$，专门以$art/painting$、$music$为主。 现在已经在原博客上更了两期了，因为实在懒得再去捯饬图片的事儿，于是就直接链过来好了： ArseniXC &amp; 莫奈 var ap = new APlayer({ element: document.getElementById("aplayer-dEmNtBgh"), narrow: false, autoplay: false, showlrc: false, music: { title: "人啊", author: "徐佳莹", url: "徐佳莹-人啊.mp3", pic: "/2019/02/14/笙上月/rena.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>笙上月</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#536Div2の题解(E&F)]]></title>
    <url>%2F2019%2F02%2F08%2FCF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F%2F</url>
    <content type="text"><![CDATA[$0x01~~Preface$$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕 这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233 简单总结一下前面四道题$\color{red}{Link}$： A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次身败名裂XD B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树） C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。 D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞 下面两道题就好像不是那么水了qaq $0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$$\color{red}{Link}$简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。 最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。 $\mathfrak {Solution}$呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。 之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。 Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXM 233#define MAXN 100010using namespace std ;struct time_node&#123; int mark, d, w ; bool operator &lt; (const time_node &amp;T) const &#123; return w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d); &#125;&#125; base[MAXN] ; map &lt;time_node, int&gt; M_set ; vector&lt;time_node&gt;Time[MAXN] ; long long Ans ;int N, M, K, A, B, C, D, i, j ; long long dp[MAXN][MAXM] ; int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; memset(dp, 63, sizeof(dp)) ; for (i = 1 ; i &lt;= K ; ++ i)&#123; scanf("%d%d%d%d", &amp;A, &amp;B, &amp;C, &amp;D), Time[A].push_back((time_node)&#123;1, C, D&#125;) ; Time[B + 1].push_back((time_node)&#123;2, C, D&#125;) ; &#125; for (i = 1 ; i &lt;= N ; ++ i)&#123; register int tot = Time[i].size() ; for (j = 0 ; j &lt; tot ; ++ j) if (Time[i][j].mark == 1) ++ M_set[Time[i][j]] ; else M_set[Time[i][j]] &gt; 1 ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ; if (M_set.size()) base[i] = (*M_set.begin()).first ; else base[i] = (time_node)&#123;0, i, 0&#125; ; &#125;dp[0][0] = 0, Ans = dp[1][1] ; for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = 0 ; j &lt;= M ; ++ j)&#123; j &gt; 0 ? dp[i][j] = min(dp[i - 1][j - 1], dp[i][j]) : 1 ; dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - 1][j] + base[i].w) ; &#125; &#125; for (i = 0 ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$$Link$ 简单来说就是给你一个序列$F_x$的$k$项的递推法则（幂次积式递推），在认定前$k-1$项都满足$F_x=1$的基础上给定$F_n$，让你倒推出$F_k$来。 $\mathfrak {Solution}$恕我直言…这道题我考场上是不可能会的…（已扑街 首先我们观察一般形式：$$F_x = \begin{cases}1~, &amp;\rm{x&lt;k} \newline ?~, &amp; \rm{x = k} \newline \prod\limits_{j=1}^kF_{x-j}^{b_j} , &amp; \rm{x&gt;k}\end{cases}~ (\mod 998,244,353)$$ 大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个我没想出来、想出来也不会用的$Idea​$，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。 次我们选择$998,244,353​$的原根作为底数。因为原根有一个很优美的性质，就是$p​$的原根的幂次可以遍历$p​$的简化剩余系。而由$NTT​$里得到的经验，这个模数的最小原根是$3​$。 原根的基本定义：设$g$为$p$的一个原根，则满足：$$𝑔^{𝑝−1} \equiv 1(\mod p)$$$$∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$ 之后呢？之后我们就找一个函数$q(x)$，令$$g^{q(x)} \equiv x(\bmod p)$$ 目的是为了构造一个$l_x = q(F_x)$，使得等式$$g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}}( \mod p)$$成立。而比较特殊的是，因为$F_1$~$F_{k-1}$都为$1$，所以$l_i=0\quad(1 \leq i &lt;k)$ 。那么也就是说对于指数上的$l_x$满足$$l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i}( \mod p-1)$$这就是一个线性递推的形式了。 此处有个小$trick$，就是我们为了防止$l_x$过大，我们需要对它取模，此时直接依据费马小定理，取$p-1$做模数即可。 接下来是一个十分巧妙的$Idea$，我们虽然不知道$l_k$，但是我们可以知道$l_k$到$l_n$是如何变化的。观察题目性质，$$l_j = \omega_j l_k \mod(p-1)$$其中的$\omega_j$是一个关于$b_k$的常量因子。证明也比较简单，因为$l_i=0\quad(1 \leq i &lt; k) $是显然的。 那么我们只需要做一下矩阵快速幂——幂次上是$n-k$——就可以得出$\omega_n$来。而我们的$l_n$是可以通过对原根$g$求$BSGS$解得的。那么现在就是$$l_k\omega_n = l_n \mod (p-1)$$移个项可以得到$$l_k \omega_n + t(p-1)= l_n$$由于原题让求的是最小的正整数解，所以应用一下$exgcd$判一下是否有解就解决了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 108#define LL long long#define Mod 998244353using namespace std ;map&lt;LL, LL&gt; Hash ;int N, T, base[MAXN] ;LL Ft, Hn, Xs, Ans, X, Y, G ; struct Matrix&#123; LL M[MAXN][MAXN] ; void clear() &#123; memset(M, 0, sizeof(M)) ;&#125; void reset() &#123; clear() ; for (int i = 1 ; i &lt;= N ; ++ i) M[i][i] = 1 ; &#125; Matrix friend operator *(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) for (int k = 1 ; k &lt;= N; ++ k) Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - 1) ; return Ans ; &#125; Matrix friend operator +(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % (Mod - 1) ; return Ans ; &#125;&#125; ; inline Matrix expow(Matrix T, LL P)&#123; Matrix Ans ; Ans.reset() ; while (P)&#123; if (P &amp; 1) Ans = Ans * T ; T = T * T, P &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline LL bsgs(LL x, LL y, LL p)&#123; LL P = ceil(sqrt(p - 1)), Q = expow(x, -P + 2 *(p - 1), p) ; for (LL i = 1, j = 0 ; j &lt;= P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i)) return Hash[i] + j * P ;&#125;inline LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(!b) &#123;x = 1, y = 0 ; return a ;&#125; LL t = exgcd(b, a % b, y, x) ; y -= a / b * x ; return t ;&#125;inline LL qr()&#123; register LL k = 0, p = 1 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') &#123; c = getchar() ; if (c == '-') p = -1 ;&#125; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k * p ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) base[i] = qr() ; cin &gt;&gt; T &gt;&gt; Ft ; Matrix lab ; lab.clear() ; for (i = 2 ; i &lt;= N ; ++ i) lab.M[i][i - 1] = 1ll ; for (i = 1 ; i &lt;= N ; ++ i) lab.M[i][N] = 1ll * base[N -i + 1] ; lab = expow(lab, T - N), Hn = bsgs(3,Ft, Mod), Xs = lab.M[N][N] ; G = exgcd(Xs, Mod - 1, X, Y) ; if (Hn % G) return puts("-1"), 0 ; X = (X % (Mod - 1) * (Hn / G) % (Mod - 1) + Mod - 1) % (Mod - 1) ; Ans = expow(3, X, Mod) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x00\quad$后记说实话，这是第一次做整套CF的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A$~$E$都还好，但是$F$实在是……看题解都要想半天的那种……尤其是这个解离散方根的东西……哇塞恶心死了从没听说过还有这东西qaq rqy说$F$题是省选一轮的难度——虽然没说是$D$几$T$几，但我感觉他的语气不像是在说一道很难的题…… 完了，要跪了。 奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。 ​ ——（pks《春日绝句》）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>动态规划-普通DP</tag>
        <tag>线性代数-矩阵</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lagrange Formula·拉格朗日插值法]]></title>
    <url>%2F2019%2F02%2F07%2FLagrange-Formula%2F</url>
    <content type="text"><![CDATA[$\rm{0x01~~} Preface$插值($Interpolaton$) 在多项式域中可以看做是求值$(Evaluation)$的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。 而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明—— $\rm{0x02}~~\rm{Proof}$$Proof ~of~Existence$​ 我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。 ​ 首先我们需要构造一个对于第$i$个二元组的特殊多项式$L_i(x)$，满足$$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \newline 0, &amp; \rm{i \neq j}\end{cases}$$ 那么我们所求的多项式$F(x)​$就可以写作$$F(x) = \sum L_i(x_i)\cdot y_i​$$这个式子保证了我们对应的$n​$个二元组，$F(x)=y​$恒成立。 ​ 那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出$$L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)$$其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数$$k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}$$那么$$L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$从而$$F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$ $\mathcal{Q.E.D.}$ $Proof~of~Uniqueness^{[1]}$​ 我们接下来要证明的是多项式$L_i(x)​$的唯一性 ​ 我们假设同时有两个实数域上的$n-1​$次多项式$L_1(x),L_2(x)​$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}​$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2​$在取所有的$x_i​$时，其值均为$0​$。那么一定会有多项式$$L’(x) = \prod\limits_{i=1}^{n}(x - x_i)​$$满足$$L’|L_{\Delta}​$$ 其中$|​$表示多项式整除。但是我们知道，对于$L’​$这个多项式，其次数为$n-1​$；而对于我们所定义的$L_i(x)​$，均为$(n-2)​$次的，从而$L_{\Delta}​$也是$n-2​$次多项式。所以我们可以得出$$L_{\Delta} = 0​$$从而有$$L_1=L_2​$$ $\mathcal{Q.E.D.}$$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$1234567891011121314151617181920212223242526272829303132333435363738题号：Luogu4781#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 2020#define LL long long#define Mod 998244353using namespace std ; LL Ans, xs ;int N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;inline LL expow(LL A, LL B)&#123; LL res = 1 ; while (B)&#123; if (B &amp; 1) (res *= A) %= Mod ; B &gt;&gt;= 1, (A *= A) %= Mod ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld%lld", &amp;xv[i], &amp;yv[i]) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; t = 1 ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (xv[i] - xv[j] + Mod)) %= Mod ; &#125; t = expow(t, Mod - 2) ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (T - xv[j] + Mod)) %= Mod ; &#125; (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;// cout &lt;&lt; Ans &lt;&lt; endl ; &#125; printf("%lld", Ans) ; return 0 ;&#125; $\rm{Reference}$ $[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 $^{^{[\nearrow ]}}$ $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Math - Lagrange Formula</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群论入门]]></title>
    <url>%2F2019%2F02%2F06%2F%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。 群$1~)~$群的定义比较简单的来讲，所谓群$(\rm{group})$指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质： 我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算： $Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$那么也就是说的直白点吧，对所有的元素，做完该群所带有的带有结合律的运算之后，所得结果仍然属于该群且一定存在单位元，对于每个元素存在运算逆元。 那我们不妨定义一些其他的： 阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。 半群：满足封闭性和结合律的群。 有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶 结合几个例子来解释一下： 比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)​$$ $$(R\setminus{0}~, ~\cdot)​$$$$ (C\setminus{0}~,~\cdot)​$$ 他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。 或者一个好玩儿的乘法群$$((1, -1)~~, ~~\cdot)$$或者是所有非奇异的$n$阶矩阵也可以组成一个乘法群。 或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断是否成群,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。 $Extra Things :$ 以下是两种复合抽代数据结构（名字自己起的$233$）： 环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。 域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群举例子 ：$Q,R,C$即有理数域、实数域和复数域。 好的，那我们尝试证明两个命题： $Proposition1~~~~$一个群中的单位元唯一设有两个单位元$e_1,e_2$ 那么$e_1=e_1e_2=e_2$，其实是一个$233$ $Proposition2~~~~$群中元素的逆元唯一以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$ 显然也是同一个。 那么此时我打算整理一个群的共性特征：$$(ab)^{-1}=b^{-1}a^{-1}$$ 很显然，证明如下：$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$ 提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心 那么之后我们讨论周期 对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$ $o(a)$表示最小正整数，使得$a^{o(a)}=e$ $2~)~$子群及衍生本节所指“群”没有特别说明便均为有限群 不妨先给出子群的浅显版定义： 如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示那么从而我们可以定义生成子群这个东西： 生成子群：若$S \subseteq G​$， 并且对于运算$C​$而言，$(G,C)​$也是一个群，那么就称$G​$为集合$S​$在运算$C​$下的生成子群。集合$S​$的生成子群用$&lt;​$$S​$$&gt;​$表示 这之后我们就可以定义陪集这个概念 陪集一般上包含左陪集和右陪集。 左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。$233$也可以叫做傍集或者旁系之类的~ 那么我们这个地方先只研究右陪集$233$ $Lemma1:$我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的群中元素数量。 这个其实比较显然，因为事实上群都是定义在非可重集上面的。 较为严谨的证明如下： $Proof.$ 对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$ 反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾 对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$ $Lemma2:$之后我们再证明一些好玩儿的： 命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ 看起来好像不是那么好玩…… $Proof.$ 若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$ 若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$ $hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$ 因此$H_a=H_b$ 那么我们还可以有一个推论： 若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$ $Proof.$ 假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾 从而还可以有个定理（$Lagrange$定理）： 由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么 $$|G|=|H|\cdot [G:H]$$ 也就是说$|H|$是$|G|$的约数。 这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。 但是其实这是个很伟大的定理$233$ 好的，那么从而就会有一些神奇的推论： 推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ $Proof.$ 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ 推论二：对任意的$a \in G,a ^{|G|} = e$ $Proof.$ 比较显然，由推论一可知。 推论三：若$|G|$为素数，则$G$是循环群 $Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。 接下来我们真的要去做些好玩的了~ 定理$1$·$Fermat$小定理如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $ $Proof. $考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知： $$\forall a\in G, a^{p-1}=1(\mod p)$$ 定理2·$Euler$定理$a^{\phi(n)}=1 (\mod n)$ $Proof.$考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法 那么会有$|G|=\phi(n)$，从而有： $$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$ 没错，证明十分的简洁美观。 作者被这种神奇的证明给折服了$stO$.]]></content>
      <tags>
        <tag>抽象代数-群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS-Junior·BSGS算法初探]]></title>
    <url>%2F2019%2F02%2F06%2FBSGS-junior%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ $\mathcal{Preface}$$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法。当然也会被叫做拔山盖世、北上广深算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : 给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x$, 使得$a^x≡ b~(\mod p)$ 而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)​$，并且我们还知道$a^0=1≡1 ~(\mod p)​$，所以我们可以得出一个断言： 如果方程$a^x≡ b~(\mod p)​$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))​$中 $\qquad \qquad(1) ​$ 此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。 之后我们将以此为基础进行类似分块的操作—— $\rm{0x02~~Baby~Step~Giant~Step}$首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：$$a^{i\cdot n+j}≡ b~(\mod p)$$移一下项就可以变成$$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$$那么现在我们的策略是算出所有$a^j$来，在$\mod p$ 意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做小步$(\rm{Baby~Step})$， 称右边枚举$b \cdot a^{-i\cdot n}$叫做大步$~(\rm{Giant~Step})$。 那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。 123456789101112131415161718inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "-1" &lt;&lt; endl ;&#125; 其中细节还是有的： 计算sqrt时要上取整。 我们在求$a^{-i\cdot n}​$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。 两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$ 算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的Q就会=0，从而在下面的第二个循环处出错——我们的hash[i]和j不能同时为$0$，从而输出错误的答案。 $\rm{0x03}$ 例题$T1~$$LuoguP4028$ 裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;tr1/unordered_map&gt;#define LL long longusing namespace std ; using namespace tr1 ; int T ;LL A, B, M, P, Q ; unordered_map &lt;LL, LL&gt; Hash ;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ;&#125;inline LL qr()&#123; LL res = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res ;&#125;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; M = qr(), A = qr(), B = qr() ; if ((!(A % M == 0 &amp;&amp; B))) bsgs(A, B, M) ; else cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ; &#125; return 0 ;&#125; $T2~$ $TJOI2007~Cute~Prime​$ 最裸最裸的、无特判的题……可以水一下双倍经验。 $\mathfrak{writter: pks}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT's Junior Intro]]></title>
    <url>%2F2019%2F02%2F04%2FLCT-s-Junior-Intro%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护森林连通性的。 嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。 但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转$Luogu3391$，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。 也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。 $\rm{0x02}$ 闲话 · 关于$\rm{splay}$道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢 历史的重任最后落到了$\rm{splay}​$的身上。然后$\rm{splay}​$他居然： 他甚至还： …… 好吧，由于某些rqy也不知道的原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$ $\rm{0x03}$ $LCT$的思路和基础操作一 主要思路主要思路嘛……大概是基于实链剖分的操作。 朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。 而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。 实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。 那么接下来我们来看一个$LCT​$是如何定义的: 首先，一棵$LCT​$管控的是一对分散的点，点以几棵分散的$splay​$的形式聚集。起初整棵$LCT​$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access​$、$makeroot​$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT​$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。 实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别： 虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。 实边是完整的双向存储。 $\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。 如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱. 二 基础操作$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作，我们这个地方先把点$n$所在联通块儿内的树的根记作$root(n) $，把与$n$以实边相连的儿子记作实儿子。 $\rm{1}$ $Access$ 这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是$Access(n)$表示从$root(n)$向$n$打通一条实链，并以$n$点为最深度最大的点、$root(n)$为深度最小的点形成一棵$\rm{splay}$。 不难看出，这个操作其实跟是一种逻辑层面的自我调控，没有改变原树的结构。 我们思考，如果此时我们$Access​$完点$n​$之后，理论上来讲，$n​$点应该不再有实儿子了——显然，如果有实儿子的话，$splay​$中是应该包含这个实儿子的——而这就不符合$n​$是$\rm{splay}​$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}​$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}​$连上。 1234inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125; 然后这就是$Access​$了。 $2 ~~Make~ Root~$ $make_root​$先从原来的根向$n​$打通一条路径，然后$splay​$上去，最后$reverse​$一下。此处由于一开始$n​$的深度最大，$splay​$之后深度依旧最大，但此时$n​$是$splay​$的根，所以$reverse(n)​$就相当于翻转了整条树上的链，那么翻转之后，$n​$的深度就变成了最小，于是就是这个联通块儿的根节点了。 1234567891011121314151617181920#define lc T[x].Son[0]#define rc T[x].Son[1]struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; inline void splay(int x) ;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void splay(int x)&#123;int qwq = x ; stk.push(qwq) ;while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;while(!stk.empty()) push_down(stk.top()), stk.pop() ;while(check(x))&#123;int fa = T[x].F, g_fa = T[fa].F ;if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125;&#125; 此处$splay$中由于要下放标记，保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。 $3 ~Merge~$ 此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。 1inline void Merge(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125; $4~~Link~\&amp;~Cut$ 如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。 12inline void Link(int x, int y)&#123; Rooten(x) ; T[x].F = y ;&#125;inline void Cut(int x, int y)&#123; Merge(x, y) ; T[x].F = T[y].Son[0] = 0 ;&#125; 此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。 但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作…… $New-Link$ 12inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125; 此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233 但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。 多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根 $New-Cut$ 12345inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125; 此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。 之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$Depth(x) &lt; Depth(y\text{的左儿子们}) &lt; Depth(y)$，其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。 剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。 5 $~Rotate$中的坑点 呃……其实就一处而已。就是： 123456inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void rotate(int x) &#123; int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125; 这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g_fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$ 剩下的……大概就没了吧…… 于是—— $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 300233#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)using namespace std ;struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; stack &lt;int&gt; stk ;int base[MAXN], N, M, A, B, C, i ;inline int Find(int x) ;inline void splay(int x) ;inline void push_down(int x) ;inline void update(int x) &#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;inline void rotate(int x) &#123;int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125;inline void splay(int x)&#123; int qwq = x ; stk.push(qwq) ; while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ; while(!stk.empty()) push_down(stk.top()), stk.pop() ; while(check(x))&#123; int fa = T[x].F, g_fa = T[fa].F ; if (check(fa)) &#123; rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ; &#125;&#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void split(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125;inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; rep(i, 1, N) scanf("%lld", &amp;base[i]) ; rep(i, 1, M)&#123; scanf("%d%d%d", &amp;A, &amp;B, &amp;C) ; if (A == 0) split(B, C), printf("%d\n", T[C].S) ; else if (A == 1) Link(B, C) ; else if (A == 2) Cut(B, C) ; else splay(B), base[B] = C ; &#125; return 0 ;&#125; $\rm{0x00}$ 后记和参考可写完了……嗝……打个肥宅嗝犒劳犒劳自己 怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨…… 写博客真是一个陶冶情操的过程啊……包括做表情包 加油吧，$pks$！ $\rm{Reference}$ $[1]$ :$Flash_Hu$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :某篇论文，结合食用效果显著 $^{^{[\nearrow]}}$ $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>LCT-Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intro]]></title>
    <url>%2F2019%2F02%2F04%2FIntro-1%2F</url>
    <content type="text"><![CDATA[Hello, here is Orchidany, a high-school student from S.D., China. Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is Olympiad in Informatics，shorthanded for OI. And this blog is mainly gonna to record my Learning Steps. Although I’m a bit weak in OI by now, but I shall catch the glimmer and keep getting stronger! During daliy lives, I shall also write some about my own emotion, music &amp; art…it seems like I’m a chairwamrer in OI hhhhh… See you soon in my articles ! Somthing Special Errr…About this ID _Orchidany_, there is a theory about that: My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) : 鹃住落英满，柳拂溪畔沙。南城略炊烟，浣女徐归家。故人今安否，欲歌口偏哑。笔寒下梅去，皎月半洒花。 So……I’ m glad to encounter you!]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可并堆·左偏树（1）]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%B7%A6%E5%81%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[嗯…就当作是复习了233…时隔好几个月（其实就两个月）才想起来要整理。 $\rm{0x01}$ 关于左偏树首先是整理自己想出来的几个梗 $\mathcal{To~be~(left) ~or~not ~to~be~(left), this~is ~a~question}$ 左偏还是右偏，这是个问题。（哈姆雷特梗） $Hell~!~Where~is~my~Left~Leaning~Tree?$ 该死，我的左偏树向右偏了。 左偏树是1个log，右偏树也是1个log，那我左右都偏是不是就会更快！（恭喜你建出了一棵满二叉树） 讲个鬼故事：每棵树都是下偏树。 其实，左耳离心脏更近，所以甜言蜜语麻烦合并到左偏树里吧。（《左耳》梗） 好吧我承认不是很好笑 呐，下面进入正题。左偏树，一种可以合并的堆状结构，支持$insert/remove/merge$等操作。稳定的时间复杂度在$\Theta(\log n)$的级别。对于一个左偏树中的节点，需要维护的值有$dist$和$value$。其中$value$不必多说，$dist$记录这个节点到它子树里面最近的叶子节点的距离，叶子节点距离为$0$。 首先，他有以下几个喜闻乐见的性质： 一个节点的$value$必定（或小于）左、右儿子的$value$ （堆性质） 一个节点的左儿子的$dist$不小于右儿子的$dist$ （左偏性质） 一个节点的距离始终等于右儿子$+1$ 那么这就可以推出以下性质： 推论：任何时候，节点数为$n$的左偏树，距离最大为$\log (n+1)-1$$$Proof.$$ 对于一棵距离为定值$k$的树，点数最少时，一定是一棵满二叉树。这是显然的。因为对于每个节点，如果想要有最少的儿子，那么起码要做到左儿子的数量等于右儿子的数量。那么对于他的逆命题也是成立的——“若一棵左偏树的距离为$k$，则这棵左偏树至少有$2^{k+1}-1$个节点。” 所以会有$$n \geq 2^{k+1}-1$$,$$\log_2{(n+1)} \geq k+1$$, $$\log_2{(n+1)}-1 \geq k$$ $$\mathcal{Q.E.D}$$ $emmm$这可是一个很美妙的性质啊。 $\rm{0x02}~~$基本操作 $Merge$ 这是整个左偏树的重头戏，时间复杂度稳定在一个$log$，其主要思想就是不断把新的堆合并到新的根节点的右子树中——因为我们的右子树决定“距离”这个变量，而距离又一定保证在$~\log~$的复杂度内，所以不断向右子树合并。 大体思路（以小根堆为例），首先我们假设两个节点$x$和$y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了。 合并了$x$的右子树和$y$之后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护性质二，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x = dist_{rson(x)}+1$. 123456inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125; 我们观察，我们是不断交替拆分右子树，由推论可得我们的距离不会大于$\Theta(\log(n_x+1))+\Theta(\log(n_y+1))-2 =O(\log n_x+ \log n_y) $ 这个地方比较喜闻乐见的是需要存$root$，即需要路径压缩。不路径压缩的话，寻一次$rt$就是$\Theta(n)$的了，复杂度是不对的但似乎Luogu的模板，不路径压缩会更快 $Pop$ ……$pop$的话，乱搞就好了$233$ 1inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125; 然后就是总代码： 1234567891011121314151617181920212223242526272829struct Tree&#123; int dis, val, Son[2], rt ;&#125;S[MAXN] ; int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) S[i].rt = i, scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1) continue ; int f1 = Get(B), f2 = Get(C) ; if (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125;&#125; $\rm{0x03}$ 一点问题问题大概就是路径压缩…… $LuoguP3377$很不负责任地处了数据，导致以下这份代码可以过： 12345678910111213141516171819202122232425262728293031using namespace std ;struct Tree&#123; int dis, val, F, Son[2] ;&#125;S[MAXN] ;int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;int Get(int x)&#123; while(S[x].F) x = S[x].F ; return x ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].F = S[rs].F = 0, Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y), S[rs].F = x ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1 || B == C) continue ; int f1 = Get(B), f2 = Get(C) ; Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125; return 0 ;&#125; 一切都很正常，但问题在于他复杂度不对： 1int Get(int x)&#123; while(S[x].F) x = S[x].F ; return x ; &#125; 这显然是个上界为$O(n)$的函数……不寒而栗…… 所以他是不对的，这组数据可以很好的卡掉（由巨佬小粉兔制作）。 所以应该用一个并查集维护。而我们在路径压缩之后，必须要在$pop$后，给$pop$掉的点一个指针指向新的根，所以： 123inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125; 于是最后的代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 150010#define swap my_swap#define ls S[x].Son[0]#define rs S[x].Son[1]using namespace std ;struct Tree&#123; int dis, val, Son[2], rt ;&#125;S[MAXN] ; int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) S[i].rt = i, scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1) continue ; int f1 = Get(B), f2 = Get(C) ; if (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125; return 0 ;&#125; $\rm{0x04}$ 一道水题无论怎么说，单独用一篇博客来整理板子题实在是太$Low$了（尤其是显得笔者很没品位），于是就直接拼到一起吧qwq [LuoguP1456]Monkey King 链接 这玩意儿真tm水爆啊…直接存个代码证明我做过这道题吧qaq： 等会儿，突然想起来这道题的坑点来。就是原来的板子题，都是维护序列那种感觉，一个元素pop掉之后又就不用管它了。但是这道题是一道应用题，所以不应该删完不管，应该清空qwq。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 200010#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, i, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;struct Heap&#123; int val, dis, Son[2], rt ;&#125;T[MAXN] ; int N, M, A, B, i ;inline int get(int x)&#123; if (x == T[x].rt) return x ; return T[x].rt = get(T[x].rt) ;&#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (T[x].val &lt; T[y].val) x ^= y ^= x ^= y ; rc = Merge(rc, y) ; if (T[lc].dis &lt; T[rc].dis) lc ^= rc ^= lc ^= rc ; T[lc].rt = T[rc].rt = T[x].rt = x, T[x].dis = T[rc].dis + 1 ; return x ; &#125;int main()&#123; while (~scanf("%d", &amp;N))&#123; memset(T, 0, sizeof(T)) ; rep(1, i, N) T[i].rt = i, scanf("%d", &amp;T[i].val) ; cin &gt;&gt; M ; rep(1, i, M)&#123; scanf("%d%d", &amp;A, &amp;B) ; int rt1, rt2 ; int f1 = get(A), f2 = get(B) ; int ff1, ff2 ; if (f1 == f2) &#123; puts("-1") ; continue ; &#125; T[f1].val &gt;&gt;= 1, T[f2].val &gt;&gt;= 1 ; rt1 = Merge(T[f1].Son[0], T[f1].Son[1]) ; T[f1].Son[0] = T[f1].Son[1] = T[f1].dis = 0 ; rt2 = Merge(T[f2].Son[0], T[f2].Son[1]) ; T[f2].Son[0] = T[f2].Son[1] = T[f2].dis = 0 ; ff1 = Merge(f1, rt1), ff2 = Merge(f2, rt2) ; T[ff2].rt = T[ff1].rt = Merge(ff1, ff2), printf("%d\n", T[get(T[ff1].rt)].val) ; &#125; &#125; return 0 ;&#125; $\rm{writter:Flower_pks}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>可并堆/左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流2·HLPP+丧心病狂的优化]]></title>
    <url>%2F2019%2F01%2F11%2FHLPP%2F</url>
    <content type="text"><![CDATA[#define $u$的伴点集合 与$u$相隔一条边的且$u$能达到的点的集合 $0x00~ {}~Preface$ $HLPP(Highest~Label~Preflow~Push)​$最高标签预流推进算法是处理网络最大流里两种常用方法——增广路&amp;预流推进中，预流推进算法的一种。据传由$tarjan​$发明怎么又是他 ，并被其他科学家证明了其复杂度是紧却的$O(n^2\sqrt m)​$。在随机数据中不逊色于普通的增广路算法，而在精心构造的数据中无法被卡，所以是一种可以替代$Dinic​$的方法（随我怎么说，代码又长又难调，所以还是$Dinic​$好啊$\rm{TAT}​$） 但无论怎样，$wiki$里面已经承认$HLPP$是现在最优秀的网络流算法了。 那么预流推进这个大门类里面，思想都差不多。大抵上就是我们对每个点记录超额流($Extra~Flow$) ，即允许流在非源点暂时存储，并伺机将超额流推送出去。不可推送的，就会流回源点。那么最终答案显然存储在$Extra[T]$里面。 但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用最高标号的策略，给每个点一个高度，对于一个点$u​$以及它的伴点集合${v}​$，当且仅当$h_u = h_v + 1​$ 时才可以推送流。并且我们对于源点$S​$，设置$h_S = N​$，并对于$S​$实行无限制推送。那么最后的答案就保存在$Extra[T]​$里面 。 但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑拔高它的高度，即重贴标签($relabel​$)操作。 $0x01\quad$ 初步的算法流程以下我们用$Extra_u$表示$u$的超额流，$h_u$表示$u$的高度，用$f_k$表示边$k$的容量。 首先把所有的$h_i$都置为零，并把$h_s$置为$N$（点数）。 将$S$的流推送到每个与$S$相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。 对于点$u$推送过程中，如果$Extra_u$减到了$0$，就立即退出（优化一） 对于每条出边$k$，推送的流量$F = min(f_k,Extra_u)$并执行两个点（$u,v$）的超额流增减。如果$v$不在堆里面，要把$v$放到堆里面。 如果推送完毕$Extra[u]$不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度$h_{min}$，则新的$h_u = h_{min}+1$，并把$u​$入堆。 好的，然后就可以撒花了……可是等等，他怎么这么慢$qaq$ 接下来我们发现，重贴标签的过程似乎与$ISAP$有点点像……所以我们不妨通过一个$Gap$数组来记录”断层情况“：即如果对于一个点$u$来说，他的伴点集${v}$已经不存在$h_u = h_v + 1$的点了，并且也不存在一个点$j$使得$h_j = h_u$那么这个地方就是一个断层$(Gap)$ ，那么也就是说，对于所有$h_i&gt; h_u$的点来说，它们把流推送到$h_u$的高度就不能继续推送了，所以我们直接$h_i = N + 1$，让他们回流到源点。（优化二） 接下来这个优化，亲测可以提速$4000ms​$，平均每个测试点提速$700​$ ~ $800ms​$，去掉数据最小的点，每个点平均提速$1000ms​$。这就是——$BFS​$! 我们不妨一开始就倒着$BFS$一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度（源点高度还是$N$。嗯，$Mr_Spade$大佬实在太强了$qwq$ 对了，代码实现方面，需要好多判断不是源点和汇点的小细节……无路赛无路赛无路赛$&gt;_&lt;$！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//省略某些部分#define Inf, MAXN, MAXM, to(k)struct state&#123; int num, h ; bool operator &lt;(const state &amp; now) const&#123; return h &lt; now.h ; &#125;&#125; ; priority_queue &lt;state&gt; heap ; BFS init ;int N, M, S, T, cnt = -1, A, B, C, D, t, min_h ;int head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;inline void Preflow_Push()&#123; register int i, k ; for (i = 1 ; i &lt;= N ; ++ i) if(H[i] &lt; Inf) ++ Gap[H[i]] ; for(k = head[S]; k != -1 ; k = E[k].next) if((t = E[k].f))&#123; E[k].f -= t, E[k ^ 1].f += t, Extra[S] -= t, Extra[to(k)] += t ; if(to(k) != T &amp;&amp; !vis[to(k)]) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; while(!heap.empty())&#123; vis[node = heap.top().num] = 0, min_h = Inf, heap.pop() ; for(k = head[node] ; k != -1 ; k = E[k].next)&#123; if(E[k].f &amp;&amp; H[node] == H[to(k)] + 1)&#123; t = min(Extra[node], E[k].f) ; E[k].f -= t, E[k ^ 1].f += t, Extra[node] -= t, Extra[to(k)] += t ; if(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; if (E[k].f) min_h = min(min_h, H[to(k)]) ; if (!Extra[node]) break ; &#125; if(Extra[node]) &#123; if (!--Gap[H[node]]) for(i = 1; i &lt;= N ; ++ i) if(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + 1) H[i] = N + 1 ; H[node] = Inf; H[node] = min_h + 1 ; heap.push((state)&#123;node, H[node]&#125;), vis[node] = 1, ++ Gap[H[node]] ; &#125; &#125;&#125;inline int read() &#123;fast;&#125;int main()&#123; Input() ; for (i = 1 ; i &lt;= N ; ++ i) head[i] = -1, H[i] = Inf ; while(M --)&#123;Add; &#125; q.push(T), H[T] = 0 ; while(!q.empty())&#123; int now = q.front() ; q.pop() ; for(k = head[now] ; k != -1 ; k = E[k].next) if (H[to(k)] &gt; H[now] + 1) H[E[k].to] = H[now] + 1, q.push(E[k].to) ; &#125; if (H[S] == 0) &#123;cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ;&#125; H[S] = N, Preflow_Push() ; cout &lt;&lt; Extra[T] &lt;&lt; endl ;&#125; 看起来我们加上下面这一句话的毒瘤卡常就可以有$4000ms$左右的好成绩，但事实上，这个速度依旧慢的要死。 注意！这个写法是经典写法，其时间复杂度是紧却的$\boldsymbol{\rm{\Theta(n^2mlogn)}}$的，也就是说在$\boldsymbol{n=1200}$时会带一个$\boldsymbol{10}$倍的常数 怎么优化呢—— $\boldsymbol{0x02~~Optimization}$各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）…… 来，我们首先思考思考普通的HLPP到底会慢在哪里： $STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！ 每次$Gap$优化，我们的时间复杂度是紧确的$\Theta(n)$。的这显然不合算，因为假设我当前的$\boldsymbol{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会浪费$\boldsymbol{\Theta(n)}$的时间。 事实上…普通的$HLPP$代码并不长，主要问题就是这两个。 我们考虑，如果不用堆的话怎么做呢？ 呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，高度函数$\boldsymbol{H(x)}$和点数集大小$\boldsymbol{N(x)}$是广义同阶的。 换句话说，我们可以考虑从高度入手。 换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\boldsymbol{O(n)}$而不是$\boldsymbol{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。 那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。 也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333 hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。 好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花… 哦对，还有几点我debug的时候被坑死的点： 那个$Iterator$类型的$vector$对象是点的编号不是高度！ 注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质wrnm，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$ (我觉得写的很难看但是有注释qaq)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//writter:Orchidany(pks)#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")//sb毒瘤优化#define MAXN 10030#define min my_min#define BG begin()#define gc getchar#define rr register #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;//list，就是快（//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; /*vector存边（据说会快）*/vector&lt;List::iterator&gt; Era_pos ; //辅助定位+删除inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;//黑科技inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = gc() ; while (!isdigit(c)) c = gc() ;while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = gc() ; return k ; &#125;inline void Init_label()&#123;//等价于一开始的那个BFS，只执行一次 rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; H.assign(N + 1, N + 1) ; H[T] = 0 ; q[t ++] = T ;//从T（高度小的）向前标号 while (h &lt; t)&#123;//队列……BFS……真熟悉啊……嗝…… rr int now = q[h] ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == N + 1 &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + 1, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N + 1) Set[i].clear(), Gap[i].clear() ;//还是清空一下比较好吧 rep(i, 0, N) if (H[i] &lt;N + 1) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), //疑似insert函数的返回值是一个指针qaq (Extra[i]&gt;0) ? Set[H[i]].push_back(i) : eggs() ;//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同… max_H = now_H = H[q[-- t]] ; //更新，BFS的性质，最后一个元素一定高度最大（除了源点）&#125;inline void Push(int x, Edge &amp;e)&#123;//单独写出来的push函数，好像很方便？ rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into "heap"&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0)//如果可以流 if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123;//如果出现断层了 for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)//这个gap的for肯定比O(n)优秀 for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; /*断层以上的高度都没用了*/return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; //重贴标签操作，为当前点删除原来的高度 ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;//增添新的高度&#125;inline int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt.assign(N, 0), cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] =- INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; //下面源点要单独拿出来推送，因为源点推送时高度差不需要=1. Init_label() ; //初始化（BFS） while (now_H &gt;= 0) //正式开始HLPP（泪目） if (Set[now_H].empty()) now_H -- ; //高度递减，实现一个堆的效果 else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ; return Extra[T] + INF ;&#125;int main()&#123; N = qr(),; rr int i ;//下面的++N是为了日后好操作qaq rep(i, 1, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125; 下面是个$fread$卡常版本$qaq$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#define MAXN 1202#define min my_min#define BG begin()#define rr register#define swap my_swap #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;const int ch_top=4e7+3;char ch[ch_top],*now_r=ch-1,*now_w=ch-1;inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x;&#125;inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w='\n';&#125;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; vector&lt;List::iterator&gt; Era_pos ; inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline void Init_label()&#123; rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; rr int qaq = N + 1 ; H.assign(qaq, qaq) ; H[T] = 0 ; q[t ++] = T ; while (h &lt; t)&#123; rr int now = q[h], qwq = H[now] + 1 ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == qaq &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = qwq, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N - 1) Set[i].clear(), Gap[i].clear() ; rep(i, 0, N - 1) if (H[i] &lt; N) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] &gt; 0) ? Set[H[i]].push_back(i) : eggs() ; max_H = now_H = H[q[-- t]] ; &#125;inline void Push(int x, Edge &amp;e)&#123; rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into heap&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0) if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123; for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i) for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;&#125;int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; cnt.assign(N, 0) ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] = -INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; Init_label() ; while (now_H &gt;= 0) if (Set[now_H].empty()) now_H -- ; else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;return Extra[T] + INF ;&#125;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read(), S = read(), T = read() ; rr int i ; rep(i, 1, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,1,now_w-ch,stdout) ;&#125; 撒fa~ $0x03~~$后记 这道题的经典版本好几个月之前我写了一天……然后今天又翻出来，发现了巨佬KevinYu抛了一个玉，我就打算优化一波……毒瘤啊，什么$vector$存边、$list$我都是第一次用呜呜…… 不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） 最后，人艰不拆，人艰不拆… $\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>目测用不到的算法之HLPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想四·故人今安否？]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 最近初三的小朋友们生龙活虎地来了，虽然没有什么深入的交流，但是其身上洋溢着的青春，确是我辈所比不了的。 是啊，一年了啊。 去年这个时候，我们也是这样意气风发的吧？听说今年的“小班”（初三来的实验班），信竞有12个人，和去年一样。换句话说，和我们一样，只不过他们这一级女生有四个，我们只有一个而已。 真像啊。 $\rm{0x01}$ 结束比我想象的要早，早好多，好多好多。 我退役了，虽然是本赛季退役。 我仿佛从来没有考虑过这件事情，18年的2月、3月、4月……甚至一直到8月，我都一直以我仍然初三、仍然未升上高中而自豪。我们是有生力量里面最年轻的一代，我们开口$Splay$、网络流、$Tarjan$，闭口莫队、$A-star$、替罪羊，我们研究各种奇妙的算法，我们刷各种三倍经验，我们酒入豪肠酿成三分月光，我们春风得意马蹄疾—— 我们年轻啊。 恍如隔世，考完$Noip$或许才真正知道自己几斤几两。 我悔恨，我懊恼，我痛苦，我不甘。我终于也变成了只能孤注一掷在高二出成绩的老年人。我或许什么都没少，只不过少了一次计划；但我或许已经一无所有——我的时间没有了。 我曾经认为考省一应该不算多难，结果现实重重地给了我一闷棍，厉喝道：这就是现实的力量。 或许几个月之前，或者说，从考完Noip到现在，我的所有负面情绪表现出来的都是消极、沉默、颓废，而直到今天，我看着窗外空旷的操场、不燥的微风，我看着天边徘徊的流云——我只想哭，声嘶力竭地、歇斯底里地哭。 我只想哭。 $\rm{0x02}$ 故人最近晚眠前，常会想起初来实验部时的同僚们：]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流1·Dinic&费用流]]></title>
    <url>%2F2018%2F08%2F20%2Fnet-work-flow%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[$0x00~ {}~Preface$$2333​$这是好久之前学的了，不过一直在咕咕咕咕。 一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。 那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。那么，我们定义容量为$c(u,v) \in E ? c(u,v) : 0​$。在整张图中有一个源点和一个汇点，且对于每个点来说有$$\sum F_{in} = \sum F_{out}​$$并且我们人为的将$S​$的$F_{in}​$设置为$0​$，$F_{out}​$设置为$+\infty​$。$T​$正好相反。当然，如果非说不合适的话，可以将源点和汇点看做同一个点233. 通过线性规划我们可以证明的是最大流等价于最小割，而博主现在对线性规划还只是一知半解，等什么时候“贯通了”再整理博客吧233 好的，窝觉得定义什么的可以不说了，我们直接上$EK$ $0x01~$ 不知道可以用来干啥的$EK$其实，$EK$身为大家眼中的$basis$算法，他居然是比$Dinic$晚发表的……$233$ 全程是$Edmond-Karp$ ,由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，是个比较没用的算法 他的原理就是，我们通过两个杀器来实现最大流： $Killer1:$增广路 这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。 $Killer2:$ 反向边 虽然图集与解是单射的逻辑关系，即虽然对于同一张图$G(U, V)$无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从$T$连向$S$的，等同于原来没反向边时的情况。 嗯，那么我们程序实现的时候，大概就是这样 12345678910111213141516171819202122232425bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125; 其中$Last$记录前驱，$dis$就是个$mark$，$_F$数组记录增广路上最大的流量 。 那我们接下来分析复杂度。值得注意的是，$EK$由于采用$BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}++$），所以在每条边都作为残量最小值增广一次之后（至多$m$次）最短路就会增加。而最短路最多从$2$增到$n$，所以最多增广$n \times m$次。而每次$bfs$至多是$\Theta(m)$的，所以总复杂度上界是$\Theta(nm^2)$ 但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以$EK$可以解决朴素的最大流问题。 全部的代码存档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ;&#125;e[MAX &lt;&lt; 1] ;int MAX_F, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; endl ; return 0 ;&#125; $0x02$ 据说可以拯救世界的$Dinic$那么接下来我们说$Dinic$，这个算法是由$Dinic$教授创造的$qwq$ 然后$Dinic$在$EK$的基础上，采用了两个新的优化方案： $Case1:$分层图 每次我们选择用$bfs + dfs$去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用$dfs$遍历这张增广网。 $Case2:$当前弧 我们依仗的是这一段（句）代码： 1for(int &amp;i=cur[now];i!=-1;i=line[i].nxt) 其中比较重要的是引用符号，此处引用的目的是不断更新$cur$，达到不重复枚举的目的。 那么整体代码就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;queue&gt; #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ; &#125;e[MAX &lt;&lt; 1] ; int A, B, C, i ;int head[MAX], cnt = -1, now, cur[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool bfs()&#123; queue&lt;int&gt; q ; fill(dis, dis + N + 23, 0) ; q.push(S), dis[S] = 1 ; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if (!dis[e[k].to] &amp;&amp; e[k].v) dis[e[k].to] = dis[now] + 1, q.push(e[k].to) ; &#125; &#125; return dis[T] ? 1 : 0 ;&#125;int dfs(int St, int Aim, int Flow)&#123; if (St == Aim || !Flow) return Flow ; int Fl, res = 0 ; for (int &amp;k = cur[St] ; k != -1; k = e[k].next) if (dis[e[k].to] == dis[St] + 1 &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123; res += Fl, e[k].v -= Fl, e[k ^ 1].v+= Fl ; Flow -= Fl ; if (!Flow) break ; &#125; return res ;&#125;int Dinic()&#123; int res = 0 ; while(bfs())&#123; for(i = 1; i &lt;= N; ++ i) cur[i] = head[i] ; res += dfs(S, T, 0x7fffffff) ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; cout &lt;&lt; Dinic() ; return 0 ;&#125; 嗯，那么我们不难看出$cur$其实就是为了防止我们不断重复枚举边。因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走。而复杂度没有变，但是确实会更快。 那么接下来证明一下$Dinic$的时间复杂度。 根据分层图而言，$t$的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有$n$次重新分层。而对于每次在增广网上的操作，至多有$m$条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共$O(2n)$的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。 很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。 据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。 最后我们来说一下费用流。 $0x03$ 费用流（最小费用最大流）其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把$EK$的$bfs$换成$SPFA$就行了233 至于为什么不能$dinic$，很显然是因为没法分层啊……$hhh$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v, c ;&#125;e[MAX &lt;&lt; 1] ;bool mark[MAX] ; int MAX_F, MAX_C, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w, int c)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool SPFA()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, Inf) ; fill(mark, mark + N + 1, 0) ; q.push(S), dis[S] = 0, mark[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; mark[now] = 0 ; for (int k = head[now]; k != -1 ; k = e[k].next) if (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123; dis[e[k].to] = dis[now] + e[k].c ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; if(!mark[e[k].to])&#123; q.push(e[k].to) ; mark[e[k].to] = 1 ; &#125; &#125; &#125; return dis[T] != Inf;&#125;void _EK()&#123; while(SPFA())&#123; now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt;" "&lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125; 但是$SPFA$他，他他他他他已经死在了$NOI2018$…… 那么我们考虑是否能用$dijkstra$来做。那我们要考虑的就是负权边，因为我们建的反向边是要把代价也跑回去的啊，所以我们致力于解决负权边问题。$rqy$当时是这么给我们讲的： 考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。 那么我们从点$S$到点$B$点的距离便从$dis_B$变成了$dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。 下面我们思考到底要选取什么作为势函数呢？ 我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的： 这为什么是对的呢? 考虑一条边 $u→v$ ，费用为 $c$ 。 如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 于是我们现在可以用 $Dijkstra$ 增广，很快而且更难卡( 至于代码，大概长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100010#define Inf 192608170using namespace std ;struct edge&#123; int to, next, c, f ;&#125;e[MAX &lt;&lt; 1] ; int H[MAX], S ;int dist[MAX], _F[MAX], Pre[MAX], i, k ;int N, M, A, B, C, D, cnt = -1, x1, x2, head[MAX] ;struct node&#123; int dist, num ; bool operator &lt;(const node &amp; now) const&#123;return dist &gt; now.dist ; &#125;&#125;; priority_queue&lt;node&gt; q ; bool vis[MAX] ; int Last[MAX], MAX_F, MAX_C, t, ww ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void Add(int u, int v, int f, int c)&#123; e[++ cnt].to = v, e[cnt].f = f ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].f = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool dijkstra()&#123; for (i = 1 ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = 0 ; q.push((node)&#123;0, S&#125;) ; dist[S] = 0 ; while(!q.empty())&#123; node now = q.top() ; q.pop() ; while(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop(); x1 = now.num, x2 = now.dist ; if(vis[x1]) continue ; vis[x1] = 1 ; for(k = head[x1] ; k != -1 ; k = e[k].next) if (e[k].f &gt; 0 &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123; int T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ; _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ; &#125; &#125; return dist[t] &lt; Inf ;&#125;inline void _EK()&#123; while(dijkstra())&#123; ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ; while(ww != S) e[Last[ww]].f -= _F[t], e[Last[ww] ^ 1].f += _F[t], ww = Pre[ww] ; for (i = 1 ; i &lt;= N ; ++ i) H[i] += dist[i] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ; for (i = 0 ; i &lt;= N ; ++ i) head[i] = -1 ; for (i = 1 ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; " " &lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想二·丘吉尔]]></title>
    <url>%2F2018%2F08%2F08%2F%E9%9A%8F%E6%83%B3%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 啊……还有几十天就$NOIp$了啊…… 现在是下午四点，机房。 比我弱的都在颓废，比我强的都在做题。 唯独我在写博客。 我在想些什么呢？ 我是$pks$，没错，我不敢称自己为$Flower_pks$，不敢称自己为“花”，因为这跟我实力不符——我不是那个在$Luogu$这个$OJ$上小有名气的大佬，不是那个题解写得十分详细的作者，更不是$SD$集训里面排的上号的人。 没错，我不配啊。 上午$rqy$出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。 旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。 撇过头来看键盘上发着光的$w$键，突然有种想哭的欲望。 我是真弱啊。 $NOIp$现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。 我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕…… 但我什么也没有。我也不是个富有毅力的人。 我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。 我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。 估计是我什么都不适合吧。 其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。 这种人强到让我厌恶。也让我悲哀。 好啦好啦你强好啦……我滚粗好了吧…… 我并不是很服气，但是现实却总是不尽人意。 过去我一直能依靠着的、可以包容我的人已经与我一别两宽了， 估计以后也只能靠自己了吧。 我并不知道为什么我要选择承受这么多，大概是天性使然吧。 我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。 二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。 路在哪呢……]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想一·杨柳岸晓风残月]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E6%83%B3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 我是花，来自山东，今时今日写下这一篇，只是为了给并肩的$Oiers$一个不算多美的故事，为了给后来的$Oiers$一个对未来有所期望的愿景。 看着眼前发黄的电脑屏幕，不知道该说些什么。 现在的我即将高一，有着比较厉害的学长，和什么都不会的教练，每天来机房就是刷题-&gt;不会-&gt;刷题-&gt;不会。 大概我马上就要习惯了吧。 闷热的八月让人有一种说不出的惆怅，大概是初中毕业旧事未了，或者是即将$NOIp$但却并没太大信心，或者是教练总是给出不尽人意的安排打乱计划。 我捏着手边新换上的眼镜腿儿，默默地想到。 我依稀记得几个月前的快乐场景：每天都在学新算法、不亦乐乎地学、废寝忘食地学。最讨厌做模拟题、玛丽题或者搜索题。最喜欢去学习新的算法，所以导致我整天刷模板题：线段树、$Splay$、$LCA$……偶尔会兴致盎然地发几篇题解，也总是会用最生动的语言，盯着$luogu$的$markdown$那方小小的编辑框，一个字一个字地码着。二月的培训让我觉得是最有意义的一次培训了，大多数精致的$blog$都出自那时。一般都是回到宾馆后，开始联机颓废，等到半夜凌晨开始写博客，写到鱼肚泛白或者困意袭来才罢休。 可真是让人高兴的回忆啊…… 回想这几个月，变化是日新月异的——就如同把一颗小小的石子扔进一池静水，起初不见多大声势，静候才可见其早已涤荡了半池——是波纹展开了。一开始来这儿，是实力悬殊的——初中有人努力、也有人不努力；初中时都挺聪明，在班里都名列前茅；初中时上奥赛几乎等于颓废，因为没多少人真正地在做题…… 可惜时光不容许保留原来的模样。 主任盯得紧，教练怂主任从而也盯得紧；大多数人都因为外力的因素必须要努力，但也有根本不想努力的人；以前可以骄傲的资本、譬如文化课，现在早就变成了一纸空谈——作为所谓“奥赛负责人”的我，看到来到实验部第一次的月考成绩时，看到级部前二十（这一级实验部一共$116$个人）充斥着数学物理化学生物奥赛的人、却又跟信息学奥赛没有任何关系时，我不知道该怎么做。 于是我便开始加大压力：组织学生定期讲课、定期比赛。用这种空泛的压榨时间的行为来压榨效率无疑是可笑的，但是也起了一部分好的效果：几个$NOIp$内容都没会熟练的家伙开始跃跃欲试地学习$Splay$、学习网络流……我不知道这样做是否真的好，就如同我不知道我学习新东西是否会在十月、甚至十一月之前压垮所有人的神经——学完新东西、反过头来发现基础却根本不牢固——就如同为了学新知识，而去学新知识。这种功利让我不知道现在在走着一条怎样的路。 终于，差距出来了。经过几个月训练、实力强劲的人自然涌了上来，也有根本不行的人光辉逐渐黯淡。二月时的能力局面现在早就会焕然一新，有人选择走，有人选择苟活。我不清楚原来那些充满骄傲的、惬意的脸庞如今去了哪里，我只知道我给他们定的目标是今年全部省一、我只知道来到实验部之后，只能选择负重前行。 看着机房里其他人的变化，就宛如翻完了一部小说一般，跌宕而符合逻辑。 告别了初中，留下了什么呢？或许是由于自身意气用事而破坏了原本纯洁的友情，但是我不能——真的不能仅仅把$Ta$当作一个不世出的好朋友。但当我跨越了自身的那一步之后才发现原来无人等候，才发现我只能把一些事情抛撒在风里，然后安慰自己“没事”。 我喜欢李宗盛，喜欢他的歌里面唱出的人间无奈。而最喜欢的是他的《山丘》: 给自己随便找了个理由， 向情爱的挑逗，命运的左右。 不自量力地还手，直至死方休—— 越过山丘——虽然已白了头； 喋喋不休——时不我予的哀愁； 还未如愿见着不朽 就把自己先搞丢—— 越过山丘——才发现无人等候； 喋喋不休——再也唤不回了温柔； 为何记不得上一次是谁给的拥抱 在什么时候。 大概是能唱出柳永“杨柳岸晓风残月”几分意味的吧。 $2018/8/4​$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
</search>
