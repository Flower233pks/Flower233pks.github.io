<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[$To-do~List·$任务清单]]></title>
    <url>%2F2019%2F02%2F12%2FTo-do-List%2F</url>
    <content type="text"><![CDATA[Emmm…Due to my poor executive force, I plan to make this table for myself ans for u, to show what I’m doing and what I’m gonna do. Praying, this way will help a bit :) And…From one task was accomplished, there is two weeks for it to remain in the table for showing. $\boldsymbol{Task }$ $\boldsymbol{Deadline}$ $\boldsymbol{Remarks}$ $\boldsymbol{Priority}$ $\boldsymbol{Num.}$ $\boldsymbol{Accomplish?}$ 网络流$24$题 $\frak{April.1^{st}}$ $After ~task ~2$ $4$ $1$ $Not~ yet$ $\rm{Optimization~of~HLPP}$ $\frak{Feb.13^{th}}$ $Mast ~the ~Greatest~!$ $1$ $2$ $Finish~$ $\rm{Do~ CF~the ~first~20~Divs}$ $\frak{16^{th}~ day ~of~ the ~2^{nd} ~L-M}$ $the~ level ~is ~as ~NOIP$ $2$ $3$ $Not ~yet$ $\rm{Add ~aplayer ~to ~this ~site}$ $\frak{Feb.13^{th}}$ …… $1$ $4$ $Not~yet$ $\rm{do~20~DPs}$ $\frak{March.1^{st}}$ $the~ level ~is ~as ~NOIP$ $3$ $5$ $Not~yet$ $\rm{empty}$ $\rm{empty}$ $\rm{empty}$ $\rm{empty}$ *$1:$ L-M means “Lunar Month”. var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 0, music: { title: "See You Again", author: "Wiz Khalifa", url: "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3", pic: "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.lrc", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>闲情逸致</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$CF\#536Div2$の题解($E\&F$)]]></title>
    <url>%2F2019%2F02%2F08%2FCF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F%2F</url>
    <content type="text"><![CDATA[$CF$#$536Div2$の题解($E\&amp;F$)$0x01~~Preface$$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕 这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233 简单总结一下前面四道题$\color{red}{Link}$： A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次身败名裂XD B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树） C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。 D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞 下面两道题就好像不是那么水了qaq $0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$$\color{red}{Link}$简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。 最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。 $\mathfrak {Solution}$呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。 之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。 Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXM 233#define MAXN 100010using namespace std ;struct time_node&#123; int mark, d, w ; bool operator &lt; (const time_node &amp;T) const &#123; return w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d); &#125;&#125; base[MAXN] ; map &lt;time_node, int&gt; M_set ; vector&lt;time_node&gt;Time[MAXN] ; long long Ans ;int N, M, K, A, B, C, D, i, j ; long long dp[MAXN][MAXM] ; int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; memset(dp, 63, sizeof(dp)) ; for (i = 1 ; i &lt;= K ; ++ i)&#123; scanf("%d%d%d%d", &amp;A, &amp;B, &amp;C, &amp;D), Time[A].push_back((time_node)&#123;1, C, D&#125;) ; Time[B + 1].push_back((time_node)&#123;2, C, D&#125;) ; &#125; for (i = 1 ; i &lt;= N ; ++ i)&#123; register int tot = Time[i].size() ; for (j = 0 ; j &lt; tot ; ++ j) if (Time[i][j].mark == 1) ++ M_set[Time[i][j]] ; else M_set[Time[i][j]] &gt; 1 ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ; if (M_set.size()) base[i] = (*M_set.begin()).first ; else base[i] = (time_node)&#123;0, i, 0&#125; ; &#125;dp[0][0] = 0, Ans = dp[1][1] ; for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = 0 ; j &lt;= M ; ++ j)&#123; j &gt; 0 ? dp[i][j] = min(dp[i - 1][j - 1], dp[i][j]) : 1 ; dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - 1][j] + base[i].w) ; &#125; &#125; for (i = 0 ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$]]></content>
      <tags>
        <tag>BSGS</tag>
        <tag>动态规划-普通DP</tag>
        <tag>线性代数-矩阵</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$Lagrange ~Formula·$拉格朗日插值法]]></title>
    <url>%2F2019%2F02%2F07%2FLagrange-Formula%2F</url>
    <content type="text"><![CDATA[拉格朗日插值公式 $\rm{Lagrange~Interpolation~Formula}$$\rm{0x01~~} Preface$插值($Interpolaton$) 在多项式域中可以看做是求值$(Evaluation)$的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。 而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明—— $\rm{0x02}~~\rm{Proof}$$Proof ~of~Existence$​ 我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。 ​ 首先我们需要构造一个对于第$i​$个二元组的特殊多项式$L_i(x)​$，满足$$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}​$$ 那么我们所求的多项式$F(x)​$就可以写作$$F(x) = \sum L_i(x_i)\cdot y_i​$$这个式子保证了我们对应的$n​$个二元组，$F(x)=y​$恒成立。 ​ 那么对于$L_i(x)​$，我们考虑由我们对$L_i(x)​$的定义可以得出$$L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)​$$其中不包含$x-x_i​$这一因式。而由$L_i(x_i)=1​$可知我们的比例系数$$k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}​$$那么$$L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}​$$从而$$F(x)=\sum L_i(x)\cdot y_i(x) = y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}​$$ $\mathcal{Q.E.D.}$ $Proof~of~Uniqueness^{[1]}$​ 我们接下来要证明的是多项式$L_i(x)​$的唯一性 ​ 我们假设同时有两个实数域上的$n-1​$次多项式$L_1(x),L_2(x)​$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}​$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2​$在取所有的$x_i​$时，其值均为$0​$。那么一定会有多项式$$L’(x) = \prod\limits_{i=1}^{n}(x - x_i)​$$满足$$L’|L_{\Delta}​$$ 其中$|​$表示多项式整除。但是我们知道，对于$L’​$这个多项式，其次数为$n-1​$；而对于我们所定义的$L_i(x)​$，均为$(n-2)​$次的，从而$L_{\Delta}​$也是$n-2​$次多项式。所以我们可以得出$$L_{\Delta} = 0​$$从而有$$L_1=L_2​$$ $\mathcal{Q.E.D.}$$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$1234567891011121314151617181920212223242526272829303132333435363738题号：Luogu4781#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 2020#define LL long long#define Mod 998244353using namespace std ; LL Ans, xs ;int N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;inline LL expow(LL A, LL B)&#123; LL res = 1 ; while (B)&#123; if (B &amp; 1) (res *= A) %= Mod ; B &gt;&gt;= 1, (A *= A) %= Mod ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld%lld", &amp;xv[i], &amp;yv[i]) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; t = 1 ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (xv[i] - xv[j] + Mod)) %= Mod ; &#125; t = expow(t, Mod - 2) ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (T - xv[j] + Mod)) %= Mod ; &#125; (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;// cout &lt;&lt; Ans &lt;&lt; endl ; &#125; printf("%lld", Ans) ; return 0 ;&#125; $\rm{Reference}$ $[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 $^{^{[\nearrow ]}}$ $\mathfrak{writter:pks}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Math - Lagrange Formula</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群论入门]]></title>
    <url>%2F2019%2F02%2F06%2F%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。 群$1~)~$群的定义比较简单的来讲，所谓群$(\rm{group})$指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质： 我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算： $Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$那么也就是说的直白点吧，对所有的元素，做完该群所带有的带有结合律的运算之后，所得结果仍然属于该群且一定存在单位元，对于每个元素存在运算逆元。 那我们不妨定义一些其他的： 阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。 半群：满足封闭性和结合律的群。 有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶 结合几个例子来解释一下： 比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)$$, $$(R\setminus{0}~, ~\cdot)$$,$$ (C\setminus{0}~,~\cdot)$$ 他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。 或者一个好玩儿的乘法群$$({1,-1}~~, ~~\cdot)​$$或者是所有非奇异的$n​$阶矩阵也可以组成一个乘法群。 或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断是否成群,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。 $Extra \ \ Things :$ 以下是两种复合抽代数据结构（名字自己起的$233$）： 环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。 域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群举例子 ：$Q,R,C$即有理数域、实数域和复数域。 好的，那我们尝试证明两个命题： $Proposition1~~~~$一个群中的单位元唯一设有两个单位元$e_1,e_2$ 那么$e_1=e_1e_2=e_2$，其实是一个$233$ $Proposition2~~~~$群中元素的逆元唯一以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$ 显然也是同一个。 那么此时我打算整理一个群的共性特征：$$(ab)^{-1}=b^{-1}a^{-1}$$ 很显然，证明如下：$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$ 提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心 那么之后我们讨论周期 对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$ $o(a)$表示最小正整数，使得$a^{o(a)}=e$ $2~)~$子群及衍生本节所指“群”没有特别说明便均为有限群 不妨先给出子群的浅显版定义： 如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示那么从而我们可以定义生成子群这个东西： 生成子群：若$S \subseteq G​$， 并且对于运算$C​$而言，$(G,C)​$也是一个群，那么就称$G​$为集合$S​$在运算$C​$下的生成子群。集合$S​$的生成子群用$&lt;​$$S​$$&gt;​$表示 这之后我们就可以定义陪集这个概念 陪集一般上包含左陪集和右陪集。 左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。$233$也可以叫做傍集或者旁系之类的~ 那么我们这个地方先只研究右陪集$233$ $Lemma1:$我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的群中元素数量。 这个其实比较显然，因为事实上群都是定义在非可重集上面的。 较为严谨的证明如下： $Proof.$ 对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$ 反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾 对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$ $Lemma2:$之后我们再证明一些好玩儿的： 命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ 看起来好像不是那么好玩…… $Proof.$ 若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$ 若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$ $hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$ 因此$H_a=H_b$ 那么我们还可以有一个推论： 若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$ $Proof.$ 假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾 从而还可以有个定理（$Lagrange$定理）： 由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么 $$|G|=|H|\cdot [G:H]$$ 也就是说$|H|$是$|G|$的约数。 这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。 但是其实这是个很伟大的定理$233$ 好的，那么从而就会有一些神奇的推论： 推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ $Proof.$ 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ 推论二：对任意的$a \in G,a ^{|G|} = e$ $Proof.$ 比较显然，由推论一可知。 推论三：若$|G|$为素数，则$G$是循环群 $Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。 接下来我们真的要去做些好玩的了~ 定理$1$·$Fermat$小定理如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $ $Proof. $考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知： $$\forall a\in G, a^{p-1}=1(\mod p)$$ 定理2·$Euler$定理$a^{\phi(n)}=1 (\mod n)$ $Proof.$考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法 那么会有$|G|=\phi(n)$，从而有： $$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$ 没错，证明十分的简洁美观。 作者被这种神奇的证明给折服了$stO$.]]></content>
      <tags>
        <tag>抽象代数-群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$\rm{BSGS-Junior}·$BSGS算法初探]]></title>
    <url>%2F2019%2F02%2F06%2FBSGS-junior%2F</url>
    <content type="text"><![CDATA[$BSGS$$\rm{0x01}$ $\mathcal{Preface}$$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法。当然也会被叫做拔山盖世、北上广深算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : 给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x​$, 使得$a^x≡ b~(\mod p)​$而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)​$，并且我们还知道$a^0=1≡1 ~(\mod p)​$，所以我们可以得出一个断言： 如果方程$a^x≡ b~(\mod p)​$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))​$中 $\qquad \qquad(1) ​$ 此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。 之后我们将以此为基础进行类似分块的操作—— $\rm{0x02~~Baby~Step~Giant~Step}$首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：$$a^{i\cdot n+j}≡ b~(\mod p)$$移一下项就可以变成$$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$$那么现在我们的策略是算出所有$a^j$来，在$\mod p$ 意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做小步$(\rm{Baby~Step})$， 称右边枚举$b \cdot a^{-i\cdot n}$叫做大步$~(\rm{Giant~Step})$。 那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。 123456789101112131415161718inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "-1" &lt;&lt; endl ;&#125; 其中细节还是有的： 计算sqrt时要上取整。 我们在求$a^{-i\cdot n}​$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。 两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$ 算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的Q就会=0，从而在下面的第二个循环处出错——我们的hash[i]和j不能同时为$0$，从而输出错误的答案。 $\rm{0x03}$ 例题$T1~$$LuoguP4028$ 裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;tr1/unordered_map&gt;#define LL long longusing namespace std ; using namespace tr1 ; int T ;LL A, B, M, P, Q ; unordered_map &lt;LL, LL&gt; Hash ;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ;&#125;inline LL qr()&#123; LL res = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res ;&#125;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; M = qr(), A = qr(), B = qr() ; if ((!(A % M == 0 &amp;&amp; B))) bsgs(A, B, M) ; else cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ; &#125; return 0 ;&#125; $T2~$ $TJOI2007~Cute~Prime​$ 最裸最裸的、无特判的题……可以水一下双倍经验。 $\mathfrak{writter: pks}$]]></content>
      <tags>
        <tag>BSGS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$LCT's ~Junior ~Intro·$LCT入门]]></title>
    <url>%2F2019%2F02%2F04%2FLCT-s-Junior-Intro%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护森林连通性的。 嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。 但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转$Luogu3391$，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。 也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。 $\rm{0x02}$ 闲话 · 关于$\rm{splay}$道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢 历史的重任最后落到了$\rm{splay}​$的身上。然后$\rm{splay}​$他居然： 他甚至还： …… 好吧，由于某些rqy也不知道的原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$ $\rm{0x03}$ $LCT$的思路和基础操作一 主要思路主要思路嘛……大概是基于实链剖分的操作。 朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。 而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。 实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。 那么接下来我们来看一个$LCT​$是如何定义的: 首先，一棵$LCT​$管控的是一对分散的点，点以几棵分散的$splay​$的形式聚集。起初整棵$LCT​$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access​$、$makeroot​$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT​$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。 实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别： 虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。 实边是完整的双向存储。 $\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。 如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱. 二 基础操作$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作，我们这个地方先把点$n$所在联通块儿内的树的根记作$root(n) $，把与$n$以实边相连的儿子记作实儿子。 $\rm{1}$ $Access$ 这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是$Access(n)$表示从$root(n)$向$n$打通一条实链，并以$n$点为最深度最大的点、$root(n)$为深度最小的点形成一棵$\rm{splay}$。 不难看出，这个操作其实跟是一种逻辑层面的自我调控，没有改变原树的结构。 我们思考，如果此时我们$Access​$完点$n​$之后，理论上来讲，$n​$点应该不再有实儿子了——显然，如果有实儿子的话，$splay​$中是应该包含这个实儿子的——而这就不符合$n​$是$\rm{splay}​$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}​$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}​$连上。 1234inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125; 然后这就是$Access​$了。 $2 ~~Make~ Root~$ $make_root​$先从原来的根向$n​$打通一条路径，然后$splay​$上去，最后$reverse​$一下。此处由于一开始$n​$的深度最大，$splay​$之后深度依旧最大，但此时$n​$是$splay​$的根，所以$reverse(n)​$就相当于翻转了整条树上的链，那么翻转之后，$n​$的深度就变成了最小，于是就是这个联通块儿的根节点了。 1234567891011121314151617181920#define lc T[x].Son[0]#define rc T[x].Son[1]struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; inline void splay(int x) ;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void splay(int x)&#123;int qwq = x ; stk.push(qwq) ;while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;while(!stk.empty()) push_down(stk.top()), stk.pop() ;while(check(x))&#123;int fa = T[x].F, g_fa = T[fa].F ;if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125;&#125; 此处$splay$中由于要下放标记，保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。 $3 ~Merge~$ 此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。 1inline void Merge(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125; $4~~Link~\&amp;~Cut$ 如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。 12inline void Link(int x, int y)&#123; Rooten(x) ; T[x].F = y ;&#125;inline void Cut(int x, int y)&#123; Merge(x, y) ; T[x].F = T[y].Son[0] = 0 ;&#125; 此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。 但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作…… $New-Link$ 12inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125; 此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233 但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。 多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根 $New-Cut$ 12345inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125; 此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。 之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$Depth(x) &lt; Depth(y\text{的左儿子们}) &lt; Depth(y)$，其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。 剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。 5 $~Rotate$中的坑点 呃……其实就一处而已。就是： 123456inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void rotate(int x) &#123; int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125; 这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g_fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$ 剩下的……大概就没了吧…… 于是—— $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 300233#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)using namespace std ;struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; stack &lt;int&gt; stk ;int base[MAXN], N, M, A, B, C, i ;inline int Find(int x) ;inline void splay(int x) ;inline void push_down(int x) ;inline void update(int x) &#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;inline void rotate(int x) &#123;int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125;inline void splay(int x)&#123; int qwq = x ; stk.push(qwq) ; while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ; while(!stk.empty()) push_down(stk.top()), stk.pop() ; while(check(x))&#123; int fa = T[x].F, g_fa = T[fa].F ; if (check(fa)) &#123; rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ; &#125;&#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void split(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125;inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; rep(i, 1, N) scanf("%lld", &amp;base[i]) ; rep(i, 1, M)&#123; scanf("%d%d%d", &amp;A, &amp;B, &amp;C) ; if (A == 0) split(B, C), printf("%d\n", T[C].S) ; else if (A == 1) Link(B, C) ; else if (A == 2) Cut(B, C) ; else splay(B), base[B] = C ; &#125; return 0 ;&#125; $\rm{0x00}$ 后记和参考可写完了……嗝……打个肥宅嗝犒劳犒劳自己 怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨…… 写博客真是一个陶冶情操的过程啊……包括做表情包 加油吧，$pks$！ $\rm{Reference}$ $[1]$ :$Flash_Hu$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :某篇论文，结合食用效果显著 $^{^{[\nearrow]}}$ $\mathfrak{writter:pks}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>LCT-Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$Intro$]]></title>
    <url>%2F2019%2F02%2F04%2FIntro-1%2F</url>
    <content type="text"><![CDATA[Hello, here is Orchidany, a high-school student from S.D., China. Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is Olympiad in Informatics，shorthanded for OI. And this blog is mainly gonna to record my Learning Steps. Although I’m a bit weak in OI by now, but I shall catch the glimmer and keep getting stronger! See you soon in my articles ! Somthing Special Errr…About this ID Orchidany, there is a theory about that: My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) : 鹃住落英满，柳拂溪畔沙。南城略炊烟，浣女徐归家。故人今安否，欲歌口偏哑。笔寒下梅去，皎月半洒花 So……I’ m glad to encounter you!]]></content>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流$2$·$HLPP$+丧心病狂的优化]]></title>
    <url>%2F2019%2F01%2F11%2FHLPP%2F</url>
    <content type="text"><![CDATA[$\mathfrak{HLPP}$嗯，我也不知道我在月考即将爆炸 + $NOIp$即将爆炸之际，学$HLPP$的目的何在$\rm{TAT}$。 #define $u$的伴点集合 与$u$相隔一条边的且$u$能达到的点的集合 $0x00~ {}~Preface$ $HLPP(Highest~Label~Preflow~Push)​$最高标签预流推进算法是处理网络最大流里两种常用方法——增广路&amp;预流推进中，预流推进算法的一种。据传由$tarjan​$发明怎么又是他 ，并被其他科学家证明了其复杂度是紧却的$O(n^2\sqrt m)​$。在随机数据中不逊色于普通的增广路算法，而在精心构造的数据中无法被卡，所以是一种可以替代$Dinic​$的方法（随我怎么说，代码又长又难调，所以还是$Dinic​$好啊$\rm{TAT}​$） 但无论怎样，$wiki$里面已经承认$HLPP$是现在最优秀的网络流算法了。 那么预流推进这个大门类里面，思想都差不多。大抵上就是我们对每个点记录超额流($Extra~Flow$) ，即允许流在非源点暂时存储，并伺机将超额流推送出去。不可推送的，就会流回源点。那么最终答案显然存储在$Extra[T]$里面。 但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用最高标号的策略，给每个点一个高度，对于一个点$u​$以及它的伴点集合${v}​$，当且仅当$h_u = h_v + 1​$ 时才可以推送流。并且我们对于源点$S​$，设置$h_S = N​$，并对于$S​$实行无限制推送。那么最后的答案就保存在$Extra[T]​$里面 。 但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑拔高它的高度，即重贴标签($relabel​$)操作。 $0x01$ 初步的算法流程以下我们用$Extra_u$表示$u$的超额流，$h_u$表示$u$的高度，用$f_k$表示边$k$的容量。 首先把所有的$h_i$都置为零，并把$h_s$置为$N$（点数）。 将$S$的流推送到每个与$S$相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。 对于点$u$推送过程中，如果$Extra_u$减到了$0$，就立即退出（优化一） 对于每条出边$k$，推送的流量$F = min(f_k,Extra_u)$并执行两个点（$u,v$）的超额流增减。如果$v$不在堆里面，要把$v$放到堆里面。 如果推送完毕$Extra[u]$不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度$h_{min}$，则新的$h_u = h_{min}+1$，并把$u​$入堆。 好的，然后就可以撒花了……可是等等，他怎么这么慢$qaq$ 接下来我们发现，重贴标签的过程似乎与$ISAP$有点点像……所以我们不妨通过一个$Gap$数组来记录”断层情况“：即如果对于一个点$u$来说，他的伴点集${v}$已经不存在$h_u = h_v + 1$的点了，并且也不存在一个点$j$使得$h_j = h_u$那么这个地方就是一个断层$(Gap)$ ，那么也就是说，对于所有$h_i&gt; h_u$的点来说，它们把流推送到$h_u$的高度就不能继续推送了，所以我们直接$h_i = N + 1$，让他们回流到源点。（优化二） 接下来这个优化，亲测可以提速$4000ms​$，平均每个测试点提速$700​$ ~ $800ms​$，去掉数据最小的点，每个点平均提速$1000ms​$。这就是——$BFS​$! 我们不妨一开始就倒着$BFS$一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度（源点高度还是$N$。嗯，$Mr_Spade$大佬实在太强了$qwq$ 对了，代码实现方面，需要好多判断不是源点和汇点的小细节……无路赛无路赛无路赛$&gt;_&lt;$！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//省略某些部分#define Inf, MAXN, MAXM, to(k)struct state&#123; int num, h ; bool operator &lt;(const state &amp; now) const&#123; return h &lt; now.h ; &#125;&#125; ; priority_queue &lt;state&gt; heap ; BFS init ;int N, M, S, T, cnt = -1, A, B, C, D, t, min_h ;int head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;inline void Preflow_Push()&#123; register int i, k ; for (i = 1 ; i &lt;= N ; ++ i) if(H[i] &lt; Inf) ++ Gap[H[i]] ; for(k = head[S]; k != -1 ; k = E[k].next) if((t = E[k].f))&#123; E[k].f -= t, E[k ^ 1].f += t, Extra[S] -= t, Extra[to(k)] += t ; if(to(k) != T &amp;&amp; !vis[to(k)]) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; while(!heap.empty())&#123; vis[node = heap.top().num] = 0, min_h = Inf, heap.pop() ; for(k = head[node] ; k != -1 ; k = E[k].next)&#123; if(E[k].f &amp;&amp; H[node] == H[to(k)] + 1)&#123; t = min(Extra[node], E[k].f) ; E[k].f -= t, E[k ^ 1].f += t, Extra[node] -= t, Extra[to(k)] += t ; if(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; if (E[k].f) min_h = min(min_h, H[to(k)]) ; if (!Extra[node]) break ; &#125; if(Extra[node]) &#123; if (!--Gap[H[node]]) for(i = 1; i &lt;= N ; ++ i) if(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + 1) H[i] = N + 1 ; H[node] = Inf; H[node] = min_h + 1 ; heap.push((state)&#123;node, H[node]&#125;), vis[node] = 1, ++ Gap[H[node]] ; &#125; &#125;&#125;inline int read() &#123;fast;&#125;int main()&#123; Input() ; for (i = 1 ; i &lt;= N ; ++ i) head[i] = -1, H[i] = Inf ; while(M --)&#123;Add; &#125; q.push(T), H[T] = 0 ; while(!q.empty())&#123; int now = q.front() ; q.pop() ; for(k = head[now] ; k != -1 ; k = E[k].next) if (H[to(k)] &gt; H[now] + 1) H[E[k].to] = H[now] + 1, q.push(E[k].to) ; &#125; if (H[S] == 0) &#123;cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ;&#125; H[S] = N, Preflow_Push() ; cout &lt;&lt; Extra[T] &lt;&lt; endl ;&#125; 看起来我们加上下面这一句话的毒瘤卡常就可以有$4000ms$左右的好成绩，但事实上，这个速度依旧慢的要死。 注意！这个写法是经典写法，其时间复杂度是紧却的$\boldsymbol{\rm{\Theta(n^2mlogn)}}$的，也就是说在$\boldsymbol{n=1200}$时会带一个$\boldsymbol{10}$倍的常数 怎么优化呢—— $\boldsymbol{0x02~~Optimization}$各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）…… 来，我们首先思考思考普通的HLPP到底会慢在哪里： $STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！ 每次$Gap$优化，我们的时间复杂度是紧确的$\Theta(n)$。的这显然不合算，因为假设我当前的$\boldsymbol{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会浪费$\boldsymbol{\Theta(n)}$的时间。 事实上…普通的$HLPP$代码并不长，主要问题就是这两个。 我们考虑，如果不用堆的话怎么做呢？ 呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，高度函数$\boldsymbol{H(x)}$和点数集大小$\boldsymbol{N(x)}$是广义同阶的。 换句话说，我们可以考虑从高度入手。 换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\boldsymbol{O(n)}$而不是$\boldsymbol{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。 那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。 也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333 hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。 好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花… 哦对，还有几点我debug的时候被坑死的点： 那个$Iterator$类型的$vector$对象是点的编号不是高度！ 注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质wrnm，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$ (我觉得写的很难看但是有注释qaq)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//writter:Orchidany(pks)#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")//sb毒瘤优化#define MAXN 10030#define min my_min#define BG begin()#define gc getchar#define rr register #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;//list，就是快（//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; /*vector存边（据说会快）*/vector&lt;List::iterator&gt; Era_pos ; //辅助定位+删除inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;//黑科技inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = gc() ; while (!isdigit(c)) c = gc() ;while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = gc() ; return k ; &#125;inline void Init_label()&#123;//等价于一开始的那个BFS，只执行一次 rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; H.assign(N + 1, N + 1) ; H[T] = 0 ; q[t ++] = T ;//从T（高度小的）向前标号 while (h &lt; t)&#123;//队列……BFS……真熟悉啊……嗝…… rr int now = q[h] ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == N + 1 &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + 1, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N + 1) Set[i].clear(), Gap[i].clear() ;//还是清空一下比较好吧 rep(i, 0, N) if (H[i] &lt;N + 1) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), //疑似insert函数的返回值是一个指针qaq (Extra[i]&gt;0) ? Set[H[i]].push_back(i) : eggs() ;//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同… max_H = now_H = H[q[-- t]] ; //更新，BFS的性质，最后一个元素一定高度最大（除了源点）&#125;inline void Push(int x, Edge &amp;e)&#123;//单独写出来的push函数，好像很方便？ rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into "heap"&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0)//如果可以流 if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123;//如果出现断层了 for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)//这个gap的for肯定比O(n)优秀 for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; /*断层以上的高度都没用了*/return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; //重贴标签操作，为当前点删除原来的高度 ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;//增添新的高度&#125;inline int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt.assign(N, 0), cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] =- INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; //下面源点要单独拿出来推送，因为源点推送时高度差不需要=1. Init_label() ; //初始化（BFS） while (now_H &gt;= 0) //正式开始HLPP（泪目） if (Set[now_H].empty()) now_H -- ; //高度递减，实现一个堆的效果 else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ; return Extra[T] + INF ;&#125;int main()&#123; N = qr(),; rr int i ;//下面的++N是为了日后好操作qaq rep(i, 1, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125; 下面是个$fread$卡常版本$qaq$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#define MAXN 1202#define min my_min#define BG begin()#define rr register#define swap my_swap #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;const int ch_top=4e7+3;char ch[ch_top],*now_r=ch-1,*now_w=ch-1;inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x;&#125;inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w='\n';&#125;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; vector&lt;List::iterator&gt; Era_pos ; inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline void Init_label()&#123; rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; rr int qaq = N + 1 ; H.assign(qaq, qaq) ; H[T] = 0 ; q[t ++] = T ; while (h &lt; t)&#123; rr int now = q[h], qwq = H[now] + 1 ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == qaq &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = qwq, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N - 1) Set[i].clear(), Gap[i].clear() ; rep(i, 0, N - 1) if (H[i] &lt; N) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] &gt; 0) ? Set[H[i]].push_back(i) : eggs() ; max_H = now_H = H[q[-- t]] ; &#125;inline void Push(int x, Edge &amp;e)&#123; rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into heap&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0) if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123; for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i) for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;&#125;int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; cnt.assign(N, 0) ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] = -INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; Init_label() ; while (now_H &gt;= 0) if (Set[now_H].empty()) now_H -- ; else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;return Extra[T] + INF ;&#125;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read(), S = read(), T = read() ; rr int i ; rep(i, 1, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,1,now_w-ch,stdout) ;&#125; 撒fa~$0x03~~$后记 这道题的经典版本好几个月之前我写了一天……然后今天又翻出来，发现了巨佬KevinYu抛了一个玉，我就打算优化一波……毒瘤啊，什么$vector$存边、$list$我都是第一次用呜呜…… 不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） 最后，人艰不拆，人艰不拆… $\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>目测用不到的算法之HLPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流1·$Dinic\&$费用流]]></title>
    <url>%2F2018%2F08%2F20%2Fnet-work-flow%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[网络流1·$Dinic\&amp;$费用流$0x00~ {}~Preface$$2333$这是好久之前学的了，不过一直在咕咕咕咕。 一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。 那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。那么，我们定义容量为$c(u,v) \in E ? c(u,v) : 0​$。在整张图中有一个源点和一个汇点，且对于每个点来说有$$\sum F_{in} = \sum F_{out}​$$并且我们人为的将$S​$的$F_{in}​$设置为$0​$，$F_{out}​$设置为$+\infty​$。$T​$正好相反。当然，如果非说不合适的话，可以将源点和汇点看做同一个点233. 通过线性规划我们可以证明的是最大流等价于最小割，而博主现在对线性规划还只是一知半解，等什么时候“贯通了”再整理博客吧233 好的，窝觉得定义什么的可以不说了，我们直接上$EK$ $0x01~$ 不知道可以用来干啥的$EK​$其实，$EK$身为大家眼中的$basis$算法，他居然是比$Dinic$晚发表的……$233$ 全程是$Edmond-Karp$ ,由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，是个比较没用的算法 他的原理就是，我们通过两个杀器来实现最大流： $Killer1:$增广路 这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。 $Killer2:$ 反向边 虽然图集与解是单射的逻辑关系，即虽然对于同一张图$G(U, V)$无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从$T$连向$S$的，等同于原来没反向边时的情况。 嗯，那么我们程序实现的时候，大概就是这样 12345678910111213141516171819202122232425bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125; 其中$Last$记录前驱，$dis$就是个$mark$，$_F$数组记录增广路上最大的流量 。 那我们接下来分析复杂度。值得注意的是，$EK$由于采用$BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}++$），所以在每条边都作为残量最小值增广一次之后（至多$m$次）最短路就会增加。而最短路最多从$2$增到$n$，所以最多增广$n \times m$次。而每次$bfs$至多是$\Theta(m)$的，所以总复杂度上界是$\Theta(nm^2)$ 但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以$EK$可以解决朴素的最大流问题。 全部的代码存档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ;&#125;e[MAX &lt;&lt; 1] ;int MAX_F, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; endl ; return 0 ;&#125; $0x02$ 据说可以拯救世界的$Dinic$那么接下来我们说$Dinic$，这个算法是由$Dinic$教授创造的$qwq$ 然后$Dinic$在$EK$的基础上，采用了两个新的优化方案： $Case1:$分层图 每次我们选择用$bfs + dfs$去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用$dfs$遍历这张增广网。 $Case2:$当前弧 我们依仗的是这一段（句）代码： 1for(int &amp;i=cur[now];i!=-1;i=line[i].nxt) 其中比较重要的是引用符号，此处引用的目的是不断更新$cur$，达到不重复枚举的目的。 那么整体代码就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;queue&gt; #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ; &#125;e[MAX &lt;&lt; 1] ; int A, B, C, i ;int head[MAX], cnt = -1, now, cur[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool bfs()&#123; queue&lt;int&gt; q ; fill(dis, dis + N + 23, 0) ; q.push(S), dis[S] = 1 ; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if (!dis[e[k].to] &amp;&amp; e[k].v) dis[e[k].to] = dis[now] + 1, q.push(e[k].to) ; &#125; &#125; return dis[T] ? 1 : 0 ;&#125;int dfs(int St, int Aim, int Flow)&#123; if (St == Aim || !Flow) return Flow ; int Fl, res = 0 ; for (int &amp;k = cur[St] ; k != -1; k = e[k].next) if (dis[e[k].to] == dis[St] + 1 &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123; res += Fl, e[k].v -= Fl, e[k ^ 1].v+= Fl ; Flow -= Fl ; if (!Flow) break ; &#125; return res ;&#125;int Dinic()&#123; int res = 0 ; while(bfs())&#123; for(i = 1; i &lt;= N; ++ i) cur[i] = head[i] ; res += dfs(S, T, 0x7fffffff) ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; cout &lt;&lt; Dinic() ; return 0 ;&#125; 嗯，那么我们不难看出$cur$其实就是为了防止我们不断重复枚举边。因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走。而复杂度没有变，但是确实会更快。 那么接下来证明一下$Dinic$的时间复杂度。 根据分层图而言，$t$的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有$n$次重新分层。而对于每次在增广网上的操作，至多有$m$条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共$O(2n)$的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。 很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。 据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。 最后我们来说一下费用流。 $0x03$ 费用流（最小费用最大流）其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把$EK$的$bfs$换成$SPFA$就行了233 至于为什么不能$dinic$，很显然是因为没法分层啊……$hhh$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v, c ;&#125;e[MAX &lt;&lt; 1] ;bool mark[MAX] ; int MAX_F, MAX_C, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w, int c)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool SPFA()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, Inf) ; fill(mark, mark + N + 1, 0) ; q.push(S), dis[S] = 0, mark[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; mark[now] = 0 ; for (int k = head[now]; k != -1 ; k = e[k].next) if (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123; dis[e[k].to] = dis[now] + e[k].c ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; if(!mark[e[k].to])&#123; q.push(e[k].to) ; mark[e[k].to] = 1 ; &#125; &#125; &#125; return dis[T] != Inf;&#125;void _EK()&#123; while(SPFA())&#123; now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt;" "&lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125; 但是$SPFA$他，他他他他他已经死在了$NOI2018$…… 那么我们考虑是否能用$dijkstra$来做。那我们要考虑的就是负权边，因为我们建的反向边是要把代价也跑回去的啊，所以我们致力于解决负权边问题。$rqy$当时是这么给我们讲的： 考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。 那么我们从点$S$到点$B$点的距离便从$dis_B$变成了$dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。 下面我们思考到底要选取什么作为势函数呢？ 我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的： 这为什么是对的呢? 考虑一条边 $u→v$ ，费用为 $c$ 。 如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 于是我们现在可以用 $Dijkstra$ 增广，很快而且更难卡( 至于代码，大概长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100010#define Inf 192608170using namespace std ;struct edge&#123; int to, next, c, f ;&#125;e[MAX &lt;&lt; 1] ; int H[MAX], S ;int dist[MAX], _F[MAX], Pre[MAX], i, k ;int N, M, A, B, C, D, cnt = -1, x1, x2, head[MAX] ;struct node&#123; int dist, num ; bool operator &lt;(const node &amp; now) const&#123;return dist &gt; now.dist ; &#125;&#125;; priority_queue&lt;node&gt; q ; bool vis[MAX] ; int Last[MAX], MAX_F, MAX_C, t, ww ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void Add(int u, int v, int f, int c)&#123; e[++ cnt].to = v, e[cnt].f = f ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].f = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool dijkstra()&#123; for (i = 1 ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = 0 ; q.push((node)&#123;0, S&#125;) ; dist[S] = 0 ; while(!q.empty())&#123; node now = q.top() ; q.pop() ; while(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop(); x1 = now.num, x2 = now.dist ; if(vis[x1]) continue ; vis[x1] = 1 ; for(k = head[x1] ; k != -1 ; k = e[k].next) if (e[k].f &gt; 0 &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123; int T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ; _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ; &#125; &#125; return dist[t] &lt; Inf ;&#125;inline void _EK()&#123; while(dijkstra())&#123; ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ; while(ww != S) e[Last[ww]].f -= _F[t], e[Last[ww] ^ 1].f += _F[t], ww = Pre[ww] ; for (i = 1 ; i &lt;= N ; ++ i) H[i] += dist[i] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ; for (i = 0 ; i &lt;= N ; ++ i) head[i] = -1 ; for (i = 1 ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; " " &lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
</search>
