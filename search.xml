<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随想 · 目次表</title>
    <url>/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p>
<a id="more"></a>
<p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p>
<p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p>
<p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>

        <div id="aplayer-UdynjIfe" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-UdynjIfe"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "花",
              author: "Hello Nico",
              url: "Hello Nico-花.flac",
              pic: "/2050/12/31/随想·目次表/qwq.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<p>以下是目录：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">篇目</th>
<th style="text-align:center">链接（点击即可）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">随想一 · 山丘</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想二 · 丘吉尔</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想四 · 故人</td>
<td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td>
</tr>
<tr>
<td style="text-align:center">随想五 · 手中没有红玫瑰</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想六 · 难</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想七 · 言叶之庭</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想八 · 逃吧</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想九 · 意义</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想十 · 繁星</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td>
</tr>
</tbody>
</table>
</div>
<p>第一篇大概是开始？</p>
<p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p>
<p>第三篇就是2018考完NOIP写的啦。</p>
<p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p>
<p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p>
<p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p>
<p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p>
<p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p>
<p>第九篇大概是「奇异人生」的读/观后感？</p>
<p>最后一篇…是秘密！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【公告】关于这个blog</title>
    <url>/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一个本blog的观光指南？虽然可能并没有人来逛QAQ</p>
<p>如果可以的话，谢谢你喜欢我！</p>
<a id="more"></a>
<h1 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h1><p>现在高二啦，坐标SD弱校，马上退役啦。</p>
<p>CSP-2019考的太菜，导致现在十分被动。</p>
<p>平时在学校处于停课状态。由于我们班大概都停课了，所以不是很担心。</p>
<p>其实挺热爱算法的吧？</p>
<p>CF平时真的不是很常打，所以并不像给CF的ID。sorry啦。</p>
<p>似乎具有鲜明的喷子属性，十分想摆脱这个 <code>tag</code> 。</p>
<p>QQ:2836531293</p>
<h1 id="关于闲扯"><a href="#关于闲扯" class="headerlink" title="关于闲扯"></a>关于闲扯</h1><p><del>关于如何刷访问量</del></p>
<p>首先是<strong>「随想」</strong> 系列。这个系列，从生理学上分析，大概是体内雌性激素水平提高的时候才会写出来的东西，都很感性，都有着丰富的情感喷薄。所以写这些东西的时候，我大概都莫得理智。</p>
<p>「随想」系列目录：<a href="https://www.orchidany.cn/2050/12/31/随想·目次表">戳</a></p>
<p>然后是新开的「生活碎片」系列。大概还是闲扯。但是这其中不会过多地掺杂很复杂的感情，更像是流水账。以后大部分时间可能只有这个会更新了。</p>
<p>「生活碎片」系列目录：<a href="https://www.orchidany.cn/2020/02/07/生活碎片目录/">戳</a></p>
<h1 id="关于OI"><a href="#关于OI" class="headerlink" title="关于OI"></a>关于OI</h1><p>大概以后算法学习就不会很涉及了？大部分都会是做题。有些 blog 可能有密码，需要的话可以来找我要。</p>
<p>个人比较讨厌一个题看一篇blog，太浪费空间<del>除了我想水blog的时候确实会这么做</del>。</p>
<h1 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h1><p>友链的话，可以加我的企鹅号申请，或者直接去侧边栏的 <code>Friends</code> 那一栏评论申请。</p>
<p>所有的朋友都会待在侧边栏 <code>Friends</code> 的页面中哦。</p>
<h1 id="关于留言"><a href="#关于留言" class="headerlink" title="关于留言"></a>关于留言</h1><p>请访问这个blog的人，务必去留言板留个言啊QAQ</p>
<p>我一个人很无聊的说QAQ</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片4】生化危机Resident Evil</title>
    <url>/2020/02/08/Life4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里可是《生化危机》系列的死忠！</p>
<p>其实这里放的是高一下学期某次语文课演讲的演讲稿了啦。</p>
<a id="more"></a>
<div class="pdf" target="./Lecture.pdf" height></div>
<p>才发现原来强制用WPS进行ppt转word，动画效果是莫得的，所以有些图片只能拼一起了，sad。</p>
<p>如果pdf加载不出来，推荐 <code>firefox</code> 浏览器或者等上那么一二三四…五六十分钟（huaji</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>「生活碎片」系列目录</title>
    <url>/2020/02/07/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>出这个系列，原因是想瞎写点东西记录生活。有别于「随想」系列，这些文章的感情不是那么浓厚，大概是记录比较正常的生活点滴。</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">篇目</th>
<th style="text-align:center">链接（点击即可）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">「生活碎片0」CSP2019游记</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片1」一个小开始</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/15/Life1/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片2」原来我还什么都不懂</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/23/Life2/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片3」Life is strange</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/24/Life3/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片4」生化危机Resident Evil</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/02/08/Life4/#more">$Link$</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】杜教筛</title>
    <url>/2020/01/24/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种比较快的筛法？</p>
<p>用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：</p>
<script type="math/tex; mode=display">
\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\
\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>得出来的：</p>
<script type="math/tex; mode=display">
\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。</p>
<a id="more"></a>
<p>似乎很简单？因为这种题的难点在于构造，构造完了就可以分块做了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	ll s = sum(<span class="number">1</span>, n, f * g) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>) </span><br><span class="line">    r = n / (n / l), s -= solve(n / l) * sum(<span class="number">1</span>, l, g) ;</span><br><span class="line"> 	<span class="keyword">return</span> (s /= g(<span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这么做的复杂度不对。考虑这样一个引理：</p>
<script type="math/tex; mode=display">
\forall x,y,z\in\mathbb{Z},\quad \left\lfloor\frac{\left\lfloor\frac{z}{x}\right\rfloor}{y}\right\rfloor=\left\lfloor\frac{z}{x y}\right\rfloor</script><p>证明大概是把 $z$ 设成带余除法的标准形式，然后搞一下就可以了。此处略去。</p>
<p>于是发现，其实每次要计算的 $n’$ ，都是某个 $\lfloor \frac{n}{x}\rfloor$ ，因为假设这次是 $\lfloor \frac{n}{x}\rfloor$ ，下次是 $\lfloor \frac{\lfloor \frac{n}{x}\rfloor}{y}\rfloor=\lfloor \frac{n}{x\cdot y}\rfloor$ 。所以 $\sqrt n$ 为上界，可以直接通过 $\lfloor \frac{n}{x}\rfloor $ 记忆化所有的 $x$ 。</p>
<p>同时，发现对于 $x$ 的调用，都只会是 </p>
<script type="math/tex; mode=display">
1,2,3\dots \sqrt n,\lfloor{\frac{n}{1}}\rfloor,\lfloor{\frac{n}{2}}\rfloor,\lfloor{\frac{n}{3}}\rfloor\dots\lfloor{\frac{n}{\sqrt n}}\rfloor</script><p>这些数，且每次计算 $\mathbf{S}$ 的复杂度都是 $\sqrt n$ 。所以最终复杂度是：</p>
<script type="math/tex; mode=display">
O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{i}+\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\int_{1}^{\sqrt{n}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{\frac{3}{4}}\right)</script><p>其实就是两步近似。</p>
<p>然而可以做到更优，即发现对于一些很小的 $n’$ ，完全可以直接预处理出来。所以假设对于前 $p(0&lt;p&lt;1)$ 的 $\mathbf S$ 直接预处理，那么复杂度会变成：</p>
<script type="math/tex; mode=display">
O\left(n^{p}+\sum_{i=1}^{n^{1-p}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(n^{p}+\int_{1}^{n^{1-p}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{p}+n^{1-\frac{1}{2} p}\right)</script><p>发现此时取 $p=\frac{2}{3}$ 为最优，所以复杂度 $O(n^{\frac{2}{3}})$。</p>
<p>草，据说这东西是 xudyh 在考场上构造出来的，这也太神了吧…</p>
<h1 id="1-例题"><a href="#1-例题" class="headerlink" title="$1$ 例题"></a>$1$ 例题</h1><h2 id="LG4213-【模板】杜教筛（Sum）"><a href="#LG4213-【模板】杜教筛（Sum）" class="headerlink" title="LG4213 【模板】杜教筛（Sum）"></a>LG4213 【模板】杜教筛（Sum）</h2><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\begin{aligned}
&a n s_{1}=\sum_{i=1}^{n} \varphi(i)\\
&a n s_{2}=\sum_{i=1}^{n} \mu(i)
\end{aligned}</script><p>$1\leq n\leq 2\times 10^9$</p>
</blockquote>
<p>考虑杜教筛。</p>
<p>考虑如何构造 $\varphi$ 的 $g$ 。发现有 $\sum_{d|n}\varphi(d)=n$，即 $\varphi <em> \mathbf{1}=\bf Id$，那么 $\bf f</em>g$ 就是 $\frac{n\cdot (n+1)}{2}$。</p>
<p>考虑如何构造 $\mu$ 的 $g$ 。发现有 $\sum_{d|n}\mu(d)=[n=1]$，即 $\mu <em> \bf 1 = ϵ$，那么 $\bf f</em>g$ 就是 $[n=1]$。</p>
<p>然后就没有然后了。去年 $6$ 月我写的是不带记忆化的，慢的很。今天重写加了记忆化，复杂度看起来还可以？但是不知道为啥被 <code>min_25</code> 吊着锤。(其实也就快一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXS 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> T, N, S ; </span><br><span class="line"><span class="keyword">bool</span> chk[MAXN] ; </span><br><span class="line">LL phi[MAXN], Mu[MAXN] ; </span><br><span class="line">LL Smu[MAXS], Sphi[MAXS] ;</span><br><span class="line"><span class="keyword">int</span> pr[MAXN], t, i, j, x ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">	Mu[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; MAXN ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!chk[i]) </span><br><span class="line">      pr[++ t] = i, Mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= t &amp;&amp; pr[j] * i &lt; MAXN ; ++ j)&#123;</span><br><span class="line">			chk[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123; </span><br><span class="line">        phi[i * pr[j]] = phi[i] * pr[j] ; </span><br><span class="line">        <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">      	Mu[i * pr[j]] = - Mu[i],</span><br><span class="line">        phi[i * pr[j]] = phi[i] * phi[pr[j]] ;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; MAXN ; ++ i) Mu[i] = Mu[i - <span class="number">1</span>] + Mu[i], phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_Mu</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> Mu[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Smu[p]) <span class="keyword">return</span> Smu[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Smu[N / p]) <span class="keyword">return</span> Smu[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line">	<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_Mu(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Smu[N / p] = ret) : (Smu[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> phi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Sphi[p]) <span class="keyword">return</span> Sphi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Sphi[N / p]) <span class="keyword">return</span> Sphi[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1l</span>l * (<span class="number">1</span> + p) * p / <span class="number">2L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line">	<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_phi(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Sphi[N / p] = ret) : (Sphi[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T, init() ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N, S = <span class="built_in">sqrt</span>(N) ;</span><br><span class="line">        <span class="built_in">memset</span>(Smu, <span class="number">0</span>, <span class="keyword">sizeof</span>(Smu)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Sphi, <span class="number">0</span>, <span class="keyword">sizeof</span>(Sphi)) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get_phi(N) &lt;&lt; <span class="string">" "</span> &lt;&lt; get_Mu(N) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="$3$ 高级应用"></a>$3$ 高级应用</h1><p> 高级应用：我不是很会的应用（</p>
<blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\left(\sum_{i=1}^{n} \sum_{j=1}^{n} i \cdot j \cdot \operatorname{gcd}(i, j)\right) \bmod p</script><p>$p\in \mathbb{P},1\leq n\leq 10^{10}$ .</p>
</blockquote>
<p>首先是朴素反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n} \sum_{j=1}^{n} i\cdot j\cdot \operatorname{gcd}(i, j)\\
=&\sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot\sum_{d|i\operatorname{and}d|j} \varphi(d)\\
=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}i\cdot j\\
=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \left(\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\right)^2\\
\end{aligned}</script><p>然后发现前面都是完全积性，后面那个平方里面还带着求和不是很好搞…</p>
<p>这个地方有个很牛的引理：</p>
<script type="math/tex; mode=display">
\left(\sum_{i=1}^xi\right)^2=\sum_{i=1}^{x}i^3</script><p>这东西大概是能归纳出来的。似乎还没有什么比较有趣的证明<del>约等于只能选择背过</del></p>
<p>然后就是</p>
<script type="math/tex; mode=display">
\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}p^3</script><p><del>发现都比较容易算，并且都积性，于是就可以直接杜教筛了。</del></p>
<p>上句话在扯 $p$。后面那一坨根本没法筛。于是考虑整除分块套一个杜教筛。这样复杂度还是 $n^{\frac{2}{3}}$ ！！这点很重要！！因为本质上我的整除分块还是在枚举某些 $\lfloor\frac{\lfloor\frac{n}{l}\rfloor}{x}\rfloor$。于是该记下来的不多不少，还是记下来了，复杂度不变。</p>
<p>代码实现有点细节，还需要多学习多积累。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; pq ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXNN], chk[MAXN] ;</span><br><span class="line">LL Inv6, Inv4, cnt, p[MAXNN] ;</span><br><span class="line">LL P ; LL N, Sp[MAXN], phi[MAXNN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL l, LL r)</span></span>&#123;</span><br><span class="line">    l -- ; l %= P, r %= P ;</span><br><span class="line">    LL r1 = r * (r + <span class="number">1</span>) % P * (<span class="number">2</span> * r + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    LL r2 = l * (l + <span class="number">1</span>) % P * (<span class="number">2</span> * l + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    <span class="keyword">return</span> ((r1 - r2) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calcc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans ; x %= P ;</span><br><span class="line">    ans = x * x % P ;</span><br><span class="line">    (ans *= Inv4) %= P ;</span><br><span class="line">    (ans *= (x + <span class="number">1</span>) % P * (x + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; MAXNN)</span><br><span class="line">        <span class="keyword">return</span> phi[x] ;</span><br><span class="line">    LL y = N / x ;</span><br><span class="line">    <span class="keyword">if</span> (chk[y]) <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">    chk[y] = <span class="number">1</span> ; LL &amp;ans = Sp[y] ;</span><br><span class="line">    ans = calcc(x) ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l),</span><br><span class="line">        (ans -= calc(l, r) * solve(x / l) % P) %= P ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += P ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l) ;</span><br><span class="line">        (res += (solve(r) - solve(l - <span class="number">1</span>)) * calcc(x / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; N ; phi[<span class="number">1</span>] = vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    Inv4 = expow(<span class="number">4</span>, P - <span class="number">2</span>), Inv6 = expow(<span class="number">6</span>, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXNN ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] * i &gt;= MAXNN) <span class="keyword">break</span> ;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * p[j]] = phi[i] * p[j] % P ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]] % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXNN ; ++ i) </span><br><span class="line">      (phi[i] = <span class="number">1l</span>l * i * i % P * phi[i] + phi[i - <span class="number">1</span>]) %= P ;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; phi[8000000] &lt;&lt; endl ; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, work(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>数学/积性函数/欧拉反演</tag>
        <tag>数学/积性函数求和/杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2353 [NOI2007]货币兑换</title>
    <url>/2020/01/24/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某CDQ好题.</p>
<p><del>没人看出上面这句话是有俩含义吗</del></p>
<a id="more"></a>
<p>小Y最近在一家金券交易所工作。该金券交易所只发行交易两种金券：$A$ 纪念券（以下简称 $A$ 券）和 $B$ 纪念券（以下简称 $B$ 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。</p>
<p>每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 $A$ 券和 $B$ 券的价值分别为 $A_K$ 和 $B_K$ （元/单位金券）。</p>
<p>为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。</p>
<p>比例交易法分为两个方面：</p>
<p>a) 卖出金券：顾客提供一个 $[0，100]$ 内的实数 $\rm OP$ 作为卖出比例，其意义为：将 $\rm OP\%$ 的 $A$ 券和 $\rm OP\%$ 的 $B$ 券以当时的价值兑换为人民币；</p>
<p>b) 买入金券：顾客支付 $\rm IP$ 元人民币，交易所将会兑换给用户总价值为 $\rm IP$ 的金券，并且，满足提供给顾客的 $A$ 券和 $B$ 券的比例在第 $K$ 天恰好为 $\rm Rate_K$ ；</p>
<p>小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $\rm N$ 天内的 $A$ 券和 $B$ 券的价值以及 $\rm Rate$。他还希望能够计算出来，如果开始时拥有 $\rm S$ 元钱，那么 $\rm N$ 天后最多能够获得多少元钱。</p>
<p>其中 $\rm N\leq 10^5$.</p>
<p>首先想到 $dp$ 。这个地方设计的 $dp$ 个人感觉还是比较 $\rm tricky$ 的。发现本质上最大化 $A$ 券或者 $B$ 券的数量和最大化手里拿到的rmb都是某些最优决策，所以不能一起维护。</p>
<p>发现通过券来维护rmb比较方便，于是考虑设 $f_i$ 表示在第 $i$ 天把rmb都花完能得到多少 $A$ 券。初值显然是</p>
<script type="math/tex; mode=display">
m=f_1\cdot A_1+\frac{f_1\cdot B_1}{\rm Rate_1}\\
f_1=\frac{m\cdot\mathrm{Rate_1}}{A_1\cdot \mathrm{Rate_1}+B_1}</script><p>那么考虑如何以此计算rmb。发现第 $i$ 天可能会保有 $1\sim i-1$ 天时的金券。于是令 $g_i$ 表示前 $i$ 天的最大获利，发现可以这么转移：</p>
<script type="math/tex; mode=display">
g_i=\max_{1\leq j<i}(g_{i-1},f_j\cdot (A_i+\frac{B_i}{\rm Rate_j}))</script><p>转移的正确性在于，卖出的 $A$ 券和 $B$ 券的百分比必须一致，所以不会出现分多次卖的情况。于是喜提一个 $n^2$ 算法。</p>
<p>考虑优化。发现如果对于一个 $i$ 其转移点为 $j$，那么会有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_i&=f_j\cdot A_i+f_j\cdot \frac{B_i}{\rm Rate_j}\\
\frac{f_j}{\mathrm{Rate_j}}&=-\frac{A_i}{B_i}\cdot f_j+\frac{g_i}{B_i}
\end{aligned}</script><p>发现可以令 $y_i=\frac{f_i}{\mathrm{Rate_i}},x_i=f_i$ 。那么这就是一个斜率优化的标准形式。</p>
<p>但问题在于，$f_j$ 很悲惨的由于每天的兑换量有不同，它并不单增，并且斜率也不单增，所以不能用删除末尾几个（即单调队列）来维护凸壳，必须要用某些神秘 $\rm splay$ 技巧来加速这个过程。</p>
<p>然而还有另一种 $\rm CDQ$ 写法。大概就是考虑为了保证横坐标是单调的，所以要排序，但是排序之后转移就会失秩，而这个过程显然可以 $\rm CDQ$ 来优化，于是就没了。</p>
<p>值得注意的是，朴素的 $\rm CDQ$ 由于不需要严格按秩，即二进制拆分顺序不限，所以可以瞎分治。但是维护 $dp$ 的时候由于转移顺序必须按秩，所以有严格的分治顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cash</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, k ;</span><br><span class="line">    <span class="keyword">double</span> A, B, R ; <span class="keyword">int</span> ID ;</span><br><span class="line">&#125;T[MAXN], Div[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">double</span> M ; <span class="keyword">double</span> dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">double</span> Ans, t ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Ans = M, dp[<span class="number">1</span>] = M * T[<span class="number">1</span>].R / (T[<span class="number">1</span>].A * T[<span class="number">1</span>].R + T[<span class="number">1</span>].B) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">                Ans = max(Ans, dp[j] * T[i].A + dp[j] / T[j].R * T[i].B) ;</span><br><span class="line">            dp[i] = Ans * T[i].R / (T[i].A * T[i].R + T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, Ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CDQ&#123;</span><br><span class="line">    <span class="keyword">int</span> stk[MAXN] ; <span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e9</span>, eps = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Cash &amp; A, <span class="keyword">const</span> Cash &amp; B)</span></span>&#123; <span class="keyword">return</span> A.k &lt; B.k ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(T[d].x - T[b].x) &lt;= eps) <span class="keyword">return</span> INF ;</span><br><span class="line">        <span class="keyword">return</span> (T[d].y - T[b]. y) / (T[d].x - T[b].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L, r = Mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= Mid &amp;&amp; (r &gt; R || T[l].x &lt; T[r].x))</span><br><span class="line">        Div[i] = T[l ++]; <span class="keyword">else</span> Div[i] = T[r ++] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dp_CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">            dp[L] = max(dp[L], dp[L - <span class="number">1</span>]) ;<span class="comment">//?</span></span><br><span class="line">            T[L].y = dp[L] / (T[L].A * T[L].R + T[L].B), T[L].x = T[L].y * T[L].R ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//y : f[j] / Rate[j], x : f[j]。此处应该以f[j]单增来排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l = L - <span class="number">1</span>, r = Mid ; <span class="keyword">int</span> top = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (T[i].ID &lt;= Mid) Div[++ l] = T[i] ; <span class="keyword">else</span> Div[++ r] = T[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ; dp_CDQ(L, Mid) ; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= Mid ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt; getr(stk[top], i)) -- top ;</span><br><span class="line">            stk[++ top] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = Mid + <span class="number">1</span> ; i &lt;= R ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt;= T[i].k) -- top ;</span><br><span class="line">            dp[T[i].ID] = max(dp[T[i].ID], T[stk[top]].x * T[i].A + T[stk[top]].y * T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        dp_CDQ(Mid + <span class="number">1</span>, R), Merge_sort(L, R, Mid) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = M ;</span><br><span class="line">          sort(T + <span class="number">1</span>, T + N + <span class="number">1</span>, Compare) ;</span><br><span class="line">          dp_CDQ(<span class="number">1</span>, N) ; <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, dp[N]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen("1492.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//     freopen("1492.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;T[i].A, &amp;T[i].B, &amp;T[i].R),</span><br><span class="line">      T[i].k = -T[i].A / T[i].B, T[i].ID = i ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>) DP :: Solve1() ;</span><br><span class="line">      <span class="keyword">else</span> CDQ :: Solve2() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】CDQ分治</title>
    <url>/2020/01/24/CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是对操作分治的算法，算是我最早学过的离线分治算法了？</p>
<p>大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。</p>
<p>那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 </p>
<a id="more"></a>
<h1 id="loj-112-模板-三维偏序"><a href="#loj-112-模板-三维偏序" class="headerlink" title="loj#112 [模板]三维偏序"></a>loj#112 [模板]三维偏序</h1><blockquote>
<p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$、$b_i$、$c_i$三个属性。</p>
<p>设 $f_i$ 表示满足 $a_j\leq a_i$ 且 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的 $j$ 的数量。</p>
<p>对于 $\forall i \in [0,n)$ ，求 $f_j=i$ 的 $j$ 的数量。</p>
</blockquote>
<p>这不是传统意义上的 $\rm CDQ$ 。考虑 $\rm CDQ$ 在维护本质上是在维护一系列权值，通过分治统计前面对后面的贡献，类似于通过分治对全局的询问做时间上的二进制拆分。所以其实具有类似拆分性质的统计都可以这么实现。</p>
<p>回到这题，发现本质上三维数点也可以直接通过 $\rm CDQ$ 解决。考虑在分治完后，需要统计本层左区间对右区间的贡献。这时直接bit+扫描线即可，即按照一维排序，另一维用bit维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, K, bit[MAXN], res[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span> <span class="keyword">int</span> x, y, z, ans ; &#125;base[MAXN], t[MAXN] ;</span><br><span class="line">il <span class="keyword">bool</span> <span class="keyword">operator</span> == (nodes a, nodes b)&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.x == b.x) &amp; (a.y == b.y) &amp; (a.z == b.z) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">	<span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; p ; p -= low(p)) ret += bit[p] ; </span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> ; </span><br><span class="line">	<span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r ; </span><br><span class="line">	cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R) ;  </span><br><span class="line">	sort(base + L, base + Mid + <span class="number">1</span>, comp2), l = L ;</span><br><span class="line">	sort(base + Mid + <span class="number">1</span>, base + R + <span class="number">1</span>, comp2), r = Mid + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].y &lt;= base[r].y) </span><br><span class="line">			upd(base[l].z, <span class="number">1</span>), ++ l ; </span><br><span class="line">		base[r].ans += qry(base[r].z), ++ r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt; l ; ++ i) upd(base[i].z, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, o ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base[i].x = qr(), base[i].y = qr(), base[i].z = qr() ; </span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; cdq(<span class="number">1</span>, N) ;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>, j = o = <span class="number">0</span> ; i &lt;= N ; j = o = <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span> (base[i] == base[i - <span class="number">1</span>]) ++ i, ++ j ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) o = max(o, base[k].ans) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) base[k].ans = o ; <span class="keyword">if</span> (!j) ++ i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[base[i].ans] ++ ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Violet-天使玩偶-SYJ摆棋子"><a href="#Violet-天使玩偶-SYJ摆棋子" class="headerlink" title="[Violet] 天使玩偶/SYJ摆棋子"></a>[Violet] 天使玩偶/SYJ摆棋子</h1><blockquote>
<p>给定一张 $n\times m$ 的网格。</p>
<p>有两个操作，插入一个新的点或者询问离某个点欧几里得距离最近的点。</p>
<p>$n,m\leq 3\times10^5$ </p>
</blockquote>
<p>发现欧几里得距离即：</p>
<script type="math/tex; mode=display">
|x_i-x_j|+|y_i-y_j|</script><p>通过分类讨论可以得到有这么四类情况：</p>
<script type="math/tex; mode=display">
x_i-x_j+y_i-y_j\\
x_i-x_j-y_i+y_j\\
-x_i+x_j+y_i-y_j\\
-x_i+x_j-y_i+y_j\\</script><p>发现，其中第二种情况就是第一种按照 $x$ 轴对称了一下的结果，后两种类似。于是可以通过坐标变换都转化到第一种问题。</p>
<p>对于第一个问题，发现询问可以分段处理，于是想到 $\rm CDQ$ 。考虑如何处理离自己最近的点：</p>
<script type="math/tex; mode=display">
x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)</script><p>这样转化出来的两部分即具有差分性质（即可以拆），并且保证了只与时间轴有关（不再和网格图有关）。所以可以把 $x_i+y_i$ 插入进去，这样就可以用四遍 $\rm CDQ$ 做完这题了。</p>
<p>感觉还是很神仙的吧…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 192608170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, bit[MAXM], ans[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrys</span>&#123;</span> <span class="keyword">int</span> mk, id, x, y ; &#125;t[MAXN], q[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch_top 24000001</span></span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">7</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K &amp;&amp; bit[p] ; p += low(p)) bit[p] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] = max(bit[p], v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; p ; p -= low(p)) ret = max(ret, bit[p]) ; </span><br><span class="line">	<span class="keyword">return</span> ret ? ret : -Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R) <span class="keyword">return</span> ; </span><br><span class="line">	rg <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r, o = L ; </span><br><span class="line">	cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R), l = L, r = Mid + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].x &lt;= base[r].x)&#123;</span><br><span class="line">			<span class="keyword">if</span> (base[l].mk &lt; <span class="number">2</span>) </span><br><span class="line">				upd(base[l].y, base[l].x + base[l].y) ; </span><br><span class="line">			t[o ++] = base[l ++] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (base[r].mk &gt; <span class="number">1</span>) </span><br><span class="line">			ans[base[r].id] = min(ans[base[r].id], </span><br><span class="line">							  base[r].x + base[r].y - qry(base[r].y)) ; </span><br><span class="line">		t[o ++] = base[r ++] ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt; l ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (base[i].mk &lt; <span class="number">2</span>) del(base[i].y) ;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= Mid) t[o ++] = base[l ++] ; </span><br><span class="line">  <span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) base[i] = t[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ox, <span class="keyword">const</span> <span class="keyword">int</span> &amp;oy)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">		base[i] = q[i] ; </span><br><span class="line">		base[i].x = ox ? q[i].x : K - q[i].x, </span><br><span class="line">		base[i].y = oy ? q[i].y : K - q[i].y ;</span><br><span class="line">	&#125;</span><br><span class="line">	cdq(<span class="number">1</span>, N + M) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("data1.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//	freopen("data1.out", "w", stdout) ;</span></span><br><span class="line">	fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">	N = read(), M = read() ; <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		q[i].mk = <span class="number">1</span>, q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">		q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) </span><br><span class="line">		q[i].mk = read(), q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">		q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">	solve(<span class="number">1</span>, <span class="number">0</span>), solve(<span class="number">0</span>, <span class="number">1</span>), solve(<span class="number">1</span>, <span class="number">1</span>), solve(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="keyword">if</span> (q[i].mk &gt; <span class="number">1</span>) write(ans[i]) ;</span><br><span class="line">	fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不知道啥时候才能真正地灵活运用…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>CDQ分治</category>
      </categories>
      <tags>
        <tag>离线算法/CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片3】· Life is strange</title>
    <url>/2020/01/24/Life3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Life is strange, no matter who u are.</p>
</blockquote>
<a id="more"></a>
<p>初逢「奇异人生」这款游戏，还是从C菌那里了解的。但是这次不同以往，发现这东西在Mac上完全带的起来，于是就决定自己在steam上买来玩儿。虽然没有汉化，但是基本上还是很流畅的（除了有时候由于不知道在说哪国英语而疯狂卡关）。最后从C菌那里也成功地看到了第二个结局。</p>
<p>至于「奇异人生二」，则完全是在看C菌的实况。从19年 $4$ 月的第三章等到 $8$ 月，接着等到 $12$ 月，这部被先入为主的粉丝批评「没有第一部好」的杰作，终于迎来了它的 $\rm Ending$。结局共 $4$ 个，都体现了很高的「讲故事」水平，个人来讲这可能是我能想到最好的结局。</p>
<p>会有三吗？可能会有吧。对我来说，这是个有温度的公司，制作的有温度的游戏。每一帧画面、每一首 $\rm bgm$ 都是在不紧不慢地叙事，交织成一条缓缓流淌的河，流过主人公的奇异人生，流向远方。</p>
<p>那其中或许昭示着，每一种不同的生命状态都有其存在的意义和价值。换句话说，不论你活成什么样，都值得继续活下去。因为人生的意义，就在于活着。</p>
<!--more-->
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>其实 「奇异人生1」的剧情已经在 「随想9」里面说了很多啦。大概就是讲的两个妹子之间无可撼动的友谊遇上了滥用会导致天灾的超能力，最后（我选择）把 $\rm Acadia~ Bay$ 整个牺牲了换妹子的故事。</p>
<p>其实 $1$ 里面的剧情也好、世界也好，都仅仅是局限在 $\rm Acadia~ Bay$ 的一角而已，比起「二」中的「竖跨美国」来讲十分的狭窄。所以如果说「二」的主题是「成长」与「勇气」，那么「一」的主题可能会是「成长」与 「赋予意义」。</p>
<p>$\rm Max$ 生活的城市其实并不很好，学校里的环境也不完美。然而从 $\rm Max$ 掌握了超能力开始，她似乎可以拯救周围的一切了——救下要自杀的同学、解决了人际关系的漏洞、数次救回了在死亡边缘疯狂试探的 $\rm Cloye$ 。但是无论怎么改，到最后都无法创造一个完美的结局——可以说，到最后，让 $\rm Cloye$ 活着才是她最希望且唯一希望的事。</p>
<p>但其实，似乎制作者钦定的结局是牺牲 $\rm Cloye$ 而不是 $\rm Acadia~Bay$。这或许就更好地揭示了「赋予意义」这层含义：生活其实本身就是那样地充满 “$\rm Obstacles$” ，也没有什么可以拯救一切的超能力（因为 $\rm Max$ 的超能力滥用会导致日食、双月、飓风等非自然现象），所以大家都只是平凡活着的平凡人，做着自己喜欢的平凡的事，人生是否「奇异」不在于自己获得了什么天助的能力，在于给自己的平凡生活赋予了什么不凡的意义。「碌碌无为」的牢笼需要自己走出，拥有再强的超能力也只是加速了自己原地打转的速度而已。所以，可能学会「赋予意义」才是让每天都可以「翩翩起舞」的最佳方案。</p>
<p>所以最后 $\rm Cloye$ 被剧情杀了。可能这也是在告诉 $\rm Max$ 和我们，一切美好的东西都会逝去，如何对接下来的生活更好地赋予意义，才是真正需要思考的问题。</p>
<p>「一」中最受好评的，可能是其最后两章的叙事手法，简直是神来之笔。一遍遍回溯、一遍遍寻找，交叠的空间与时间，$\rm Max$ 拯救 $\rm Cloye$ 的过程，让人十分动容。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>「奇异人生二」跟「一」不同。主角兄弟俩一开始过着平稳安逸的生活，被突如其来的冲突打乱、被视为通缉犯，决定南下去墨西哥开启新生活，并在途中经历了一系列波折。这其中没有「一」中奇诡的剧情，但是横跨了比「一」更大的时空。</p>
<p>其实呢，「二」遭人诟病，是因为剧情比起「一」来水了很多。「二」中的作画和配乐依旧优秀、细节处理依然到位，但是剧情很薄。比起「一」中 $\rm Max$ 和 $\rm Cloye$ 无比真挚的友谊，「二」中没有激烈的情感喷薄，只是在淡淡地叙事罢了。</p>
<p>但是，「二」的剧情似乎被最后的结局给救了回来。最后一共有四个结局：</p>
<ul>
<li>1：弟弟用超能力炸毁了边境大门，和哥哥一起去了墨西哥。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「冲」才可以达成。最后他们在墨西哥开了间修车厂，过上了黑帮的生活。个人感觉不是一个很好的结局，因为本身他俩都是受害者，经历劫难之后似乎根本没有走出阴影，也就是「成长」的味道比较浅。</li>
<li>2：哥哥选择投降，但是弟弟不投降，执意冲过边境线但导致哥哥被流弹击杀。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「不冲」才可以达成。最后弟弟一个人在墨西哥开启了新的「秧歌star」生活…我觉得应该是最烂的结局了233</li>
<li>3：哥哥选择投降，弟弟也选择投降。这需要选择「不冲」并且弟弟被玩家教育的很懂事才可以。最后当然是哥哥被关了 $20+$ 年，弟弟由于是未成年人并且自首啥事没有，出来已经是中年人了。也不是很好吧233</li>
<li>4：哥哥选择冲，弟弟选择帮他炸开边境但是自己留了下来、接受制裁。这是我认为最好的结局。哥哥路上经历的一切有了报偿，弟弟也不再一味索求，选择主动奉献。最后的结局很美。哥哥在墨西哥给弟弟写信，弟弟在美国的外公外婆家里读信。两人都成长了、收获了自己应有的生活。</li>
</ul>
<p>「二」中的剧情，是慢慢地讲述着的。无论是他们重逢了他们的母亲，还是路上遇到一切的艰难险阻，都如同一条均匀地洒满金箔的河流，慢慢地流淌，慢慢地把闪光点展露出来。</p>
<p>这是 $\rm B$ 站里面四个结局的 $\rm Link$：<a href="https://www.bilibili.com/video/av78032043?from=search&amp;seid=1274319984559483706" target="_blank" rel="noopener">戳我</a></p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>「二」中也或多或少直径了第一部，于是会根据玩家第一部选择的是牺牲 $\rm Cloye$ 还是 $\rm Acadia~Bay$ 流了不同的彩蛋。</p>
<p>最后留个 $\rm Link$ 吧：<a href="https://www.bilibili.com/video/av78454677?from=search&amp;seid=2854200599543211488" target="_blank" rel="noopener">戳我</a> </p>
<p>你问我为什么不像以前一样写很长的篇末总结？</p>
<p>对于这种十分美好的东西，「让它淡淡的来，让他好好的去」才是最恰当的方案吧？</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究】用LCT维护MST</title>
    <url>/2020/01/24/LCT3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。</p>
<p>说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。</p>
<p>似乎很简单？就是很简单。</p>
<a id="more"></a>
<h1 id="LG3366-【模板】最小生成树"><a href="#LG3366-【模板】最小生成树" class="headerlink" title="LG3366 【模板】最小生成树"></a>LG3366 【模板】最小生成树</h1><p>就是贴个代码?</p>
<p>值得注意的是，需要把每一条边加入点，删除的话就只需要把与这条边相连的点之间的边断掉。</p>
<p>似乎没啥难的？LCT虽然说很长，但是似乎写起来很轻松诶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(k) e[k].vl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vl ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> val[M] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span>, swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), access(v), splay(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), fa(u) = v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    split(u, v) ;</span><br><span class="line">    fa(u) = lc(v) = <span class="number">0</span> ;</span><br><span class="line">    update(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//access(to(x)) ; </span></span><br><span class="line">	splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)),</span><br><span class="line">        qr(to(i)), qr(vl(i)) ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; vl(i) &lt;&lt; endl ;</span></span><br><span class="line">        fr(i) += m, to(i) += m ;</span><br><span class="line">        make_root(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(fr(i)) != to(i))</span><br><span class="line">            ans += vl(i), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[fr(i)]))&#123;</span><br><span class="line">			ans += vl(i) - vl(val[fr(i)]) ;</span><br><span class="line">        	cut(val[fr(i)]), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WC2006-水管局长"><a href="#WC2006-水管局长" class="headerlink" title="[WC2006]水管局长"></a>[WC2006]水管局长</h1><blockquote>
<p>要求动态维护一张图。</p>
<p>只有删边操作、动态询问 $x$ 到 $y$ 间所有路径上最大边权的最小值。</p>
</blockquote>
<p>那显然是在最小生成树上跑。</p>
<p>既有加边也有删边的MST是没法做的。因为删边的时候可能有一堆候选集合，这是无法简单维护的。但是只有加边或者只有删边的MST很简单。由于只有删边，所以倒着做一遍就完了。</p>
<p>hiahiahia，快来欣赏一下我特别棒的码风：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> o, u, v ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; to(i))</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        Id[mk_p(fr(i), to(i))] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span> ; i &lt;= m + q ; ++ i)&#123;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) &lt;= <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">            swap(u, v),</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        o = Id[mk_p(u, v)] ;</span><br><span class="line">        vis[o] = <span class="number">1</span>, mem[i] = o ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        u = fr(i) ;</span><br><span class="line">        v = to(i) ;</span><br><span class="line">        make_root(v) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">            link(u, i) ;</span><br><span class="line">            link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[u]))&#123;</span><br><span class="line">            dcut(val[u]) ;</span><br><span class="line">            link(u, i) ; link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + q ; i &gt; m ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">int</span> j = mem[i] ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) == <span class="number">1</span>)&#123;</span><br><span class="line">            merge(u, v) ;</span><br><span class="line">            ans[i - m] = vl(val[v]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            u = fr(j) ;</span><br><span class="line">            v = to(j) ;</span><br><span class="line">            make_root(v) ;</span><br><span class="line">            ans[i - m] = <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">                link(u, j) ;</span><br><span class="line">                link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vl(j) &lt; vl(val[fr(j)]))&#123;</span><br><span class="line">                dcut(val[u]) ;</span><br><span class="line">                link(u, j) ; link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOI2014-魔法森林"><a href="#NOI2014-魔法森林" class="headerlink" title="[NOI2014]魔法森林"></a>[NOI2014]魔法森林</h1><blockquote>
<p>给出一个 $n$ 个点，$m$ 条边的无向图，每条边都有权值 $a_i,b_i$ 。</p>
<p>求一条从点 $1$ 到点 $n$ 的路径，使得这条路径上边的 $a_i,b_i$ 最大值之和最小。</p>
<p>$2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5$。</p>
</blockquote>
<p>发现可以先把边权按照第一维排个序，然后做普通的lct维护MST就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        merge(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            merge(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我在水博客。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】LCT简单题选做</title>
    <url>/2020/01/24/LCT2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是重学了一遍 $\rm LCT$。然后整理一下之前做过的题？大多数都比较套路。</p>
<a id="more"></a>
<h1 id="SDOI2008-洞穴勘测"><a href="#SDOI2008-洞穴勘测" class="headerlink" title="[SDOI2008]洞穴勘测"></a>[SDOI2008]洞穴勘测</h1><blockquote>
<p>动态维护图的连通性。</p>
<p>保证任意时刻图的边数不超过 $n-1$ 条。</p>
</blockquote>
<p>发现是个sb线段树分治，然后随便写个lct就过了（</p>
<h1 id="COCI-2009-OTOCI-极地旅行社"><a href="#COCI-2009-OTOCI-极地旅行社" class="headerlink" title="[COCI 2009] OTOCI / 极地旅行社"></a>[COCI 2009] OTOCI / 极地旅行社</h1><blockquote>
<p>给出一张空图</p>
<ul>
<li><p><code>bridge u v</code>：询问结点 u与结点 $v$ 是否连通。如果是则输出 <code>no</code>；否则输出 <code>yes</code>，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。</p>
</li>
<li><p><code>penguins u x</code>：将结点 $u$ 对应的权值$ w_u$ 修改为 $x$。</p>
</li>
<li><p><code>excursion u v</code>：如果结点 $u$ 和结点 $v$ 不连通，则输出 <code>impossible</code>。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。</p>
</li>
</ul>
<p>保证两点存在至多一条路径。</p>
</blockquote>
<p>发现是个弱智题，随便维护一下就可以。</p>
<h1 id="BJOI2014-大融合"><a href="#BJOI2014-大融合" class="headerlink" title="[BJOI2014]大融合"></a>[BJOI2014]大融合</h1><blockquote>
<p>给出一张空图</p>
<ul>
<li><code>A x y</code> ：若 $x$ 和 $y$不连通则连边.</li>
<li><code>Q x y</code> ：询问 $a$ 和 $b$ 在边 $(x,y)$ 两端的 $(a,b)$ 点对数。 </li>
</ul>
</blockquote>
<p>考虑实儿子和虚儿子数量分别维护。发现只有 <code>access</code> 和 <code>link</code> 需要修改。于是魔改一下就做完了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">		splay(x), npn[x] += size[rc] - size[qwq], rc = qwq, push_up(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Access(x), splay(x), reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    Rooten(x), Access(y), splay(y) ;</span><br><span class="line">    T[x].F = y, npn[y] += size[x], push_up(y) ;</span><br><span class="line">&#125;<span class="comment">//npn维护虚儿子</span></span><br></pre></td></tr></table></figure>
<h1 id="国家集训队-Tree-II"><a href="#国家集训队-Tree-II" class="headerlink" title="[国家集训队]Tree II"></a>[国家集训队]Tree II</h1><blockquote>
<p>一棵 $n$ 个点的树，每个点的初始权值为 $1$。</p>
<p>对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：</p>
<ul>
<li><code>+ u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都加上自然数 $c$ ；</li>
<li><code>- u1 v1 u2 v2</code>：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树 ；</li>
<li><code>* u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都乘上自然数 $c$ ；</li>
<li><code>/ u v</code>：询问 $u$ 到 $v$ 的路径上的点的权值和，将答案对 $51061$ 取模。</li>
</ul>
</blockquote>
<p>发现就是很板的 $\rm LCT$ ？splay维护一下加法和乘法 <code>tag</code> 就好了。</p>
<p>主要是记录一下代码…</p>
<p>好久之前做的题了，当时给函数瞎起了一个 <code>split</code> 的名字，并且码风奇差，感觉自己很弟弟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> O[<span class="number">3</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> R ; <span class="keyword">long</span> <span class="keyword">long</span> tagv, tags ; </span><br><span class="line">	<span class="keyword">int</span> F, Son[<span class="number">2</span>], sz ; <span class="keyword">long</span> <span class="keyword">long</span> s, v  ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> stk[MAXN], base[MAXN], N, M, A, B, C, i ;</span><br><span class="line">                                                       </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;     </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;                        </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s += y * size) %= Mod, (T[x].v += y) %= Mod, (T[x].tags += y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; T[x].s = (T[lc].s + T[rc].s + T[x].v) % Mod ; T[x].sz = T[lc].sz + T[rc].sz + <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s *= y) %= Mod, (T[x].v *= y) %= Mod, (T[x].tagv *= y) %= Mod ; (T[x].tags *= y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">    T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> qwq = x, t = <span class="number">1</span> ; stk[<span class="number">1</span>] = x ;</span><br><span class="line">	<span class="keyword">while</span>(check(qwq)) stk[++ t] = (qwq = T[qwq].F) ;</span><br><span class="line">	<span class="keyword">while</span>(t) push_down(stk[t --]) ;</span><br><span class="line">	<span class="keyword">while</span>(check(x))&#123;</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line">		<span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> res = <span class="number">0</span>, k = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) k = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ;  T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; split(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (T[x].tagv != <span class="number">1</span>) Mul(lc, T[x].tagv), Mul(rc, T[x].tagv), T[x].tagv = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].tags)	    Add(lc, T[x].tags), Add(rc, T[x].tags), T[x].tags = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].R) 	&#123; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	rep(i, <span class="number">1</span>, N) T[i].v = T[i].tagv = T[i].sz = <span class="number">1</span> ;</span><br><span class="line">	rep(i ,<span class="number">1</span>, N - <span class="number">1</span>) A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">	rep(i, <span class="number">1</span>, M)&#123;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;O) ;</span><br><span class="line">		<span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'+'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Add(B, C) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'*'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Mul(B, C) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'/'</span>) A = qr(), B = qr(), split(A, B), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, T[B].s) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'-'</span>) A = qr(), B = qr(), Cut(A, B), A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Cf938G Shortest Path Queries</title>
    <url>/2020/01/24/Cf938G/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给出一个连通带权无向图,边有边权,要求支持 $q$ 个操作:</p>
<p><code>1 x y d</code> 在原图中加入一条 $x$ 到 $y$ 权值为 $b$ 的边。</p>
<p><code>2 x y</code> 把图中 $x$ 到 $y$ 的边删掉。</p>
<p><code>3 x y</code> 表示询问 $x$ 到 $y$ 的异或最短路。</p>
<p>保证任意操作后原图连通无重边自环且操作均合法。</p>
<p>$1\leq n,m,q\leq 200000$</p>
<a id="more"></a>
<p>这题和 [HAOI2017] 的那个不是很相同。那题比较弱智，每次询问的只是包括 $1$ 的圈，但是这题需要维护连通性，并且没有初始边。所以就需要维护一个可撤销的 $dsu$ 来配合操作。</p>
<p>嗯，又写了一遍发现这个可撤销并查集的实现可能需要再领悟一下。</p>
<p>感觉代码实现方面还有很多需要熟悉的啊…尤其是线性基维护生成树、直接用 <code>query(x) &amp; query(y)</code> 就可以直接求出询问，感觉很神奇。慢慢学、慢慢来吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">30</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">800010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> tot, cntq ;</span><br><span class="line"><span class="keyword">int</span> fa[N], sz[N] ;</span><br><span class="line"><span class="built_in">map</span> &lt;pint, <span class="keyword">int</span>&gt; sch ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxj</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base[<span class="number">50</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = B ; ~k ; -- k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; k &amp; x)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[k]) x ^= base[k] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[k] = x, <span class="keyword">void</span>() ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">            ret = min(ret, ret ^ base[i]) ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F ;</span><br><span class="line"><span class="comment">//using namespace xxj ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &gt; ur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dofa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doxor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= f[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, xxj now)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;edge&gt; O ; <span class="comment">//O.clear() ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> w = S[rt][i].val ;</span><br><span class="line">        <span class="keyword">int</span> f1 = dofa(u), f2 = dofa(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; w &lt;&lt; endl ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; " " &lt;&lt; sz[f1] &lt;&lt; " " &lt;&lt; sz[f2] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edge)&#123;f1, f2, sz[f2]&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1],</span><br><span class="line">            f[f1] = doxor(u) ^ doxor(v) ^ w ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now.Insert(doxor(u) ^ doxor(v) ^ w) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        ans[l] = now.Query(doxor(qs[l].u) ^ doxor(qs[l].v)) ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid, now),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, now) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        fa[O[i].u] = O[i].u, sz[O[i].v] = O[i].l, f[O[i].u] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, mk ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(u), qr(v), qr(w) ;</span><br><span class="line">        e[++ tot] = (edge)&#123;u, v, <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        sch[mkp(u, v)] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        qr(mk), qr(u), qr(v) ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) swap(u, v) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            qr(w), ++ tot,</span><br><span class="line">            sch[mkp(u, v)] = tot,</span><br><span class="line">            e[tot] = (edge)&#123;u, v, cntq + <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            e[sch[mkp(u,v)]].r = cntq ;</span><br><span class="line">        <span class="keyword">else</span> qs[++ cntq] = (qss)&#123;u, v&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (e[i].r &lt; <span class="number">0</span>) e[i].r = cntq ;</span><br><span class="line">   <span class="comment">// for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].r &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, cntq, e[i].l, e[i].r, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">1</span>, cntq, F) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2312 [HAOI2017]八纵八横</title>
    <url>/2020/01/24/HAOI2017%E5%85%AB%E7%BA%B5%E5%85%AB%E6%A8%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实不是什么难题，只是因为「写起来很麻烦」+「单独拿出来方便记忆」所以单独开一篇。</p>
<a id="more"></a>
<p>Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市)，保证任意两个城市都可以通过高速公路互达。</p>
<p>Anihc 国正在筹划「八纵八横」的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在「八纵八横」计划建成之后，将「一带一路」扩展为「一带一路一环」，增加「内陆城市经济环」即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令「内陆城市经济环」的 $\rm GDP$ 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。</p>
<p>现在 Anihc 在会议上讨论「八纵八横」的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的「八纵八横」的建设计划的方案「内陆城市经济环」的最大是多少。</p>
<p>初始时，八纵八横计划中不包含任何—条高铁，有以下三种操作：</p>
<p><code>Add x y z</code>  在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 <code>Add</code> 操作，则将这条高铁命名为 $k$ 号高铁。</p>
<p><code>Cancel k</code>  将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。</p>
<p><code>Change k z</code>  表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在.</p>
<h2 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm Sol$"></a>$\rm Sol$</h2><p>不得不说这题有点恶心…因为他需要 <code>bitset</code>，于是各种操作就很不优美。</p>
<p>大概就是考虑用线段树分治去维护边的存在性。那么接下来就是一开始随便 $dfs$ 出一个生成树来，然后每次询问时，发现对于每个合法的方案都是从 $1$ 开始的一个环。 那么考虑最后一定是一些环套起来，所以可以直接在线性基里面查询。</p>
<p>做这题时发现，这么做的正确性在于，可以随便生成一棵树。同时生成出来的环也具有「生成子集」的性质，也就是说可以据此生成所有 <strong>剩下未被统计的环</strong>。要证明其实也不难。</p>
<p>所以可能这种「线性基+生成树+环生成子集」的结合是“完洽”的，即彼此有着共同的性质，这种搭配似乎不是很常见？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">char</span> s[L] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; f[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; ans[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, tot, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xxj&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; base[L] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="built_in">bitset</span>&lt;L&gt; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (x[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][i]) x ^= base[i] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; Query()&#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;L&gt; res ; res.reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res[i] ^ base[i][i]) res ^= base[i] ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xxj ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">(<span class="built_in">bitset</span> &lt;L&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (!x[i])</span><br><span class="line">            &#123;<span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'1'</span>), flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>&lt;L&gt; get_bit()&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; ret ; ret.reset() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ret.<span class="built_in">set</span>(len - i) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">bitset</span>&lt;L&gt; w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; O ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> d = Insert(S[rt][i].val ^ f[u] ^ f[v]) ;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) O.p_b(d) ; <span class="comment">//,cout &lt;&lt;d&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) ans[l] = Query() ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; O.size() ; ++ i) base[O[i]].reset() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            Insert(f[u] ^ f[to(k)] ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> f[to(k)] = f[u] ^ val(k), dfs(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(u), qr(v), add(u, v, get_bit()) ;</span><br><span class="line">    dfs(<span class="number">1</span>) ;</span><br><span class="line">	<span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i].count() &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'A'</span>)</span><br><span class="line">            ++ tot, qr(e[tot].u), qr(e[tot].v),</span><br><span class="line">            e[tot].val = get_bit(), e[tot].l = i, e[tot].r = q ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'a'</span>)</span><br><span class="line">            qr(u),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]), e[u].l = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">else</span> qr(u), update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]),</span><br><span class="line">             e[u].l = i, e[u].val = get_bit(), e[u].r = q ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val.count() &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~e[i].l) update(<span class="number">1</span>, <span class="number">0</span>, q, e[i].l, q, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">0</span>, q) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= q ; ++ i) out_put(ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线段树分治</title>
    <url>/2020/01/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线段树分治用于离线处理一些带有时间属性的操作。最常见的是对于给定的每个操作都只在某个时间区间内存在效力，换言之即每个操作都需要可撤销。</p>
<p>嗯，废话说完了。做法大概就是拿线段树 $+$ <code>vector</code> 维护一下操作区间的所有操作，然后直接在询问里按时间跑分治，顺便在线段树内维护合法修改即可。</p>
<a id="more"></a>
<h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><p>以下是 $bzoj4025$ :</p>
<blockquote>
<p>神犇有一个 $n$ 个节点的图。</p>
<p>因为神犇是神犇，所以在 $\rm T$ 时间内一些边会出现后消失。神犇要求出每一时间段内这个图是否是二分图。这么简单的问题神犇当然会做了，于是他想考考你。</p>
<p>$1\leq n,m,\rm T\leq 10^6$。</p>
</blockquote>
<p>大概就是通过线段树+vector维护每个区间加了哪些边，然后通过可撤销的并查集来维护当前图内是否有奇环。判断过程大概就是如果可以有边加进去就加边，否则判断两者到根的实际距离是否奇偶性相同，如果相同那么添上这条边一定会使得出现一个奇环。</p>
<p>然后这题由于有奇环可以把答案记为 $0$，那么就可以不再递归下去。也算是一个剪枝？</p>
<p>哦对，由于要支持撤销，所以就换成了按 $\rm size$ 合并的并查集。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, ans[T] ;</span><br><span class="line"><span class="keyword">int</span> dis[N], fa[N], sz[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span> <span class="keyword">int</span> u, v ; &#125; ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edges&gt; S[N * <span class="number">3</span>], O ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= dis[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> fr, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b((edges)&#123;fr, to&#125;), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, fr, to) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, fr, to) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; <span class="built_in">vector</span>&lt;edges&gt;O ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edges)&#123;f1, f2&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            dis[f1] = dis[u] ^ dis[v] ^ <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dist(u) == dist(v)) &#123; ret = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">if</span> (l == r) ans[l] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> do_do(rt &lt;&lt; <span class="number">1</span>, l, mid), do_do(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        sz[O[i].v] -= sz[O[i].u], dis[O[i].u] = <span class="number">0</span>, fa[O[i].u] = O[i].u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) update(<span class="number">1</span>, <span class="number">1</span>, k, l + <span class="number">1</span>, r, u, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ; do_do(<span class="number">1</span>, <span class="number">1</span>, k) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        ans[i] ? <span class="built_in">puts</span>(<span class="string">"Yes"</span>) : <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，然后就没了…</p>
<h1 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h1><h2 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h2><blockquote>
<p>求不包含元素 $1\sim n$ 的 $01$ 背包。</p>
<p>$1\leq n,m\leq 2000$</p>
</blockquote>
<p>直接线段树分治做，第 $i$ 个物品的存在时间是 $1\sim i-1$ 和 $i+1 \sim n$ .</p>
<p>但有个问题就在于每次计算的复杂度都是 $nw$ 的。所以最后复杂度就是 $nw\log n$ 。</p>
<h2 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h2><blockquote>
<p>给定一张图，对所有的 $i,j,k$ 求 $i$ 到 $j$ 不经过 $k$ 的⽅案数。</p>
</blockquote>
<p>发现朴素地做是 $n^4$ 的。可以通过和上面那题差不多的方法，用线段树分治优化到 $n^3\log n$ 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实我关于离线三姐妹的学习顺序是CDQ-&gt;整体二分-&gt;线段树分治。最后学线段树分治是因为第一次看这个算法感觉很懵…尤其是所有题解都在繁复叨叨那几句话QAQ</p>
<p>总之，句号也是一个新的开始，不是吗？</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树分治</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>图论/二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性基</title>
    <url>/2020/01/24/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>真正线性基的定义需要扯到线代那一部分。因为心情不好，所以鸽了。</p>
<p>此处主要讨论的线性基定义在异或运算上。即考虑给出一系列整数，称其中某个可以通过异或运算表出全部元素的子集为一组<strong>生成子集</strong>，称一组彼此都不能被表出元素为<strong>线性无关集</strong>。那么<strong>线性基</strong>就是一组<strong>线性无关生成子集</strong>。</p>
<p>如果把每个数看成一个 $01$ 向量。可以如是做的原因是位运算时位位独立，就如同系数矩阵在做初等变换时行、列分别独立一样。所以这个线性空间内基的个数就是这个 $01$ 矩阵的秩。换句话说，求这个的过程完全可以通过高斯消元来实现。</p>
<a id="more"></a> 
<h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="$1$ 基本操作"></a>$1$ 基本操作</h1><h2 id="（1）插入"><a href="#（1）插入" class="headerlink" title="（1）插入"></a>（1）插入</h2><p>普通的插入顺便消了消元：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ;</span><br><span class="line">                ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概消成的就是一个倒三角矩阵。显然最后 $x_i$ 有值的位数就是这个矩阵的秩。</p>
<p>虽然这样插入没错，但有一种更精妙的插入方式。这样插入之后可以保证线性基内至多存在 $1$ 个 $b_i$ 位为 $1$ 的数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                	<span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               		<span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样消出来的就可以保证是一个部分对角的矩阵，比上三角矩阵有着更优秀的性质。</p>
<h2 id="（2）-询问"><a href="#（2）-询问" class="headerlink" title="（2） 询问"></a>（2） 询问</h2><p>询问操作常(我)见(会)的，首先是求最大值/最小值，这东西显然贪心一遍即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">    ans = max/min(ans, ans ^ x[i]) ;</span><br></pre></td></tr></table></figure>
<p>这种感觉。从大到小枚举不是因为贪心顺序，是因为这样可以保证消元消出来没有后效性。</p>
<p>然后是询问第 $k$ 小/大。这东西的话，考虑对于这个线性空间，一共可以张成 $2^n$ 个值。特判掉 $0$ 之后，发现对 $k$ 二进制拆分实际上就是在对角矩阵里面选数。所以如果一开始选择消成对角矩阵，那么就可以直接做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">63</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> haha ; LL z ;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt ; LL ans ;</span><br><span class="line">LL base[N], x[M + <span class="number">1</span>], rst[M + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                	<span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               		<span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL k)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!haha) -- k ;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1l</span>l &lt;&lt; cnt)) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; (<span class="number">1l</span>l &lt;&lt; i)) res ^= rst[i] ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; haha = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], haha &amp;= ins(base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; <span class="comment">//cout &lt;&lt; haha &lt;&lt; endl ;</span></span><br><span class="line">    cnt = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x[i]) rst[cnt ++] = x[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;z), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(z)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目是 <code>loj#114 k大异或和</code> 。</p>
<h2 id="（3）删除"><a href="#（3）删除" class="headerlink" title="（3）删除"></a>（3）删除</h2><p>这部分我很迷啊…</p>
<p>首先如果可以离线就可以线段树分治，剩下的先鸽着。</p>
<p>大概就是考虑如果删除了一个不在线性基内的数，那就无所谓了。如果在其中，那么</p>
<h1 id="2-经典应用"><a href="#2-经典应用" class="headerlink" title="$2$ 经典应用"></a>$2$ 经典应用</h1><blockquote>
<p>[WC2011]最大XOR和路径</p>
<p>考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 $\operatorname{XOR}$ 和最大。</p>
<p>$1\leq n,m\leq 10^6$</p>
</blockquote>
<p>一道很经典的题。大概是维护异或生成树。</p>
<p>考虑这题先随便生成一条 $1\sim n$ 的路径，这样就是钦定了一颗生成树，那么剩下的会是一些圈。考虑从这条路径走出去，走完剩下的圈再走回来是一个来回，中间的桥边（装作）会被经过两次，所以不需要考虑。</p>
<p>所以 <code>dfs</code> 一遍就行。遇到环就丢到线性基里面，否则记录一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~ i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; x)&#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i]) x ^= base[i] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, <span class="keyword">void</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL basic)</span></span>&#123;</span><br><span class="line">    LL ret = basic ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">        ret = max(ret, ret ^ base[i]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, LL res)</span></span>&#123;</span><br><span class="line">    f[u] = res, vis[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)]) </span><br><span class="line">          dfs(to(k), res ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(res ^ val(k) ^ f[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v ; LL w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w, add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Query(f[n])) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性基</category>
      </categories>
      <tags>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Kruskal重构树</title>
    <url>/2020/01/24/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是模拟 <code>Kruskal</code> 加边的过程，重构成一棵树。</p>
<p>过程大概是把原图中所有的点作为重构树的叶子，边按一定的秩排序，合并两个集合时把连接两个集合的边权作为公共父亲的点权。</p>
<p>这样的建树有一定性质。比如基于最小生成树的重构，两个点的 $lca$ 点权一定是「两点之间所有路径上最大值的最小值」。</p>
<a id="more"></a>
<h1 id="NOI2018-归程"><a href="#NOI2018-归程" class="headerlink" title="[NOI2018] 归程"></a>[NOI2018] 归程</h1><blockquote>
<p>给定一张图，每条路有一个长度一个海拔。</p>
<p>每次询问，询问从点 $x$ 出发，第一段只走海拔 $&gt;h$ 的边，走到某个点，然后无限制地走第二段到达 $1$ 号点，第二段路程的最小长度。</p>
<p>强制在线。</p>
</blockquote>
<p>发现Kruskal重构树具有堆性质，于是如果基于最大生成树重构，那么对于一个点能够经过大于 $v$ 的边到达的点应该在某个子树内。所以可以按照这个方式倍增。之前预处理一下子树内到 $1$ 的 $\rm mindist$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cost(k) E[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, c ;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, cost ;</span><br><span class="line">    <span class="keyword">int</span> fr, to, next ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, n ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp; neww) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; neww.dis ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> ff[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> lastans ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q, s ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> dis[N], vis[N] ;</span><br><span class="line">priority_queue&lt;Node&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].fr = u ;</span><br><span class="line">    E[cnt].val = w, E[cnt].cost = c ;</span><br><span class="line">    E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">127</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    Q.push((Node)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node qwq = Q.top() ; Q.pop() ;</span><br><span class="line">        <span class="keyword">int</span> x1 = qwq.n, x2 = qwq.dis ;</span><br><span class="line">        <span class="keyword">if</span>(vis[x1]) <span class="keyword">continue</span> ; vis[x1] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = head[x1]; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = min(dis[E[k].to], x2 + cost(k)) ;</span><br><span class="line">               Q.push((Node)&#123;dis[to(k)], to(k)&#125;) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(edges u, edges v)</span></span>&#123; <span class="keyword">return</span> u.w &gt; v.w ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ff[x] ? x : ff[x] = find(ff[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ffff)</span></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = ffff ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">19</span> ; ++ j)</span><br><span class="line">        fa[x][j] = fa[fa[x][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        dfs(to(k), x), dis[x] = min(dis[x], dis[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("return.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("return.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> tot ;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c, k, l, now, ok ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].c &gt;&gt; e[i].w,</span><br><span class="line">             add(e[i].u, e[i].v, e[i].w, e[i].c), add(e[i].v, e[i].u, e[i].w, e[i].c) ;</span><br><span class="line">        dijkstra() ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; k &gt;&gt; s ; tot = n ; ok = <span class="number">0</span> ;</span><br><span class="line">        sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, comp) ; <span class="comment">//cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">        fill(head, head + <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n + <span class="number">1</span> ; ++ i) ff[i] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = find(e[i].u) ;</span><br><span class="line">            <span class="keyword">int</span> f2 = find(e[i].v) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ++ ok ;</span><br><span class="line">                now = ++ tot ;</span><br><span class="line">                base[now] = e[i].w ;</span><br><span class="line">                ff[f1] = now, ff[f2] = now ;</span><br><span class="line">                add(now, f1, <span class="number">0</span>, <span class="number">0</span>), add(now, f2, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(now, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">            u = qr(), l = qr() ; <span class="keyword">int</span> x = u ;</span><br><span class="line">            l = (l + <span class="number">1l</span>l * k * lastans) % (s + <span class="number">1</span>) ;</span><br><span class="line">            x = (x + <span class="number">1l</span>l * k * lastans - <span class="number">1</span>) % n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (fa[x][j] &amp;&amp; base[fa[x][j]] &gt; l) x = fa[x][j] ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = dis[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">        <span class="built_in">memset</span>(base, <span class="number">0</span>, <span class="keyword">sizeof</span>(base)) ;</span><br><span class="line">        fill(vis + <span class="number">1</span>, vis + tot + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        fill(head + <span class="number">1</span>, head + tot + <span class="number">1</span>, <span class="number">0</span>), lastans = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="神秘的题目"><a href="#神秘的题目" class="headerlink" title="神秘的题目"></a>神秘的题目</h1><blockquote>
<p>给出一棵 $n$ 个点的树，树边上有边权。 </p>
<p>定义一个点的权值为其到其他所有节点的路径上最小边权之和，求权值最大的点。 </p>
</blockquote>
<p>建一棵基于最大生成树的重构树，然后发现每条边作为 $(u,v)$ 最小边权当且仅当 $u,v$ 在重构树上的 $lca$ 是这条边。</p>
<p>所以可以直接离线统计每条边的贡献，<code>dfs</code> 时将左右子树中的叶子结点个数加权互加一下就完了。可以直接在 <code>dfn</code> 上维护一个差分，这样就是排序外线性了。 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Kruskal重构树</category>
      </categories>
      <tags>
        <tag>图论/Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj#3545 Peaks</title>
    <url>/2020/01/24/Peaks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有 $n$ 座山峰，每座山峰有他的高度 $h_i$。</p>
<p>有山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值。</p>
<p>现在有 $q$ 组询问，询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。</p>
<a id="more"></a>
<p>发现可以倍增，因为 $\leq x$ 的权在重构树上是一个子树。</p>
<p>倍增完了就可以直接套主席树了。主席树可以比较简单的按照叶子的标号建，每个边结点维护一个 $\rm leftrange$ 和 $\rm rightrange$ 即可。</p>
<p>等会儿，我就整理这么点儿东西为啥要新开这一篇blog啊？太浪费资源了吧QAQ。</p>
<p><del>那看上去就只能用代码来占空间了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">    <span class="keyword">int</span> next, val ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> dad[N] ;</span><br><span class="line"><span class="keyword">int</span> wth[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> rg[N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[V], res, sz ;</span><br><span class="line"><span class="keyword">int</span> rt[V], lc[V], rc[V] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lc[now] = build(l, mid) ;</span><br><span class="line">    rc[now] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    lc[now] = lc[last] ;</span><br><span class="line">    rc[now] = rc[last] ;</span><br><span class="line">    sum[now] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">        lc[now] = update(lc[last], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> rc[now] = update(rc[last], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rtl, <span class="keyword">int</span> rtr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> delta = sum[rc[rtr]] - sum[rc[rtl]] ;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; delta)</span><br><span class="line">        <span class="keyword">return</span> query(lc[rtl], lc[rtr], l, mid, v - delta) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rc[rtl], rc[rtr], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = w, fr(cnt) = u ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == dad[x] ? x : dad[x] = find(dad[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge A, Edge B)</span></span>&#123; <span class="keyword">return</span> A.val &lt; B.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">    rg[u][<span class="number">0</span>] = res ;</span><br><span class="line">    <span class="keyword">if</span> (!head[u])</span><br><span class="line">        rg[u][<span class="number">0</span>] = ++ res,</span><br><span class="line">        rt[res] = update(rt[res - <span class="number">1</span>], <span class="number">1</span>, len, base[u]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">    rg[u][<span class="number">1</span>] = res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, now, k, tot, op ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + len + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w), add(v, u, w) ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n ; ++ i) dad[i] = i ;</span><br><span class="line">    fill(head + <span class="number">1</span>, head + n + <span class="number">1</span>, <span class="number">0</span>), op = cnt, tot = n, cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= op ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(fr(i)) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = find(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            now = ++ tot ;</span><br><span class="line">            wth[now] = val(i) ;</span><br><span class="line">            dad[f1] = dad[f2] = now ;</span><br><span class="line">            fa[f1][<span class="number">0</span>] = fa[f2][<span class="number">0</span>] = now ;</span><br><span class="line">            add(now, f1, <span class="number">0</span>),add(now, f2, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; fa[i][0] &lt;&lt; endl ;</span></span><br><span class="line">    rt[<span class="number">0</span>] = build(<span class="number">1</span>, len) ; dfs(now) ; <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;w, &amp;k) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (fa[u][j] &amp;&amp; wth[fa[u][j]] &lt;= w) u = fa[u][j] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (rg[u][<span class="number">1</span>] - rg[u][<span class="number">0</span>] &lt; k) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; rg[u][0] &lt;&lt; " " &lt;&lt; rg[u][1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[query(rt[rg[u][<span class="number">0</span>]], rt[rg[u][<span class="number">1</span>]], <span class="number">1</span>, len, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>图论/Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究】欧拉反演</title>
    <url>/2020/01/24/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是对于 $\varphi$ 函数性质的一点应用？比起 $\mu$ 其实不是那么的复杂，实用性也不是很高。</p>
<p>考虑 $\varphi$ 的这么一个性质：</p>
<script type="math/tex; mode=display">
\sum _{d|n}\varphi(d)=n</script><p>这大概就是这篇文章的主角。</p>
<a id="more"></a>
<hr>
<p>这东西大概可以用莫比乌斯反演定理来证？</p>
<p>令 $f(x)=\varphi(x)$，$g(x)=\boldsymbol{\rm Id}(x)$ ，则根据狄利克雷卷积的某些常识有</p>
<script type="math/tex; mode=display">
\sum_{d|n}g(d)\mu(\frac{n}{d})=f(n)\\</script><p>反演一下</p>
<script type="math/tex; mode=display">
g(n)=\sum_{d|n}f(d)</script><p>即</p>
<script type="math/tex; mode=display">
\sum_{d|n}\varphi(d)=\boldsymbol{\rm Id}(n)=n</script><p>当然也可以通过浅显的数论知识来证明：</p>
<p>设 $f(n)=\sum_{d|n}\varphi(d)$ ，则容易证明 $f$ 也是积性函数。（易证=懒得证XD）</p>
<p>考虑 $n$ 的标准分解式：</p>
<script type="math/tex; mode=display">
n=\sum p_i^{e_i}</script><p>并且考虑当 $p\in\mathbb{P}$ 时 </p>
<script type="math/tex; mode=display">
\varphi(p^k)=p^k-p^{k-1}=p(p^{k-1}-p^{k-2})</script><p>证明很简单，在不越界的情况下， $p^k$ 由于只有 $p$ 一个质因子，所以与 $p\times1,p\times2\cdots p\times p^{k-1}$ 都不互质，所以是 $p^k-p^{k-1}$ 。</p>
<p>那么有</p>
<script type="math/tex; mode=display">
f\left(p_{i}^{e_{i}}\right)=1+p-1+p(p-1)+p^{2}(p-1) \ldots+p^{e_{i}-1}(p-1)</script><p>通过几何级数的求和公式可以得到：</p>
<script type="math/tex; mode=display">
f(p_i^{e_i})=p_i^{e_i}</script><p>根据积性可以得到</p>
<script type="math/tex; mode=display">
f(n)=n</script><p>是不是比上一个证明清真了很多！</p>
<p>以下默认 $[i,j]$ 表示 $i,j$ 的 $\rm lcm$ 。 </p>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote>
<p>求 </p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m(i,j)</script><p>$1\leq n,m\leq 10^6,q\leq 10^5$</p>
</blockquote>
<p>随便做啦</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m(i,j)
\\=&\sum _{i=1}^n\sum_{j=1}^m\sum_{d|n}\varphi(d)
\\=&\sum _{d=1}^n\varphi(d)\cdot \lfloor\frac{n}{d} \rfloor \cdot \lfloor\frac{m}{d} \rfloor
\end{aligned}</script><hr>
<p>接下来是一道翻车题：</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote>
<p>[国家集训队]Crash的数字表格 </p>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[i,j]</script><p>$1\leq n,m\leq 10^7$。</p>
</blockquote>
<p>根据以往套路变形</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m[i,j]
\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{(i,j)}
\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\sum\limits_{d|i~\mathrm{and}~d|j}\varphi(d)}
\\=&\sum _{d=1}^n\frac{1}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor} j
\end{aligned}</script><p>看上去很真？但是并不对。原因是 <strong>和的倒数不等于倒数的和</strong>，也就是中间 $\sum \varphi(d)$ 不能直接提出来。</p>
<p>所以遇到这种情况就只能用莫比乌斯反演。考虑如此：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m[i,j]
\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]
\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) 
\\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j
\end{aligned}</script><p>然后这东西就可以两个数论分块套一起来解决，复杂度 $O(\sqrt n)\cdot O(\sqrt n)=O(n)$。</p>
<p>然而似乎有一只 $\sqrt{n}$ 的做法？有空再学吧233</p>
<p>代码似乎有不少细节？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, pr[N], o ;</span><br><span class="line">LL F[N], mu[N], ans ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">do_do</span><span class="params">(LL u, LL v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u * (u + <span class="number">1</span>) / <span class="number">2</span> % P) * (v * (v + <span class="number">1</span>) / <span class="number">2</span> % P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x, y) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; endl ;</span></span><br><span class="line">        r = min(x / (x / l), y / (y / l)) ;</span><br><span class="line">        <span class="comment">// if (y == 1) cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ret += ((F[r] - F[l - <span class="number">1</span>]) % P + P) % P * do_do(x / l, y / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ o] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= o ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[pr[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * pr[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[pr[j] * i] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        F[i] = ((F[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * i * mu[i] % P) % P + P) % P ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ans += (<span class="number">1l</span>l * (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % P) * (solve(n / l, m / l) % P) % P) %= P ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((ans % P + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote>
<p>LG4917天守阁的地板/LG5221Product</p>
<p>简化题意：</p>
<p>求</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}</script><p>$1\leq n\leq 10^6$</p>
</blockquote>
<p>大概就是转化</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}\\
=&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{i\times j}{\operatorname{gcd}^2(i, j)}\\
\end{aligned}</script><p>然后观察到 $\prod$ 对于除法有结合律，即可以分别算分母和分子。同时指数上的 $2$ 也可以最后再算。</p>
<p>于是考虑下半部分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^{n} \prod_{j=1}^{n} \operatorname{gcd}(i, j)\\
=&\prod_{d=1}^n\prod_{i=1}^{n} \prod_{j=1}^{n} d\cdot [\operatorname{gcd}(i, j)=d]\\
=&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\
\end{aligned}</script><p>其中第二步到第三步的原因是根据结合律 $\prod$ 要升级为乘方（就像 $\sum$ 会升级为 $\times $ 一样</p>
<p>发现似乎后面那个是老朋友了，所以可以直接反演成 $\mu$ 形式或者 $\varphi$ 形式。</p>
<p>其中 $\varphi$ 形式的证明大概是考虑每个数的数的贡献，同时由于是有序数对所以是 $\times 2-1$ 。</p>
<p>嗯，然后就会反演成这个样子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\
=&\prod_{d=1}^n{d^{-1+2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)}}
\end{aligned}</script><p>发现后面的可以数论分块于是这就可以 $\sqrt n$ 做了。</p>
<p>对于分子，发现就是：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n\prod_{j=1}^n i\cdot j=\prod_{i=1}^n(i^n\cdot n!)=(n!)^n\cdot (n!)^n=(n!)^{2n}</script><p>然后就没有然后了233。</p>
<p>不过 <code>LG5221</code> 卡了空间，于是最后是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000001</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">104857601</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, pr[<span class="number">80001</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> ans1, ans2, phi[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1l</span>l * res * a % P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> fac = <span class="number">1</span> ;</span><br><span class="line">    pr[<span class="number">0</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>, ans2 = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j] ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * pr[j]] = phi[i] * (pr[j] - <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; l - 1 &lt;&lt; " " ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            fac = <span class="number">1l</span>l * fac * i % P ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; pr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] &gt; P - <span class="number">1</span>) phi[i] -= P - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1 = expow(pr[cnt], <span class="number">2</span> * n + <span class="number">2</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ; <span class="keyword">int</span> t = ++ cnt ; ++ cnt ;</span><br><span class="line">        ans2 = <span class="number">1l</span>l * ans2 * expow(<span class="number">1l</span>l * pr[cnt] * expow(pr[t], P - <span class="number">2</span>) % P, phi[n / l]) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * expow(ans2, P - <span class="number">5</span>) * ans1 % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学/积性函数/欧拉反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】$\mu$ 函数的性质</title>
    <url>/2020/01/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知 $\mu$ 函数具有如下性质：</p>
<script type="math/tex; mode=display">
\sum_{d|n} \mu(d)=[n=1]</script><p>大部分有关于 $\gcd$ 、带有艾佛森括号的反演题目都可以用这个性质解决。</p>
<a id="more"></a>
<p>证明方式有很多，此处采用狄利克雷卷积的方式来比较简洁地证明。</p>
<p>根据 $\mu$ 的定义，$\mu*\boldsymbol{1}=\boldsymbol{I}$，那么有 </p>
<script type="math/tex; mode=display">
\sum _{d|n}\mu(d)=\mu * \boldsymbol{1}=\boldsymbol{I}=[n=1]</script><p>当然，其实还有更优美的证法。思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p>
<p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}&\sum_{d|n}\mu(d)\\ = &\sum_{d|n'}\mu(d)\\= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\= & ~(1+(-1))^k\\= & ~[k=0]\end{aligned}</script><p>所以到最后 $[k=0]$ 就意味着 $[n=1]$ 。$\mathcal{Q.E.D.}$</p>
<p>默认 $(a,b)$ 代表 $a$ 与 $b$ 的最大公约数，$|$ 表示整除。</p>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p>
</blockquote>
<p>其实就是代换：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|(i,j)}\mu(d)
\\&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|i~\text{and}~d|j}\mu(d)
\\&=\sum _{d=1}^n\mu(d) \sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]
\\&=\sum _{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor \cdot \lfloor\frac{m}{d}\rfloor
\end{aligned}</script><p>然后就可以 $O(n)+O(q\sqrt n)$ 来做了。</p>
<p>但其实本质上，$n$ 可以出到 $10^9$ ？但是总感觉杜教筛套上一层数论分块复杂度就不是很对了。此处可能还需要思考思考。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote>
<p>[POI2007]ZAP-Queries/LG4450双亲数</p>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p>
</blockquote>
<p>其实本质上是一样的。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|(i,j)}\mu(d)
\\&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|i~\text{and}~d|j}\mu(d)
\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d) \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[d|i]\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[d|j]
\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{dk}\rfloor \cdot \lfloor\frac{m}{dk}\rfloor
\end{aligned}</script><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote>
<p>$\forall p\in\mathbb{P}$，求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=p]</script><p>$1\leq n\leq m\leq 10^7,q\leq 10000$</p>
</blockquote>
<p>发现到最后变成了这样：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{cntp}\sum _{d=1}^{\lfloor\frac{n}{p_k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{p_kd}\rfloor \cdot \lfloor\frac{m}{p_kd}\rfloor</script><p>考虑继续换元，令 $q=p_kd$，枚举 $q$:</p>
<script type="math/tex; mode=display">
\sum_{q=1}^{n}\lfloor\frac{n}{q}\rfloor \cdot \lfloor\frac{m}{q}\rfloor\cdot \left(\sum _{k=1}^{cntp}[p_k~|~q]\cdot \mu(\frac{q}{p_k})\right)</script><p>然后发现前半部分可以数论分块，后半部分可以直接在筛素数的时候 $dp$ 出来即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; Pr[i] * j &lt;= MAXN - <span class="number">15</span> ; ++ j)</span><br><span class="line">		f[j * Pr[i]] += Mu[j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= MAXN - <span class="number">15</span> ; ++ i) S[i] = S[i - <span class="number">1</span>] + f[i] ;</span><br></pre></td></tr></table></figure>
<h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><blockquote>
<p>题目来自神仙李思杰的 $blog$：</p>
<p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \sum_{j=1}^{m} i\cdot j\cdot [(i, j)=k] \quad(n<m)</script><p>$1\leq n,m\leq 10^6$</p>
</blockquote>
<p>发现可以这么做：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n} \sum_{j=1}^{m} i \cdot j\cdot[(i, j)=k] 
&=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot[(i, j)=1] \\
&=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot\sum_{d|i~\mathrm{and}~d|j} \mu(d)\\
&=k^2\cdot \sum_{d=1}^n\mu(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor} i\cdot \sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor} j\\
\end{aligned}</script><p>发现后面是个简单的二阶求和形式，故至此已经可以分快了。</p>
<h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><blockquote>
<p>[SDOI2015]约数个数和</p>
<p>求 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)</script><p>$1\leq n,m\leq 10^6,1\leq q\leq 10^5$</p>
</blockquote>
<p>首先考虑一步<del>几乎想不出来的</del>转化：</p>
<script type="math/tex; mode=display">
\sigma_0(i \cdot j)=\sum_{x | i} \sum_{y | j}[(x, y)=1]</script><p>可以类似线性筛那样感性理解。</p>
<p>然后就可以直接做了：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}[(x, y)=1]\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}\sum_{d|x\operatorname{and} d|y} \mu(d)\\
=&\sum_{x = 1}^n \sum_{y = 1}^m\lfloor\frac{n}{x}\rfloor\cdot \lfloor\frac{m}{y}\rfloor\cdot \sum_{d|x\operatorname{and} d|y} \mu(d)\\
=&\sum_{d = 1}^n \mu(d) \sum_{x = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\cdot \lfloor\frac{m}{dy}\rfloor\\
\end{aligned}</script><p>发现后面这东西可以很简单地</p>
<p>预处理，所以复杂度 $O(q\cdot\sqrt n)$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】回滚莫队</title>
    <url>/2020/01/23/%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种离线算法，用于巧妙维护没有删除操作的离线序列问题。一般情况下都可以转化成普通的莫队带一个 ds 的 $\log$ 做法，可以比较简单地去维护某些不能差分的操作（即 <code>del</code> 比较难以实现，比如 $\max$）。</p>
<a id="more"></a>
<p>考虑不同于普通莫队的另一种做法。</p>
<p>首先还是将所有询问排序。考虑一种根号分治的做法：</p>
<ul>
<li><p>对于两个端点在同一个块内的直接跑暴力，总复杂度是 $O(qB)$；</p>
</li>
<li><p>两个端点不在一个块内的，考虑把连个指针都指针移到下一个块的开头，途中对每个点只撤销贡献而不删除贡献，之后 $r$ 单调向右移，$l$ 向左移，添加过程中计算贡献——其中控制 $r$ 单增的原因是 $r$ 的移动步长是 $O(n)$ 的，但每次 $l$ 的移动步长是 $O(B)$ 的。</p>
</li>
</ul>
<p>这样的话，复杂度就是 $O(qB+\frac{n^2}{B})$ 。简单地均值一下发现还是 $O(n\sqrt q)$ 的。</p>
<p>那看上去除了复杂度分析很莫队，本质上就是个根号分治啊。</p>
<h1 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h1><blockquote>
<p>给定一堆事件：</p>
<ol>
<li>选择日记中连续的一些天作为分析的时间段</li>
<li>事件种类 $t$ 的重要度为 $t$  $\times$ (这段时间内种类为 $t$ 的事件数)。</li>
<li>计算出所有事件种类的重要度，输出其中的最大值 现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值.</li>
</ol>
</blockquote>
<p>发现插入很简单，但是由于求的是 $\max$，所以朴素地删除会让答案难以统计。于是考虑直接上回滚莫队。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line">LL res ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line">LL ans[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"><span class="keyword">int</span> n, w, m, b, bnum ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs p1,qs p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[p1.l] ^ blg[p2.l] )</span><br><span class="line">        <span class="keyword">return</span> blg[p1.l] &lt; blg[p2.l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p1.r &lt; p2.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, LL &amp; ret)</span></span>&#123;</span><br><span class="line">    buc[base[p]] ++ ;</span><br><span class="line">    ret = max(ret, <span class="number">1l</span>l * buc[base[p]] * g[p]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bucc[N] ;</span><br><span class="line"><span class="function">LL <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    LL ret ; ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        ret = max(ret, <span class="number">1l</span>l * bucc[base[i]] * g[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] -- ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, lb ;</span><br><span class="line">    b = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n) ; bnum = n / b + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i]), t[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        L[i] = (i - <span class="number">1</span>) * b + <span class="number">1</span>, R[i] = i * b ;</span><br><span class="line">    R[bnum] = min(R[bnum], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i] ; j &lt;= R[i] ; ++ j)</span><br><span class="line">            blg[j] = i ; sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    w = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + w + <span class="number">1</span>, g[i]) - t ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; base[i] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp), l = <span class="number">1</span>, r = <span class="number">0</span>, lb = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; q[i].l &lt;&lt; " " &lt;&lt; q[i].r &lt;&lt; endl ;</span></span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] ^ lb)&#123;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; R[blg[q[i].l]]) del(r --) ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; R[blg[q[i].l]] + <span class="number">1</span>) del(l ++) ;</span><br><span class="line">            res = <span class="number">0</span> ; lb = blg[q[i].l] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ul = l ; LL anss = res ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">        anss = res ; <span class="keyword">while</span> (ul &gt; q[i].l) add(-- ul, anss) ;</span><br><span class="line">        <span class="keyword">while</span> (ul &lt; l) del(ul ++) ; ans[q[i].id] = anss ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LG-5906-回滚莫队"><a href="#LG-5906-回滚莫队" class="headerlink" title="LG 5906 回滚莫队"></a>LG 5906 回滚莫队</h1><blockquote>
<p>给定一个序列，多次询问一段区间 $[l,r]$，求区间中<strong>相同的数的最远间隔距离</strong>。</p>
<p>序列中两个元素的<strong>间隔距离</strong>指的是<strong>两个元素下标差的绝对值</strong>。</p>
<p>$1\leq n,m\leq 2\cdot 10^5$</p>
</blockquote>
<p>本质上第一次见这题是某次校内胡策 <a href="https://www.luogu.com.cn/problem/U96381" target="_blank" rel="noopener">戳我</a>。之后发现原来是 <code>codechef</code> 上的题，然后就自己出了数据放到了谷上……然而数据十分的水……虽然我觉得我是精心构造了…233</p>
<p>然后这题其实是道好题…原因就是上一道题是不完全版的回滚莫队：上一道题的左端点 <code>add</code> 和右端 <code>add</code> 可以一样，因为第二层信息 <code>buc</code> 可以差分，即如果现减成 $-1$ 后来是可以加回来的；但是这道题的话，如果记录上一个和下一个相同的数字的位置会有很麻烦的边界，大部分做法都是赋值为 $0$ 或 $n$ ，但这样就会丢失信息，也就是左端点的 <code>add</code> 和右端点的 <code>add</code> 要分开处理。</p>
<p>所以如果铁憨憨地拿头写就会由很多边界，所以比较好的处理方式：</p>
<h2 id="询问分块处理"><a href="#询问分块处理" class="headerlink" title="询问分块处理"></a>询问分块处理</h2><p>大概就是每个块清零一次，直接让两个指针回归。这样做不容易错，但复杂度是满的 $\frac{n^2}{\sqrt m}$ （因为每个块都是 $\Theta(n)$ 的清零）。所以大概可以改下块大小来微调？但其实这题我出的所有 $n,m$ 差不超过 $5$ …233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, x, y ;</span><br><span class="line"><span class="keyword">int</span> val[N], base[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N], tmp[N], suf[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> qs &amp;a, <span class="keyword">const</span> qs &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) tmp[base[i]] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[base[i]] = Min(tmp[base[i]], i), ret = Max(ret, i - tmp[base[i]]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    suf[base[p]] = Max(suf[base[p]], p) ;</span><br><span class="line">    pre[base[p]] = Min(pre[base[p]], p) ;</span><br><span class="line">    res = Max(res, suf[base[p]] - pre[base[p]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> bnum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s, L = Min(n, bnum * b) ;</span><br><span class="line">    <span class="keyword">int</span> l = L + <span class="number">1</span>, r = L ; res = <span class="number">0</span> ;</span><br><span class="line">    fill(pre + <span class="number">1</span>, pre + len + <span class="number">1</span>, n) ;</span><br><span class="line">    fill(suf + <span class="number">1</span>, suf + len + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span>( ; blg[q[i].l] == bnum ; ++ i )&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> anss = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tmp[base[j]] = n ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">            tmp[base[j]] = Min(tmp[base[j]], j) ;</span><br><span class="line">            anss = max(anss, Max(j - tmp[base[j]], suf[base[j]] - j)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id] = max(anss, res) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr(), val[i] = base[i] ;</span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>) ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    len = unique(val + <span class="number">1</span>, val + n + <span class="number">1</span>) - val - <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(val + <span class="number">1</span>, val + len + <span class="number">1</span>, base[i]) - val ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        q[i].l = qr(), q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = (i - <span class="number">1</span>) / b + <span class="number">1</span> ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; <span class="keyword">int</span> L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blg[n] ; ++ i) &#123;</span><br><span class="line">        L = solve(L, i) ; <span class="keyword">if</span> (L &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把所有函数展开"><a href="#把所有函数展开" class="headerlink" title="把所有函数展开"></a>把所有函数展开</h2><p>没写过，因为个人认为会搞乱码风。</p>
<hr>
<h2 id="瞎写"><a href="#瞎写" class="headerlink" title="瞎写"></a>瞎写</h2><p>于是个人最初的写法是这样的，十分吊诡：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400100</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> buf[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[M] ;</span><br><span class="line"><span class="keyword">int</span> tbuc[N] ;</span><br><span class="line"><span class="keyword">int</span> bucp[N] ;</span><br><span class="line"><span class="keyword">int</span> bucs[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[a.l] ^ blg[b.l])</span><br><span class="line">        <span class="keyword">return</span> blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buf[base[i]]) buf[base[i]] = i ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = max(ret, i - buf[base[i]]) ;</span><br><span class="line">            buf[base[i]] = min(i, buf[base[i]]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buf[base[i]]) buf[base[i]] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    bucp[base[x]] = N ;</span><br><span class="line">    bucs[base[x]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">    bucs[base[x]] = max(x, bucs[base[x]]) ;</span><br><span class="line">    bucp[base[x]] = min(x, bucp[base[x]]) ;</span><br><span class="line">    val = max(val, bucs[base[x]] - bucp[base[x]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = i / b ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bucs[i] = <span class="number">0</span>, bucp[i] = N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (blg[q[i].l] &gt; k)&#123;</span><br><span class="line">                <span class="keyword">while</span> (blg[r] &lt;= blg[q[i].l]) del(r ++)  ;</span><br><span class="line">                <span class="keyword">while</span> (blg[r] &gt; blg[q[i].l]) del(r --) ;</span><br><span class="line">                <span class="keyword">while</span> (blg[l] &lt;= blg[q[i].l]) del(l ++) ;</span><br><span class="line">                add(++ r, res) ; res = <span class="number">0</span> ; k = blg[q[i].l] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t, fl = l, ress = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tbuc[base[j]] = N ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">                t = base[j] ;</span><br><span class="line">                tbuc[t] = min(j, tbuc[t]) ;</span><br><span class="line">                ress = max(ress, max(j - tbuc[t], bucs[t] - j)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[q[i].id] = max(ress, res) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>边界很烦人…很烦人…当然个人实力菜占主要原因…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上莫队</title>
    <url>/2020/01/23/%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯…好…序列数据结构就是用来上树的嘛/kk</p>
<p>发现首先树上分块很好处理，比较麻烦的一点在于，如何从 $(ou,ov)$ 这条路径移动到 $(nu,nv)$。</p>
<p>发现莫队的精髓在于排完序之后左右端点的移动是独立的，所以考虑如何转化成 $(ou,nu)$ 和 $(ov,nv)$。</p>
<a id="more"></a>
<h1 id="1-瞎构造"><a href="#1-瞎构造" class="headerlink" title="$1$ 瞎构造"></a>$1$ 瞎构造</h1><p><del>蜜汁more.jpg</del></p>
<p>有一个很常见的定理，就是「树上两条路径如果有交点，那么一定是在其中一条路径两端点的 $lca$   」。</p>
<p>证明暂时不知道（但是我有在思考）什么比较优美的证明。但遇到这种情况总是可以分类讨论的…略了略了</p>
<p>于是为了不处理本来就有交点的情况，莫队上树选择维护 $p(u,v)=(u,v)\setminus\{lca(u,v)\}$ 。发现这东西有很好的性质，即 </p>
<script type="math/tex; mode=display">
p(u,v)~\mathrm{xor}~ p(x,y)=p(x, u) \text { xor } p(v, y)</script><p>其中 $~\mathrm{xor}~$ 定义在集合上。</p>
<p>证明大概是考虑令 $r(x)$ 表示 $x$ 到根节点的路径的点集。那么就可以这么化式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(u,v)~\mathrm{xor}~ p(x,y)&=p(x, u) \text { xor } p(v, y)\\
(r(u) ~\mathrm{xor}~ r(v))~\mathrm{xor}~(r(x) ~\mathrm{xor}~ r(y))&=(r(u) ~\mathrm{xor}~ r(x))~\mathrm{xor}~(r(v) ~\mathrm{xor}~ r(y))\\

\end{aligned}</script><p>然后接下来懒得写了，发现就是个交换律+结合律的套路。</p>
<p>于是考虑每次把 $p(ou,nu)$ 和 $p(ov, nv)$ 内的点全部取反，单独处理一下 $lca$ 就好了。</p>
<h1 id="2-如何分块"><a href="#2-如何分块" class="headerlink" title="$2$ 如何分块"></a>$2$ 如何分块</h1><p>发现就是 <code>loj#2151王室联邦</code> 这题的分块方式。似乎这东西证明的话可以直接归纳出来？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = tp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u]; k; k = next(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to(k), u);</span><br><span class="line">        <span class="keyword">if</span> (tp - base &gt;= S) &#123;</span><br><span class="line">            cap[++Id] = u;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; base) </span><br><span class="line">              blg[s[tp--]] = Id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[++tp] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i, u, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[s[tp--]] = Id;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">cout</span> &lt;&lt; blg[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Id; ++i) <span class="built_in">cout</span> &lt;&lt; cap[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-例题"><a href="#3-例题" class="headerlink" title="$3$ 例题"></a>$3$ 例题</h1><h2 id="1-SP10707-Count-On-a-Tree-2"><a href="#1-SP10707-Count-On-a-Tree-2" class="headerlink" title="$1$ SP10707 Count On a Tree 2"></a>$1$ SP10707 Count On a Tree 2</h2><blockquote>
<p>给定一个 $n$ 个节点的树，每个节点表示一个整数。</p>
<p>$q$ 组询问，询问 $u$ 到 $v$ 的路径上有多少个不同的整数。</p>
</blockquote>
<p>套路题？不禁思考我都做了些什么浪费时间的题啊…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[M] ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> son[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> n, q, len ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> top[N], sz[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; u &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">int</span> old = tp ; sz[u] = <span class="number">1</span> ;</span><br><span class="line">    fa[u] = f, dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f)&#123;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">			<span class="keyword">if</span> (tp - old &gt;= b)&#123;</span><br><span class="line">         	   ++ bnum ;</span><br><span class="line">         	   <span class="keyword">while</span> (tp &gt; old)</span><br><span class="line">				   blg[stk[tp --]] = bnum ;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f &amp;&amp; to(k) != son[u]) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qss a, qss b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.u] == blg[b.u] ? blg[a.v] &lt; blg[b.v] : blg[a.u] &lt; blg[b.u] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v) ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[x])</span><br><span class="line">        res += !buc[base[x]] ++ ;</span><br><span class="line">    <span class="keyword">else</span> res -= !-- buc[base[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) rev(u), u = fa[u] ;</span><br><span class="line">    <span class="keyword">while</span> (u != v) rev(u), rev(v), u = fa[u], v = fa[v] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ; </span><br><span class="line">	<span class="keyword">int</span> u, v, f ; b = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + n + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; bnum ++ ;</span><br><span class="line">	<span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ; </span><br><span class="line">	<span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qs[i].u, &amp;qs[i].v), qs[i].id = i ;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; lca(5, 8) &lt;&lt; " " &lt;&lt; lca(2, 7) &lt;&lt; " " &lt;&lt; lca(3, 7) &lt;&lt; endl ; </span></span><br><span class="line">    sort(qs + <span class="number">1</span>, qs + q + <span class="number">1</span>, comp) ; u = v = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        movemove(u, qs[i].u) ; u = qs[i].u ;</span><br><span class="line">        movemove(v, qs[i].v) ; v = qs[i].v ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qs[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>btw，感觉自己码风好多了？</p>
<h2 id="2-uoj-53-WC2013-糖果公园"><a href="#2-uoj-53-WC2013-糖果公园" class="headerlink" title="$2$ uoj#53 [WC2013]糖果公园"></a>$2$ uoj#53 [WC2013]糖果公园</h2><blockquote>
<p>给出一棵 $n$ 个点的树，每个节点有一个颜色。</p>
<p>每次或者询问你一条路径求 $\sum_{c}val_c\sum_{i=1}^{cnt_c}w_i$，或者更改一个点的颜色。</p>
<p>其中 $val$ 表示该颜色的价值, $cnt$ 表示其出现的次数, $w_i$ 表示第 $i$ 次出现的价值。</p>
<p>可以离线。</p>
</blockquote>
<p>发现就是树上莫队套了一个带修？</p>
<p>写起来没什么感觉…就是很长…很长…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, c ;</span><br><span class="line">&#125;us[Q] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">int</span> t, id ;</span><br><span class="line">&#125;qy[Q] ;</span><br><span class="line">LL res ;</span><br><span class="line">LL ans[Q] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> cntu, cntq ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> sz[N], son[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N], vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], top[N] ;</span><br><span class="line"><span class="keyword">int</span> val[M], wth[M], clr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u] = f ; <span class="keyword">int</span> t = tp ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), u) ; sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">        <span class="keyword">if</span> (tp - t &gt;= b)&#123;</span><br><span class="line">            ++ bnum ;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; t)</span><br><span class="line">                blg[stk[tp --]] = bnum ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != f) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            u ^= v ^= u ^= v ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.u] == blg[c.u]) ?</span><br><span class="line">           ((blg[a.v] == blg[c.v]) ? a.t &lt; c.t : blg[a.v] &lt; blg[c.v]) : (blg[a.u] &lt; blg[c.u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])</span><br><span class="line">        res -= <span class="number">1l</span>l * wth[buc[clr[x]] --] * val[clr[x]] ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res += <span class="number">1l</span>l * wth[++ buc[clr[x]]] * val[clr[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[x] &gt; dep[y]) rev(x), x = fa[x] ;</span><br><span class="line">    <span class="keyword">while</span> (x != y) rev(x), rev(y), x = fa[x], y = fa[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, l, r, mk, t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wth[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;clr[i]) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; endl ;</span></span><br><span class="line">    b = <span class="built_in">pow</span>(<span class="number">1.0</span> * n, <span class="number">0.6667</span>) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; ++ bnum ;</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ;dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) ;</span><br><span class="line">    u = <span class="number">1</span>, v = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; lca(1, 3) &lt;&lt; " " &lt;&lt; lca(2,4) &lt;&lt; " " &lt;&lt; lca(1, 4) &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " "  ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;mk, &amp;l, &amp;r) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)</span><br><span class="line">            qy[++ cntq].u = l, qy[cntq].v = r,</span><br><span class="line">            qy[cntq].t = cntu, qy[cntq].id = cntq ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            us[++ cntu].p = l, us[cntu].c = r ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(qy + <span class="number">1</span>, qy + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)&#123;</span><br><span class="line">        movemove(u, qy[i].u) ;</span><br><span class="line">        movemove(v, qy[i].v) ;</span><br><span class="line">        u = qy[i].u, v = qy[i].v ;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; qy[i].t)&#123;</span><br><span class="line">            ++ t ;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; qy[i].t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">            t -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qy[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】简单莫队瞎吹</title>
    <url>/2020/01/23/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E4%B8%8E%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>…感觉这东西似乎也没啥好说的啊</p>
<a id="more"></a>
<h1 id="1-理论瞎吹"><a href="#1-理论瞎吹" class="headerlink" title="$1$ 理论瞎吹"></a>$1$ 理论瞎吹</h1><p>大概就是个分块？但是是对询问分块的。莫队的精髓在于排序，排序时如果 <code>belong[l]</code> 相同复杂度就按照右端点排序，这样似乎是有保证的？</p>
<p>令 $m$ 为操作数，$B$ 为块大小。考虑对于一个块内的 $l$，其 $r$ 是单增的，于是考虑如下：</p>
<ul>
<li>左端点，在块内可能会一前一后这样设置，这样复杂度被卡到最满，为 $O(m\cdot B)$ ；</li>
<li>右端点，考虑各块内的询问显然都可以做到单块 $O(n)$，所以不需要考虑 $m$ 的贡献，即右端点移动的复杂度就是 $\frac{n}{B}\cdot n=\frac{n^2}{B}$。</li>
</ul>
<p>均值一下发现 $m\cdot B+\frac{n^2}{B}\geq 2\sqrt{n^2m}=O(n\sqrt m)$ ，此时有 $m\cdot B=\frac{n^2}{B}$，解得 $B=\frac{n}{\sqrt m}$ .</p>
<p>所以取块大小为 $\frac{n}{\sqrt m}$ 时达到理论最优，复杂度为 $O(n\sqrt m)$ 。</p>
<p>…当然这东西可能不准，毕竟常数稍微优一点可能就可以瞎分块了233</p>
<p>然后考虑如何带修改(当然只能离线做)。发现单纯地平移询问区间不对，于是考虑加一维时间轴，在平移完询问之后平移修改操作。排序时把「离当前询问最近的前一个修改操作是第几次修改」作为第三关键字，第二关键字换成「右端点所在块的编号」。</p>
<p>令 $c$ 为修改个数， $q$ 为询问个数，$B$ 依旧为块大小。那么考虑三维指针是怎么移动的：</p>
<ul>
<li>左端点和右端点依次还是 $qB+\frac{n^2}{B}$ ；</li>
<li>时间端点，考虑时间端点实际上每次至多移动 $c$，但是时间端点之外此时套了一层按 <code>belong[r]</code> 分的块，所以这一部分的复杂度为 $O(c\times\frac{n^2}{B^2})$ .</li>
</ul>
<p>于是总复杂度为 $O(\frac{n^2c}{B^2}+qB+\frac{n^2}{B})$。</p>
<p>这个东西他怎么求 $\min$ 呢…</p>
<p><del>嗯，你看这个式子这么可爱，求导总是可以求出来的吧，于是就不详细写了</del>~</p>
<p>直接上结论，$B=O(n^{\frac{2}{3}})$ 时最优，此时复杂度为 $O(n^{\frac{2}{3}}c+n^{\frac{2}{3}}q+n^\frac{4}{3})=O(n^{\frac{2}{3}}m)$。</p>
<p>发现这东西很好的一点就是，这么分块，复杂度不会受操作类型影响，因为 $q+c=m$ 是根据已知推出来，不是放缩放掉的。所以是个很满分的复杂度。</p>
<h1 id="2-水题瞎做"><a href="#2-水题瞎做" class="headerlink" title="$2$ 水题瞎做"></a>$2$ 水题瞎做</h1><h2 id="1-LG2709-小B的询问"><a href="#1-LG2709-小B的询问" class="headerlink" title="$1$ LG2709 小B的询问"></a>$1$ LG2709 小B的询问</h2><blockquote>
<p>给出长度为 $n$ 的序列，$q$ 组询问，每次询问区间 $[l,r]$ 内的 $\sum e_i^2$ 。其中 $e_i$ 表示数 $i$ 的出现次数。</p>
</blockquote>
<p>似乎是憨憨题？就是道普通的莫队。</p>
<p>不过学了一招，就是奇偶块的 $r$ 坐标反向排序。这样似乎理论应该带一个下界为 $\frac{1}{2}$ 的常数。但实际应用可能并不明显。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> blg[a.l] == blg[b.l] ? ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans -= (<span class="number">2l</span>l * buc[base[p]] - <span class="number">1l</span>l), buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans += (<span class="number">2l</span>l * buc[base[p]] + <span class="number">1l</span>l), buc[base[p]] ++ ; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-LG1494-小Z的袜子"><a href="#2-LG1494-小Z的袜子" class="headerlink" title="$2$ LG1494 小Z的袜子"></a>$2$ LG1494 小Z的袜子</h2><blockquote>
<p>给出一个长为 $n$ 的序列，每次询问 $[l,r]$ 内，随机取两个数取到相同的数的概率。</p>
</blockquote>
<p>大概也是个憨憨题…发现最后结果就是 $\frac{\mathrm{cnt(same_pair)}}{\binom{r-l+1}{2}}$。</p>
<h2 id="3-LG3709-大爷的字符串题"><a href="#3-LG3709-大爷的字符串题" class="headerlink" title="$3$ LG3709 大爷的字符串题"></a>$3$ LG3709 大爷的字符串题</h2><p>这题nmd是道语文题…</p>
<blockquote>
<p>原题面：</p>
<p>给你一个字符串 $a$，每次询问一段区间的贡献</p>
<p>贡献定义：</p>
<p>每次从这个区间中拿出一个字符 $x$，然后把 $x$ 从这个区间中删除，你要维护一个集合 $\rm S$：如果 $\rm S$ 为空，你 $rp$ 减 $1$ ; 如果 $\rm S$ 中有一个元素不小于 $x$，则你 $rp$  减 $1$，清空 $\rm S$；之后将 $x$ 插入 $\rm S$ 。</p>
<p>由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 $rp$ ？$rp$ 初始为 $0$，询问之间不互相影响。</p>
</blockquote>
<p>发现大概是在说，每次给定一个区间，要从中取出最少数量的严格上升子序列使得覆盖所有的数。发现其实就是「区间内出现次数最多的数」出现的次数。</p>
<p>这东西也比较容易维护，再拿另一个 $bucbuc$ 来维护 $buc$ 就解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">	rg <span class="keyword">int</span> t = ++ buc[base[p]] ; </span><br><span class="line">	bucbuc[t] ++, bucbuc[t - <span class="number">1</span>] --, ans += (t &gt; ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">	rg <span class="keyword">int</span> t = -- buc[base[p]] ;</span><br><span class="line">	bucbuc[t] ++, bucbuc[t + <span class="number">1</span>] --, ans -= !bucbuc[ans] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是离散化之后的，复杂度就是比较稳的 $m \sqrt n$ 了。</p>
<p>但是还有一个不费脑子的方法，就是第一个 $buc$ 直接用 <code>std:: unordered_map</code> 来实现。但这东西首先复杂度是个谜，你说他是 $O(1)$ 的，但是确实很慢；你说他是 $\log$ 的，但毕竟只是个 $Hash$ 表，实在没理由是 $\log$ 的。</p>
<p>嗯，具体实现可能是什么 「亚 $\log$」 的Hash表吧。</p>
<h2 id="4-LG1903-国家集训队-数颜色"><a href="#4-LG1903-国家集训队-数颜色" class="headerlink" title="$4$  LG1903 [国家集训队]数颜色"></a>$4$  LG1903 [国家集训队]数颜色</h2><blockquote>
<p>询问区间内不同的数的个数+带修。</p>
</blockquote>
<p>这有啥好说的啊？</p>
<p>不过有一点需要注意：由于时间轴左右横跳要消除贡献，所以需要记录一下每个位置修改之前的值。这个地方直接 <code>std:swap</code> 做就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> blg[a.l] == blg[b.l] ? </span><br><span class="line">		  (blg[a.r] == blg[b.r] ? a.t &lt; b.t : blg[a.r] &lt; blg[b.r]) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!-- buc[base[p]]) -- ans ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!buc[base[p]] ++) ++ ans ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> l, r, v, p, i, j ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">if</span> (In[<span class="number">1</span>] == <span class="string">'Q'</span>)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r), q[++ cntq].t = cntm, </span><br><span class="line">			q[cntq].l = l, q[cntq].r = r, q[cntq].id = cntq ;  </span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v), m[++ cntm].p = p, m[cntm].c = v ;</span><br><span class="line">	&#125;</span><br><span class="line">	B = <span class="built_in">pow</span>((<span class="keyword">double</span>)N, <span class="number">0.677</span>), </span><br><span class="line">	Bnum = <span class="built_in">ceil</span>((<span class="keyword">double</span>)N / (<span class="keyword">double</span>)B) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Bnum ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = B * i + <span class="number">1</span> ; j &lt;= B * (i + <span class="number">1</span>) ; ++ j) blg[j] = i + <span class="number">1</span> ;</span><br><span class="line">	l = <span class="number">1</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>, T = <span class="number">0</span> ;</span><br><span class="line">	sort(q + <span class="number">1</span>, q + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">		<span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ;		</span><br><span class="line">		<span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">		<span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ; </span><br><span class="line">		<span class="keyword">while</span> (q[i].t &gt; T)&#123;</span><br><span class="line">			++ T ;</span><br><span class="line">			<span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line">				<span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">			&#125;</span><br><span class="line">			swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (q[i].t &lt; T)&#123;</span><br><span class="line">			<span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line">				<span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">			&#125;	</span><br><span class="line">			swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">			-- T ;</span><br><span class="line">		&#125;</span><br><span class="line">		res[q[i].id] = ans ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cntq ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎选的都是很水的…剩下的题需要脑子，我莫得脑子，所以就先这样吧。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记&amp;题解】线段树优化建图</title>
    <url>/2020/01/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是把边数从 $n^2$ 优化到 $n\log n$ 的一个操作？还是挺简单的吧。</p>
<a id="more"></a>
<h1 id="0-瞎扯"><a href="#0-瞎扯" class="headerlink" title="$0$ 瞎扯"></a>$0$ 瞎扯</h1><p>考虑三个场景：从 $[l_1,r_1]$ 连向 $x$, 从 $x$ 连向 $[l_2,r_2]$，从 $[l_1,r_1]$ 连向 $[l_2,r_2]$ 。</p>
<p>发现可以用两棵线段树来模拟这个东西，一棵线段树从 $rt$ 向 $lc,rc$ 连边，一棵从 $lc,rc$ 向 $rt$ 连边。只要把叶子节点设置为 $1\sim n$ ，这样最终点数就是 $O(n\log n)$ 的。稳得很。</p>
<p>然后就没有然后了。</p>
<h1 id="1-CF786B-Legacy"><a href="#1-CF786B-Legacy" class="headerlink" title="$1$ CF786B Legacy"></a>$1$ CF786B Legacy</h1><blockquote>
<p>给定一张 $n$ 个点的图，有 $m$ 个下列操作：</p>
<ul>
<li><p>1.进行单点与单点连有向边 </p>
</li>
<li><p>2.进行单点与区间连有向边 </p>
</li>
<li><p>3.进行区间与单点连有向边。</p>
</li>
</ul>
<p>求最短路。</p>
</blockquote>
<p>发现就是个板子？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[NN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">LL dis[NN] ;</span><br><span class="line"><span class="keyword">int</span> n, m, s ;</span><br><span class="line"><span class="keyword">bool</span> vis[NN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="keyword">int</span> Id, head[NN], cnt ;</span><br><span class="line"><span class="keyword">int</span> rt1, rt2, lc[NN], rc[NN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = val,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid, p) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">    <span class="keyword">if</span> (!p) add(rt, lc[rt], <span class="number">0</span>), add(rt, rc[rt], <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">else</span> add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        p ? add(rt, u, w) : add(u, rt, w) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w, p) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    Id = n, <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; s ;</span><br><span class="line">    build(rt1, <span class="number">1</span>, n, <span class="number">0</span>) ;</span><br><span class="line">    build(rt2, <span class="number">1</span>, n, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> mk, u, v, w, l, r ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt1, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt2, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; " " &lt;&lt; E[i].val &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    fill(dis, dis + Id + <span class="number">1</span>, Inf) ;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        vis[n] = <span class="number">0</span>, q.pop() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[n] + val(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[n] + val(k) ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, dis[i] == Inf ? <span class="number">-1</span> : dis[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-LG3588-POI2015-PUS"><a href="#2-LG3588-POI2015-PUS" class="headerlink" title="$2$ LG3588 [POI2015]PUS"></a>$2$ LG3588 [POI2015]PUS</h1><blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $a$ ,每个数都在 $1$ 到 $10^9$ 范围内,告诉你其中 $s$ 个数.</p>
<p>给出 $m$ 条信息,每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数,表示 $a_l..a_{l+1}…a_{r-1}..a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大 (严格大于，即没有等号)</p>
<p>构造一组合法解或者输出 $-1$ </p>
</blockquote>
<p>似乎就是一个差分约束？发现每次需要从每个 $k_{i,j}$ 连向剩下的子区间。如果用线段树优化建图，这样就是 $\sum k_i^2\log k_i$ 的边数，炸的很惨。</p>
<p>这个地方有个很妙的 $\rm Idea$ ，即对每个操作建立一个新点 $p_i$，让每个 $k_{i,j}$ 连向 $p_i$，再让 $p_i$ 连向每个分割开的子区间。这样就成功地只需要 $\sum O(k_i\log k_i)$ 的空间，很稳。</p>
<p><del>话说这还是自己第一次真正去写差分约束</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = val, deg[v] ++ ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) <span class="keyword">return</span> add(rt, u, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; m ;</span><br><span class="line">    Id = n ; build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), base[u] = dis[u] = v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k) ;</span><br><span class="line">        Id ++, last = l - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v) ; add(Id, v, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (last + <span class="number">1</span> &lt; v)</span><br><span class="line">				update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, v - <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            last = v ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last &lt; r)</span><br><span class="line">            update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, r, <span class="number">0</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dis[i]) dis[i] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        u = q.front() ; q.pop() ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = max(dis[to(k)], dis[u] + val(k)) ;</span><br><span class="line">            <span class="keyword">if</span> (base[to(k)] &amp;&amp; dis[to(k)] &gt; base[to(k)])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i] || dis[i] &gt; Inf) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"TAK"</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dis[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-SNOI2017-炸弹"><a href="#3-SNOI2017-炸弹" class="headerlink" title="$3$ [SNOI2017]炸弹"></a>$3$ [SNOI2017]炸弹</h1><blockquote>
<p>在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $x_i$，爆炸半径是 $r_i$。</p>
<p>当一个炸弹爆炸时，如果另一个炸弹所在位置 $x_j$ 满足： $|x_j-x_i| \le r_i$ ，那么，该炸弹也会被引爆。计算先把第 $i$ 个炸弹引爆，将引爆多少个炸弹。</p>
<p>答案对 $10^9+7$ 取模。保证 $x_i$ 随着 $i$ 单增。</p>
</blockquote>
<p>发现可以先二分出每个点要连的左右端点。然后考虑缩点。由于是 $\rm DAG$ 就可以直接求出每个点能到达的点的编号的 $\min,\max$ ，这东西可以一遍 $\rm topsort$ 求出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">8000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N], tp ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">LL x[N], r[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> SCC, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> n, Id, root ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">3</span>][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N] ;</span><br><span class="line"><span class="keyword">int</span> lc[N * <span class="number">3</span>], rc[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, fr(cnt) = u,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        rt = l ;</span><br><span class="line">        val[l][<span class="number">0</span>] = l ;</span><br><span class="line">        val[l][<span class="number">1</span>] = l ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(rt, lc[rt]) ; add(rt, rc[rt]) ;</span><br><span class="line">    val[rt][<span class="number">0</span>] = val[lc[rt]][<span class="number">0</span>] ;</span><br><span class="line">    val[rt][<span class="number">1</span>] = val[rc[rt]][<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul ,<span class="keyword">int</span> ur, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> f == rt ? <span class="keyword">void</span>() : add(f, rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, ul, ur, f) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, ul, ur, f) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++ tp] = x, vis[x] = <span class="number">1</span> ;</span><br><span class="line">    dfn[x] = low[x] = ++ tot ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to(k)])</span><br><span class="line">            tarjan(to(k)),</span><br><span class="line">            low[x] = min(low[x], low[to(k)]) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            low[x] = min(low[x], dfn[to(k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> now ;</span><br><span class="line">        L[++ SCC] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (tp)&#123;</span><br><span class="line">            now = s[tp --] ;</span><br><span class="line">            L[SCC] = min(L[SCC], val[now][<span class="number">0</span>]) ;</span><br><span class="line">            R[SCC] = max(R[SCC], val[now][<span class="number">1</span>]) ;</span><br><span class="line">            vis[now] = <span class="number">0</span>, blg[now] = SCC ;</span><br><span class="line">            <span class="keyword">if</span> (now == x) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> lq, rq ; LL xx, oo ;</span><br><span class="line">    Id = n, build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; fr(i) &lt;&lt; " " &lt;&lt; to(i) &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x[i], &amp;r[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        xx = x[i], oo = r[i] ;</span><br><span class="line">        lq = lower_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx - oo) - x ;</span><br><span class="line">        rq = upper_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx + oo) - x ;</span><br><span class="line">        rq -- ; <span class="keyword">if</span> (lq &lt;= rq) update(root, <span class="number">1</span>, n, lq, rq, i) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; lq &lt;&lt; " " &lt;&lt; rq &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; root &lt;&lt; endl ;</span></span><br><span class="line">    tarjan(root) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; " " &lt;&lt; SCC &lt;&lt; endl ;</span></span><br><span class="line">    tot = cnt, cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (blg[fr(i)] != blg[to(i)])</span><br><span class="line">            add(blg[to(i)], blg[fr(i)]), deg[blg[fr(i)]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= SCC ; ++ i) <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        oo = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[oo] ; k ; k = next(k))&#123;</span><br><span class="line">            L[to(k)] = min(L[to(k)], L[oo]) ;</span><br><span class="line">            R[to(k)] = max(R[to(k)], R[oo]) ;</span><br><span class="line">            <span class="keyword">if</span> (!-- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        (ans += <span class="number">1l</span>l * i * (R[blg[i]] - L[blg[i]] + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; L[blg[i]] &lt;&lt; " " &lt;&lt; R[blg[i]] &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>图论/普通建图技巧</tag>
        <tag>图论/线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记&amp;题解】线段树合并瞎吹</title>
    <url>/2020/01/23/SegmentTreemerge1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是合并俩线段树？重复的点一块儿用，否则直接拉过来指针。大多数都是动态开点写法（比较优美）。</p>
<p>以合并值域线段树为例说明。其复杂度是均摊的，即考虑每一次合并操作的复杂度实际上是两颗线段树重叠的点的数量。因为最后一共有 $n\log |V|$ 个点，所以复杂度是 $O(n\log |V|)$，其中 $V$ 是每个被合并元素的值域。</p>
<p>值得注意的是有些题同样需要维护合并之前的信息，那么合并的时候就需要新建节点当根。但根据主席树那套理论，本质上空间复杂度只会多个 $\log$ ?（存疑</p>
<a id="more"></a>
<h1 id="1-USACO17JAN-Promotion-Counting"><a href="#1-USACO17JAN-Promotion-Counting" class="headerlink" title="$1$ [USACO17JAN]Promotion Counting"></a>$1$ [USACO17JAN]Promotion Counting</h1><blockquote>
<p>给定一棵树，对于所有的 $i\in[1,n]∩\mathbb{Z}$ ，求以 $i$ 为根的子树内有多少权值 $&gt;i$ 的点。 </p>
</blockquote>
<p>大概是比较裸的线段树合并了？</p>
<p>考虑如果按照正常地线段树合并方式，从底向上合并，那么离散化后对于每个点只需要查询线段树内 $base_i\sim n$ 的数字个数和。于是就完了。</p>
<p>有两个点需要注意：</p>
<ul>
<li>1、线段树合并不同于普通的值域线段树建立，每次 <code>update</code> 可能会存在走重复节点的情况（否则复杂度就不对了）。所以需要特判 <code>if (!Rt) Rt = ++ Id ;</code> 。</li>
<li>2、本题由于保证了 $base_i$ 互异，所以离散化可以用一种比较有趣的方式进行：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[a] &lt; base[b] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = i ;</span><br><span class="line">sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>, comp), base[t[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f), add(f, i), base[t[i]] = i ;</span><br></pre></td></tr></table></figure>
<p>其实也是很简单的吧？类似的 $trick$ 以前用过好多次了？</p>
<p>然后以下是总代码。大概就背一背 <code>merge</code> 就好了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N] ; <span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> lc[N * <span class="number">15</span>], rc[N * <span class="number">15</span>] ;</span><br><span class="line"><span class="keyword">int</span> rt[N * <span class="number">15</span>], val[N * <span class="number">15</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, ans[N], base[N], t[N], Id ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[a] &lt; base[b] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;Rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Rt) Rt = ++ Id ; val[Rt] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid) update(lc[Rt], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[Rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ Id ;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="number">1l</span>l * x * y)) <span class="keyword">return</span> x + y ;</span><br><span class="line">    val[now] = val[x] + val[y] ;</span><br><span class="line">    lc[now] = merge(lc[x], lc[y]),</span><br><span class="line">    rc[now] = merge(rc[x], rc[y]) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> val[root] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(lc[root], l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(rc[root], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        dfs(to(k)), rt[u] = merge(rt[u], rt[to(k)]) ;</span><br><span class="line">    ans[u] = query(rt[u], <span class="number">1</span>, n, base[u] + <span class="number">1</span>, n), update(rt[u], <span class="number">1</span>, n, base[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = i ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>, comp), base[t[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f), add(f, i), base[t[i]] = i ;</span><br><span class="line">    dfs(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-POI2011-ROT-Tree-Rotations"><a href="#2-POI2011-ROT-Tree-Rotations" class="headerlink" title="$2$ [POI2011]ROT-Tree Rotations"></a>$2$ [POI2011]ROT-Tree Rotations</h1><blockquote>
<p>给出一棵 $n(1≤n≤200000)$ 个叶子的二叉树，可以交换每个点的左右子树，要求前序遍历叶子的逆序对最少。</p>
</blockquote>
<p>很妙的一道线段树合并题。</p>
<p>首先，考虑由于只能交换左右子树，所以对于一个点，后代的子树怎么变对其答案没有影响。发现用线段树合并来维护特别合适：对于每个点是否交换左右子树，分别算出新增的逆序对个数然后取 $\min$，该过程可以在 <code>merge</code> 中直接进行——维护值域的 $\rm exist_sum$ 之后，每次只需要用乘法原理求一下即可。</p>
<p>然后就是这题读入很诡…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200011</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400011</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6000011</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt ;</span><br><span class="line"><span class="keyword">int</span> lc[NN], rc[NN], rt[NN] ;</span><br><span class="line">LL ans, val[NN], ans1, ans2 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ch_top = <span class="number">5e7</span> + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">char</span> ch[ch_top], *now_r = ch - <span class="number">1</span>, *now_w = ch - <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">' '</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;Rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Rt)</span><br><span class="line">        Rt = ++ cnt ;</span><br><span class="line">    val[Rt] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid) update(lc[Rt], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[Rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x + y ;</span><br><span class="line">    val[x] += val[y] ;</span><br><span class="line">    ans1 += val[lc[x]] * val[rc[y]] ;</span><br><span class="line">    ans2 += val[rc[x]] * val[lc[y]] ;</span><br><span class="line">    lc[x] = merge(lc[x], lc[y]) ;</span><br><span class="line">    rc[x] = merge(rc[x], rc[y]) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, ls, rs ;</span><br><span class="line">    y = read() ;</span><br><span class="line">    <span class="keyword">if</span> (!y)&#123;</span><br><span class="line">        ls = rs = <span class="number">0</span> ;</span><br><span class="line">        dfs(ls), dfs(rs) ; ans1 = ans2 = <span class="number">0</span> ;</span><br><span class="line">        x = merge(ls, rs) ; ans += min(ans1, ans2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> update(x, <span class="number">1</span>, n, y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">    n = read() ; <span class="keyword">int</span> u = <span class="number">0</span> ; dfs(u) ; write(ans) ;</span><br><span class="line">    fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Vani有约会-雨天的尾巴"><a href="#3-Vani有约会-雨天的尾巴" class="headerlink" title="$3$ [Vani有约会]雨天的尾巴"></a>$3$ [Vani有约会]雨天的尾巴</h1><blockquote>
<p>给出一棵 $n$ 个结点的树。共 $m$ 次操作，每次给出树上的一条路径，给路径上所有点添加一个权值为 $w$ 的元素。最后输出每个点出现次数最多的元素的权值。</p>
</blockquote>
<p>考虑暴力去剖，发现这么做是 $\frac{n^2\log^2 n}{\omega}$的，即暴力合并 bitset.</p>
<p>但是发现可以离线，于是考虑直接用剖去维护树上差分。那么考虑，对于最终的 $m$ 组询问，可以处理为 $n\log n$ 段 $dfn$ 上的序列差分。</p>
<p>于是对这些差分再用权值线段树从头开始扫一遍就完了。最终复杂度 $O(n\log n)\times O(\log n)=O(n\log^2n)$ 。</p>
<p>但其实发现，树上差分然后拆区间这个过程完全可以用dfs+线段树合并来替代，于是复杂度降为 $n\log n$ 。</p>
<p>…但其实第二个做法其中拆询问的那个 $\log$ 跟本跑不满，再加上线段树合并的复杂度，均摊出来是在是有点 $gg$，于是似乎链剖踩爆了线段树合并的亚子QAQs。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    fa[u] = f, sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != f) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v) ;</span><br><span class="line">        u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &gt; dep[v] ? v : u ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[lc[u]] &gt; s[rc[u]])</span><br><span class="line">        s[u] = s[lc[u]], val[u] = val[lc[u]] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[lc[u]] &lt; s[rc[u]])</span><br><span class="line">        s[u] = s[rc[u]], val[u] = val[rc[u]] ;</span><br><span class="line">    <span class="keyword">else</span> s[u] = s[lc[u]], val[u] = min(val[lc[u]], val[rc[u]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) u = ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        s[u] += v ;</span><br><span class="line">        val[u] = s[u] ? r : <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(lc[u], l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[u], mid + <span class="number">1</span>, r, p, v) ; _up(u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> s[x] += s[y], val[x] = l, x ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lc[x] = merge(lc[x], lc[y], l, mid) ;</span><br><span class="line">    rc[x] = merge(rc[x], rc[y], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _up(x) ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f)</span><br><span class="line">            do_do(to(k), x),</span><br><span class="line">            rt[x] = merge(rt[x], rt[to(k)], <span class="number">1</span>, S) ;</span><br><span class="line">    ans[x] = val[rt[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v, z, f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(u), qr(v),</span><br><span class="line">        qr(z), f = lca(u, v) ;</span><br><span class="line">        update(rt[u], <span class="number">1</span>, S, z, <span class="number">1</span>) ;</span><br><span class="line">        update(rt[v], <span class="number">1</span>, S, z, <span class="number">1</span>) ;</span><br><span class="line">        update(rt[f], <span class="number">1</span>, S, z, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (fa[f]) update(rt[fa[f]], <span class="number">1</span>, S, z, <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    do_do(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-HNOI2012-永无乡"><a href="#4-HNOI2012-永无乡" class="headerlink" title="$4 $ [HNOI2012] 永无乡"></a>$4 $ [HNOI2012] 永无乡</h1><blockquote>
<p>你需要维护若干连通快，有两个操作：</p>
<ul>
<li>合并 $x,y$ 所在的连通块。</li>
<li>询问 $x$ 所在连通块中权值从小到大排第 $k$ 的结点编号。</li>
</ul>
<p>$1\leq n,q\leq 3\cdot 10^5$</p>
</blockquote>
<p>fa♂现线段树合并之后直接在线段树上二分就做完了，$n\log n$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, I + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2) fa[f2] = f1, rt[f1] = merge(rt[f1], rt[f2]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u = qr(), k = qr(), u = find(u) ;</span><br><span class="line">        <span class="keyword">if</span> (s[rt[u]] &lt; k) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(rt[u], <span class="number">1</span>, n, k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片2】· 原来我还什么都不懂</title>
    <url>/2020/01/23/Life2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在看「爱情公寓5」，感触很多。</p>
<a id="more"></a>
<p>还记得自己是小学4年级第一次听同学说过这个剧，当时还觉得名字很俗气。之后就开始慢慢地追啊追，从当时正在热播的第三季追到第二季、第一季，而后又等到第四季，等到现在的第五季。</p>
<p>然而，每次看「爱情公寓」之前，都是很纠结很纠结的。纠结在，剧里描绘的那个世界那么美好简单，每次看完我都会感到无奈好几天、难以释怀好几天——这样的生活恐怕不属于我吧。</p>
<p>如果说我心中有两个地方最脆弱，那就是对往事的追思让我感到无奈与感动、对可望而不可即的生活的期盼让我感到渺小与希望。</p>
<p>所以，本质上，「爱情公寓5」这部剧，就是一个「移情」的途径。它既承载了我对以前追剧时简单生活的追思与怀念，又承载了「最好的朋友就在身边、最爱的人就在对面」的渴望与无奈，所以我才会很难以释怀。</p>
<p>然而这其实只是个小问题，但以前我似乎从来没去想过为什么我会那么彷徨无奈。</p>
<p>或许是从停课开始的，或许是从联赛开始的，或许会更早些——我会时常感到：“啊，原来我还什么都不懂，原来这个世界对我来说还是陌生的”。</p>
<p>啊，原来我还什么都不懂。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>初中时，跟最要好的伙伴有一天突然聊到了心理。她说：“或许大家应该都去看看那些心理学的书，里面的东西或许挺值得学习的”。</p>
<p>我记得当时我十分不屑地说：“那上面那些东西，对自己而言都没啥价值吧？学了之后去别人或许挺有用，这点心理暗示对自己根本不起作用。”</p>
<p>她本就是个比较文静沉默的人，所以并没有继续跟我争论。</p>
<p>记得自己小时候很爱看心理学的书。可能缘于刚接触大自然，对什么事情都有一种新鲜的控制欲，自然什么「微表情窥探一个人的内心」、「浅谈心理学」之类的科普书籍比较受我喜爱。</p>
<p>但直到最近我才发现，原来这是一门需要经验和丰富学识的学科，并不是草草的阅读就能拯救来的。</p>
<p>接着我发现，原来似乎每一行要干好，都不容易。自己以前建立起的莫名其妙的自负，从那开始便渐渐开始烟消云散了。</p>
<p>原来我还什么都不懂。</p>
<p>记得曾经在初中，寄宿制。最好的两个朋友每天都要去给父母打一次电话。我很不理解，因为自己两周也未必会打一次电话。于是就带着有点轻蔑的口吻问他们：“每天打一次电话是不是有点太不独立了？老哥们，我们都初中了诶，也不用像小学一样成天跟家长沟通吧。要独立，独立！”</p>
<p>之后，他们也没说什么，只是简单地搪塞了过去。当时自己还觉得我很厉害，有点瞧不起这种每天都依赖父母的人。</p>
<p>直到高一的暑假，外出培训时，和别的人又发生了类似的争吵——我才发现，可能我随手毁坏的、侮辱的，是别人的人生信条。不同的人有不同的人生信条，就如同不同的夜挂着不同的星。我说那夜没有星，只是因为我觉得每天的星都不同而没去看，经验之谈罢了。</p>
<p>原来我还什么都不懂。</p>
<h2 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h2><p>看完了《爱情公寓5》。其实本来我一周前就看完了前 $34$ 集，一直舍不得看最后两集，骗自己说『没事，不看完的话，就永远也不会结束，对吧？』。</p>
<p>这种家庭式喜剧永远是我的伤痛。我有着健全美满的家庭，不错的同学朋友，优秀的老师。但我就是不满足。似乎我的快乐根本无法寄托在这种人与人之间的情感共鸣上。但是每当看完一季《爱情公寓》也好、《生活大爆炸》也罢、等待下一季的时候，我都会时不时地在想：为什么我就不能进入那个世界呢？周围的生活庸俗且颓废，高中之后唯一的寄托可能就是OI，但是OI这条路，我已经等够了啊。一天又一天告诉自己等待只是因为自己太弱，但是原谅我，我不知道该怎么改变这个现状啊？</p>
<p>于是自己就一直想要去逃避，逃避这一切。</p>
<p>但看《爱情公寓》的片花时，我发现，撕开那璀璨的剧情，原来每个演员都是十分努力的在演戏，一条不行换下一条，比起我这个整日只会空想的死肥宅高到不知道什么地方去了。所以我就在想啊，他们其实就是在无比地热爱着自己的生活吧？而我呢？似乎上了高中之后，就再也没有热爱过生活。</p>
<p>我到底怎么了呢？</p>
<p>但其实，我可能还没有必要去纠结这些东西。《爱情公寓》在落幕之前，揭示了主旨，就是『革命乐观主义精神』。宣传片的歌词里也说『_人生下一关 / 等着我们去开启 / 成长需要告别过去自己_』。所以，这可能就是我需要的吧。</p>
<p>热爱自己的生活，就是这样。无论自己空想出来的世界有多美，书里、剧里勾勒的世界有多妙，这一幕结束之后，我还是要去走自己的人生。逃避是没有用的，正面A上去才是唯一的救赎之道。</p>
<h2 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h2><p>这一篇算什么？鸡汤？</p>
<p>差不多吧。但我觉得比起鸡汤来，这东西显得浑浊的多。</p>
<p>我身处无尽深渊的最底部。周身弥漫的是紫黑色的雾气。我的双眼瞎了、两耳聋了、嘴也张不开了。但我能感受到自己身上在绽放着生命的力量，催我爬出去。</p>
<p>嗯，很赞同的一个观点：</p>
<blockquote>
<p>很多人想知道，生命的意义到底是什么？我们每天行色匆匆、得过且过。我们到底为什么而活？</p>
<p>其实，『活着』的意义，就是『活着』本身。</p>
</blockquote>
<p>总之呢，原来我还什么都不懂。这个世界，我还要一点一点慢慢地探索；这条路，我还要慢慢的走。</p>
<h2 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h2><p>最后挂几张爱情公寓的图，毕竟也是陪了我五六年的剧了。纪念一下吧！</p>
<p>再见啦，我的青春。再见啦，爱情公寓！</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1RP91A.jpg" alt><br><img src="https://s2.ax1x.com/2020/02/08/1RPPXt.jpg" alt><br><img src="https://s2.ax1x.com/2020/02/08/1RPppd.jpg" alt><br><img src="https://s2.ax1x.com/2020/02/08/1RCzfH.jpg" alt><br><img src="https://s2.ax1x.com/2020/02/08/1RCxte.jpg" alt><br><img src="https://s2.ax1x.com/2020/02/08/1RPFnP.jpg" alt></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记/题解】AC自动机瞎吹</title>
    <url>/2020/01/17/AC%E8%87%AA%E5%8A%A8%E6%9C%BA1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AC自动机算是自动机系列比较早期引入OI的算法，全称为「$\rm Aho-Corasick ~Automaton$」。</p>
<p>然而其实这款自动机是以两个科学家的名字命名的。（这「款」？</p>
<p>并且上面这一条信息还是我从有道词典里查出来的，百度根本百度不到好吗 QAQ</p>
<p>不过话说这东西也是好久之前学的，于是这篇 blog 实际上是在炒冷饭。</p>
<a id="more"></a>
<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="$1$ 原理"></a>$1$ 原理</h1><p>原理还是很简单的，就是把 KMP 的一半放到了 Trie 上。那找 fail 就肯定要 bfs 了对吧。根据 Trie 的性质，一开始肯定是要把根节点所有非空孩子当作起始状态。大概是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123; </span><br><span class="line">    	<span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]) ; </span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!tr[now][i]) tr[now][i] = tr[fail[now]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[tr[now][i]] = tr[fail[now]][i], q.push(tr[now][i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑求 $fail$ 的时候，如果没有当前的孩子，执行一个路径压缩。否则直接转移就可以了。</p>
<p>关于 $fail$ 的意义，一个点的 $fail$ 指向是其他模式串和他的最长的公共后缀，并且和这个最长公共后缀必然从根开始，不同于 KMP 的 border 。</p>
<p>大概AC自动机就这点知识吧？</p>
<h1 id="2-水题杀手"><a href="#2-水题杀手" class="headerlink" title="$2$ 水题杀手"></a>$2$ 水题杀手</h1><p>嗯，这个标题很炫酷。</p>
<h2 id="1-LG3808-【模板】AC自动机（简单版）"><a href="#1-LG3808-【模板】AC自动机（简单版）" class="headerlink" title="1 LG3808 【模板】AC自动机（简单版）"></a>1 LG3808 【模板】AC自动机（简单版）</h2><blockquote>
<p>给定 $n$ 个模式串和 $1$ 个文本串，求有多少个模式串在文本串里出现过。</p>
</blockquote>
<p>建 Trie 时记录一下每个串的 $endpos$ 就完了。</p>
<h2 id="2-LG3796-【模板】AC自动机（加强版）"><a href="#2-LG3796-【模板】AC自动机（加强版）" class="headerlink" title="2 LG3796 【模板】AC自动机（加强版）"></a>2 LG3796 【模板】AC自动机（加强版）</h2><blockquote>
<p>有 $\rm N$ 个由小写字母组成的模式串以及一个文本串 $\rm T$。</p>
<p>每个模式串可能会在文本串中出现多次。你需要找出<strong>哪些</strong>模式串在文本串 $\rm T$ 中出现的次数最多。</p>
</blockquote>
<p>嗯，这个其实是个弱化版本。考虑记录最暴力的解法大概就是每匹配到一个点，就不断向上跳 $fail$ 去找有哪些点打上了 $endpos$ 标记，每次匹配的时候不断向上跳，遇到 $endpos$ 就 $ ++$，最后再扫一遍。</p>
<p>当然其实这个地方存在一个剪枝。完全可以记录离现在这个点最近的一个有 $endpos$ 的 $fail$。推的方式跟推 $fail$ 大同小异。</p>
<p>大概可以把 $fail$ 理解为一阶失配指针，$last$ 为二阶的，所以理所应当在一阶上面跑。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">      <span class="keyword">if</span>(Trie[<span class="number">0</span>][i]) q.push(Trie[<span class="number">0</span>][i]) ; <span class="comment">//1 </span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!v(now)) Trie[now][i] = Trie[fail[now]][i] ;</span><br><span class="line">            <span class="keyword">else</span> fail[v(now)] = Trie[fail[now]][i], q.push(v(now)), </span><br><span class="line">            last[v(now)] = Send[fail[v(now)]] ? fail[v(now)] : last[fail[v(now)]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-LG5357-【模板】AC自动机（二次加强版）"><a href="#3-LG5357-【模板】AC自动机（二次加强版）" class="headerlink" title="3 LG5357 【模板】AC自动机（二次加强版）"></a>3 LG5357 【模板】AC自动机（二次加强版）</h2><blockquote>
<p>有 $\rm N$ 个由小写字母组成的模式串以及一个文本串 $\rm T$。</p>
<p>每个模式串可能会在文本串中出现多次。你需要找出<strong>哪些</strong>模式串在文本串 $\rm T$ 中出现的次数最多。</p>
</blockquote>
<p>en，好久之前rqy就有讲过这个问题。其实上面那题无论剪不剪枝，最坏复杂度都是 $O(n^2)$ 的，只要这么构造就可以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">........(省略)</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<p>于是考虑这东西似乎正着算不好算，于是考虑倒着计算贡献。发现原来是个 $dp$ 的过程。</p>
<p>大概就是，在AC自动机的fail树上，自己的孩子一定和自己有着相同后缀。所以只需要按照fail边建树，然后算一遍子树大小。之前需要记录对应位置，最后输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXD 60010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXP 201000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">char</span> In[MAXP], S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Hash&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAXN] ;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull ;</span><br><span class="line">    <span class="built_in">map</span> &lt;ull, <span class="keyword">int</span>&gt; htble ;</span><br><span class="line">    <span class="keyword">const</span> ull base = <span class="number">137</span> ;</span><br><span class="line">    <span class="function">ull <span class="title">get_h</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s) ;</span><br><span class="line">        ull ret = (s[<span class="number">0</span>] ^ <span class="number">32768</span>) + <span class="number">3</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">            ret = ret * base + (ull)s[i] ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Hash ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, next ;</span><br><span class="line">    &#125;E[MAXP &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt1, head[MAXP] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        E[++ cnt1].to = v, E[cnt1].next = head[u], head[u] = cnt1 ;</span><br><span class="line">        E[++ cnt1].to = u, E[cnt1].next = head[v], head[v] = cnt1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Graph ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt, e[MAXP], last[MAXP], ans ;</span><br><span class="line">    <span class="keyword">int</span> tr[MAXP][<span class="number">27</span>], res[MAXP], Id[MAXP], fail[MAXP] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Id, <span class="number">0</span>, <span class="keyword">sizeof</span>(Id)) ;</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail)) ;</span><br><span class="line">        <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="keyword">sizeof</span>(last)) ;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span>(tr)), cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = p[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!tr[rt][now]) </span><br><span class="line">              tr[rt][now] = ++ cnt ;</span><br><span class="line">            rt = tr[rt][now] ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ e[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idins</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = p[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!tr[rt][now]) </span><br><span class="line">              tr[rt][now] = ++ cnt ;</span><br><span class="line">            rt = tr[rt][now] ;</span><br><span class="line">        &#125;</span><br><span class="line">        e[rt] = ID, Id[ID] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz[MAXN] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">          <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]) ; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> qwq tr[now][i]</span></span><br><span class="line">            <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; q.size() &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!qwq) qwq = tr[fail[now]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[qwq] = tr[fail[now]][i], q.push(qwq) ;</span><br><span class="line">                <span class="keyword">if</span> (e[fail[qwq]]) last[qwq] = fail[qwq] ;</span><br><span class="line">                <span class="keyword">else</span> last[qwq] = last[fail[qwq]] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work1</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, ret = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p), q ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], q = rt ;</span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; (~e[q])) </span><br><span class="line">              ret += e[q], e[q] = <span class="number">-1</span>, q = fail[q] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work2</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, ret = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p), q ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], q = rt ;</span><br><span class="line">            <span class="keyword">while</span> (q) &#123; <span class="keyword">if</span> (e[q]) res[e[q]] ++ ; q = last[q] ; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work3</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], sz[rt] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) add(i, fail[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == v) <span class="keyword">continue</span> ;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AC ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ans ; <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) f[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In) ;</span><br><span class="line">        ull p = get_h(In) ;</span><br><span class="line">        <span class="keyword">if</span> (!htble.count(p))</span><br><span class="line">            idins(In, i), htble[p] = i ;</span><br><span class="line">        <span class="keyword">else</span> f[i] = htble[p] ;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs() ; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S) ; work3(S) ; dfs(<span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sz[Id[f[i]]]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唉，学了好几遍才真正学明白 $fail$ 指针是个什么东西，wtcl</p>
<p>btw，感觉AC自动机如果真要起名的话，叫后缀自动机也可以啊（</p>
<h1 id="4-例题"><a href="#4-例题" class="headerlink" title="$4$ 例题"></a>$4$ 例题</h1><h2 id="rm-POI2000-病毒"><a href="#rm-POI2000-病毒" class="headerlink" title="[$\rm POI2000$] 病毒"></a>[$\rm POI2000$] 病毒</h2><blockquote>
<p>给定一堆 $01$ 串，判断是否有一个无限长的 $01$ 串使得不包含任何一个给出 $01$ 串作为其子串。</p>
</blockquote>
<p> 考虑怎样才能算是无限长的安全代码。</p>
<p>先给出结论：对每个存在病毒代码的状态打上标记。那么如果<strong>完整</strong>的trie图里面存在一个不带标记的圈，就会有无限长的安全代码。此处完整指的是，对于给定一棵trie树，补全他的所有叶子。</p>
<p>可知这是显然的，因为本质上只需要考虑到深度=最长的病毒串长度这一步就ok了，剩下都可以循环生成。</p>
<p>注意到本质上 trie 不用显式地建出来，于是最后 $dfs$ 的时候统计一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXS], vis[MAXS], sz ;</span><br><span class="line">    <span class="keyword">int</span> _ed[MAXS], trans[MAXS][<span class="number">2</span>], ans[MAXS] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span> ; N = <span class="built_in">strlen</span>(t + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            t[i] -= <span class="string">'0'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trans[rt][t[i]])</span><br><span class="line">                trans[rt][t[i]] = ++ sz ;</span><br><span class="line">            rt = trans[rt][t[i]] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[rt] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, n ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            n = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[n][i])</span><br><span class="line">                    trans[n][i] = trans[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fail[trans[n][i]] = trans[fail[n]][i],</span><br><span class="line">                    _ed[trans[n][i]] |= _ed[fail[trans[n][i]]], q.push(trans[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[x])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"TAK"</span>), <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (_ed[x] || vis[x]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        vis[x] = ans[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="comment">//if (trans[x][i]) dfs(trans[x][i]) ;</span></span><br><span class="line">            dfs(trans[x][i]) ;</span><br><span class="line">        ans[x] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>), A.Ins(s) ;</span><br><span class="line">    A.build() ; A.dfs(<span class="number">0</span>) ; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到代码中 $dfs$ 里面注释的一行，显然是错的，可以被：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>这组数据直接给卡掉。但是数据太水就给过掉了…</p>
<p>…说实在的我本来想尝试去证明为什么那样错的写是对的，尝试努力去编出一个合理解释，到最后才发现是自己原来的 $code$ 错了QAQ</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】AC自动机泛做</title>
    <url>/2020/01/17/AC%E8%87%AA%E5%8A%A8%E6%9C%BA2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>几道AC自动机简单题qwq</p>
<p>以上是原标题。现在整理一遍发现除了第一道题都不太会了，所以题都挺好的QAQ</p>
<p><del>所以是不是间接证明了「好题」=「由于自己太菜而想不出来的题」啊，听上去好悲伤</del></p>
<a id="more"></a>
<h1 id="1-TJOI2013-单词"><a href="#1-TJOI2013-单词" class="headerlink" title="$1$ [TJOI2013]单词"></a>$1$ [TJOI2013]单词</h1><blockquote>
<p>小张最近在忙毕设，所以一直在读论文。</p>
<p>一篇论文是由许多单词组成。但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。</p>
</blockquote>
<p>发现怎么做都可以啦。当时自己似乎是记录了一下关键点(endpos)和每个点的经过次数，然后反向topsort就dp完了。</p>
<p>多攒攒经验，万一哪天就可以一眼秒了呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> rt = <span class="number">0</span>, c ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; s[k] ; ++ k)&#123;</span><br><span class="line">        c = s[k] - <span class="string">'a'</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!Trie[rt][c]) </span><br><span class="line">          Trie[rt][c] = ++ tot ; </span><br><span class="line">        rt = Trie[rt][c], ++ res[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[ID] = rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">      <span class="keyword">if</span>(Trie[<span class="number">0</span>][i]) q.push(Trie[<span class="number">0</span>][i]) ; </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; T[++ n] = now ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!v(now)) </span><br><span class="line">              Trie[now][i] = Trie[fail[now]][i] ;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">              fail[v(now)] = Trie[fail[now]][i], q.push(v(now)) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (i = n ; i &gt;= <span class="number">0</span> ; -- i) res[fail[T[i]]] += res[T[i]] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-USACO15FEB-Censoring-Gold"><a href="#2-USACO15FEB-Censoring-Gold" class="headerlink" title="$2$ [USACO15FEB]Censoring(Gold)"></a>$2$ [USACO15FEB]Censoring(Gold)</h1><blockquote>
<p>给出一个长串和一堆小串。每次从长串中找出最靠右的小串，删掉之后拼起来，继续删。求删到最后的串。</p>
<p>$\rm |S|\leq 10^6$</p>
</blockquote>
<p>第一眼不会做，我是弟弟QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *In)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span>, L = <span class="built_in">strlen</span>(In) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> now = In[i] - <span class="string">'a'</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!Trie[rt][now]) </span><br><span class="line">		    Trie[rt][now] = ++ cnt ;</span><br><span class="line">		rt = Trie[rt][now] ;<span class="comment">// 1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	Id[rt] = L ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span> ;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Ls ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> now = S[i] - <span class="string">'a'</span> ;</span><br><span class="line">		rt = Trie[rt][now], R[i] = rt, stk[++ top] = i ;</span><br><span class="line">		<span class="keyword">if</span> (Id[rt]) top -= Id[rt], rt = top ? R[stk[top]] : <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现似乎正解出奇的简洁…</p>
<p>然后发现原来「删除一个串再拼起来」这东西就直接顺着扫一遍弹栈就完了…</p>
<p>这题似乎挺考察基本功的吧…像我这种基本功不行的老年选手又被无情吊锤了QAQ</p>
<h1 id="3-NOI2011-阿狸的打字机"><a href="#3-NOI2011-阿狸的打字机" class="headerlink" title="$3$ [NOI2011]阿狸的打字机"></a>$3$ [NOI2011]阿狸的打字机</h1><blockquote>
<p>有一个打字机，支持三种操作：</p>
<ul>
<li>字符串末尾加一个小写字母</li>
<li>字符串末尾删一个字符</li>
<li>输出这个字符串</li>
</ul>
<p>经过不超过 $n$ 次操作后有 $m$ 组询问：$(x,y)$，表示询问第 $x$ 次输出第字符串在第 $y$ 次输出第字符串里出现几次</p>
<p>$1\leq n,m \leq 10^5$</p>
</blockquote>
<p>本来没做过这道题，但是一篇文章写两道题总觉得有点不爽，于是决定加一道。</p>
<p>于是就发现自己进了个天坑……本来觉得这题应该挺简单的说（通过题目名称猜的（（（</p>
<p>根据 ACAM 的性质，发现所有包含某个串 $\rm S$ 的集合 $O$ 就是 $\rm endpos(S)$ 在 $fail$ 树上的子树。所以每次可以看做查询 $\rm endpos(S_\mathit{x})$ 的 $fail$ 树子树中有多少个单词也在 $\rm S_\it{y}$ 里面。发现「也在 $\rm S_\it{y}$ 里面」这东西可以通过「$\rm endpos(S\mathit{_y})$ 在 Trie 上到根的路径」来表示，于是就直接拿个树状数组维护 $dfs$ 序就可以了。</p>
<p>然后以下是写这个题踩的坑：</p>
<ul>
<li>AC自动机由于求 fail 的时候要路径压缩，所以如果压完直接去 dfs 这个 Trie 的话会错，所以要事先复制一份（因为显然不路径压缩复杂度不对）。</li>
<li>不要忘了AC自动机有 0 号节点，所以 dfn 可能会比编号大 1，加上即可。</li>
<li>这题读入十分鬼畜，导致不能一个一个插入。发现删除就是跳 father ，加入就是走 root，所以也是考察了AC自动机的状态简并性吧。</li>
</ul>
<p>唉，我太菜了。中间由于思考不足导致走了一堆弯路。且一开始由于 TLE 还觉得是线段树太慢了又写了个 BIT…233</p>
<p>不管不管，这么难写的东西一定要代码全篇贴qwq！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Sigma = <span class="number">26</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> Id ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">char</span> T[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[SZ] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[SZ] ;</span><br><span class="line"><span class="keyword">int</span> dep[SZ] ;</span><br><span class="line"><span class="keyword">int</span> head[SZ] ;</span><br><span class="line"><span class="keyword">int</span> t[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> tag[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">bool</span> vis[SZ] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;pint&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L, rt ;</span><br><span class="line">    <span class="keyword">int</span> fa[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> id[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> sz, tot ;</span><br><span class="line">    <span class="keyword">int</span> _ed[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> _ED[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> fail[SZ] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> tr[SZ][Sigma] ;</span><br><span class="line">    <span class="keyword">int</span> trans[SZ][Sigma] ;</span><br><span class="line">    <span class="comment">/*void Insert(char *S, int len)&#123;</span></span><br><span class="line"><span class="comment">        L = len, rt = 0, ++ tot ;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; " ** " &lt;&lt; len &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= L ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">            //cout &lt;&lt; S[i] ;</span></span><br><span class="line"><span class="comment">            int o = S[i] - 'a' ;</span></span><br><span class="line"><span class="comment">            if (!trans[rt][o])</span></span><br><span class="line"><span class="comment">                trans[rt][o] = ++ sz ;</span></span><br><span class="line"><span class="comment">            rt = trans[rt][o] ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        _ed[rt] = tot ; _ED[tot] = rt ; //puts("") ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Workfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= sz ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Sigma ; ++ j)</span><br><span class="line">                tr[i][j] = trans[i][j] ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!tr[x][i]) tr[x][i] = tr[fail[x]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    dfn[x] = ++ Id ; sz[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        dep[to(k)] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        dfs(to(k)), sz[x] += sz[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void down(int x, int l, int r)&#123;</span></span><br><span class="line"><span class="comment">    if (tag[x])&#123;</span></span><br><span class="line"><span class="comment">        int lc = x &lt;&lt; 1 ;</span></span><br><span class="line"><span class="comment">        int rc = x &lt;&lt; 1 | 1 ;</span></span><br><span class="line"><span class="comment">        int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">        tag[lc] += tag[x] ;</span></span><br><span class="line"><span class="comment">        tag[rc] += tag[x] ;</span></span><br><span class="line"><span class="comment">        t[rc] += tag[x] * (r - mid) ;</span></span><br><span class="line"><span class="comment">        t[lc] += tag[x] * (mid - l + 1) ;</span></span><br><span class="line"><span class="comment">        tag[x] = 0 ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void update(int rt, int l, int r, int ul, int ur, int v)&#123;</span></span><br><span class="line"><span class="comment">    if (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span></span><br><span class="line"><span class="comment">        t[rt] += v * (r - l + 1) ;</span></span><br><span class="line"><span class="comment">        tag[rt] += v ; return void() ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ; down(rt, l, r) ;</span></span><br><span class="line"><span class="comment">    if (ul &lt;= mid) update(rt &lt;&lt; 1, l, mid, ul, ur, v) ;</span></span><br><span class="line"><span class="comment">    if (mid &lt; ur) update(rt &lt;&lt; 1 | 1, mid + 1, r, ul, ur, v) ;</span></span><br><span class="line"><span class="comment">    t[rt] = t[rt &lt;&lt; 1] + t[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">void update(int rt, int l, int r, int p, int v)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">    if (l == r)</span></span><br><span class="line"><span class="comment">        return t[rt] += v, void() ;</span></span><br><span class="line"><span class="comment">    if (p &lt;= mid)</span></span><br><span class="line"><span class="comment">        update(rt &lt;&lt; 1, l, mid, p, v) ;</span></span><br><span class="line"><span class="comment">    else update(rt &lt;&lt; 1 | 1, mid + 1, r, p, v) ;</span></span><br><span class="line"><span class="comment">    t[rt] = t[rt &lt;&lt; 1] + t[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int query(int rt, int l, int r, int ql, int qr)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, ret = 0 ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= l &amp;&amp; r &lt;= qr) return t[rt] ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= mid) ret += query(rt &lt;&lt; 1, l, mid, ql, qr) ;</span></span><br><span class="line"><span class="comment">    if (qr &gt; mid) ret += query(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr) ;</span></span><br><span class="line"><span class="comment">    return ret ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= A.sz ; p += low(p)) _bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p))</span><br><span class="line">        res += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; t[1] &lt;&lt; endl ;</span></span><br><span class="line">    mdf(dfn[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (A._ed[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> n, k = A._ed[x] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : qs[k])&#123;</span><br><span class="line">            n = A._ED[i.first] ;</span><br><span class="line">            ans[i.second] = ask(dfn[n] + sz[n] - <span class="number">1</span>) ;</span><br><span class="line">            ans[i.second] -= ask(dfn[n] - <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (A.trans[x][i]) do_do(A.trans[x][i]) ;</span><br><span class="line">    mdf(dfn[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y, rt ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ;</span><br><span class="line">    y = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; A.sz = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= y ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        if (S[i] == 'B') x -- ;</span></span><br><span class="line"><span class="comment">        else if (S[i] == 'P') A.Insert(T, x) ;</span></span><br><span class="line"><span class="comment">        else T[++ x] = S[i] ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    rt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= y ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'B'</span>) rt = A.fa[rt] ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'P'</span>)</span><br><span class="line">            A._ed[rt] = ++ A.tot, A._ED[A.tot] = rt ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> o = S[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!A.trans[rt][o]) A.trans[rt][o] = ++ A.sz ;</span><br><span class="line">            A.fa[A.trans[rt][o]] = rt, rt = A.trans[rt][o] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; A.sz &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= A.sz ; ++ i, puts(""))</span></span><br><span class="line"><span class="comment">        for (int j = 0 ; j &lt;= 2 ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; A.trans[i][j] &lt;&lt; " " ;*/</span></span><br><span class="line">    A.Workfail() ;</span><br><span class="line"><span class="comment">/*    for (int i = 1 ; i &lt;= A.sz ; ++ i, puts(""))</span></span><br><span class="line"><span class="comment">        for (int j = 0 ; j &lt;= 2 ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; A.trans[i][j] &lt;&lt; " " ;*/</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; A.tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.sz ; ++ i)</span><br><span class="line">        add(A.fail[i], i) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= 3 ; ++ i) cout &lt;&lt; dep[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; A.fail[9] &lt;&lt; endl ;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= A.tot ; ++ i) cout &lt;&lt; A._ED[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= A.sz ; ++ i) cout &lt;&lt; A.fail[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= A.sz ; ++ i) cout &lt;&lt; sz[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= m ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        scanf("%d%d", &amp;x, &amp;y) ;</span></span><br><span class="line"><span class="comment">        x = A._ed[x], y = A._ed[y] ;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        if (dfn[y] &gt;= dfn[x] &amp;&amp; dfn[y] &lt;= dfn[x] + sz[x] - 1)</span></span><br><span class="line"><span class="comment">            printf("%d\n", dep[y] - dep[x] + 1) ; else puts("0") ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y),</span><br><span class="line">        qs[y].push_back(make_pair(x, i)) ;</span><br><span class="line">    do_do(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/AC自动机</tag>
        <tag>字符串/失配树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】整体二分泛做</title>
    <url>/2020/01/17/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说是泛做其实就是多做了三道题？</p>
<p>博文内容的水分日渐增多.jpeg</p>
<a id="more"></a>
<h1 id="1-LG1527-国家集训队-矩阵乘法"><a href="#1-LG1527-国家集训队-矩阵乘法" class="headerlink" title="$1$ LG1527 [国家集训队]矩阵乘法"></a>$1$ LG1527 [国家集训队]矩阵乘法</h1><blockquote>
<p>给你一个 $N\times N$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $K$ 小数。</p>
</blockquote>
<p>把BIT换成二维的就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, l, r, z ;</span><br><span class="line">&#125;q[MAXM], lq[MAXM], rq[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> ans[MAXQ], _bit[MAXN][MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = p ; i &lt;= N ; i += low(i))</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = q ; j &lt;= N ; j += low(j))</span><br><span class="line">            _bit[i][j] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = p ; i ; i -= low(i))</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = q ; j ; j -= low(j))</span><br><span class="line">            ret += _bit[i][j] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rg <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].z &lt;= vmid)</span><br><span class="line">                upd(q[i].x, q[i].y, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res = ask(q[i].l, q[i].r) ;</span><br><span class="line">            res -= ask(q[i].x - <span class="number">1</span>, q[i].r) ;</span><br><span class="line">            res -= ask(q[i].l, q[i].y - <span class="number">1</span>) ;</span><br><span class="line">            res += ask(q[i].x - <span class="number">1</span>, q[i].y - <span class="number">1</span>) ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op &amp;&amp; q[i].z &lt;= vmid)</span><br><span class="line">            upd(q[i].x, q[i].y, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">int</span> n, x, y, l, r, k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            q[++ cnt].op = <span class="number">0</span>, q[cnt].x = i,</span><br><span class="line">            q[cnt].y = j, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[cnt].z) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        ++ cnt, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[cnt].x, &amp;q[cnt].y) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q[cnt].l, &amp;q[cnt].r, &amp;q[cnt].z), q[cnt].op = i ;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; q[i].x &lt;&lt; " " &lt;&lt; q[i].y &lt;&lt; " " &lt;&lt; q[i].l &lt;&lt; " " &lt;&lt; q[i].r &lt;&lt; " " &lt;&lt; q[i].z &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    solve(<span class="number">0</span>, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-LG4175-CTSC2008-网络管理"><a href="#2-LG4175-CTSC2008-网络管理" class="headerlink" title="$2$ LG4175 [CTSC2008]网络管理"></a>$2$ LG4175 [CTSC2008]网络管理</h1><blockquote>
<p>给定一棵树，每次或者修改一个点的点权，或者查询两点之间的第 $k$ 大点权。</p>
</blockquote>
<p>这东西是真的丧心病狂嗷233</p>
<p>发现写个树剖就变成傻题了。最终 $\log ^3$ 能过 $10^5$ 可能是医学奇迹叭。</p>
<p>贴个代码记录一下此时美好心情（毕竟写的很长.jpg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">100000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> o[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Mary&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, next ;</span><br><span class="line">    &#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line">    <span class="keyword">int</span> Id[MAXN], dfn[MAXN], top[MAXN], tot ;</span><br><span class="line">    <span class="keyword">int</span> dep[MAXN], sz[MAXN], faa[MAXN], son[MAXN] ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line">        to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">        to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        faa[u] = fa ;</span><br><span class="line">        sz[u] = <span class="number">1</span>, dep[u] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> _top)</span></span>&#123;</span><br><span class="line">        top[u] = _top, dfn[u] = ++ tot ;</span><br><span class="line">        <span class="keyword">if</span> (son[u]) dfs(son[u], u, _top) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> uv)</span></span>&#123;</span><br><span class="line">        rg <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> s[rt] += uv, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, uv) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, uv) ;</span><br><span class="line">        s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">        rg <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; rg <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v) ;</span><br><span class="line">            ret += query(<span class="number">1</span>, <span class="number">1</span>, N, dfn[top[u]], dfn[u]), u = faa[top[u]] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] &gt; dfn[v]) swap(u, v) ;</span><br><span class="line">        ret += query(<span class="number">1</span>, <span class="number">1</span>, N, dfn[u], dfn[v]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Mary ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rg <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">-1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rg <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">            res = Query(q[i].x, q[i].y) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span> &amp;&amp; q[i].y &gt; vmid)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span> &amp;&amp; q[i].y &gt; vmid)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, k, u, v ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, Mary :: add(u, v) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    Mary :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    Mary :: dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        q[++ cnt].y = base[i],</span><br><span class="line">        q[cnt].x = i, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r,</span><br><span class="line">            q[++ cnt].op = i, o[i] = <span class="number">1</span>,</span><br><span class="line">            q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r ;</span><br><span class="line">            q[++ cnt].y = base[l],</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-2</span> ;</span><br><span class="line">            q[++ cnt].y = (base[l] = r),</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    solve(<span class="number">0</span>, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!o[i]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!ans[i])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid request!"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-POI2011-Meteors"><a href="#3-POI2011-Meteors" class="headerlink" title="$3$ [POI2011] Meteors"></a>$3$ [POI2011] Meteors</h1><blockquote>
<p>给定一个环，每个节点有一个所属国家，$k$ 次事件，每次对 $[l,r]$ 区间上的每个点点权加上一个值，求每个国家最早多少次操作之后所有点的点权和能达到一个值。</p>
</blockquote>
<p>据蒋神说有 $1\log$ 的写法，然而并不想去学，等抽个空补上吧（</p>
<p>还是整体二分，二分时间。怎么说呢，这道题比之前做的题要灵活一点。考虑二分时间本质上就是在二分操作，所以只需要执行 $[vl,vmid]$ 内的操作就可以了。发现这样需要分治的是国家，查询的话拿一个vector+BIT差分维护一下即可。</p>
<p>感觉…就是还欠火候。明明每一部分都了解得一清二楚，明明每一部分都知道该怎么写，但是却串接不起来…wtcl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">191981000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; _be[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">met</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v, id ;</span><br><span class="line">&#125;q[N] ; <span class="keyword">int</span> t[N], lt[N], rt[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k, s[N], b[N], _bit[N &lt;&lt; <span class="number">1</span>], ans[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= <span class="number">2</span> * m ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ; <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; _be[p].size() ; ++ i)&#123;</span><br><span class="line">        ret += ask(_be[p][i]) + ask(_be[p][i] + m) ;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= s[p]) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            ans[t[i]] = vl ; <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vr + vl) &gt;&gt; <span class="number">1</span>, fl = <span class="number">0</span>, fr = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vl ; i &lt;= vmid ; ++ i)</span><br><span class="line">        upd(q[i].l, q[i].v), upd(q[i].r + <span class="number">1</span>, -q[i].v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = query(t[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= s[t[i]]) lt[++ fl] = t[i] ;</span><br><span class="line">        <span class="keyword">else</span> s[t[i]] -= res, rt[++ fr] = t[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vl ; i &lt;= vmid ; ++ i)</span><br><span class="line">        upd(q[i].l, -q[i].v), upd(q[i].r + <span class="number">1</span>, q[i].v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= fl ; ++ i) t[i + l - <span class="number">1</span>] = lt[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= fr ; ++ i) t[i + l + fl - <span class="number">1</span>] = rt[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + fl - <span class="number">1</span>) ; solve(vmid + <span class="number">1</span>, vr, l + fl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]), _be[b[i]].pb(i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) t[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;s[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].v),</span><br><span class="line">        q[i].r += (q[i].l &gt; q[i].r) ? m : <span class="number">0</span>, q[i].id = i ;</span><br><span class="line">    q[++ k].l = <span class="number">1</span>, q[k].r = <span class="number">2</span> * m, q[k].id = k, q[k].v = Inf ;</span><br><span class="line">    solve(<span class="number">1</span>, k, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == k) <span class="built_in">puts</span>(<span class="string">"NIE"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数据结构/线段树</tag>
        <tag>离线算法/整体二分</tag>
        <tag>数据结构/数据结构方法/轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】整体二分</title>
    <url>/2020/01/16/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哇，一直想学整体二分诶，终于学会了233</p>
<p>十分感谢李煜东的蓝书！感觉从网上找讲解，一直看不明白呢…</p>
<a id="more"></a> 
<p>整体二分，其实本质上跟线段树上二分、splay上二分很相似。是对值域的整体分治。</p>
<p>首先考虑一个简单的问题，如何求解整个序列的第 $k$ 大。有这么一种二分的方法。最开始取一个 $L=1$，一个 $R=\rm MAX$。如果当前 $L\sim mid$ 的数字个数不足 $k$ 个，那么令 $k$ 减去这些数量，并将 $mid+1$ 作为新的 $L$ 继续二分。可以证明这样做也是 $\log$ 的。</p>
<p>为什么要说这种方法？本质上，求出整个序列的第 $k$ 大二分方法有很多，比如你可以直接二分答案。但实际上，只有上述二分方式具有较强的<strong>可分治性</strong>，每次可以直接舍弃掉 $[L,mid]$ 的全部内容，每次问题规模都小一半；但显然直接去二分第 $k$ 大不具备这个性质。</p>
<p>所以从这个例子中，或许可以得出一些启发性的分治方式。</p>
<h1 id="rm-Part1-简述整体二分"><a href="#rm-Part1-简述整体二分" class="headerlink" title="$\rm Part1$ 简述整体二分"></a>$\rm Part1$ 简述整体二分</h1><p>考虑现在给定一个序列有 $n$ 个数，$m$ 组询问。每次询问一个区间的第 $k$ 小的数。 可以离线</p>
<p>考虑首先离散化，并且把序列中一开始给出的数当作插入操作。然后：</p>
<ul>
<li>1、每次二分，在把答案分治掉的同时，需要对整个序列的元素也分治。所以需要对整个序列进行重排，很简单地 $double-l$ 扫一遍再合并就可以了。</li>
<li>2、考虑采用上方说的方法去处理插入和询问。对于一个插入操作，如果插入的数值 $&lt;$ 当前二分的值域的 $mid$，那么就直接插入BIT并且放到前一半，否则放到后一半不管；对于一个询问，可以用树状数组求出现在区间 $[ql,  qr]$ 内有多少被插入过的数——根据上文讨论得到的解法，考虑如果 $qk$ 比当前值大，说明之前还有比当前值域的 $mid$ 大的数没有被插入，所以把当前的询问减去当前的 $res$ 后放到后一半；否则什么都不处理，放到前一半。</li>
<li>3、考虑这么做的正确性。发现插入操作一定在询问操作之前，所以不需要担心询问扑空；同时发现对于一个单独的询问，实际上就是进行了上文中类似全局二分的操作。</li>
<li>4、每次用完BIT要清零。</li>
<li>5、s发现每次值域规模、元素规模均减半。于是最后复杂度就是 $O(m\log^2 n)$。而如果一开始不离散化，复杂度就会变成 $O(m\log \mathrm{SIZE}\log n)$ 。值得注意的是，不离散化也根本不需要担心空间会挂，因为在分治整个值域的时候，把值域作为分治轴可以使得只用下标就可以计算出贡献。</li>
</ul>
<p>然后以下是 <code>LG3834【模板】可持久化线段树1 (主席树)</code>，裸的区间 $k$ 小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 400010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> ans[MAXN], _bit[MAXN], t[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= N ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res = ask(q[i].y) - ask(q[i].x - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; bl &lt;&lt; " " &lt;&lt; br &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">int</span> n, val, l, r, k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + N + <span class="number">1</span>) ;</span><br><span class="line">    n = unique(t + <span class="number">1</span>, t + N + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; t[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        val = lower_bound(t + <span class="number">1</span>, t + n + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">        ++ cnt, q[cnt].op = <span class="number">0</span>, q[cnt].x = i, q[cnt].y = val ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; q[cnt].y &lt;&lt; endl ; </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k), ++ cnt ;</span><br><span class="line">        q[cnt].op = i, q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">0</span>, N * <span class="number">2</span>, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="comment">// for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; ans[i] &lt;&lt; endl ;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[ ans[i] ]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Part2-如何处理简单带修"><a href="#rm-Part2-如何处理简单带修" class="headerlink" title="$\rm Part2$ 如何处理简单带修"></a>$\rm Part2$ 如何处理简单带修</h1><p>发现其实每个带修操作都是单点覆盖的话，可以拆成一个插入一个删除，而删除操作是BIT可维护的。</p>
<p>以下是 <code>bzoj#1901 Dynamic Rankings</code> ，裸的区间 $k$ 小+单点替换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], _bit[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= N ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">-1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res ;</span><br><span class="line">            res = ask(q[i].y) - ask(q[i].x - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span> &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span> &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, k ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        q[++ cnt].y = base[i],</span><br><span class="line">        q[cnt].x = i, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (c + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">1</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k, q[++ cnt].op = i,</span><br><span class="line">            q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; k ;</span><br><span class="line">            q[++ cnt].y = base[l],</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-2</span> ;</span><br><span class="line">            q[++ cnt].y = (base[l] = k),</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(-Inf, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Part3-一道拓展"><a href="#rm-Part3-一道拓展" class="headerlink" title="$\rm Part3$ 一道拓展"></a>$\rm Part3$ 一道拓展</h1><blockquote>
<p>你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。<br>这些集合初始都是空集，有 $m$ 个操作：</p>
<p><code>1 l r c</code>：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中<br><code>2 l r c</code>： 表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。</p>
</blockquote>
<p>发现这东西本质上就是把单点插入变成了区间插入，所以拿线段树维护一下区间和即可。并且由于查询 $K$ 大，原来的二分方式需要对称一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y ; LL z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line">LL s[MAXN &lt;&lt; <span class="number">2</span>], cov[MAXN &lt;&lt; <span class="number">2</span>], tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123; s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ; &#125;</span><br><span class="line">il <span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (cov[rt])&#123;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span>] = s[rt &lt;&lt; <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        cov[rt &lt;&lt; <span class="number">1</span>] = cov[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">1</span>, cov[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span>] += tag[rt] ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[rt] ;</span><br><span class="line">        s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += <span class="number">1l</span>l * (r - mid) * tag[rt] ;</span><br><span class="line">        s[rt &lt;&lt; <span class="number">1</span>] += <span class="number">1l</span>l * (mid - l + <span class="number">1</span>) * tag[rt] ;</span><br><span class="line">        tag[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> tag[rt] += v,</span><br><span class="line">               s[rt] += v * (r - l + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    cov[<span class="number">1</span>] = <span class="number">1</span>, tag[<span class="number">1</span>] = s[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].z &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, q[i].x, q[i].y, <span class="number">1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            LL res ;</span><br><span class="line">            res = query(<span class="number">1</span>, <span class="number">1</span>, N, q[i].x, q[i].y) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL op, l, r, k ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].op &gt;&gt; q[i].x &gt;&gt; q[i].y &gt;&gt; q[i].z ;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) q[i].op = <span class="number">0</span> ; <span class="keyword">else</span> q[i].op = ++ cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(-N, N, <span class="number">1</span>, M) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>数据结构/树状数组</tag>
        <tag>离线算法/整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj#4044 [CERC2014]Virus Synthesis</title>
    <url>/2020/01/16/CERC2014-Virus-synthesis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>初始有一个空串，利用下面的操作构造给定串 $\rm S$ 。</p>
<p>1、串开头或末尾加一个字符</p>
<p>2、串开头或末尾加一个该串的逆串</p>
<p>求最小化操作数， $\rm |S| \leq 10^5$。</p>
</blockquote>
<p>dp是不可能会的，这辈子都不会了QAQ</p>
<a id="more"></a>
<p>首先预处理处上一篇 $blog$ 里的 $fail$ 和 $fail’$。</p>
<p>然后开始<del>不会</del>dp。发现对于PAM里每个状态 $x$，都可以由 $fail’(x)$ 推出。原因是 $fail’(x)$ 作为半失配指针（名字自己起的233），正好满足复制一遍的需求。于是考虑转移：</p>
<script type="math/tex; mode=display">
f_u=\min(f_{pre_u}+1,f_{fail'(u)}+(\frac{len_u}{2} - len_{fail'(u)}+1))</script><p>前半部分由于我们可以把加一个字符放到前面去执行，所以可以 $+1$ 而不用 $+2$ 。 后半部分由于半失配指针的最优性可以直接转移。</p>
<p>这样就做完了，考虑最后一定是一个长回文串加上一堆下脚料（原因是题目要求不能多串一起生成，只能维护一个回文串，所以不能把两个回文串拼起来之类的）。所以维护答案也很好维护。</p>
<p>按秩转移的话，bfs一遍就完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="keyword">int</span> N, C, ans, dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">300</span>], vis[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> rt0, rt1, sz, last, f[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trans[MAXN][<span class="number">4</span>], fail[MAXN], len[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sz = <span class="number">-1</span> ;</span><br><span class="line">        val[<span class="string">'A'</span>] = <span class="number">0</span>, val[<span class="string">'C'</span>] = <span class="number">1</span>,</span><br><span class="line">        val[<span class="string">'G'</span>] = <span class="number">2</span>, val[<span class="string">'T'</span>] = <span class="number">3</span> ;</span><br><span class="line">        rt0 = ++ sz, rt1 = ++ sz ;</span><br><span class="line">        len[rt0] = <span class="number">0</span>, len[rt1] = <span class="number">-1</span> ;</span><br><span class="line">        fail[last = rt0] = fail[rt1] = rt1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, np, nq ;</span><br><span class="line">        <span class="keyword">while</span> (S[pos] != S[pos - len[p] - <span class="number">1</span>]) p = fail[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!trans[p][x])&#123;</span><br><span class="line">            np = ++ sz, q = fail[p] ;</span><br><span class="line">            <span class="keyword">while</span> (S[pos] != S[pos - len[q] - <span class="number">1</span>]) q = fail[q] ;</span><br><span class="line">            len[np] = len[p] + <span class="number">2</span>, fail[np] = trans[q][x], trans[p][x] = np ;</span><br><span class="line">            nq = f[p] ; <span class="keyword">if</span> (len[np] &lt;= <span class="number">2</span>) f[np] = fail[np] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br><span class="line">                nq = fail[nq] ; f[np] = trans[nq][x] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = trans[p][x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>, ans = N, q.push(<span class="number">0</span>), vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[x][i]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> y = trans[x][i] ; dp[y] = dp[x] + <span class="number">1</span> ;</span><br><span class="line">                dp[y] = min(dp[y], dp[f[y]] + len[y] / <span class="number">2</span> - len[f[y]] + <span class="number">1</span>) ;</span><br><span class="line">                ans = min(ans, dp[y] + N - len[y]) ; <span class="keyword">if</span> (!vis[y]) q.push(y), vis[y] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= sz ; ++ i) vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C ;</span><br><span class="line">    <span class="keyword">while</span> (C --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>),</span><br><span class="line">        N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), T.Init() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            T.Ins(T.val[(<span class="keyword">int</span>)S[i]], i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= T.sz ; ++ i) dp[i] = T.len[i] ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; T.sz &lt;&lt; endl ;</span></span><br><span class="line">        T.bfs() ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= T.sz ; ++ i) </span><br><span class="line">          <span class="built_in">memset</span>(T.trans[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(T.trans[i])) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dpdpdpdpdpdpdpdpdpdp不会不会不会不会好烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦啊QAQ</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/回文自动机,PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2579[SHOI2011]双倍回文</title>
    <url>/2020/01/16/SHOI2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道PAM思维题…</p>
<p>像我这种只会写板子、莫得脑子的选手注定要挨打啊/kk</p>
<p>题面简述：</p>
<blockquote>
<p>给定一个串 $\rm S$，求该串最长的「双倍回文子串」。「双倍回文」指的是这么一种子串：自身回文，且前半部分、后半部分均回文。</p>
<p>$\rm |S|\leq 10^6$</p>
</blockquote>
<a id="more"></a>
<p>考虑PAM。但发现似乎不是很好做，因为每次转移是像串的两端各加一个字符，有点gg。但是仔细思考就会发现，PAM的 $fail$ 实际指向的是最长的回文后缀，而我们的所求也是这么一个回文后缀的形式，只不过限制了长度。</p>
<p>所以考虑求PAM的时候顺便维护另一个 $fail’$，其意义是「不超过当前串长一半的回文后缀」。</p>
<p>思考原来PAM的构造方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">int</span> u = p.last ; </span><br><span class="line">	<span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line">	<span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line">		<span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line">		<span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">		p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">		p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn ;</span><br><span class="line">	&#125;</span><br><span class="line">	p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以类推出新的构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, np, nq ;</span><br><span class="line">        <span class="keyword">while</span> (S[pos] != S[pos - len[p] - <span class="number">1</span>]) p = fail[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!trans[p][x])&#123;</span><br><span class="line">            np = ++ sz, q = fail[p] ;</span><br><span class="line">            <span class="keyword">while</span> (S[pos] != S[pos - len[q] - <span class="number">1</span>]) q = fail[q] ;</span><br><span class="line">            len[np] = len[p] + <span class="number">2</span>, fail[np] = trans[q][x], trans[p][x] = np ;</span><br><span class="line">            nq = f[p] ; <span class="keyword">if</span> (len[np] &lt;= <span class="number">2</span>) f[np] = fail[np] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br><span class="line">                nq = fail[nq] ; f[np] = trans[nq][x] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = trans[p][x] ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这东西唯一的不同就是多了一个找 $fail’$ 的过程。首先如果当前的 $\rm len\leq 2$ 那么就应该是 $fail$（毕竟都是1个字母）  ，否则就向上跳着找。</p>
<p>复杂度证明：因跳跳 $fail$ 的复杂度是对的所以跳 $fail’$ 也是对的（雾</p>
<p>值得注意的是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这一句里第二个判断很容易写错。因为实际上我们跳的 $fail$ 是未扩展之前的，这一点从 <code>S[pos] != S[pos - len[nq] - 1]</code> 这一句就可以明显地看出来。所以如果要比较的话，应该 $+2$ 之后再比较。</p>
<p>于是为了水字数贴个代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; (S + <span class="number">1</span>) ; P.Init() ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Ins(S[i] - <span class="string">'a'</span> + <span class="number">1</span>, i) ;</span><br><span class="line"><span class="comment">//    for (i = 1 ; i &lt;= P.sz ; ++ i) cout &lt;&lt; P.len[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= P.sz ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (P.len[i] == (P.len[P.f[i]] &lt;&lt; <span class="number">1</span>) &amp;&amp; (P.len[i] % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">            ans = max(ans, P.len[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实本质上也不算一道难题，对吧？</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习/出题笔记】失配树瞎吹</title>
    <url>/2020/01/16/%E5%A4%B1%E9%85%8D%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原因是做 <code>[POI2005]SZA-Template</code> 这题时新学了fail树，觉得很神的亚子233.</p>
<p>其实本质上就是对于每个前缀 $i$ ，向 $\mathrm{fail}_i$ 连一条边，可以知道这样连出来的一定是一棵 $root$ 为 $0$ 的树。</p>
<a id="more"></a>
<h1 id="1-LG5829-【模板】失配树"><a href="#1-LG5829-【模板】失配树" class="headerlink" title="$1$ LG5829 【模板】失配树"></a>$1$ LG5829 【模板】失配树</h1><p>当当当当！是我出的题啦~</p>
<blockquote>
<p>给定一个字符串 $s$，定义它的 <strong>$k$ 前缀</strong> $pre_k$ 为字符串 $s_{1\dots k}$，<strong>$k$ 后缀</strong> $suf_k$ 为字符串 $s_{|s|-k+1\dots |s|}$，其中 $1 \le k \le |s|$。</p>
<p>定义 $\boldsymbol{Border}(s)$ 为<strong>对于 $i \in [1, |s|)$，满足 $pre_i = suf_i$</strong> 的字符串 $pre_i$ 的集合。$\boldsymbol{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\operatorname{border}$。</p>
<p>有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 <strong>$\boldsymbol{p}$ 前缀</strong> 和 <strong>$\boldsymbol{q}$ 前缀</strong> 的 <strong>最长公共 $\operatorname{border}$</strong>  的长度。</p>
</blockquote>
<p>发现其实，怎么说呢，从根到某个点的路上的所有点，一定都是它的 $border$。所以就变成了 $lca$ 傻题。然而因为 $border$ 定义的时候不包含整个串，于是再判一下一个是不是另一个 $border$ 即可。</p>
<p>咋说呢，「判断一个点在不在另一个点的子树中」，接到这个问题我居然愣了几秒才想起用 $dfs$ 序搞，wtcl。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> freopen(a, b, c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1000000</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == end) &#123;</span><br><span class="line">      end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="keyword">if</span> (front == end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(front++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = IPT::GetChar(), lst = <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">while</span> ((ch &gt; <span class="string">'9'</span>) || (ch &lt; <span class="string">'0'</span>)) lst = ch, ch=IPT::GetChar();</span><br><span class="line">  <span class="keyword">while</span> ((ch &gt;= <span class="string">'0'</span>) &amp;&amp; (ch &lt;= <span class="string">'9'</span>)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = IPT::GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">120</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft, <span class="keyword">const</span> <span class="keyword">bool</span> pt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>);&#125;</span><br><span class="line">  <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;OPT::buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>);&#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(OPT::buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (pt) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadStr</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> beg = p;</span><br><span class="line">  <span class="keyword">do</span> *(++p) = IPT::GetChar(); <span class="keyword">while</span> ((*p &gt;= <span class="string">'a'</span>) &amp;&amp; (*p &lt;= <span class="string">'z'</span>));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> fa[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dfn[MAXN], son[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> H, N, M, dep[MAXN], fail[MAXN], sz[MAXN], top[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, dfn[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// qw(u, '\n', true), qw(v, '\n', true) ;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span> ;</span><br><span class="line">    N = ReadStr(S), qr(M) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; S[j + <span class="number">1</span>] != S[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (S[j + <span class="number">1</span>] == S[i]) fail[i] = ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">    dfs(<span class="number">0</span>) ; dfs2(<span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">int</span> p, q ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        p = <span class="number">0</span>, q = <span class="number">0</span>, qr(p), qr(q) ;</span><br><span class="line">        <span class="keyword">int</span> ans = lca(p, q) ;</span><br><span class="line">        <span class="keyword">if</span> (dep[p] &gt; dep[q]) swap(p, q) ;</span><br><span class="line">        <span class="keyword">if</span> (dfn[q] &gt;= dfn[p] &amp;&amp; dfn[q] &lt;= dfn[p] + sz[p] - <span class="number">1</span>) ans = fa[ans] ;</span><br><span class="line">        qw(ans, <span class="string">'\n'</span>, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长长的 <code>Read</code> 是嫖的zay的233，放到这里算是纪念一下他帮我验题吧！</p>
<h1 id="2-NOI2014-动物园"><a href="#2-NOI2014-动物园" class="headerlink" title="$2$ [NOI2014] 动物园"></a>$2$ [NOI2014] 动物园</h1><blockquote>
<p>定义 $num[i]$ 为字符串 $S$ 的前缀 $S[1\sim i]$ 中不重叠的相同前后缀的个数。给定 $S$，求所有 $(num[i]+1)$ 的乘积。$L\leq 10^6$</p>
</blockquote>
<p>发现其实就是 $fail$ 树上，这个点到根的路径上所有 $\leq \frac{L_{now}}{2}$ 的点的编号和。</p>
<p>这东西，那不是随便做？你可以随便上莫队，但是显然过不去；你可以直接剖，可能也不太过得去…不过发现，既然维护一个点到根的信息，那可以直接用栈维护链+dfs=稳得很。所以一眼肯定是二分，不过需要带个 $\log$。</p>
<p>这个地方有一个很nb的trick，可以做到 $O(n)$。根据「二分有可能可以two-pointers」的经典理论，发现随着深度递增，栈内可行的点不降。于是用栈去更新子树信息即可。复杂度 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    (ans *= <span class="number">1l</span>l * (res + <span class="number">1</span>)) %= Mod ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x], r ; k ; k = next(k))&#123;</span><br><span class="line">        stk[++ tp] = to(k), r = res ;</span><br><span class="line">        <span class="keyword">while</span> (stk[res + <span class="number">1</span>] * <span class="number">2</span> &lt;= to(k)) ++ res ;</span><br><span class="line">        dfs(to(k)) ; stk[tp --] = <span class="number">0</span>, res = r ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail)) ;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; S[j + <span class="number">1</span>] != S[i]) j = fail[j] ;</span><br><span class="line">            <span class="keyword">if</span> (S[j + <span class="number">1</span>] == S[i]) fail[i] = ++ j ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">        ans = <span class="number">1</span>, res = <span class="number">0</span>, dfs(<span class="number">0</span>) ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-POI2005-SZA-Template"><a href="#3-POI2005-SZA-Template" class="headerlink" title="$3$ [POI2005] SZA-Template"></a>$3$ [POI2005] SZA-Template</h1><blockquote>
<p>给定一个串，求一个最小的长度，使得该长度的前缀可以通过循环覆盖覆盖整个串。同一个位置的字符可以覆盖多次。比如 <code>ababa</code> 就可以被 <code>aba</code> 覆盖掉。</p>
<p>$L\leq 10^6$</p>
</blockquote>
<p>很神的一道题233</p>
<p>考虑先建出 $fail$ 树来，那么可能成为答案的一定是 $0\sim n$ 这一条链上的点，于是打标记。同时考虑，对于一个 $border$ ，只有两个 $border$ 结尾字符的距离 $\leq$ 该 $border$ 的长度才有可能被算入答案。</p>
<p>考虑怎么维护这个东西，发现对于一段前缀 $[1….i]$，他的所有终点都在他的子树中。于是只需要知道，子树中相邻的点，编号差的最大值，就可以判断是否合法。发现这东西可以直接求前驱和后继，据说有一种暴力可以拿平衡树去维护，然而不是很懂.jpg</p>
<p>考虑从上到下遍历这棵树，那么不断删除不在路径上的子树，更新答案即可。</p>
<p>思考了半天，一直觉得这个算法看不太透。但似乎稍微手玩/思考一下，也没啥大问题。。</p>
<hr>
<p>嗯，出去吃了个晚饭，编了个自认为很合理的解释：考虑对于一个前缀 $i$，在 $0\sim n$ 的路径上，会对它的判定造成影响的只会是那些包含他但不把他作为 $border$ 的更长的前缀。那么考虑，如果一个前缀不以 $i$ 为 $border$，那么也一定不以 $i+k~(k&gt;0)$ 做 $border$。所以对于一个 $i$ 而言，只需要考虑比他小的 $border$ 产生的贡献，这也正是从根到它的路径上，除去 $0\sim n$ 链之外的所有子树。于是删掉即可。复杂度 $O(\rm |S|)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="keyword">int</span> N, fail[MAXN], ans ;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], nxt[MAXN], onw[MAXN], val = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//  cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    pre[nxt[x]] = pre[x] ;</span><br><span class="line">    nxt[pre[x]] = nxt[x] ;</span><br><span class="line">    val = max(val, nxt[x] - pre[x]),</span><br><span class="line">    pre[x] = nxt[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) del(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= u) </span><br><span class="line">      <span class="keyword">return</span> ans = u, <span class="keyword">void</span>() ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">int</span> xyg ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) </span><br><span class="line">      <span class="keyword">if</span> (onw[to(k)]) xyg = to(k) ; <span class="keyword">else</span> del(to(k)) ;</span><br><span class="line">    dfs(xyg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), ans = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; In[j + <span class="number">1</span>] != In[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (In[j + <span class="number">1</span>] == In[i]) fail[i] = ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i ; i = fail[i]) onw[i] = <span class="number">1</span> ; </span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>失配树</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>字符串/fail树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SAM瞎做 · 公共子串相关</title>
    <url>/2020/01/16/SAM3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了水blog，决定单拿出来再整理一篇233</p>
<p>严格来讲，这东西似乎应该算在广义SAM的范畴？</p>
<a id="more"></a>
<h1 id="1-SP1811-LCS"><a href="#1-SP1811-LCS" class="headerlink" title="$1$ SP1811 LCS"></a>$1$ SP1811 LCS</h1><blockquote>
<p>输入 $2$ 个长度不大于 $250000$ 的字符串，输出这 $2$ 个字符串的最长公共子串。</p>
</blockquote>
<p>考虑对连个串都建SAM，方法是插入一个串后随便插入一个 $\not\in \Sigma$ 的字符间隔开，这样，从本质上就把第二个串的后缀连成了一棵新子树接在虚根的下面。</p>
<p>还是原来的 $dp$ 原理。每次遇到一个在两个串中都出现过的串就把答案更新一下。</p>
<p>嗯，不得不说，SAM按照 $endpos$ 构建等价类这个想法实在太妙了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[x][<span class="number">0</span>] += f[to(k)][<span class="number">0</span>], f[x][<span class="number">1</span>] += f[to(k)][<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (f[x][<span class="number">0</span>] &amp;&amp; f[x][<span class="number">1</span>]) ans = max(ans, sam.len[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sam.Init() ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) sam.Ins(S[i] - <span class="string">'a'</span> + <span class="number">1</span>, <span class="number">0</span>) ; sam.Ins(<span class="number">27</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) sam.Ins(T[i] - <span class="string">'a'</span> + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= sam.sz ; ++ i) add(sam.fa[i], i) ; dfs(<span class="number">1</span>) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-HAOI2016-找相同字符"><a href="#2-HAOI2016-找相同字符" class="headerlink" title="$2$ [HAOI2016] 找相同字符"></a>$2$ [HAOI2016] 找相同字符</h1><blockquote>
<p>给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。</p>
</blockquote>
<p>我明白了，$15,16$ 年的时候正值SAM变的普及的阶段，所以这种没有新意的题才会有一堆人出。</p>
<p>首先就是乘法原理，然后考虑不同的子串数量可以直接 $parent$ 上父子差分，然后就没了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[x][<span class="number">0</span>] += f[to(k)][<span class="number">0</span>], f[x][<span class="number">1</span>] += f[to(k)][<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; f[x][<span class="number">0</span>] &amp;&amp; f[x][<span class="number">1</span>]) </span><br><span class="line">		ans += <span class="number">1l</span>l * f[x][<span class="number">0</span>] * f[x][<span class="number">1</span>] * (sam.len[x] - sam.len[sam.fa[x]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-多串的LCS"><a href="#3-多串的LCS" class="headerlink" title="$3$ 多串的LCS"></a>$3$ 多串的LCS</h1><p>此处的 “S” 指的是 “Substring” 的意思啦。</p>
<p>本质上是SPOJ的两道题，<code>SP10570 LONGCS</code> 和 <code>SP1812 LCS2</code> 。</p>
<blockquote>
<p>给定一些字符串，求出它们的最长公共子串</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN], T[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, L, res, ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> last, sz ;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN], f[MAXN], len[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trans[MAXN][<span class="number">27</span>], buc[MAXN], base[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = sz = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++ sz ;</span><br><span class="line">        last = np, len[np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fa[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = <span class="number">1</span>, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">int</span> q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = q, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">int</span> nq = ++ sz ;</span><br><span class="line">        fa[nq] = fa[q],</span><br><span class="line">        fa[q] = fa[np] = nq ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="keyword">sizeof</span>(trans[q])) ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    void dfs(int x)&#123;</span></span><br><span class="line"><span class="comment">        if (vis[x]) return ; vis[x] = 1 ;</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= 26 ; ++ i) if (trans[x][i]) dfs(trans[x][i]) ;</span></span><br><span class="line"><span class="comment">        ans[fa[x]] = max(ans[fa[x]], min(ans[x], len[fa[x]])) ;</span></span><br><span class="line"><span class="comment">        f[x] = min(f[x], ans[x]), ans[x] = 0 ; </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= sz ; ++ i) buc[len[i]] ++ ;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= sz ; ++ i) buc[i] += buc[i - <span class="number">1</span>] ;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = sz ; i &gt;= <span class="number">1</span> ; -- i) base[buc[len[i]] --] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">1</span>, x, l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (rt &amp;&amp; !trans[rt][x]) rt = fa[rt], l = len[rt] ;</span><br><span class="line">            <span class="keyword">if</span> (rt) ++ l, rt = trans[rt][x], ans[rt] = max(ans[rt], l) ;</span><br><span class="line">            <span class="keyword">else</span> rt = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sz ; i ; -- i)</span><br><span class="line">            rt = base[i], x = fa[rt], </span><br><span class="line">            ans[x] = max(ans[x], min(ans[rt], len[x])), </span><br><span class="line">            f[rt] = min(f[rt], ans[rt]), ans[rt] = <span class="number">0</span> ; </span><br><span class="line">        <span class="comment">// for (int i = 1 ; i &lt;= sz ; ++ i) cout &lt;&lt; ans[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">        <span class="comment">// dfs(1) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;M ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; <span class="keyword">int</span> i ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        M.Insert(S[i] - <span class="string">'a'</span> + <span class="number">1</span>) ;</span><br><span class="line">    M.sort() ;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, T + <span class="number">1</span>))</span><br><span class="line">        L = <span class="built_in">strlen</span>(T + <span class="number">1</span>), M.work(T) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M.sz ; ++ i)</span><br><span class="line">        res = max(res, M.f[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先拿第一个串朴素建 SAM。对于一个新的串，考虑将这个串放到 SAM 上运行，同时记录每个位置能够匹配到的最长长度。再用一个 $f$ 记录全局，而 $f$ 显然应该对每个串的 $rt$ 处的匹配取 $\min$。</p>
<p>嗯，注意由于 $parent$ 树的性质，父亲答案的一部分包含在儿子中，但也不会多于自身的长度。于是一开四$topsort$ 一遍就可以了。复杂度似乎是 $\sum\rm |S_i|$ ?</p>
<p>en，似乎这道题也是 <code>[POI2000]公共串</code> 的加强版。不过这种题目几倍经验也不奇怪吧？</p>
<h1 id="4-SDOI2008-Sandy的卡片"><a href="#4-SDOI2008-Sandy的卡片" class="headerlink" title="$4$ [SDOI2008] Sandy的卡片"></a>$4$ [SDOI2008] Sandy的卡片</h1><blockquote>
<p>Sandy和Sue的热衷于收集干脆面中的卡片。</p>
<p>每一张卡片都由一些数字进行标记，第 $i$ 张卡片的序列长度为 $M_i$，要想兑换人物模型，首先必须要集够 $N$ 张卡片，对于这 $N$ 张卡片，如果他们都有一个相同的子串长度为 $k$，则可以兑换一个等级为 $k$ 的人物模型。相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串。</p>
<p>现在又一堆卡片，请你帮助Sandy和Sue，看看他们最高能够得到哪个等级的人物模型。</p>
</blockquote>
<p>看到这题蒙了半天，甚至写了一发枚举「加上的数是多少」然后再去SAM，结果发现原来不同串之间可以用不同的数 ……我是弟弟。</p>
<p>于是最后被题解暴击：差分一下即可。我是dd。QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; N ; T -- ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) t[i] = S[i] - S[i - <span class="number">1</span>] ; M.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) M.Insert(t[i]) ; M.sort() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ss[i][<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= ss[i][<span class="number">0</span>] ; ++ j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ss[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt;= ss[i][<span class="number">0</span>] ; ++ j) t[j] = ss[i][j] - ss[i][j - <span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//        for (j = 1 ; j &lt;= ss[i][0] ; ++ j) cout &lt;&lt; t[j] &lt;&lt; " " ; puts(" ") ;</span></span><br><span class="line">        t[<span class="number">1</span>] = -(i + <span class="number">1</span>) ; M.work(t, ss[i][<span class="number">0</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M.sz ; ++ i) res = max(res, M.f[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方我默认把第一个元素瞎给了个值。</p>
<p>哦，还有，可能好久没写差分了？一开始写差分我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) S[i] = S[i] - S[i - <span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>
<p>是弟中弟本弟没错了（cry</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SAM瞎做 · 字典序相关</title>
    <url>/2020/01/16/SAM2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了证明自己不是🕊并且自己经常写博客，打算把本来可以 $1p$ 讲完的分了 $4p$。这是第二 $p$，嘎嘎嘎。</p>
<a id="more"></a>
<h1 id="1-LG1368-工艺"><a href="#1-LG1368-工艺" class="headerlink" title="$1$ LG1368 工艺"></a>$1$ LG1368 工艺</h1><p>似乎std是什么最小表示法，看⑧透啊，$O(n)$ 的SAM它不香吗 ？</p>
<blockquote>
<p>把一个串循环排列，求最小的字典序排列。</p>
</blockquote>
<p>发现把串向SAM里面插两次，从始状态开始不断找最小的转移，走 $n$ 次就完了。</p>
<p>似乎只是用到了一丢丢SAM的性质啊QAQ</p>
<h1 id="2-SP7258-Lexicographical-Substring-Search"><a href="#2-SP7258-Lexicographical-Substring-Search" class="headerlink" title="$2$ [SP7258] Lexicographical Substring Search"></a>$2$ [SP7258] Lexicographical Substring Search</h1><p>题目名称…好长…</p>
<blockquote>
<p>给定一个字符串，求本质不同排名第k小的子串</p>
</blockquote>
<p>考虑首先在SAM上算出现次数，然后从 $1$ 开始走，类似于二叉搜索木找 $k-$极值 的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span> ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (S.trans[u][i]) </span><br><span class="line">      dfs2(S.trans[u][i]), </span><br><span class="line">  		g[u] += g[S.trans[u][i]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_Out</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= f[p]) </span><br><span class="line">    	<span class="keyword">return</span> ; </span><br><span class="line">  <span class="keyword">else</span> s -= f[p] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!S.trans[p][i]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; g[S.trans[p][i]]) s -= g[S.trans[p][i]] ;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%c"</span>, i + <span class="string">'a'</span>), go_Out(S.trans[p][i], s) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) &gt;&gt; T ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; S.Init() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) S.Ins(In[i] - <span class="string">'a'</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) add(S.fa[i], i) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) g[i] = f[i] = <span class="number">1</span> ; dfs2(<span class="number">1</span>) ;</span><br><span class="line">	dfs2(<span class="number">1</span>) ; <span class="keyword">while</span> (T --) K = qr(), go_Out(<span class="number">1</span>, K), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-TJOI2015-弦论"><a href="#3-TJOI2015-弦论" class="headerlink" title="$3$ [TJOI2015]弦论"></a>$3$ [TJOI2015]弦论</h1><blockquote>
<p>求：</p>
<ul>
<li>本质不同的第 $k$ 小子串</li>
<li>第 $k$ 小子串</li>
</ul>
</blockquote>
<p>发现第一问就是上面那一道，但是第二问里面，本质不同的串要算多次。</p>
<p>然而其实并没有什么变化，$dfs$ 一遍顺便算个出现次数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) </span><br><span class="line">		dfs(to(k)), f[u] += f[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span> ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (S.trans[u][i]) </span><br><span class="line">			dfs2(S.trans[u][i]), g[u] += g[S.trans[u][i]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_Out</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= f[p]) <span class="keyword">return</span> ; <span class="keyword">else</span> s -= f[p] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!S.trans[p][i]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; g[S.trans[p][i]]) s -= g[S.trans[p][i]] ;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%c"</span>, i + <span class="string">'a'</span> - <span class="number">1</span>), go_Out(S.trans[p][i], s) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片1】· 开始啦</title>
    <url>/2020/01/15/Life1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小班终于来啦！孤独的机房终于要迎来一丝亮色了。</p>
<p>自己呢？也要准备好背起行囊，重新出发了吧！</p>
<p><del>流水账警告</del></p>
<a id="more"></a>
<h1 id="rm-Part1"><a href="#rm-Part1" class="headerlink" title="$\rm Part1$"></a>$\rm Part1$</h1><blockquote>
<p>「沉舟侧畔千帆过，病树前头万木春。」</p>
</blockquote>
<p>第一部分当然要谦虚一点，自己是沉舟病树啦。</p>
<p>然而其实谦不谦虚的，都是沉舟病树qaq</p>
<p>最近小班来了，金哥把四个提前学过的放到了我这屋。跟他们在一块显著感觉出自己有多么颓废，虽然不是很想承认，可能金哥的「错位打击」真的管用了吧？</p>
<p>然后就是想讲课？可能是因为孩儿们太可爱了，所以忍不住地就像去找他们玩…然而他们现在学的不多，所以可能不能讲太难的内容。想了一两天，决定给他们讲贪心啊、随机化啊、构造啊这种有意思的题目。</p>
<p>于是就开始学 $\TeX $ 咋用，其实挺好明白的，跟着网上找几个教程，下一堆乱七八糟的东西就好了。这里推荐清华搭的镜像站，速度很快，不愧是你清。</p>
<p>再之后就开始学 $beamer$，发现还是很简单的。然而由于自己没用过 <code>sublime 3</code> （目前只用来识别特殊字符+文本替换+文档暂存），所以就只能一行一行地手敲 $\TeX$，给爷整蒙了……</p>
<p>不过经历了一番苦难还是做好了的，最后就是 $42$ 页 PPT，觉得还可以？但不知道为啥，总觉得只有像 $\rm lxl$ 和我校化学奥赛教练那样一个课件做好几百页才算做PPT…于是只给自己打 $95$ 分（雾</p>
<p>然而，在给他们讲课的前一天下午，听他们聊起的内容，已经是 「$\rm SPFA$」、「Luogu上蓝色的贪心」这种东西，于是觉得他们很强，就临时又加了一点 $dp$ 的内容，加到了$84$ 页…and为了防止被喷菜，随便找了一道作为Cfdiv2F的dp。<del>才不会告诉你我自己看这个题都蒙了半天最后还翻的题解</del></p>
<p>结果……发现好像有什么不对……</p>
<p>大概就是本来觉得 $\rm 2h$ 结束的内容讲了 $\text{6+}~h$ 还没讲完…</p>
<p>不过最终感觉还可以？可能构造和dp是个亮点，前面讲贪心翻了一次车233，我还是太菜啊QAQ</p>
<p>发现了几个比较有天分的小朋友，希望他们将来会有所建树吧。</p>
<p>首先是人生经验：</p>
<div class="pdf" target="./瞎讲讲.pdf" height></div>
<p>其次是课件，自我感觉做的还不错：</p>
<div class="pdf" target="./技巧性问题选讲.pdf" height></div>
<p>（如果pdf加载不出来，推荐 <code>firefox</code> 浏览器或者等上那么一二三四…五六十分钟【huaji ）</p>
<p>最后把自己从MO那里嫖来的数竞教材交给了下一代…233</p>
<p>不过呢，感觉自己真是老了啊。衔接班的懵懂，高一的迷茫，高二的从容，一路走来，经历了很多，也明白了很多。</p>
<p>但是，比较伤感的一点是，无论我对这一级初三的小班有多么真挚的感情，我都不可能再陪他们去参加一年联赛了。也就说自己可能就只是他们OI生涯中，一个不起眼的过客…</p>
<p>想来有点伤感呢，但这世界本就是这样吧？</p>
<p>想起自己前几天看张庚新学长的 $blog$，里面大多都是「给小班讲STL」之类的，当时的小班（现在是我的2级学长）也很高兴地去催更。虽然东西明明那么简单，讲的明明也那么简陋，但我总能感觉出一种感情、一股力量，嵌在文字间、流淌在评论里。想到这里，感觉心脏似乎空了一块儿。</p>
<p>那力量，似乎就是从沉舟病树里面发出的，似乎在大声地喊「我还要活着」。</p>
<p>那感情，可能就是最质朴的感情吧？</p>
<h1 id="rm-Part2"><a href="#rm-Part2" class="headerlink" title="$\rm Part2$"></a>$\rm Part2$</h1><p>第二部分呢，打算自己当一回「千帆过」、「万木春」233。</p>
<p>实不相瞒，暗恋了一年多的妹子突然有了男票之后唯一的感觉就是空虚…一种「过去把自己分到她身上一部分，现在她走了，自己空了一大块」的认知，一种「为什么总感觉生活只是在不断兜着一个从“做梦”到“失败”再到“做梦”的圈子」的情感，两者叠加在一起，让我感到每天都十分的浑浑噩噩…</p>
<p>但仔细想了想，自己似乎做的事还有很多。比如可以学音乐啊、学英语、法语、俄语、日语啊之类的。但总觉得自己是三分钟热度。</p>
<p>虽然看不到什么东西，在偌大的世界也总感觉自己是孤单一人。但《飘》里面，斯嘉丽在最后说的话，似乎比较适合结尾：</p>
<blockquote>
<p> Tomorrow is another day !</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】后缀自动机瞎学</title>
    <url>/2020/01/15/SAM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次学SAM还是一年前，当时只记得怎么看怎么不会orz</p>
<a id="more"></a>
<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="$1$ 基本内容"></a>$1$ 基本内容</h1><p>…于是还是分条陈述</p>
<p>0、一个子串的 $endpos$ 集合指的是它在原串内出现的所有的右端点下标组成的集合。显然有这么一个性质，对于两个子串，它们的 $endpos$ 集合要么存在包含关系，要么没有交集。 </p>
<p>1、首先，SAM是个自动机。转移是字母，状态是 <strong>$endpos$ 集合相同的子串</strong>。有一个其实状态，一堆终止状态，每个终止状态是原串的一个后缀。</p>
<p>2、如果记每个状态里面最长的子串的长度为 $L_{\max}$，最短的子串长度为 $L_{\min}$ ，那么这个状态承载的子串长度覆盖 $[L_{\min},L_{\max}]$.</p>
<p>3、考虑后缀链接 $\rm link$ 。$\mathrm{link}(v)$ 指向的是 $L_{\max}(u)+1=L_{\min}(v)$ 且 $endpos(v)\sub endpos(u)$ 的这么一个节点 $u$ . 可以看出，其实 $u$ 里面的子串就是 $v$ 中的子串的某些更短的后缀。</p>
<p>4、发现后缀链接 $\rm link$ 联系期的每个状态之间，长度单调且前驱唯一，再加上显然连通，所以 $\{\rm S,link\}$ 本质上是一棵树。</p>
<p>5、于是考虑怎么构造。大概就是增量构造法。</p>
<ul>
<li><p>每次加入一个新的状态 $np$ 时，考虑上一个转移到的状态 $p$ ，把 $L_{max}(np)$ 设置为 $L_{\max}(p) + 1$ （显然）。一直沿着后缀链接向上跳，并且把途中的转移都连向 $np$，因为原来不存在当前字母 $c_{now}$ 的转移，所以加入一个字母之后要一起改</p>
</li>
<li><p>考虑不断跳 $p$ ，直到跳到一个 $p$ 具有 $c_{now}$ 的转移，把这个转移到的状态称之为 $q$。那么此时 $endpos(q)$ 会多出一个元素，长度为 $L_{\max}+1$。此时由于 $L_{\max}(p)&lt;q$ 有两种情况需要考虑：</p>
<ul>
<li><ol>
<li>$L_{\max}(q)=L_{\max}(p)+1$，这时 $q$ 代表的所有串的 $endpos$ 不变。考虑 $np$ 具有至少一个不同于 $q$ 的状态，即 $[1…now]$ ，现在插入的最长前缀。所以此时令 $\mathrm{link}(np)=q$ ，而不是合并。</li>
</ol>
<ul>
<li><ol>
<li>$L_\max(q)&gt;L_\max(p)+1$，这时 $q$ 中的串，长度不超过 $L_\max$ 的串会多一个 $endpos$，即 $now$；但是大于 $L_{\max}$ 的串则不会。所以此时需要 <strong>拆开状态</strong> 。考虑为了维护一个状态里面所有点的 $endpos$ 相同，需要新建一个状态 $nq$，代表原来串中所有长度不超过 $L_\max(p)+1$ 的串。发现这么拆分的话，有 <script type="math/tex; mode=display">
\mathrm{link}(q)=\mathrm{link}(np) = nq</script></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>对于第二种情况，发现就类似于扣掉一个点，换进去一颗子树。于是乎从 $p$ 开始又要不断向上跳，把 所有 $trans=q$ 的点都改成 $nq$。</li>
</ul>
<p>哦，对，树 $\{\rm S,link\}$ 有个学名叫做 $parent$ 树来着。</p>
<p>然后就完了，就完了……</p>
<p>发现其实到最后SAM十分的短：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> last, sz ;</span><br><span class="line">	<span class="keyword">int</span> trans[MAXN][Sigma] ;</span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fa[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; last = sz = <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> np = ++ sz ; </span><br><span class="line">		<span class="keyword">int</span> p = last, q, nq ;</span><br><span class="line">		last = np, f[np] = <span class="number">1</span> ;</span><br><span class="line">		len[np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; !trans[p][x]) </span><br><span class="line">			trans[p][x] = np, p = fa[p] ; </span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="keyword">return</span> fa[np] = <span class="number">1</span>, <span class="keyword">void</span>() ; </span><br><span class="line">		q = trans[p][x] ; </span><br><span class="line">		<span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> fa[np] = q, <span class="keyword">void</span>() ;</span><br><span class="line">		nq = ++ sz, </span><br><span class="line">		len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">		fa[nq] = fa[q], fa[q] = fa[np] = nq ; </span><br><span class="line">		<span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="keyword">sizeof</span>(trans[q])) ; </span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q) </span><br><span class="line">			trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure>
<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="$2$ 例题"></a>$2$ 例题</h1><p>然而有些例题就是很水。。。于是放到这里来了。。</p>
<h2 id="1-SDOI2016-生成魔咒"><a href="#1-SDOI2016-生成魔咒" class="headerlink" title="$1$ [SDOI2016]生成魔咒"></a>$1$ [SDOI2016]生成魔咒</h2><p>2016年SD居然考过这种有趣东西x</p>
<blockquote>
<p>询问每加入一个字符时，当前整个串的本质不同子串数量。</p>
</blockquote>
<hr>
<p>发现在SAM里面的 $\rm link$ 树上，本质不同的子串数的增量是 $L_{\max}(now)-L_{\max}(fa)$。</p>
<p>于是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">设fa为q原来的父亲。</span><br><span class="line">则原来的贡献是len(q) - len(fa) </span><br><span class="line">现在的贡献是</span><br><span class="line">len(nq) - len(fa) + len(q) - len(nq) + len(np) - len(nq) </span><br><span class="line">= len(q) - len(a) + len(np) - len(nq)</span><br><span class="line">相当于只增加了len(np) - len(nq)</span><br><span class="line">SAM题 = 推式子题.jpg</span><br></pre></td></tr></table></figure>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> last, sz ; </span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fa[MAXN] ;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; trans[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; last = sz = <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> np = ++ sz ;</span><br><span class="line">		<span class="keyword">int</span> p = last, q, copy ; </span><br><span class="line">		len[np] = len[p] + <span class="number">1</span>, last = np ;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; !trans[p].count(x)) </span><br><span class="line">			trans[p][x] = np, p = fa[p] ;</span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">			<span class="keyword">return</span> fa[np] = <span class="number">1</span>, ans += <span class="number">1l</span>l * len[np], <span class="keyword">void</span>() ; </span><br><span class="line">		q = trans[p][x] ;</span><br><span class="line">		<span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) </span><br><span class="line">			<span class="keyword">return</span> fa[np] = q, ans += <span class="number">1l</span>l * (len[np] - len[q]), <span class="keyword">void</span>() ; </span><br><span class="line">		copy = ++ sz ;</span><br><span class="line">		fa[copy] = fa[q], </span><br><span class="line">		fa[q] = fa[np] = copy, </span><br><span class="line">		len[copy] = len[p] + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//		memcpy(trans[copy], trans[q], sizeof())</span></span><br><span class="line">		trans[copy] = trans[q] ; </span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q) trans[p][x] = copy, p = fa[p] ;</span><br><span class="line">		ans += <span class="number">1l</span>l * (- len[copy] + len[np]) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S ;</span><br></pre></td></tr></table></figure>
<h2 id="2-LG3804【模板】SAM"><a href="#2-LG3804【模板】SAM" class="headerlink" title="$2$  LG3804【模板】SAM"></a>$2$  LG3804【模板】SAM</h2><blockquote>
<p>给定一个只包含小写字母的字符串 $\rm S$,</p>
<p>请你求出 $\rm S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。</p>
</blockquote>
<p>于是发现，这个出现次数的话，可以在 $parent$ 树上直接 $dp$ 一遍。对于每个准确插入的状态，初始设置成 $1$，然后 $dp$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) </span><br><span class="line">		dfs(to(k)), f[x] += f[to(k)] ;</span><br><span class="line">	<span class="keyword">if</span> (f[x] &gt; <span class="number">1</span>) ans = max(ans, f[x] * <span class="number">1l</span>l * S.len[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), S.Init() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) S.Insert(In[i] - <span class="string">'a'</span> + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) add(S.fa[i], i) ; dfs(<span class="number">1</span>) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-USACO06DEC-Milk-Patterns"><a href="#3-USACO06DEC-Milk-Patterns" class="headerlink" title="$3$ [USACO06DEC] Milk Patterns"></a>$3$ [USACO06DEC] Milk Patterns</h2><blockquote>
<p>找 $\rm S$ 中出现次数超过 $k$ 的最长的串的长度。</p>
</blockquote>
<p>还是 $dp$ 一遍，然后就没有然后了。</p>
<p><del>我在干什么？</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">svoid <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[u] += f[to(k)] ; </span><br><span class="line">	<span class="keyword">if</span> (f[u] &gt;= K) ans = max(S.len[u], ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SPOJ数个数</title>
    <url>/2020/01/05/count-divisors/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目名称是我瞎写的233</p>
<p>事实上是 $\rm SPOJ$ 的三<del>倍经验</del>道题，解决的是以下问题：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^{n}\sigma_0(i^k)</script><p>其中 $n,k$ 给定，$n\leq 10^{10},\quad k\leq2^{64}$ </p>
<p><del>我也忘了是不是这个数据范围反正能过就对了</del></p>
<p>提交链接 ：</p>
<p>1 <a href="http://www.spoj.com/problems/DIVCNTK2/" target="_blank" rel="noopener">$k=2$  DIVCNTK2</a><br>2 <a href="http://www.spoj.com/problems/DIVCNTK3/" target="_blank" rel="noopener">$k=3$  DIVCNTK3</a><br>3 <a href="http://www.spoj.com/problems/DIVCNTK/" target="_blank" rel="noopener">$\mathrm{input} ~k$  DIVTNK(general)</a></p>
<a id="more"></a>
<h2 id="正经题解"><a href="#正经题解" class="headerlink" title="正经题解"></a>正经题解</h2><p>其实很水的，对吧？已知 $\forall p\in \mathbb{P,}~\sigma_0(p^k)=k+1$，所以有 $f(p)=k+1,f(p^j)=jk+1$ 于是这东西看起来可以效仿原来的思路直接设一个 $f(p)=1,f(p)=k$ 来做，然后就。。。就不对了！</p>
<p>然后我就很奇怪啊，为啥按照公式推，$g$ 应该没推错，但是结果不对？迷惑了大半个上午。</p>
<p>…到最后这个题纠结了半天，原因是我忘了 $f(p)=k$ 这东西 <strong>不是积性函数</strong> ，所以不能去推 $f(k)$，也就是说<strong>不能直接拆</strong>。</p>
<p>然后为了这个事儿还去 uoj 群丢了一上午人，Life so hard ….</p>
<p>所以怎么解决？考虑只维护一个 $f(p)=1$，然后计算的时候 $\times ~(k+1)$ 就完了。</p>
<p>最后还是 <a href="https://www.cnblogs.com/bestwyj" target="_blank" rel="noopener"><code>iostream</code></a> 神仙在Luogu的讨论区帮了我，十分感动555</p>
<p>总结：感觉自己是个弟弟qaq</p>
<p>然后以下是正确写法，只推一个 $h$ 就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL n, e ;</span><br><span class="line">LL val[N], h[N] ;</span><br><span class="line"><span class="keyword">int</span> s, tot, cnt ;</span><br><span class="line">LL id1[N], id2[N] ;</span><br><span class="line"><span class="keyword">int</span> T, chk[N], pr[N] ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = p &lt;= s ? id1[p] : id2[n / p] ;</span><br><span class="line">    LL ans = h[id] * (e + <span class="number">1</span>) - q * (e + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p)</span><br><span class="line">            <span class="keyword">break</span> ; LL m = pr[k], t = pr[k] ; <span class="keyword">int</span> o ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span> ; m &lt;= p ; ++ o, m *= t)</span><br><span class="line">            ans += <span class="number">1u</span>ll * (o * e + <span class="number">1</span>) * (S(p / m, k) + (o &gt; <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    sieve(N - <span class="number">1</span>) ;</span><br><span class="line">    LL l, r, w, t ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n, e = <span class="number">3</span> ;</span><br><span class="line">        s = <span class="built_in">sqrt</span>(n) ; tot = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            t = n / l ; r = n / t ;</span><br><span class="line">            val[++ tot] = t ; h[tot] = t - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (t &lt;= s) id1[t] = tot ; <span class="keyword">else</span> id2[l] = tot ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            LL nowp = <span class="number">1l</span>l * pr[i] * pr[i], w, id ;</span><br><span class="line">            <span class="keyword">if</span> (nowp &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; val[j] &gt;= nowp ; ++ j)&#123;</span><br><span class="line">                w = val[j] / pr[i] ;</span><br><span class="line">                id = (w &lt;= s) ? id1[w] : id2[n / w] ;</span><br><span class="line">                h[j] -= h[id] - (i - <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S(n, <span class="number">0</span>) + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>上午在去 uoj 群里丢脸之前，找到欧神 <code>ouuuyuuu</code> （欧神：说了多少遍我不打算起这个ID！？）——我校现役MO最强战力，SD-01，CMO2019非集训队第一。找他是因为曾经给他看过杜教筛，他觉得简单，于是我就让他现场 $5min$ 学完了 $\rm Min25$ 筛（可能效果不是很好）然后问他为什么不对。</p>
<p>然后我俩：</p>
<blockquote>
<p>好迷啊（齐声）</p>
</blockquote>
<p>所以事实证明，弱菜弱到一定地步是可以带飞神仙的。qed。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>SPOJ</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】#loj6053 简单的函数</title>
    <url>/2020/01/05/loj6053/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定函数 $f(x)$ 满足：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\text { 1. } f \left (1\right) =1} \\ {\text { 2. } f\left(p^{c}\right)=p \oplus c} \qquad \oplus\text{代表异或运算}\\ {\text { 3. } f\left(a b\right)=f\left(a\right) f\left(b\right) \qquad (a,b)=1}\end{array}</script><p>求 $\sum f(x)$, $n\leq 10^{10}$</p>
</blockquote>
<p>单独拿出一道题来整理一下，也算是理一下用 Min_25 解题的一点思路吧。</p>
<a id="more"></a>
<p>嗯，首先思考 Min_25 筛本质上需要做什么：</p>
<p>1、对于每个 $x = \lfloor \frac{n}{y}\rfloor$ ，这样不同的 $x$ 共有 $O(\sqrt n)$ 个，需要快速得到 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^x \boldsymbol{F'}(i)</script><p>的值。</p>
<p>2、需要根据递推式求出 $g$ 来，同时由于空间不够，而我们其实只需要知道 $g(x,j)$ 在所有 $x = \lfloor \frac{n}{y}\rfloor$ 处的取值就好，所以考虑用两个 $\sqrt n$ 的标号来存。</p>
<p>3、在 $\rm S$ 中，分工很明确，<code>for</code> 之前求的是所有质数处的 $f$ 和，然而由于直接算 $f$ 求出的是 $1\sim n$ 的质数处的 $f$ 和，我们需要的是 $j+ 1\sim n$ 的，所以把 $1\sim j$ 的减去；对于合数，我们枚举每个 $\geq j+1$ 的质数，然后 $\log$ 次向上计算：</p>
<script type="math/tex; mode=display">
\sum_{p_{k}^{e} \leq n, k>j} f\left(p_{k}^{e}\right)\left(\mathrm{S}\left(\frac{n}{p_{k}^{e}}, k\right)+[e>1]\right)</script><p>直观上可以感觉出有一个很大的上界 $n$，即 </p>
<script type="math/tex; mode=display">
\sum_{x=1}^{\lfloor\frac{n}{\ln n}\rfloor} \log_xn<n</script><p>。。。然而似乎并没有用，因为线性筛也是这个复杂度233</p>
<p>然后说题，考虑质数处的取值：</p>
<script type="math/tex; mode=display">
f(p)=p \operatorname{xor} 1=\left\{\begin{array}{ll}{p+1} & {p=2} \\ {p-1} & {p\not =2}\end{array}\right.</script><p>然后就可以维护一个 $n$ 一个 $1$，质数次幂就是 $f(p^c)=p\oplus c$ 易求，最后再加上 $2$ 处多减去的 $2$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL n ;</span><br><span class="line">LL val[N] ;</span><br><span class="line">LL g[N], h[N] ;</span><br><span class="line"><span class="keyword">int</span> s, tot, cnt ;</span><br><span class="line"><span class="keyword">int</span> chk[N], pr[N] ;</span><br><span class="line">LL id1[N], id2[N], sp[N] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            sp[cnt] = (sp[cnt - <span class="number">1</span>] + i) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = p &lt;= s ? id1[p] : id2[n / p] ;</span><br><span class="line">    LL ans = ((g[id] - h[id] - sp[q] + q) % P + P) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!q) ans += <span class="number">2</span> ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p)</span><br><span class="line">            <span class="keyword">break</span> ; LL m = pr[k], t = pr[k] ; <span class="keyword">int</span> o ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span> ; m &lt;= p ; ++ o, m *= t)</span><br><span class="line">            ans = (ans + <span class="number">1l</span>l * (pr[k] ^ o) * (S(p / m, k) + (o &gt; <span class="number">1</span>)) % P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; s = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">    sieve(s) ; LL l, r, w, t ;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        t = n / l ; r = n / t ;</span><br><span class="line">        val[++ tot] = t ; h[tot] = ((t - <span class="number">1</span>) % P + P) % P  ;</span><br><span class="line">        g[tot] = ((t % P * (t % P + <span class="number">1</span>) % P * Inv2 % P - <span class="number">1</span>) % P + P) % P ;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= s) id1[t] = tot ; <span class="keyword">else</span> id2[l] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">        LL nowp = <span class="number">1l</span>l * pr[i] * pr[i], w, id ;</span><br><span class="line">        <span class="keyword">if</span> (nowp &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; val[j] &gt;= nowp ; ++ j)&#123;</span><br><span class="line">            w = val[j] / pr[i] ;</span><br><span class="line">            id = (w &lt;= s) ? id1[w] : id2[n / w] ;</span><br><span class="line">            (h[j] -= h[id] - (i - <span class="number">1</span>)) %= P ;</span><br><span class="line">            (g[j] -= <span class="number">1l</span>l * pr[i] * (g[id] - sp[i - <span class="number">1</span>]) % P) %= P  ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; h[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (S(n, <span class="number">0</span>) + <span class="number">1</span>) % P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一想到 zzq 出这个题的年纪我还在玩泥巴，就知道自己退役预定了。</p>
<p>是啊，本来就是强行续命，所以无论结果怎么样也只能欣然接受了吧。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Min_25筛</title>
    <url>/2020/01/04/min25%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>源自一个日本老哥神仙级别的构造，原链接在这里：<a href="https://min-25.hatenablog.com/entry/2018/11/11/172216" target="_blank" rel="noopener">$min_25’s~blog$</a></p>
<p>啊，学了好久啊…总是学不会呢，再聪明一点吧。</p>
<a id="more"></a>
<p>然后 $min25$ 筛大概是对积性函数求和的一种方法。他求和的函数有以下特征：</p>
<p>1、$\boldsymbol{F}$ 是整值积性函数 </p>
<p>2、广义上讲，需要 ${i\in \mathbb{P}},\boldsymbol{F}(i),\boldsymbol{F}(i^k)$ 这俩东西可以很简单地计算</p>
<p>3、然而一般情况下，都是 $f$ 这东西在素数处可以化作一个低次多项式（即完全积性，否则不能提出来）。</p>
<p>嗯，第三条是大部分情况下都会把原函数拆分为 $\sum _{i\in\mathbb{P}} i^k$ 这种形式，因为这种形式的和比较好求。然而其实这么说来十分的naive，毕竟 $\varphi,\mu$ 也很好求。</p>
<p>大概思想就是神仙构造，比杜教筛神仙许多的构造。当然也有人管这个叫“扩展埃拉托色尼筛”…不过也确实很形象。</p>
<h1 id="1-构造一个-g-n-j"><a href="#1-构造一个-g-n-j" class="headerlink" title="$1$ 构造一个 $g(n,j)$"></a>$1$ 构造一个 $g(n,j)$</h1><p>本节先假设 $f$ 为 <strong>完全积性函数</strong>。</p>
<p>嗯，这东西是这么一种形式 ：</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=1}^{n}f(i)\cdot\max([i\in\mathbb{P}],[\mathrm{minf}(i)> prime_j])</script><p>其中 $[]$ 还是艾佛森括号，$prime_j$ 表示线性筛出来的质数集合中第 $j$ 大的元素，$\mathrm{minf}(i)$ 表示 $i$ 的最小素因子。</p>
<p>直观地来说，$g(n,j)$ 表示的就是 $n$ 以内的在埃筛算法进行第 $i$ 轮后尚未被筛去的数的 $f$ 的和。</p>
<p>然后思考怎么转移，假设枚举到了 $j$：</p>
<p>1、如果当前 $prime_j^2&gt;n$ ，那么对于当前的 $prime$ 不可能存在更多的 $\mathrm{minf}(i)&gt; prime_j$ 。所以此时 $g(n,j)=g(n,j-1)$<br>2、如果当前 $prime_j^2\leq n$，即 $\lfloor \frac{n}{prime_j}\rfloor \geq prime_j$ 那么考虑应该减去那些最小素因子为 $prime_j$ 的数的 $f$ 值。 然而这个值发现本质上可以通过 $g$ 数组本身来刻画。即：</p>
<script type="math/tex; mode=display">
g(n,j)=g(n,j-1) - f(prime_j)\cdot (g(\lfloor \frac{n}{prime_j}\rfloor,j-1)-g(prime_{j-1},j-1))</script><p>（1）首先，根据上文假设，$f$ 应该是一个完全积性函数，所以可以直接提出来。<br>（2）第二项的前一半是所有剔除掉 $prime_j$ 这一项之后，最小质因子 $&gt;prime_{j-1}$ 即 $\geq prime_j$ 的数字的和，因为这些数字没有比 $prime_j$ 更小的质因子，所以要减去；后面是要减去前一项里面顺带计算了的 $&lt;prime_j$ 的质数，因为显然 $1\sim prime_{j-1}$ 不可能存在以比 $prime_{j-1}$ 大的质数为最小质因子的数，所以累加的只有质数；而据定义这一部分需要倍计算进去，但是他们 $ \times ~prime_j$ 之后的数显然最小质因子不是 $prime_j$ 。</p>
<p>所以最终的递推式，为了简洁用 $p_j$ 替代 $prime_j$:</p>
<script type="math/tex; mode=display">
g_{(n,j)}=\begin{cases}g_{(n,j-1)} - f_{(p_j)}\cdot (g_{(\lfloor \frac{n}{p_j}\rfloor,j-1)}-g_{(p_{j-1},j-1)}) & \mathrm{if}~(p_j^2\leq n) \\\ g_{(n,j-1)} & \mathrm{otherwise}\end{cases}</script><p>…鬼知道我为了理解这部分<del>打了多久的摆</del>花了多少时间和精力233</p>
<p>不过观察整s个 $g$ 的递推，可以发现只跟 $f$ 在质数处的取值有关。所以如果对于一个积性函数 $\boldsymbol{F}$， 我们可以将其拆分成几个完全积性函数 $\boldsymbol{F’,F’’….}$ 在 $x\in \mathbb{P}$ 处的乘积或者是加和，就可以实现快速计算 $g$。</p>
<p>这也正是上文中对于 $\boldsymbol{F}$ 的限制。如果 $\boldsymbol{F}$ 是个简单的低次多项式，那么就可以按照幂次拆分成几项分别求和再相加；或者更广义一点， $\boldsymbol{F}$  可以拆分成许多在质数处以求得的函数，那么同样适用于 $min25$ 筛</p>
<h1 id="2-求和"><a href="#2-求和" class="headerlink" title="$2$ 求和"></a>$2$ 求和</h1><p>终于要求和啦！</p>
<p>首先令 $\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)&gt;prime_j]$ ，那么最终结果就是 $\mathrm{S}(n,0)+f(1)$ 。最后的 $1$ 是因为 $1$ 没有质因子。</p>
<p>（ps : 然而似乎 $f(1)\equiv 1$？因为毕竟 $f(x)$ 是积性函数，那么就一定有 $f(x)\cdot f(1)=f(x)$……除了 $f(x)\equiv0$ 这种情况）</p>
<p>那么就可以知道 $\rm S$ 可以这么推：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)= g(n,|\{p \}|) - g(p_{j-1},j-1)+\sum_{p_{k}^{e} \leq n, k>j} f\left(p_{k}^{e}\right)\left(\mathrm{S}\left(\frac{n}{p_{k}^{e}}, k\right)+[e>1]\right)</script><p>前半部分是所有质数的贡献，同样由于不存在比最大的质数 $p_{\max}$ 更大的质因子，所以第一项就是统计了所有质数；后一项则是根据定义减掉了比 $j$ 小的质数的贡献。</p>
<p>后半部分计算合数。这个地方考虑枚举合数的最小质因子（此处显然 $&gt;prime_j$，即枚举 $k&gt;j$），然后利用积性函数的性质提取。值得注意的是最后有一个艾佛森括号，$[e&gt;1]$，其意义是前文提到过的“ $1$ 没有质因子”，而当 $e=1$ 时，$prime_k^1\in \{prime\}$ , 是质数, 在前半部分计算过了。</p>
<p>嗯，于是这东西就可以暴力 $dfs$ 了。稳得很。</p>
<h1 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="$3$ 复杂度"></a>$3$ 复杂度</h1><p>大家都说是 $\frac{n^{\frac{3}{4}}}{\ln n}$，然而神仙说其实应该是 $O(n^{1-\epsilon})$，是一种亚线性筛法，但感觉用在 $n\leq 1e10$ 还是可以 $1.5s$ 以内出结果的。</p>
<p>然后有个小细节，就是发现算 $g$ 这个东西的时候，空间开不下。然而其实发现 </p>
<script type="math/tex; mode=display">
\left\lfloor\frac{\left\lfloor\frac{n}{a}\right\rfloor}{b}\right\rfloor=\left\lfloor\frac{n}{a b}\right\rfloor</script><p>这东西说明了，$n$ 除以某个数得到的值其实是有限的。于是就可以直接当 $k&gt;\sqrt n$ 时，用第一张表存 $\lfloor \frac{n}{k}\rfloor$ ；当 $k\leq \sqrt n$ 时，用第二张表存 $k$。同时 $g$ 的第二维也可以直接滚掉。发现这样空间复杂度就做到了 $O(\sqrt n)$ 。</p>
<h1 id="4-例题"><a href="#4-例题" class="headerlink" title="$4$ 例题"></a>$4$ 例题</h1><h2 id="LG5325-【模板】Min-25筛"><a href="#LG5325-【模板】Min-25筛" class="headerlink" title="LG5325 【模板】Min_25筛"></a>LG5325 【模板】Min_25筛</h2><blockquote>
<p>给定积性函数 $f$，满足 $p\in \mathbb{P},f(p^k)=p^k(p^k-1)$ 。求和</p>
<p>$n\leq 10^{10}$。</p>
</blockquote>
<p>发现这就是比较套路的多项式拆成单项式，所以就直接拆成平方项和一次项做就好了。</p>
<p>然后递推 $g$ 之前要先把 $g(n,0)$ 算出来，这东西完全可以 $\sqrt n$ 根据定义直接算。</p>
<p>。。。还有，注意取模</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL g1[N], g2[N] ;</span><br><span class="line">LL n, s1[N], s2[N] ;</span><br><span class="line">LL dex[<span class="number">2</span>][N] ; <span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004l</span>l ;</span><br><span class="line"><span class="keyword">int</span> s, pr[N], cnt, chk[N] ; LL Id[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_sieve</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= w ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            s1[cnt] = (s1[cnt - <span class="number">1</span>] + i) % P,</span><br><span class="line">            s2[cnt] = (s2[cnt - <span class="number">1</span>] + <span class="number">1l</span>l * i * i % P) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; w) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc1</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    x %= P ; </span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % P * Inv2 % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    x %= P ; </span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % P * (<span class="number">2</span> * x + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    LL ans = ((g2[id] - g1[id] - s2[q] + s1[q]) % P + P) % P ;</span><br><span class="line">  	<span class="comment">//上一句本质上就是 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ; LL o, t, pq ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span>, pq = pr[k] ; pq &lt;= p ; ++ o, pq = <span class="number">1l</span>l * pr[k] * pq)</span><br><span class="line">            t = pq % P,</span><br><span class="line">            ans = (ans + t * (t - <span class="number">1</span>) % P * (S(p / pq, k) % P + (o &gt; <span class="number">1</span>))) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n,</span><br><span class="line">    s = <span class="built_in">sqrt</span>(n) + <span class="number">1</span>,</span><br><span class="line">    pre_sieve(s) ; LL l, r, w ;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l),</span><br><span class="line">        Id[++ tot] = n / r ;</span><br><span class="line">        g1[tot] = (calc1(n / l) - <span class="number">1</span> + P) % P ;</span><br><span class="line">        g2[tot] = (calc2(n / l) - <span class="number">1</span> + P) % P ;</span><br><span class="line">        <span class="keyword">if</span> (n / l &gt; s)</span><br><span class="line">            dex[<span class="number">1</span>][l] = tot ;</span><br><span class="line">        <span class="keyword">else</span> dex[<span class="number">0</span>][n / l] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">        w = <span class="number">1l</span>l * pr[i] * pr[i] ; LL now ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; w &lt;= Id[j] ; ++ j)&#123;</span><br><span class="line">            now = Id[j] / pr[i] ;</span><br><span class="line">            now = (now &lt;= s) ? dex[<span class="number">0</span>][now] : dex[<span class="number">1</span>][n / now] ;</span><br><span class="line">            (g1[j] -= <span class="number">1l</span>l * pr[i] * (g1[now] - s1[i - <span class="number">1</span>] + P) % P) %= P ;</span><br><span class="line">            (g2[j] -= <span class="number">1l</span>l * pr[i] * pr[i] % P * (g2[now] - s2[i - <span class="number">1</span>] + P) % P) %= P ;</span><br><span class="line">            g1[j] += (g1[j] &lt; <span class="number">0</span>) ? P : <span class="number">0</span> ;</span><br><span class="line">            g2[j] += (g2[j] &lt; <span class="number">0</span>) ? P : <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">        printf("%lld %lld\n", g1[i], g2[i]) ; */</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (S(n, <span class="number">0</span>) + <span class="number">1</span>) % P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LG4213-【模板】杜教筛"><a href="#LG4213-【模板】杜教筛" class="headerlink" title="LG4213 【模板】杜教筛"></a>LG4213 【模板】杜教筛</h2><blockquote>
<p>求 $\sum \varphi(i)$ 和 $\sum \mu(i)$ .</p>
<p>$n&lt; 2^{31}$</p>
</blockquote>
<p>发现 $p\in \mathbb{P}$ ，$\varphi(p)=p-1,\varphi(p^k)=p^{k-1}(p-1)$，可以快速求，于是可以用一个 $g$ 来推 $f(x)=x$ 的前缀质数和，一个 $g$ 来推 $1$ ；同样对于 $p\in \mathbb{P},\mu(p)=-1,\mu(p^{k})=0 $ 所以这东西也可以通过递推 $1$ 来实现。</p>
<p>代码方面，虽然比自己实现的杜教筛要快，但是比其他人的杜教筛要慢不少。。。awsl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ; LL sp[N] ;</span><br><span class="line">LL gmu[N], gphi[N] ;</span><br><span class="line">LL dex[<span class="number">2</span>][N] ; <span class="keyword">int</span> T, tot ;</span><br><span class="line"><span class="keyword">int</span> s, pr[N], cnt, chk[N] ; LL Id[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_sieve</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= w ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            sp[cnt] = sp[cnt - <span class="number">1</span>] + i ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; w) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc1</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Sphi</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    rg LL ans = (gphi[id] - gmu[id]) - (sp[q] - q) ; </span><br><span class="line">  	<span class="comment">//上一句本质上就是g(n,|\&#123;prime \&#125;|) - g(prime_&#123;j-1&#125;,j-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;<span class="comment">//之后就是枚举更大的素因子（枚举合数）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ; LL o, t, pq ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span>, pq = pr[k] ; pq &lt;= p ; ++ o, pq = <span class="number">1l</span>l * pr[k] * pq)</span><br><span class="line">            ans = (ans + (pq / pr[k]) * (pr[k] - <span class="number">1</span>) * (Sphi(p / pq, k) + (o &gt; <span class="number">1</span>))) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Smu</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    LL ans = -gmu[id] + q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ;</span><br><span class="line">        ans += -(Smu(p / pr[k], k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    pre_sieve(N - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; tot = <span class="number">0</span> ;</span><br><span class="line">        rg LL l, r, w, t ; s = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//先用整除分块预处理g(n,0)</span></span><br><span class="line">            t = n / l ;</span><br><span class="line">            r = n / t ;</span><br><span class="line">            Id[++ tot] = t ;<span class="comment">//(保存每一项，最多只有2*sqrt(n)个)</span></span><br><span class="line">            gmu[tot] = t - <span class="number">1</span> ;<span class="comment">//预处理1，即在j=0时，就是该函数在所有的素数的取值-1</span></span><br><span class="line">            gphi[tot] = calc1(t) - <span class="number">1</span> ;<span class="comment">//预处理n</span></span><br><span class="line">            <span class="keyword">if</span> (n / l &gt; s)</span><br><span class="line">                dex[<span class="number">1</span>][l] = tot ;</span><br><span class="line">            <span class="keyword">else</span> dex[<span class="number">0</span>][n / l] = tot ;<span class="comment">//空间节省</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            w = <span class="number">1l</span>l * pr[i] * pr[i] ; LL now ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; Id[j] &gt;= w ; ++ j)&#123;</span><br><span class="line">                now = Id[j] / pr[i] ;</span><br><span class="line">                now = (now &lt;= s) ? dex[<span class="number">0</span>][now] : dex[<span class="number">1</span>][n / now] ;</span><br><span class="line">                gmu[j] -= gmu[now] - (i - <span class="number">1</span>), <span class="comment">//按照递推式求g1和g2</span></span><br><span class="line">              	gphi[j] -= <span class="number">1l</span>l * pr[i] * (gphi[now] - sp[i - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, Sphi(n, <span class="number">0</span>) + <span class="number">1</span>, Smu(n, <span class="number">0</span>) + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-一点后话"><a href="#5-一点后话" class="headerlink" title="$5$ 一点后话"></a>$5$ 一点后话</h1><p>在写题的过程中发现了另一种写法。大概就是原本 $\rm S$ 的定义是这样的：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)>prime_j]</script><p>然后他们推导的是这样的：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)\geq prime_j]</script><p>这样最后的答案就是 $\mathrm{S}(n,1)+1$ ，在写的时候也需要后移一位。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Min_25筛</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】树的直径泛做</title>
    <url>/2019/12/31/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了做和这一块儿有关的题。</p>
<p><del>说是泛做然而只做了三道题</del></p>
<a id="more"></a>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>嗯，首先就是考虑一点定义。</p>
<ul>
<li>树的直径：一棵树内最长的一条简单路径。</li>
</ul>
<p>然后关于直径有一些性质，大部分都可以拿反证法证出来：</p>
<ul>
<li><p>对树上随便一个点 $x$ 而言，与之相距最远的点一定是直径的某个端点。</p>
<ul>
<li>证明的话可以分类讨论:<ul>
<li><ol>
<li>对于直径上一点 $x$，离他最远点设为 $y$，不在直径上，那么直径完全可以从这个地方拐到 $y$ 从而变得更大，与直径的最优性矛盾。</li>
</ol>
</li>
<li><ol>
<li>对于非直径上一点 $x$，离他最远的点为 $y$，不在直径上。那么考虑设 $x$ 到直径上最近一点 $u$ 的距离为 $d_u$，直径远端的距离为 $d$，到 $y$ 的距离为 $d_y$。那么有 $d_y+d_u&gt;d$ 。于是考虑如果让直径从 $u$ 拐到 $y$ 的话显然会更优，与直径的最优性矛盾。 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定义一棵树的 <strong>中心</strong> 为 $\max_{v\in T}{d_{u,v}}$ 最小的点 $u$，那么 $u$ 在直径上。</p>
<ul>
<li>证明的话考虑如果不在直径上，那么考虑到直径上最近的一点 $p$，发现 $p$ 对于直径的两个端点距离要小于 $p$ 。再结合上面证明过的，对于 $u$ 而言，$\max_{v\in T}{d_{u,v}}$ 一定会在直径上面取到，而 $u$ 的次远点到 $p$ 的距离一定小于 $p$ 到直径端点的距离，所以中心 $u$ 一定在直径上。</li>
</ul>
</li>
</ul>
<p>这两个结论有事还是很有用的2333</p>
<hr>
<p>以上是证明着玩的。接下来考虑直径的求法。</p>
<p>首先就是喜闻乐见的两遍 $dfs/bfs$ 求。大概就是考虑第一遍随便选一个点找一个与他相距最远的点 $u$， 那么 $u$ 一定会在直径上。之后再dfs求一遍最远点即可。由于固定了端点所以就直接脑残求就完了。</p>
<p>然而我是这么 $dfs$ 的。回想起来自己是个憨憨：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是直接 $dp$ ，这个比较傻，维护最长链和次长链即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n), ans = max(ans, dp[n] + dp[to(k)] + val(k)) ;</span><br><span class="line">        dp[n] = max(dp[n], dp[to(k)] + val(k)) ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2 例题"></a>2 例题</h1><h2 id="1-APIO2010-巡逻"><a href="#1-APIO2010-巡逻" class="headerlink" title="1 [APIO2010]巡逻"></a>1 [APIO2010]巡逻</h2><blockquote>
<p>给定一棵树。可以连 $K~(K\in\\{1,2\\})$ 条额外的边使得从 $1$ 号点出发，遍历所有路径一次，使走的走路程最短。</p>
<p>同时有以下约束：</p>
<ul>
<li>每条路必须经过<strong>至少</strong>一次，点可以经过多次。</li>
<li>最后要回到一号点。</li>
</ul>
</blockquote>
<p>发现 $K=1$ 时比较容易考虑，把直径两端连起来放到最后走，这样一定是最优的。于是此时答案为 $2(n-1) - (L-1)=2n-L+1$ 。</p>
<p>然后考虑 $K=2$ 。发现 $K=2$ 时和 $K=1$ 情况大致相似，第一条边连直径。然后考虑第二条边，发现第二条边可能存在连出的圈与第一个圈有相交一部分的情况。但解决方法也很简单，把直径上的边权设置为其相反数即可。</p>
<p>然后就是求两遍直径就完事了233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)] || to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        val(k) = <span class="number">-1</span>, val(k ^ <span class="number">1</span>) = <span class="number">-1</span>, do_do(to(k), n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">			do_dp(to(k), u), </span><br><span class="line">			L2 = max(L2, d[to(k)] + val(k) + d[u]) ; </span><br><span class="line">			d[u] = max(d[u], d[to(k)] + val(k)) ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ;</span><br><span class="line">    dfs(n, <span class="number">0</span>), L1 = d[n] + (<span class="keyword">bool</span>)(K == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, n = pre[n] ;</span><br><span class="line">    vis[n] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; L1 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        do_do(n, <span class="number">0</span>) ;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)) ; </span><br><span class="line">		do_dp(<span class="number">3</span>, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1 &lt;&lt; " " &lt;&lt; L2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * N - L1 - L2 &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-NOIp2007-树网的核"><a href="#2-NOIp2007-树网的核" class="headerlink" title="2 [NOIp2007]树网的核"></a>2 [NOIp2007]树网的核</h2><blockquote>
<p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：</p>
<script type="math/tex; mode=display">
\max_{\begin{aligned}u,v & \in \rm T\\\ u\in V, &v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}</script><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p>
<p>$1\leq n\leq 5,000$</p>
</blockquote>
<p>类比一开始对中心的位置的证明，可以发现这段路径一定在直径上（事实上可以把这段路径缩成一个点来考虑）。然后就考虑先把直径找出来，然后 $n^2$ 枚举路径端点 $(p,q)$ ，$O(n)$ 算一下最长距离，这样是 $O(n^3)$ 的。然而发现可以贪心，链长期望越长，式子的值期望越小。所以可以 $n^2$ 预处理出来直径上离每个点最远且距离 $\leq s$ 的端点，然后 $n^2$ 做即可。最终复杂度 $n^2$。</p>
<h2 id="3-SDOI2011-消防"><a href="#3-SDOI2011-消防" class="headerlink" title="3 [SDOI2011]消防"></a>3 [SDOI2011]消防</h2><blockquote>
<p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：</p>
<script type="math/tex; mode=display">
\max_{\begin{aligned}u,v & \in \rm T\\\ u\in V, &v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}</script><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p>
<p>$1\leq n\leq 500,000$</p>
</blockquote>
<p>……所以其实就是上一道题的加强版。</p>
<p>考虑怎么优化一下 $n^2$ 的算法，发现两部分都需要优化。首先考虑 <code>n^2 预处理出来直径上离每个点最远且距离 ≤ s 端点</code> 这东西，发现完全可以二分，于是变成了 $\log$ ；然后发现后一部分，完全可以一遍 $dp$ 求出来 “离直径上每个点最远的点的距离”这个东西，然后就可以 $\rm rmq$ 解决。然后两部分就都变成了 $n\log n$ 。（当然你也可以认为 $rmq$ 是 $O(\rm C)$ 的）</p>
<p>但实际上可以继续优化。首先发现的是那个二分可以拿尺取法做掉。之后考虑拿出之前整过的结论操作一下。令 $d_u$ 表示直径上一点 $u$ 在不经过直径的情况下，到某个非直径上点的最远距离。设直径的点集为 $l$，起点为 $s$， 终点为 $t$。那么答案就是</p>
<script type="math/tex; mode=display">
\min_{i,j\in l} \\{ \quad \max (dist_{s,i},dist_{j,t},\max_{v\in \mathrm{path}(i,j)} \\{ d_v \\}) \quad \\}</script><p>但是其实里面的最后一项 $\max_{v\in \mathrm{path}(i,j)} \\{ d_v \\}$ 可以被换成 $\max_{v\in l} \\{ d_v \\}$。原因是考虑当前枚举的段外一点（此处默认是在靠 $s$ 近的一侧） $w$ 的 $d_w$ 肯定会小于等于 $dist(s,w)$，而由于 $i$ 在这一段外面，所以 $dist(s,w)&lt;dist(s,i)$ ，也就是说对答案没有贡献，可以直接忽略掉。</p>
<p>于是最后就可以 $O(n)$ 做了。</p>
<p>然后先上一下 $rmq$ 的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        do_do(to(k), u) ;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">        d[u] = max(d[to(k)] + val(k), d[u]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> d[l] ;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt;= r - l) k ++ ;</span><br><span class="line">    k -- ; <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k)][k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span>, res = Inf ; </span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ; </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) rev[s[i]] = i ; </span><br><span class="line">	  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; ~j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) f[i][<span class="number">0</span>] = d[s[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j + (<span class="number">1</span> &lt;&lt; i) &lt;= tot + <span class="number">1</span> ; ++ j)</span><br><span class="line">            f[j][i] = max(f[j][i - <span class="number">1</span>], f[j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)][i - <span class="number">1</span>]) ;</span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = max(ans, d[i]) ; </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ; <span class="comment">//cout &lt;&lt; base[tot] &lt;&lt; " " ; </span></span><br><span class="line">        res = min(res, max(max(base[l], base[tot] - base[r]), query(l, r))) ;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是另一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &lt; b? a : b ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &gt; b? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">    N = read(), S = read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        u = read(), v = read(), w = read(), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = Max(ans, d[s[i]]) ; res = ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ;</span><br><span class="line">        res = Min(res, Max(Max(base[l], base[tot] - base[r]), ans)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    write(res) ; fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>程序猿的生命大多葬送给了调试。</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>动态规划/树形DP</tag>
        <tag>树上技巧/树的直径的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】灭绝树</title>
    <url>/2019/12/30/%E7%81%AD%E7%BB%9D%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来想学支配树，据说和灭绝树就是一个东西，就滚去学了灭绝树。</p>
<p>不过一说到灭绝树，脑海中就会勾勒出一副好久之前的场景，让人怀念……</p>
<a id="more"></a>
<h1 id="1-ZJOI2012-灾难"><a href="#1-ZJOI2012-灾难" class="headerlink" title="1 [ZJOI2012] 灾难"></a>1 [ZJOI2012] 灾难</h1><blockquote>
<p>给定一个 $\rm DAG$，定义灾难值：在一个节点被删去后以它为根从上到下逐步删去入度为 $0$ 的点，最终被删去的点的数量。求每个点的灾难值。</p>
<p>$n \leq 100,000$</p>
</blockquote>
<p>不说构造方面的东西了，直接考虑怎么做。直接建一棵树， $fa_x$ 记录的是这么一个点 $u$，表示如果 $u$ 挂了那么 $x$ 肯定会挂且 $dist(u,x)$ 最小。然后考虑这个东西实际上就是每个 $x$ 的入边的另一个端点在这棵树上的 $\rm LCA$ ，于是考虑边 <code>topsort</code> 边建树。然后子树大小 $-1$ 就是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>], e[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], Head[MAXN], sz[MAXN], cnt1, cnt2 ;</span><br><span class="line"><span class="keyword">int</span> N, deg[MAXN], dep[MAXN], fa[MAXN], anc[MAXN][<span class="number">20</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ cnt1].to = v, e[cnt1].next = head[u], head[u] = cnt1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt2].to = v, E[cnt2].next = Head[u], Head[u] = cnt2 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = Head[u] ; k ; k = E[k].next)</span><br><span class="line">        dfs(E[k].to), sz[u] += sz[E[k].to] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, x, y ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">        <span class="keyword">while</span> (y) add1(y, i), deg[i] ++, <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; deg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) fa[i] = <span class="number">0</span>, q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        q.pop(), add2(fa[n], n) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[n] ; i ; i = e[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[e[i].to] == <span class="number">-1</span>) fa[e[i].to] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[e[i].to] = lca(n, fa[e[i].to]) ;</span><br><span class="line">            <span class="keyword">if</span> (!(-- deg[e[i].to])) q.push(e[i].to) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " " ;</span></span><br><span class="line">    dfs(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (sz[i] - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是很简单的吧？</p>
<h1 id="2-CF757F-Team-Rocket-Rises-Again"><a href="#2-CF757F-Team-Rocket-Rises-Again" class="headerlink" title="2 CF757F Team Rocket Rises Again"></a>2 CF757F Team Rocket Rises Again</h1><p>一道例题？</p>
<blockquote>
<p>给定一个 $n$ 个点，$m$ 条边的带权无向图和起点 $\rm S$。选择一个点 $u$ $(u\not =\rm S)$，使在图中删掉点 $u$ 后，有尽可能多的点到 $\rm S$ 的最短距离改变。</p>
<p>$n\leq 200,000$</p>
</blockquote>
<p>在发现求完一遍最短路这个图变成 DAG之后，这道题就变成了一道傻题。</p>
<p>哦，忘了，有个坑点。他可能给的这个图一开始不连通，所以要判一下 <code>vis</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    E[m][++ cnt[m]].to = v, E[m][cnt[m]].val = w,</span><br><span class="line">    E[m][cnt[m]].next = head[m][u], head[m][u] = cnt[m] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">2</span>][u] ; k ; k = E[<span class="number">2</span>][k].next)</span><br><span class="line">        dfs(E[<span class="number">2</span>][k].to), sz[u] += sz[E[<span class="number">2</span>][k].to] ;</span><br><span class="line">    <span class="keyword">if</span> (vis[u] &amp;&amp; u &amp;&amp; u != S) ans = max(ans, sz[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w),</span><br><span class="line">        add(<span class="number">0</span>, u, v, w), add(<span class="number">0</span>, v, u, w) ;</span><br><span class="line">    q.push(S) ; vis[S] = <span class="number">1</span> ;</span><br><span class="line">    fill(dis + <span class="number">1</span>, dis + N + <span class="number">1</span>, Inf), dis[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ; q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">0</span>][n] ; k ; k = E[<span class="number">0</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[E[<span class="number">0</span>][k].to] &gt; dis[n] + E[<span class="number">0</span>][k].val)&#123;</span><br><span class="line">                dis[E[<span class="number">0</span>][k].to] = dis[n] + E[<span class="number">0</span>][k].val ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[E[<span class="number">0</span>][k].to])</span><br><span class="line">                    vis[E[<span class="number">0</span>][k].to] = <span class="number">1</span>, q.push(E[<span class="number">0</span>][k].to) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[<span class="number">0</span>][i] ; j ; j = E[<span class="number">0</span>][j].next)</span><br><span class="line">            <span class="keyword">if</span> (dis[i] + E[<span class="number">0</span>][j].val == dis[E[<span class="number">0</span>][j].to])</span><br><span class="line">                add(<span class="number">1</span>, i, E[<span class="number">0</span>][j].to, <span class="number">0</span>), deg[E[<span class="number">0</span>][j].to] ++ ;</span><br><span class="line">    fill(vis, vis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    q.push(S), fa[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        q.pop(), vis[n] = <span class="number">1</span>, add(<span class="number">2</span>, fa[n], n, <span class="number">0</span>) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>][n] ; k ; k = E[<span class="number">1</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ww = E[<span class="number">1</span>][k].to ;</span><br><span class="line">            <span class="keyword">if</span> (!(~fa[ww])) fa[ww] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[ww] = lca(fa[ww], n) ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[ww]) q.push(ww) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-吐槽"><a href="#3-吐槽" class="headerlink" title="3 吐槽"></a>3 吐槽</h1><p>这东西在 Luogu 上也能算紫色的？</p>
<h1 id="4-一点回忆"><a href="#4-一点回忆" class="headerlink" title="4 一点回忆"></a>4 一点回忆</h1><p>那是 18 年的 4 月。想来已经是前年了，有些伤感。</p>
<p>当时金牌教练让 rqy 给我们出题考试，题目如下：</p>
<div class="pdf" target="./P0.pdf" height></div>
<p>T1是个有点 tricky 的最小字典序最大独立集，T2就是个灭绝树的板子，T3是个 DLX 的板子。然而当时大家最高分只有 $60$ 分也是有点惨惨。</p>
<p>还记得当时大家几乎都在认真地做 T2，我在做 T1 的前 60 分。然而最后 T1 还是因为边表没开两倍而 RE 挂了 40，大家 T2 都是枚举每个点然后再去 topsort , 可惜当时我连 topsort 也不会。</p>
<p>然后大家考完之后，听完 rqy 讲题就开始研究 T2，发现原来就是“[ZJOI]灾难”那题。然后大家就都去做了那道题。</p>
<p>还记得wx在考场上已经想出了几近正解，当时自己只会膜。</p>
<p>到现在为止，“灾难”这题在Luogu的题解区，地一篇题解依旧是wx的，他的前三条评论依旧是我的。</p>
<p>感觉……有点伤感。不知道是不是机房太冷的缘故，感到大脑有些麻木。是啊，rqy不再是当年的rqy了，LCEZ55级机房也不是之前那个LCEZ55级机房了，也搬到了新校。总之，一切都变了。</p>
<p>倒不是说改变不好，只是那些夕阳下的场景总是让现如今孑然一身的我感到有些无所适从。</p>
<p>看来我就是那被遗忘在时光里的老人了吧。</p>
<p>要说启迪什么的，大概就是不要再等到失去之后发现自己当时有多么愚蠢。</p>
<p>以前总是不理解为什么 rqy 要为了没有人陪他学OI而哭，现在才发现，“哦，原来是这样子的感觉啊”。</p>
<p>『 初闻不解戏中意，如今已是戏中人。』</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>灭绝树</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>图论/灭绝树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Cf Round 250</title>
    <url>/2019/12/30/CFR250/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先呢，做这一场的原因是看了 vfk 的 blog（<a href="https://blog.csdn.net/VFleaKing/article/details/90521383" target="_blank" rel="noopener">戳我</a>）感觉很有趣，并且似乎以前的 CF 的 <code>div1</code> 难度比现在低一点，于是就打算做一下。</p>
<p>嗯，是一场 CNround，可能会更贴合国内的出题氛围？感觉质量还是很好的233.</p>
<p>题号是 $\rm CF437/438$。</p>
<p>向前辈们致敬！</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给出一个四项选择题，三长选一短，三短选一长，否则选 $C$。</p>
<p>其中“短”和“长”限制了 2 倍关系。</p>
</blockquote>
<p>我不会告诉你这题我交了5遍:(</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; L[<span class="number">4</span>] ;</span><br><span class="line"><span class="keyword">char</span> I[<span class="number">4</span>][MAXN] ; <span class="keyword">int</span> ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (I[<span class="number">0</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">1</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">2</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">3</span>] + <span class="number">1</span>) ;</span><br><span class="line">    L[<span class="number">0</span>].sc = <span class="number">0</span>, L[<span class="number">1</span>].sc = <span class="number">1</span>, L[<span class="number">2</span>].sc = <span class="number">2</span>, L[<span class="number">3</span>].sc = <span class="number">3</span> ;</span><br><span class="line">    L[<span class="number">0</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">0</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">1</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">1</span>] + <span class="number">1</span>) - <span class="number">2</span> ;</span><br><span class="line">    L[<span class="number">2</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">2</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">3</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">3</span>] + <span class="number">1</span>) - <span class="number">2</span> ; </span><br><span class="line">  sort(L, L + <span class="number">4</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">3</span>].fr &gt;= L[<span class="number">2</span>].fr * <span class="number">2</span>) ++ ans ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">0</span>].fr * <span class="number">2</span> &lt;= L[<span class="number">1</span>].fr) ans += <span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">3</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ans == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">0</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"C"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给你两个整数$n$, $m$，要求在 $1\sim m$ 中选任意个数 $x_i$，使得 $\sum lowbit(x_i)=n$ 。 </p>
</blockquote>
<p>一开始脑残写了一堆奇怪的东西？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, cnt, ans[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x &amp; (-x)) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        p[i] = make_pair(lowbit(i), i) ;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + M + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= p[i].first)</span><br><span class="line">            N -= p[i].first, ans[++ cnt] = p[i].second ;</span><br><span class="line">    <span class="keyword">if</span> (N) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">    <span class="comment">/*while (N)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; N &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        if (N == lowbit(N))</span></span><br><span class="line"><span class="comment">            ans[++ cnt] = N ;</span></span><br><span class="line"><span class="comment">        else ans[++ cnt] = lowbit(N) ;</span></span><br><span class="line"><span class="comment">        if (ans[cnt] &gt; M) return puts("-1") ;</span></span><br><span class="line"><span class="comment">        else N -= lowbit(N) ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">while</span> (cnt) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[cnt --]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>$n$ 个带权点，$m$ 条无向边，删除一个点就要付出所有与之有相连且没有被删除的点的点权之和的代价。</p>
<p>求删除所有点的最小代价。</p>
<p>$n,m\leq 200,000$</p>
</blockquote>
<p>小清新题，可能需要想一会儿。由于发现最后每条边只会被删一次，且每条边显然都可以做到被小权值的点删掉，于是答案就是 $\sum _{k\in E} \min(val_{from(k)},val_{to(k)})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, j, u, v ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, ans += <span class="number">1l</span>l * min(base[u], base[v]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>给定一张点权图，随机选两个点，求两点间所有简单路径中路径上最小点权的最大值的期望。</p>
<p>$n,m\leq 200,000$</p>
</blockquote>
<p><del>开始时一直读不懂题我好难啊</del></p>
<p>大概就是考虑一遍建生成树一边建生成树一边同记。首先考虑路径一定会在最大生成树上。然后发现由于是最小点权，所以要用小的那个点来统计答案。于是排好序后，对于加入一个点 $u$ 之前的那些点，点权都大于 $u$ 。所以此时 $u$ 可以作为只剩下权值比他大的点时的图中的答案点，统计一下即可。</p>
<p>嗯，是个 trick。记得当时做“货车运输”那题是为了应付作业直接 copy 的同学的代码，导致后来一直不是很熟悉……233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], fa[MAXN], sz[MAXN], Id[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> base[a] &gt; base[b] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) sz[i] = <span class="number">1</span>, fa[i] = Id[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    sort(Id + <span class="number">1</span>, Id + N + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        LL ctn = <span class="number">0</span> ; <span class="keyword">int</span> n = Id[i], f1, f2 ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[n] ; j ; j = next(j))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to(j)]) <span class="keyword">continue</span> ;</span><br><span class="line">            f1 = find(n), f2 = find(to(j)) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ctn += <span class="number">1l</span>l * sz[f1] * sz[f2],</span><br><span class="line">                sz[f1] += sz[f2], fa[f2] = f1 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1l</span>l * base[n] * ctn, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ans * <span class="number">2.0</span> / (<span class="number">1.0</span> * N * (N - <span class="number">1</span>))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给出 $n$ 个点，求这个多边形的三角剖分的方案数对 $1e9+7$ 取模。</p>
<p>$n\leq 200$</p>
</blockquote>
<p>恕我直言…我对三角剖分唯一知道的就是能叉出多边形面积来233</p>
<p>根据数据范围猜算法，发现应该是区间 $dp$ 的形式。$f_{l,r}$ 表示区间 $l,r$ 内的点的三角剖分方案数。那么转移就是考虑</p>
<script type="math/tex; mode=display">
f_{l,r}=\sum_{k=l}^{r} [\mathrm{convex}(l\to k\to r)]\cdot (f_{l,k}\times f_{k,r})</script><p>其中 $[]$ 还是艾佛森括号，$\rm convex$ 函数为一个 $0/1$ 函数，返回给定的三个点对于整个多边形是否是凸的。</p>
<p>然后为了快速判断这个东西，可以先把所有点按照一个方向排一圈，然后叉积求出是否在外侧。</p>
<p>以下是如何用叉积去判:</p>
<p>如果 $a\times b &lt; 0$ 说明 $a$ 在 $b$ 的逆时针方向， $=0$ 说明同向， $&gt;0$ 说明 $a$ 在 $b$ 的顺时针方向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">double</span> s ;</span><br><span class="line">LL f[MAXN][MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    nodes <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (nodes)&#123;a.x - b.x, a.y - b.y&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    s += base[N] * base[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        s += base[i] * base[i + <span class="number">1</span>], f[i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) reverse(base + <span class="number">1</span>, base + N + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">2</span> ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> ((base[i] - base[j]) * (base[k] - base[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                    (f[j][i] += f[j][k] * f[k][i]) %= Mod ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][N] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote>
<p>给定数列，区间查询和，区间取模，单点修改。</p>
<p>$1\leq n,m\leq 100,000,\quad 0\leq a_i\leq 10^9$。</p>
</blockquote>
<p>大概就是发现取模的一个性质，就是取模成功之后数值至少减半。可以分类讨论 $p&gt;\frac{n}{2}$ 和 $p\leq \frac{n}{2}$ ，发现 $n$ 对  $p$ 取完膜之后肯定 $&lt;\frac{n}{2}$ 。</p>
<p>于是这东西就是 $\log$ 的。于是就可以直接 $m \log n + m\log a_i$ 做了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mk, n, m, base[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N &lt;&lt; <span class="number">1</span>] ; LL s[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid) ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) _change(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> _change(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] %= mod, s[rt] %= mod, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, mod) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, mod) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r)) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;v),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;v), _change(<span class="number">1</span>, <span class="number">1</span>, n, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><blockquote>
<p>求每个结点都有个权值只在 $c_1, c_2, …, c_n$中取的，总点权为 $s$ 的二叉树的个数。对于每个 $1 \leq s \leq m$ 计算答案。</p>
<p>$1\leq n,m \leq 10^5$ 。</p>
</blockquote>
<p>发现其实是一个卡特兰数的转移形式。令 $f_n$ 表示总点权为 $n$ 的二叉树个数，那么转移应该这么转移：</p>
<script type="math/tex; mode=display">
f_n=[n=0]+\sum_{p=1}^{m}[p\in c] \sum_{q=0}^{m-p}f_{q}f_{m-p-q}</script><p>发现后面是 $p + q + m-p-q=m$ ，正好是卷积的形式。</p>
<p>那如果设 $\\{ f_n\\}$ 的生成函数为 $\rm F$， $g_x=[x\in c]$，$\\{g_n\\}$ 的生成函数为 $\rm G$，则有：</p>
<script type="math/tex; mode=display">
\rm F = G\times F^2+1</script><p>那么解一下可以得到</p>
<script type="math/tex; mode=display">
\rm F=\frac{1±\sqrt{1-4G}}{2G}</script><p>发现改变一下形式之后：</p>
<script type="math/tex; mode=display">
\rm F=\frac{2}{1±\sqrt{1-4G}}</script><p>这东西，在取负号的时候，分母是不存在逆元的。所以分母取正号。</p>
<p>然后就多项式一顿套就完了233。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gp = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, Gi, R[MAXN] ;</span><br><span class="line">LL G[MAXN], H[MAXN], F[MAXN], t[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> L, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr LL Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        Gn = expow(Gp, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = Gi * Gn % P)&#123;</span><br><span class="line">                rr <span class="keyword">int</span> real = J[j + k], iroot = J[j + k + i] * Gi % P ;</span><br><span class="line">                J[j + k] = (real + iroot) % P, J[j + k + i] = (real - iroot + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Inv = expow(L, P - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Inv(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, <span class="number">1</span>), NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - t[i] * g[i] % P + P) % P * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">LL Ig[MAXN], pf[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _sqr(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)&#123; g[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _sqr(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) Ig[i] = <span class="number">0</span>, pf[i] = <span class="number">2</span> * g[i] % P ;</span><br><span class="line">    _Inv(pf, Ig, len) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) <span class="comment">/* */</span> t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; ( l - <span class="number">1</span> )) ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; NTT(Ig, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, l = <span class="number">1</span> ;</span><br><span class="line">    Gi = expow(Gp, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, ++ K, M = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j), F[j] = <span class="number">1</span> ;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        F[i] = (<span class="number">-4l</span>l * F[i] % P + P) % P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; F[i] &lt;&lt; " " ;</span></span><br><span class="line">    _sqr(F, G, K), (G[<span class="number">0</span>] += <span class="number">1</span>) %= P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; G[i] &lt;&lt; " " ;</span></span><br><span class="line">    _Inv(G, H, K) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, H[i] * <span class="number">2l</span>l % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>动态规划/普通DP</tag>
        <tag>奇怪的技巧</tag>
        <tag>多项式的应用</tag>
        <tag>贪心</tag>
        <tag>组合计数/生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】李超树</title>
    <url>/2019/12/28/%E6%9D%8E%E8%B6%85%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>李超树，一种奇怪的数据结构——然而其实是线段树，用于维护平面优势直线。</p>
<p>顺便学了学标记永久化。</p>
<a id="more"></a>
<p>虽然不知道是谁，但是先orz李超233</p>
<h1 id="1-标记永久化"><a href="#1-标记永久化" class="headerlink" title="$1$ 标记永久化"></a>$1$ 标记永久化</h1><p>似乎李超树不是很好 <code>push_down</code> 的样子，于是去网上学了一发。大概思想就是，线段树区间维护时信息不再打标记，而是选择把标记打在自己身上不再下传。查询的时候一路查下去，记录覆盖在这条路径上的信息，然后基于修改的信息对整个区间的信息合并一下即可。</p>
<p>然后是瞎写的伪代码？Sumblime 3 真好用，自创语法真有趣233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认区间修改 = 区间的每个单点更新信息 </span></span><br><span class="line">Class Segment_Tree&#123;</span><br><span class="line">	Inform * Tag, Val ;</span><br><span class="line">	<span class="keyword">int</span> : L, R, Mid, Lson, Rson ;</span><br><span class="line">	<span class="function">Function <span class="title">Clear</span><span class="params">()</span> </span>&#123;....&#125; ;</span><br><span class="line">&#125;<span class="comment">//其中 *Tag 是当前点维护信息时打的标记，*Val 是当前节点的信息。</span></span><br><span class="line"></span><br><span class="line">Function[Inform] Merge(Inform * n, Inform * m) &#123;....&#125; ;</span><br><span class="line">Function[<span class="keyword">void</span>] Update(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line">	Do_Some_Work(T[root], qL, qR, S) ;</span><br><span class="line">	<span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR)</span><br><span class="line">		<span class="keyword">return</span> T[root].Tag = Merge(S, T[root].tag), <span class="keyword">void</span>() ;  </span><br><span class="line">	<span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">		Update(T, T[root].Lson, qL, qR, S) ;</span><br><span class="line">	<span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">		Update(T, T[root].Rson, qL, qR, S) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">void</span>() ; </span><br><span class="line">&#125;</span><br><span class="line">Function[Inform] Query(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line"><span class="comment">//询问操作，最后一个参数代表一路询问下来的合并标记</span></span><br><span class="line">	Inform * res ; res = EMPTY ; </span><br><span class="line">	<span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR) </span><br><span class="line">		<span class="keyword">return</span> res = Merge(T[root].Val, S) ; </span><br><span class="line">	<span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">		res = Merge(res, Query(T, T[root].Lson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line">	<span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">		res = Merge(res, Query(T, T[root].Rson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line">	<span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-李超树"><a href="#2-李超树" class="headerlink" title="$2$ 李超树"></a>$2$ 李超树</h1><p>首先李超树的最简单操作就是：</p>
<ul>
<li>向平面内添加一条直线</li>
<li>查询覆盖在某个坐标上的直线中，纵坐标值最大/最小值</li>
<li>$n,m\leq 200,000$</li>
</ul>
<p>考虑如何维护这个东西，考虑维护每个点代表区间的<strong>优势直线</strong>，即在大多数区域内<strong>可能</strong>是最优解的那条线——或者，在代表区间的中点是最优解的直线。这么做采用了启发式的思想，保存了有限多的备选最优解。于是就可以保证最后询问的时候，采用标记永久化的思想，取所有覆盖在一个单点上的优势直线的最大值即可，复杂度 $\log n$ 。</p>
<p>那么考虑怎么维护优势区间。假设区间 $\rm [L,R]$ 的优势直线为 $l$ ，现在插入一条直线 $l’$，开始分类讨论：</p>
<ul>
<li>如果当前区间的左端和右端都满足 $l’$ 更优，那么直接拿 $l’$ 替代。</li>
<li><p>如果当前取件的左端和右端都满足 $l’$ 更劣，那么 $l’$ 爱滚哪去滚哪去。</p>
</li>
<li><p>$\mathrm {slope}(l’)&gt;\mathrm{slope}(l)$</p>
<ul>
<li><p>当 $l$ 在中点处的值比 $l’$ 劣时，那么左区间可能要算一波，右区间就一定会是 $l’$ 更优。这个时候为了保证 $l$ 作为潜在的优选方案不丢失，就把 $l’$ 保存在当前区间，把 $l$ 送到自己的左儿子区间。</p>
</li>
<li><p>$l’$ 更劣时，那么右区间可能算一波，当前区间的优势直线也不会变，所以只去改右区间即可。</p>
</li>
</ul>
</li>
<li><p>$\mathrm {slope}(l’)&lt;\mathrm{slope}(l)$</p>
<ul>
<li>同理可证，显然，证毕（</li>
</ul>
</li>
</ul>
<p>于是就上代码，模板题 <code>LG4254 JSOI2008 BlueMarry开公司</code>。注意本题给的直线需要平移一下再用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ; <span class="keyword">int</span> m, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[id] * (x - <span class="number">1</span>) + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">    o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">    q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">    s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (k[v[rt]] &gt; k[id20])</span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v[rt]), v[rt] = id ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, v[rt]), v[rt] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val(x, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span>, l, mid, x)) ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'P'</span>)</span><br><span class="line">            ++ cnt,</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;b[cnt], &amp;k[cnt]),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, cnt) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)query(<span class="number">1</span>, <span class="number">1</span>, n, x) / <span class="number">100</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-一道例题"><a href="#3-一道例题" class="headerlink" title="$3$ 一道例题"></a>$3$ 一道例题</h1><p>例题就是 <code>HEOI2013 Segment</code> 。插入一条<strong>线段</strong>，维护每个横坐标的优势线段编号。</p>
<p>发现魔改一下就可以。然后一个坑点就是斜率为 $\inf$ 的线段要特殊处理一下，然而一开始自己直接把这种线段的 $\max val$ 当作 $\inf$ 算了也是很降智。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 19260817.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M1 39989</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M2 1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> L, m, mk, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * x * k[id] + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">        o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">        q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">        s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">        <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (k[v[rt]] &gt; k[cnt])</span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span>, l, mid, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M1 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M2 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, e, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)&#123;</span><br><span class="line">            ++ cnt ;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;e, &amp;c, &amp;d) ;</span><br><span class="line">            a = w(a), e = g(e), c = w(c), d = g(d) ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; a &lt;&lt; " " &lt;&lt; e &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt; c) swap(a, c), swap(d, e) ;</span><br><span class="line">            <span class="keyword">if</span> (c == a) k[cnt] = <span class="number">0</span>, b[cnt] = max(d, e) ;</span><br><span class="line">            <span class="keyword">else</span> k[cnt] = (<span class="keyword">double</span>)(d - e) / (<span class="keyword">double</span>)(c - a),</span><br><span class="line">                 b[cnt] = <span class="number">1.0</span> * d - <span class="number">1.0</span> * c * k[cnt] ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; k[cnt] &lt;&lt; " " &lt;&lt; b[cnt] &lt;&lt; endl ;</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, a, c, cnt) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), x = w(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L = query(<span class="number">1</span>, <span class="number">1</span>, n, x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>李超树</category>
      </categories>
      <tags>
        <tag>数据结构/李超树</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】对抗搜索与Alpha-Beta剪枝</title>
    <url>/2019/12/28/%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学了一下比较简单的博弈模型的常规求解方式，发现就是爆搜。顺便学了有启发式思想的 Alpha-Beta 剪枝，现在觉得是玄学……可能还是记搜比较靠谱？</p>
<a id="more"></a>
<h1 id="1-对抗搜索"><a href="#1-对抗搜索" class="headerlink" title="1 对抗搜索"></a>1 对抗搜索</h1><p>……然而其实就是搜索。每次大概就是记录一下双方的决策结果和（哈希之后的）局面，然后改谁走谁走就完了。伪代码大概可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">	Value res = -Inf ;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMin(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &gt; res] res = now ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">	Value res = Inf ;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMax(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &lt; res] res = now ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> res ;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概就是交替迭代的思想。</p>
<p>考虑一棵博弈树，节点承载的信息是局面 。那么对于一个零和博弈游戏，双方必然是让自己得益更多，于是考虑转化一下，令局面的分数为「先手的分数 - 后手的分数」，那么先手就是最大化局面分数，后手则是最小化。</p>
<p>于是定义轮到<strong>最大化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Max}$<strong>节点</strong>，轮到<strong>最小化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Min}$<strong>节点</strong> 。那么显然在博弈树上同类节点集合是一个独立集。这种博弈也叫做 <strong>零和博弈完全信息公平博弈</strong> ，双方的目的均是 <strong>最值化局面分数</strong>。</p>
<h1 id="2-Alpha-Beta-剪枝"><a href="#2-Alpha-Beta-剪枝" class="headerlink" title="2 Alpha-Beta 剪枝"></a>2 Alpha-Beta 剪枝</h1><p>然后这东西就是一个剪枝，给每个节点一个 $\alpha$ 下界和 $\beta$ 上界。类比状态转移，考虑相邻的状态，大致如下：</p>
<ul>
<li><p>假设当前节点为 $\boldsymbol{Max}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Max}$ 状态的分数 $&gt;$ <strong>上一层</strong>决策的分数<strong>上限</strong> $\beta’$，那么当前节点的父亲节点，$\boldsymbol{Min}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Max$ 决策。</p>
</li>
<li><p>假设当前节点为 $\boldsymbol{Min}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Min}$ 状态的分数 $&lt;$ <strong>上一层</strong>决策的分数<strong>下限</strong> $\alpha’$，那么当前节点的父亲节点，$\boldsymbol{Max}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Min$ 决策。</p>
</li>
<li><p>于是我们记录 $\alpha$ 值为每个 $\boldsymbol{Max}$ 状态的<strong>得分下界</strong>，$\beta$ 值为每个 $\boldsymbol{Min}$ 状态的得分下界。初始为 $\alpha=-\infty,\beta=+\infty$</p>
</li>
<li><p>考虑优化的意义。当前状态的分支可能有很多，但是如果在搜第一个分支的时候就发现已经有 $\alpha_n&gt;\beta_{fa_n}$ 了，那么 $fa_n$ 就一定不会走这个决策（毕竟最次也可以让对方得益），于是剩下的分支就不用再搜了。</p>
</li>
<li><p>显然，这种决策是启发性的。同时有以下特点：</p>
<ul>
<li><p>决策顺序影响时间效率。如果每次搜都在第一次跳出自然可以让时间上做到最优，但是如果每次都在最后一次跳出就是压根没剪。</p>
</li>
<li><p>不可以裸的记忆化。考虑每个节点如果要记忆化，记下来的应该是当前状态能扩展到的最优局面。但是 Alpha-Beta 剪枝的目的就是在未得到这个点的最优决策时，已经知道该不该继续走。</p>
</li>
</ul>
</li>
</ul>
<p>然后就是伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S, Value alpha, Value beta)</span></span>&#123;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMin(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &gt; alpha] alpha = now ;</span><br><span class="line">		<span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> alpha ;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> alpha ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S, Value alpha, Value Beta)</span></span>&#123;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMax(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &lt; beta] beta = now ; </span><br><span class="line">		<span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> beta ;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> beta ;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的话，我们顶多是能快速计算谁赢谁输而不是赢多少/输多少。于是考虑魔改一下：</p>
<p>版本一：某一方获利最多。参考题目：[九省联考]一双木棋，可以拿到 $70pts$</p>
<p>其实就是修改一下终态的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet, <span class="keyword">int</span> sa, <span class="keyword">int</span> sb)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (dep &gt;= N * M) <span class="keyword">return</span> sa - sb ; <span class="keyword">int</span> val, b = dep &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    memset(R[b], 0, sizeof(R[b])) ;</span></span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "A" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa + A[i][j], sb) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span> ; alp = max(val, alp) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> alp ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "B" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa, sb + B[i][j]) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> bet ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本二：败方存活时间最长。参考题目：[CQOI2013]棋盘游戏，可以拿到 $40pts$</p>
<p>这种的话就直接返回 $-1^{\text{胜方}}\times \text{深度}$ 即可，最大化的就是败方存活的最大深度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> xa, <span class="keyword">int</span> ya, <span class="keyword">int</span> xb, <span class="keyword">int</span> yb, <span class="keyword">bool</span> w, <span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt; <span class="number">3</span> * N) <span class="keyword">return</span> _d_a_y ;</span><br><span class="line">    <span class="keyword">if</span> (xa == xb &amp;&amp; ya == yb) <span class="keyword">return</span> w ? -step : step ; <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">if</span> (!w)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = xa + dx[i], ky = ya + dy[i] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                val = dfs(kx, ky, xb, yb, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                alp = max(alp, val) ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = xb + dx[i], ky = yb + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            val = dfs(xa, ya, kx, ky, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">            bet = min(val, bet) ; <span class="keyword">if</span> (bet &lt;= alp) <span class="keyword">return</span> bet ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bet ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-两道例题"><a href="#3-两道例题" class="headerlink" title="3 两道例题"></a>3 两道例题</h1><p>uva好啊。</p>
<h2 id="1-UVA10111-Find-the-Winning-Move"><a href="#1-UVA10111-Find-the-Winning-Move" class="headerlink" title="$(1$ UVA10111 Find the Winning Move"></a>$(1$ UVA10111 Find the Winning Move</h2><blockquote>
<p>两人下 $4\times 4$ 的井字棋，给出一个残局，问是否有先手必胜策略。</p>
<p>井字棋：必须要四子连珠才能赢。</p>
</blockquote>
<p>这东西只问赢没赢，于是就可以愉快地把局面分数赋为 $1/-1$。搜就完事了233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">        res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[i][j] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[j][i] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][<span class="number">5</span> - i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = (ans - step) &amp; <span class="number">1</span>, val ;</span><br><span class="line">    <span class="keyword">if</span> (!st)&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">2</span>) || !step) <span class="keyword">return</span> -check(<span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">1</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt; alp)&#123;</span><br><span class="line">                        alp = val ;</span><br><span class="line">                        <span class="keyword">if</span> (step == ans)</span><br><span class="line">                            resx = i - <span class="number">1</span>, resy = j - <span class="number">1</span> ;</span><br><span class="line">                        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">1</span>) || !step) <span class="keyword">return</span> check(<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">2</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                    <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> bet ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'$'</span>) <span class="keyword">return</span> <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, bc[i] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">                base[i][j] = bc[i][j] == <span class="string">'x'</span> ? <span class="number">1</span></span><br><span class="line">                          : (bc[i][j] == <span class="string">'.'</span> ? <span class="number">0</span> : <span class="number">2</span>) ;</span><br><span class="line">                ans += (!base[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= <span class="number">12</span>) &#123; <span class="built_in">puts</span>(<span class="string">"#####"</span>) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line">        ans = battle(ans, <span class="number">-1</span>, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>, resx, resy) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"#####"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-UVA751-Triangle-War"><a href="#2-UVA751-Triangle-War" class="headerlink" title="$(2$ UVA751 Triangle War"></a>$(2$ UVA751 Triangle War</h2><blockquote>
<p>给出 $10$ 个点，共有 $18$ 条边，每次 $A,B$ 两个人轮流加入一条边。A先加。</p>
<p>如果形成一个三角形，则三角形归他所有，<strong>而且还必须再走一步</strong>。最后三角形多的人胜。</p>
<p>现在已经给出一部分已经完成的步数，由于两位玩家都是<strong>最聪明的</strong>，他们都会走<strong>为自己带来最大优势</strong>的步数。你需要判断谁会赢得游戏。</p>
</blockquote>
<p>一道憨憨题。发现可以直接状压且每个询问图不变，所以果断<del>打开题解找到思路差不多的把打的表copy过来</del>手推。然后其实就是一开始先把初始状态走完，然后因为一共九个三角形，所以如果一方比另一方多 $5$ 个游戏就结束了，于是发现可以把这个差值当做局面分数，搜就完事了。</p>
<p>还有一个烂大街的 $trick$，按秩转移每条边于是想到 $\rm lowbit$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q, T, M, A[N][N], st[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e[<span class="number">11</span>][<span class="number">11</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">17</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">16</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t[<span class="number">9</span>] = &#123;<span class="number">7</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">448</span>, <span class="number">3584</span>, <span class="number">6160</span>, <span class="number">28672</span>, <span class="number">49280</span>, <span class="number">229376</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span></span>&#123;</span><br><span class="line">    rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (((p &amp; t[i]) != t[i]) &amp;&amp; ((q &amp; t[i]) == t[i])) ++ ret ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">0</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">1</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> O = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>, ss ;</span><br><span class="line">    <span class="keyword">int</span> _rest = s ^ O, now, val ;</span><br><span class="line">    <span class="keyword">for</span> ( ; _rest ; _rest -= low(_rest))&#123;</span><br><span class="line">        now = calc(s, ss = s | low(_rest)) ;</span><br><span class="line">        <span class="keyword">if</span> (n)</span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            bet = min(bet, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            alp = max(alp, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n ? bet : alp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T, Q = T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M) ;</span><br><span class="line">        st[<span class="number">0</span>] = st[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> _state = <span class="number">0</span>, n = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, z, i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), </span><br><span class="line">            z = calc(_state, _state | (<span class="number">1</span> &lt;&lt; e[x][y])) ;</span><br><span class="line">            _state |= (<span class="number">1</span> &lt;&lt; e[x][y]), st[n] += z, n ^= (((<span class="keyword">bool</span>)z) ^ <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; _state &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game %d: "</span>, Q - T) ;</span><br><span class="line">        <span class="keyword">if</span> (battle(n, _state, <span class="number">-23333</span>, <span class="number">23333</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"A wins.\n"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"B wins.\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学这个就图一乐。想得高分请记搜/kel。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>搜索/剪枝</tag>
        <tag>博弈论/对抗搜索</tag>
        <tag>博弈论/Alpha-Beta剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】构造题选做 · 2</title>
    <url>/2019/12/24/%E6%9E%84%E9%80%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没啥特别原因，就是底下那篇文章题太多了就分流出一部分。</p>
<a id="more"></a>
<h3 id="1-UVa1697"><a href="#1-UVa1697" class="headerlink" title="$1$ UVa1697"></a>$1$ UVa1697</h3><blockquote>
<p>给定一排长度为 $4n$ 的格子，编号从 $-2n+1$ 到 $2n$ 每个编号为正的格子中有一个物品，其中每个编号为奇数的格子中有一个 $B$ 类物品，编号为偶数的格子中有一个 $A$ 类物品。</p>
<p>你只能进行一种操作：选择某两个相邻的都有物品的格子，移动到另外两个相邻的空格子中，同时不能改变两个格子的相对位置。</p>
<p>要求进行最少的操作使得所有物品以 <code>AAA…ABBB…B</code> ($n$ 个 $A$ 和 $n$ 个 $B$) 的形式排列在一起 输出一种可行方案 </p>
<p>$3\leq n \leq 100$</p>
</blockquote>
<p>人类智慧学不来了orz</p>
<p>考虑 $n=3,4,5,6,7$ 的时候都可以人类智慧。那么对于 $n &gt; 7$ 时考虑增量构造，即从 $n$ 构造到 $n+4$。</p>
<p>那么 $n=4$ 时可以这么构造：</p>
<blockquote>
<p><code>__babababa</code></p>
<p><code>abbabab__a</code></p>
<p><code>abba__bbaa</code></p>
<p><code>a__abbbbaa</code></p>
<p><code>aaaabbbb__</code></p>
</blockquote>
<p>然后考虑对于 $n+4$，记 $|BA|$  表示有一堆 <code>bababa</code> 这种东西。</p>
<p>那么考虑 $n+4$ 可以这么玩：</p>
<blockquote>
<p><code>__|BA|</code></p>
<p><code>ab|BA|b__a</code></p>
<p><code>abba__|BA|bbaa</code></p>
</blockquote>
<p>发现中间那一段和起始状态是一样的，就可以大力递归，回代的时候回代一下即可。</p>
<p>$n=3\sim 7$ 我选择直接从网上抄来别人的人类智慧，毕竟我莫得智慧.jpg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" to "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = R - L + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">3</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(<span class="number">2</span>, <span class="number">-1</span>), oo(<span class="number">5</span>, <span class="number">2</span>), oo(<span class="number">3</span>, <span class="number">-3</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">4</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">5</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">5</span>), oo(L - <span class="number">1</span>, L + <span class="number">2</span>), oo(L + <span class="number">6</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">7</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">8</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">6</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">9</span>, L - <span class="number">2</span>), oo(L + <span class="number">6</span>, L + <span class="number">9</span>), oo(L + <span class="number">1</span>, L + <span class="number">6</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">1</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">10</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">7</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">4</span>, L + <span class="number">7</span>), oo(L + <span class="number">11</span>, L + <span class="number">4</span>),</span><br><span class="line">               oo(L + <span class="number">2</span>, L + <span class="number">11</span>), oo(L + <span class="number">8</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">8</span>), oo(L + <span class="number">12</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    oo(R - <span class="number">2</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, R - <span class="number">2</span>), work(L + <span class="number">4</span>, R - <span class="number">4</span>), oo(L - <span class="number">1</span>, R - <span class="number">5</span>), oo(R - <span class="number">1</span>, L - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) work(<span class="number">1</span>, N * <span class="number">2</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-BZOJ4148-Pillars"><a href="#2-BZOJ4148-Pillars" class="headerlink" title="$2$ BZOJ4148 Pillars"></a>$2$ BZOJ4148 Pillars</h3><blockquote>
<p>给定一个 $n\times m$ 的矩形，其中有 $f$ 个 $2\times 2$ 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 $6$，且每个障碍物的中心到边缘的距离至少为 $3$。</p>
<p>请找到一条从左下角 $(1,1)$ 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。</p>
<p>保证 $n,m$ 均为偶数，且 $1\leq n,m\leq 1000$ .</p>
</blockquote>
<p>就是考虑如果没有障碍的走法，由于 $n,m$ 都是偶数，所以可以从 $(1,1)$ 上到 $(1,n)$，然后从 $(1,n)$ 到 $(n,n)$ 再到 $(n,n-1)$ 再到 $(2,n-1)$ 这么蛇形走。</p>
<p>考虑有了障碍，因为每个障碍可以看做是独立的的，所以大概可以这么走：</p>
<p><img src="qwq.png" alt></p>
<p>其中紫色是障碍，黄色是原来的路线，红色是新的。由于 $6$ 的限制，所以可以这么绕。</p>
<p>所以是道细节题233</p>
<p>代码先鸽着，什么时候有心情再写。s</p>
<h3 id="3-【UR-6】-智商锁"><a href="#3-【UR-6】-智商锁" class="headerlink" title="$3$ 【UR #6】 智商锁"></a>$3$ 【UR #6】 智商锁</h3><blockquote>
<p>构造一个节点数不超过 $100$ 的无向图，使其生成树个数对 $998244353$ 取模的结果为 $k$ 。</p>
<p>$k\leq 10^9$</p>
</blockquote>
<p>看题，仔细一想，莫非是什么神秘的 $\boldsymbol{EGF}$ 大力乱搞（警觉）。</p>
<p>结果人傻了……以下是官方做法：</p>
<p>考虑如果两个图只有一个公共点，那么生成树个数为两个图相乘。那么随机 $1000$ 个随机无向图，两两拼凑出 $10^6$ 个无向图，然后对每一个在 <code>map</code> 里找 $k$ 的逆元即可。<del>如果没有就再随机一遍。</del></p>
<p>发现这样实际上几乎不可能没有解。。。</p>
<p><img src="http://img.uoj.ac/utility/bear-thinking.gif" alt="思考熊"></p>
<p>降智打击.jpg</p>
<h3 id="4-【UNR-1】Jakarta-Skyscrapers"><a href="#4-【UNR-1】Jakarta-Skyscrapers" class="headerlink" title="$4$  【UNR #1】Jakarta Skyscrapers"></a>$4$  【UNR #1】Jakarta Skyscrapers</h3><blockquote>
<p>有一个数集，最初其中只有 $a$ 和 $b$。</p>
<p>你可以进行最多 $400$ 次操作，每次选择集合中满足 $i&gt;j$ 的 $i$ 和 $j$，把 $i-j$ 加入集合中，使得最后 $c$ 在这个集合中。</p>
<p>$a,b,c\leq 10^{18}$</p>
</blockquote>
<p>考虑构造中间状态。发现可以用 $a-(a-b-c)$ 构造 $b+c$， 可以用 $a-(a-b-b)$ 构造倍增，于是考虑先辗转相除得到 $1$，然后倍增，然后就没了。注意，如果一开始 $(a,b) \not|~c$ 的话是无解的。那么考虑同除<br>$(a,b)$ 就可以快乐地更相减损得到 $1$ 了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】构造题选做 · 1</title>
    <url>/2019/12/24/%E6%9E%84%E9%80%A01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从网课和 <code>uoj</code> 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。</p>
<a id="more"></a>
<h3 id="1-神秘的题目"><a href="#1-神秘的题目" class="headerlink" title="1 神秘的题目"></a>1 神秘的题目</h3><p>设 $f_A$ 表示 $A$ 的本质不同子串个数<br>给出 $x, y$，要求构造出两个字符串 $A, B$<br>满足：<br>$f_A = x , f_B = y , f_{A+B} = x + y$</p>
<p>$x, y ≤ 5000$</p>
<hr>
<p>考虑 $x$ 个 $a$，$y$ 个 $a$ ，然后拼起来就好……</p>
<h3 id="2-CF743C"><a href="#2-CF743C" class="headerlink" title="2 CF743C"></a>2 CF743C</h3><p>给出 n，构造出 x, y, z，满足：</p>
<script type="math/tex; mode=display">
\frac{2}{n} = \frac{1}{x}+\frac{1}{y}+\frac{1}{z}\\\
x\not= y, x\not= z, y\not= z</script><p>无解输出 −1<br>$n ≤ 10^4$</p>
<hr>
<p>考虑通分（分时裂项），即</p>
<script type="math/tex; mode=display">
\frac{1}{n}-\frac{1}{n+1}=\frac{1}{n(n+1)}\\\
\frac{1}{n}=\frac{1}{n+1}+ \frac{1}{n(n+1)}\\\
\frac{2}{n}=\frac{1}{n} + \frac{1}{n+1}+ \frac{1}{n(n+1)}</script><p>然后就做完了。</p>
<p>注意1要特判。</p>
<h3 id="3-CF359B"><a href="#3-CF359B" class="headerlink" title="3 CF359B"></a>3 CF359B</h3><p>给出 $n, k , 2k ≤ n$，构造出 $2n$ 的一个排列，满足：</p>
<script type="math/tex; mode=display">
∑^n_{i=1} |a_{2i−1} − a_{2i}| − |∑^n_{i=1}(a_{2i−1} − a_{2i})| = 2k</script><p>$n ≤ 50000$</p>
<hr>
<p>寄几想了一种构造，就是$a_{i+1} = a_i+k,~i=2p,~p \in \mathbb{N+}$，然后随便两次交换两项就好了。然而并不对，因为这样构造出的结果并不合法；于是遂决定改成$a_{i+1} = a_i+2k,~i=2p,~p \in \mathbb{N+}$，但也不对，单次交换的步长太长了，是$4k$。于是我又想能否有什么诡异的交换方法可以补救回来$2k$……失败了qaq</p>
<p>然而其实很简单，我们只要把步长控制为$1$就一定能凑出来。所以一开始先令$a_i=a_{i+1}+1$这种感觉，然后交换$k$次即可。</p>
<h3 id="color-violet-4-rm-CF-it-512E"><a href="#color-violet-4-rm-CF-it-512E" class="headerlink" title="$\color{violet}{4~ \rm{CF}\it{512E}}$"></a>$\color{violet}{4~ \rm{CF}\it{512E}}$</h3><p>对于一个正 n 边形，可以用 n − 3 条边分成 n − 2 个三角形<br>给出两种划分，你需要进行若干次操作把第一种划分变成第二种划分<br>每次操作选择一个四边形删去它的对角线，连另外一条对角线<br>n ≤ 1000，操作次数不超过 20000</p>
<hr>
<p> 开始掉线……</p>
<p>其实主要思想就是<del>酱油瓶</del>状态替换，把起始状态 $s$ 变成对角线都从 $1$ 出发的状态 $p$，再从 $p$ 出发变成终态 $t$。</p>
<p>具体操作好像是</p>
<p>别想了，掉线了怎么可能还会有？</p>
<h3 id="5-神秘的题目"><a href="#5-神秘的题目" class="headerlink" title="$5$ 神秘的题目"></a>$5$ 神秘的题目</h3><blockquote>
<p>给出一棵树，定义一个点的邻居集合为到它距离 $\leq 2$ 的所有点。</p>
<p>给出所有点的邻居集合，还原原树。</p>
<p>$n\leq 1,000$</p>
</blockquote>
<p>考虑一个结论，如果两个点的邻居集合交集大小为 $2$， 那么交集中的点一定有连边。（$\rm bitset$ 做到 $\frac{n^3}{w}$）</p>
<p>于是就可以先把 <strong>非叶子节点</strong> 两两之间的连边求出来</p>
<p>然后考虑如何求出叶子。发现叶子有个性质，就是叶子到某些非叶节点的距离一定 $=$ 与之相邻的非叶节点到某些非叶节点的距离 $+1$。所以就可以再把离每个非叶节点距离为 $1$ 的非叶节点求出来，称这个点集为<strong>旁边集合</strong>。那么如果叶子 $u$ 的邻居集合与非叶节点 $v$ 的旁边集合相同，那么 $u$ 就一定挂在 $v$ 上。</p>
<h3 id="6-AT3877"><a href="#6-AT3877" class="headerlink" title="$6$ AT3877"></a>$6$ AT3877</h3><blockquote>
<p>给定 $\rm X,Y$， 给出 $[d_{i,j}]$ 表示当 $\mathrm X=i,\mathrm Y=j$ 时，$\rm S$ 到 $\rm T$ 的最短路。</p>
<p>构造这张图，使之点数 $&lt;300$，无自环和重边，每条边的权值 $\leq 100$， 权值可以是数也可以是 $\rm X,Y$，并给出 $\rm S,T$ 。</p>
</blockquote>
<p>设 $g_{i,j}$ 表示从 $\rm S$ 到 $\rm T$ ，经过了包含 $i$ 条 $\rm X$ 边， $j$ 条 $\rm Y$ 边的路径，其它边的边权最小和。</p>
<p>那么发现这东西可以这么转移出 $[d_{i,j}]$来</p>
<script type="math/tex; mode=display">
d_{i,j}= \min_{p,q}{(p\cdot i+q\cdot j + g_{p,q})}</script><p>然后可以得到松弛条件</p>
<script type="math/tex; mode=display">
\forall p,q, \quad \exists~ d_{i,j}\leq p\cdot i+q\cdot j+g_{p,q}</script><p>移项可以得到</p>
<script type="math/tex; mode=display">
g_{p,q}=\max_{i,j}{(d_{i,j}-p\cdot i - q\cdot j)}</script><p>于是考虑求出 $g $ ，之后反推出 $[d_{i,j}]’$ 观察是否吻合。吻合则考虑根据经过的 $\rm X,Y$ 连边即可。</p>
<h3 id="7-ARC-095F"><a href="#7-ARC-095F" class="headerlink" title="$7$ ARC 095F"></a>$7$ ARC 095F</h3><blockquote>
<p>给定一棵树 $\rm T$, 要求构造一个排列 $p$ .</p>
<p>对于每一个 $p_i$ ，找到最大的 $j$ 使得 $p_j&lt;p_i$，然后在 $i,j$ 间连边。</p>
<p>问是否可以构造出与 $\rm T$ 同构的树。</p>
<p>如果可以，则给出字典序最小的排列。</p>
<p>$n\leq 100,000$</p>
</blockquote>
<p>反向考虑，观察对于一个排列生成的树。按照排列的权值升序操作，维护最靠右的位置 $mxp$ 即可。</p>
<p>然后发现由于一个排列不可能同时有两个最大值，这样生成的树一定会是一根长链周围分散着单点。</p>
<p>于是考虑把直径抽出来，对上面的点扫一遍。遇到有挂在上面的肯定考虑从小到大放在前面，然后就没有然后了。</p>
<p>可能实现还不太会，要再想想。</p>
<h3 id="8-小题整理"><a href="#8-小题整理" class="headerlink" title="$8$ 小题整理"></a>$8$ 小题整理</h3><p>8.1 覆盖</p>
<blockquote>
<p>平面上给定 $n$ 个点，每个点可以覆盖 $\frac{1}{4}$ 的平面，求最少需要多少个点才能覆盖所有点</p>
</blockquote>
<hr>
<p>orz我和ouuuyuuu一开始觉得题很傻，最多四个，结果发现原来最多两个就可以，然后发现我们很傻。。</p>
<p>找某一维坐标最大/最小的两个点，再判一下是不是只需要一个点就可以满足，就做完了。</p>
<p>8.2 CF477B</p>
<blockquote>
<p>有 $n$ 个集合，彼此交集为空。</p>
<p>每个集合有 $4$ 个元素，两两之间均有 $\gcd = k$</p>
<p>求 $4n$ 个数中最大值的最小值</p>
<p>$1\leq n\leq 10000$</p>
</blockquote>
<p>发现可以同除以 $k$ ，于是就变成两两互质了，于是 $4$ 个数中至多 $1$ 个偶数。</p>
<p>同时发现一个<del>鬼能发现的</del>性质，就是相邻两个奇数一定互质，那么就构造 </p>
<script type="math/tex; mode=display">
\mathrm{S}:\{6i-1,6i-3,6i-5,6i-4 \}</script><p>可知它们互质。然后就没了。</p>
<h3 id="9-CF-527D"><a href="#9-CF-527D" class="headerlink" title="$9$ CF 527D"></a>$9$ CF 527D</h3><blockquote>
<p>每个元素有一个 $a_i$ 一个 $b_i$ .</p>
<p>求一个最大的点集使得 $\forall p,q\in \mathrm{S},\quad |a_p-a_q|\geq b_p+b_q$</p>
<p>$n\leq 200,000$</p>
</blockquote>
<p>我丢，其实就是把每个元素看做 $(a_i-b_i,a_i+b_i)$ 这么一段区间，然后求的就是最长不相交的区间个数。</p>
<p>然后就没了……就没了……</p>
<h3 id="10-ARC-084D"><a href="#10-ARC-084D" class="headerlink" title="$10$ ARC 084D"></a>$10$ ARC 084D</h3><blockquote>
<p>求出 $K$ 的倍数中，各位数字的和最小的那个数字的数字和。</p>
<p>$K \leq 100,000$</p>
</blockquote>
<p>考虑从 $i$ 到 $i+1$ 连一条长度为 $1$ 的边，$i$ 到 $10\cdot i$ 连长度为 $0$ 的边。然后按照$\bmod k$ 的余数建边，最后就是  $1\to 0$ 的最短路。</p>
<h3 id="11-神秘的题目"><a href="#11-神秘的题目" class="headerlink" title="$11$ 神秘的题目"></a>$11$ 神秘的题目</h3><blockquote>
<p>给出一张 $n \cdot m$ 的网格图，曼哈顿距离为 $2$ 或 $3$ 的点之间连一条边，构造出一条哈密尔顿回路。</p>
<p>可能无解。哈密尔顿回路：经过每个点恰一次。</p>
</blockquote>
<p>发现可以走法可以是棋盘染色，即黑白相间染色，先走完黑色再走完白色。</p>
<p>发现只有 $n=2,m=2$ 时无解。当 $\min(n,m)=1$ 时，考虑 $(1,2),(1,3),(2,4),(2,5)$ 都必须连（保证有回路），剩下的瞎构造即可。</p>
<h3 id="12-CF-468A"><a href="#12-CF-468A" class="headerlink" title="$12$ CF 468A"></a>$12$ CF 468A</h3><blockquote>
<p>用 $1\sim n$ 的所有数凑出 $24$，输出方案。</p>
<p>每个数都要用，只能用 <code>+</code>、<code>-</code>、<code>×</code> 三种运算。 $n\leq 100,000$</p>
</blockquote>
<p>发现 $n\leq 3$ 显然不行。</p>
<p>然后 $n=4$ 的时候阶乘即可，$n=5$ 的时候发现可以 $5\times 3+4\times 2+1$ 这么算。</p>
<p>然后考虑 $n&gt;5$，那么 $n$ 一定可以由 $n-2$ 推过来，因为只要乘上 $n-(n-1)$ 即可。发现这样总是可以构造出来合法解。</p>
<h3 id="13-Loj-525"><a href="#13-Loj-525" class="headerlink" title="$13$ Loj #525"></a>$13$ Loj #525</h3><blockquote>
<p>给定一个正整数 $k$，你需要寻找一个系数均为 $0$ 到 $k−1$ 之间的非零多项式 $f(x)$，满足对于任意整数 $x$ 均有 $f(x)≡0~(\bmod k)$</p>
<p>要求 $\deg(f)\leq 60000$</p>
<p>$k\leq 30000$<br>首先发现只要对 $0\sim k-1$ 成立那么就满足条件。 <del>然后就变成傻题了，分治FFT！分治FFT！</del></p>
</blockquote>
<p>然而分治FFT会T。不妨令 $q\geq \varphi(k)$，则由于扩展欧拉定理有：</p>
<script type="math/tex; mode=display">
x^q\equiv x^{q\bmod \varphi(k)+\varphi(k)}(\mod k)</script><p>那么如果令 $v=q+\varphi(k)$，就会有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^v & \equiv x^{v\bmod \varphi(k)+\varphi(k)} (\bmod k) \\\ &\equiv x^{(q\bmod \varphi(k)+\varphi(k) \bmod \varphi(k))\bmod \varphi(k) +\varphi(k)} (\bmod k)\\\ & \equiv x^{q\bmod \varphi(k)+\varphi(k)}(\bmod k)\\\ & \equiv x^q(\bmod k)
\end{aligned}</script><p>然后就构造第 $\varphi(k)$ 项系数为 $k-1$，第 $2\cdot \varphi(k)$ 项系数为 $1$ 即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【练习记录】之前的杂题整理（To Be Continued....）</title>
    <url>/2019/12/22/%E6%9D%82%E9%A2%98%E6%B3%9B%E5%81%9A%C2%B7%E4%B9%8B%E5%89%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是 <code>CSP-S 2019</code> 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……</p>
<a id="more"></a>
<hr>
<p>1、<a href="https://www.luogu.com.cn/problem/P1357" target="_blank" rel="noopener">LG5317 花园</a></p>
<p>发现一共只有两种方格，并且转移只跟 $\rm M$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p>
<p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，然后就快速幂。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波。</p>
<p>2、<a href="https://www.luogu.com.cn/problem/P4318#submit" target="_blank" rel="noopener">LG4218 完全平方数</a></p>
<p>一道傻题，大概就是考察 $\mu$ 的性质。</p>
<ul>
<li><p>$\rm Algorithm~1$</p>
<ul>
<li>发现可以容斥，且 $\mu$ 函数的性质在于，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子且 $x$ 的不同素因子个数为 $k$。所以就考虑先二分，二分完了求一下 </li>
<li><script type="math/tex; mode=display">
\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \frac{n}{i^2}\rfloor</script><ul>
<li>就变成傻题了。复杂度 $T \cdot \sqrt n \log n$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>顺便记录一个很绝的 <code>idea</code></p>
<ul>
<li><p>$\rm Algorithm~2$</p>
<ul>
<li><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p>
<ul>
<li><script type="math/tex; mode=display">
\sum _{i=1}^{x}\mu^2(x)\leq K</script><p>然后我们发现这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><del>但显然杜教筛被暴力给爆锤了好吗</del></p>
<p>3、[]</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>技巧/状态压缩</tag>
        <tag>容斥/暴力容斥</tag>
        <tag>数学/线性代数/矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【游记】CSP-S2019游记</title>
    <url>/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想不到吧，还有这个时候写游记的。</p>
<p>在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233</p>
<p>这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。</p>
<a id="more"></a>
<h1 id="rm-Day-quad"><a href="#rm-Day-quad" class="headerlink" title="$\rm Day\quad -???$"></a>$\rm Day\quad -???$</h1><p>LCEZ机房终于只剩8个人了。</p>
<p>分别是经常会灵光一现的wxl，稳得一批的yjk，经常被膜被AKIOI的wx，玩梗宅男ljp，爱占便宜的lwy，智商不低的qcr，首席颓蛋/电视导购lzr和我。</p>
<p>其实初三刚来实验班一开始是12个人，但是后来1个人去了友校，1个人选择在 <code>NOIP2018</code> 之前去学文化课，我们把她在团队里的名字改成了“等你回来”，但是最后也没等到；剩下两个人选择考完NOIP2018就退出，现在其中一个因为选了一科地理去了平行班，另一个选择留在文化课班专攻文化课。当然，那就是另一个故事了。</p>
<p>NOIP2018，我们之中有人考得很好，有人铩羽而归，而我属于后者。所以大家都在积极准备着，选择在国庆之后就停课。</p>
<p>国庆的时候，我和lzr，wx和qcr去了青岛参加正睿，自认为是停课效果排名比较靠前的一次外出培训了。我只记得前几天每天闲的时候会选择去打 _This is the police 2_，并且在走的前一天成功丢了身份证awa，lzr 则在狂颓上古卷轴Online，wx和qcr在另一个屋，所以我并不清楚。无论怎样，青岛的培训也是很值得回忆的吧。我到现在也可以回想起夜里无人的大街、昏黄的房间只有一件台灯、抑郁的我、经常去买的大桶雪碧和辣条<del>和我丢了的身份证</del>。</p>
<p>无论怎样，青岛的外卖没有济南的好吃，嘿嘿。</p>
<h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad -??$"></a>$\rm Day\quad -??$</h1><p>我选择把每天上午安排给ZR的模拟赛，一般名次都不会很高，唉菜死了。</p>
<p>剩下人可能在做题，可能在颓。印象最深刻的就是我每五次去找yjk玩，有三次他都在刷知乎。。。</p>
<p>发现自己无论什么大型比赛之前都会发现自己原来有整理不完的博客，平时习惯太差带来的后果真可怕e</p>
<p>不过似乎是有我引起的一阵风，机房里大家都开始晚上喝_香飘飘_，甚至连铁公鸡yjk也拔毛了买过几次奶茶，于是走廊上就一股浓郁的奶茶味233</p>
<p>之前嘛，就做了做<code>dp</code>，学了学<code>odt</code>，第一次写莫队结果被逼着调了半天最后套了个线段树。剩下的或许就没有什么印象深刻的事情了。</p>
<p>哦，胜利一中的神仙们一直很在状态。我就很奇怪为什么会有人每天坚持打比赛还能坚持整完所有题目的……期间我整天听歌，还抽了一个晚上看了集《奇葩说》，感觉李诞认真起来实力也不弱蛤。</p>
<p>要来了吗？要来了吧。</p>
<h1 id="rm-Day-quad-3"><a href="#rm-Day-quad-3" class="headerlink" title="$\rm Day\quad-3$"></a>$\rm Day\quad-3$</h1><p>给最喜欢的语文老师写了封信，跟她说我觉得我可能在考完之后不会继续走下去了，这让我很难过，因为我割舍不下那些回忆，觉得她可能会理解我。她回信了。我很高兴她没有硬塞什么心灵鸡汤。于是每天晚上我都会拿出信来读一遍。</p>
<p>哦对，她以前是我的语文老师，文化课/奥赛分班之后她就只教隔壁了。</p>
<p>其实你说现在我有什么感受呢？我也不知道，就是蔡琴唱过的 _让它好好的来，让它好好的去_ 这种感觉吧。</p>
<h1 id="rm-Day-quad-0"><a href="#rm-Day-quad-0" class="headerlink" title="$\rm Day\quad 0$"></a>$\rm Day\quad 0$</h1><p>报到日，群体乘大巴。大巴上我教yjk打音游和拳皇，打deemo他菜的一批233</p>
<p>到了考点，日照什么职业技术大学。校园一般，宿舍还行，起码有插头和桌子。</p>
<p>去试了试饭菜，感觉还可以，挺丰富的。发现是兑换餐币，于是就换了三种面值的留下作纪念了。</p>
<p>晚上去试机，豪华六边形方桌，和机房里一样，感到很开心。键盘也很轻。听别人说键盘难用、座位之间间距太小，才知道原来不是每个考场都是豪华六边形方桌。有抽中大奖的喜悦233</p>
<p>试机回来就是瞎写了写板子，写了写博客。睡前听的是德彪西的《月光》。</p>
<p>考前和yjk估摸了一下，Day1要拿260左右才能稳，不知道明天会怎样。</p>
<p>哦，对，当时听的那一版《月光》，是我听完好多版之后最喜欢的一个版本。但之后我尝试找过，但无论怎么找都找不到了…</p>
<h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad 1$"></a>$\rm Day\quad 1$</h1><p>考啦考啦。</p>
<p>开题发现有一些奇怪的说明，没管。</p>
<p>开 $\rm T1$，发现是个sb题，写了$\rm [5,10]min$ 左右切了，开考 $15\min$ 的时候拍上了。</p>
<p>开 $\rm T2$，发现 $50$ 在送，于是先写了 $50$ 。之后寻思着去做做 $\rm T3$，发现不太会。本着求稳，写了 $10pts$ 就回去写 $\rm T2$了。于是就开始演，演了半小时写出了一堆不知道啥东西，然后又演了半小时发现大样例爆栈了……</p>
<p>我不会告诉你我接下来浪费了快半小时去回忆<code>Dev</code>怎么开栈…… </p>
<p>最后还是失败了，但是发现其实大样例不需要 <code>dfs</code> ，于是写了个序列版本给演过去了。之后 $\rm T2$ 就拍上了。此时大概是 $10:15$ 。</p>
<p>觉得去刚 $\rm T3$ 应该不至于一分没有，结果就真的一分没有，伤心。</p>
<p>之后就自闭了。出了考场，我戴紧冲锋衣帽子冲到了一个僻静的小路里面，周围都是密密麻麻的树，开始思考人生。在家庭群里用微信发了句 “考挂了，没救了”，跟妹子说了声“要退役了”就找了个角落开始思考人生。思考完之后开始在校园里闲逛，不想回宿舍。我觉得一定会有 sb 学弟或者 sb 同级生在对 tnd 答案，结果最后手机没电了不得不回去。</p>
<p>回去之后要了份脆皮鸡饭叫上 yjk 出去逛，发现原来大家都是 210 左右，心态得到了放松。结果不知道为啥，后半程跟 yjk 越走越自闭。我们俩大概是这么聊天的：</p>
<blockquote>
<p>我：你最后考到多少名还学？</p>
<p>yjk：20~30吧。</p>
<p>我：嗯我也是。那 70 以后呢（因为他去年这个名次）？</p>
<p>yjk：不学了吧。。</p>
<p>我：嗯我也是。</p>
<p>yjk：今天的题感觉没有区分度啊</p>
<p>我：是啊，没有区分度啊。回去还要补文化课。大家今天都 210，全天下都 210，明天还会更难，肯定会加大区分度，那我可能就被区分下去了…（开始碎碎念）</p>
<p>yjk：是啊……</p>
</blockquote>
<p>于是我俩就在四季桥那里自闭了，和俩二傻子一样蹲在桥边，如果忽略肤色，宛如两尊佛。</p>
<p>不过后来走着走着心态又回来了。回到宿舍后被辅导员骂了一顿，因为手机落在宿舍并且没签到，233.</p>
<p>之后选择去吃晚饭，碰到了胜利一中的神仙，但是显然他们不可能认识我，所以我就像一个狗仔一样单方面盯着他们看……233</p>
<p>晚饭挺不错！这是真的！之后去买了红牛，希望明天能用上。</p>
<p>晚上其实一直在颓火影和拳皇……睡之前写了写博客，<code>hexo -d</code> 之后就睡了。</p>
<p>还是听的《月光》。</p>
<h1 id="rm-Day-quad-2"><a href="#rm-Day-quad-2" class="headerlink" title="$\rm Day\quad 2$"></a>$\rm Day\quad 2$</h1><p>……自闭了。</p>
<p>开场看T1，发现是计数，不会。去搞 T2，觉得很可做，发现40在送；写完去看T3，发现40在送。于是决定写 T2。然后 T2 猜了一波单调性发现可以 64，于是数据分治了一下，拍上了；之后去写了个T3的40。T2推了推，觉得似乎可以斜率优化，但是发现有二次项似乎很难办，就没管。剩下的时间就在做T1……</p>
<p>最大的失误是啥呢？可能就是我T1<strong>把 n 和 m 看反了，并且过了前两个样例</strong>，于是觉得这题64在送。但是死活过不去第三个样例。好久之后才发现看反了，赶紧写了个玄学dfs。赛后一测re了。真开心。T3当时看的时候觉得75都是送，但是最后也没来得及写……于是第二天就这么凉了。</p>
<p>一出来，就自闭了。闲逛了好久，用QQ跟妹子说“真退役了”，用微信跟家长说“已经准备迎接新生活了”，后来就没有后来了。回去一问发现大家也都挂了……yjk哭了，我头一次见他哭。</p>
<p>不用想的，Day2就是考区分度。之前zr做题的时候就明白了，我是那种被区分下去的人。容斥、dp、贪心之类的这些基本功，我都很烂很不扎实，被区分下去是我活该。你说我会为自己以前拼命学多项式感到不值吗？可能确实不值，但是说啥都没用了。</p>
<p>回去的路上还是比较愉快的。车上的电视终于不放上21世纪初的悲情无脑乡村恋爱歌曲，改放《欢乐喜剧人》，于是最终和yjk看了一路233</p>
<p>rqy哭了，可能是因为觉得我们都退役了吧。但是我感觉我和他已经不是一个世界的人了。我一直感觉，如果让我从实力和陪伴里面选一个，我肯定毫不迟疑地选择前者。但，结束了。</p>
<p>晚上回家了，就是在一直颓而已，没啥别的，期间励志要开启新生活，觉得很有斗志。</p>
<h1 id="rm-Day-7"><a href="#rm-Day-7" class="headerlink" title="$\rm Day ~7$"></a>$\rm Day ~7$</h1><p>在校的周六，选择去机房收拾东西，顺便看了眼民间数据成绩单。发现自己和yjk都是省里50多名，还一个分…这就很难了，我们之前没讨论过这个区间该干啥呀？</p>
<h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>之后？之后就是我又滚回来追梦，yjk去文化课了，剩下的人都退役了。</p>
<p>LCEZ55 级的机房故事，也就这么结束了吧？我一直觉得，我们机房没有其它机房可爱，我是罪魁祸首。我身为队长，要张罗日常事务，但是从来没真正关心过谁，加上脾气很差容易着急（虽然现在好很多了？）。并且一开始我很菜，要一直不遗余力的提升自己实力，不顾什么”同学友谊“啊啥的，功利且浮躁。大家平时也不怎么敢跟我交流，于是机房就很冷清。</p>
<p>但机房里也时常会有笑声，比如联赛前，机房里一直其乐融融的。现在看来那似乎是遥远的回忆了。</p>
<p>现在机房里只有我一个人了，我开心吗？终于等到了我喜欢的悠远的寂静，我更快乐吗？</p>
<p>向前走吧。</p>
<p>我还很菜，啥都不会，迷茫且不知所措。</p>
<p>但是人生也就应该是这样的吧。</p>
<p>明天你好。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家一起加油吧！为了梦想和明天。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】闲谈</title>
    <url>/2019/12/15/%E9%97%B2%E6%89%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>别名：一句话日记</del></p>
<p>不过似乎写着写着早就不止一二三四五六七八句话了/kk</p>
<p>可能就是用来随时记录自己感悟的东西？</p>
<p>现在已经鸽了</p>
<a id="more"></a>
<h3 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h3><p>我发现，在家里是不可能写blog的。所以鸽了鸽了。</p>
<h3 id="1-22"><a href="#1-22" class="headerlink" title="1.22"></a>1.22</h3><p>今天决定要补一补之前欠下的日记，发现从 $1.5$ 开始就断更，实在是太多了…多亏了和zay的聊天记录能帮我想起我当时到底在干什么…</p>
<p>晚上因为一些事情陷入了深深的思考……</p>
<h3 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h3><p>今天决定去找同学玩，上午因为看「碟中谍3」并且搭错了公交鸽了好久233</p>
<p>(PS:我tm打出「碟中谍」才发现原来第一个die和第三个die不是一个die…</p>
<p>下午她要去书店社会实践，本来想继续跟她一起混，结果发现她闺蜜来了之后我就没人认领了…不是很开心地回了家。不过仔细想想的话，其实也是正常。把奇怪的东西逐渐看做正常，也算一种进步吧。</p>
<p>晚上水群+做题，还是阿狸那题，踩了一堆坑总算是做完了。</p>
<p>QAQ本来觉得调整得很好的作息又莫得了。两点才睡，晚安啦。</p>
<h3 id="1-20"><a href="#1-20" class="headerlink" title="1.20"></a>1.20</h3><p>做题是因为本来决定写的一篇blog，相关内容只写了俩题。我觉得吧，要么只整理一道，要么就三道，不知道为啥对「二」很不爽，于是就决定再写一道。</p>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><p>翻了一翻自己的任务清单，精挑细选地删了好多之后发现还是多到做不完？于是开始学线段树合并，发现不是很难。中途思考了一下线段树合并的本质，发现这东西不是很难，于是就疯狂写板子。并且由于复杂度是均摊的，所以没有什么很创新的玩法（比如按秩合并这种）。</p>
<p>成功地混进了胜利一中的群，有种找到组织的喜悦。不过为啥我那么喜欢水群啊QAQ</p>
<p>晚上在poj写了一道求桥的题，调了好半天发现自己十分弟弟地写错了。之后被zay拉着谈感情…可怕</p>
<p>现在不知道为啥十分想回家，感觉自己一天天的是要颓死在这儿了QAQ</p>
<h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>上午尝试去做了一下SPOJ的三道Min25的题目，然后就开始写博客，觉得自己效率很高……</p>
<p>其中穿插了一个情节，就是写着写着题突然感觉自己又不会Min25了，于是去uoj群里丢人，结果我凭借我精湛的提问技巧让大家都不知道我在说什么，于是群就很冷，于是我就开始疯狂地「すみません」，场面一度十分尴尬…</p>
<p>于是决定以后还是独立思考问题好了.jpg</p>
<p>然后下午不出意外地开始颓了起来。临吃饭时去拿了zay寄来的Luogu网校教材，看了看确实挺好，于是给金哥推荐了一下，作为小班的教材。然而金哥「挺好」了一句之后，就把教材还给我了233.</p>
<p>无论怎样，zay欠我一杯可乐了嘎嘎嘎嘎。然而自己的体检结果，体内尿素含量过高，所以暂时不能喝可乐，sad</p>
<p>晚上决定看看李煜东的书，挑了道点双的题目开始写，然后写自闭了。最后发现自己把 <code>while</code> 换成 <code>do_while</code> 就过了，于是去问zay。最后发现是我两分代码除了这部分，其余的并不严格相同，比如说我忘了清空……然后就没有然后了。</p>
<p>晚上金哥居然托rqy给zay说：</p>
<p><img src="4.png" alt></p>
<p>我只能233了。</p>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>今天决定有心劲一点，结果在机房从 $7：30$ 睡到 $8:30$……可海星</p>
<p>嗯，其实是在学 Min_25筛，学了一上午也没太整明白，就比着题解写了写板子，感觉不太好，那种囫囵吞枣的感觉又涌了上来。不过大致是懂了？</p>
<p>下午继续Min25，顺便写了一下笔记。在看过大多数人让人迷惑的blog之后，发现HN-001神仙 <code>xzz</code> 讲的最清楚明白。于是把大部分知识点给扣清楚了，剩下的小块可能还需要继续追索。</p>
<p>晚上不知道为啥开始一直看《巨人》，从 $90+$ 一直看到了 $123$ 话，期间用 $\rm Min25$ 过掉了杜教筛的板板，觉得自己啥都不会智障的很。</p>
<p>不过好在巨人快看完了？说实话我《巨人》看的没有当年补《海贼》看的详细，因为《海贼》是我去一本一本买的单行本，许多本反复看了好多遍，而巨人甚至连比较长的对白都跳过了。加上作者诡异的紧凑的画风导致观感极差。</p>
<p>不过要说剧情，我比较深的感觉就是，艾伦和三爷，以及他的小伙伴们都回不到原来了。从什么时候开始的呢？大概是从马莱对艾尔迪亚人派出那四个智慧巨人开始的吧，家不家矣，国不国矣。但是你能说出到底是谁错了吗？每个人都坚持着自己心中的正义而已吧……</p>
<p>感觉巨人的思想内核还是很现实的，再加上作者没有尾田那种浪漫主义情怀——毕竟说到底，海贼和巨人的思想内核都很沉重，探索的人性也很复杂，但是尾田却能把海贼画的很浪漫。每次结束战斗都要庆祝，都会看到笑容。我想，其实两部动漫都是在解剖这个社会，但是一个是笑着解剖，一个是哭着解剖吧。</p>
<p>最近感觉很困。听说下周二周三由于高考听力占考场，所以放假。不知道我们放不放。但我觉得不放的可能性更大吧…</p>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>今天准备学最短路树，但是中途穿插着一直在看《进击的巨人》，所以效率不高。</p>
<p>结果发现最短路树其实不难，难的是有一堆十分诡异的题目…比如随手套个点分治之类的233</p>
<p>结果下午就自闭了，自闭在 $\rm TJOI$ 的一道题上，大概就是每次询问删一条边之后 $\rm S\to T$ 的最短路是多少，询问之间独立。看题解看了好久也没整明白…菜死我算了。</p>
<p>然后下午明白之后晚上就写啊，写了好久才写对。然后就蒙逼了。</p>
<p>不知道什么，感觉最近不是那么有心劲了…可能是停课必经的一个阶段吧？我不是很想把这个当做自己在一段卑微的感情中受挫的副产物，那也太惨了吧？</p>
<p>不过很自闭就是了……</p>
<p>我一直在想，或许我就是因为不喜欢文化课才学的奥赛吧？从理智还是从情感上来说，我都更应该去学文化课。所以，我在做什么呢？真的是在追梦吗？每天就这么低下的学习紧张度能做成什么呢？</p>
<p>我找了好久，本来以为找到了自己的路，后来才发现原来自己只是兜了个大圈，又回到原地了而已。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>…上午写完鸽了的题解，然后几乎啥都没干……原因是本来打算学整体二分，结果看到动态图连通性这东西觉得可以学一下，就去学了学ETT——然而其实就是大略地看了那么几眼，明白原理就不看了，回过头来发现这东西好像不是给正常人写的……并且跑的似乎也没有暴力快……于是就又回去学整体二分了。</p>
<p>于是就二分了一下午，我是憨憨。</p>
<p>晚上本来打算很有心劲，结果看起了《进击的巨人》，最终漫画从 $55$ 话看到了第 $70$ 话。本来可以看更多，但是中途有 <code>slyz</code> 的神仙组团来精（教）准（我）扶（做）贫（人），比如我被怒斥：</p>
<p><img src="1.png" alt></p>
<p>然后就不敢颓了，就去做题了…</p>
<p>结果写了个整体二分套树剖的题，临走也只拿了 $10$ 分，整个人都不好了……</p>
<p>不过还是很开心的，我也是有小伙伴的人了（嚣张.yml）</p>
<p>然后下午发现了一个很秀的表情：</p>
<p><img src="2.gif" alt></p>
<p>感觉整个人都朋克起来了233</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>颓了一天，下午就返校了。上午主要是看了看B站跨年的回放。⑧说了，邓紫棋天下第一（</p>
<p>晚上突然很难受。还是关于妹子的事，可能我真的需要一段时间才能缓过来吧？感觉自己的祝福，每一句话、每一个字都在痛击自己的心。但是我能怎么样呢？我又能怎么样呢？</p>
<p>又是CSP考完那种无力感：就这样了吗？就这样了吧。</p>
<p>一个人的奥赛室，孤独到让我想哭。是啊，以后就再也不能去找妹子说最近自己心态崩了求安慰之类的话了，也必须要描黑那道若有若无的界限了，感觉生活少了点什么。</p>
<p>但总之，是一个新的开始不是吗？</p>
<p>明天可还要继续啊。</p>
<p>喂喂，pks，我们可是舞台上的战士啊，怎么能这么早就谢幕呢？</p>
<blockquote>
<p>《你的答案》_by 阿冗_</p>
<p>也许世界就这样<br>我也还在路上<br>没有人能诉说<br>也许我只能沉默<br>眼泪湿润眼眶<br>可又不甘懦弱<br>低着头 期待白昼<br>接受所有的嘲讽<br>向着风 拥抱彩虹<br>勇敢的向前走<br>黎明的那道光<br>会越过黑暗<br>打破一切恐惧我能<br>找到答案<br>哪怕要逆着光<br>就驱散黑暗<br>丢弃所有的负担<br>不再孤单<br>不再孤单<br>不再孤单</p>
</blockquote>
<h3 id="Goodbye-2019"><a href="#Goodbye-2019" class="headerlink" title="Goodbye 2019"></a>Goodbye 2019</h3><blockquote>
<p>又是一年啊。 </p>
<p>这一年里，我失去了很多，也获得了不少；看清了很多，也迷茫了不少。每一次相遇，每一次离别都值得回忆；每一份高兴，每一分忧伤也都值得我带到未来。</p>
<p>对于2019，「让它好好地来，让它好好地去」，我更喜欢这么来形容。</p>
<p>明年有什么心愿呢？生而为人，握紧很简单，但是放下却很难。然而握得越紧越发现原来没有握住，看得越重越发现自己扑了个空。所以，我希望，我可以一觉醒来发现自己什么都不记得，这样才可以放下之前的所有，大踏步得走向明天。2020，请让我变得更释然一些吧，好吗？ </p>
<p>总之呢，谢谢各位一年的陪伴。</p>
<p>2020，这个世界，与我重新来过吧。</p>
</blockquote>
<h3 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h3><p>今天早上很高兴地在早读给妹子写完新年快乐的明信片+信，让隔壁班同学当信使给送去。听他说了下最近隔壁班的八卦，发现以前觉得会厮守很久的情侣不在了，以前觉得根本不搭的两个人在一起了。感觉和他们同班的日子已经远去很久了。</p>
<p>顺便知道了原来喜欢的妹子已经有了男票，于是打算把写好的东西扔进垃圾桶。在信使老鸽的劝说下还是没扔，还是送了出去。最后感觉有点惆怅。从初中到现在，自己似乎一直在趟别人的浑水，感觉自己似乎跟他们早就不是一个世界的人了。</p>
<p>是啊，不是一个世界的人了。可能我真的需要破除『我执』了吧，不想再去纠结这些没头没脑的固执了。于是趁着夜幕还没被拽走，便匆匆来到了奥赛室。</p>
<hr>
<p>冷静思考了思考，发现自己一旦对什么东西有了厌恶感就很难再喜欢上了。所以真正对的那个人应该还没来吧，我需要继续等下去。嗯，从小父母就教导，走丢的时候原地等着是最好的选择。所以也只有等待，才是迎接光明的最好办法吧。</p>
<hr>
<p>然后晚上她用她闺蜜的 qq 给我发信息。不知道为啥。她说她本来以为我今天下午会在班里看电影（因为我们班奥赛退役选手在其它班联欢的时候，在班里看电影），然而实际上我在奥赛室看了一下午的《进击的巨人》（233。所以她就给我拍过来一张照片：</p>
<p><img src="hello.jpg" alt></p>
<p>。。。那个“弄得我很怂”的上文是我问她说每次跟她偶然遇见她为啥都故意不看我233</p>
<p>然后事情是这么发展的：</p>
<blockquote>
<p>她：还有一件信息量比较大的事情</p>
<p>她：我脱单了</p>
</blockquote>
<p>啊。</p>
<p>下午时一直在想，如果她其实和那个男生还没真正确定的话，我去“兴师问罪”是不是有点不太好？</p>
<p>好在事态的发展没让我那么尴尬……</p>
<p>我当时似乎，似乎是，思考了一瞬间，就已经知道该怎么回她了。那些“为什么你有了男朋友而不告诉我？”和“有了男朋友为什么还要给别人以希望”之类的话，已经被扔到了不知处。</p>
<p><img src="3.png" alt></p>
<blockquote>
<p>题外话：</p>
<p>……可能大家都不知道我们到底是什么关系，大概就是她知道我一直喜欢她但是我是这么一种心态：</p>
<blockquote>
<p>喜欢不等于占有</p>
</blockquote>
<p>于是和她就变成了好朋友？起码在聊天软件里还是很铁的（</p>
<p>至于她是什么人，我只能说是很单纯一妹子……就是跟人用qq聊天还用 <code>。。。。</code> 这东西做前后缀的人，现如今几乎没有了吧？</p>
</blockquote>
<p>嗯，就这样了吗？就这样了吧。</p>
<p>晚上看了看C菌的《心魔》，到最后虽然很爽，但是感觉和《逃生2》差不多，爽是爽了，但是没啥深度。</p>
<p>睡了睡了。</p>
<h3 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h3><p>昨晚不知道为啥宿舍里有一堆蚊子…让人很难过地一点多才睡，于是今天就变成了活死人状态。上午看了看高数，发现到一阶微分方程那里公式已经不是人记的了，于是觉得无聊就不学了。下午和晚上做了做 <code>vfk</code> 曾经出的某场 <code>cf</code>，剩下的时间学了发笛卡尔树就去颓了。</p>
<p>前几天看了梁文道的《我执》，几天晚上方才明白<code>我执</code>的意思，突然很有感触。以下是摘录，转自<a href="https://www.zhihu.com/question/20015896/answer/15644432" target="_blank" rel="noopener">链接</a>，有删改：</p>
<blockquote>
<p>你的名字不是你，你的职业不是你，在哪里上班的那个也不是你，这一切是你的经验，但经验不是你本身。我们经由我们生命的内容来定义自己，我们的年龄、健康、人际关系、财务状况、工作和生活情境以及心理情绪状态等等，但是这些是经验的客体，而不是主体。我们的错误就是会把这些经验当成是我们的主体，然后与它们认同，把它们当成自我的一部分。</p>
<p>一言以蔽之：我执就是在外在事物上所建立的那个虚假的自我感（ 这里的外在事物还包括你的情绪和念头，下面会细谈)。无论你执着什么，你就是在把它当成自我的一部分，而那个东西就是你「我执」的体现。在根本上，并无一个实体的，不变的「我」存在。也正是因为我们把自我感建立在这些外在的事物上，所以当它们变化时，我们的痛苦便产生了。但是这些事物的变化是不可避免的，因为它们的本质便是「无常」。所以，只要你把自我感建立在外在稍纵即逝的事物上，则我们心理上的痛苦就不可避免。</p>
<p>我们的悲哀是，我们终其一生，都只是在为自我填充这一个个意象。财富，权位，知识，还有你执着的任何东西，如果它没有伤害到他人，我想这些都是好东西，但是只要你没有认清这些东西和你的本质是完全无关的，只要你还在这些事物上建立认同感，那你所得到的一切不过是加强我执而已，而当那个意象破灭，则痛苦就将来临。</p>
</blockquote>
<p>于是感觉似乎佛教不是印象里那种玄学的宗教，而是一套科学化理论化的世界观和方法论。</p>
<p>我什么时候才能「看惯风波里，闲步红尘外」呢？</p>
<h3 id="12-29"><a href="#12-29" class="headerlink" title="12.29"></a>12.29</h3><p>上午考的数学和英语，下午考的语文，成功要到了记忆中上一次合格考跟我一个考场、这次也一个考场的可爱妹子的QQ。感觉到达了人生巅峰。</p>
<p>然后晚上回来学了学支配树，发现有神仙说灭绝树就是支配树，然后发现自己还不会灭绝树，然后就去做灭绝树了233</p>
<p>啊，终于马上要放假了，开森。</p>
<h3 id="12-28"><a href="#12-28" class="headerlink" title="12.28"></a>12.28</h3><p>上午在奥赛室背政治……下午考了政治觉得自己还可以。</p>
<p>晚上尝试写了一下「一双木棋」，发现 <code>alpha-beta</code> 只能干出 $70pts$ 来，然后就去颓了。</p>
<h3 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h3><p>没啥好讲的，明天要合格考了，在发愁自己的政治233</p>
<h3 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h3><p>上午下午一共做了三道题，从李煜东的蓝书上看来的。中途写挂了好几次，但是最终调出来还是挺有成就感的。</p>
<p>饭卡丢了，有点郁闷。毕竟电话卡和饭卡是一张卡，电话卡丢了还要去电信营业厅补办。。。太麻烦了吧233</p>
<p>……然后……然后就因为一些奇怪的事情陷入了奇怪的思考。感觉自己正在被拽进奇怪的漩涡中，感觉自己似乎如同「奇异人生」里面 <code>Max</code> 经常梦到的场景，在风暴之中，自己在被撕扯着想要登上灯塔。可惜只有我一个人。</p>
<p>看着一堆东西还没学，也不是很想学。后天还要考政治，什么都没背，感觉有点不太好。</p>
<p>似乎我走迷了路。或者说，我经常会走迷了路。高中到现在为止我一直在追求着什么，放弃了很多，但是到现在我也一直不知道我到底在追求些什么。是奥赛吗？我恍惚了。是功成名就吗？我恍惚了。</p>
<p>感觉到现在为止，我只有每个学期刚刚开始，即18年9月 $\sim$ 10月和今年的9月 $\sim$ 10月有认真学过文化课，剩下的时间都在划水；美其名曰学研究奥赛，学来的线性规划或者 <code>HLPP</code> 可能永远也用不上。我在干什么？其他人丰富有趣、值得回忆的高中生活，在我眼里就是一场又一场的白日梦，一次又一次地跌倒再爬起来再欺骗自己：你没跌倒。这一切的一切，真是我想要的吗？</p>
<p>我又在瞎想了。给梁文道做序的某作家（忘了名字）说，为什么人们喜欢寓哲学于文学呢，因为人们喜欢问没有答案的问题，喜欢去体味这种求索的感觉。可能对我来说，这也算是一点心理安慰了吧。</p>
<p>嗯，写完这些感觉内心明显平静了许多。</p>
<h3 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h3><p>今天有点颓，上午只写了一篇题解，下午做$[\rm SNOI2019]$的D2T1，做了好久，剩下的时间不知道干什么去了。</p>
<p>晚上继续和 <code>ouuuyuuu</code> 出去跑圈。外面开始下雪了，十分开心。但是一边跑，风雪夹带着冷雨扑打过来有点难受。眼镜中途还因为镜面上水太多，想用手套擦，结果擦成了磨砂玻璃…233摘下眼镜来继续跑就会感觉跟喝了一壶一样，看着周围都是一派虚无缥缈的景象。</p>
<p>开始看梁文道的《我执》了。感觉还行。但是毕竟只看了一点，也不知道到底有什么精彩等待着我。</p>
<p>发现自己写文章的时候，可能是因为平时说话说太快了，一直不喜欢加句号。大多数情况下都是一大段全是逗号233</p>
<p>晚上发现胜利一中的神仙们去逛了我的 <code>Luogu</code> 博客，比较开心。因为似乎我也没法跟别人交流了。</p>
<p>瞎扯一句，感觉 <code>rqy</code> 能一个人在这儿奋斗两年，十分厉害。孤独+经常会有的绝望+偶尔的希望，不把人逼自闭已经算是很好了。</p>
<p>诶，刚刚才发现原来自己有三个博客，但是这三个博客上的东西几乎都不一样。。。233</p>
<h3 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h3><p>平安夜，很自闭233</p>
<p>看了一上午+大半个下午的构造，感觉一般。听 <code>ouuuyuuu</code> 说构造题只能长经验，是学不会的，感觉有点小失落。</p>
<p><del>人总要有梦想，万一我就学会了呢</del></p>
<p>晚上复盘了一下自己的 $\rm CSP-S~2019$ ，感觉虽然和大家都很有差距，但是如果从进步的意义上来讲，比起去年来自己进步还是蛮多的。毕竟去年也就那点水平。</p>
<p>嗯，所以呢，谁知道将来我会不会进步到我想象不到的水平呢？加油吧，我可是想要创造奇迹的笨蛋啊！</p>
<h3 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h3><p>越来越困了，发现啥都学不会，然后自闭了。</p>
<p>发现去了 <code>pkuwc</code> 的小伙伴们似乎都有约拿了，感觉更自闭了。</p>
<p>……我觉得我现在应该是全校最盼着放寒假的人了。当初觉得似乎机房生活会很轻松，结果发现比文化课生活自闭了不止一个量级。可海星……</p>
<p>发现啥都学不会了，发现比别人拉下的不止一点半点……有点难受，但是一想到马上要放假了（虽然还有一个多月）就会开心一点phh</p>
<h3 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h3><p>……之前换了几天的 <code>jacman</code> 主题，说实话感觉不是很漂亮。换主题的原因是我关了一次 <code>icloud</code>，然后他就给我吞了……迷惑。于是只能重新建一个主题。不过好在我<del>找回了失去的脑子</del>找到了对应的文件夹，于是九成功复原了。于是现在就又换回了 <code>next</code> 主题。</p>
<p>怎么说呢，虽然 <code>next</code> 主题确实用的比较多，有烂大街的嫌疑，但是你要真让我去挑其他的喜欢的并且配置出来，确实很麻烦。</p>
<p>嗯，这个故事告诉我们要学会备份。 </p>
<h3 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h3><p>upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。</p>
<p>新建了这个文档，本想写很多，结果突然发现自己WC都去不了。</p>
<p>然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Manacher简单题泛做</title>
    <url>/2019/12/15/Manacher%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>在？为啥不用PAM？</del></p>
<p>emm那可能是空间开不下（自我安慰</p>
<a id="more"></a>
<h1 id="1-LG1659-国家集训队-拉拉队排练"><a href="#1-LG1659-国家集训队-拉拉队排练" class="headerlink" title="$1$ LG1659 [国家集训队]拉拉队排练"></a>$1$ LG1659 [国家集训队]拉拉队排练</h1><blockquote>
<p>求前$k$大的奇数长度回文串的长度之积。</p>
<p>$\rm |S|\leq 1e6,K\leq 1e12$</p>
</blockquote>
<p>……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq</p>
<p>二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。</p>
<p>以下是错误代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L = <span class="number">-1</span> ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ret *= x) %= Mod ; </span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">int</span> x = ed[p], i ; </span><br><span class="line">	<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; p ; ++ i)</span><br><span class="line">		ret += <span class="number">1l</span>l * ((ed[i] - ed[p] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(ret + (buc[ed[p]]) &gt;= K) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; </span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) buc[base[i] - <span class="number">1</span>] ++ ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i += <span class="number">2</span>) <span class="keyword">if</span> (buc[i]) ed[++ tot] = i ; </span><br><span class="line">	reverse(ed + <span class="number">1</span>, ed + tot + <span class="number">1</span>) ; <span class="keyword">int</span> L = <span class="number">1</span>, R = tot, Mid, ans, pos = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">		Mid = (L + R) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">		<span class="comment">/*if (rand() % 2)</span></span><br><span class="line"><span class="comment">			while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ;</span></span><br><span class="line"><span class="comment">		else </span></span><br><span class="line"><span class="comment">			while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/</span></span><br><span class="line">		<span class="keyword">if</span> (check(Mid)) ans = Mid, R = Mid - <span class="number">1</span> ; <span class="keyword">else</span> L = Mid + <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	pos = ans, res = <span class="number">1l</span>l, _up = ed[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ed[pos] ; i &lt;= ed[<span class="number">1</span>] ; i += <span class="number">2</span>) fact *= <span class="number">1l</span>l * i ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (ed[i] &lt; _up) fact /= _up, _up -= <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">if</span> ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span> &gt; K)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">0</span> ; </span><br><span class="line">			<span class="keyword">while</span> (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K)</span><br><span class="line">				res = res * <span class="number">1l</span>l * ed[i], ed[i] -= <span class="number">2</span>, ++ j ; </span><br><span class="line">			<span class="keyword">break</span> ; </span><br><span class="line">		&#125; </span><br><span class="line">		res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ;</span><br><span class="line">		K -= <span class="number">1l</span>l * ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line">		<span class="keyword">if</span> (K &lt;= <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">	&#125; 	 </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ret *= x) %= Mod ; </span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= <span class="number">1</span>) ++ base[i] ; </span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i], id = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">		ans += buc[i] ; </span><br><span class="line">		<span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;		</span><br><span class="line">		<span class="keyword">if</span> (ans &lt;= K)	</span><br><span class="line">			(res *= expow(i, ans)) %= Mod, K -= ans ; </span><br><span class="line">		<span class="keyword">else</span> &#123; (res *= expow(i, K)) %= Mod, K -= ans ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。</p>
<h1 id="2-LG4555-国家集训队-最长双回文串"><a href="#2-LG4555-国家集训队-最长双回文串" class="headerlink" title="$2$ LG4555 [国家集训队]最长双回文串"></a>$2$ LG4555 [国家集训队]最长双回文串</h1><p>这题比第一题友善了很多。。。</p>
<blockquote>
<p>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。</p>
</blockquote>
<p>嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">int</span> i, id = <span class="number">0</span>, rt = <span class="number">0</span> ; ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">else</span> base[i] = min(rt - i + <span class="number">1</span>, base[<span class="number">2</span> * id - i]) ;  </span><br><span class="line">		<span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line">		<span class="keyword">if</span> (i + base[i] &gt; rt) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = i / <span class="number">2</span> - (base[i] / <span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">int</span> r = i / <span class="number">2</span> + (base[i] / <span class="number">2</span>) - <span class="number">1</span> ; <span class="keyword">if</span> (ns[i] == <span class="number">35</span>) ++ r ;</span><br><span class="line">		Ls[r] = max(Ls[r], base[i] - <span class="number">1</span>), Rs[l] = max(Rs[l], base[i] - <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + <span class="number">1</span>]) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】PAM简单题泛做</title>
    <url>/2019/12/15/PAM%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都是简单的PAM习题</p>
<a id="more"></a>
<h1 id="1-LG5496-【模板】回文自动机"><a href="#1-LG5496-【模板】回文自动机" class="headerlink" title="$1$ LG5496 【模板】回文自动机"></a>$1$ LG5496 【模板】回文自动机</h1><blockquote>
<p>对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。</p>
<p>$|s|\leq 1e6$</p>
</blockquote>
<p>然后就是PAM的板子题<del>咋感觉好像没有不是很板的PAM题呢</del></p>
<p>考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移</p>
<script type="math/tex; mode=display">
cnt_{p}=cnt_{fail_p}+1</script><p>然后就没有然后了。</p>
<h1 id="2-APIO2014-回文串"><a href="#2-APIO2014-回文串" class="headerlink" title="$2$ [APIO2014]回文串"></a>$2$ [APIO2014]回文串</h1><blockquote>
<p>给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。</p>
<p>对于给你的这个字符串$s$，求所有回文子串中的最大存在值。</p>
<p>$|s|\leq 1e6$</p>
</blockquote>
<p>感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然<strong>“串的最长回文后缀唯一”</strong>的逆命题<strong>“任何串会唯一作为其他串的最长回文后缀”</strong>也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用</p>
<script type="math/tex; mode=display">
\rm f_u=ctn_u+\sum_{v\in S(u)}f_v</script><p>其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。</p>
<p>emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; i --) </span><br><span class="line">    P.f[P.pre[i]] += P.f[i], ans = max(ans, <span class="number">1l</span>l * P.len[i] * P.f[i]) ;</span><br></pre></td></tr></table></figure>
<p><del>哪那么多P话，就是背啊</del></p>
<h1 id="3-LG5555-秩序魔咒"><a href="#3-LG5555-秩序魔咒" class="headerlink" title="$3$ LG5555 秩序魔咒"></a>$3$ LG5555 秩序魔咒</h1><blockquote>
<p>求两个串的最长公共回文子串以及该长度的出现次数。</p>
<p>$\rm |S|,|T|\leq 10^6$</p>
</blockquote>
<p><del>恭喜发现一个新套路</del></p>
<p>观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ans == P.len[x]) res ++ ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; P.len[x]) res = <span class="number">1</span>, ans = P.len[x] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By the way，奇根/偶根都要$dp$一次。</p>
<h1 id="4-JSOI2013-快乐的-JYY"><a href="#4-JSOI2013-快乐的-JYY" class="headerlink" title="$4$ [JSOI2013]快乐的 JYY"></a>$4$ [JSOI2013]快乐的 JYY</h1><blockquote>
<p>求两个串的不同公共回文串的个数，其中不同意思是下标不同。</p>
<p>$|s|,|t|\leq 10^6$</p>
</blockquote>
<p>……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x + y &gt; <span class="number">2</span>) ans += <span class="number">1l</span>l * P.f[x] * Q.f[y] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	P.Init(), Q.Init() ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Insert(S[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, S) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) Q.Insert(T[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, T) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; </span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">1</span>) ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans&lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-闲扯"><a href="#5-闲扯" class="headerlink" title="$5$ 闲扯"></a>$5$ 闲扯</h1><p>写模板题真是让人感到空虚……</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】PAM &amp; Manacher</title>
    <url>/2019/12/15/PAMandManacher/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PAM &amp; Manacher，两种用来处理回文串的玩意儿。</p>
<a id="more"></a> 
<h1 id="1-Manacher"><a href="#1-Manacher" class="headerlink" title="$1$ Manacher"></a>$1$ Manacher</h1><p><del>挺短，背是挺好背的</del></p>
<p>Manacher用于求回文串长度。思想大概就是：</p>
<p>1、加入字符集之外的识别字符（比如<code>#</code>）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。</p>
<p>2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定<strong>至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$}</strong> 。然后就不断扩展即可。</p>
<p>3、关于复杂度证明。我们记<strong>一次帅气的操作</strong>的意义是<strong>成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$</strong>，记以当前点为轴的最长回文子串为 $\rm T$，$ \rm T$ 的右端点为 $q$。可以知道 .</p>
<ul>
<li>（1）$\rm S$的右端点是单增的；</li>
<li>（2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然<code>while</code>1次，$maxlen$增大一次；</li>
<li>（3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出<code>while</code>；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。</li>
</ul>
<p>So,最终复杂度就是$\Theta(n)$的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id, fars, i ; </span><br><span class="line">	id = <span class="number">0</span>, fars = <span class="number">0</span> ;</span><br><span class="line">	<span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line">	<span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> 		<span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), </span><br><span class="line">	L = <span class="number">-1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; Manacher(In) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) ans = max(ans, base[i] - <span class="number">1</span>) ; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-PAM"><a href="#2-PAM" class="headerlink" title="$2$ PAM"></a>$2$ PAM</h1><p>学了PAM，不知道为啥感觉比SAM简单？</p>
<p>其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下：</p>
<p>0、一个串的回文子串至多有 $O(n)$ 个。</p>
<p>1、首先每个节点需要保存这个节点中回文串的长度。</p>
<p>2、显然始状态需要有两个，即奇数长度的 $s_1$ 和偶数长度的 $s_0$ ，称作<strong>“奇根”</strong>和<strong>“偶根”</strong>。那么为了方便呢，奇根的长度设置为 $-1$，偶根长度设置为 $0$。</p>
<p>3、考虑要从 $last$ 指针扩展当前状态，假设当前需要 <code>insert</code> 的字母是 $c$，是这个串里面的第 $p$ 个字符，那我们需要找到一个后缀 $s[j…p-1]\quad s.t.\quad s[j…p-1]$ 本身回文且 $s[j-1]=c$，那么就可以向下扩展。</p>
<p>4、考虑怎么找这个后缀，显然对于一个串 $\rm S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的<strong>最长回文后缀</strong>。</p>
<p>5、插入新节点时，考虑跳完 $fail$ 后如果没有相应的转移边，就要新建一个状态然后连$fail$.</p>
<p>然后是代码和一点注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">	<span class="keyword">int</span> rt0, rt1, last, sz ;</span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fail[MAXN] ;</span><br><span class="line">&#125;P ;</span><br><span class="line"><span class="keyword">void</span> _init(PAM &amp;p)&#123;</span><br><span class="line">	p.sz = <span class="number">-1</span>, </span><br><span class="line">	p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ;</span><br><span class="line">	p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ;</span><br><span class="line">	p.last = p.rt0, p.len[p.rt0] = <span class="number">0</span>, p.len[p.rt1] = <span class="number">-1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">int</span> u = p.last ; </span><br><span class="line">	<span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line">	<span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line">		<span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line">		<span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">		p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">		p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, </span><br><span class="line">	&#125;</span><br><span class="line">	p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn,</span><br></pre></td></tr></table></figure>
<p>原因是当 $fa=u$ 时就出现环了。</p>
<h1 id="3-闲扯"><a href="#3-闲扯" class="headerlink" title="$3$ 闲扯"></a>$3$ 闲扯</h1><p>学完才知道，$\rm PAM$ 又简单又好背功能又多……Manacher被打爆了啊喂qwq。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PAM,回文自动机</category>
      </categories>
      <tags>
        <tag>字符串/Manacher</tag>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces前11场泛做</title>
    <url>/2019/11/15/cf1-11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq</p>
<a id="more"></a>
<h1 id="rm-CF·1C"><a href="#rm-CF·1C" class="headerlink" title="$\rm {CF·1C}$"></a>$\rm {CF·1C}$</h1><blockquote>
<p>求包含给定三点的正多边形最小面积。</p>
</blockquote>
<hr>
<p>先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。</p>
<p>之后对于该多边形，我们考虑，由于其让求的正多边形需要<strong>面积最小</strong>。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是<strong>该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍</strong></p>
<p>那么我们就做一个<code>double</code>类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。</p>
<p>最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-4</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.00000</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> mark ; <span class="comment">// 0 = exist, 1 = inexist ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">&#125;A, B, C, O, m1, m2, m3 ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ;<span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line">    <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; <span class="comment">// y = kx + b, x = k, y = k ;</span></span><br><span class="line">&#125;L[<span class="number">12</span>] ; <span class="keyword">double</span> Len[<span class="number">4</span>], agl[<span class="number">4</span>], R, angle ; <span class="keyword">int</span> i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is x = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is y = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_Mid</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.x + B.x) / <span class="number">2</span>, (A.y + B.y) / <span class="number">2</span> &#125; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_verti</span><span class="params">(Node n, Line a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.mark) <span class="keyword">return</span> (Line) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (a.mark == <span class="number">1</span>) <span class="keyword">return</span> (Line) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = <span class="number">-1.0</span> / a.k, bb = n.y - n.x * kk ; </span><br><span class="line">  	<span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_Line</span><span class="params">(Node A, Node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A. y == B. y) <span class="keyword">return</span> (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A. x == B. x) <span class="keyword">return</span> (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, A.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; </span><br><span class="line">  	<span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span><span class="params">(Line A, Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, get_x(A, B), get_y(A, B)&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.y - B.b) / B.k, A.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (B.y - A.b) / A.k, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, B.x, B.x * A.k + A.b&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, A.x, A.x * B.k + B.b&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">gcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; Eps) <span class="keyword">return</span> a ; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; Eps) <span class="keyword">return</span> b ; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, <span class="built_in">fmod</span>(a, b)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; </span><br><span class="line">  	A.mark = B.mark = C.mark = <span class="number">0</span> ;</span><br><span class="line">    L[<span class="number">1</span>] = get_Line(A, B), L[<span class="number">2</span>] = get_Line(B, C), L[<span class="number">3</span>] = get_Line(A, C) ; </span><br><span class="line">  	m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ;</span><br><span class="line">    L[<span class="number">4</span>] = get_verti(m1, L[<span class="number">1</span>]), L[<span class="number">5</span>] = get_verti(m2, L[<span class="number">2</span>]) ;</span><br><span class="line">  	O = get_inter(L[<span class="number">4</span>], L[<span class="number">5</span>]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / <span class="number">3.0</span> ;</span><br><span class="line">    Len[<span class="number">1</span>] = dis(A, B), Len[<span class="number">2</span>] = dis(B, C), Len[<span class="number">3</span>] = dis(A, C) ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) agl[i] = <span class="built_in">acos</span>(<span class="number">1</span> - Len[i] * Len[i] / (<span class="number">2</span> * R * R) ); </span><br><span class="line">    agl[<span class="number">3</span>] = <span class="number">2</span> * Pi - agl[<span class="number">1</span>] - agl[<span class="number">2</span>], angle = gcd(agl[<span class="number">3</span>], gcd(agl[<span class="number">1</span>], agl[<span class="number">2</span>])) ; 		<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (Pi * R * R * <span class="built_in">sin</span>(angle)) / angle) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·2B"><a href="#rm-CF·2B" class="headerlink" title="$\rm CF·2B$"></a>$\rm CF·2B$</h1><blockquote>
<p>给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走</p>
<p>以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾.</p>
<p>$n\leq 1,000$</p>
</blockquote>
<p>考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> &amp;N, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!N) &#123; zerox = i, zeroy = j ; <span class="keyword">return</span> <span class="number">1</span> ; &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ; <span class="keyword">while</span> (!(N % fac)) ++ res, N /= fac ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark, <span class="keyword">int</span> kind)</span></span>&#123; <span class="comment">//mark 1 : D, 2 : R ;</span></span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (kind == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mark) <span class="keyword">return</span> ; <span class="keyword">if</span> (mark == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"D"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp2)), dp2[<span class="number">1</span>][<span class="number">0</span>] = dp2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(dp5, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp5)), dp5[<span class="number">1</span>][<span class="number">0</span>] = dp5[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp2[i][j] = min(dp2[i - <span class="number">1</span>][j], dp2[i][j - <span class="number">1</span>]) </span><br><span class="line">          						+ (base[i][j][<span class="number">1</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">2</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp5[i][j] = min(dp5[i - <span class="number">1</span>][j], dp5[i][j - <span class="number">1</span>]) </span><br><span class="line">          						+ (base[i][j][<span class="number">2</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">5</span>)) ;</span><br><span class="line">    Ans = min(dp5[N][N], dp2[N][N]) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans &gt; <span class="number">1</span> &amp;&amp; zerox &amp;&amp; zeroy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zerox ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zeroy ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zerox + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zeroy + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  		dp5[N][N] &gt; dp2[N][N] ? Print(N, N, <span class="number">0</span>, <span class="number">1</span>) : Print(N, N, <span class="number">0</span>, <span class="number">2</span>) ;</span><br><span class="line">    &#125; </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF-·2C"><a href="#rm-CF-·2C" class="headerlink" title="$\rm CF ·2C$"></a>$\rm CF ·2C$</h1><blockquote>
<p>给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。</p>
</blockquote>
<p><del>咋又是计算几何啊</del></p>
<p>设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。</p>
<p>那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有<script type="math/tex">\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}</script></p>
<p>稍微移一下项，就会有<script type="math/tex">\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}</script></p>
<p>那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。</p>
<p>事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可：</p>
<p>设比例系数为$k(k \geq 1)$, 那么：</p>
<script type="math/tex; mode=display">
\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\\
\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2</script><p>稍微移一下项就会得到</p>
<script type="math/tex; mode=display">
(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0</script><p>看起来有点儿长……</p>
<p>令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$</p>
<p>那么就会变成</p>
<script type="math/tex; mode=display">
Ax^2 + Ay^2+ Cx + Dy+E = 0</script><p>由于$A,C,D,E$都是常数，所以这是一个<strong>圆的一般方程。</strong></p>
<p>我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说<strong>当且仅当两个圆半径相等时，点$T$的轨迹是一条直线</strong>。其余的情况则是<strong>一个圆</strong>。</p>
<p>我们不妨先记这种<strong>到两个圆的圆心的距离成定比例的</strong>轨迹为两个圆的<strong>生成曲线</strong>。</p>
<p>那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要：</p>
<ul>
<li>$(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。</li>
<li>$(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合<script type="math/tex">\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}</script>的点，我们需要判断对于圆$C$是否也满足<script type="math/tex; mode=display">
\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}</script></li>
<li>$(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。</li>
</ul>
<p>然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233</p>
<p>代码很繁琐233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-3</span> ; <span class="keyword">int</span> i ;<span class="comment">//以下的mark都是记录状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> xa, ya, xb, yb ; &#125; I[<span class="number">5</span>] ; </span><br><span class="line"><span class="comment">// 0 = inexist, 1 = exist*1, 2 = exist*2 ;</span></span><br><span class="line"><span class="comment">//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; &#125;L[<span class="number">12</span>] ; </span><br><span class="line"><span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ; <span class="comment">// 1 : circle ; 0 : Line ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r ;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, D, E ;</span><br><span class="line">    Circle <span class="keyword">friend</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> Circle &amp;A, <span class="keyword">const</span> Circle &amp;B)&#123;</span><br><span class="line">        <span class="keyword">return</span> (Circle)&#123;<span class="number">0</span>, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;C[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">double</span> ansx, ansy ; <span class="keyword">bool</span> check ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> A.mark &lt; B.mark ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is (x = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is (y = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disa</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); </span><br><span class="line">&#125;<span class="comment">//第一个点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disb</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); </span><br><span class="line">&#125;<span class="comment">//第二个点之间的距离</span></span><br><span class="line"><span class="comment">//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">Line_inter</span><span class="params">(Line A, Line B)</span></span>&#123;<span class="comment">//斜截式直线求交点（之前写的直接copy过来的）</span></span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) ) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, get_x(A, B), get_y(A, B), <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.y - B.b) / B.k, A.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (B.y - A.b) / A.k, B.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, B.x, B.x * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, A.x, A.x * B.k + B.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span> <span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//“生成曲线”求交点</span></span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">0</span> &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == <span class="number">0</span>))&#123;<span class="comment">//一条是直线，一个是圆</span></span><br><span class="line">        <span class="keyword">if</span> (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; <span class="comment">// B is a line ;</span></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span> + (B.C / B.D) * (B.C / B.D), del ;</span><br><span class="line">        <span class="keyword">double</span> c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ;</span><br><span class="line">        <span class="keyword">double</span> b = (A.C - B.C * A.D / B.D + <span class="number">2</span> * B.C * B.E /((B.D) * (B.D)) ) ; </span><br><span class="line">        <span class="keyword">if</span> ((del = (b * b - <span class="number">4</span> * a * c)) &lt; -Eps) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ; </span><br><span class="line">        <span class="comment">// printf("%lf %lf %lf %lf\n", a, b, c, del) ;</span></span><br><span class="line">        <span class="keyword">double</span> xa =  (-b + <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a), xb = (-b - <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a) ;</span><br><span class="line">        <span class="keyword">double</span> ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">return</span> (Node)&#123;<span class="number">2</span>, xa, ya, xb, yb&#125; ;<span class="comment">//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.mark &amp;&amp; !B.mark)&#123;</span><br><span class="line">        Line La, Lb ; <span class="comment">//两条都是直线，那么就直接转化成斜截式求。</span></span><br><span class="line">        <span class="keyword">if</span> (!A.C) La = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - A.E / A.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!A.D) La = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -A.E / A.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> La = (Line)&#123;<span class="number">2</span>, -A.C / A.D, -A.E / A.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (!B.C) Lb = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - B.E / B.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!B.D) Lb = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -B.E / B.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> Lb = (Line)&#123;<span class="number">2</span>, -B.C / B.D, -B.E / B.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">        <span class="keyword">return</span> Line_inter(La, Lb) ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (A.mark &amp;&amp; B.mark)&#123;</span><br><span class="line">        Circle C = A - B ; <span class="keyword">return</span> get_inter(C, A) ;</span><br><span class="line">        <span class="comment">//此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">make_rat</span><span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//rat = ratio[n.]比例；比率，用来求生成曲线的函数</span></span><br><span class="line">    <span class="keyword">double</span> _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; <span class="keyword">double</span> t ; </span><br><span class="line">    Ans.A = Ans.B = (_k2 - <span class="number">1</span>), </span><br><span class="line">  	Ans.C = <span class="number">-2</span> * (_k2 * B.x - A.x), </span><br><span class="line">  	Ans.D = <span class="number">-2</span> * (_k2 * B.y - A.y), </span><br><span class="line">    Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), </span><br><span class="line">  	Ans.x = Ans.y = Ans.r = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (Ans.A != <span class="number">0</span>) </span><br><span class="line">      Ans.mark = <span class="number">1</span>, t = Ans.A, Ans.A /= t, </span><br><span class="line">  		Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; </span><br><span class="line">  	<span class="keyword">else</span> Ans.mark = <span class="number">0</span> ; </span><br><span class="line">  	<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_for_Ans</span><span class="params">()</span></span>&#123;<span class="comment">//最后的结果，判断选哪个交点</span></span><br><span class="line">    sort(I + <span class="number">1</span>, I + <span class="number">3</span>, Comp) ;<span class="comment">//我闲的，方便一点</span></span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>].mark &lt;= <span class="number">1</span>) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> A1, A11, B1, B11 ;</span><br><span class="line">        I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]) ;</span><br><span class="line">        A1 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        A11 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        B1 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        B11 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        <span class="keyword">if</span> (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) </span><br><span class="line">          	check = <span class="number">1</span> ;<span class="comment">//如果在误差范围内都不相等就说明无解。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> Ja = <span class="built_in">sin</span>(<span class="number">1</span> / A1), Jb = <span class="built_in">sin</span>(<span class="number">1</span> / B1) ;<span class="comment">//比较角的大小，通过sin来搞</span></span><br><span class="line">            <span class="keyword">if</span> (Ja &gt; Jb) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">          	<span class="keyword">else</span> ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) </span><br><span class="line">      	<span class="built_in">cin</span> &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ;</span><br><span class="line">    C[<span class="number">4</span>] = make_rat(C[<span class="number">1</span>], C[<span class="number">2</span>]), </span><br><span class="line">  	C[<span class="number">5</span>] = make_rat(C[<span class="number">2</span>], C[<span class="number">3</span>]), </span><br><span class="line">  	C[<span class="number">6</span>] = make_rat(C[<span class="number">3</span>], C[<span class="number">1</span>]), </span><br><span class="line">    I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]), </span><br><span class="line">  	I[<span class="number">2</span>] = get_inter(C[<span class="number">5</span>], C[<span class="number">6</span>]), </span><br><span class="line">  	I[<span class="number">3</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">6</span>]) ; </span><br><span class="line">    <span class="comment">/*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!I[<span class="number">1</span>].mark || !I[<span class="number">2</span>].mark || !I[<span class="number">3</span>].mark) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'\n'</span>), <span class="number">0</span> ; </span><br><span class="line">  	make_for_Ans() ; (!check) ? <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf"</span>, ansx, ansy) : <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·3B"><a href="#rm-CF·3B" class="headerlink" title="$\rm CF·3B$"></a>$\rm CF·3B$</h1><blockquote>
<p>有一辆载重量为$v$的货车， 准备运送两种物品。 </p>
<p>物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。</p>
<p>$n\leq 100,000\quad v\leq 1e9$</p>
</blockquote>
<p>其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。</p>
<p>$\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学）</p>
<p>有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ,val ;</span><br><span class="line">&#125; base1[MAXN], base2[MAXN] ; <span class="keyword">int</span> N, M, p, v, v1, v2, c ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ; <span class="keyword">int</span> tot1, tot2, t1, t2, i ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Data a, Data b)</span></span>&#123; <span class="keyword">return</span> a.val &gt; b.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="built_in">memset</span>(base1, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base1)) ; </span><br><span class="line">    <span class="built_in">memset</span>(base2, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base2)) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v) ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">1</span>) base2[++ tot2].val = v, base2[tot2].num = i ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*qwq*/</span>base1[++ tot1].val = v, base1[tot1].num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base1 + <span class="number">1</span>, base1 + tot1 + <span class="number">1</span>, Comp), </span><br><span class="line">    sort(base2 + <span class="number">1</span>, base2 + tot2 + <span class="number">1</span>, Comp) ;</span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp; <span class="number">1</span>) ans.pb(base1[<span class="number">1</span>].num), Ans += base1[<span class="number">1</span>].val, ++ t1, M -- ;</span><br><span class="line">    <span class="keyword">while</span> (M &gt; <span class="number">1</span>)&#123;<span class="comment">//此处&gt;1是选v=2时防止越界</span></span><br><span class="line">        v2 = base2[t2 + <span class="number">1</span>].val ;</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) <span class="keyword">break</span> ;</span><br><span class="line">        v1 = base1[t1 + <span class="number">1</span>].val + base1[t1 + <span class="number">2</span>].val ; </span><br><span class="line">        <span class="keyword">if</span> (t1 + <span class="number">2</span> &gt; tot1) v1 = base1[t1 + <span class="number">1</span>].val, c = <span class="number">1</span> ; <span class="keyword">else</span> c = <span class="number">2</span> ; </span><br><span class="line">        <span class="keyword">if</span> (v1 &gt;= v2)&#123;</span><br><span class="line">            Ans += v1 ; M -= c ;</span><br><span class="line">            rep(i, <span class="number">1</span>, c) ans.pb(base1[++ t1].num) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Ans += v2, M -= <span class="number">2</span>, ans.pb(base2[++ t2].num) ; </span><br><span class="line">    &#125;<span class="comment">//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp;&amp; t1 &lt; tot1) </span><br><span class="line">      Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; </span><br><span class="line">  	<span class="keyword">if</span> (Ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) <span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="string">" "</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·4D"><a href="#rm-CF·4D" class="headerlink" title="$\rm{CF·4D}$"></a>$\rm{CF·4D}$</h1><blockquote>
<p>给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$</p>
<p>求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度<br>$n \leq 5,000$</p>
</blockquote>
<p>一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	&#123; </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), f[i] = <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">if</span> (A &lt;= W || B &lt;= H) <span class="keyword">continue</span> ;</span><br><span class="line">      E[++ tot].w = A, E[tot].h = B, E[tot].num = i ;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(E + <span class="number">1</span>, E + tot + <span class="number">1</span>, Comp) ;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h)</span><br><span class="line">              <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                  f[i] = f[j] + <span class="number">1</span>, r[i] = j ;</span><br><span class="line">              &#125; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; ans) ans = f[i], End = i ;</span><br><span class="line">  <span class="keyword">while</span>(End) s.push(End), End = r[End] ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">while</span> (!s.empty()) <span class="built_in">cout</span> &lt;&lt; E[s.top()].num &lt;&lt; <span class="string">" "</span>, s.pop() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5C"><a href="#rm-CF·5C" class="headerlink" title="$\rm CF·5C$"></a>$\rm CF·5C$</h1><blockquote>
<p>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。</p>
<p>$n\leq 1,000,000$</p>
</blockquote>
<p>好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s ; </span><br><span class="line"><span class="keyword">int</span> N, dp[MAXN], f[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) s.push(i)<span class="comment">/*, cout &lt;&lt; "qwq" &lt;&lt; endl */</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s.empty()) base[s.top()] = base[i] = <span class="number">1</span>, s.pop() ; </span><br><span class="line">    &#125; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (base[i]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span> ; <span class="keyword">else</span> dp[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      f[i] = max(f[i - <span class="number">1</span>], dp[i]) ; <span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">  	<span class="keyword">int</span> maxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dp[i] == f[N]) ++ ans ; <span class="built_in">cout</span> &lt;&lt; (f[N] ? ans : <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5D"><a href="#rm-CF·5D" class="headerlink" title="$\rm CF·5D$"></a>$\rm CF·5D$</h1><blockquote>
<p>有一个长度为$l$的道路，你的加速是$a$。</p>
<p>从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。</p>
<p>$w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。</p>
</blockquote>
<p>高中物理模拟题？？</p>
<p>其实就是分类讨论一下就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> mark ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span> ; </span><br><span class="line"><span class="keyword">double</span> x_1, x_2, ans, x ;</span><br><span class="line"><span class="keyword">double</span> vnow, a, vmax, L, D, vmaxd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b &gt; a) swap(a, b) ;</span><br><span class="line">	<span class="keyword">return</span> ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ;</span><br><span class="line">	vnow = <span class="built_in">sqrt</span>(<span class="number">0.5</span> * (<span class="number">2</span> * a * D + vmaxd * vmaxd)) ; </span><br><span class="line">	<span class="keyword">if</span> (vnow &gt; vmax) vnow = vmax, mark = <span class="number">1</span> ;</span><br><span class="line">	x_1 = vnow * vnow / <span class="number">2</span> / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line">	<span class="keyword">if</span> (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;</span><br><span class="line"><span class="comment">//		if (!mark)&#123;</span></span><br><span class="line">			ans += vnow / a + (vnow - vmaxd) / a ; </span><br><span class="line">			<span class="keyword">if</span> (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ;</span><br><span class="line">		<span class="comment">/*&#125;</span></span><br><span class="line"><span class="comment">		else &#123;</span></span><br><span class="line"><span class="comment">			ans += vnow / a + (vnow - vmaxd) / a ;</span></span><br><span class="line"><span class="comment">			x = ans += x / vnow ;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		vnow = vmax, x = vnow * vnow / <span class="number">2</span> / a ;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; L || equal(x, L))&#123;</span><br><span class="line">			ans = vnow / a, ans += (L - x) / vmax ;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			vnow = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * L) ;</span><br><span class="line">			ans = vnow / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x = (vmax * vmax - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; L - D || equal(x, L - D))&#123;</span><br><span class="line">		ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		vnow = vmaxd, x = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * (L - D) + vnow * vnow) ;</span><br><span class="line">		ans += (x - vnow) / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5E"><a href="#rm-CF·5E" class="headerlink" title="$\rm CF·5E$"></a>$\rm CF·5E$</h1><blockquote>
<p>有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。</p>
<p>$n\leq 100,000$</p>
</blockquote>
<p>一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; ++ i) <span class="built_in">stack</span>[i] = Mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">	init(M), ans = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i, tp = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tp &amp;&amp; <span class="built_in">stack</span>[tp].first &lt; base[i]) </span><br><span class="line">      ans += <span class="built_in">stack</span>[tp].second, -- tp ;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>[tp].first != base[i])  </span><br><span class="line">			ans += (tp &gt; <span class="number">0</span>), <span class="built_in">stack</span>[++ tp] = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">		<span class="keyword">else</span> ans += (tp &gt; <span class="number">1</span>) + <span class="built_in">stack</span>[tp].second, ++ <span class="built_in">stack</span>[tp].second ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i + N] = base[i] = qr() ;</span><br><span class="line">	pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; St, Ed ;</span><br><span class="line">	St = Mp(<span class="number">-1</span>, <span class="number">0</span>), Ed = Mp(<span class="number">-1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (St.first &lt; base[i]) </span><br><span class="line">      Ed = St, St = Mp(base[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (St.first == base[i]) ++ St.second ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Ed.first &lt; base[i]) Ed = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ed.first == base[i]) ++ Ed.second ;</span><br><span class="line">	&#125;</span><br><span class="line">	Ans = Solve(<span class="number">2</span> * N) - Solve(N),</span><br><span class="line">  Ans -= (St.second * St.second + ((St.second == <span class="number">1</span>) ? Ed.second : <span class="number">0</span>)), </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·6D"><a href="#rm-CF·6D" class="headerlink" title="$\rm CF·6D$"></a>$\rm CF·6D$</h1><blockquote>
<p>有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。</p>
<p>不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。</p>
<p>$n\leq 10$</p>
</blockquote>
<p>看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, a, b, blood[MAXN], i, j, k, l ; </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; From[MAXN][MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;	</span><br><span class="line">	Print(step - <span class="number">1</span>, From[step + <span class="number">1</span>][jj][kk].first, From[step + <span class="number">1</span>][jj][kk].second) ;</span><br><span class="line">	<span class="keyword">int</span> tow = dp[step][From[step + <span class="number">1</span>][jj][kk].first][From[step + <span class="number">1</span>][jj][kk].second] ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">1</span> ; qwq &lt;= dp[step + <span class="number">1</span>][jj][kk] - tow ; ++ qwq) <span class="built_in">printf</span>(<span class="string">"%d "</span>, step) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; blood[i], ++ blood[i] ;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">2</span>][blood[<span class="number">1</span>]][blood[<span class="number">2</span>]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= blood[i - <span class="number">1</span>] ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= blood[i] ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">int</span> down_ = (j + b - <span class="number">1</span>) / b ;</span><br><span class="line">				<span class="keyword">if</span> (dp[i][j][k] &gt; INF) <span class="keyword">continue</span> ;</span><br><span class="line">				<span class="keyword">int</span>	up_ = max(down_, max((blood [i + <span class="number">1</span>] + b - <span class="number">1</span>) / b, (k + a - <span class="number">1</span>) / a)) ;</span><br><span class="line">				<span class="keyword">for</span> (l = down_ ; l &lt;= up_ ; ++ l)&#123;</span><br><span class="line">					<span class="keyword">int</span> now_j = max(<span class="number">0</span>, k - a * l) ;</span><br><span class="line">          <span class="keyword">int</span> now_k = max(<span class="number">0</span>, blood[i + <span class="number">1</span>] - b * l) ;</span><br><span class="line">					<span class="keyword">if</span> (dp[i + <span class="number">1</span>][now_j][now_k] &gt; dp[i][j][k] + l)</span><br><span class="line">						dp[i + <span class="number">1</span>][now_j][now_k] = dp[i][j][k] + l, </span><br><span class="line">          	From[i + <span class="number">1</span>][now_j][now_k] = Mp(j ,k) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[N][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; Print(N - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF-·6E"><a href="#rm-CF-·6E" class="headerlink" title="$\rm CF ·6E$"></a>$\rm CF ·6E$</h1><blockquote>
<p>给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。</p>
<p>$n\leq 100,000$</p>
</blockquote>
<p>憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233</p>
<p>值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。</p>
<p>然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, h1 = <span class="number">1</span>, t1 = <span class="number">0</span>, h2 = <span class="number">1</span>, t2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ;</span><br><span class="line">  <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ;</span><br><span class="line">  q[++ t1] = p[++ t2] = i ; </span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123;</span><br><span class="line">  	l ++ ; <span class="keyword">while</span> (q[h1] &lt; l) ++ h1 ; <span class="keyword">while</span> (p[h2] &lt; l) ++ h2 ;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, s[i] - s[l - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是二分$st$表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_ST</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> H = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= H ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) &lt;= N + <span class="number">1</span> ; ++ i)</span><br><span class="line">			dp1[i][j] = max(dp1[i][j - <span class="number">1</span>], dp1[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]), </span><br><span class="line">			dp2[i][j] = min(dp2[i][j - <span class="number">1</span>], dp2[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line">	<span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line">	<span class="keyword">return</span> max(dp1[l][k - <span class="number">1</span>], dp1[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line">	<span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line">	<span class="keyword">return</span> min(dp2[l][k - <span class="number">1</span>], dp2[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		dp1[i][<span class="number">0</span>] = dp2[i][<span class="number">0</span>] = base[i] = qr() ;</span><br><span class="line">	build_ST(), ans = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		L = i, R = N ;</span><br><span class="line">		<span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">			Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span> (query_max(i, Mid) - query_min(i, Mid) &lt;= K) </span><br><span class="line">				t = Mid, L = Mid + <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">else</span> R = Mid - <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		L = t ;</span><br><span class="line">		<span class="keyword">if</span> (L - i + <span class="number">1</span> &gt; ans) ans = L - i + <span class="number">1</span>, Ans[cnt = <span class="number">1</span>][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L - i + <span class="number">1</span> == ans) Ans[++ cnt][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i][<span class="number">0</span>], Ans[i][<span class="number">1</span>]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·7C"><a href="#rm-CF·7C" class="headerlink" title="$\rm CF·7C$"></a>$\rm CF·7C$</h1><blockquote>
<p>给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。</p>
</blockquote>
<p>sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq</p>
<h1 id="rm-CF·7D"><a href="#rm-CF·7D" class="headerlink" title="$\rm CF·7D$"></a>$\rm CF·7D$</h1><blockquote>
<p>一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，<code>abaaba</code>是3阶字符串。</p>
<p>现在给定你一字符串，请你求出其所有前缀的的阶级之和。</p>
<p>$|\sf S|\leq 5,000,000$</p>
</blockquote>
<p>似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么</p>
<script type="math/tex; mode=display">
f_i=[\quad H[1...\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1...i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)</script><p>答案就是$\sum f_i$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">131</span> ;<span class="keyword">bool</span> mark[MAXN] ;</span><br><span class="line"><span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> N, Ans, i, j, h, ans[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1[MAXN], base2[MAXN], times[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	times[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base1[i] = (base1[i - <span class="number">1</span>] * base + S[i]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base2[i] = (base2[i - <span class="number">1</span>] * base + S[N - i + <span class="number">1</span>]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) times[i] = times[i - <span class="number">1</span>] * base % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), init() ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		h = i / <span class="number">2</span> ;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> t1 = base1[h] % Mod ;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ;</span><br><span class="line">		ans[i] = (t1 == t2) * (ans[h] + <span class="number">1</span>),  Ans += ans[i] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·8C"><a href="#rm-CF·8C" class="headerlink" title="$\rm CF·8C$"></a>$\rm CF·8C$</h1><blockquote>
<p>平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。</p>
</blockquote>
<p>我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN], Pre[MAXN], Max ;</span><br><span class="line"><span class="keyword">int</span> N, D[<span class="number">50</span>][<span class="number">50</span>], i, j, k, bit[<span class="number">50</span>], tp ; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Obj[<span class="number">50</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Obj[<span class="number">0</span>].fr &gt;&gt; Obj[<span class="number">0</span>].sc &gt;&gt; N ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; ++ j)</span><br><span class="line">			D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) </span><br><span class="line">      									+ (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ;</span><br><span class="line">	Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i) dp[i] = Inf ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit)), tp = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) bit[++ tp] = j + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= tp ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tp ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j != k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]])</span><br><span class="line">						dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]], </span><br><span class="line">          Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>) ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					<span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>])</span><br><span class="line">						dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>], </span><br><span class="line">        		Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ;</span><br><span class="line">				<span class="keyword">if</span> (dp[i] &lt; <span class="number">1061109567</span>) <span class="keyword">break</span> ;</span><br><span class="line">			&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[Max] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">while</span> (Max)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">		<span class="keyword">int</span> qaq = Max ^ Pre[Max] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; qaq) <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">		Max = Pre[Max] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·9D"><a href="#rm-CF·9D" class="headerlink" title="$\rm CF·9D$"></a>$\rm CF·9D$</h1><blockquote>
<p>用$n$个点组成二叉树，问高度大于等于$h$的有多少个。</p>
<p>$n\leq 35$</p>
</blockquote>
<p>没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; H ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; j ; ++ k)</span><br><span class="line">				dp[j][i] += dp[k][i - <span class="number">1</span>] * dp[j - k - <span class="number">1</span>][i - <span class="number">1</span>] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[N][N] - dp[N][D - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·10C"><a href="#rm-CF·10C" class="headerlink" title="$\rm CF·10C$"></a>$\rm CF·10C$</h1><blockquote>
<p>定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$</p>
<p>现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。</p>
<p>$N\leq 1000000$</p>
</blockquote>
<p>考虑$d()$的本质：</p>
<script type="math/tex; mode=display">
d(x)=\left\{\begin{array}{ll}{x \bmod 9,} & {x \bmod 9 \neq 0} \\ {9,} & {x \bmod 9=0}\end{array}\right.</script><p>那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。</p>
<p>那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, base[<span class="number">20</span>], A, B, i, j ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i % <span class="number">9</span>] ++, B += N / i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">			A += base[i] * base[j] * base[i * j % <span class="number">9</span>] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; A - B &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·10D"><a href="#rm-CF·10D" class="headerlink" title="$\rm CF·10D$"></a>$\rm CF·10D$</h1><blockquote>
<p>求两个串的最长公共上升子序列。</p>
<ul>
<li><p>$n\leq 500$</p>
</li>
<li><p>$n\leq 5,000$</p>
</li>
</ul>
</blockquote>
<p>第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">		dp[i][j] = dp[i - <span class="number">1</span>][j] ;</span><br><span class="line">		<span class="keyword">if</span> (base1[i] != base2[j]) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[i][j] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt; j ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][k] + <span class="number">1</span>)</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, f[j] = k ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。</p>
<p>于是最后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">	dfs(pre[x]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, n = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (N = qr(), i = <span class="number">1</span> ; i &lt;= N ; ++ i) A[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (M = qr(), i = <span class="number">1</span> ; i &lt;= M ; ++ i) B[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>, befo = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] != B[j]) f[i][j] = f[i - <span class="number">1</span>][j] ;</span><br><span class="line">			<span class="keyword">else</span> f[i][j] = res + <span class="number">1</span>, pre[j] = befo ;</span><br><span class="line">			<span class="keyword">if</span> (B[j] &lt; A[i]) </span><br><span class="line">				<span class="keyword">if</span> (res &lt; f[i - <span class="number">1</span>][j]) </span><br><span class="line">					res = f[i - <span class="number">1</span>][j], befo = j ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (ans &lt; f[N][i]) ans = f[N][i], n = i ; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; dfs(n) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·11C"><a href="#rm-CF·11C" class="headerlink" title="$\rm CF·11C$"></a>$\rm CF·11C$</h1><blockquote>
<p>你有一个$01$矩阵。里面有多少个正方形？</p>
<p>其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣：</p>
<p>第一种：每条边与矩阵的边平行的正方形；</p>
<p>第二种：每条边与矩阵的对角线平行的正方形。</p>
<p>$t\leq 10,000\quad 2\leq n,m\leq 250$</p>
</blockquote>
<p>然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base[x][y] != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    base[x][y] = <span class="number">-1</span>, ++ step ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &gt;= <span class="number">1</span> &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= <span class="number">1</span> &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + step &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + i][y] != <span class="number">-1</span>) | (base[x][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + step][y + i] != <span class="number">-1</span>) | (base[x + i][y + step] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = step &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x + lx &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (base[x + lx][y] != <span class="number">-1</span> || y &lt; step) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + lx - i][y - i] != <span class="number">-1</span>) | (base[x + lx - i][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + i][y - i] != <span class="number">-1</span>) | (base[x + i][y + i] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][j] != <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                res = <span class="number">0</span>, dfs(i, j, res) ;</span><br><span class="line">                <span class="keyword">if</span> (res % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; res / <span class="number">4</span> &lt;= min(N, M))</span><br><span class="line">                    ans += chk1(res / <span class="number">4</span>, i, j) + chk2(res / <span class="number">4</span>, i, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·11D"><a href="#rm-CF·11D" class="headerlink" title="$\rm CF·11D$"></a>$\rm CF·11D$</h1><blockquote>
<p>求简单无向图的环数。</p>
<p>$n\leq 19$</p>
</blockquote>
<p>一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。</p>
<p>观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从<code>lowbit</code>转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M, Mx = (1 &lt;&lt; N) - 1 ;</span><br><span class="line">for (i = 1, j = 0 ; j &lt; N ; ++ j, i &lt;&lt;= 1) f[i][j] = 1 ;</span><br><span class="line">for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] = A[v][u] = 1 ;</span><br><span class="line">for (s = 1 ; s &lt;= Mx ; ++ s)&#123;</span><br><span class="line">    for (i = 0 ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ;</span><br><span class="line">        for (j = 0 ; j &lt; N ; ++ j)&#123;</span><br><span class="line">            if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ;</span><br><span class="line">            if ((1 &lt;&lt; j) == low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans += f[s][i] ;</span><br><span class="line">            else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] += f[s][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>贪心</tag>
        <tag>动态规划/状压DP</tag>
        <tag>计算几何/基础的点、直线与圆</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-711 Virtual</title>
    <url>/2019/11/14/Codeforces-711/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个马来西亚老哥出的一场<code>Div2</code>，题目还算有点意思，于是就virtual了后三个题。</p>
<a id="more"></a>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。</p>
<p>$n,m\leq 100$</p>
</blockquote>
<p>一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; val[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= K ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= M ; ++ k)</span><br><span class="line">			dp[i][j][k] = Inf ; </span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">	for (j = i - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">		if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*/</span></span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">	for (j = 1 ; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">		if (j &gt;= pos[i])&#123;</span></span><br><span class="line"><span class="comment">			for (k = 1 ; k &lt;= M ; ++ k)</span></span><br><span class="line"><span class="comment">				for (l = 1 ; l &lt;= M ; ++ l)</span></span><br><span class="line"><span class="comment">					for (w = 1 ; w &lt;= K ; ++ w)</span></span><br><span class="line"><span class="comment">						if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else &#123;</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (base[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[<span class="number">1</span>][<span class="number">1</span>][i] = val[<span class="number">1</span>][i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K ; ++ j)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!base[i])&#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)&#123;</span><br><span class="line">				dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k] + val[i][k]);</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= M ; ++ l)</span><br><span class="line">					<span class="keyword">if</span> (k != l) </span><br><span class="line">             dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][l] + val[i][k]) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j][base[i]]) ;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k )</span><br><span class="line">				<span class="keyword">if</span> (k != base[i]) </span><br><span class="line">           dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Ans = Inf, i = <span class="number">1</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (Ans == Inf ? - <span class="number">1</span> : Ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 </p>
<p>每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环</p>
</blockquote>
<p>一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。</p>
<p>好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>, base = <span class="number">2</span> ;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">	dep[u] = deep, vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), deep + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)] &lt;= <span class="number">1</span>) rop[++ tot] = dep[u] - dep[to(k)] + <span class="number">1</span> ;</span><br><span class="line"> 	&#125;</span><br><span class="line">	vis[u] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N, Ans = <span class="number">1</span> ; <span class="keyword">int</span> qaq ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qaq), Add(i, qaq) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> ( !dep[i] ) dfs(i, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) </span><br><span class="line">	    cnt += rop[i], (Ans *= (expow(rop[i]) - <span class="number">2</span> + Mod)) %= Mod ;</span><br><span class="line">	Ans = Ans * expow(N - cnt) % Mod ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。</p>
<p>$n,k\leq 10^{18},\rm Mod=1e6+3$</p>
</blockquote>
<p>首先考虑答案就是</p>
<script type="math/tex; mode=display">
\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}</script><p>然后就变成了如果把这个东西求出来<del>传统艺能.jpg</del></p>
<p>1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。</p>
<p>2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来</p>
<p>3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$.</p>
<p>4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\\ &=(\prod\limits_{i=1}^{k}i,2^n)\\ &=(k!,2^n)
\end{aligned}</script><p>再结合抽屉原理，只需要枚举$2$的幂就可以算了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; ll Son, Mom ;</span><br><span class="line">ll N, M, Inv, _gcd, qwq, i, base = <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= Mod ;</span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		base &lt;&lt;= <span class="number">1</span> ; <span class="keyword">if</span> (base &gt;= M) &#123; ans = <span class="number">0</span> ; <span class="keyword">break</span> ;&#125; </span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1 1"</span>), <span class="number">0</span> ;  Son = <span class="number">1</span> ;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M - <span class="number">1</span> ; i &lt;&lt;= <span class="number">1</span>) qwq += (M - <span class="number">1</span>) / i ;  </span><br><span class="line">	_gcd = expow(<span class="number">2</span>, qwq), </span><br><span class="line">  Inv = expow(_gcd, Mod - <span class="number">2</span>) ; </span><br><span class="line">  Mom = expow(<span class="number">2</span>, N  % (Mod - <span class="number">1</span>) * (M - <span class="number">1</span>) % (Mod - <span class="number">1</span>)) ;</span><br><span class="line">  (Mom *= Inv) %= Mod ; </span><br><span class="line">  <span class="keyword">if</span> (M - <span class="number">1</span> &gt;= Mod) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, Mom, Mom), <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; M ; ++ i) </span><br><span class="line">    Son = Son * (expow(<span class="number">2</span>, N) - i + Mod) % Mod ; </span><br><span class="line">  (Son *= Inv) %= Mod, </span><br><span class="line">  Son = ((Mom - Son) % Mod + Mod) % Mod ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Son &lt;&lt; <span class="string">" "</span> &lt;&lt; Mom &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>动态规划/普通DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-840 Virtual</title>
    <url>/2019/11/14/Codeforces-840/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。</p>
<p>但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。</p>
<p>$n\leq 10^5$</p>
</blockquote>
<p>刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的……</p>
<p>然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(n,k)&=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\\&=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\\&=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\\&=\frac{n+1}{k+1}
\end{aligned}</script><p>然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。</p>
<p>你需要选出一些边（不一定联通），使得这些边构成的图符合要求。</p>
<p>$n\leq 3\cdot 10^5$</p>
</blockquote>
<p>首先考虑如果没有<code>-1</code>并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。</p>
<p>发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。</p>
<p>然后分类讨论：<code>0</code>的点和<code>1</code>的点</p>
<ul>
<li><code>0</code>的点。直接忽略，因为不产生影响；</li>
<li><code>1</code>的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。</li>
</ul>
<p>于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span> ; <span class="keyword">int</span> ret = base[u] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">if</span> (ST(to(k))) </span><br><span class="line">      res[++ tot] = (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ret ^= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (base[u] &lt; <span class="number">0</span>) ret = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), </span><br><span class="line">  	(base[i] &lt; <span class="number">0</span>) ? mr1 = i : (mr2 ^= base[i]) ;</span><br><span class="line">	<span class="keyword">if</span> (!mr1 &amp;&amp; mr2) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">	ST(mr1 ? mr1 : <span class="number">1</span>) ;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  sort(res + <span class="number">1</span>, res + tot + <span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。</p>
</blockquote>
<p>考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$ 后，两个数相同时，其乘积才会为完全平方数。</p>
<p>那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。</p>
<p>那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$</p>
<script type="math/tex; mode=display">
f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll d, ll z)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (z)&#123;</span><br><span class="line">		<span class="keyword">if</span> (z &amp; <span class="number">1</span>) (res *= d) %= Mod ;</span><br><span class="line">		( d *= d ) %= Mod, z &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N, dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; base[i] ; <span class="keyword">bool</span> mk = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">			ll p = trunc(<span class="built_in">sqrt</span>(base[i] * grp[j])) ;</span><br><span class="line">			<span class="keyword">if</span> (p * p == base[i] * grp[j])&#123;++ tm[j], mk = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!mk) grp[++ cnt] = base[i], tm[cnt] = <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">for</span> (Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (Frac[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">			Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; tot += tm[i], ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= tot ; ++ j) </span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tm[i] ; ++ k)	</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">0</span>, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --)</span><br><span class="line">					<span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt; N) </span><br><span class="line">            (dp[i][t] += </span><br><span class="line">             Frac[tm[i]] * Cm[tm[i] - <span class="number">1</span>][k - <span class="number">1</span>] % Mod </span><br><span class="line">           * Cm[j][l] % Mod * Cm[tot - j + <span class="number">1</span>][k - l] % Mod </span><br><span class="line">           * dp[i - <span class="number">1</span>][j] % Mod) %= Mod ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[cnt][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>这个D曾经单独写过：<a href="http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/" target="_blank" rel="noopener">Link</a></p>
<p>233反正就是乱搞就对了</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>思维题/计数</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E2</title>
    <url>/2019/11/14/xiaone-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛第二弹</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>$𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 </p>
</blockquote>
<p>性质题，找不出来人似乎就没了233</p>
<p>考虑最优情况下肯定会是<strong>单调地跳</strong>，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。</p>
<p>小$c$开始了漫长的<code>debug</code>的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。</p>
<p>等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出<code>NO</code></p>
</blockquote>
<p>题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。</p>
<p>我也是贪心做的，不过是正着做的。没有限制时，如果上一个是<code>(</code>，那我这一个就安排成<code>)</code>就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是<code>()(</code>这样，第三个括号被强制为右括号，就顺便把前一个右括号改成<code>(</code>，即变为<code>(()</code>，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; M, i = <span class="number">1</span> ; i &lt;= M ; ++ i) ok[qr()] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">if</span> (ok[i] &amp;&amp; !stk[base[i]].size())&#123;</span><br><span class="line">		ans[i] = <span class="number">1</span> ; </span><br><span class="line">		stk[base[i]].pb(mat[buc[base[i]]]) ;</span><br><span class="line">		ans[i] = <span class="number">1</span>, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = <span class="number">0</span> ;</span><br><span class="line">		mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">else</span> mat[i] = stk[base[i]].back(), ans[i] = <span class="number">1</span>, </span><br><span class="line">		 mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (!ans[i]) <span class="built_in">stack</span>[++ t] = i ; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">		 <span class="keyword">else</span> <span class="built_in">stack</span>[t --] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c%d "</span>, ans[i] ? <span class="string">'-'</span> : <span class="string">'+'</span>, base[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个$\{a\}$的子集来凑出$x$。同时，求最小$|\{a\}|$下凑出所有$x$的方案总数。</p>
</blockquote>
<p>第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。</p>
<p>第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ .</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。</p>
<p>JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。</p>
</blockquote>
<p><del>质疑题面在恰饭</del></p>
<p>一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。</p>
<p>然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。</p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。</p>
<p>$n,q\leq 100,000$</p>
</blockquote>
<p>一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。</p>
<p>考虑推式子</p>
<script type="math/tex; mode=display">
\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\\
x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\\
y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}</script><p>然后如果我们令$val_i=y\cdot A_i-x \cdot  B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去<code>uoj</code>群里问了一圈发现这个被<code>lxl</code>规约到了$n \sqrt n$的问题上面……</p>
<p>然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了<code>100ms~6500ms</code>这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。</p>
<p>然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? </span><br><span class="line">      		  blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇数块正着排，偶数块倒着排，就会快好多。</p>
<p>然后最后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写了一下午QAQ</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[MAXN] ; <span class="keyword">int</span> l, r, buc[MAXM], val[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> blg[MAXN], T[MAXM &lt;&lt; <span class="number">2</span>], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, X, Y, M, S, U, base[MAXN], cnt[<span class="number">2</span>][MAXM], pre[MAXN][<span class="number">2</span>], res, res2 ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> T[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R, p, v) ;</span><br><span class="line">    T[rt] = max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">0</span>][val[p]]) cnt[<span class="number">0</span>][val[p]] = Nxt[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">1</span>][val[p]]) cnt[<span class="number">1</span>][val[p]] = Pre[p] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;<span class="comment">// cout &lt;&lt; T[1] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">0</span>][val[p]] = min(cnt[<span class="number">0</span>][val[p]], p) ;</span><br><span class="line">    cnt[<span class="number">1</span>][val[p]] = max(cnt[<span class="number">1</span>][val[p]], p) ;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        base[i] = s[i] - <span class="string">'A'</span>,</span><br><span class="line">        pre[i][base[i]] = pre[i - <span class="number">1</span>][base[i]] + <span class="number">1</span>,</span><br><span class="line">        pre[i][base[i] ^ <span class="number">1</span>] = pre[i - <span class="number">1</span>][base[i] ^ <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][<span class="number">0</span>] - X * pre[i][<span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">-1</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i &gt;= <span class="number">0</span> ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + <span class="number">1</span>, buc[val[i]] = i ;</span><br><span class="line">    M = qr() ; S = <span class="built_in">pow</span>(M, <span class="number">0.5832</span>) ; U = <span class="built_in">ceil</span>((<span class="keyword">double</span>)M / S) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">0</span>], <span class="number">63</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">1</span>], <span class="number">-1</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = (i - <span class="number">1</span>) * S + <span class="number">1</span> ; j &lt;= i * S ; ++ j) blg[j] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) q[i].l = qr() - <span class="number">1</span>, q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + M + <span class="number">1</span>, comp) ; l = <span class="number">0</span>, r = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) upd(++ r) ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) upd(-- l) ;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">        ans[q[i].id] = res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233</p>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote>
<p>你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。</p>
<p>算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。</p>
<p>你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了）</p>
<p>然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。</p>
<p>现在，你需要求出完成上述一系列动作走过的最短路程。</p>
<p>$n \leq 20$</p>
</blockquote>
<p>一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。</p>
<p>然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个<code>floyd</code>，然后每次的代价就是</p>
<script type="math/tex; mode=display">
\mathsf{\min _{x\in S,y\in T}(f_{S,x}+dis_{x,y}+g_{T,y})+\min _{x\in S,y\in T}(g_{S,x}+dis_{x,y}+f_{T,y}})</script><p>然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[MAXS][MAXN], pre[MAXS][<span class="number">2</span>], sz[MAXS], ans ;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, ans = Inf ;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span> (f)) ; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) dis[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= E ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; k &gt;&gt; o,</span><br><span class="line">        A[j][k] = A[k][j] = o,</span><br><span class="line">        dis[j][k] = dis[k][j] = o ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span> * (dis[<span class="number">0</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>])), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][now] = min(f[i][now], f[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ; g[<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)][N - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)) + <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> g[i][now] = min(g[i][now], g[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; g[M][1] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] != N / <span class="number">2</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> stA = i, stB = (~i &amp; M), res = Inf, fg = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stA)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stB) </span><br><span class="line">						res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//        if (!fg) res = 0 ;</span></span><br><span class="line">		stB ^= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>), stB |= <span class="number">1</span> ;</span><br><span class="line">		stA ^= <span class="number">1</span>, stA |= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stB)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;</span><br><span class="line"><span class="comment">//		if (!fg) ans *= 2 ;</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>动态规划/普通DP</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
        <tag>数据结构/线段树</tag>
        <tag>动态规划/状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 2</title>
    <url>/2019/11/13/dsu-on-tree-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要就是整理一下dsu on tree的进阶版习题。</p>
<a id="more"></a>
<h1 id="0x01-rm-Cf375D-Tree-and-Queries"><a href="#0x01-rm-Cf375D-Tree-and-Queries" class="headerlink" title="$0x01$ $\rm Cf375D$  Tree and Queries"></a>$0x01$ $\rm Cf375D$  Tree and Queries</h1><blockquote>
<p>给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 </p>
</blockquote>
<p>考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，<code>calc</code>到每个点的时候先<code>del</code>掉原来的再<code>upd</code>新的信息……然后就做完了233</p>
<p>然而一开始的时候我调了好久，因为我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ts[base[u]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ts[base[u]] -- ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _count(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)&#123;</span><br><span class="line">	<span class="keyword">bool</span> fg = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!chk[base[u]]) </span><br><span class="line">		chk[base[u]] = <span class="number">1</span>, </span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, val), fg = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; </span><br><span class="line">	<span class="keyword">if</span> (!fg) chk[base[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	_count(u, fa, <span class="number">-1</span>) ; do_do(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	_count(u, fa, <span class="number">-1</span>) ; do_del(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去很对的亚子，但是错就错在<strong>必须每个点独立计算完贡献才能考虑下一个点</strong>，否则下一个点的信息就是错误的——也就是说不能整体<code>del</code>再整体<code>upd</code>，必须逐个逐个的<code>del</code>和<code>upd</code>。。然而事实上关键问题还是在$buc$的统计上出了问题233</p>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">	ts[base[u]] ++ ; </span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">	ts[base[u]] -- ; </span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) </span><br><span class="line">		dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">		ans[u].pb(query(<span class="number">1</span>, <span class="number">1</span>, N, qs[u][k] + <span class="number">1</span>, N)) ;</span><br><span class="line">	vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths"><a href="#0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths" class="headerlink" title="$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"></a>$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</h1><blockquote>
<p> 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 </p>
</blockquote>
<p>似乎是<code>Cf570D</code>的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的：</p>
<blockquote>
<p>我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数</p>
</blockquote>
<p>然后就是考虑怎么维护这个东西。</p>
<ul>
<li><p>不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$.</p>
</li>
<li><p>经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。</p>
</li>
</ul>
<p>看上去应该这么实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	f[dis[u]] = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> &amp; ans, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">		ans = max(ans, f[dis[u]] + dep[u] - <span class="number">2</span> * d) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">			ans = max(ans, f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	f[dis[u]] = max(f[dis[u]], dep[u]) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>), ans[u] = max(ans[u], ans[to(k)]) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) </span><br><span class="line">		dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span>, </span><br><span class="line">		ans[u] = max(ans[u], ans[son[u]]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != fa) </span><br><span class="line">			calc(to(k), u, ans[u], dep[u]), update(to(k), u) ;</span><br><span class="line">	<span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">		ans[u] = max(ans[u], f[dis[u]] - dep[u]) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">			ans[u] = max(ans[u], f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] - dep[u]) ;</span><br><span class="line">	f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。</p>
<p>唔，感觉这个题还是比较有技巧性的233</p>
<h1 id="0x03-rm-NOIP2018-模拟-·-树"><a href="#0x03-rm-NOIP2018-模拟-·-树" class="headerlink" title="$0x03$ $\rm NOIP2018$模拟 · 树"></a>$0x03$ $\rm NOIP2018$模拟 · 树</h1><p>这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：<a href="https://www.luogu.org/problem/U92408" target="_blank" rel="noopener">$\rm Link$</a></p>
<p>题面：</p>
<blockquote>
<p>给定一棵树。</p>
<p>令$[L,R]$描述的是序号在$[L,R]$内的点的集合。</p>
<p>同时，令函数$\boldsymbol F(\{ \rm S\})$表示令集合$\rm S$内的点联通的需要的最小边数。</p>
<p>问题则是求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])</script><p>$n\leq 100,000$</p>
</blockquote>
<hr>
<p>一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。</p>
<p>子树内的比较容易维护，考虑假设现在有了$\{1,2,3\},\{5,6\}$两个集合，将其视作两个连通块，当加进来$\{4\}$时，会和左右都相连接，不妨假设先与$\{1,2,3\}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用<strong>并查集+并查集的$size$</strong>来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。</p>
<p>之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的<code>ans_out</code>显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，<code>set</code>里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了</p>
<script type="math/tex; mode=display">
calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)</script><p>原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。</p>
<p>所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], op[MAXN] ;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span> ; &#125;</span><br><span class="line"><span class="keyword">void</span> _clear()&#123;</span><br><span class="line">	s.clear() ;</span><br><span class="line">	ansout = calc(N), ansin = <span class="number">0</span>, </span><br><span class="line">	s.insert(<span class="number">0</span>), s.insert(N + <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fr[x] ? x : fr[x] = _find(fr[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	s.insert(u) ; op[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; :: iterator l, r, mid ;</span><br><span class="line">	l = r = mid = s.find(u), l --, r ++ ;</span><br><span class="line">	ansout += calc(*r - *mid - <span class="number">1</span>) + calc(*mid - *l - <span class="number">1</span>) - calc(*r - *l - <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (op[u - <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="keyword">int</span> f1 = _find(u - <span class="number">1</span>), f2 = _find(u) ; </span><br><span class="line">		ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (op[u + <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="keyword">int</span> f1 = _find(u + <span class="number">1</span>), f2 = _find(u) ;</span><br><span class="line">		ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	fuck(u) ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> _update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	op[u] = <span class="number">0</span>, fr[u] = u, bg[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> _delete(to(k), u) ; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	_update(u, fa), ans += calc(N) - ansout - ansin ; </span><br><span class="line">	<span class="keyword">if</span> (!mk) _delete(u, fa), _clear() ; vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Warning"><a href="#rm-Warning" class="headerlink" title="$\rm Warning$"></a>$\rm Warning$</h1><ul>
<li><p>注意一个地方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br></pre></td></tr></table></figure>
<p>把这两句写反了会调一下午，欢迎尝试quq</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 1</title>
    <url>/2019/11/13/dsu-on-tree-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly ~Direct~ Counting~ on~ Tree}$，“优雅的树上暴力统计”。</p>
<a id="more"></a>
<h1 id="rm-0x01-前言-amp-技术分析"><a href="#rm-0x01-前言-amp-技术分析" class="headerlink" title="$\rm 0x01$ 前言$\&amp;$技术分析"></a>$\rm 0x01$ 前言$\&amp;$技术分析</h1><p>严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛：</p>
<blockquote>
<p>1、维护子树信息；</p>
<p>2、不能带修改操作。</p>
</blockquote>
<p>但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。</p>
<p>然后来看技术分析。</p>
<p>首先，假设我们有这样一个问题：</p>
<blockquote>
<p>给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。</p>
<p>$n,q\leq 5\cdot1e5$</p>
<p>一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。</p>
</blockquote>
<p>考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。</p>
<p>考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。</p>
<p>现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。</p>
<p>所以这样就解决了维护树上信息的问题，复杂度$n\log n$。</p>
<h1 id="0x02-入门题目选整"><a href="#0x02-入门题目选整" class="headerlink" title="$0x02$ 入门题目选整"></a>$0x02$ 入门题目选整</h1><p>感觉大部分<code>blog</code>找的题目都很不清真233</p>
<h2 id="rm-Task1-rm-Cf600E-Lomsat-gelral"><a href="#rm-Task1-rm-Cf600E-Lomsat-gelral" class="headerlink" title="$\rm Task1$ $\rm Cf600E$ Lomsat gelral"></a>$\rm Task1$ $\rm Cf600E$ Lomsat gelral</h2><p>一句话题意</p>
<blockquote>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 </p>
</blockquote>
<p>考虑套$\rm EDCT$的板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">		dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">		<span class="keyword">if</span> (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa, <span class="number">1</span>) ; ans[u] = res ; <span class="keyword">if</span> (son[u]) vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!mk) calc(u, fa, <span class="number">-1</span>), res = <span class="number">0</span>, max_cnt = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是最后的<code>calc</code>函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	buc[clr[u]] += mk ; </span><br><span class="line">	<span class="keyword">if</span> (mk &gt; <span class="number">0</span> &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123;</span><br><span class="line">		<span class="keyword">if</span> (buc[clr[u]] &gt; max_cnt) </span><br><span class="line">		    res = <span class="number">0</span>, max_cnt = <span class="number">1l</span>l * buc[clr[u]] ;</span><br><span class="line">		res += <span class="number">1l</span>l * clr[u] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; </span><br><span class="line">		calc(to(k), u, mk) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Task2-Cf570D-Tree-Requests"><a href="#rm-Task2-Cf570D-Tree-Requests" class="headerlink" title="$\rm Task2 ~Cf570D$ Tree Requests"></a>$\rm Task2 ~Cf570D$ Tree Requests</h2><p>一句话题意：</p>
<blockquote>
<p>给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. </p>
</blockquote>
<p>这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	buc[dep[u]] ^= (<span class="number">1</span> &lt;&lt; base[u]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">while</span> (x) ret += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(ret &lt;= <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	buc[dep[u]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">		ans[u].pb(getl(buc[qs[u][k]])) ; </span><br><span class="line">	vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-814 Virtual</title>
    <url>/2019/11/13/codeforces-814/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场<code>cn</code> round，然后每次<code>cn</code> round的最后一题都会很奇怪……</p>
<p>⑧说了，计数是不可能会的，这辈子都不可能了QAQ</p>
<a id="more"></a>
<h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega $"></a>$\Omega $</h1><p>$\rm virtual$了一场……说实话这种<code>div2 only</code>的场次最后一题就经常比较毒……</p>
<p><del>老规矩，前面几题用来水字数</del></p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给出一个长度为$N$的非负整数序列$a_i$与长度为$K$的正整数序列$b_i$，满足$a_i$中刚好有$K$个$0$，且任一正整数在序列$a$和序列$b$中的出现次数的和不会超过$1$。</p>
<p>现在试判断是否存在一种方法，使得用$b_i$中的元素替换$a_i$中的$0$得到的序列不是递增序列。 </p>
</blockquote>
<p>sb一眼题，显然如果递减放进去还是递增就无解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline bool cmp(int a, int b)&#123; return a &gt; b ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K ; int j = 1 ;</span><br><span class="line">	for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ;</span><br><span class="line">	for (i = 1 ; i &lt;= K ; ++ i) cin &gt;&gt; t[i] ; sort(t + 1, t + K + 1, cmp) ;</span><br><span class="line">	for (i = 1 ; i &lt;= N ; ++ i) if (!base[i]) base[i] = t[j ++] ;</span><br><span class="line">	for (i = 1 ; i &lt; N ; ++ i) if (base[i] &gt; base[i + 1]) return puts(&quot;Yes&quot;), 0 ;</span><br><span class="line">	return puts(&quot;No&quot;), 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给定两个长度为$n$的不相同序列$a$和$b$，这两个序列至少有一个位置不同</p>
<p>现在需要构造一个长度为$n$的排列$p$，使得$p$与$a$只有一个地方不同，且$p$与$b$也只有一个地方不同</p>
</blockquote>
<p>一眼就可以看出最多有两个位置不同，否则一定不合法。考虑分类讨论，如果只有一个位置不同那就放上那个没出现过的数字；如果有两个位置不同，那就考虑是$A$中第一个位置放多了还是第二个位置放多了，放上$B$的就完了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), Ma[A[i]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), Mb[B[i]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i] != B[i]) pos[++ cnt] = i ; </span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">			<span class="keyword">if</span> (!Ma.count(i) &amp;&amp; !Mb.count(i)) &#123; A[pos[<span class="number">1</span>]] = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Ma[A[pos[<span class="number">1</span>]]] &gt; <span class="number">1</span> &amp;&amp; !Ma[B[pos[<span class="number">1</span>]]])&#123; </span><br><span class="line">		A[pos[<span class="number">1</span>]] = B[pos[<span class="number">1</span>]] ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; </span><br><span class="line">		A[pos[<span class="number">2</span>]] = B[pos[<span class="number">2</span>]] ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来觉得是道构造题，后来发现是道细节模拟题。。。</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给你一个由小写字母构成的字符串.<br>有$q$个询问，每个询问给出数字$m$和小写字母$c$，你可以任意地修改字符串中的$m$个字符，求最多能够使字符串中含有多少个连续相同的字母$c$.<br>每个询问各自独立.<br>$|\rm S|\leq 1,500$</p>
</blockquote>
<p>其实感觉复杂度一点也不对……比如我觉得这题可以做到$5e4$以上……</p>
<p>考虑弱化版（原版）的解法，大概就是用$f_{i,j}$表示前$i$个字符用了$k$次机会最长的连续段有多长。然后就可以直接$O(26n^2)$给预处理出来，每次询问回答一下即可。</p>
<p>但是我们发现这玩意儿复杂度一点也不平衡，因为预处理贼慢但是回答贼快。于是考虑有哪些性质没用。我们考虑预处理出原串中对于一个字符$c$，最近的两个$c$之间的位置来，然后如果要修改就显然先修改跨度小的$c_i$和$c_{i+1}$中间的部分，因为这样肯定不会更劣。同时只有把中间的非$c$区域占满才能使之连通，故每次对于一个给定的$k$，二分查找一下可以占满的区间，剩下的随便铺，对于这些占满的区间提前预处理出贡献的前缀和就完了。复杂度大概是$q\log n+26n$</p>
<p>然而升级版只是口胡，什么时候闲下来再写吧qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] == <span class="string">'a'</span> + i) dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] - <span class="string">'a'</span> == i) dp[i][j][k] = dp[i][j - <span class="number">1</span>][k] + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j][k] = max(dp[i][j][k], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">			ans[i][k] = max(ans[i][k], dp[i][j][k]) ;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;k, &amp;In) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans[(<span class="keyword">int</span>)In - <span class="string">'a'</span>][k] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p> 有$n$个圆，将其分为两组。每组中，只有奇数个圆覆盖的区域的才会算入面积，求可能的最大面积。 </p>
</blockquote>
<p>首先考虑贪心。大概就是说原本的覆盖一定可以看做一团一团独立的子问题。将圆按照面积大小排序，之后考虑选每一堆最大的放到第一堆，然后把与之原本冲突的放到第二堆。这样可以发现最终减去的部分面积变成了之前产生贡献的部分面积……然而这不重要，重要的是这样保证了每次选的一定都是面积最大的圆的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			<span class="keyword">if</span> (check_in(base[i], base[j])) ++ mark[j] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (!mark[i] || (mark[i] &amp; <span class="number">1</span>)) Ans += get_S(base[i]) ; <span class="keyword">else</span> Ans -= get_S(base[i]) ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans) ;  	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这个贪心似乎不好想，于是考虑一种精妙的$\rm dp$<del>其实更不好想</del>。考虑按照圆从大到小枚举顺次连边，最后连出来的会是一个森林状物。然后对于这个东西， 定义$dp[u][0/1][0/1]$表示以点$u$为根的子树里面，除$u$之外分成两堆之后，两堆分别的高度为偶数/奇数时的最优值。这东西就可以直接分类讨论求和+转移。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(C A, C B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_S</span><span class="params">(C A)</span></span>&#123; <span class="keyword">return</span> Pi * A.r * A.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_in</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r + B.r &gt; dist(A, B) ; &#125;</span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> next, to ;</span><br><span class="line">	&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    	E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    	E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> faa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">2</span>][<span class="number">2</span>] ; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">if</span> (to(k) == faa) <span class="keyword">continue</span> ;</span><br><span class="line">			do_dp(to(k), u) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">					f[ii][jj] += dp[to(k)][ii][jj] ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">				dp[u][ii][jj] = max(</span><br><span class="line">                	f[ii ^ <span class="number">1</span>][jj] + (<span class="number">1l</span>l * (ii ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r), </span><br><span class="line">					f[ii][jj ^ <span class="number">1</span>] + (<span class="number">1l</span>l * (jj ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r)) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">			<span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">				<span class="keyword">if</span> (check_in(base[i], base[j])) </span><br><span class="line">					<span class="keyword">if</span> (!fa[j] || base[fa[j]].r &gt; base[i].r) fa[j] = i ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (fa[i]) Add(i, fa[i]) ;	</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	<span class="keyword">if</span> (!fa[i]) do_dp(i, <span class="number">0</span>), Ans += dp[i][<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans * Pi) ;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给出$n$个点和每个点的度让你构造出一张无向图满足以下两条性质：</p>
<ul>
<li><p>$1.$点1到点$i$仅有<strong>唯一</strong>一条最短路</p>
</li>
<li><p>$2.$点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度</p>
</li>
</ul>
<p>求能构成满足条件的无向图的个数   $n\leq 50, 2\leq degree_i\leq 3$</p>
</blockquote>
<p>这种计数题会是不可能会的，这辈子都不可能会了qaq</p>
<p>考虑一个$idea$，因为这张图无权，所以最短路一定会是$\it bfs$的分层。那么对于一个$i$来讲，他的要么和$i-1$在同一层，要么就在$i-1$的下一层。</p>
<p>那么考虑记$f_{i,j}$表示前$i$个点中有$j$个和$i$在同一层的方案数。那么考虑这东西的转移跟上一层中点的度数有关，也就是需要记$dp_{k,c_1,c_2}$表示当前层有$k$个点，上一层度数为$2$的点有$c_1$个，度数为$3$的点有$c_2$个这一子状态的方案数。那么有如下：</p>
<script type="math/tex; mode=display">
dp_{i,j,k}=\begin{cases}{1} & (i=j=k=0)\\ \\ {\sum\limits_{l=2}^{k-1} dp_{i,j,k-l-1} \cdot\left(\begin{array}{c}{k-1} \\ {l}\end{array}\right) \cdot N_{l+1}} &(i=j=0,k>0) \\ \\ {(j-1) \cdot dp_{i,j-2,k}+k \cdot dp_{i,j,k-1}} & (i=0,j>0)\\ \\{j \cdot dp_{i-1,j-1,k}+k \cdot dp_{i-1,j+1,k-1}} & (i>0)\\ \\{0}\end{cases}</script><p>其中$N_i$表示<strong>$\boldsymbol{i-}$项链数</strong>，也就是长度为$i$、元素各异、镜像对称的单环的数量，计算方式如下：</p>
<script type="math/tex; mode=display">
N_i=\begin{cases} 1 & (i=2)\\ \frac{(i-1)!}{2} &(i>2)\\ 0 & \rm{otherwise}\\ \end{cases}</script><p>对于第二个转移，就是考虑向上一层插入一个点使其成为度数为$3$的点。考虑因为度数为$3$且题目要求“有位移最短路”，所以同一层中只有可能是简单的平边相连。所以就是考虑枚举原来的点里面可以与新加入的点组成项链的方案数。注意这里项链数必须$&gt;2$原因是题目中强调了不能有两个点之间连$&gt;1$条边。</p>
<p>对于第三个转移，考虑插入一个点使其度数为$2$，这一步转移即考虑$j-1$个点中选择一个可能变成$2$度的点和新加近来这个点相连有$j-1$种方案，相连之后两个点度数都变为$2$；同时考虑另一种可能性，就是这一个点和一个可能变成$3$度的点相连，那么原来的二度点变为三度点，新加进来的变成二度点。</p>
<p>对于第四个转移，考虑这一层最后一个加进来的节点，要么和上一层中一个可能变成$2$度的点相连要么和可能变成$3$度的点相连。</p>
<p>然后最后的答案就是枚举最后一层的点数</p>
<script type="math/tex; mode=display">
ans =\sum_{j=1}^{n}f_{n,j}\cdot g_{0,c_1,c_2}</script><p>其中$c_1$和$c_2$表示枚举到现在有多少个$d=2$和$d=3$的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> N, clr1, clr2, base[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, l ; ll dp[MAXN][MAXN] ;</span><br><span class="line">ll Ans, A[MAXN], f[MAXN][MAXN][MAXN], Cm[MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N  ; Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">			Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ; </span><br><span class="line">	<span class="keyword">for</span> ( A[<span class="number">1</span>] = A[<span class="number">0</span>] = <span class="number">0</span>, A[<span class="number">2</span>] = A[<span class="number">3</span>] = <span class="number">1</span>, i = <span class="number">4</span> ; i &lt;= N ; ++ i) A[i] = A[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % Mod ;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; <span class="comment">//Calculate g</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - j ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (!j &amp;&amp; k)</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt; k ; ++ l)</span><br><span class="line">					(f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - l - <span class="number">1</span>] * Cm[k - <span class="number">1</span>][l] % Mod * A[l + <span class="number">1</span>] % Mod) %= Mod ;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (j &gt;= <span class="number">2</span>) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j - <span class="number">2</span>][k] * (j - <span class="number">1</span>) % Mod) %= Mod ;</span><br><span class="line">				<span class="keyword">if</span> (k) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - <span class="number">1</span>] * k % Mod) %= Mod ; </span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N - i ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - i - j ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j) (f[i][j][k] += f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * j % Mod) %= Mod ;</span><br><span class="line">				<span class="keyword">if</span> (k) (f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * k % Mod) %= Mod ;</span><br><span class="line"><span class="comment">//				cout &lt;&lt; f[i][j][k] &lt;&lt; endl ;</span></span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//Calculate dp</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; dp[base[<span class="number">1</span>] + <span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = base[<span class="number">1</span>] + <span class="number">2</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i - base[<span class="number">1</span>] - <span class="number">1</span> ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, k = <span class="number">1</span> ; k &lt;= i - j ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (base[i - j - k + <span class="number">1</span>] &lt;= <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">				(dp[i][j] += (dp[i - j][k] * f[j][clr1][clr2] % Mod)) %= Mod ;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (base[N - i + <span class="number">1</span>] == <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">		(Ans += (dp[N][i] * f[<span class="number">0</span>][clr1][clr2]) % Mod) %= Mod ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/构造</tag>
        <tag>思维题/计数</tag>
        <tag>动态规划/普通DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E1</title>
    <url>/2019/11/13/xiaonei-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛选整</p>
<p>大概难度都是TG里面$2$~$3$左右的。</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给定直线上$n\leq 2000$个建筑的坐标，两种覆盖方式，$A:$覆盖长度为$L$，可以用$p$次；$B$：覆盖长度为$2L$，可以用$q$次。求最小的$L$.</p>
</blockquote>
<hr>
<p>首先就是可以知道$p,q$可以缩到$p+q\leq n$，否则答案就是$1$。</p>
<p>之后考虑二分一个$L$，$check$其正确性。$check$时感觉贪心并不是很好贪，可能会有比较妙的贪心，但这个地方选择一种更加稳妥的$dp$。考虑$f_{i,j}$表示两种覆盖分别用了$i,j$个最多能覆盖到哪个建筑，则</p>
<script type="math/tex; mode=display">
f_{i,j}=\max(go_p[f_{i-1,j}+1], go_q[f_{i,j-1}+1])</script><p>其中$go_x[P]$表示在位置$P$使用第$x$种覆盖能够覆盖多少建筑。于是最后复杂度$O(n^2\log n)$.</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>定义<code>string</code>类型的递推$f_0=’0’$，$f_1=’1’$，$f_i=f_{i-2}+f_{i-1}$，其中$+$表示<code>string</code>类型的连接。多组询问，询问$f_n$中区间$\rm [L,R]$内的串。$n\leq 1e9,~\rm L\leq R\leq 2e9,\sum (R-L)\leq 1e7$</p>
</blockquote>
<hr>
<p>拿到这题首先应该手写出前$6$项来找规律……</p>
<p>发现$f_i.size()$就是斐波那切数列的第$i$项，并且序号奇偶性相同的两项$f_i,f_j$，当$j&lt;i$时满足$f_j$是$f_i$的前缀，这东西可以数学归纳出来<del>并且肉眼看不出来</del>。</p>
<p>之后可以发现$\rm L,R\leq 2e9$，而斐波那切数列的第$50$项已经超过了这个范围。于是考虑对于一个询问$f_n[L,R]$，先把$n$缩到$50$以内，然后分奇偶性赋值为$48/49$，然后每次考虑把$f_n$分成$f_{n-2}+f_{n-1}$，分治下去。注意到其实是可以预处理一些状态来提速，于是选择预处理前$20$项左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; f[n].substr(L, R - L + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt; fib[n - <span class="number">2</span>]) solve(n - <span class="number">2</span>, L, min(R, fib[n - <span class="number">2</span>])) ; </span><br><span class="line">	<span class="keyword">if</span> (R &gt;= fib[n - <span class="number">2</span>]) solve(n - <span class="number">1</span>, max(<span class="number">0l</span>l, L - fib[n - <span class="number">2</span>]), R - fib[n - <span class="number">2</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>我们有一张方格纸，他大概长这样：</p>
<p><img src="https://s2.ax1x.com/2020/01/09/lfSP0I.jpg" alt></p>
<p>我们现在要从左上角$(0,0)$到右下角$(n,m)$画一条直线，然后询问它经过黑格子的长度与总长度的比值，并输出一个互质分数的形式。</p>
</blockquote>
<p>sb结论题，以下是结论，觉得证的挺好的（</p>
<blockquote>
<p>无论怎样，$rqy$太强了！！</p>
<p>以下是$rqy$给的严谨证明：</p>
<ul>
<li><p>对于每个二元组$(n,m)$，$(\frac{n}{\gcd(n,m)},\frac{m}{\gcd(n,m)})$ 的本质与$(n,m)$是一样的。</p>
</li>
<li><p>当$n$是偶数<strong>或者</strong>$m$是偶数的时候，答案显然是$\frac{1}{2}$，因为我们可以考虑把所有的颜色翻转，答案是一样的。</p>
</li>
<li><p>余下的情况，由于我们现在已经缩小了问题规模使得$n,m$互质，所以只有可能是$n、m$均为奇数，此时我们考虑如下（前方高能）：</p>
</li>
<li><p>由于横向有$m$段，纵向有$n$段，所以总共这条直线可以分成$n \times m$段，当然，有些段的颜色相同。我们这么做的目的是为了保证<strong>每一段不会跨过每个格子的边界，即同一段的每个部分都会是相同的颜色</strong></p>
</li>
<li><p>通过观察可以得到，对于从左上到右下的第$i$段，它应该在第$\lfloor \frac{i}{n} \rfloor$<strong>列</strong>，第$\lfloor \frac{i}{m} \rfloor$<strong>行</strong>。注意这个地方，虽然$n$表示的是行，但是$\lfloor \frac{i}{n} \rfloor$表示的是列。道理其实很简单：</p>
<ul>
<li>对于第$i$段，它占的部分是$\frac{i}{n \times m}$ ，所以所属的行应该是$\lfloor \frac{i}{n \times m} \cdot n \rfloor$，所属的列为$\lfloor \frac{i}{n \times m} \cdot m \rfloor$，约分一下答案显而易见。 </li>
</ul>
</li>
<li><p>基于前两条，我们会有一个比较平凡的结论：对于某一段$i$，当$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$为偶数的时候，这一段在黑色的格子上；是奇数的时候，这一段在白色格子上。</p>
</li>
<li><p>我们可以考虑对$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$搞一些事情：</p>
<script type="math/tex; mode=display">
\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor\begin{align} \\ \\&\equiv\frac{i - i \mod n}{n}+\frac{i - i \mod m}{m} \pmod 2\\ &\equiv 2i - i \mod n - i \mod m \pmod 2\\  & \equiv i \mod n  + i  \mod m \pmod 2\end{align}</script></li>
</ul>
<p>上式的目的其实就是通过对$2$取模建立同余式，由于$n,m$均为奇数，所以在$\mod 2$意义下都是$1$，可以直接除掉。那么接下来我们考虑，这样的$i$有多少个呢？很显然的，在$0 \to n - 1$中，共有$\frac {n-1}{2}$个奇数,$\frac{n+1}{2}$个偶数；在$0 \to m-1$中，共有$\frac {m-1}{2}$个奇数，$\frac {m+1}{2}$个偶数。因为只有奇偶性相同时，才属于黑色格子，所以由中国剩余定理得</p>
<script type="math/tex; mode=display">
\begin{aligned}\sum check(i) &= \frac{n-1}{2} \cdot \frac{m-1}{2} + \frac{n+1}{2} \cdot \frac{m+1}{2} \\& = \frac{2nm + 2}{4}\end{aligned}</script><p>那么最终答案就是</p>
<script type="math/tex; mode=display">
\frac {\sum check(i)}{n \cdot m} = \frac{n \cdot m+1}{2n \cdot m}</script></blockquote>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>给定一棵树，某些点是关键点。每条边有代价，每次可以删掉一条边并且获得这条边的代价。求最少的代价，使得所有关键点不连通。$n\leq 300,000$</p>
</blockquote>
<hr>
<p>直观的想法是$dp$，即记$f_x$表示处理完以$x$为根的子树内的关键点（不互相连通）的最少代价。但是发现这样似乎很难转移，因为转移时要考虑子树之间的关键点是否连通。于是考虑再记$g_x$表示处理完以$x$为根的子树内关键点互相不连通，且不与外界连通的最小代价。</p>
<p>那么考虑转移，记$x$为当前节点，$y$为$x$的子节点：</p>
<ul>
<li><p>当$x$为关键点时，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
f_x&=\sum g_y \\
g_x&=f_x+pre_x
\end{align*}</script></li>
<li><p>当$x$不为关键点时，有</p>
<script type="math/tex; mode=display">
f_x=\min(\sum f_y-f_{y'}+g_{y'})\\
g_x=\min(f_x+pre_x, \sum g_y)</script></li>
</ul>
<p>唔，这个第二个转移的$f_x$还是需要编一编的，大概就是考虑现在只需要不让子树内部连通，那么就可以选出一棵子树来内部不连通，其他子树都不和外部连通，可知这样是最优的（因为天选之子不需要“不和外部连通”）。</p>
<p>学习了，学习了。</p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>现在有如下一个表达式： $0 ~a_1 b_1 a_2 b_2 … a_n b_n$。其中$a_i$为一个位运算符（$\boldsymbol{and/or/xor}$），$b_i$是一 个整数。每一对$a_i,b_i$有$c_i$的概率会消失，求表达式的结果的期望。  </p>
</blockquote>
<hr>
<p>需要建立某种神秘的条件反射，就是遇到位运算的题目就要想到“位与位之间是无关的”。那么就可以直接按位做，令$f_{i,0/1}$表示计算完前$i$对，现在这一位为$0/1$的概率是多少。转移时别忘了加上当前这一对被删除的概率，即$f_{i-1,0/1}$。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>奇怪的技巧</tag>
        <tag>有趣的二分答案</tag>
        <tag>动态规划/树形DP</tag>
        <tag>数学/概率,期望</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】分治在FFT上的应用</title>
    <url>/2019/08/27/fzfft-md/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是cdq分治+FFT。</p>
<p>分治FFT解决的问题的一般形式：</p>
<p>给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且</p>
<script type="math/tex; mode=display">
f_i=\sum_{j=1}^{i} f_{i-j} g_j</script><p>求$f_1,f_2\cdots f_{n-1}$</p>
<a id="more"></a>
<p>先展开观察性质</p>
<script type="math/tex; mode=display">
\begin{aligned}f_1&=g_1f_0,\\\ f_2&=g_1f_1+g_2f_0,
\\\ f_3&=g_1f_2+g_2f_1+g_3f_0\\\ f_4&=g_1f_3+g_2f_2+g_3f_1+g_4f_0=g_1^4\end{aligned}</script><p>我们发现如果将整个序列分成两半，前一半对后一半的贡献是：</p>
<script type="math/tex; mode=display">
o_p=\sum_{i=l}^{\rm{mid}}f_ig_{p-i}</script><p>其中$p\in(\rm{mid},r]$，$o$是额外的贡献。</p>
<p>我们发现，其实这是个卷积的形式，毕竟对于普通的卷积定义是：</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\leq i} a_jb_{i-j}</script><p>于是我们就可以通过分治，每次暴力NTT计算前一半对后一半的贡献，类似于cdq分治的操作，复杂度$n\log ^2n$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">if</span> (!l) F[l] = <span class="number">1</span> ; <span class="keyword">return</span> ;&#125; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, L = r - l + <span class="number">1</span>, Len = <span class="number">1</span>, l1 = <span class="number">0</span> ;</span><br><span class="line">    cdqNTT(l, mid) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt;= L) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="built_in">memcpy</span> (P, G, <span class="keyword">sizeof</span>(LL) * (r - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memcpy</span> (Q, F + l, <span class="keyword">sizeof</span>(LL)*(mid - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memset</span> (P + r - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - r + l)) ;</span><br><span class="line">    <span class="built_in">memset</span> (Q + mid - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - mid + l)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>), NTT(Q, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = P[i] * Q[i] % Mod ;</span><br><span class="line">    NTT(P, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) (F[i] += P[i - l]) %= Mod ; cdqNTT(mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]) ;</span><br><span class="line">    cdqNTT(<span class="number">0</span>, N - <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, F[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，得出结论我的分治没学好qaq</p>
<p>但是如果换一个角度观察，设出两个形式幂级数，即令</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm{F}&=\sum f_ix^i\\\
\rm{G}&=\sum g_ix^i
\end{aligned}</script><p>然后我们把他俩卷起来，且因为F本身就是卷积的形式，即有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm{F} *\rm{G} & =\sum x^i\sum_{j\leq i} f_ig_j
\\\
&= \sum x_i f_{i+1}\\\
&= \rm{F}-f_0
\end{aligned}</script><p>那么先移项，之后两边同时卷一个$\rm{G}-1$ 的逆就可以得到：</p>
<script type="math/tex; mode=display">
\rm{F}= \frac{1}{1-G}</script><p>于是直接求一个逆就完了，复杂度$n\log n$。</p>
<p>不得不说这也算是一个小技巧了qwq</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Berlekamp-Massey算法</title>
    <url>/2019/08/26/BM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Berlekamp-Massey</strong>算法用于在$O(n^2)$的时间内求解数列的递推式。</p>
<p>形式化地讲，给定 $a_i(i=1,2,3…n-1,n)$，求一组 $b_j(j=1,2,3…m)$，满足：</p>
<script type="math/tex; mode=display">
\forall i\geq m+1, a_i=\sum _{j=1}^{m} a_{i-j}b_j</script><p>其中或许会有条件限制$m$最小。</p>
<a id="more"></a>
<h1 id="神仙构造"><a href="#神仙构造" class="headerlink" title="神仙构造"></a>神仙构造</h1><p>考虑增量构造。即已知满足前 $i - 1$ 项的递推式，如何求出也满足第 $i$ 项的。</p>
<p>定义 $\Delta_i$ 表示第 $i$ 项与当前递推式之间的差值，$\rm F$ 为当前暂时满足条件的递推式 $\{f_i\}$。</p>
<p>那么定义：</p>
<script type="math/tex; mode=display">
\Delta_i=a_i-\sum_{j=1}^{m}f_ja_{i-j}</script><p>考虑如果 $\Delta_i=0$ 那么就不需要管，现在考虑 $\Delta_i \not =0$  的情况。</p>
<p>考虑一个大体的构造思想，我们最后构造出的 $\rm F$ 尽量是让前面满足的递推关系满足，并且使得新加进来的一组关于 $i$ 的递推关系也满足。</p>
<p>考虑令 $\mathrm{F}_k$ 表示修改过 $k$ 次之后的递推式，$\mathrm{fail}_k$ 表示第 $k$ 个版本的递推式是哪个 $i$ 开始失配的。不妨记算完 $a_{i-1}$ 的 $\rm F$ 是第 $q$ 个版本，即 $\rm F_q$</p>
<p>那么考虑我们需要构造一个这样的 $\mathrm F’:\{f’_1,f’_2,\dots f_{m’}’\}$ ，使得 </p>
<script type="math/tex; mode=display">
\forall p\in[m'+1,i-1]\cap\mathbb Z,\\
\sum_{j=1}^{m'} f'_ja_{p-j}=0</script><p>同时有：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^{m'} f'_ja_{i-j}=\Delta_{i}</script><p>那么显然令 $\mathrm{F}_{q+1}=\mathrm{F_q}+\mathrm{F’}$ 就是答案。</p>
<p>考虑这么一种构造方式：随便选一个历史版本 $o,1\leq o\leq q$ ，令 $\alpha=\frac{\Delta_i}{\Delta_o}$ ，那么 $\rm F’$ 就是：</p>
<script type="math/tex; mode=display">
\{0,0\ldots0,\alpha,-\alpha\cdot \mathrm F_o\}</script><p>其中前缀 $0$ 的个数为 $i-\mathrm{fail}_o-1$ ，最后 $\mathrm {fail} _o$ 项是 $\rm F\it _o$ 整体乘上了 $\alpha$。</p>
<p>思考这样的可行性，设 $p’\in[1,i]\cap\mathbb Z$ ，那么有：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^{m'}f_j'a_{p'-j}=
\begin{cases}
\alpha\cdot(a_{\mathrm{fail}_o}-\sum_{j=1}^{|\mathrm{F}_{o}|}f_{o,j}a_{\mathrm{fail}_o-j})=\alpha\cdot \Delta_{\mathrm{fail}_o}=\Delta_i,\quad &p'=i\\
\alpha\cdot(a_{\mathrm{fail}_o-k}-\sum_{j=1}^{|\mathrm{F}_{o}|}f_{o,j}a_{\mathrm{fail}_o-k-j})=0,\quad &p'=i-k,k\in \mathbb Z_{+}
\end{cases}</script><p>发现刚好满足要求。于是可知 $\mathrm{F}_{q+1}=\mathrm{F_q}+\mathrm{F’}$ 即为答案。</p>
<p>那么考虑如何求最短递推式。发现 $1\leq o\leq q$ 的选取没有限制，所以选 $|\mathrm{F}_o|+i-\mathrm{fail}_o$ 最小的即可。</p>
<h1 id="实现部分"><a href="#实现部分" class="headerlink" title="实现部分"></a>实现部分</h1><p>大概还是很显然的？过程都很清晰，就是模拟了一遍而已。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fail[MAXN] ; </span><br><span class="line"><span class="built_in">vector</span> &lt;LL&gt; f[MAXN] ;</span><br><span class="line">LL delta[MAXN], now ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">int</span> I)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= I ; ++ i)&#123;</span><br><span class="line">      	now = base[i] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= f[M].size() ; ++ j)</span><br><span class="line">            now = now - base[i - j] * f[M][j - <span class="number">1</span>] % Mod ;</span><br><span class="line">        delta[i] = (now % Mod + Mod) % Mod ; </span><br><span class="line">      	<span class="keyword">if</span> (!delta[i]) <span class="keyword">continue</span> ; <span class="keyword">else</span> fail[M] = i ;</span><br><span class="line">        <span class="keyword">if</span> (!M) &#123; </span><br><span class="line">          f[++ M].resize(i) ;</span><br><span class="line">          delta[i] = base[i] ;  <span class="keyword">continue</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Id = M - <span class="number">1</span> ;</span><br><span class="line">        v = f[Id].size() - fail[Id] + i ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i - fail[j] + f[j].size() &lt; v)</span><br><span class="line">                Id = j, v = i - fail[j] + f[j].size() ;</span><br><span class="line">        f[M + <span class="number">1</span>] = f[M] ; ++ M ; </span><br><span class="line">      	<span class="keyword">while</span> (f[M].size() &lt; v) f[M].push_back(<span class="number">0</span>) ;</span><br><span class="line">        LL mul = delta[i] * expow(delta[fail[Id]], Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">        (f[M][i - fail[Id] - <span class="number">1</span>] += mul) %= Mod  ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; f[Id].size() ; ++ j)</span><br><span class="line">            (f[M][i - fail[Id] + j] -= mul * f[Id][j]) %= Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; f[M].size() ; ++ i)</span><br><span class="line">        p[i + <span class="number">1</span>] = (f[M][i] % Mod + Mod) % Mod, <span class="built_in">cout</span> &lt;&lt; p[i + <span class="number">1</span>] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就没有然后了</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Berlekamp-Massey算法</category>
      </categories>
      <tags>
        <tag>Berlekamp-Massey</tag>
        <tag>数学/常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】快速沃尔什变换</title>
    <url>/2019/08/26/fwt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速沃尔什变换(FWT)</strong>是一种广义上的<strong>傅里叶变换</strong>，可以解决<strong>子集并卷积</strong>、<strong>子集交卷积</strong>以及<strong>子集对称差卷积</strong>。</p>
<p>而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决<strong>子集对称差卷积</strong>，即：</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\oplus k=i} a_jb_k</script><p>其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。</p>
<a id="more"></a>
<hr>
<h1 id="再谈线性变换实质"><a href="#再谈线性变换实质" class="headerlink" title="再谈线性变换实质"></a>再谈线性变换实质</h1><p>首先是构造，我们考虑线性变换的本质，需要有:</p>
<script type="math/tex; mode=display">
{\rm FWT(C)}_i={\rm FWT(B)}_i\cdot{\rm FWT(A)}_i</script><p>那么一个思路就是先设一个辅助函数$\varphi(i,x)$出来：</p>
<script type="math/tex; mode=display">
{\rm FWT(F)}_i=\sum_{j\geq 0}\varphi(j,i) \cdot f_j</script><p>那么就会有：</p>
<script type="math/tex; mode=display">
\sum_{j\geq 0}\varphi(j,i) \cdot c_j=\sum_{j\geq 0}\varphi(j,i) \cdot a_j\times \sum_{j\geq 0}\varphi(j,i) \cdot b_j</script><p>然后把</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\oplus k=i} a_jb_k</script><p>带进去并调整：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j\geq 0}\varphi(j,i) \cdot \sum_{p\oplus q=j} a_pb_q & =\sum_{j\geq 0}\varphi(j,i) \cdot a_j \times\sum_{j\geq 0}\varphi(j,i) \cdot b_j\\\
\sum_{p \geq 0} \sum_{q\geq 0}\varphi(p\oplus q,i)\cdot a_pb_q & =\sum_{p\geq 0}\sum_{q\geq 0}\varphi(p,i) \cdot \varphi(q,i)\cdot a_pb_q\\\
\end{aligned}</script><p>发现 $\sum_{p\geq 0}\sum _{q\geq 0}a_pb_q$ 是可以消掉的，于是就有：</p>
<script type="math/tex; mode=display">
\varphi(p\oplus q,i)=\varphi(p,i)\cdot \varphi(q,i)</script><h1 id="构造-varphi"><a href="#构造-varphi" class="headerlink" title="构造$\varphi$"></a>构造$\varphi$</h1><p>对于异或操作来说，异或前后$1$的个数的奇偶性不会改变。即也就是说$i,j$中$1$的个数加起来和$i\oplus j$中1的个数的奇偶性是一样的。形式化地讲：</p>
<script type="math/tex; mode=display">
\rm bitcount(i)+bitcount(j)\equiv bitcount(i~\oplus ~j)~(\bmod 2)</script><p>证明：</p>
<p>考虑$i \oplus j$的每一位：</p>
<ul>
<li>若$i$和$j$的这一位相同，那么就会变成$0$，$1$的个数减二或不变；</li>
<li>如不同，那么就一定是$(xx1xx)\oplus(xx0xx)=(xx1xx)$，$1$的个数还是不变。</li>
</ul>
<p>而我们发现这个引理解决的是相加不变的问题，而我们需要的$\varphi$函数需要满足相乘不变，于是自然而然地想到要放到幂上去。</p>
<p>于是就定义了$\varphi$:</p>
<script type="math/tex; mode=display">
\varphi(s,t)=(-1)^{|s\cap t|}</script><p>换成数值的表示方法：</p>
<script type="math/tex; mode=display">
\varphi(i,j)=(-1)^{\rm bitcount \mathcal{(i ~\rm{and}~ j)}}</script><p>这么定义的原因是：</p>
<script type="math/tex; mode=display">
(i \cap x) \oplus(j \cap x)=(i \oplus j) \cap x</script><p>即<strong>异或对交有分配律</strong>，那么：</p>
<script type="math/tex; mode=display">
{\rm{FWT(F)}}_i=\sum_{j \geq 0}(-1)^{|i\cap j|}f_j</script><p><del>于是就喜提一个指数级算法</del></p>
<h1 id="真正的-rm-FWT"><a href="#真正的-rm-FWT" class="headerlink" title="真正的$\rm{FWT}$"></a>真正的$\rm{FWT}$</h1><p>我们发现似乎这东西没有办法dp，于是考虑：</p>
<blockquote>
<p>每一次考虑新加入第$i$个物品取不取的情况，将当前集合分为$i$取和$i$不取，$i$取的放右边，$i$不取的放左边。</p>
<p>$i$取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小$−1$。$i$不取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小同样的不变。 </p>
<p>这样考虑原有状态，左右两边对$i$不取的贡献都是$\text{++}$，因为集合大小不变。左边对$i$取的贡献是$+$，右边对$i$取的贡献是$\text{−−}$，因为都取$i$的话并集增加了$1$，贡献取反。</p>
</blockquote>
<p>然后其实就是个模拟的思路，由于$(1xxxxxx)_2$和$(0xxxxxx)_2$的数量是一致的，所以我们可以将小于$(1000000)_2$的分为一类，大于等于$(1000000)_2$的分为一类，从数值上看就是前一半和后一半。</p>
<p>总之就是个FFT🦋操作的思路啦。</p>
<p>然后对于逆变换，因为我们刚才的结论有：</p>
<script type="math/tex; mode=display">
\begin{aligned}{F[j+k] =F[j+k]+F[i+j+k]} \\\ {F[i+j+k]=F[j+k]-F[i+j+k]}\end{aligned}</script><p>所以我们现在为了得到原来的$F[i+j+k]$和$F[j+k]$，直接</p>
<script type="math/tex; mode=display">
\begin{array}{c}{F[j+k]=\frac{F[j+k]+F[j+i+k]}{2}} \\ {F[j+i+k]=\frac{F[j+k]-F[j+i+k]}{2}}\end{array}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, m = <span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>), x, y ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                x = f[j + k], y = f[i + j + k] ;</span><br><span class="line">                f[j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + y) % Mod ;</span><br><span class="line">                f[i + j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + Mod - y) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是时间复杂度就是$n \log n$了。</p>
<h1 id="rm-FWT-做or-and卷积"><a href="#rm-FWT-做or-and卷积" class="headerlink" title="$\rm FWT$做or/and卷积"></a>$\rm FWT$做or/and卷积</h1><p>艹，真是被血坑了。</p>
<p>才发现原来FWT做or/and卷积就是跟FMT一个道理：</p>
<script type="math/tex; mode=display">
\boldsymbol{or}: F[i+j+k]+=F[j+k]\\\
\boldsymbol{and}: F[j+k]+=F[i+j+k]</script><p>然后逆变换就直接把加号改成减号就好了……原因就是“不取这个东西”一定是“取这个东西”的子集。</p>
<p>但是当时我认真学习FMT的时候，<code>Rockdu</code>博客里面FMT的代码是FWT的！！！然后再看别人的代码我就懵O了好久……</p>
<p>真是zz</p>
<p>但是终于理解了<code>JOHNKRAM</code>神仙的话：</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mjCdF1.jpg" alt></p>
<p>不得不说是很形象了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>其实Lugou上的板子的复杂度是$2^n n$的，我一开始就觉得暴力枚举子集没啥问题，结果最后发现枚举子集不是枚举$(n)_2$的子集，而是枚举$(2^n)_2$的子集……白学了白学了</li>
<li>唉，本来就是功能相同的FWT和FMT，看错代码真是GG</li>
<li>其实只有对称差卷积难理解一些，交并卷积都是很形象的。</li>
</ul>
]]></content>
      <tags>
        <tag>快速沃尔什变换(FWT)</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】快速莫比乌斯变换&amp;子集卷积</title>
    <url>/2019/08/26/fmt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速莫比乌斯变换(FMT)</strong>可以方便地解决<strong>子集交卷积</strong>和<strong>子集并卷积</strong>，形式化地讲就是求一个$\rm C$：</p>
<script type="math/tex; mode=display">
c_i=\sum_{k\cup j=i} a_kb_j\\
c_i=\sum_{k\cap j=i} a_kb_j</script><p>而<strong>快速子集变换(FST)</strong>则是在FMT基础上的扩展，解决的也是子集交卷积，但是限制了<strong>状态不重复</strong>，即</p>
<script type="math/tex; mode=display">
c_i=\sum_{\substack{\begin{aligned}~k &\cup j=i\\ k &\cap j= \emptyset \end{aligned}}}a_kb_j</script><p>换个写法：</p>
<script type="math/tex; mode=display">
c_s=\sum_{t\subseteq s}a_sb_{s-t}</script><p>同时，以上两种变换所涉及的交集、并集和差集的对象都是集合（也就是$c_i$的下角标$i$指代的是集合），其二进制表示能更好地展示这一点。</p>
<a id="more"></a>
<h1 id="rm-FMT"><a href="#rm-FMT" class="headerlink" title="$\rm{FMT}$"></a>$\rm{FMT}$</h1><p>首先我们考虑一步线性变换的实质。考虑FFT，其本质是通过DFT使得我们可以直接线性地逐项相乘，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm {C} & =\rm{A*B}\\\
\Longrightarrow \rm{DFT(C)_i} & =\rm{DFT(A)_i\cdot DFT(B)_i}
\end{aligned}</script><p>那么我们同时也希望构造出一种变换使得可以逐项相乘。</p>
<h2 id="1-子集并卷积"><a href="#1-子集并卷积" class="headerlink" title="$(1)$ 子集并卷积"></a>$(1)$ 子集并卷积</h2><p>不妨先扩大一下范围，即若$A\cup B=C$，则一定有$A\subseteq C$且$B \subseteq C$，但是反过来不一定。</p>
<p>那么先考虑$\rm MT$，即考虑一种变换而不思考其复杂度。我们令</p>
<script type="math/tex; mode=display">
\rm MT(F)_i= \mathcal{\sum_{j\subseteq i} f_j}</script><p>则有</p>
<script type="math/tex; mode=display">
\rm{MT(F)_i\cdot MT(G)_i}=\mathcal{\sum _{j,k\subseteq i} f_j\cdot g_k}</script><p>而实际上我们求的是</p>
<script type="math/tex; mode=display">
\rm{P_i}=\mathcal{\sum_{j\cup k=i}f_jg_k}</script><p>而我们发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{j\subseteq i}{\rm}_j &=\sum_{d \subseteq i} \sum_{j\cup k=d}f_jg_k\\\ &= \sum_{j,k\subseteq i} f_jg_k\\\ &= \rm{MT(P)_i}\end{aligned}</script><p>也就是说有</p>
<script type="math/tex; mode=display">
\rm MT(F)_i\cdot MT(G)_i =MT(P)_i</script><p>于是就构造出了这样的线性变换，本质就是子集和。</p>
<p>但是普通的子集和是$O(2^nn)$的，但是我们的$n$是$100000$级别，所以考虑一个dp一样的东西。就是我们每次枚举每一位，那么这一位为0就是这一位为1的子集，所以类加进答案。于是这样的复杂度就变成了$n\log n$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N = (1 &lt;&lt; M) - 1 ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j ^ (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-子集交卷积"><a href="#2-子集交卷积" class="headerlink" title="$(2)$ 子集交卷积"></a>$(2)$ 子集交卷积</h2><p>我们对称思考，即令$\rm{MOT}$表示交卷积的变换，那么应该有：</p>
<script type="math/tex; mode=display">
\rm MOT(F)_i= \mathcal{\sum_{i\subseteq j} f_j}</script><p>那么</p>
<script type="math/tex; mode=display">
\rm{MOT(F)_i\cdot MOT(G)_i}=\mathcal{\sum _{i\subseteq j,i\subseteq k} f_j\cdot g_k}</script><p>我们要求的是</p>
<script type="math/tex; mode=display">
\rm{Q_i}=\mathcal{\sum_{j\cap k=i}f_jg_k}</script><p>则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i\subseteq j}{\rm}_j &=\sum_{i \subseteq d} \sum_{j\cap k=d}f_jg_k\\\ &= \sum_{i\subseteq j,i\subseteq k} f_jg_k\\\ &= {\rm{MOT(Q)}_i}\end{aligned}</script><p>于是就直接反着求一遍即可。</p>
<p>然后这东西就也还是个dp，复杂度$n \log n$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = M ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j | (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-优化：增量分治"><a href="#3-优化：增量分治" class="headerlink" title="$(3)$ 优化：增量分治"></a>$(3)$ 优化：增量分治</h2><p>阅读提示：优你🐎的化，这就是个FWT。</p>
<p>以下是以前的翻车现场：</p>
<hr>
<p>实际上我觉得也没怎么优化……</p>
<p>拿并卷积举例，大体上就是我们考虑如果存在$i\subseteq j\subseteq k$，我们朴素的要算两次，但实际上我们对于前半部分的$k$只需要算一次。这样实际上就是我们考虑每次只转移前$n-i$个元素相同的集合。</p>
<p>(以下内容来自<code>Rockdu</code>的$blog$)</p>
<p>于是每当多了一个元素，即我们考虑由$i$层转移到$i+1$层，发现只是多了一个元素的状态——讨论一下这个元素取不取，发现这个元素不取，答案就和原来一样，因为它的子集和不变；如果这个元素要取，那么这个元素不取的情况是它的子集，会多出这个元素不取的子集和。最终我们发现，到第$i$层只需要把第$i$个元素不取的状态加到第$i$个元素取的状态就可以了。</p>
<p>于是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(<span class="keyword">int</span> * A, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = i &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)</span><br><span class="line">                (A[i + j + k] += A[j + k]) %= Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去每次只用计算一半，但是<code>JOHNKRAM</code>神仙是这么说的：</p>
<p><img src="https://s2.ax1x.com/2019/08/29/mbfpBq.png" alt></p>
<p>你看他长得和FFT的蝴蝶操作一毛一样，所以还是$n\log n$的。</p>
<hr>
<p>= =假酒害人，假代码更害人</p>
<h1 id="rm-FST"><a href="#rm-FST" class="headerlink" title="$\rm FST$"></a>$\rm FST$</h1><p><del>这个名字不是很吉利</del></p>
<p>这东西其实也不是非要用$\rm FMT$来做，$\rm FWT$也可以。</p>
<p>然后就是考虑在卷积的时候多增加一维，即$f_{i,S}$表示集合$S$中有$i$个元素，于是发现只有当元素个数相加符合时才是对的。</p>
<p>于是一开始将$f_{bct(s),s}$赋值为$f_s$，其中$bct(s)=\rm bitcount(s)$。然后对每一个$f_i$分别做$\rm FMT$，之后按位乘的时候需要</p>
<script type="math/tex; mode=display">
P_{i, S}=\sum_{i=0}^{i} f_{j, S} * g_{i-j, S}</script><p>输出的时候只输出$P_{bct(s),s}$即可。</p>
<p>板子题是<a href="https://loj.ac/problem/152" target="_blank" rel="noopener"><code>LOJ #152</code></a>，略微卡常，被逼无奈写了神奇的取模优化233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 1056701</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> bc[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M ; LL A[MAXN][MAXM], B[MAXN][MAXM], C[MAXN][MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(LL &amp;x)</span> </span>&#123; x += x &gt;&gt; <span class="number">63</span> &amp; Mod ; &#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">Ifmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] -= f[j ^ <span class="number">1</span> &lt;&lt; i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">fmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] += f[j ^ <span class="number">1</span> &lt;&lt; i] - Mod) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; <span class="keyword">register</span> <span class="keyword">int</span> i, j, s ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) bc[i] = bc[i - (i &amp; -i)] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) A[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fmt(A[i]), fmt(B[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (s = <span class="number">0</span> ; s &lt;= M ; ++ s)</span><br><span class="line">                (C[i][s] += A[j][s] * B[i - j][s]) %= Mod ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ifmt(C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, C[bc[i]][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际上国际上根本不通用FMT和FST这两个简写（甚至可能国内也没几个人用FST指代”子集卷积“）,于是就只能233了</p>
<p>upd：有些说明参见FWT的讲解。</p>
<h2 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm Referance$"></a>$\rm Referance$</h2><ul>
<li>$[1]$ :<code>Dance of Faith</code>的$blog$ <a href="https://www.cnblogs.com/Dance-Of-Faith/p/8818211.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[2]$ :<code>Rockdu</code>的$blog$ <a href="http://blog.leanote.com/post/rockdu/TX20" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>奇怪的变换</category>
      </categories>
      <tags>
        <tag>快速莫比乌斯变换(FMT)</tag>
        <tag>快速沃尔什变换(FWT)</tag>
        <tag>快速子集变换(FST)</tag>
      </tags>
  </entry>
  <entry>
    <title>随想十 · 繁星</title>
    <url>/2019/08/20/10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>upd2 : 时机依旧不成熟，但睁开了眼睛，发现原来世界是这样的，决定慢慢体会什么是善恶、什么是明暗。终于坚定了不再当行尸走肉的决心，要成为真正独立、有血有肉的人。</p>
<p>upd1 : 时机尚不成熟，双眸是瞎的，看不到一丝光亮，只是一具只会随波逐流的皮肉罢了。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF Educational Round70 题解</title>
    <url>/2019/08/19/Er70/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Educational Round</code>，顾名思义，<strong>教育做人专场</strong>。</p>
<p>这场比赛巧妙地教育了一个初出茅庐的萌新Oier（我）<strong>到底该如何做人</strong>（哭晕）。</p>
<p>比赛链接：<a href="https://codeforces.com/contest/1202" target="_blank" rel="noopener">戳</a></p>
 <a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$~A$"></a>$~A$</h1><p>题意：给你两个二进制字符串$x$和$y$，将$y$左移$k$位，再与$x$相加，得到字符串$s_k$，最后将其反转得到$res_k$。求当$res_k$字典序最小时的$k$。</p>
<hr>
<p>诡异的贪心……</p>
<p>实不相瞒我想了整整半个多小时（中间伴有间歇性走神）……</p>
<p>其实就是转化的思想，求反串的字典序最小，就是要把正串里面的低位1们尽量消掉。又因为题目里面限制了$x&gt;y$，所以一定存在$x$的二进制表示中至少一个$1$比$y$的最低位$1$靠左。考虑贪心的思想，$x$被消掉的$1$越靠右，反串字典序就越小。所以说我们要找的就是$\boldsymbol{x}$<strong>中能被$\boldsymbol{y}$消掉的最靠右的那个$\boldsymbol{1}$的位置</strong>。</p>
<p>于是扫一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">	<span class="keyword">int</span> i, posa = <span class="number">0</span> , posb = <span class="number">0</span> ;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, A + <span class="number">1</span>) ;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, B + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">int</span> La = <span class="built_in">strlen</span>(A + <span class="number">1</span>), Lb = <span class="built_in">strlen</span>(B + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Lb ; ++ i)</span><br><span class="line">	<span class="keyword">if</span> (B[i] == <span class="string">'1'</span>) posb = i ; posb = Lb - posb + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= La ; ++ i)</span><br><span class="line">	<span class="keyword">if</span> (A[i] == <span class="string">'1'</span>) <span class="keyword">if</span> (La - i + <span class="number">1</span> &gt;= posb) posa = La - i + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; posa &lt;&lt; " " &lt;&lt; posb &lt;&lt; endl ;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, posa - posb) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="it-B"><a href="#it-B" class="headerlink" title="$\it{B}$"></a>$\it{B}$</h1><p>题意：给定一个计数器$(x-y)$，对于每次引进的常数$z$，可以选择$\text{((+=x)mod=10)}$ 或者$\text{((+=y)mod=10)}$（$\text{mod=}$就是<code>%=</code>）然后把结果再丢到运算里面继续运算。现在给定一个残缺的$z$序列（省略了中间的某些结果），求$0\text{~}9$两两组合的计数器分别至少需要多少步才能还原这个串的运算。</p>
<hr>
<p>草，我这最短路又是白学了。</p>
<p>首先我们考虑一个显然的$10^4\cdot \Omega(1)$的预处理，就是令$(i-j)$为计数器，从$k$到$o$的最短距离，这玩意儿显然可以BFS，由于是对$10$取模所以大概循环节也在下界为$\Theta(1)$左右酱紫。之后对于询问直接暴力枚举就好了，复杂度大概是$100\cdot O(|S|)\leq 100\times 2,000,000=2e8$……梦想算法……但其实显然那个$100$可以只做$50+$的样子，毕竟是对称的……不过还是梦想算法233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">10</span> ; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (o = <span class="number">0</span> ; o &lt; <span class="number">10</span> ; ++ o)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> mark[<span class="number">200</span>] ;</span><br><span class="line">                    dis[i][j][k][o] = <span class="number">-1</span> ;</span><br><span class="line">                    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark)) ;</span><br><span class="line">                    q.push((wk)&#123;k, <span class="number">0</span>&#125;) ;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">                        wk now = q.front() ; q.pop() ;</span><br><span class="line">                        <span class="keyword">if</span> (now.num == o &amp;&amp; now.cnt)&#123;</span><br><span class="line">                            dis[i][j][k][o] = now.cnt ; <span class="keyword">break</span> ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mark[now.num]) <span class="keyword">continue</span> ;mark[now.num] = <span class="number">1</span> ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + i) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + j) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) q.pop() ;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">/*for (i = 0 ; i &lt; 10 ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = 0 ; j &lt; 10 ; ++ j)</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt; 10 ; ++ k)</span></span><br><span class="line"><span class="comment">                for (o = 0 ; o &lt; 10 ; ++ o)</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; dis[i][j][k][o] &lt;&lt; " " ;*/</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ; <span class="keyword">int</span> ans = <span class="number">0</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = In[i] - <span class="string">'0'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)&#123; <span class="comment">/*qwqwq*/</span></span><br><span class="line">            <span class="keyword">for</span> (ans = <span class="number">0</span>, k = <span class="number">2</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j][base[k - <span class="number">1</span>]][base[k]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"-1 "</span>), ans = <span class="number">-1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dis[i][j][base[k - <span class="number">1</span>]][base[k]] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans - N + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（代码渲染会自动把<code>tab</code>映射成<code>force-tab</code>我也懒得管了= =）</p>
<h1 id="mathcal-C"><a href="#mathcal-C" class="headerlink" title="$\mathcal{C}$"></a>$\mathcal{C}$</h1><p>题意：给定一段某个机器人的操作序列<code>WSAD</code>，可以添加一个字符，求最终机器人的最小活动区域面积。</p>
<hr>
<p>首先显然是<strong>行列无关</strong>的，所以分开考虑；接着发现最优策略肯定是让某一步相当于没走，但是假设$x_{min}$和$x_{max}$均在这次改动操作的后面，那么缩小$x_{max}$的时候也会缩小$x_{min}$，相当于没缩——所以应找到一个界点，所有的最大值都在左/右边，对应的所有最小值都在右/左边。</p>
<p>由于每一步操作都是有后效性的，所以考虑直接前缀和上求出$min$和$max$就好。</p>
<p>但是考虑无论怎么移动，都不能越过预处理出来的$x_{min}$、$x_{max}$这个界（否则会出现越贪越大）。也就是说假设有一个$x_{max}$，接着过了一会儿有一个$x_{min}$，为了“拔高”$x_{min}$我们必须要添加一个$W$，所以我们必须要保证任何时刻不会出现$x_{max}$在放上一个$W$之后越界的情况，也就是说$x_{min}$和$x_{max}$出现的位置之间必须要一个$S$才能用来抵消掉我们$W$，需要特判。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL ans ; </span><br><span class="line"><span class="keyword">int</span> fhm, fhn, fwm, fwn, pos[<span class="number">2</span>][<span class="number">5</span>], i ; </span><br><span class="line"><span class="keyword">int</span> T, N, Sw[MAXN], Sh[MAXN] ; <span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        fhm = fwm = -Inf, fhn = fwn = Inf ;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            Sh[i] = Sh[i - <span class="number">1</span>], Sw[i] = Sw[i - <span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">'W'</span>) Sh[i] = Sh[i - <span class="number">1</span>] + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'S'</span>) Sh[i] = Sh[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'D'</span>) Sw[i] = Sw[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'A'</span>) Sw[i] = Sw[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">        &#125;<span class="comment">//前缀和 : w x h </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fwm = max(Sw[i], fwm), fwn = min(Sw[i], fwn) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fhm = max(Sh[i], fhm), fhn = min(Sh[i], fhn) ; </span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max w</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min h    </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min w</span></span><br><span class="line">        ans = <span class="number">1l</span>l * (fwn - fwm - <span class="number">1</span>) * (fhn - fhm - <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">3</span>] &lt; pos[<span class="number">0</span>][<span class="number">2</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">3</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">3</span>] &lt; pos[<span class="number">1</span>][<span class="number">2</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">3</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">4</span>] &lt; pos[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">4</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">4</span>] &lt; pos[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">4</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">1</span>] = pos[<span class="number">1</span>][<span class="number">1</span>] = pos[<span class="number">0</span>][<span class="number">2</span>] = pos[<span class="number">1</span>][<span class="number">2</span>] = Inf ;</span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">3</span>] = pos[<span class="number">1</span>][<span class="number">3</span>] = pos[<span class="number">0</span>][<span class="number">4</span>] = pos[<span class="number">1</span>][<span class="number">4</span>] = -Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmm好像当时<code>debug</code>了好久的样子。</p>
<h1 id="rm-D"><a href="#rm-D" class="headerlink" title="$\rm{D}$"></a>$\rm{D}$</h1><p>题意：构造一个含有<code>1</code>/<code>3</code>/<code>7</code>的串，使得子序列<code>1337</code>的数量恰好为$x$。</p>
<hr>
<p>这特么就是一个智商题。就是考虑一个最简单的构造<code>133..3337</code>这种，但是不是每一个$x$都可以表示成$\frac{p(p-1)}{2}$这种形式的……所以考虑找出最大的$p~\rm{s.t.}$ $p(p-1)\leq 2x$，然后拼命地向第一组<code>33</code>后面添加<code>7</code>就好了。这样总长度是上限是$2\sqrt x$的，挺稳。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> p = <span class="built_in">sqrt</span>(<span class="number">2</span>*N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &lt;= <span class="number">2</span>*N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * (i - <span class="number">1</span>) &gt; <span class="number">2</span> * N) <span class="keyword">break</span> ;</span><br><span class="line">            L1 = i * (i - <span class="number">1</span>) / <span class="number">2</span>, L2 = N - L1, L1 = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"133"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L2 ; ++ i) <span class="built_in">putchar</span>(<span class="string">'7'</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L1 - <span class="number">2</span> ; ++ i) <span class="built_in">putchar</span>(<span class="string">'3'</span>) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mathbb-E"><a href="#mathbb-E" class="headerlink" title="$\mathbb{E}$"></a>$\mathbb{E}$</h1><p>题意：给定$N~(\leq 1e5)$个模板串$s_i$和一个文本串$T$，求所有的$s_i+s_j~(i\not=j)$在$T$中出现的次数之和。</p>
<hr>
<p>嗯，顺带复习了一下$AC$自动机。</p>
<p>思路其实也很简单，就是建俩$AC$自动机，一个跑正串，一个跑反串，然后枚举每个合法的i作为中间的结合位点，乘法原理就好了……但其实这种结论能轻易得出还是建立在$AC$自动机掌握十分扎实的基础上啊。</p>
<p>哦对，似乎对于AC自动机的题目，树形dp才是正确的打开方式。每次重新跳fail根本吃不消。。（<code>CF</code>真的有数据去卡这东西，<code>aaa..aa</code>这种……）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN], In[MAXN] ; <span class="keyword">int</span> N ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACm</span>&#123;</span></span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ; <span class="keyword">int</span> cnt ;</span><br><span class="line">	<span class="keyword">int</span> tr[MAXN][<span class="number">27</span>], res[MAXN] ;</span><br><span class="line">	<span class="keyword">int</span> fail[MAXN], ans[MAXN], e[MAXN] ; </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) tr[rt][x]</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> Id)</span></span>&#123;	</span><br><span class="line">		<span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), k, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i)&#123;</span><br><span class="line">			k = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">			<span class="keyword">if</span> (!v(k)) v(k) = ++ cnt ; </span><br><span class="line">			rt = v(k) ;</span><br><span class="line">		&#125;</span><br><span class="line">		e[rt] ++ ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) <span class="keyword">if</span> (v(i)) q.push(v(i)) ;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">			rt = q.front(), q.pop() ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!v(i)) v(i) = tr[fail[rt]][i] ; </span><br><span class="line">				<span class="keyword">else</span> fail[v(i)] = tr[fail[rt]][i], q.push(v(i)) ;</span><br><span class="line"><span class="comment">//				if (e[fail[v(i)]]) last[v(i)] = fail[v(i)] ; else last[v(i)] = last[fail[v(i)]] ;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">	void work(char *s)&#123;</span></span><br><span class="line"><span class="comment">		int i, j = strlen(s), p, rt = 0 ; </span></span><br><span class="line"><span class="comment">		for (i = 0 ; i &lt; j ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">			rt = v(s[i] - 'a'), p = rt ; </span></span><br><span class="line"><span class="comment">			while(p) res[i] += e[p], p = fail[p] ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">if</span> (res[rt] != <span class="number">-1</span>) <span class="keyword">return</span> res[rt] ;</span><br><span class="line">		<span class="keyword">return</span> res[rt] = e[rt] + dfs(fail[rt]) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">		<span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), p, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) rt = v(s[i] - <span class="string">'a'</span>), ans[i] = dfs(rt) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;P, Q ; LL ans ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S &gt;&gt; N ; <span class="keyword">int</span> i, j ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In), P.insert(In, i) ; </span><br><span class="line">		j = <span class="built_in">strlen</span>(In), reverse(In, In + j), Q.insert(In, i) ;</span><br><span class="line">	&#125;</span><br><span class="line">	P.build(), Q.build() ; j = <span class="built_in">strlen</span>(S) ;</span><br><span class="line">	P.work(S), j = <span class="built_in">strlen</span>(S) ; reverse(S, S + j) ; Q.work(S) ;</span><br><span class="line"><span class="comment">//	for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; P.res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; Q.res[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) ans += <span class="number">1l</span>l * P.ans[i] * Q.ans[j - <span class="number">2</span> - i] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mathfrak-F"><a href="#mathfrak-F" class="headerlink" title="$\mathfrak{F}$"></a>$\mathfrak{F}$</h1><p>题意：给定大写字母$A$和$B$的数量，求可以组成多少种不同的最短周期。其中周期的定义式不完全的，即只需要满足$\forall i,s[i]=s[i~\bmod~k]$，$k$就是周期。</p>
<hr>
<p>这真是神仙题……</p>
<p>下文中用$a,b$表示输入的那俩值。</p>
<p>考虑对于一个合法的$k$而言，假设在这个$k$满足$k=\lfloor n/p\rfloor,p\in \mathbb{N}$，那么$p$就是循环节的数量。现在我们假设有$q_a+q_b=k$，即每一段循环节中$A$的数量和$B$的数量。那么一定需要满足的是$q_a\cdot p\leq a$并且$q_b\cdot p\leq b$。</p>
<p>同时考虑一定会有</p>
<script type="math/tex; mode=display">
q_a \leq \lfloor\frac{a}{p}\rfloor, q_b \leq \lfloor\frac{b}{p}\rfloor</script><p>但同时还有一个条件，就是虽然实际上多出去一堆下脚料，但$a_{rest},b_{rest}$必须小于等于$q_a$和$q_b$。也就是说需要有</p>
<script type="math/tex; mode=display">
(p+1)\cdot q_a \geq a,(p+1)\cdot q_b\geq b</script><p>美化一下就是</p>
<script type="math/tex; mode=display">
\lceil \frac{a}{p+1} \rceil \leq q_a\leq \lfloor \frac{a}{p} \rfloor \\\
\lceil \frac{b}{p+1} \rceil \leq q_b\leq \lfloor \frac{b}{p} \rfloor</script><p>就可以通过从$1$到$n$枚举$p$来求得$q_a$和$q_b$，那么根据定义，$q_a$和$q_b$是一段循环节中的$A$和$B$的数量，所以$q_a+q_b$对$k$产生贡献。</p>
<p>还有一个小问题，就是如何保证一定是<strong>最小的$k$</strong>。这个其实也很简单。假设对于每一段完整的循环节他同时也自循环，段和段之间$A$和$B$个数一定相同，所以可以考虑直接把每一段的$A$丢到前面，$B$丢到后面，就避免了自循环这种情况。</p>
<p>然后这东西显然是可以数论分块的，所以我们分一下块就做完了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, L ; LL Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, L = N + M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g, l = <span class="number">1</span>, r ; l &lt;= L ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        g = L / l, r = L / g ;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; g || M &lt; g) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> ln = (N + g) / (g + <span class="number">1</span>), hn = N / g ;</span><br><span class="line">        <span class="keyword">int</span> lm = (M + g) / (g + <span class="number">1</span>), hm = M / g ;</span><br><span class="line">        <span class="keyword">if</span> (hn &gt;= ln &amp;&amp; hm &gt;= lm)</span><br><span class="line">            Ans += max(<span class="number">0l</span>l, <span class="number">1l</span>l * (min(hn + hm, r) - max(l, lm + ln) + <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒🌹fa~</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
        <tag>字符串/AC自动机</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】留言板</title>
    <url>/2019/08/09/%E7%95%99%E8%A8%80%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学rvalue造了个留言板，也顺便整理一些有趣的事情。</p>
<p>看起来似乎是用来留言的？或许吧233</p>
<p>Σ( ° △ °|||)︴这东西是给大家留言的辣，挂友链/踩爆我/吐槽blog的设计都阔以的啊QAQ</p>
<p>Upd on 12.26: 泥萌来都来了不留个言嘛qwq</p>
<a id="more"></a>
<p>以下是被教育做人的经历：</p>
<blockquote>
<p>你眼前看到的景象，只不过是你自己的想象；你所认为你命中将拥有的，只不过是一种偶然。握得越紧越是徒然，看得越重越是无用。此之谓我执。</p>
<p>​                —— 编自梁文道的《我执》</p>
<p>人生有许多道：曾经踏足的是道，即将踏往的也是道，那什么才是道呢？唯有脚下走的才是道。一切精神或者物质都归于虚无，然后从混沌中衍生出三万道。在悲喜间涉足一条无数前人经历过，且将有无数后人奔赴的道，无论是否已经或者将要到达彼岸，然后便不再回头或是左顾右盼，即使有些道繁盛至极，夜灯如昼，无数人一浪又一浪的涌去，造就了世人皆知的辉煌；即使有些道草木凋敝，荒草丛生，只等勇敢的开拓者斩开荆棘，创造一片天地；这些都无所关，无所在意，彼岸何如、来日何方甚至过往旧事都化作一缕云烟，飘渺碧霄，我自撷高山之月色，独随足落处往行。</p>
<p>​                                                                        ——SD队长ckw</p>
<p>笔蘸波涛饰昆仑。</p>
<p>​                ——konoset学长</p>
</blockquote>
<p>居然有人想要我这种老年选手的企鹅号：<code>2836531293</code></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式的快速插值和求值</title>
    <url>/2019/08/07/qzcz/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多项式的求值即给出一支多项式$\rm{F}$，同时给出多个$x$求出相应的${\rm{F}}_{[x]}$</p>
<p>多项式的插值即给出$n+1$个点对$(x,{\rm F}_{[x]}),$ 根据唯一分解定理求出对应的多项式$\rm{F}$</p>
<a id="more"></a>
<h1 id="1-多点求值"><a href="#1-多点求值" class="headerlink" title="$1$ 多点求值"></a>$1$ 多点求值</h1><p>还是分治+构造。</p>
<p>首先一种思维是：用多项式除法来<strong>降次</strong>。</p>
<p>具体来说就是</p>
<script type="math/tex; mode=display">
\rm{F=PQ+R}</script><p>这是带余除法的标准式，其中一定保证了$\deg(\rm{R})\leq \deg(\rm{P})$且$\deg(\rm{R})\leq \deg(\rm{Q})$.</p>
<p>所以假设我们令$\rm{P_{[x]}Q_{[x]}}=0$，那么对于同一个$x$就会有$\rm{F_{[x]}=R_{[x]}}$。</p>
<p>所以我们如果想要分治，那么就需要先构造出一个$\rm{Q}$且$\deg(\rm{Q})=\frac{1}{2}\deg(\rm F)$</p>
<p>那么我们直接让$\rm F$对$\rm Q$取模就可以得到$\rm R$，然后不断分治下去就可以$n \log^2 n$计算了。</p>
<p>设第$i$个需要求值的$x$是$A_i$，那么关于F的构造其实很简单，只需要让他满足$\rm Q_{[A_i]}=0$即可，所以完全可以想到构造一个$m$次的多项式$\rm Q$：</p>
<script type="math/tex; mode=display">
\rm Q=\prod(x-A_i)</script><p>显然这个东西，他还是可以分治来做，于是多点求值似乎就不能再优化了，因为他<strong>复杂度完全平衡了</strong>，即预处理复杂度和运算复杂度都是$\log^2$级别的。</p>
<p>哦，然后对于<a href="https://www.luogu.org/problemnew/solution/P5050" target="_blank" rel="noopener">LuoguP5050</a>这道题，卡常十分严重，所以一开始的版本是这个画风的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse-lm"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fipa-sra"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-pre"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-vrp"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpeephole2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ffast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-spec"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-labels"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdevirtualize"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcaller-saves"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcrossjumping"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fthread-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fwhole-program"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-tail-merge"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-aliasing"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-overflow"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-skip-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-follow-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-interblock"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpartial-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"no-stack-protector"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-findirect-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fhoist-adjacent-loads"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-frerun-cse-after-loop"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-finline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-switch-conversion"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-foptimize-sibling-calls"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fexpensive-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funsafe-loop-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions-called-once"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdelete-null-pointer-checks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 270009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Gp = <span class="number">3</span> ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; P[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], F[MAXN], gg[<span class="number">20</span>][MAXN], Ls[MAXN], R[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">        a = a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;L, <span class="keyword">const</span> <span class="keyword">int</span> &amp;flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> m = <span class="number">0</span>, i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ m)&#123;</span><br><span class="line">        rr <span class="keyword">int</span> *rua = gg[m] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                LL real = J[j + k],</span><br><span class="line">                         iroot = J[j + k + i] * (LL)rua[k] ;</span><br><span class="line">                J[j + k] = (real + iroot) % Mod,</span><br><span class="line">                J[j + k + i] = ((real - iroot) % Mod +Mod)%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    rr <span class="keyword">int</span> Inv = expow(L, Mod - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        Ls[rt] = <span class="number">1</span> ;</span><br><span class="line">        P[rt].push_back((-base[l]%Mod+Mod)%Mod) ;</span><br><span class="line">        P[rt].push_back(<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    segNTT(l, mid, rt &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">    segNTT(mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">    Ls[rt] = Ls[rt &lt;&lt; <span class="number">1</span>] + Ls[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l1 = <span class="number">0</span> ; <span class="keyword">while</span> (Len &lt; ((Ls[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = Ls[lc] + <span class="number">1</span> ; i &lt; Len ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Ls[rc] + <span class="number">1</span> ; i &lt; Len ; ++ i) Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[lc] ; ++ i) X[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[rc] ; ++ i) Y[i] = P[rc][i] ;</span><br><span class="line">    NTT(X, Len, <span class="number">1</span>), NTT(Y, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) X[i] = (LL)X[i] * (LL)Y[i] % Mod ;</span><br><span class="line">    NTT(X, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[rt] ; ++ i) P[rt].push_back(X[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], ig[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> gt[MAXN], ft[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> G[MAXN] ;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f,  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>* Rs)&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">0</span>, O = n - m + <span class="number">1</span>, L , i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= (n &lt;&lt; <span class="number">1</span>) ; ++ i) ig[i] = ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = <span class="number">0</span>, L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = O ; i &lt; (n &lt;&lt; <span class="number">1</span>); ++ i) ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    Inv(gt, ig, O) ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>,++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L ; ++ i) t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(ig, L, <span class="number">1</span>), NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, - <span class="number">1</span>) ; reverse(X, X + O) ; <span class="keyword">for</span> (i = O ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    O = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>))  ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT (G, L, <span class="number">1</span>)  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * G[i] * X[i] % Mod, X[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) Rs[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; <span class="built_in">printf</span>(<span class="string">"%d"</span>, *f), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> T[(Ls[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], Ls[rt] - <span class="number">1</span>, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], Ls[rt] - <span class="number">1</span>, Ls[rc], T) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">19</span>  ;++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> *rua = gg[i] ; rua[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> gi = rua[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span>/(<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) rua[j] = <span class="number">1l</span>l * rua[j - <span class="number">1</span>] * gi % Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;F[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    segNTT(<span class="number">1</span>, M, <span class="number">1</span>), <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span>(X)), <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span>(Y)) ;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M) _Mod(F, P[<span class="number">1</span>], N, M, F) ; cdqNTT(<span class="number">1</span>, M, <span class="number">1</span>, F) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>逼得我差点上指令集</del></p>
<p>然后发现是这个NTT常数太大了，所以考虑直接<strong>边角暴力</strong>，区间长度小到一定地步直接暴力秦九韶并且循环展开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1024</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">            LL x = base[i], c1, c2, c3, c4, now = f[r - l] ; b[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">16</span> ; ++ j) b[j] = b[j - <span class="number">1</span>] * x % Mod ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=r-l<span class="number">-1</span>;j<span class="number">-15</span>&gt;=<span class="number">0</span>;j-=<span class="number">16</span>)&#123;</span><br><span class="line">                c1=(<span class="number">1l</span>l*now*b[<span class="number">16</span>]+<span class="number">1l</span>l*f[j]*b[<span class="number">15</span>]+<span class="number">1l</span>l*f[j<span class="number">-1</span>]*b[<span class="number">14</span>]+<span class="number">1l</span>l*f[j<span class="number">-2</span>]*b[<span class="number">13</span>])%Mod,</span><br><span class="line">                c2=(<span class="number">1l</span>l*f[j<span class="number">-3</span>]*b[<span class="number">12</span>]+<span class="number">1l</span>l*f[j<span class="number">-4</span>]*b[<span class="number">11</span>]+<span class="number">1l</span>l*f[j<span class="number">-5</span>]*b[<span class="number">10</span>]+<span class="number">1l</span>l*f[j<span class="number">-6</span>]*b[<span class="number">9</span>])%Mod,</span><br><span class="line">                c3=(<span class="number">1l</span>l*f[j<span class="number">-7</span>]*b[<span class="number">8</span>]+<span class="number">1l</span>l*f[j<span class="number">-8</span>]*b[<span class="number">7</span>]+<span class="number">1l</span>l*f[j<span class="number">-9</span>]*b[<span class="number">6</span>]+<span class="number">1l</span>l*f[j<span class="number">-10</span>]*b[<span class="number">5</span>])%Mod,</span><br><span class="line">                c4=(<span class="number">1l</span>l*f[j<span class="number">-11</span>]*b[<span class="number">4</span>]+<span class="number">1l</span>l*f[j<span class="number">-12</span>]*b[<span class="number">3</span>]+<span class="number">1l</span>l*f[j<span class="number">-13</span>]*b[<span class="number">2</span>]+<span class="number">1l</span>l*f[j<span class="number">-14</span>]*b[<span class="number">1</span>])%Mod,</span><br><span class="line">                now=(<span class="number">0l</span>l+c1+c2+c3+c4+f[j<span class="number">-15</span>])%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (r-l)%<span class="number">16</span><span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; -- j)now=(<span class="number">1l</span>l*now*x+f[j])%Mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, now), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> T[(Ls[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], Ls[rt] - <span class="number">1</span>, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], Ls[rt] - <span class="number">1</span>, Ls[rc], T) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以随便过了。</p>
<h1 id="2-快速插值"><a href="#2-快速插值" class="headerlink" title="$2$ 快速插值"></a>$2$ 快速插值</h1><p>首先思考拉格朗日插值：</p>
<script type="math/tex; mode=display">
\rm{F}=\mathcal{\sum y_i\prod_{i\neq j}\frac{x-x_j}{x_i-x_j}}</script><p>我们发现$\prod (x-x_j)$就是个弟弟，于是考虑：</p>
<script type="math/tex; mode=display">
\rm{G}=\mathcal {\sum \frac{y_i}{\prod_{i\neq j}x_i-x_j}}</script><p>如果我们随便设一个多项式$ \phi(x)$</p>
<script type="math/tex; mode=display">
\phi=\prod(x-x_i)</script><p>那么原式就变成了：</p>
<script type="math/tex; mode=display">
\rm{G}=\mathcal {\sum \frac{y_i}{\frac{\phi(x_i)}{x-x_i}}}</script><p>这东西就可以：<img src="https://s2.ax1x.com/2019/08/28/mH5tyj.jpg" alt></p>
<p>就可以<strong>洛</strong>！即</p>
<script type="math/tex; mode=display">
\lim _{x \rightarrow a} \frac{f(x)}{g(x)}=\lim _{x \rightarrow a} \frac{f^{\prime}(x)}{g^{\prime}(x)}</script><p>由于是形式幂级数之间的运算，于是就可以胡搞，也就是</p>
<script type="math/tex; mode=display">
\frac{\phi(x_i)}{x-x_i}=\phi'(x_i)</script><p>显然关于这个$\phi$是可以分治的，分治完求一个导然后再多点求值即可。</p>
<p>回代之后，求个逆就可以求出G，之后接着分治后面的$\prod(x-x_j)$就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300011</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> Len[MAXN], Q[MAXN], R[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, *P[MAXN], *K[MAXN], bx[MAXN], gg[<span class="number">25</span>][MAXN], by[MAXN], cy[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rr LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * <span class="number">1l</span>l * a % Mod ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> *now = gg[i] ; now[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> p = now[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) now[j] = <span class="number">1l</span>l * now[j - <span class="number">1</span>] * p % Mod ; <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> L, <span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, m = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) <span class="keyword">if</span> (i &lt; R[i]) swap(J[R[i]], J[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ m)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> *now = gg[m] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; L ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">const</span> LL x = J[j + k], y = <span class="number">1l</span>l * now[k] * J[i + j + k] ;</span><br><span class="line">                J[j + k] = (x + y) % Mod, J[i + j + k] = ((x - y) % Mod + Mod) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o &gt; <span class="number">0</span>) <span class="keyword">return</span> ; <span class="keyword">const</span> <span class="keyword">int</span> inv = expow(L, Mod - <span class="number">2</span>) ;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + L) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * inv * J[i] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ft[MAXN], gt[MAXN], ig[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], G[MAXN], X[MAXN], Y[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        P[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] ; Len[rt] = <span class="number">1</span> ;</span><br><span class="line">        P[rt][<span class="number">0</span>] = (-bx[l]+Mod)%Mod , P[rt][<span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    solve(l, mid, lc), solve(mid + <span class="number">1</span>, r, rc) ;</span><br><span class="line">    Len[rt] = Len[lc] + Len[rc], P[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[Len[rt] + <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> L = <span class="number">1</span>, l1 = <span class="number">0</span> ; <span class="keyword">while</span> (L &lt; ((Len[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>))  ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[lc] + <span class="number">1</span> ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[rc] + <span class="number">1</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[lc] ; ++ i) X[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rc] ; ++ i) Y[i] = P[rc][i] ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>), NTT(Y, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * X[i] * Y[i] % Mod ;</span><br><span class="line">    NTT(X, L, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rt] ; ++ i) P[rt][i] = X[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Dev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; g[len] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= len ; ++ i) g[i - <span class="number">1</span>] = <span class="number">1l</span>l * i * f[i] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> *res, <span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, l = <span class="number">0</span>, i, o = n - m + <span class="number">1</span>, d = n &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; d ; ++ i) ft[i] = gt[i] = ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = o ; i &lt; (n &lt;&lt; <span class="number">1</span>) ; ++ i) ft[i] = gt[i] = <span class="number">0</span> ; Inv(gt, ig, o) ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (o &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) t[i] = <span class="number">0</span>, R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;<span class="comment">//1</span></span><br><span class="line">    NTT(ig, L, <span class="number">1</span>) ; NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, <span class="number">-1</span>) ; reverse(X, X + o) ;</span><br><span class="line">    <span class="keyword">for</span> (i = o ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    o = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (o &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;<span class="comment">//2</span></span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT(G, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * X[i] * G[i] % Mod, X[i] = <span class="number">0</span> ;<span class="comment">//3</span></span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) res[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) % Mod + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">LL b[<span class="number">100</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">            LL x = bx[i], c1, c2, c3, c4, now = f[r - l] ; b[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">16</span> ; ++ j) b[j] = b[j - <span class="number">1</span>] * x % Mod ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=r-l<span class="number">-1</span>;j<span class="number">-15</span>&gt;=<span class="number">0</span>;j-=<span class="number">16</span>)&#123;</span><br><span class="line">                c1=(<span class="number">1l</span>l*now*b[<span class="number">16</span>]+<span class="number">1l</span>l*f[j]*b[<span class="number">15</span>]+<span class="number">1l</span>l*f[j<span class="number">-1</span>]*b[<span class="number">14</span>]+<span class="number">1l</span>l*f[j<span class="number">-2</span>]*b[<span class="number">13</span>])%Mod,</span><br><span class="line">                c2=(<span class="number">1l</span>l*f[j<span class="number">-3</span>]*b[<span class="number">12</span>]+<span class="number">1l</span>l*f[j<span class="number">-4</span>]*b[<span class="number">11</span>]+<span class="number">1l</span>l*f[j<span class="number">-5</span>]*b[<span class="number">10</span>]+<span class="number">1l</span>l*f[j<span class="number">-6</span>]*b[<span class="number">9</span>])%Mod,</span><br><span class="line">                c3=(<span class="number">1l</span>l*f[j<span class="number">-7</span>]*b[<span class="number">8</span>]+<span class="number">1l</span>l*f[j<span class="number">-8</span>]*b[<span class="number">7</span>]+<span class="number">1l</span>l*f[j<span class="number">-9</span>]*b[<span class="number">6</span>]+<span class="number">1l</span>l*f[j<span class="number">-10</span>]*b[<span class="number">5</span>])%Mod,</span><br><span class="line">                c4=(<span class="number">1l</span>l*f[j<span class="number">-11</span>]*b[<span class="number">4</span>]+<span class="number">1l</span>l*f[j<span class="number">-12</span>]*b[<span class="number">3</span>]+<span class="number">1l</span>l*f[j<span class="number">-13</span>]*b[<span class="number">2</span>]+<span class="number">1l</span>l*f[j<span class="number">-14</span>]*b[<span class="number">1</span>])%Mod,</span><br><span class="line">                now=(<span class="number">0l</span>l+c1+c2+c3+c4+f[j<span class="number">-15</span>])%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (r-l)%<span class="number">16</span><span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; -- j)now=(<span class="number">1l</span>l*now*x+f[j])%Mod;</span><br><span class="line">            cy[i] = now ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> T[(Len[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], T, Len[rt] - <span class="number">1</span>, Len[lc]) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], T, Len[rt] - <span class="number">1</span>, Len[rc]) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void cdqNTT(int l, int r, int rt, int *f)&#123;</span></span><br><span class="line"><span class="comment">    int T[(Len[rt] + 2) &lt;&lt; 1] ;</span></span><br><span class="line"><span class="comment">    if (l == r) &#123; cy[l] = f[0] ; return ; &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, lc = rt &lt;&lt; 1, rc = lc | 1 ;</span></span><br><span class="line"><span class="comment">    _Mod(f, P[lc], T, Len[rt] - 1, Len[lc]), cdqNTT(l, mid, lc, T) ;</span></span><br><span class="line"><span class="comment">    _Mod(f, P[rc], T, Len[rt] - 1, Len[rc]), cdqNTT(mid + 1, r, rc, T) ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqLg</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        K[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] ;</span><br><span class="line">        K[rt][<span class="number">0</span>] = <span class="number">1l</span>l * by[l] * expow(cy[l], Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">        K[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lc = rt &lt;&lt; <span class="number">1</span>, rc = lc | <span class="number">1</span>, i ;</span><br><span class="line">    cdqLg(l, mid, lc), cdqLg(mid + <span class="number">1</span>, r, rc) ; <span class="keyword">int</span> L = <span class="number">1</span>, l0 = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; ((Len[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l0 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l0 - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[lc] + <span class="number">1</span> ; i &lt; L ; ++ i) A[i] = C[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[rc] + <span class="number">1</span> ; i &lt; L ; ++ i) B[i] = D[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[lc] ; ++ i) A[i] = K[lc][i], C[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rc] ; ++ i) B[i] = K[rc][i], D[i] = P[rc][i] ;</span><br><span class="line">    NTT(A, L, <span class="number">1</span>), NTT(B, L, <span class="number">1</span>), NTT(C, L, <span class="number">1</span>), NTT(D, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) A[i] = (<span class="number">1l</span>l * A[i] * D[i] % Mod + <span class="number">1l</span>l * B[i] * C[i] % Mod) % Mod ;</span><br><span class="line">    NTT(A, L, <span class="number">-1</span>) ; K[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[Len[rt] + <span class="number">1</span>] ; <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= Len[rt] ; ++ i ) K[rt][i] = A[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    rr int W ; freopen("2.in", "r", stdin) ;</span></span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>);</span><br><span class="line">    N = read() ; <span class="keyword">int</span> i ; pre() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) bx[i] = read(), by[i] = read() ;</span><br><span class="line">    solve(<span class="number">1</span>, N, <span class="number">1</span>) ; <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span>(X)) ; <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span>(Y));</span><br><span class="line">    _Dev(P[<span class="number">1</span>], Q, Len[<span class="number">1</span>]) ; cdqNTT(<span class="number">1</span>, N, <span class="number">1</span>, Q) ; cdqLg(<span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; N ; ++ i) cout &lt;&lt; K[1][i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) write(K[<span class="number">1</span>][i]) ; fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：すべて分割べることのできる多項式生活最高だ！（一切皆可分治的多项式生活赛高！）</p>
]]></content>
      <tags>
        <tag>多项式基础</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】常系数齐次线性递推</title>
    <url>/2019/08/07/xxdt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>$\boldsymbol{k}$阶常系数齐次线性递推</strong>指的是以下问题：</p>
<blockquote>
<p>给出$k$阶线性递推式$\boldsymbol{f}$以及初始项$\boldsymbol{a_0,a_1…a_{k-1}}$，并满足：</p>
<script type="math/tex; mode=display">
a_{n}=\sum_{i=1}^{k} f_{i} \times a_{n-i}</script><p>对于某个$o$，求解$f_o$在某个固定模数下的值。</p>
</blockquote>
<p>然后以下是<code>shadowice1984</code>的人话版本：</p>
<blockquote>
<p>1.它是常系数的，换句话说递推系数和下标n无关</p>
<p>2.它是线性的，换句话说递推式中每一项的次数都是1，没有乱七八糟的2次3次项</p>
<p>3.它是齐次的，换句话说递推式的常数项等于0</p>
</blockquote>
<p>这个问题的弱智解法是$O(k^3\log n)$的矩阵快速幂。但是通过多项式加速可以将复杂度优化至$O(k^2\log n)$甚至$O(k\log k \log n)$.</p>
<p><del>于是这个世界上就再也没有矩阵快速幂了</del></p>
<a id="more"></a>
<h1 id="1-特征向量与特征多项式"><a href="#1-特征向量与特征多项式" class="headerlink" title="$1$  特征向量与特征多项式"></a>$1$  特征向量与特征多项式</h1><p>首先，给定$n$阶矩阵$\boldsymbol{A}$，若存在向量$\boldsymbol{x}$使得$\exists \lambda \in \mathbb {R}$ ，满足：</p>
<script type="math/tex; mode=display">
\tag{1} \boldsymbol{A}\cdot \boldsymbol{x} = \lambda\boldsymbol{x}</script><p>则称$\boldsymbol{x}$是$\boldsymbol{A}$的<strong>特征向量</strong>，$\lambda$称为$\boldsymbol{A}$的特征值，$(1)$式称之为<strong>特征方程</strong>。</p>
<p>同时也可以写作</p>
<script type="math/tex; mode=display">
(\boldsymbol{A}-\lambda\boldsymbol{I})\cdot \boldsymbol{x}= \boldsymbol{0}</script><p>有解的条件是</p>
<script type="math/tex; mode=display">
\tag{2} \det(\boldsymbol{A}-\lambda\boldsymbol{I})=0</script><p>同时定义<strong>特征多项式</strong>为<strong>类形式幂级数</strong>，即不考虑未知数$x$的数学形态，$x$可以为矩阵、向量$  etc.$</p>
<p>我们观察，$(2)$中右边的行列式计算的性质保证了行列式展开后每一项一定至多是$\lambda$的$n$次（主对角线相乘）、$n-1$次$\cdots$ $0$次，那么<strong>特征多项式即为关于$\lambda$的$\det(\boldsymbol{A}-\lambda\boldsymbol{I})$展开</strong>，记为$\boldsymbol{\phi(\lambda)}$.</p>
<p>接着观察$\phi(\lambda)$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi(\lambda)= |\boldsymbol{A}-\lambda \boldsymbol{I}| & = \left[\begin{array}{ccccc}{\ \lambda} & {0} & {\cdots} & {0} & {0} \\\ {0} & {\lambda} & {\cdots} & {0} & {0} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {\lambda} & {0} \\\ {0} & {0} & {\cdots} & {0} & {\lambda}\end{array}\right]-\left[\begin{array}{ccccc}{\ 0} & {0} & {\cdots} & {0} & {a_{k}} \\\ {1} & {0} & {\cdots} & {0} & {a_{k-1}} \\\ {0} & {1} & {\cdots} & {0} & {a_{k-2}} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {0} & {\lambda}\end{array}\right]\\\ & =\left[\begin{array}{ccccc}{\lambda} & {0} & {\cdots} & {0} & {-a_{k}} \\\ {-1} & {\lambda} & {\cdots} & {0} & {-a_{k-1}} \\\ {0} & {-1} & {\cdots} & {0} & {-a_{k-2}} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {-1} & {\lambda-a_{1}}\end{array}\right]
\end{aligned}</script><p>然后对于这个我们可以进行<strong>拉普拉斯展开</strong>（就是用代数余子式展开一个行列式），我们选择最后一列：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=\sum\limits_{i=1}^{k} a_{k-i+1}(-1)^{i+k}\phi(\lambda)_{i, k}</script><p>其中$\phi(\lambda)_{i,k}$表示丢掉$(i,k)$同行同列之后的代数余子式。</p>
<p>这东西可以暴力迭代式化简/直接良序归纳得出他的<del>背诵</del>化简形式：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=(-1)^{n}\left(\lambda^{n}-\sum_{i=1}^{n} a_{i} \lambda^{n-i}\right)</script><p><del>好像胡扯了半天也没扯到点子上，递推在哪？？</del></p>
<h1 id="2-一步转化-构造"><a href="#2-一步转化-构造" class="headerlink" title="$2$  一步转化/构造"></a>$2$  一步转化/构造</h1><p><strong>現在は大力构造時間です！！</strong></p>
<p>我们考虑构造一个这样的数列$\boldsymbol{g}$，满足：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{A}^i</script><p>然后我们两边同时左乘一个初始状态$\boldsymbol{F_0}$:</p>
<script type="math/tex; mode=display">
\boldsymbol{F_0\cdot A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{F_0\cdot A}^i</script><p>我们考虑对于矩阵乘法的$\boldsymbol{res}$矩阵，我们关心的是它的$(0,0)$处的值，不妨记为$\boldsymbol{res_0}$，那么就有：</p>
<script type="math/tex; mode=display">
\boldsymbol{res}_0=(\boldsymbol{F_0\cdot A} ^ n)_0 =\sum_{i=0}^{k-1}g_i(\boldsymbol{F_0\cdot A}^i)_0</script><p>其中$\boldsymbol{X}_p$表示一维向量$\boldsymbol{X}$的第$p$项。</p>
<p>然后使用观察法，我们发现$\boldsymbol{F_0\cdot A}^i$这东西就是转移了$i$次之后的第$0$项，换言之也就是$\boldsymbol{F_0}$的第$i$项，那么就会有：</p>
<script type="math/tex; mode=display">
\boldsymbol{res_0}=\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i</script><p>所以只要我们可以构造出一组$g$，我们就可以在$O(k)$的时间内求出答案。</p>
<h1 id="3-快速线性递推"><a href="#3-快速线性递推" class="headerlink" title="$3~$ 快速线性递推"></a>$3~$ 快速线性递推</h1><p>现在我们的任务就是构造$\boldsymbol{g}$序列了。</p>
<p>首先我们随便设一个关于$\boldsymbol{A}$的多项式：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^n=P(\boldsymbol{A})Q(\boldsymbol{A})+R(\boldsymbol{A})</script><p>于是我们发现，似乎根据带余除法的性质$\deg (R(\boldsymbol{A}))\leq \deg(\boldsymbol{A}^n)=n$，正好满足$\deg(\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i)\leq n$的性质，所以我们考虑当$P(\boldsymbol{A})Q(\boldsymbol{A})$这一项为$\boldsymbol{0}$时，恰好构造出一组可行的答案。</p>
<p>我们结合特征多项式考虑，$\phi(\lambda)=0$，恰好满足我们的需求。于是我们直接令$\boldsymbol{A}^n \bmod \phi(\lambda)$即可求出$R(\boldsymbol{A})=g$。</p>
<p>然后普通的就可以直接$k^2$暴力NTT，如果很闲并且模数是NTT模数的话还可以用$\log^2$的复杂度搞出来。</p>
<p>以下是<a href="https://www.luogu.org/problem/P4723" target="_blank" rel="noopener">LuoguP4723</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Gp 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 251003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line">LL base[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, L, K, R[MAXN] ;</span><br><span class="line">LL F[MAXN], G[MAXN], P[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rr LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;flag)</span></span>&#123;</span><br><span class="line">    rr LL Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; l ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        Gn = expow(Gp, (Mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; l ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = <span class="number">1l</span>l * Gi * Gn % Mod)&#123;</span><br><span class="line">                <span class="keyword">int</span> real = J[j + k], iroot = <span class="number">1l</span>l * J[j + k + i] * Gi % Mod ;</span><br><span class="line">                J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    rr <span class="keyword">int</span> Inv = expow(<span class="number">1l</span>l * l, Mod - <span class="number">2</span>) ; reverse(J + <span class="number">1</span>, J + l) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line">LL t[MAXN], T[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Inv(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - t[i] * g[i] % Mod + Mod) % Mod * g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">LL IG[MAXN], Ft[MAXN], Gt[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Div(LL *f, <span class="keyword">const</span> <span class="keyword">int</span> &amp;Len)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> L1 = (K &lt;&lt; <span class="number">1</span>), D, i ;</span><br><span class="line">    <span class="keyword">while</span> (!f[-- L1]) ; <span class="keyword">if</span> (L1 &lt; K) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; D = L1 - K + <span class="number">1</span> ;</span><br><span class="line">    reverse(Ft, Ft + L1 + <span class="number">1</span>) ; <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Ft, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ;</span><br><span class="line">    NTT(P, Len, - <span class="number">1</span>) ; <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) P[i] = <span class="number">0</span> ; reverse(P, P + D) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) (P[i] *= G[i]) %= Mod ; NTT(P, Len, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) f[i] = (f[i] - P[i] + Mod) % Mod ; <span class="keyword">for</span> (i = K ; i &lt;= L1 ; ++ i) f[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("2.in", "r", stdin) ;</span></span><br><span class="line">    rr <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i ; <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (K &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ; F[<span class="number">0</span>] = <span class="number">1</span> ; Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;p[i]), p[i] = p[i] &lt; <span class="number">0</span> ? p[i] + Mod : p[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), base[i] = base[i] &lt; <span class="number">0</span> ? base[i] + Mod : base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) Gt[K - i] = G[K - i] = Mod - p[i] ; T[<span class="number">1</span>] = G[K] = Gt[K] = <span class="number">1</span> ;reverse(Gt, Gt + K + <span class="number">1</span>) ;</span><br><span class="line">    NTT(G, Len, <span class="number">1</span>) ; _Inv(Gt, IG, Len &gt;&gt; <span class="number">1</span>), NTT(IG, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        NTT(T, Len, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            NTT(F, Len, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) F[i] = F[i] * T[i] % Mod ;</span><br><span class="line">            NTT(F, Len, <span class="number">-1</span>) ; _Div(F, Len) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) (T[i] *= T[i]) %= Mod ; NTT(T, Len, <span class="number">-1</span>) ; _Div(T, Len), N &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) (Ans += (F[i] * base[i]) % Mod) %= Mod ; <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>常系数齐次线性递推</category>
      </categories>
      <tags>
        <tag>数学/常系数齐次线性递推</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式求幂/开根</title>
    <url>/2019/08/07/rooti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>形式化来讲，我们要解决这两个问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= F^k \ (\bmod \ x^n)\\\
G^k &= F \ (\bmod \ x^n)
\end{aligned}</script><p>然而实际上后一个咕了，我曾把这玩意儿当作<code>多项式牛顿迭代</code>的课后题来着……并且更重要的原因没人出这玩意儿的题，所以直接简化成$G^2\equiv F$好了。。。</p>
<a id="more"></a>
<h1 id="1-求幂"><a href="#1-求幂" class="headerlink" title="$1$ 求幂"></a>$1$ 求幂</h1><p>首先思考式子</p>
<script type="math/tex; mode=display">
G=F^k(~\bmod~x^n)</script><p>怎么化开。那么喜闻乐见的就是一步求对数然后exp回去：</p>
<script type="math/tex; mode=display">
\ln G = k \ln F~(\bmod~x^n)\\\
\exp(k\ln F)=G~(\bmod ~x^n)</script><p>对应的是<code>Luogu</code>的<a href="https://www.luogu.org/problem/P5245" target="_blank" rel="noopener"><code>P5245</code></a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, y ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N, M = <span class="number">1</span> ;</span><br><span class="line">    Gi = expow(Gp, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (M &lt;= N) M &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; In ; y = <span class="built_in">strlen</span>(In) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;F[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; y ; ++ i) K = (K * <span class="number">10</span> + In[i] - <span class="string">'0'</span>) % P ;</span><br><span class="line">    _Ln(F, L, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) L[i] = <span class="number">1l</span>l * L[i] * K % P ;</span><br><span class="line">    _Exp(L, G, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, G[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法只能应用于$a_0=1$的情况下，原因在写<code>exp</code>的时候整理过。</p>
<p>但这东西显然是可以$\Theta(n\log^2n)$暴力ntt做的，我很快乐地水过了这道题的加强版<a href="https://www.luogu.org/problem/P5273" target="_blank" rel="noopener"><code>P5273</code></a>，即不保证$a_0=1$的版本：</p>
<blockquote>
<p>似乎大家都是诡异的写法，没有人用$O(n\log^2 n)$去暴力艹这道题。</p>
<p>然而事实上是完全可以卡过去的。我的提交虽然加了<code>-O2</code>和<code>#pragma</code><del>显得十分弟弟</del>，但是其实去掉之后也是很快的。不吹，绝对比大部分的普通$O(n\log^2n)$的NTT跑得快。</p>
<p>那么以下是几个优化的措施：<br>$\#1$</p>
<p>预处理原根的次幂——卡常利器。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">19</span>  ;++ i)&#123;</span><br><span class="line">        rr <span class="keyword">int</span> *rua = gg[i] ; rua[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        rr <span class="keyword">int</span> gi = rua[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span>/(<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) rua[j] = <span class="number">1l</span>l * rua[j - <span class="number">1</span>] * gi % P ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后每次NTT就不需要重新再计算了。</p>
<p>$\#2$</p>
<p>做快速幂的时候注意可以少几次<code>NTT</code>。这点常数优化也是需要的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (K)&#123;</span><br><span class="line">        NTT(F, M, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (K &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            NTT(A, M, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i) A[i] = <span class="number">1l</span>l * A[i] * F[i] % P ;</span><br><span class="line">            NTT(A, M, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = N ; i &lt; M ; ++ i) A[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i)</span><br><span class="line">            F[i] = <span class="number">1l</span>l * F[i] * F[i] % P ; NTT(F, M, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = N ; i &lt; M ; ++ i) F[i] = <span class="number">0</span> ; K &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$\#3$</p>
<p>不用<code>long long</code>.</p>
<p>这其实一个通用的技巧，因为long long一般都比int多好多常数。同时不要强制类型转换而选择<code>1ll*</code>这种形式。实测可以快许多。</p>
</blockquote>
<p>不得不说，这个预处理原根确实是一个卡常黑科技qwq</p>
<h1 id="2-开根"><a href="#2-开根" class="headerlink" title="$2$ 开根"></a>$2$ 开根</h1><p>普通的开根还是<code>exp</code>和<code>ln</code>：</p>
<script type="math/tex; mode=display">
G^2=F\\\
2 \ln G = \ln F\\\
G = \exp(\frac{\ln F}{2})</script><p>然后就可以胡搞<a href="https://www.luogu.org/problem/P5205" target="_blank" rel="noopener">LuoguP5205</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Invsqr(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i, o ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ; o = expow(<span class="number">2l</span>l, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    _Ln(f, E, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) E[i] = E[i] * o % P ; _Exp(E, g, M) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是还是有问题，就是因为需要$\exp$，上述也必须要$F_0=1$。于是当$F_0\neq 1$时，我们可以直接暴力求<strong>二次剩余</strong>，注意这种方法就需要用牛迭来实现开根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> solveroot&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span> <span class="keyword">int</span> x, y ; &#125; ;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">mul</span><span class="params">(<span class="keyword">complex</span> a, <span class="keyword">complex</span> b, <span class="keyword">int</span> p, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = (<span class="number">1l</span>l * a.x * b.x % p + <span class="number">1l</span>l * a.y * b.y % p * rt % p) ;</span><br><span class="line">        <span class="keyword">int</span> ny = (<span class="number">1l</span>l * a.x * b.y % p + <span class="number">1l</span>l * a.y * b.x % p) ;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">complex</span>)&#123;nx % p, ny % p&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">expow</span><span class="params">(<span class="keyword">complex</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">complex</span> res = (<span class="keyword">complex</span>)&#123;<span class="number">1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = mul(res, a, p, z), b -- ;</span><br><span class="line">            a = mul(a, a, p, z), b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = <span class="number">1l</span>l * a * res % p ;</span><br><span class="line">            a = <span class="number">1l</span>l * a * a % p ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        srand((<span class="keyword">int</span>)<span class="string">'x'</span>+<span class="string">'q'</span>+<span class="string">'I'</span>+<span class="string">'L'</span>+<span class="string">'o'</span>+<span class="string">'v'</span>+<span class="string">'e'</span>+<span class="string">'u'</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pint <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        seed() ;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">int</span> x, y ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            x = rand() % p ;</span><br><span class="line">            y = (<span class="number">1l</span>l * x * x + (p - n)) % p ;</span><br><span class="line">            <span class="keyword">if</span> (expow(y, (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p) == p - <span class="number">1</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">complex</span> now = (<span class="keyword">complex</span>)&#123;x, <span class="number">1</span>&#125;, ansp, ansn ;</span><br><span class="line">        ansp = expow(now, (p + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p, y),</span><br><span class="line">        ansn = (<span class="keyword">complex</span>)&#123;p - ansp.x, ansp.y&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (ansp.x &gt; ansn.x) swap(ansp, ansn) ;</span><br><span class="line">        <span class="keyword">return</span> mp(ansp.x, ansn.x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">。。。。。</span><br><span class="line">LL Ig[MAXN], pf[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> solveroot ;</span><br><span class="line"><span class="keyword">void</span> _sqr(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        g[<span class="number">0</span>] = solve(f[<span class="number">0</span>], P).fr ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _sqr(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) Ig[i] = <span class="number">0</span>, pf[i] = <span class="number">2</span> * g[i] % P ;</span><br><span class="line">    _Inv(pf, Ig, len) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) <span class="comment">/* */</span> t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; ( l - <span class="number">1</span> )) ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; NTT(Ig, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后为了做这道题还去学了<code>Cipolla</code>，然后还顺便发现luogu上少一道二次剩余的板子就顺手出了道题2333</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式ln/exp</title>
    <url>/2019/08/07/lnexp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实这两个东西只是一个拓展，思想也是简单的思想，只不过由于$\ln$运算的乘方转乘法很好用，所以大部分套路都是<strong>先多项式$\ln$乱搞一通再多项式$\exp$回去</strong>。</p>
<p>形式化地讲，我们就是要解决以下两个问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
1)\quad G&= \ln F \ (\bmod \ p)\\\
2)\quad G&= e^{F} \ (\bmod \ p)
\end{aligned}</script><a id="more"></a>
<h1 id="1-ln"><a href="#1-ln" class="headerlink" title="$1~\ln$"></a>$1~\ln$</h1><p>其实就是瞎jb记一下式子啦</p>
<script type="math/tex; mode=display">
G'= F'\cdot \frac{1}{F}=\frac{F'}{F}</script><p>……然后就先对F求个导+求个逆然后再不定积分回去就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Dev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> i ; g[len - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; len ; ++ i) g[i - <span class="number">1</span>] = i * f[i] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Invdev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">0</span> ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; len ; ++ i) g[i] = f[i - <span class="number">1</span>] * expow(i, P - <span class="number">2</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Ln(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    _Dev(f, A, len), _Inv(f, B, len) ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span> ; <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, Len, <span class="number">1</span>), NTT(B, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) A[i] = <span class="number">1l</span>l * A[i] * B[i] % P ;</span><br><span class="line">    NTT(A, Len, <span class="number">-1</span>), _Invdev(A, g, len) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也算是小清新的多项式板子了，毕竟没有诡异的清空和鬼畜的码长。</p>
<h1 id="2-exp"><a href="#2-exp" class="headerlink" title="$2~\exp$"></a>$2~\exp$</h1><script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\
\Longrightarrow G &=G_h-G_h\ln G_h+G_hF\\\
\Longrightarrow G &=G_h(1-\ln G_h+F)\\\
\end{aligned}</script><p>然后需要的知识点就是<strong>牛顿迭代</strong>了，这玩意儿之前写过，懒得再叙述一遍了……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Ln(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> i, Len = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    _Dev(f, A, len) ; _Inv(f, B, len) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= Len ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " &lt;&lt; B[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    NTT(A, Len, <span class="number">1</span>), NTT(B, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) A[i] = A[i] * B[i] % P ;</span><br><span class="line">    NTT(A, Len, <span class="number">-1</span>), _Invdev(A, g, len) ; <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t)), <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B)),  <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> C[MAXN], D[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Exp(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123; g[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    _Exp(f, g, len + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) ; <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; (len &lt;&lt; <span class="number">1</span>) ; ++ i) C[i] = D[i] = <span class="number">0</span> ; _Ln(g, C, len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; ++ i) D[i] = f[i] ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>), NTT(C, Len, <span class="number">1</span>), NTT(D, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">1l</span>l + D[i] - C[i] + P) * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt;= Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较重要的就是<strong>清空</strong>，由于$\exp$是迭代实现的，所以要进行多次$\ln$。。。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式带余除法</title>
    <url>/2019/08/07/chumod/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决一类</p>
<script type="math/tex; mode=display">
G=F\cdot P+R ~(\bmod~x^n)</script><p>其中$F, G$给定，求解$P$和$R$</p>
<p><del>然而最后变成了老年选手的多项式瞎吹？</del></p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>这就很苟，最近要被多项式除法给整疯了，原因大概是我换一道模板就需要换一种写法……原来那种怎么改都不对就很智障……</p>
<p>然后划式子过程就很苟，是一种诡异的构造方式，前置芝士大概是$F(\frac{1}{x})=F^T(x)$，其中$T$表示转置——当然是一个不严谨的记号，意思就是把这个形式幂级数的系数<code>reverse</code>掉。</p>
<p>以下是过程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(x)&=F(x)P(x)+R(x)\\\
G(\frac{1}{x})&=F(\frac{1}{x})P(\frac{1}{x})+R(\frac{1}{x})\\\
\because A_r&= x^nA(\frac{1}{x})\\\
\therefore x^nG(\frac{1}{x})&=x^nF(\frac{1}{x})P(\frac{1}{x})+x^nR(\frac{1}{x})\\\
\Longrightarrow x^nG(\frac{1}{x})&=x^mF(\frac{1}{x})\cdot x^{n-m}P(\frac{1}{x})+x^{m-1}\cdot x^{n-m+1}R(x)\\\
\Longrightarrow G_r(x)&=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x)\\\
\Longrightarrow G_r(x)&=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x) ~(\bmod x^{n-m+1})\\\
\Longrightarrow P_r(x)&=F_r(x)\cdot G_r^{-1}(x)~(\bmod x^{n-m+1})\\\
\end{aligned}</script><p>之后求出$P_r$之后就可以回代原式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G=F\cdot P+R\\\
R = G - F\cdot P
\end{aligned}</script><p>于是就完了</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>但是实际写法有些问题，比如板子<a href="https://www.luogu.org/problem/P4512" target="_blank" rel="noopener">P4512 【模板】多项式除法</a></p>
<p>这其实就直接做就好，不是很需要考虑清零什么的。但是我总觉得在<code>Inv</code>之后是不是需要重新算一下<code>R</code>……不清楚诶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL Ft[MAXN], Gt[MAXN], IG[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Div()&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, O = N - M + <span class="number">1</span> ;</span><br><span class="line">    reverse(Ft, Ft + N), reverse(Gt, Gt + M) ;</span><br><span class="line">    l = <span class="number">0</span>, L = <span class="number">1</span> ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O ; i &lt; N ; ++ i) Ft[i] = Gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    _Inv(Gt, IG, O), NTT(IG, L, <span class="number">1</span>), NTT(Ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, L, - <span class="number">1</span>) ; reverse(P, P + O) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; O ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, P[i]) ; <span class="keyword">for</span> (<span class="keyword">int</span> i = O ; i &lt; N ; ++ i) P[i] = <span class="number">0</span> ;</span><br><span class="line">    O = N, L = <span class="number">1</span>, l = <span class="number">0</span> ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, L, <span class="number">1</span>), NTT(G, L, <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, L, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ++ N, ++ M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;F[i]), Ft[i] = F[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]), Gt[i] = G[i] ; _Div() ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M - <span class="number">1</span> ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, (F[i] - Q[i] + Mod) % Mod) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是之后线性递推时需要进行的取模操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Div(LL *f, <span class="keyword">int</span> Len)&#123;</span><br><span class="line">    <span class="keyword">int</span> L1 = (K &lt;&lt; <span class="number">1</span>), D, i ;</span><br><span class="line">    <span class="keyword">while</span> (!f[-- L1]) ; <span class="keyword">if</span> (L1 &lt; K) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; reverse(Ft, Ft + L1 + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (D = L1 - K + <span class="number">1</span>, i = D ; i &lt;= L1 ; ++ i) Ft[i] = <span class="number">0</span> ; NTT(Ft, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, Len, - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) P[i] = <span class="number">0</span> ; reverse(P, P + D) ; NTT(P, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, Len, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) f[i] = (f[i] - Q[i] + Mod) % Mod ; <span class="keyword">for</span> (i = K ; i &lt;= L1 ; ++ i) f[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main_function</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) G[K - i] = Mod - p[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Gt[i] = G[i] ; reverse(Gt, Gt + K + <span class="number">1</span>) ;</span><br><span class="line">    NTT(G, Len, <span class="number">1</span>) ; _Inv(Gt, IG, Len &gt;&gt; <span class="number">1</span>), NTT(IG, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure>
<p>看上去很正常，只是多了几个预处理而已。但是不知为何当时写的就很迷。。。并且从这个板子开始我明白了，<strong>多项式长度+是否清空</strong>这个组合绝对是多项式入门里面最难受的细节。</p>
<p>之后就更迷了，多点求值这玩意儿实在毒瘤：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f,  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>* Rs)&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">0</span>, O = n - m + <span class="number">1</span>, L , i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= (n &lt;&lt; <span class="number">1</span>) ; ++ i) ig[i] = ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = <span class="number">0</span>, L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = O ; i &lt; (n &lt;&lt; <span class="number">1</span>); ++ i) ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    Inv(gt, ig, O) ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>,++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L ; ++ i) t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(ig, L, <span class="number">1</span>), NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, - <span class="number">1</span>) ; reverse(X, X + O) ; <span class="keyword">for</span> (i = O ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    O = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>))  ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT (G, L, <span class="number">1</span>)  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * G[i] * X[i] % Mod, X[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) Rs[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) + Mod) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很烦……鬼知道你tm什么时候忘清空或者忘开<code>long long</code>了就要调一年……艹</p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>最后趁机说一下写多项式的心得<del>其实就是瞎吹</del>：</p>
<ul>
<li>好烦啊（</li>
<li>代码好长啊（</li>
<li>为什么踏马每次徒手写NTT都会挂啊（</li>
<li>学了半天原来FFT是最没用的啊（</li>
<li>调死我了啊</li>
<li>还不如直接照着模板背呢，每天早读背一发，那个什么教辅不是说来着？“背虽传统，也最实用”（</li>
<li>卧槽每次写一道板子就要交上一整页<del>，我不要面子的吗</del>（</li>
</ul>
<p>正经一点的话，大概就是我这几个板子都是用数组写的，所以会有<code>memset</code>或者<code>for for for</code>之类的，闲得很凌乱。再加上之前很智障地每次都要重新推一遍蝴蝶操作的<code>Rev</code>数组，就显得很弱智。于是决定下一次多项式复习的时候，自己可以学的更成体系，也可以用上<code>operator</code>和<code>vector</code>这两个利器。</p>
<p>upd：就在落笔不到5min之后想到了一个问题，就是你会发现在多项式题目里面有$\mod x^n$和$\mod \rm{NTTPrime}$ 两种约束，一直以为的是<code>不同的运算有不同的约束</code>，但这是$\color{red}{\text{错的}}$ 。真正的区别是，前者是对次数的约束，后者是对系数的约束。</p>
<p>= =也就只有我会智障到现在才明白。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】形式幂级数的牛顿迭代</title>
    <url>/2019/08/01/diedai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多项式的牛顿迭代，是借助泰勒展开进行的一种对于形式幂级数的常规操作，解决的主要问题是：</p>
<script type="math/tex; mode=display">
G(F) \equiv 0~(\bmod x^n)</script><p>给定形式幂级数$G$，求解$F$。</p>
<p>而解决途径则是通过对降半次的$F_0$向上迭代解决的。</p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>假设我们现在已经求出了$G(F_0)\equiv 0~(\bmod~x^{\frac{n}{2}})$</p>
<p>首先之前标准的式子左边在$F_0(x)$处进行泰勒展开，可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned} G(F(x)) &=G\left(F_{0}(x)\right) \\\ &+\frac{G^{\prime}\left(F_{0}(x)\right)}{1 !}\left(F(x)-F_{0}(x)\right) \\\ &+\frac{G^{\prime \prime}\left(F_{0}(x)\right)}{2 !}\left(F(x)-F_{0}(x)\right)^{2} \\\ &+\cdots (\mod ~x^n)\end{aligned}</script><p>但是我们考虑在$\mod ~x^n$意义下，$F$和$F_0$的最后$\frac{n}{2}$项相同，所以在上面的式子，$(F-F_0)^k,~k&gt;2$时，最低次项的次数一定会大于$2\cdot\lfloor \frac{n}{2}\rfloor$，也就是说在$\mod~x^n$意义下都是全0项。那么我们就可以得到：</p>
<script type="math/tex; mode=display">
G(F(x)) \equiv G\left(F_{0}(x)\right)+G^{\prime}\left(F_{0}(x)\right)\left(F(x)-F_{0}(x)\right) \quad\left(\bmod x^{n}\right)</script><p>然后因为$G(F)=0~(\bmod~x^n)$，所以我们可以得到：</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x) - \frac{G(F_0(x))}{G^{\prime}\left(F_{0}(x)\right)} \quad\left(\bmod x^{n}\right)</script><p>于是直接递推就好。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p><del>接下来看几个课后练习</del></p>
<h3 id="1-G-2-equiv-F-bmod-x-n"><a href="#1-G-2-equiv-F-bmod-x-n" class="headerlink" title="$(1)~G^2\equiv F~(\bmod~x^n)$"></a>$(1)~G^2\equiv F~(\bmod~x^n)$</h3><script type="math/tex; mode=display">
\begin{aligned}  
G^2&=F\\\
G^2-F&=0\\\
\end{aligned}</script><p>令$T(G)=G^2-F$,<del>套用公式</del>可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(G)&=G^2-F,F\Longleftrightarrow \mathbb{C} \\\
G &= G_h-\frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G&=G_h-\frac{G_h^2-F}{2G_h}\\\
\Longrightarrow G&=\frac{G_h^2+F}{2G_h}
\end{aligned}</script><h3 id="2-G-equiv-e-F-bmod-x-n"><a href="#2-G-equiv-e-F-bmod-x-n" class="headerlink" title="$(2)~G\equiv e^{F}~(\bmod ~x^n)$"></a>$(2)~G\equiv e^{F}~(\bmod ~x^n)$</h3><p><del>按照套路应该</del>两边同时取$\ln$:</p>
<script type="math/tex; mode=display">
\ln G=F~(\bmod~x^n)</script><p>之后我们令$T(G)=\ln G-F$，<del>套用公式可以得到</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\
\Longrightarrow G &=G_h-G_h\ln G_h+G_hF\\\
\Longrightarrow G &=G_h(1-\ln G_h+F)\\\
\end{aligned}</script><h3 id="3-G-k-equiv-F-bmod-x-n"><a href="#3-G-k-equiv-F-bmod-x-n" class="headerlink" title="$(3)~G^k\equiv F~(\bmod ~x^n)$"></a>$(3)~G^k\equiv F~(\bmod ~x^n)$</h3><script type="math/tex; mode=display">
T(G) = G^k-F=0</script><p><del>套用公式可以得到</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{G_h^k-F}{kG_h^{k-1}}\\\
\Longrightarrow G &=\frac{(k-1)G_h^k+F}{kG_h^{k-1}}
\end{aligned}</script><p>然后就算这个东西就变成$\log^3~\text{or}~\log^2$可以算的东西了。</p>
<h3 id="4-2G-ln-G-equiv-F-bmod-x-n"><a href="#4-2G-ln-G-equiv-F-bmod-x-n" class="headerlink" title="$(4)~2G \ln G\equiv F~(\bmod x^n)$"></a>$(4)~2G \ln G\equiv F~(\bmod x^n)$</h3><script type="math/tex; mode=display">
T(G)\equiv 2G\ln G-F~(\bmod~x^n)</script><p>同样的台词……</p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{2G_h\ln G_h-F}{2\ln G_h+2G_h\cdot \frac{1}{G_h}}\\\
\Longrightarrow G &=\frac{2G_h\ln G_h-F}{(2\ln+1)G_h}
\end{aligned}</script><p>然后这东西好像是可以$\log^2$做的……不过有些小朋友特别喜欢出无脑的多项式板子，像这种东西就很没有意思qaq。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式求逆</title>
    <url>/2019/07/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定$F(x)$，求$G(x)$满足$G(x)\cdot F(x) \equiv1~(\bmod x^n)$.</p>
<p>不妨考虑$G’(x)\cdot F(x) =1~(\bmod x^{\frac{n}{2}})$</p>
<p>则有如下：</p>
<script type="math/tex; mode=display">
\because G'\cdot F =1~(\bmod x^{\frac{n}{2}})\\\ ~G\cdot F \equiv1~(\bmod x^{\frac{n}{2}})\\\
\therefore G' -G\equiv0~(\bmod x^{\frac{n}{2}})\\\ 
\Longrightarrow G'^2+G^2-2G'G\equiv0~(\bmod x^{n})</script><p>两端同时卷上一个$F(x)$则有：</p>
<script type="math/tex; mode=display">
\because F\cdot G\equiv1~(\bmod x^n)\\\
\therefore G\equiv 2G'-FG'^2~(\bmod x^n)</script><p>以此为递推式即可递推出$G(x)$的值，时间复杂度$O(n\log^2 n)$.</p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1~$"></a>$1~$</h1><p><a href="https://www.luogu.org/problem/P4238" target="_blank" rel="noopener">【模板】多项式求逆</a></p>
<p>就是板子，NTT一下就好= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300023</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> t[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, base[MAXN], Ans[MAXN], rev[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y) </span><br><span class="line">		res = ((y &amp; <span class="number">1</span>) ? <span class="number">1l</span>l * res * x % Mod : res), </span><br><span class="line">		x = <span class="number">1l</span>l * x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> L, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	rr <span class="keyword">int</span> Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (i &lt; rev[i]) J[i] ^= J[rev[i]] ^= J[i] ^= J[rev[i]] ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		Gn = expow(G, (Mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = <span class="number">1l</span>l * Gi * Gn % Mod)&#123;</span><br><span class="line">				rr <span class="keyword">int</span> real = J[j + k], iroot = <span class="number">1l</span>l * J[j + k + i] * Gi % Mod ;</span><br><span class="line">				J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> Inv = expow(L, Mod - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv_NTT</span><span class="params">(<span class="keyword">int</span> Len, <span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span>&#123;<span class="comment">//递推 </span></span><br><span class="line">	<span class="keyword">if</span> (Len &lt;= <span class="number">1</span>)&#123; B[<span class="number">0</span>] = expow(A[<span class="number">0</span>], Mod - <span class="number">2</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	Inv_NTT((Len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B) ; rr <span class="keyword">int</span> Lim = <span class="number">1</span>, len = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (Lim &lt; (Len &lt;&lt; <span class="number">1</span>)) Lim &lt;&lt;= <span class="number">1</span>, ++ len ; rr <span class="keyword">int</span> i, j, k ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Lim ; ++ i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len<span class="number">-1</span>)) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) t[i] = A[i] ; </span><br><span class="line">    NTT(t, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Lim ; ++ i) B[i] = <span class="number">1l</span>l * (<span class="number">2l</span>l - <span class="number">1l</span>l * t[i] * B[i] % Mod + Mod) % Mod * B[i] % Mod ;</span><br><span class="line">    NTT(B, Lim, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = Len ; i &lt;= Lim ; ++ i) B[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	Inv_NTT(N, base, Ans) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p><a href="https://www.luogu.org/problem/P4239" target="_blank" rel="noopener">【模板】多项式求逆（加强版）</a></p>
<p>然而就是把模数换成了非NTT模数= =</p>
<p>于是就做一遍MTT就好了，这里写的是带有共轭优化的版本= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM MAXN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod (1000000007)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ; <span class="keyword">int</span> T[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> t[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, base[MAXN], Ans[MAXN], rev[MAXN]  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y) </span><br><span class="line">		res = ((y &amp; <span class="number">1</span>) ? <span class="number">1l</span>l * res * x % Mod : res), </span><br><span class="line">		x = <span class="number">1l</span>l * x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM], qaq ; <span class="keyword">int</span> L1, L2, P ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r + Q.r , J.i + Q.i&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r - Q.r , J.i - Q.i&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r&#125; ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;Lim, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) qaq = J[i], J[i] = J[rev[i]], J[rev[i]] = qaq ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(rr <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Lim ; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; j ; ++ l)&#123;</span><br><span class="line">                rr node T = w[Lim / j * l] ; <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) T.i *= <span class="number">-1</span> ;</span><br><span class="line">                rr node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> *K, <span class="keyword">int</span> Length, <span class="keyword">int</span> P, <span class="keyword">int</span> Lim, <span class="keyword">int</span> *ret)</span></span>&#123;</span><br><span class="line">    rr node ia, ib, a1, a2, b1, b2 ; rr <span class="keyword">int</span> t, k, q1, q2, q3 ;  </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (Length &lt;&lt; <span class="number">1</span>) ; ++ i) A[i] = B[i] = (node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; Lim ; i &lt;&lt;= <span class="number">1</span>) <span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; i ; ++ k) w[Lim / i * k] = (node)&#123;<span class="built_in">cos</span>(k * Pi / i) , <span class="built_in">sin</span>(k * Pi / i)&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= Length ; ++ i) A[i].r = J[i] &amp; <span class="number">32767</span>, A[i].i = J[i] &gt;&gt; <span class="number">15</span>, B[i].r = K[i] &amp; <span class="number">32767</span>, B[i].i = K[i] &gt;&gt; <span class="number">15</span> ;</span><br><span class="line">    FFT(A, Lim, <span class="number">1</span>), FFT(B, Lim, <span class="number">1</span>), t = Lim - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i)&#123;</span><br><span class="line">        k = (Lim - i) &amp; t ; </span><br><span class="line">		ia = (node)&#123; A[k].r, -A[k].i &#125;, ib = (node)&#123; B[k].r, -B[k].i &#125; ; </span><br><span class="line">        a1 = (ia + A[i]) * (node) &#123;<span class="number">0.5</span>, <span class="number">0</span>&#125;, a2 = (A[i] - ia) * (node) &#123;<span class="number">0</span>, <span class="number">-0.5</span>&#125; ;</span><br><span class="line">        b1 = (ib + B[i]) * (node) &#123;<span class="number">0.5</span>, <span class="number">0</span>&#125;, b2 = (B[i] - ib) * (node) &#123;<span class="number">0</span>, <span class="number">-0.5</span>&#125; ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * (node)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">	FFT(t1, Lim, <span class="number">-1</span>), FFT(t2, Lim, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Length ; ++ i)&#123; </span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / Lim + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / Lim + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / Lim + <span class="number">0.5</span>) % P, ret[i] = ((<span class="number">1l</span>l * q3 &lt;&lt; <span class="number">30</span>) % P + (<span class="number">1l</span>l * q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv_MTT</span><span class="params">(<span class="keyword">int</span> Len, <span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Len &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">		B[<span class="number">0</span>] = expow(A[<span class="number">0</span>], Mod - <span class="number">2</span>) ; </span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	Inv_MTT(Len &gt;&gt; <span class="number">1</span>, A, B) ; rr <span class="keyword">int</span> Lim, len = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (Lim = <span class="number">1</span> ; Lim &lt;= Len ; Lim &lt;&lt;= <span class="number">1</span>) ++ len ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i) </span><br><span class="line">		rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len<span class="number">-1</span>)) ;</span><br><span class="line">	MTT(A, B, Len, Mod, Lim, T), MTT(T, B, Len, Mod, Lim, t) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Len ; ++ i) B[i] = <span class="number">1l</span>l * (<span class="number">2l</span>l * B[i] - t[i] + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))  c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; rr <span class="keyword">int</span> i, Np ; </span><br><span class="line">	<span class="keyword">for</span> (Np = <span class="number">1</span> ; Np &lt; N ; Np &lt;&lt;= <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) base[i] = qr() ;</span><br><span class="line">	Inv_MTT(Np, base, Ans) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开了一发O2发现快了三倍，woc…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】洛谷三月月赛 Derivation</title>
    <url>/2019/07/26/biaodashishu2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般在考场上写出这种东西的人，我们称之为：巨  魔  码  怪。</p>
<a id="more"></a>
<p>小 R 学会微积分中求导这一概念后，他的数学老师要求他开始做一部分导数的练习题加深自己的理解。</p>
<p>但颖悟绝伦的小 R 对繁复的练习题并不感兴趣。他希望你帮他设计一个程序，计算一个给定函数 $f(x)$ 的导数。</p>
<p>第一行一个正整数 T，表示小 R 要完成的练习题数量，亦即测试数据的组数。<br>每组测试数据的第一行是一个非空字符串，描述了输入的函数 $f(x)$。设 $p=998244353$。</p>
<p>字符串中可能包含的元素有：</p>
<p>1、系数为 $1$ 的单项式，包括 $x^2,x^0$ 等，我们保证指数为非负整数为 $1$ 时不省略，不会超过 $p-1$。所有幂号用 <code>^</code> 代替。<br>2、常数，如 $0,19260817$ 等；我们保证一切常数是非负整数且不超过 $p-1$。<br>3、复合函数。将以上两种函数组合的方式可以为加乘幂，括号等。数学中会省略乘号和括号，但我们保证任意情况下都不省略（也不会无意义冗余，即不存在 <code>((x)),(3)+(4)</code>）；保证任何指数都是常数，即不存在 $x^{g(x)}$的情况。</p>
<p>测试数据的第二行为两个整数，值在$[0,p)$之间。你需要输出两个整数，表示这些整数代入导函数后的值模 $p$ 的结果。</p>
<p>本题中认为 $0^0=1$。</p>
<hr>
<hr>
<p>这道题也是很神= =</p>
<p>首先求导不求导的，先把树建出来，然后就会发现这个题的本质还是合并左右孩子。但是有一点很神，就是合并时要用<strong>扩展欧拉定理</strong>合并，原因是我们存在<code>^</code>这个运算。然后就考虑我们可以存储当<code>x=v</code>时对所有扩欧展开时的模数取模，更新的时候按秩更新就好了= =</p>
<p>还有就是在调这题时，我发现了一个以前程序的bug。</p>
<p>关于建树时的鬼畜判断，我当时是这么加的判断:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tp = <span class="number">0</span>, <span class="built_in">memset</span>(brac, <span class="number">0</span>, <span class="keyword">sizeof</span>(brac)) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">blablabla....</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (brac[l] == r) l ++, r -- ;</span><br><span class="line">    blablabla...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这东西每次<code>memset</code>显然会超时，于是便采用一个退化版本<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (In[l] == <span class="string">'('</span> &amp;&amp; In[r] == <span class="string">')'</span>) l ++, r -- ; <span class="comment">// 1</span></span><br><span class="line">    blablabla...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tm当时自己因为这个调了好久也是很佛了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod[MAXM], n, v ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i * i &lt;= x ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i))&#123;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>) ; </span><br><span class="line">            <span class="keyword">while</span> (!(x % i)) x /= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ret = ret / x * (x - <span class="number">1</span>) ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _prework()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mod ; i &gt; <span class="number">1</span> ; i = phi(i)) </span><br><span class="line">        mod[++ n] = i ; mod[++ n] = <span class="number">1</span>, mod[++ n] = <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> brac[MAXN], stk[MAXN], tp ;</span><br><span class="line"><span class="keyword">char</span> op[MAXN], In[MAXN] ; <span class="keyword">int</span> N, T ; </span><br><span class="line"><span class="keyword">int</span> root, L[MAXN], R[MAXN], tot ; ll val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="string">'+'</span> || x == <span class="string">'*'</span> || x == <span class="string">'^'</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (In[l] == <span class="string">'('</span> &amp;&amp; In[r] == <span class="string">')'</span>) l ++, r -- ; <span class="comment">// 1</span></span><br><span class="line">    rr <span class="keyword">int</span> rt = <span class="number">0</span>, rt1 = <span class="number">0</span>, rt2 = <span class="number">0</span>, x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) i = brac[i] + <span class="number">1</span> ; <span class="keyword">if</span> (i &gt; r) <span class="keyword">break</span> ; </span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'+'</span> &amp;&amp; !isop(In[i - <span class="number">1</span>])) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'*'</span>) rt1 = i ; <span class="keyword">if</span> (In[i] == <span class="string">'^'</span> &amp;&amp; !rt2) rt2 = i ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt) x = rt ; <span class="keyword">else</span> <span class="keyword">if</span> (rt1) x = rt1 ; <span class="keyword">else</span> x = rt2 ; </span><br><span class="line">    <span class="keyword">if</span> (!x)&#123;</span><br><span class="line">        x = r ; </span><br><span class="line">        <span class="keyword">if</span> (In[r] == <span class="string">'x'</span>) op[x] = <span class="string">'X'</span>, val[x] = <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">else</span> op[x] = <span class="string">'?'</span>, <span class="built_in">sscanf</span>(In + l, <span class="string">"%lld"</span>, &amp;val[x]), val[x] %= Mod ;</span><br><span class="line">        L[x] = R[x] = <span class="number">0</span> ; <span class="keyword">return</span> x ; </span><br><span class="line">    &#125;</span><br><span class="line">    op[x] = In[x], L[x] = build(l, x - <span class="number">1</span>), R[x] = build(x + <span class="number">1</span>, r) ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll y[MAXM], dy[MAXM] ; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p) ;</span><br><span class="line">        a = mul(a, a, p) ; b &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node res ; </span><br><span class="line">    <span class="keyword">if</span> (!L[x] &amp;&amp; !R[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (op[x] == <span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">       					res.y[i] = v % mod[i], res.dy[i] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = val[x] % mod[i], res.dy[i] = <span class="number">0</span> ;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node l = dp(L[x]), r = dp(R[x]) ; </span><br><span class="line">        <span class="keyword">if</span> (op[x] == <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = add(l.y[i], r.y[i], mod[i]), </span><br><span class="line">                res.dy[i] = add(l.dy[i], r.dy[i], mod[i]) ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[x] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = mul(l.y[i], r.y[i], mod[i]), </span><br><span class="line">                res.dy[i] = add(mul(l.dy[i], r.y[i], mod[i]), mul(l.y[i], r.dy[i], mod[i]), mod[i]) ; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rr ll calc ;</span><br><span class="line">            res.y[n] = res.dy[n] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i) <span class="comment">// 1</span></span><br><span class="line">                res.y[i] = expow(l.y[i], r.y[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                calc = (!(l.y[i] % mod[i]) &amp;&amp; (r.y[i + <span class="number">1</span>] % mod[i + <span class="number">1</span>] == <span class="number">1</span>)) ?</span><br><span class="line">                 		<span class="number">1</span> : expow(l.y[i], (r.y[i + <span class="number">1</span>] + mod[i + <span class="number">1</span>] - <span class="number">1</span>) % mod[i + <span class="number">1</span>], mod[i]),</span><br><span class="line"> 				res.dy[i] = mul(mul(l.dy[i], r.y[i], mod[i]), calc, mod[i]) ; </span><br><span class="line">          <span class="comment">//calc: 此题认为0^0=1，因此判一下。s</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">return</span> res ; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _prework() ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		In[<span class="number">1</span>] = <span class="string">'('</span>, <span class="built_in">scanf</span>(<span class="string">"%s"</span>, (In + <span class="number">2</span>)) ; </span><br><span class="line">        N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), In[++ N] = <span class="string">')'</span> ;</span><br><span class="line">        Init(), tot = <span class="number">0</span>, root = build(<span class="number">1</span>, N); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v ; Node res = dp(root) ; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, res.dy[<span class="number">1</span>] % Mod, <span class="string">" \n"</span>[i == <span class="number">1</span>]) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有，就是当时自己觉得自己已经理解了怎么操作就开始瞎写，结果就开始疯狂地挂，于是发现了这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平心而论，这两个函数是最不起眼的两个函数……但是对于某些老年OI降智选手确实致命性的打击：<strong>这两个函数不是凭空存在的，是为了配合扩展欧拉定理的</strong>！</p>
<p>基本形式大概就是：</p>
<script type="math/tex; mode=display">n^k\equiv \begin{matrix} \qquad\ n^{[k\ \ mod \ \ \varphi(m)]+\varphi(m)} \   \ (k\geq \varphi(m))\\\ n^k \qquad\ (k<\varphi(m)) \end{matrix}  \qquad\  (mod \ \ m)</script><p>也就是说最后的$+p$是必要的= = 这也是很佛。。</p>
<hr>
<p>然后就是我当时还奇怪为什么兔队写的这么快，结果写上一篇文章时发现原来是自己的复杂度写假了，如果按上文中的写，复杂度应该是$O(q|S|\log|S|\log^2p)$。</p>
<p>于是为了优化掉这个log我们需要写一遍后缀表达式版的求导= = </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> ll y[MAXM], dy[MAXM] ; &#125;;</span><br><span class="line"><span class="keyword">char</span> stk[MAXM] ; Node Ans[MAXN] ; <span class="keyword">int</span> ans, i, j, tp, pt ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN], op[MAXN], res[MAXN] ; <span class="keyword">int</span> T, N, L, mod[MAXM], n ; ll val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i * i &lt;= x ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i))&#123;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (!(x % i)) x /= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ret = ret / x * (x - <span class="number">1</span>) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _prework()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mod ; i &gt; <span class="number">1</span> ; i = phi(i))</span><br><span class="line">        mod[++ n] = i ; mod[++ n] = <span class="number">1</span>, mod[++ n] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll p)</span></span>&#123;</span><br><span class="line">    rr ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p) ;</span><br><span class="line">        a = mul(a, a, p) ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'+'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'*'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'^'</span>)  <span class="keyword">return</span> <span class="number">4</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> calc(a) &gt;= calc(b) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _prework() ; <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            ll ret = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(In[i]))&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(In[i]))</span><br><span class="line">                    ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + In[i] - <span class="string">'0'</span>, ++ i ;</span><br><span class="line">                i --, val[++ L] = ret, res[L] = <span class="string">'N'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'x'</span>) val[++ L] = <span class="number">1</span>, res[L] = <span class="string">'X'</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = In[i] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (stk[tp] != <span class="string">'('</span>)</span><br><span class="line">                    res[++ L] = stk[tp --] ;</span><br><span class="line">                tp -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (tp &amp;&amp; Comp(stk[tp], In[i]))</span><br><span class="line">                    res[++ L] = stk[tp --] ; stk[++ tp] = In[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tp) res[++ L] = stk[tp --] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= <span class="number">2</span> ; ++ o)&#123;</span><br><span class="line">            rr <span class="keyword">int</span> v ; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v) ;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= L ; ++ j)&#123;</span><br><span class="line">                rr Node ret ;</span><br><span class="line">                <span class="keyword">if</span> (!calc(res[j])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (res[j] == <span class="string">'X'</span>)</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                            ret.y[i] = v % mod[i], ret.dy[i] = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                            ret.y[i] = val[j] % mod[i], ret.dy[i] = <span class="number">0</span> ;</span><br><span class="line">                    Ans[++ pt] = ret ; <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                rr Node p1 = Ans[pt --] ; rr Node p2 = Ans[pt --] ; </span><br><span class="line">                <span class="keyword">if</span> (res[j] == <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                        ret.y[i] = add(p1.y[i], p2.y[i], mod[i]),</span><br><span class="line">                        ret.dy[i] = add(p1.dy[i], p2.dy[i], mod[i]) ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res[j] == <span class="string">'*'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                        ret.y[i] = mul(p1.y[i], p2.y[i], mod[i]),</span><br><span class="line">                        ret.dy[i] = add(mul(p1.dy[i], p2.y[i], mod[i]), mul(p1.y[i], p2.dy[i], mod[i]), mod[i]) ;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rr ll calcc ; swap(p1, p2) ;</span><br><span class="line">                    ret.y[n] = ret.dy[n] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i) <span class="comment">// 1</span></span><br><span class="line">                        ret.y[i] = expow(p1.y[i], p2.y[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                        calcc = (!(p1.y[i] % mod[i]) &amp;&amp; (p2.y[i + <span class="number">1</span>] % mod[i + <span class="number">1</span>] == <span class="number">1</span>)) ?</span><br><span class="line">                                <span class="number">1</span> : expow(p1.y[i], (p2.y[i + <span class="number">1</span>] + mod[i + <span class="number">1</span>] - <span class="number">1</span>) % mod[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                        ret.dy[i] = mul(mul(p1.dy[i], p2.y[i], mod[i]), calcc, mod[i]) ;</span><br><span class="line">                &#125;</span><br><span class="line">                Ans[++ pt] = ret ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[pt].dy[<span class="number">1</span>] % Mod), pt -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        L = <span class="number">0</span>, <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完我才发现我的大常数是救不了的了，兔爷写的60ms，我写的1120ms，这tm20倍的常数宛如写了$\rm{|S|\log|S|}$……不过说会话比建树的快了些。</p>
<p>看了看题解似乎应该是兔爷多写了一层欧拉展开，于是又消掉一个log = =</p>
<blockquote>
<p>$O(q|S|\log^2 p)$ <img src="1.jpg" alt></p>
<p>$O(q|S|\log |S| log^2 p)$ <img src="2.jpg" alt></p>
</blockquote>
<p>卡常真是荼毒人名= =</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】表达式树入门</title>
    <url>/2019/07/26/biaodashishu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>严格来讲，我们所谈的<strong>表达式树</strong>是对一个计算式的中缀表达式所构造的<strong>二叉树形结构</strong>，在求解表达式的值时十分的方便。</p>
<p>对于一棵表达式树，其中每一个节点都表示一个字符，特别的是<strong>数值只会是叶子节点</strong>，这些数值由其祖先节点——均是“计算符号”的节点连接起来。而计算方式则是：</p>
<script type="math/tex; mode=display">
\rm{S_u=calc(S_{v_1}, S_{v_2})}</script><p>其中u为当前节点，calc函数的计算方式取决于点$u$上的符号。</p>
<p>从而只需要递归计算即可。</p>
<a id="more"></a>
<h1 id="1-递归建树"><a href="#1-递归建树" class="headerlink" title="$1$ 递归建树"></a>$1$ 递归建树</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == <span class="string">'+'</span> || x == <span class="string">'-'</span> || x == <span class="string">'*'</span> || x == <span class="string">'/'</span> || x == <span class="string">'^'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (brac[l] == r) <span class="keyword">return</span> build(l + <span class="number">1</span>, r - <span class="number">1</span>) ; </span><br><span class="line">	rr <span class="keyword">int</span> rt = <span class="number">0</span>, ls = <span class="number">0</span>, rs = <span class="number">0</span>, x = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> k = l ; k &lt;= r ; ++ k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[k] == <span class="string">'('</span>) k = brac[k] + <span class="number">1</span> ; <span class="keyword">if</span> (k &gt; r) <span class="keyword">break</span> ; </span><br><span class="line">		<span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; rt = k ; <span class="keyword">break</span> ; &#125;<span class="comment">//!</span></span><br><span class="line">		<span class="keyword">if</span> (In[k] == <span class="string">'*'</span> || In[k] == <span class="string">'/'</span>) ls = k ; <span class="keyword">if</span> (In[k] == <span class="string">'^'</span> &amp;&amp; !rs) rs = k ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rt) x = rt ; <span class="keyword">else</span> <span class="keyword">if</span> (ls) x = ls ; <span class="keyword">else</span> x = rs ; </span><br><span class="line">	<span class="keyword">if</span> (!x) &#123; </span><br><span class="line">		x = r, op[x] = <span class="string">'?'</span> ; </span><br><span class="line">		<span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[x]) ; </span><br><span class="line">		val[x] %= Mod ; <span class="keyword">return</span> x ; </span><br><span class="line">	&#125;</span><br><span class="line">	op[x] = In[x] ; L[x] = build(l, x - <span class="number">1</span>), R[x] = build(x + <span class="number">1</span>, r) ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	rr <span class="keyword">int</span> res = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">		(a *= a) %= Mod ; b &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ; </span><br><span class="line">	rr <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'-'</span>) res = (l - r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'/'</span>) res = l * expow(r, Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'^'</span>) res = expow(l ,r) ; <span class="keyword">return</span> res ; 	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; In + <span class="number">1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">	&#125;</span><br><span class="line">	root = build(<span class="number">1</span>, N), <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也没啥好说的，这道题是NOIP2013普及组的<a href="https://www.luogu.org/problem/P1981" target="_blank" rel="noopener">表达式求值</a>。然后建树的时候需要注意优先级……</p>
<p>但其实这个地方想说的不是这个东西，而是一个复杂度的问题。喜闻乐见的这个玩意儿的复杂度是$O(n^2)$的，但是在我加了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; </span><br><span class="line">  rt = k ; <span class="keyword">break</span> ; </span><br><span class="line">&#125;<span class="comment">//!</span></span><br></pre></td></tr></table></figure>
<p>中的break之后，他就可以在400ms内的龟速把1e6的数据给艹过去了……也算是很迷</p>
<p>但听说似乎真正$O(|S|)$的建树其实只需要预处理一下每个位置之前最近的符号就好……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Code[r][<span class="number">1</span>] &gt;= l) rt = Code[r][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Code[r][<span class="number">2</span>] &gt;= l) rt = Code[r][<span class="number">2</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        op[rt] = In[rt], </span><br><span class="line">      	L[rt] = build(l, rt - <span class="number">1</span>), </span><br><span class="line">      	R[rt] = build(rt + <span class="number">1</span>, r) ; <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    op[r] = <span class="string">'?'</span>, <span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[r]) ; val[r] %= Mod ; <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ;</span><br><span class="line">    <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'+'</span>) Add = i ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'*'</span>) Mul = i ;</span><br><span class="line">        Code[i][<span class="number">1</span>] = Add, Code[i][<span class="number">2</span>] = Mul ;</span><br><span class="line">    &#125;</span><br><span class="line">    root = build(<span class="number">1</span>, N) ; <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎就是线性的了（flag * 1）。然而测了一下速发现：</p>
<blockquote>
<p>$n^2$写法 <img src="1.jpg" alt> </p>
<p>$|S|$写法 <img src="2.jpg" alt></p>
</blockquote>
<p>似乎并没有什么区别……于是这就很佛了。。（fo * 1）</p>
<h1 id="2-用栈建树"><a href="#2-用栈建树" class="headerlink" title="$2$ 用栈建树"></a>$2$ 用栈建树</h1><p>这其实是在UOJ群里面<code>iki9</code>推荐的方式，我看到似乎兔队也是这么建的，于是就打算学一学。</p>
<p>然后其实也是蛮简单的，大概就是先用$|S|$的时间转化成后缀表达式，然后再用$|S|$的时间求出来。</p>
<p>转后缀表达式也挺简单，就是注意一定要是先计算优先级高的、后计算低的，所以我们需要一个优先级单调递减的栈来保存。</p>
<p>计算的时候用一个栈记录，每遇到一个计算符就弹出最顶上的俩数计算。因为后缀表达式的完备性所以一定是可行的。</p>
<p>好了我去写了……</p>
<hr>
<p>……这踏马是什么操作啊喂…先贴代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; stk ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; Ans ; <span class="keyword">int</span> ans, i ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN], op[MAXN], res[MAXN] ; <span class="keyword">int</span> N, L, val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'+'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'-'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'*'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'/'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'^'</span>)  <span class="keyword">return</span> <span class="number">4</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(a) &gt;= calc(b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(In[i]))&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(In[i]))</span><br><span class="line">                ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + In[i] - <span class="string">'0'</span>, ++ i ;</span><br><span class="line">            i --, val[++ L] = ret, res[L] = <span class="string">'N'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk.push(In[i]) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.top() != <span class="string">'('</span>)</span><br><span class="line">                res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">            stk.pop() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; Comp(stk.top(), In[i]))</span><br><span class="line">                res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">            stk.push(In[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!calc(res[i])) &#123; Ans.push(val[i]) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = Ans.top() ; Ans.pop() ; <span class="keyword">int</span> p2 = Ans.top() ; Ans.pop() ;</span><br><span class="line">        <span class="keyword">if</span> (calc(res[i]) == <span class="number">2</span>) &#123;<span class="keyword">int</span> p = (p1 + p2) % Mod ; Ans.push(p) ; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (calc(res[i]) == <span class="number">3</span>) &#123;<span class="keyword">int</span> p = (p1 * p2) % Mod ; Ans.push(p) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans.top() % Mod &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再贴结果：</p>
<p><img src="3.png" alt></p>
<p>？？？</p>
<p>思考了思考，似乎刚才递归那种写法不是$O(|S |)$的？嗯，很有道理，那玩意儿复杂度应该是$O(|S|\log |S|)$的啊，毕竟tm终究是棵完全二叉树……</p>
<p>我佛了</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>语义树</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>随想九 · 意义</title>
    <url>/2019/07/18/Nine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Let’s say sunshine for everyone 人们说生活总是充满阳光<br>But as far as I can remember 但在我的记忆中<br>We’ve been migratory animals 我们一直只是如野兽般流浪<br>Living under changing weather 四季变换，我们如常<br>Someday we will foresee obstacles 总有一天，我们会看见那些困难阻碍<br>Through the blizzard through the blizzard 在那片风雪之中，在那片风雪之后<br>Today we will sell our uniform 如今我们将曾经的校服变卖<br>Live together live together 一同离去，一同启程</p>
</blockquote>

        <div id="aplayer-vqzKciTI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-vqzKciTI"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "Obstacles",
              author: "Syd Matters",
              url: "Obstacles.flac",
              pic: "/2019/07/18/Nine/lis.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>最近暑假了，一直颓的很。并不想说太多，每天晚上昏睡之际眼前的火苗会在第二天早上太阳升起时熄灭，似乎也不再是什么稀罕事。不过倒是也有所收获。先是去B站看<code>C菌</code>的《奇异人生二·实况》，才知道有《Life is Strange》这么一款游戏，于是索性只看了《二》，自己从steam上买了第一部，津津有味地玩了起来。奈何CPU是1.8GHz的，仅达到了最低配的要求，故画面体验有些差，但倒也无妨。但或许游戏时长有点多？别人都说“15小时通关”，似乎我也是在拽平均分了。</p>
<p><img src="1.png" alt></p>
<p>奇怪的是一直没有官方的的汉化包（但是2和续作都有汉化包，只有1官方没发布），于是只能凭很渣的英语阅读能力来玩，中间自然也是和看《哈利波特》一样，有许多细节是看不懂的，但是95%+还是没有问题。可惜玩完之后，毕竟是12 P.M.了，不知是真的出于困倦，亦或是别的原因，我并没有什么特别的感觉，大概就是“啊，结束了”便没了后文。</p>
<p>之后的一天半<strong>全</strong>用来看韩剧《秘密森林》，豆瓣上9分+的悬疑力作，确实不错；但是看完到现在似乎已经过了10个小时多，自己却一点深刻的感觉也没有，仅仅也是“啊，结束了”。我逼自己在脑海里构思出过几个结论，诸如“剧情好，情节紧凑”、“主角们身上的品质值得学习”之类的老套的东西，毕竟自己不喜欢接受“我浪费了时间”这种事实。</p>
<p>但是我从QQ音乐上（我一直不用网易云）搜到了Life is Strange的soundtrack，听了听最后选择Cloye后的BGM，或者说谢场曲，<code>Obstacles</code>，渐渐地有了感觉。这时我才意识到，或许这真是一款伟大的游戏。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>到现在我才发现，一个真正的爱的东西，或许一张照片就能表达，不许要各个角度的拍摄、点缀——此感慨大概是来源于我本来想把自己很有感触的片段啊、镜头啊、台词啊都整理出来，丢到博客上封存起来。但碍于自己实力不够又太懒，最终决定放弃了。当然，或许这个感慨也仅是一个心理安慰而已吧。</p>
<p>不知怎的，最近无论做什么事都有种“却道天凉好个秋”的感觉。纵然坐在屏幕前，单曲循环着<code>Obstacles</code>的我心中不断闪回无数个游戏中的镜头，我从来没意识到的感动、满足在心中游动，我却只想淡淡地描述它，仿佛真的有什么东西一说出口，就会化作烟云飘飞走，再也不回。</p>
<p>最后我选择了Cloye，毫不犹豫地，毁掉了小镇。大概是太感性了吧，看着C菌玩出的拯救小镇的结局最后，棺材上翩翩落下的那只蓝蝴蝶和最后的Max的笑，我感到一阵目眩。经过了23个小时的奋战，我仿佛已经和Max融为了一体：我会感叹超能力滥用的危害，我看着Cloye开心的样子自己也会喜不自胜，看到游戏中周围的场景也恨不得赶紧拍一张，也十分想拥有和Max一样的书画方式，句里话间贯穿着充满浓郁美国西部风味的笑话，但却永远不失简约和得体。我感叹自己身为Max所经历的一切，不断变换的结局，不断迎来的挑战，直到最后才发现可以改变事实的自己有多么无力，才发现Cloye活着才是我唯一想要的。无论最后Cloye是否为此牺牲了，我都会很感慨和Cloye在一起厮混、感慨我成功救下了Kate，感慨自己房间的小清新和Cloye房间的独特，感慨Max和Cloye的那种爱情和友情不断相互叠加，创造出的那种至美至真的情感。</p>
<p>整体上来看，这应该是个悲伤的故事——无论选哪种结局。但是或许也只有悲剧会把生活中的美好撕碎给人看，之后人们才会从那些碎片里面重新拾起向前走的动力吧。</p>
<p>我很想和Max和Cloye做朋友。那一定是一件很幸福的事情吧。</p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>从现在开始，我开始很惧怕看一部新剧或者玩一部新的游戏。我害怕情节会太妙、人物会太精致导致我沉浸其中无法自拔，正如我看《哈利波特》、我看《言叶之庭》、我玩《生化危机7》、我玩Life is Strange一样，要缓好几天才能缓过来。我会泄气为什么我的生活没有那么多缤纷的元素——没有魔法、没有值得我守护的东西、没有改变时间的超能力、没有跨越鸿沟的极致爱情；我会感慨为什么我没有主人公那种超凡脱俗的品质、惊人的意志或者优秀的人际关系。仿佛每多一部文学作品，就如同我心底黑暗的夜空多了一颗星点，但我却只能蜷缩在远处黑暗的角落，瑟瑟地发着抖，看着天空中的光芒我竟会觉得刺眼，觉得避之不及。不知道什么时候，我连欣赏美好的能力都没了。</p>
<p>确实，虽然上文提到的<code>Obstacles</code>这支歌确实是Life is Strange在我心中最完美的诠释，但是我毫不留情面地把它移出了我的曲库。不在于别的，只是因为我不想再一听某首歌就有想哭的冲动，不想再听一首歌就感到自己有多么孤独。rqy口中的“早在心里哭过了”或许就是这种感觉吧。</p>
<p>我又能做什么呢？无论周围有多少人跟我成天开玩笑啊、斗嘴啊，我真的把他们打心底当作过理解我的人吗？我感觉自己每天就如同一座空壳一样，行尸走肉般地担心着一切。大概我是很难把心敞开给谁的把，或者即使我敞开了我也不认为自己敞开了吧；以此为理由说“大概是因为没有另一半造成的”，也不过是病急乱投医吧。我就仿佛一只迷途的小船，永远不知道自己的下一站在哪里。-</p>
<p>其实说到底，还是我根本不知道如何去生活。之前积累的浮躁让我不知道该如何面对平常人的生活，来到高中之后我才知道“哦，原来努力才是硬道理”。或许是rqy太强了，强到他的光芒洒在我眼前时会让我有种我也可以轻松到达那个高度的错觉——整个高一仿佛只有最后一星期不是浮躁的。</p>
<p>或许，我一直是个很好的$\rm{Admirator}$  (羡慕者)而不是一个好的$\rm{Doer}$(实践者)吧。</p>
<h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><p>我一直想知道自己现在到底为何而活，活的意义又是什么。</p>
<p>放眼四周全是烟雾弥漫，我畏惧了。</p>
<p>或许只要我强一些，在文化课上、或者在奥赛上取得了骄人的成绩我就可以全身心投入其中一者了。但奈何实力不足，两者都不是我的拿手项。我开始慌了。之前的岁月仿佛都是虚度，自己去年多么弱，今年似乎也并没有什么实质的变化。我开始慌了。</p>
<p>大家都说“不能功利地搞OI啊”，周围mcfx、rqy的成功也都反复论证了这一点。但是我，我…对我而言，似乎没有比这个更高的精神动力了啊。周围异样的目光接踵而来，因为我不是强者，不可能说出什么“走自己的路，让别人说去吧”的豪言壮语——按着传统的步调都不能取胜，自己的步调大概只是飞蛾扑火吧。</p>
<p>我似乎觉得有些奇怪，大概自己本来就不是搞OI的人，或许是个文学家更合适；但是看到期末考试惨不忍睹的语文分数，我又迷茫了；大概自己本来就没有多努力，但是我感觉今年省选前自己已经够努力了啊，或许只是方向错了——但是方向又在哪呢，我又迷茫了。</p>
<p>似乎天地之大，只有我一个人整日沉浸在迷茫之中无法脱身：人与人真是不一样啊。有些人就是可以无问西东、敢想敢干；我则只会是一个杂鱼，睡死在漫无边际的冬日。</p>
<p>每到这个时候，我都好想逃跑，我想跑到Max和Cloye的那个小镇，和他们一起无忧无虑地活着，没有文化课的压力，没有升学的压力，没有豪言壮语的压力，没有OI的压力，就只是简单地活着……最重要的，我可以不思考我为何而活。</p>
<p>当然，以上都是一个高中生的无病呻吟而已。说到底，我还是没有任何勇气的蝼蚁，不知道该怎样直面生活的痛击，不知道如何自在地活，敏感，而颓废。</p>
<blockquote>
<p>除了勇气，我什么都不缺。</p>
</blockquote>
<p>Life is Strange，Max，Cloye，寄托着的，是我遥不可及的一个梦啊。</p>
<p><img src="2.png" alt></p>
<h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><p>终于我要重新上路了，过去的快乐我想抹去，过去的心酸我想埋葬。眼泪垂青过的土地是翻上来的新泥，在心里死了好几次也必须重生。</p>
<p>至于文学作品，我能想到的最好的结束便是如下：</p>
<blockquote>
<p>或许，<br>每一份精致的艺术作品都是一个有条不紊的世界；<br>有关那个世界的回忆，不如折叠起来，就留在那个世界吧。</p>
</blockquote>
<p>是啊，Max和Cloye的故事，就留给阿卡迪亚湾和他们即将抵达的西雅图吧；秋月孝雄和雪野百香里的故事就留在那个古色古香的雨亭吧。一切的一切都是碎片，在时空里面穿行，倏而消失不见，倏而又出现在我眼前。铭记和沉沦没有意义；这个世界的一切，无论多么无聊与不可期待，明天太阳升起时，便还要继续。</p>
<p>意义？似乎意义这东西本身就是没有意义的。理解生命、理解生活反而是某种屈从，而真正的英雄则是命运的斗士——就好像JO5里面的主角们，坚定地举起反抗命运的大旗。</p>
<p>明日是否如同今日一样沉沦？我不知道。我只知道把握住下一秒就足够了。之前的生活的每一帧仿佛都像是飘在空中的泡影而已，洗刷着存在于虚妄中的记忆，一次一次，如同枷锁一样阻遏着我的前进。</p>
<p>所以，请君勿言什么明天更好之类的P话了，在绝望中求生才是人生的常态。就如同从峭壁中生出的兰花，挤落一捻石尘都是成功。</p>
<hr>
<p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">$Link$</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做一</title>
    <url>/2019/07/11/old-noip/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先简介一下这篇文章的来历……</p>
<p>此时的我正在瞎翻之前做过的、看起来还可以的NOIP水题，觉得哪个地方值得注意就整了下来。然而实际上我是只想整理“泛做二”里的题目。不过一想似乎自己基础不扎实，于是才有了这篇水文。</p>
<a id="more"></a>
<h1 id="1-2013B-火柴排队"><a href="#1-2013B-火柴排队" class="headerlink" title="$1~2013B$ 火柴排队"></a>$1~2013B$ 火柴排队</h1><p><a href="https://www.luogu.org/problem/P1966" target="_blank" rel="noopener">Link</a></p>
<p>这真是个水题。但是之前做的时候没意识到一些问题，前几天翻来看看又把这个题秒了一遍。</p>
<p>观察整个式子，我们拆开之后就发现是在最小化$-\sum a_ib_i$，也就是最大化$\sum a_ib_i$。然后根据选修4-5里面的<strong>排序不等式</strong>，逆序和&lt;乱序和&lt;顺序和，直接找逆序对就好。</p>
<p><del>偷偷学数学真有用啊/kk</del></p>
<h1 id="2-2014C-飞扬的小鸟"><a href="#2-2014C-飞扬的小鸟" class="headerlink" title="$2 ~2014C$ 飞扬的小鸟"></a>$2 ~2014C$ 飞扬的小鸟</h1><p><a href="https://www.luogu.org/problem/P1941" target="_blank" rel="noopener">Link</a></p>
<p>……一道gou题。</p>
<p>当时全天下都知道状态$f_{i,j}$就我不会转移…背包其实挺显然的，上升的时候做完全背包，注意由于即使🐦在天花板里面($h= m$)时也可以跳，所以多转移几次， 且注意既可以从i-1转移过来，也可以从现在的i转移过来；下降的时候做反向值域的01背包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; ans = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;up[i], &amp;dw[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      Wd[i][<span class="number">0</span>] = <span class="number">-1</span>, Wd[i][<span class="number">1</span>] = M + <span class="number">1</span> ; <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), S[k] = <span class="number">1</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Wd[k][<span class="number">0</span>], &amp;Wd[k][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">/*for (i = 2 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = Wd[i][0] + 1 ; j &lt; Wd[i][1] ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i - 1][j + dw[i]] ;</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt;= (j - Wd[i - 1][0] - 1) / up[i] ; ++ k)</span></span><br><span class="line"><span class="comment">                dp[i][j] = min(dp[i - 1][j - k * up[i]] + k, dp[i][j]) ;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = up[i] + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j - up[i]], dp[i][j - up[i]]) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = M + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j) </span><br><span class="line">          	dp[i][M] = min(dp[i][M], dp[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M - dw[i] ; j ++) </span><br><span class="line">          	dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j + dw[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= Wd[i][<span class="number">0</span>] ; ++ j) dp[i][j] = Inf ; </span><br><span class="line">      	<span class="keyword">for</span> (j = Wd[i][<span class="number">1</span>] ; j &lt;= M ; j ++) dp[i][j] = Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[N][i]) ; </span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, <span class="number">1</span>, ans),<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) S[i] = S[i - <span class="number">1</span>] + S[i] ; l = <span class="number">1</span>, r = N, p ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = Inf ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[mid][i]) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) l = mid + <span class="number">1</span>, p = mid ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; S[p] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-2001C-统计单词数"><a href="#3-2001C-统计单词数" class="headerlink" title="$3~2001C$ 统计单词数"></a>$3~2001C$ 统计单词数</h1><p><a href="https://www.luogu.org/problem/P1026" target="_blank" rel="noopener">$Link$</a> 一道很水的DP，难点（如果可以称之为难的话）在于判断。然后此处用的是哈希，判断的时候就瞎判就好了（雾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p ; </span><br><span class="line"><span class="keyword">char</span> D[MAXLEN][<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">const</span> UN LL base = <span class="number">131</span> ;</span><br><span class="line">LL Hash[MAXLEN][MAXLEN], H[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">stack</span>&lt; pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s, s2 ;</span><br><span class="line"><span class="keyword">const</span> UN LL Mod = <span class="number">192183781721L</span>L ;</span><br><span class="line"><span class="keyword">int</span> dp[MAXLEN][<span class="number">50</span>], Len, Length[<span class="number">10</span>], o ;</span><br><span class="line"><span class="keyword">int</span> P, M, K, i, j, k, di, dj ; <span class="keyword">char</span> S[MAXLEN] ;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Hashh</span><span class="params">(<span class="keyword">int</span> Mark)</span></span>&#123;</span><br><span class="line">	UN LL res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!Mark) &#123;</span><br><span class="line">		<span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">			res = (res * base + S[k]) % Mod ; </span><br><span class="line">		<span class="keyword">return</span> res ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= Length[Mark] ; ++k)</span><br><span class="line">		res = (res * base + D[Mark][k]) % Mod ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	LL res[<span class="number">7</span>] ;</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">	<span class="keyword">for</span> (di = <span class="number">1</span>; di &lt;= M ; ++ di)</span><br><span class="line">		<span class="keyword">for</span> (dj = x ; dj &lt;= y - Length[di] ; ++ dj)</span><br><span class="line">			<span class="keyword">if</span> (Hash[dj][dj + Length[di]] == H[di]) ++ res[di] ;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		p = s.top() ;</span><br><span class="line">		res[p.first] &gt; res[p.second] ? res[p.second] : res[p.first] = <span class="number">0</span> ; </span><br><span class="line">		s.pop(), s2.push(p) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s2.empty()) s.push(s2.top()), s2.pop() ;</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">1</span>] + res[<span class="number">2</span>] + res[<span class="number">3</span>] + res[<span class="number">4</span>] + res[<span class="number">5</span>] + res[<span class="number">6</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; K ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; P ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%20s"</span>, S + i * <span class="number">20</span>) ;	<span class="built_in">cin</span> &gt;&gt; M ; Len = <span class="built_in">strlen</span>(S) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, D[i]), Length[i] = <span class="built_in">strlen</span>(D[i]) - <span class="number">1</span>, H[i] = Hashh(i) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">for</span> (di = <span class="number">0</span> ; di &lt;= min(Length[j], Length[i]) ; ++ di)</span><br><span class="line">				<span class="keyword">if</span> (D[j][di] != D[i][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) s.push(&#123;i, j&#125;), ++ o ;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j) </span><br><span class="line">			Hash[j][i] = Hashh(<span class="number">0</span>) ;</span><br><span class="line">	<span class="comment">/*for (i = 0 ; i &lt; Len ; ++ i) </span></span><br><span class="line"><span class="comment">		for (j = 0 ; j &lt; i ; ++ j) </span></span><br><span class="line"><span class="comment">			printf("%d%c", Sum(j, i)," \n"[j == i - 1]) ;*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= K ; ++ k)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (j = k - <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">				dp[i][k] = max(dp[i][k], dp[max(<span class="number">0</span>, j - <span class="number">1</span>)][k - <span class="number">1</span>] + Sum(j, i)) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[Len - <span class="number">1</span>][K] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-2005B-过河"><a href="#4-2005B-过河" class="headerlink" title="$4~2005B$ 过河"></a>$4~2005B$ 过河</h1><p><a href="https://www.luogu.org/problem/P1052" target="_blank" rel="noopener">$Link$</a></p>
<p>也是一道很水的DP。整理这个题的原因是因为好久之前的当时做这题时用了一种诡异的做法，即通过对$\sqrt{1e9}$取模进行压缩，但是这显然不对因为1：我的写法没有处理mod之后位置相同的情况；再者转移过程也十分地不服责任：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mod=<span class="number">32501</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">bool</span> pos[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,l,r,m,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x; <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		pos[x%mod]=<span class="number">1</span>;	<span class="keyword">if</span>(l==r&amp;&amp;x%l==<span class="number">0</span>)cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;	<span class="built_in">cout</span>&lt;&lt;cnt; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++) f[i]=MAXN;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++)</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k=i%mod;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=j)f[i]=min(f[i],f[i-j]+pos[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[mod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但问题是，它过了，这就很迷。仔细想想，似乎可能是因为石头数量太小了，只有100，所以随机丢到空间里去期望意义上每$1e7$会有一块石头，且mod之后位于同一个位置的概率的相反数是$32501$，所以很难有这种数据出现……换句话说，数据水死了。</p>
<p>然而真正的做法应该是“2520缩”，意思就是因为题目中的 s~t 的取值范围是 1~10，所以取$lcm(1,2,..,10)=2520$是可行的。</p>
<h1 id="5-2009B-Hankson的趣味题"><a href="#5-2009B-Hankson的趣味题" class="headerlink" title="$5~2009B$ Hankson的趣味题"></a>$5~2009B$ Hankson的趣味题</h1><p><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">$Link$</a></p>
<p>整这个题只是因为情怀……</p>
<p>遥不可及的过去啊……<a href="https://pks-loving.blog.luogu.org/solution-p1072" target="_blank" rel="noopener">Solution</a></p>
<h1 id="6-2004D-虫食算"><a href="#6-2004D-虫食算" class="headerlink" title="$6~2004D$ 虫食算"></a>$6~2004D$ 虫食算</h1><p><a href="https://www.luogu.org/problem/P1092" target="_blank" rel="noopener">$Link$</a></p>
<p>整这个题更是因为情怀了……</p>
<p>当时是何时？不记得是末冬还是暑假，只记得我十分开心地去高中部培训，吃早饭之前跟rqy瞎聊，聊什么“是不是只要我发明出可以处理负权边的Dijkstra就可以上清华了”，不自觉地聊到了这道题。嗯…场景什么的都历历在目，尤其是餐厅东边洒落的白色的阳光，一直在我的记忆中闪亮…</p>
<p>可惜我不是当年那个我了，rqy也不是当年那个rqy了，大家都在迈着自己的步子踏实地前进，终于还是会分道扬镳吧……</p>
<p>诶诶我在干什么，qaq，学习，学习……</p>
<p>暴力就是枚举全排列，但显然只有30pts。 于是考虑一个可行性剪枝，其实就是每次dfs刚开始先check一遍合不合法。但是整理这个题的目的也不在于此，而在于其中的<code>pos</code>数组，其实就是用来记录从低位到高位每个未知数的出现顺序的。那么实际上这也是一个优秀的剪枝，因为在dfs里面我们可以根据此对靠近低位的未知数先赋值、先判断（第一个剪枝）。</p>
<p>所以大概就是可行性剪枝和最优性剪枝相辅相成的结果，比较巧妙。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> _Char ; <span class="keyword">int</span> pos[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Ans[MAX] ; <span class="keyword">bool</span> mark[MAX] ;</span><br><span class="line"><span class="keyword">int</span> N, A[MAX], B[MAX], C[MAX], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i) <span class="built_in">cout</span> &lt;&lt; Ans[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span>((NA + NB + X) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        X = (NA + NB + X) / N ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Speed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ans[A[<span class="number">0</span>]] + Ans[B[<span class="number">0</span>]] &gt;= N) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span> (NA == <span class="number">-1</span> || NB == <span class="number">-1</span> || NC == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((NA + NB) % N != NC &amp;&amp; (NA + NB + <span class="number">1</span>) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Speed()) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (sum == N + <span class="number">1</span>)&#123;<span class="keyword">if</span> (Judge()) Print() ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span>(!mark[i])&#123;</span><br><span class="line">            Ans[pos[sum]] = i, mark[i] = <span class="number">1</span> ;</span><br><span class="line">            dfs(sum + <span class="number">1</span>) ;</span><br><span class="line">            Ans[pos[sum]] = <span class="number">-1</span>, mark[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work_pos</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!mark[x])  mark[x] = <span class="number">1</span>,  pos[++ tot] = x ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    fill(Ans, Ans + MAX + <span class="number">2</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; A[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; B[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; C[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i) </span><br><span class="line">      work_pos(A[i]), work_pos(B[i]), work_pos(C[i]) ;</span><br><span class="line">    fill(mark, mark + MAX + <span class="number">2</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><blockquote>
<p>遥望扬州满地雪，不知已是惊蛰节。</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>NOIP系列</tag>
        <tag>数学/不等式</tag>
        <tag>动态规划/背包模型</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做二</title>
    <url>/2019/07/11/Old-NOIP2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事实上我不久前才发现原来NOIP里面的一些题是很好的……</p>
<p>然后大概接下来整理的都是些我认为挺有难度的吧qwq</p>
<p>但是感觉似乎这么好的题放在一块有点憋屈……于是就缩短了篇幅增多了篇目</p>
<a id="more"></a>
<h1 id="1-2011F-观光公交"><a href="#1-2011F-观光公交" class="headerlink" title="$1~2011F$ 观光公交"></a>$1~2011F$ 观光公交</h1><p><a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">$Link$</a></p>
<p>这题我还是去年的3月19号做的，显然是抄的题解，于是现在又要重做一遍/sad</p>
<p>那么其实贪心的思路很简单，找最多人经过的那条路。由于$n$是$1000$所以直接$O(nk)$的暴力就很稳了。然后注意消除后效性——大体上就是如果你这一站用了什么“氮气加速”，结果下一站还得在那等着，就没有任何作用了，这种情况就<code>gg[i]=i+1</code>，你只能拯救下一站下车的乘客；否则你也可以拯救更多的，就是<code>gg[i]=gg[i+1]</code>，也算是一种状态转移的思想吧。在我看来似乎这是本题唯一的难点了……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,f,t;</span><br><span class="line">&#125;p[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> max_each[<span class="number">100001</span>],sum_max[<span class="number">100001</span>],get[<span class="number">100001</span>],time[<span class="number">100001</span>],gg[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">cin</span>&gt;&gt;time[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;p[i].w&gt;&gt;p[i].f&gt;&gt;p[i].t;</span><br><span class="line">    	max_each[p[i].f] = max(p[i].w,max_each[p[i].f]);</span><br><span class="line">      sum_max[p[i].t]++ ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">			sum_max[i]+=sum_max[i<span class="number">-1</span>];</span><br><span class="line">		get[<span class="number">1</span>]=max_each[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">			get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			ans+=(get[p[i].t]-p[i].w);</span><br><span class="line">		&#125;<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">  	    gg[n]=gg[n<span class="number">-1</span>]=n;</span><br><span class="line">				<span class="keyword">int</span> maxn=<span class="number">0</span>,f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">      	  gg[i]=get[i+<span class="number">1</span>]&lt;=max_each[i+<span class="number">1</span>]?i+<span class="number">1</span>:gg[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        	<span class="keyword">if</span>(sum_max[gg[i]]-sum_max[i]&gt;maxn&amp;&amp;time[i])&#123;</span><br><span class="line">            maxn=sum_max[gg[i]]-sum_max[i];f=i;</span><br><span class="line">        	&#125;</span><br><span class="line">        ans-=maxn;time[f]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>拿什么拯救我当年幼稚的码风啊</del></p>
<h1 id="2-2015C-斗地主"><a href="#2-2015C-斗地主" class="headerlink" title="$2~2015C$ 斗地主"></a>$2~2015C$ 斗地主</h1><p><a href="https://www.luogu.org/problem/P2668" target="_blank" rel="noopener">Link</a></p>
<p>一道喜闻乐见的搜索题。其实蛮简单的，就是每次把能出的牌出一遍就好了，就是调有点难调，在这个时候输出调试法+肉眼查错法比什么<code>gdb</code>好用多了。</p>
<p>以下是整理的细节：</p>
<ul>
<li>至于如何出单牌和对子，只需要每次dfs时每次最后把不能出花的都出了就好，就是这样：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
<pre><code> 反之如果在出单牌/对子的时候再设置回溯——没有必要且严重扩展了状态数。
</code></pre><ul>
<li>还是剪枝，大概就是一个最优性剪枝：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​    可能是因为太套路了我一直记不住= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -- ;</span><br><span class="line">			dfs(m - cnt, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] ++ ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">         cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">     &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">			dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span>  ;</span><br><span class="line">			dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">//炸弹 or 四带二  </span></span><br><span class="line"> 		<span class="keyword">int</span> p[<span class="number">3</span>], tot = <span class="number">0</span>, q[<span class="number">3</span>], cnt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">if</span> (buc[j] &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j != k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (buc[k] &gt;= <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) q[++ cnt] = k ; </span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (buc[k] &amp;&amp; tot &lt; <span class="number">2</span>) p[++ tot] = k ; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;   </span><br><span class="line">			<span class="keyword">if</span> (tot &lt; <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) &#123; buc[j] -= <span class="number">4</span> ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[j] += <span class="number">4</span> ; &#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt; <span class="number">2</span>)  &#123; </span><br><span class="line">        buc[p[<span class="number">2</span>]] --, buc[p[<span class="number">1</span>]] --, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">6</span>, step + <span class="number">1</span>) ; buc[p[<span class="number">2</span>]] ++, buc[p[<span class="number">1</span>]] ++, buc[j] += <span class="number">4</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; </span><br><span class="line">        buc[q[<span class="number">2</span>]] -= <span class="number">2</span>, buc[q[<span class="number">1</span>]] -= <span class="number">2</span>, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">8</span>, step + <span class="number">1</span>) ; buc[q[<span class="number">2</span>]] += <span class="number">2</span>, buc[q[<span class="number">1</span>]] += <span class="number">2</span>, buc[j] += <span class="number">4</span> ; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">// 三带XXX </span></span><br><span class="line">		<span class="keyword">if</span> (buc[j] &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			buc[j] -= <span class="number">3</span> ;</span><br><span class="line">          	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !buc[k] || k == j )  <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -- ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[k] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">13</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( buc[k] &lt;= <span class="number">1</span> || j == k) <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -= <span class="number">2</span> ; dfs(m - <span class="number">5</span>, step + <span class="number">1</span>) ; buc[k] += <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            buc[j] +=<span class="number">3</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) </span><br><span class="line">    <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>= =其实这题最恶心的还是粗心地写错，毕竟那么多函数都是<code>ctrl c</code>+<code>ctrl v</code>的，鬼知道什么地方就崩掉了……</p>
<h1 id="3-2015-text-C-G-斗地主加强版"><a href="#3-2015-text-C-G-斗地主加强版" class="headerlink" title="$3~2015\text{C+/G}$  斗地主加强版"></a>$3~2015\text{C+/G}$  斗地主加强版</h1><p><a href="https://www.luogu.org/problem/P2540" target="_blank" rel="noopener">Link</a></p>
<p>直接粘一份代码过来你甚至可以获得74pts的好成绩= =</p>
<p>其实主要思想就是<strong>拆牌</strong>，原因是假设你又两组三张，一组炸，你的思路是出三次，但实际上只需要两次就可以——把一组三张拆成一单+一对，然后带走只需要两次。</p>
<p>但是我并不想写诡异的剪枝，于是索性根据题解区写了一个DP。即设$dp_{i,j,k,l,o}$表示剩下的单张有$i$个，对牌有$j$个，三张有$k$组，四张有$l$组，王有$o$个的最小出牌次数。然后转移就是朴素的转移，同时由于拆牌的存在，我们需要多加两组拆牌的转移，这就需要我们先枚举三张和炸才能转移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt;= N ; ++ l)</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= N ; ++ k)</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">				<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= N ; ++ j)</span><br><span class="line">					<span class="keyword">for</span> (rr <span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= <span class="number">2</span> ; ++ o)&#123;</span><br><span class="line">						rr <span class="keyword">int</span> res = <span class="number">100</span> ;</span><br><span class="line">						<span class="comment">// Single</span></span><br><span class="line">						<span class="keyword">if</span> (i) res = min(res, dp[i - <span class="number">1</span>][j][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j) res = min(res, dp[i][j - <span class="number">1</span>][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (k) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o) res = min(res, dp[i][j][k][l][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// T -&gt; 1</span></span><br><span class="line">						<span class="keyword">if</span> (i &amp;&amp; k) res = min(res, dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (k &amp;&amp; o) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o - <span class="number">1</span>] + <span class="number">1</span>) ; </span><br><span class="line">						<span class="comment">// T -&gt; 2</span></span><br><span class="line">						<span class="keyword">if</span> (j &amp;&amp; k) res = min(res, dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// F -&gt; 2</span></span><br><span class="line">						<span class="keyword">if</span> (l &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l - <span class="number">2</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j &amp;&amp; l)  res = min(res, dp[i][j - <span class="number">1</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i - <span class="number">2</span>][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j - <span class="number">2</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (i &amp;&amp; o &amp;&amp; l) res = min(res, dp[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// CHAI</span></span><br><span class="line">						<span class="keyword">if</span> (l) res = min(res, dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>][l - <span class="number">1</span>][o]) ;</span><br><span class="line">						<span class="keyword">if</span> (k) res = min(res, dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>][l][o]) ;</span><br><span class="line">						<span class="comment">// Trans</span></span><br><span class="line">						dp[i][j][k][l][o] = min(res, dp[i][j][k][l][o]) ;</span><br><span class="line">					&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拆牌分别是“炸拆成三张和单张”以及“三张拆成对子和单张”。</p>
<p>然后由于顺子这种东西不能根据数量转移，所以就还是dfs暴力算（dp按理说也是暴力吧/kk），最后加回来就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> 	<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">          <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">5</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">           		<span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] -- ;</span><br><span class="line">            	dfs(m - p, step + <span class="number">1</span>) ;   </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] ++ ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">3</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            	pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">            	dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">2</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            	pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span> ;</span><br><span class="line">            	dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span>(tong)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j) tong[buc[j]] ++ ; tong[<span class="number">5</span>] = buc[<span class="number">14</span>] ;</span><br><span class="line">    Ans = min(Ans, step + dp[tong[<span class="number">1</span>]][tong[<span class="number">2</span>]][tong[<span class="number">3</span>]][tong[<span class="number">4</span>]][tong[<span class="number">5</span>]]);<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-2015E-子串"><a href="#4-2015E-子串" class="headerlink" title="$4~2015E$ 子串"></a>$4~2015E$ 子串</h1><p><a href="https://www.luogu.org/problem/P2679" target="_blank" rel="noopener">$Link$</a></p>
<p>又是一道情怀题，还记得当时做的时候觉得可难了…（当时的pks：这个转移是人能想出来的吗？）</p>
<p>但其实状态很简单，$f_{i,j,k,0/1}$记录A到了$i$，B到了$j$，A迄今为止分成$k$段，$A[i]$选或者不选的方案数。</p>
<p>然后转移时考虑分类讨论：</p>
<ul>
<li><p>首先  $A[i] = B[j]:$</p>
<ul>
<li>1 ： $f_{i,j,k,1} = f_{i-1,j-1,k-1,1} + f_{i-1,j-1,k-1,0} + f_{i-1,j-1,k,1}$ 也就是{i,j}和前面的是一段/不是一段且和前面的段之间有空格/不是一段且和前面的段之间没空格（讨论空格是为了保证转移的完整性）。</li>
<li>2 ： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$ 前面一位选/不选</li>
</ul>
</li>
<li><p>否则 $A[i]\not = B[j]$</p>
<ul>
<li>1：  $f_{i,j,k,1} = 0\\$ 不合法的转移<br>2： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$</li>
</ul>
</li>
</ul>
<p>其实感觉这个方程…怎么说呢，挺有学习意义的。这其实也算是做了一个状态的前缀和，因为理论上是要从$k\text{~}i-1$中转移的，但因为是方案数，所以可以直接做一个前缀和过来；同时因为此时我们的“主元”是$A$，所以如果不选的话只能是从$(i-1,j)$转移过来而不是$(i,j-1)$（即$k$这一维限制的是$i$） 。</p>
<p>然而还有另外一种定义状态的方式；</p>
<p>其余的都差不多，还是$f_{i,j,k,1}$表示必选，但是$f_{i,j,k,0}$则表示<strong>“可选可不选”</strong>。那我们来思考这样如何转移：</p>
<ul>
<li>1：$f_{i,j,k,1} = (f_{i-1,j-1,k,1} +f_{i - 1,j-1, k-1, 0})\cdot [A_i=B_j] $ 还是分类讨论“连不连成一整段”</li>
<li>2：$f_{i,j,k,0} = f_{i−1,j,k,0}+f_{i,j,k,1}$，即<strong>保证了这一位不选的上一位的选/不选</strong>和<strong>保证了这一位必选</strong>的方案数。</li>
</ul>
<p>思想也大体相同。注意数据范围的限制，滚一下就好了。</p>
<p>嗯，是一道不错的题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">cin</span> &gt;&gt; A[i] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++) <span class="built_in">cin</span> &gt;&gt; B[i] ;</span><br><span class="line">    <span class="keyword">for</span>(d = i = <span class="number">1</span>; i &lt;= N; i ++, d ^= <span class="number">1</span>)&#123;</span><br><span class="line">        dp[d][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= K ;k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j]) </span><br><span class="line">                f[d][j][k] = (dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>] + f[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k]) % mod ;</span><br><span class="line">                <span class="keyword">else</span> f[d][j][k] = <span class="number">0</span> ; </span><br><span class="line">              	dp[d][j][k] = (dp[d ^ <span class="number">1</span>][j][k] + f[d][j][k]) % mod ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N &amp; <span class="number">1</span>][M][K]% mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-2011C-Mayan游戏"><a href="#5-2011C-Mayan游戏" class="headerlink" title="$5~2011C$ Mayan游戏"></a>$5~2011C$ Mayan游戏</h1><p><a href="https://www.luogu.org/problem/P1312" target="_blank" rel="noopener">Link</a></p>
<p>想当年这可真是噩梦……</p>
<p>简单来讲就是爆搜吧，只不过记得当时没想到是真的每次搜一遍$7\cdot5$的方阵……</p>
<p>然后这是以前的笔记：</p>
<ul>
<li>1、每次搜索要保留本次的状态，这是比较好想的，我也成功的想到了。但是问题是我们不能单纯地用一个二维数组来$copy$，需要记录步数，因为如果单纯的reset会导致之前走过的也消失。于是最终我们需要一个三维数组来记录。后半段是$qcr$告诉我的。 </li>
<li><p>2、还有就是一个小小的剪枝。就是由于对于每一个格子，我们考虑它向两边替换，而我们为了避免重复搜索，所以就决定<strong>单向搜索</strong>，即对于每个块，如果他左边也是一个块，那就不去$exchange$，只考虑右边；而如果左边是空白格，才$exchange$。显然这个剪枝的优化性是很显著的。</p>
</li>
<li><p>3、我一开始写的$remove()$、$down()$和$check()$十分的麻烦——或者说专一?反正之后我懒得调试了，直接听的$qcr$的，每次执行这几个函数的时候，直接<strong>全屏扫一遍</strong>。</p>
</li>
<li><p>4、$qcr$给我讲了一个很神的$down()$函数——其实也不算多神，只是很简单地处理了每一行的悬空态方块，但是说“神”的原因则是因为“简单”。对，简单，而有时往往我会想复杂。</p>
</li>
<li><p>5、对于$exchange$，我们要不断的$while(remove()) ~;$，因为会不断地有新情况出现。</p>
</li>
<li><p>6、最后我挂了……几个点来着……忘记了。反正原因是因为，每次$remove()$之前应该先$down()$，然而我并没有$down()$干净233</p>
</li>
<li><p>7、最后再说一个剪枝儿，不是必要性的，但是确实可以加快速度。就是我们再每次遍历$7 \times 5$的时候，遇到空白的，不是<code>continue</code>而是<code>break</code>，因为我们$down$一定是完备的，即从下向上枚举时，如果下方的已经clear了，上方的不可能悬空。所以可以少好几次空遍历。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span> <span class="keyword">int</span> x, y ;&#125; ; <span class="built_in">stack</span> &lt;D&gt; s ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ans</span>&#123;</span> <span class="keyword">int</span> x, y, d  ;&#125; res[<span class="number">100</span>] ; <span class="keyword">int</span> Remove[<span class="number">50</span>][<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, T[<span class="number">30</span>][<span class="number">30</span>], base[<span class="number">4000</span>][<span class="number">10</span>][<span class="number">10</span>], qwq[<span class="number">4000</span>][<span class="number">30</span>], color[<span class="number">30</span>], i, j, t, tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ttt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)&#123;</span><br><span class="line">        ttt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span>(T[di][dj] == <span class="number">-1</span>) ++ ttt ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(! ttt) <span class="keyword">continue</span> ;</span><br><span class="line">                T[di][dj - ttt] = T[di][dj], T[di][dj] = <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">()</span></span>&#123; <span class="comment">// void -&gt; bool</span></span><br><span class="line">    <span class="keyword">bool</span> Mark = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(Remove, <span class="number">0</span>, <span class="keyword">sizeof</span>(Remove)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; di &gt;= <span class="number">2</span> &amp;&amp; di &lt;= <span class="number">4</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di + <span class="number">1</span>][dj] &amp;&amp; T[di][dj] == T[di - <span class="number">1</span>][dj])&#123;</span><br><span class="line">                Remove[di + <span class="number">1</span>][dj] = Remove[di - <span class="number">1</span>][dj] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; dj &gt;= <span class="number">2</span> &amp;&amp; dj &lt;= <span class="number">6</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di][dj + <span class="number">1</span>] &amp;&amp; T[di][dj] == T[di][dj - <span class="number">1</span>])&#123;</span><br><span class="line">                Remove[di][dj + <span class="number">1</span>] = Remove[di][dj - <span class="number">1</span>] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Mark) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = (!Remove[di][dj]) ? T[di][dj] : <span class="number">-1</span> ;</span><br><span class="line">    down() ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prepare</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            base[x][di][dj] = T[di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _reset(<span class="keyword">int</span> x)&#123;<span class="comment">//copy_back</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = base[x][di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_work</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (judge())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= N ; ++ di)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, res[di].x, res[di].y, res[di].d) ;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (step == N + <span class="number">1</span>) <span class="keyword">return</span> ; Prepare(step) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] == <span class="number">-1</span>) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (di &gt; <span class="number">1</span> &amp;&amp; T[di - <span class="number">1</span>][dj] == <span class="number">-1</span>)&#123;</span><br><span class="line">                swap(T[di][dj], T[di - <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span> (remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span>, <span class="number">-1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (di &lt; <span class="number">5</span> &amp;&amp; T[di][dj] != T[di + <span class="number">1</span>][dj])&#123;</span><br><span class="line">                swap(T[di][dj], T[di + <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span>(remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span> ,<span class="number">1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="built_in">memset</span>(T, <span class="number">-1</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i) T[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i)</span><br><span class="line">        <span class="keyword">while</span>((t = qr()) != <span class="number">0</span>) T[i][++ T[i][<span class="number">0</span>]] = t ;</span><br><span class="line">    dfs_work(<span class="number">1</span>) ; <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="text-Afterwords"><a href="#text-Afterwords" class="headerlink" title="$\text{Afterwords}$"></a>$\text{Afterwords}$</h1><p>“</p>
<p>准确来说，没有人在到达之前知道自己到底要去哪儿。</p>
<p>”</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>奇怪的技巧</tag>
        <tag>贪心</tag>
        <tag>NOIP系列</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做三</title>
    <url>/2019/07/11/old-NOIP-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$NOIP2016$以及之前年份$NOIP$中优秀题目的泛做。</p>
<p>以下的题是我做了之后不禁感慨“啊，真是个好题”的题们……</p>
<a id="more"></a>
<p>然后首先打出难度标签：<img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<p><del>然后以下题目按照得较高的部分分的难度排序</del></p>
<h1 id="1-2013F-华容道"><a href="#1-2013F-华容道" class="headerlink" title="$  1  2013F$ 华容道"></a>$  1  2013F$ 华容道</h1><p><a href="https://www.luogu.org/problem/P1979" target="_blank" rel="noopener">$Link$</a></p>
<p>可能这道题很难…但是它有70分的暴力分！70分！在loj你甚至可以获得80分！tm这样的话暴力和正解有什么区别吗…从得分的时间分布上来讲，想正解就是大写的不值……</p>
<p>首先我们思考什么信息是有用的，嗯，空白格子的位子和当前棋子的位置，所以只要我们用BFS（而不是DFS，DFS的状态开销极大，但更可能的是我DFS的打开方式不对吧/sigh）的话，状态数就是$O(n^2m^2)$的，然后总复杂度就是$O(qn^2m^2)$，大概是四亿零500万的运算量上限…然而一开始我算成了四千五百万还纳闷为什么开了<code>-O2</code>在1s以内还跑不出来……</p>
<p>先贴个暴力吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line">	ans = Inf, vis[ex][ey][sx][sy] = <span class="number">1</span> ;</span><br><span class="line">	q.push((state)&#123;ex, ey, sx, sy, <span class="number">0</span>, <span class="number">1</span>&#125;) ; </span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		state n = q.front() ; q.pop() ;</span><br><span class="line">		<span class="keyword">if</span> (n.sx == tx &amp;&amp; n.sy == ty) ans = min(ans, n.s) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">			<span class="keyword">int</span> kx = n.bx + dx[k], ky = n.by + dy[k], px, py ; </span><br><span class="line">			<span class="keyword">if</span> (kx == n.sx &amp;&amp; ky == n.sy) </span><br><span class="line">        px = n.bx, py = n.by ; <span class="keyword">else</span> px = n.sx, py = n.sy ;</span><br><span class="line">			<span class="keyword">if</span> (!base[kx][ky] || kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || vis[kx][ky][px][py]) <span class="keyword">continue</span> ;</span><br><span class="line">			vis[kx][ky][px][py] = <span class="number">1</span> ;</span><br><span class="line">      q.push((state)&#123;kx, ky, px, py, n.s + <span class="number">1</span>, n.num + <span class="number">1</span>&#125;) ;</span><br><span class="line">		&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ans &gt;= Inf) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j]) ;</span><br><span class="line">	<span class="keyword">while</span> (Q --) <span class="built_in">cin</span> &gt;&gt; ex &gt;&gt; ey &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty, bfs() ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>喜闻乐见…不过自己打暴力的能力还是不行啊，还得练啊qaq</p>
<p>之后就是更加喜闻乐见的状态压缩。我们思考，这$n^2m^2$个状态都他娘的有鸟用吗（李云龙疾呼态），如果空白格子不在目标格子周围，那么无论空白格子怎么移动都不可能用爱发电。所以我们考虑吧直接预处理出来每个<strong>空白格子与目标格子（即起始格子）相邻的状态</strong>之间的代价，之后直接对此跑个$SPFA$就好了，毕竟最坏情况下SPFA的复杂度也只是$O(nM)$的，大概就是$O(n\cdot 4nm)&lt;\frac{O(n^2m^2)}{7.5}$，也算是很稳的复杂度了。</p>
<p>然后我们思考这样的复杂度是多少。考虑目标格子有$nm$种情况，空白格子在有效情况下只能在其四周，故状态数是$O(4nm)=nm$的。</p>
<p>然后关于代码实现这块需要比较深入的理解。首先我们先预处理出来当当前格子在随便一个格子上，空白格子想要转到另一个方向的步数。这样就可以抽象成一张空白图上先有的一个一个树（也就是一坨森林）。然后为了让这些森林之间能连上边，再将“空白格子和目标格子换了个位置”这种转移连上边（不连的话就不存在从一个格子到另一个格子的转移了）。同时不要忘了对状态的编号。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _get(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)&#123; <span class="keyword">return</span> x * <span class="number">120</span> + y * <span class="number">4</span> + d ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy, <span class="keyword">int</span> ox, <span class="keyword">int</span> oy, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Id = _get(ox, oy, d) ; </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis)), </span><br><span class="line">    dis[fx][fy] = <span class="number">1</span>, q.push((state)&#123;fx, fy&#125;) ; </span><br><span class="line"><span class="comment">//    cout &lt;&lt; fx &lt;&lt; " " &lt;&lt; fy &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        state n = q.front() ; </span><br><span class="line">        <span class="keyword">int</span> nx = n.x, ny = n.y ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = nx + dx[k], ky = ny + dy[k] ; </span><br><span class="line">            <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (base[kx][ky] &amp;&amp; !dis[kx][ky] &amp;&amp; (kx != ox || ky != oy)) </span><br><span class="line">                dis[kx][ky] = dis[nx][ny] + <span class="number">1</span>, q.push((state)&#123;kx, ky&#125;) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">3</span>) <span class="keyword">return</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = ox + dx[k], ky = oy + dy[k] ; </span><br><span class="line">        <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky] &amp;&amp; (kx != fx || ky != fy) &amp;&amp; base[kx][ky])</span><br><span class="line">            Add(Id, _get(ox, oy, k), dis[kx][ky] - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Add(Id, _get(fx, fy, d) ^ <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; base[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">         <span class="keyword">if</span> (!base[i][j]) <span class="keyword">continue</span> ;</span><br><span class="line">         <span class="keyword">if</span> (base[i - <span class="number">1</span>][j]) bfs(i - <span class="number">1</span>, j, i, j, <span class="number">0</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i + <span class="number">1</span>][j]) bfs(i + <span class="number">1</span>, j, i, j, <span class="number">1</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j - <span class="number">1</span>]) bfs(i, j - <span class="number">1</span>, i, j, <span class="number">2</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j + <span class="number">1</span>]) bfs(i, j + <span class="number">1</span>, i, j, <span class="number">3</span>) ; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们考虑在SPFA之前，我们需要求出空白格子从(ex,ey)到(sx, sy)周围需要的步数作为起始点，然后SPFA就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; MAXS ; ++ k) f[k] = Inf, vis[k] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> Id = _get(sx, sy, k), kx = sx + dx[k], ky = sy + dy[k] ;</span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky]) f[Id] = dis[kx][ky] - <span class="number">1</span>, Q.push(Id), vis[Id] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Q.front() ; Q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f[to(k)] &gt; f[n] + E[k].val)&#123;</span><br><span class="line">                f[to(k)] = f[n] + E[k].val ; </span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>, Q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-2012C-开车旅行"><a href="#2-2012C-开车旅行" class="headerlink" title="$2~2012C$ 开车旅行"></a>$2~2012C$ 开车旅行</h1><p> <a href="https://www.luogu.org/problem/P1081" target="_blank" rel="noopener">$Link$</a></p>
<p>不得不说2012的题目质量是真心好啊……</p>
<p>首先这题为了看上去不是那么毒瘤，于是加了一个70分的暴力分。然而…细节贼多——或者说只是我不细心，比如说把A和B怎么走看反了、算比值的时候用了个假<code>double</code>之类的……</p>
<p>于是70分好像有个头就会写吧= = 不知道当年什么区分度= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2 ;</span><br><span class="line">    <span class="keyword">int</span> Id1, Id2 ;</span><br><span class="line">&#125;P[MAXN] ; <span class="keyword">int</span> i, j ; <span class="keyword">double</span> o, q ;</span><br><span class="line"><span class="keyword">int</span> res, ans, N, M, T, base[MAXN], s[MAXN], x[MAXN], p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mabs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span> ; res = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (j = S ; j &lt;= N &amp;&amp; j ; u ^= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (u) <span class="keyword">if</span> (res + ans + P[j].v1 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">      				 <span class="keyword">else</span> res += P[j].v1, j = P[j].Id1 ;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/*pkspks*/</span> <span class="keyword">if</span> (res + ans + P[j].v2 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">      									<span class="keyword">else</span> ans += P[j].v2, j = P[j].Id2 ;</span><br><span class="line">        <span class="comment">//        cout &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ;  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp || (qwq == tp &amp;&amp; base[w] &gt; base[j])) </span><br><span class="line">              	tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id1 = w, P[i].v1 = tp ; tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp &amp;&amp; (qwq &gt; P[i].v1 || (qwq == P[i].v1 &amp;&amp; base[P[i].Id1] &lt; base[j])))</span><br><span class="line">                tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id2 = w, P[i].v2 = tp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    GO(2, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    GO(4, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; P[i].v1 &lt;&lt; " " &lt;&lt; P[i].Id1 &lt;&lt; " " &lt;&lt; P[i].v2 &lt;&lt; " " &lt;&lt; P[i].Id2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      GO(i, T) ; o = <span class="number">1.0</span> * res ? (<span class="number">1.0</span> * ans) / (<span class="number">1.0</span> * res) : Inf ; </span><br><span class="line">      <span class="keyword">if</span> (o &lt; q ||(o == q &amp;&amp; base[p] &lt; base[i])) q = o, p = i ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      GO(s[i], x[i]), <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后感觉从暴力到正解完全不是一个难度的。首先考虑到底是什么地方阻碍了社会的发展——初始化似乎是$n^2$的，走似乎是$&lt;n^2$的，那么从初始化入手：</p>
<h2 id="rm-Part-1-初始化的优化"><a href="#rm-Part-1-初始化的优化" class="headerlink" title="$\rm{Part~1}$ 初始化的优化"></a>$\rm{Part~1}$ 初始化的优化</h2><p>我们思考如果当前轮到第$i$高的城市了，并且此时所有现存城市中不存在编号在$i$之前的城市，即$i$是最左边的城市，那么对其有用的信息只会在第$i-1,i-2,i+1$或者第$i+2$的城市中选取。这就提示我们似乎如果从值域上考虑就是$O(4n)$的了——只要我们保证不存在在$i$左边的城市、即对应城市不可走的情况。</p>
<p>然后这个时候有个很神仙的想法就是<strong>双向链表优化</strong>，我们考虑按高度排完序之后，对相邻元素建立双向链表。然后<strong>按照从左到右的顺序枚举城市、get信息然后删除掉这个城市</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.h &lt; B.h ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.id &lt; B.id ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inlaw</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123; <span class="keyword">return</span> (pos &gt; N || !pos) ? Inf : <span class="number">0</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i].h), base[i].id = i ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Tid[base[i].id] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Tid[i] ;</span><br><span class="line">        d[<span class="number">1</span>].h = inlaw(pre[t]) + <span class="built_in">abs</span>(base[pre[t]].h - base[t].h),</span><br><span class="line">        d[<span class="number">2</span>].h = inlaw(pre[pre[t]]) + <span class="built_in">abs</span>(base[pre[pre[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">3</span>].h = inlaw(nxt[t]) + <span class="built_in">abs</span>(base[nxt[t]].h - base[t].h), </span><br><span class="line">        d[<span class="number">4</span>].h = inlaw(nxt[nxt[t]]) + <span class="built_in">abs</span>(base[nxt[nxt[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">1</span>].id = base[pre[t]].id, d[<span class="number">2</span>].id = base[pre[pre[t]]].id, </span><br><span class="line">        d[<span class="number">3</span>].id = base[nxt[t]].id, d[<span class="number">4</span>].id = base[nxt[nxt[t]]].id, </span><br><span class="line">        sort(d + <span class="number">1</span>, d + <span class="number">5</span>, cmp) ;</span><br><span class="line">        P[i].Id1 = d[<span class="number">1</span>].id, P[i].v1 = d[<span class="number">1</span>].h, </span><br><span class="line">        P[i].Id2 = d[<span class="number">2</span>].id, P[i].v2 = d[<span class="number">2</span>].h ; </span><br><span class="line">        pre[nxt[t]] = pre[t], nxt[pre[t]] = nxt[t] ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后初始化的工作就优化完了。至此可以在<code>Luogu</code>获得75pts的好成绩。</p>
<h2 id="rm-Part-2-走的优化"><a href="#rm-Part-2-走的优化" class="headerlink" title="$\rm{Part~2}$ 走的优化"></a>$\rm{Part~2}$ 走的优化</h2><p>…然而只有第一个优化情况并不会好转多少。查看数据之后发现原来最后几个点的$s$和$x$都完全是随的那种……所以就复杂度爆炸。然后我们考虑这么一个喜闻乐见的事情——限制似乎只有“小于x”和“可以继续走”诶，于是似乎相邻的几步如果都不超过限制是不是就可以一起走？于是想到<strong>倍增预处理</strong>。</p>
<p>我们用$A_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$A$走过的路程；同理$B_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$B$走过的路程。并且选择用$f_{i,j}$表示从i开始走$2^j$轮之后到达的点。然后值得注意的是最后可能走的不满一整轮，于是特判一下A能不能再走一次就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp2) ;<span class="comment">//重排回来= =</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">    	f[i][<span class="number">0</span>] = P[P[i].Id2].Id1 ;	</span><br><span class="line">    	<span class="keyword">if</span> (P[i].Id2) </span><br><span class="line">        A[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[i].h) ; </span><br><span class="line">		  <span class="keyword">if</span> (P[P[i].Id2].Id1)</span><br><span class="line">        B[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[P[P[i].Id2].Id1].h) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>], </span><br><span class="line">			A[j][i] = A[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + A[j][i - <span class="number">1</span>], </span><br><span class="line">			B[j][i] = B[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + B[j][i - <span class="number">1</span>] ;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, ll H)</span></span>&#123;</span><br><span class="line">	ans = res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line">		<span class="keyword">if</span> (f[S][j] &amp;&amp; A[S][j] + B[S][j] &lt;= H) </span><br><span class="line">			ans += A[S][j], res += B[S][j], H -= (A[S][j] + B[S][j]), S = f[S][j] ;</span><br><span class="line">	<span class="keyword">if</span> (A[S][<span class="number">0</span>] &lt;= H) ans += A[S][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-2016B-天天爱跑步"><a href="#3-2016B-天天爱跑步" class="headerlink" title="$3~2016B$ 天天爱跑步"></a>$3~2016B$ 天天爱跑步</h1><p><a href="https://www.luogu.org/problem/P1600" target="_blank" rel="noopener">$Link$</a></p>
<p>……当年的毒瘤题，还记得那还是我第一次参加NOIP（普及组），不出所料地考挂，然后rqy不出所料地考好……</p>
<p>咳，偏题了，然后对于这道题，我索性把每个部分分都写了一遍：</p>
<h2 id="rm-Part-1-25pts"><a href="#rm-Part-1-25pts" class="headerlink" title="$\rm{Part~1}$ 25pts"></a>$\rm{Part~1}$ 25pts</h2><p>$n,m\leq 1000$</p>
<p>其实就是LCA一下然后$nm$的统计答案就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">	h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">			fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line">	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), Add(x, y) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]), </span><br><span class="line">  	lca1[i] = t = lca(s[i], e[i]), </span><br><span class="line">  	_up[i] = -(dep[t] &lt;&lt; <span class="number">1</span>) + (dep[s[i]] + dep[e[i]]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i, <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans), ans = <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) t = lca(e[j], i), p = lca(s[j], i), </span><br><span class="line">  			w1 = -(dep[p] &lt;&lt; <span class="number">1</span>) + (dep[i] + dep[s[j]]), </span><br><span class="line">  			w2 = dep[i]  +  dep[e[j]] -  (dep[t] &lt;&lt; <span class="number">1</span>), </span><br><span class="line">  		  ans += (w1 == base[i]) * (_up[j] == w1 + w2) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-2-15pts"><a href="#rm-Part-2-15pts" class="headerlink" title="$\rm{Part~2}$ 15pts"></a>$\rm{Part~2}$ 15pts</h2><p>这部分是链，保证$i$到$i+1$有一条边。</p>
<p>那么其实这个问题就转化成了在一个序列上，与点$i$相隔恰好为$t[i]$的点的个数，顺便注意判断一下走没走完就好。但是这个地方我用了一个肥肠zz的写法，就是每次加完之后删除到这个点停止的那些点，而“那些点”的求法则是我手写了一个很诡异的二分……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tink&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Nodes</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> s, e, n ;</span><br><span class="line">	&#125;u[MAXN], v[MAXN] ; <span class="keyword">int</span> t1, t2 ;</span><br><span class="line">	<span class="keyword">int</span> be[MAXN], bs[MAXN], res[MAXN], k1 = <span class="number">0</span>, k2 = <span class="number">0</span> ;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &lt; b.e ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &gt; b.e ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">1</span>, r = (m ? k2 : k1) + <span class="number">1</span> , mid, l0, l1 ; </span><br><span class="line">		<span class="keyword">if</span> (!m)&#123;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (u[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l0 = l, l = <span class="number">1</span>, r = k1 + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (u[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l1 = l ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) bs[u[i].s] -- ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (v[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l0 = l, l = <span class="number">0</span>, r = k2 + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (v[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l1 = l ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) be[v[i].s] -- ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line">			t1 = qr(), t2 = qr() ; </span><br><span class="line">			<span class="keyword">if</span> (t1 &lt; t2) bs[t1] ++, u[++ k1] = (Nodes)&#123;t1, t2, k1&#125; ;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/**/</span>be[t1] ++, v[++ k2] = (Nodes)&#123;t1, t2, k2&#125; ;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(u + <span class="number">1</span>, u + k1 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[i] += bs[i - base[i]], del(i, <span class="number">0</span>) ;	</span><br><span class="line">		sort(v + <span class="number">1</span>, v + k2 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i) res[i] += be[i + base[i]], del(i, <span class="number">1</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="built_in">cout</span> &lt;&lt; res[p] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-3-20pts"><a href="#rm-Part-3-20pts" class="headerlink" title="$\rm{Part~3}$ 20pts"></a>$\rm{Part~3}$ 20pts</h2><p>保证所有起点都在根（1号点）。</p>
<p>其实这个部分也是挺水的。就是考虑一个树形DP即可。然后判断也很好判断，如果这个点的开眼时间正好是根到它的距离（深度差），那么就会一定会满足到它的点和到它的子树内的所有的点。否则就肯定不行，也就是一个都不满足。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[MAXN], dis[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">            dis[to(k)] = dis[now] + <span class="number">1</span>, sum += dfs(to(k), now) ; </span><br><span class="line"> 		&#125;</span><br><span class="line"> 		dp[now] += sum ; <span class="keyword">return</span> dp[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[e[i]] ++ ; dp[<span class="number">1</span>] = dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">          	<span class="keyword">if</span> (base[i] == dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dp[i]) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是现在就有了60pts的优秀分数。似乎这样的话就可以直接把剩下的部分弃了去写T3的期望DP辽233</p>
<h2 id="rm-Part-4-and-5-40pts"><a href="#rm-Part-4-and-5-40pts" class="headerlink" title="$\rm{Part~4~and~5}$  40pts"></a>$\rm{Part~4~and~5}$  40pts</h2><p>剩下的部分没有选择分开写<del>所以就不算谢了每个部分分是不是</del>，因为剩下的两个部分实在是太像了，都要用到一种思想——<strong>桶</strong>. <del>其实80pts还有一种不是很想写的写法在这里就留个图吧：</del></p>
<p><img src="1.png" alt></p>
<p>然后我们思考桶的解法。我们把每一段路程拆成向上和向下两段。下文中设$x$为当前节点。</p>
<ul>
<li><p>对于向上的路径</p>
<ul>
<li>首先可以产生贡献的点就是子树内的$buc[dep[x]+ base[x]]$，这个我们用作差来求解（原因是我们可能会遍历许多棵子树所以会产生数值相同但不合法的贡献）。</li>
<li>其次我们需要知道，如果一个人的起点和终点的LCA在子树内但不是$x$，那么也不会产生贡献。解决方案是每次dfs完一个点向上回溯的时候删除掉子树内所有以该点为LCA的点。</li>
<li>同时也需要我们更新以该节点为起点的路径的桶。</li>
</ul>
</li>
<li><p>对于向下的路径</p>
<ul>
<li>首先对于一条路径$(u,v)$，当对点i产生贡献时可以推出来式子：</li>
</ul>
<script type="math/tex; mode=display">
dep_v-dis_{u,v}=dep_i-base_i</script><pre><code> 那么也就是说我们可以通过把每条路径的$dep_v-dis_{u,v}$压到桶里面，然后每次计算贡献。
</code></pre><ul>
<li>同时我们还是需要消除贡献，即消除那些对于儿子而言在父亲那里停止的路径，方法就是在向下迭代之前先把所有以当前点为终点的贡献加上，到儿子时通过作差就可以减去这部分。注意向上回溯时还是需要删除那些蜷缩在子树内的路径。</li>
</ul>
</li>
</ul>
<p>之后还有需要注意的，就是如果在一条路径的LCA处正好可以观察到这条路径，那么就需要<code>-1</code>，因为我们上升下降统计了两遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Prepare&#123; <span class="comment">//25</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	    fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span>, H = max(H, dep[now]) ;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line">	        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line">	    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line">        	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    	        fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line">	   	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">	    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> -(dep[c] &lt;&lt; <span class="number">1</span>) + (dep[a] + dep[b]) ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> pks&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v1[MAXN], v2[MAXN], v3[MAXN] ;</span><br><span class="line">	<span class="keyword">int</span> buc_d[MAXN &lt;&lt; <span class="number">2</span>], buc_u[MAXN &lt;&lt; <span class="number">2</span>], ans[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> co = base[now] + dep[now], ks ; <span class="keyword">if</span> (co &lt;= H) ks = buc_d[co] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs1(to(k), now) ;</span><br><span class="line">		buc_d[dep[now]] += cnbt[now] ; <span class="keyword">if</span> (co &lt;= H) ans[now] = buc_d[co] - ks ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v1[now].size() ; ++ k) -- buc_d[dep[v1[now][k]]] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> co = dep[now] - base[now] + N, ks = buc_u[co] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v2[now].size() ; ++ k) ++ buc_u[v2[now][k] + N] ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs2(to(k), now) ;</span><br><span class="line">		ans[now] += buc_u[co] - ks ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v3[now].size() ; ++ k) -- buc_u[v3[now][k] + N] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Solve5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      cnbt[s[i]] ++, v1[LCA[i]].push_back(s[i]) ; dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      v2[e[i]].push_back(dep[e[i]] - _up[i]), </span><br><span class="line">    	v3[LCA[i]].push_back(dep[e[i]] - _up[i]) ;  dfs2(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dep[s[i]] - dep[LCA[i]] == base[LCA[i]]) -- ans[LCA[i]] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ; <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) x = qr(), y = qr(), Add(x, y) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]) ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      LCA[i] = lca(s[i], e[i]), _up[i] = wo(s[i], e[i], LCA[i]) ; </span><br><span class="line">    pks :: Solve5() ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，然后这道题就完了。不得不说虽然当时用心做了，但是过上几周再反过头来看还是觉得有些细节理解的并不到位、或者说是满分做法中的有些流程当时根本没有仔细推导。</p>
<p>不过不得不说这个题还是非常妙的。或许有时候题面复杂、需求复杂会让人忘记这道题到底有多巧妙…反正就是感觉这道题用“桶+即时修改”这个组合思想还是很<code>nice</code>的。</p>
<h1 id="4-2012F-疫情控制"><a href="#4-2012F-疫情控制" class="headerlink" title="$4~2012F$ 疫情控制"></a>$4~2012F$ 疫情控制</h1><p><a href="https://www.luogu.org/problem/P1084" target="_blank" rel="noopener">$Link$</a></p>
<p>…这个题之所以放在最后一个是因为我真的不知道部分分该怎么写啊。</p>
<p>嗯，首先是二分，这倒是可以想到。之后一开始想的是似乎不断把城市向上移动就好了，毕竟越靠上越优；但是样例就把我这种写法卡掉了，原因很浅显，我忽略了绕过根继续走的那些点可以继续产生贡献……于是就很GG。</p>
<p>…于是我选择统计了那些可以跨越根的节点。对于最终每个被覆盖的节点，我用的是直接更新<code>vector</code>预处理出来挂在每个点底下的叶子节点，check的时候直接判一下每个节点的mark。然而这样写的很繁琐，并且复杂度也是个迷…最后只能不了了之了</p>
<p>所以大概这个题我想出了50%~60%？…然而还是没有分数。</p>
<h2 id="rm-Part-1-倍增！倍增！倍增！"><a href="#rm-Part-1-倍增！倍增！倍增！" class="headerlink" title="$\rm{Part~1}$ 倍增！倍增！倍增！"></a>$\rm{Part~1}$ 倍增！倍增！倍增！</h2><p>首先喜闻乐见的是，我们向上跳的时候van♂全可以用倍增来搞，只要预处理出$2^k$级祖先就好了。</p>
<p>然后注意顺便判断一下可不可以拐弯，即跳到根之后是否在二分的时间内可以继续向下跳。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line"><span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line"><span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    t = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; </span><br><span class="line">  			<span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; </span><br><span class="line">  			<span class="keyword">else</span> &#123; </span><br><span class="line">          	t = base[i] ; </span><br><span class="line">          	<span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line">              	<span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; </span><br><span class="line">          	Army[++ n] = mp(x - Sum[base[i]], t) ; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-2-转化！转化！转化！"><a href="#rm-Part-2-转化！转化！转化！" class="headerlink" title="$\rm{Part~2}$ 转化！转化！转化！"></a>$\rm{Part~2}$ 转化！转化！转化！</h2><p>这个地方有个肥肠有意思的点，就是我们思考假设一个叶子节点没有被覆盖，那么就说明一定存在它的某一级祖先的整棵子树没有被覆盖。那么这就提示我们可以考虑<strong>直接判断根的每个儿子是否都被覆盖了（树形结构的优越性）</strong> </p>
<p>嗯，于是对于我们上一部分打完mark之后的那些点（暂时是只有不会拐弯的被打了mark），我们直接考虑不进行一次$O(n)$的<code>dfs</code>就可以完成<code>push_up</code>的操作。</p>
<p>然后我们考虑如何操作那些可以拐弯的点。思考最优的方案一定是越高越好，所以不妨就让他拐过来之后落在根的儿子上。于是我们需要统计这个的代价，并对收集来的两个信息分别排序。之后就直接双指针扫一遍根的全部儿子，看看是否全部都被覆盖了即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">	push_down(<span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) </span><br><span class="line">  	<span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">	j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">  	  <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">    	<span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，贴个总程序吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, head[MAXN], n, m ; <span class="keyword">bool</span> res[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, Sum[MAXN], ans, base[MAXN], fa[MAXN][<span class="number">25</span>], i, j, l, r, mid ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    P += w ;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &lt; b.fr ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        Sum[to(k)] = Sum[now] + E[k].v ; dfs(to(k), now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t ; n = m = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        t = base[i] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; <span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; <span class="keyword">else</span> &#123; t = base[i] ; <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) <span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; Army[++ n] = mp(x - Sum[base[i]], t) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(<span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) <span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">    j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> a, b, c ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), Add(a, b, c) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; Init() ;</span><br><span class="line">    l = <span class="number">0</span>, r = P ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>, ans = mid ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><p>其实总感觉自己做这些题还是有些力不从心233</p>
<p>不得不说类似于“二分答案”这种东西是很有OI风味的，毕竟是一种特殊的思想…不知道自己什么时候能把类似的所有思想真正地打包学会啊qaq</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
        <tag>倍增</tag>
        <tag>贪心</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】NOIP2017泛做</title>
    <url>/2019/07/11/NOIP2017/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$NOIP2017$的泛做。</p>
<a id="more"></a>
<h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega$"></a>$\Omega$</h1><p>嗯，这个代表“前言”的字母很帅。</p>
<p>先来总结一下每个题的难度，A题<code>提高（证明）/普及-（找规律）</code>, B题<code>提高</code>， C题<code>提高+</code>，总结来看，Day1比较送；D题<code>普及+</code>，E题<code>省选-</code>，F题<code>省选-</code>，Day2不如Day1水。</p>
<p>PS: <code>提高</code>以NOIP提高组平均难度为准，<code>省选</code>以弱省省选为准（比如以<code>SNOI2019</code>平均难度作为基准线）</p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p>由于当时场上切了这道题，导致我对“找规律“这种投机取巧的做题方式情有独钟，从而在某些计数题时不好好想DP反而猜sb规律……感觉很GG……</p>
<p>其实这个题就是给一个方程：</p>
<script type="math/tex; mode=display">
ax+by \not= t \quad x,y, \in\mathbb{N},\quad t\in \mathbb{N+} \quad (a,b)= 1</script><p>求$\max{t}$</p>
<p>呃，首先，我想了一种很zz的证明方式：</p>
<ul>
<li><p>当$t = a \cdot b - a - b$时，$t$满足这个方程</p>
<ul>
<li><p>我们通过移项可以得到：</p>
</li>
<li><script type="math/tex; mode=display">
ax+by-ab+a+b=0 \\\
a(x-b +1) + b(y+1) = 0 \\\</script></li>
<li><p>观察这个式子，要么有$y+1=0$且$x-b+1=0$，要么有</p>
<script type="math/tex; mode=display">
a(b-x-1) = b(y+1)\cdots(1)</script></li>
<li>第一种情况显然不成立，那么我们考虑第二种情况。此时因为$(a,b)=1$，所以会有$b~|~(b-x-1) \to b ~|~(x+1)$, 同理$a~|~(y+1)$ .但同时我们将$(1)$式搞一搞就可以得到<script type="math/tex">\frac{a}{b} = \frac{b-(x+1)}{y+1}</script>但因为$a,b \in \mathbb{N+}$，所以会有$b&gt;(x+1)$ ; 因为$b~|~(x+1)$，有$b\leq x+1$或$x+1=0$（舍） ，矛盾，故此时$t$满足这个方程。</li>
</ul>
</li>
<li><p>当$t&gt;a\cdot b-a-b$时，$t$总不满足。</p>
<blockquote>
<p>不妨设$t_0=a\cdot b-a-b, ~t=t_0+k, ~k\in\mathbb{N+}$</p>
<p>此时……然后就不会了2333——以下是借鉴的<a href="https://www.cnblogs.com/xxzh/p/9178564.html" target="_blank" rel="noopener">星星之火OIer</a>巨佬的思路：</p>
</blockquote>
</li>
<li><p>对于任意正整数$k\geq ab−a−b+1$，即$k+a+b\geq ab+1$</p>
<ul>
<li>设$k+a+b = \mu a+m~~(k\geq b,1\leq m &lt;a)$. 同时：<script type="math/tex; mode=display">
\because (a,b)=1\\\
\therefore \exists x_0,y_0 \in \mathbb{Z} \quad s.t. \quad ax_0+by_0=1 \\\
\therefore \exists x_1,y_1∈\mathbb{Z}，−(b−1)\leq x_1\leq 0 \quad s.t.\quad  ax_1+by_1=m\\\</script>这里的意思其实是设$−(b−1)\leq x_1\leq 0$，一定存在整数$y_1$使得$ax_1+by+_1=m$成立。原因就是在整数$x_1$的取值中一共有$b$个数，$y_1=(m−ax_1)/b$，根据鸽笼原理之类的zz定理，我们总是可以找到$x_1$使得$m−ax_1$能被$b$整除。</li>
</ul>
</li>
</ul>
<p>显然，$y_1\geq 1(ax_1\leq 0,m &gt;0, b&gt;0, 因此y_1\geq 1,)$。于是，取$x=\mu+x_1−1,y=y_1−1$。注意到$x_1,y_1$的取值范围，得$x,y\geq 0$， 即有$ax+by=k$</p>
<hr>
<p>？？？不知不觉写了小半个下午？？看起来A题确实是结论题了（sigh</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  A, B ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A * B - A - B ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p> ……像这种题不就是看脸题吗…手一抖就调不出来了$\rm{qaq}$</p>
<p>题解以前写过，于是直接把主要部分引用过来（以前的码风还真是抽搐</p>
<blockquote>
<p><strong>读入</strong>：</p>
<p>我们先用$while$按字符读入每个程序的第一行，抠出需要检验的复杂度，$O(1)$用$0$来存$[n^0=1  $ $~~~$ $ (n!=0)]$.</p>
<p>注意，有可能有两位数，需要多扣一位……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;	  <span class="keyword">while</span>(o!=<span class="string">')'</span>)&#123;</span><br><span class="line">&gt;    	<span class="keyword">if</span>(o==<span class="string">'1'</span>&amp;&amp;!chk) </span><br><span class="line">&gt;			   need_check=<span class="number">0</span>;</span><br><span class="line">&gt;    	<span class="keyword">if</span>(o==<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;    	   <span class="built_in">cin</span>&gt;&gt;o&gt;&gt;o;</span><br><span class="line">&gt;          need_check=o<span class="number">-48</span>;</span><br><span class="line">&gt;			   chk=<span class="number">1</span>;</span><br><span class="line">&gt;			&#125;</span><br><span class="line">&gt;       o=getchar();</span><br><span class="line">&gt;       <span class="keyword">if</span>(<span class="built_in">isdigit</span>(o)&amp;&amp;chk)need_check*=<span class="number">10</span>,need_check+=(o<span class="number">-48</span>); </span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  getchar();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>至于最后为什么要再$gatchar()$一次……自己试试就知道了。</p>
<p>那么接下来就要按行读入循环了，比较简单。</p>
<p><strong>初始化</strong>：</p>
<p>为了使码风简洁，所以写到函数里了。这个地方我用到了三个栈，一个用来记录每个循环的答案（因为有可能有多个相互独立的循环），一个用来记录每次$F$时读入的循环上下界。以上两个都是$int$栈,还有一个$char$栈，存储每次定义的循环变量，而这个字符栈搭配一个$bool$性的数组，用于记录是否可用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> MAX 1000000</span></span><br><span class="line">&gt;<span class="keyword">int</span> i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_checks,stk[MAX];</span><br><span class="line">&gt;<span class="keyword">bool</span> check[<span class="number">150</span>],flag,spj,chk;</span><br><span class="line">&gt;<span class="keyword">char</span> s[<span class="number">3010</span>],o,stkk[MAX]; </span><br><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;	<span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span>(check));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stkk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stkk));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stk));</span><br><span class="line">&gt;now=t=tt=cntf=cnte=res=flag=spj=chk=<span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>$ps:$虽然不知道用一个二进制位的$0$来初始化字符数组会怎样……不过好像海星。</p>
<p>$cnte$和$cntf$用来记录$F$和$E$的数量，$num$、$t$、$tt$都是栈的指针，$spj$用来判断一个独立循环是否结束（如果结束就把当前的得到压入栈）,$now$用来搭配$spj$记录当前独立循环体的时间复杂度， $chk$用于读入每个程序的第一行（即含有需要判断的时间复杂度的那一行），$flag$用于判断输出。</p>
<p><strong>主要操作</strong></p>
<p>对于读入的东西，分类讨论，然后$continue$……没什么可说的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;	   <span class="keyword">while</span>(l--)&#123;</span><br><span class="line">&gt;     gets(s);</span><br><span class="line">&gt;     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);)&#123;</span><br><span class="line">&gt;      		<span class="keyword">while</span>(s[i]==<span class="string">' '</span>)i++;</span><br><span class="line">&gt;				<span class="keyword">if</span>(s[i]==<span class="string">'F'</span>)&#123;</span><br><span class="line">&gt;					<span class="keyword">if</span>(cntf&gt;cnte&amp;&amp;cnte)&#123;</span><br><span class="line">&gt;						ans[++num]=now;</span><br><span class="line">&gt;						now=<span class="number">0</span>;</span><br><span class="line">&gt;					&#125;</span><br><span class="line">&gt;           	cntf++,i++;</span><br><span class="line">&gt;           	<span class="keyword">continue</span>;</span><br><span class="line">&gt;       	&#125;</span><br><span class="line">&gt;       	<span class="keyword">if</span>(s[i]==<span class="string">'E'</span>)&#123;</span><br><span class="line">&gt;       		y=stk[t],t--;</span><br><span class="line">&gt;					x=stk[t],t--;</span><br><span class="line">&gt;           	cnte++;</span><br><span class="line">&gt;           	<span class="keyword">if</span>(cnte==cntf)spj=<span class="number">1</span>;</span><br><span class="line">&gt;           	<span class="keyword">if</span>(x!=MAX)&#123;</span><br><span class="line">&gt;           		<span class="keyword">if</span>(y==MAX)now++;</span><br><span class="line">&gt;           		<span class="keyword">if</span>(y&lt;x)now=<span class="number">0</span>;</span><br><span class="line">&gt;           	&#125;</span><br><span class="line">&gt;           	<span class="keyword">else</span>&#123;</span><br><span class="line">&gt;           		<span class="keyword">if</span>(y!=MAX)now=<span class="number">0</span>;</span><br><span class="line">&gt;           	&#125;</span><br><span class="line">&gt;           	check[stkk[tt]-<span class="string">'a'</span>]=<span class="number">0</span>;</span><br><span class="line">&gt;           	tt--,i++;</span><br><span class="line">&gt;           	<span class="keyword">if</span>(spj)&#123;</span><br><span class="line">&gt;           		ans[++num]=now;</span><br><span class="line">&gt;						now=<span class="number">0</span>;</span><br><span class="line">&gt;						spj=<span class="number">0</span>;</span><br><span class="line">&gt;           	&#125;</span><br><span class="line">&gt;					<span class="keyword">continue</span>;</span><br><span class="line">&gt;       	&#125;</span><br><span class="line">&gt;           <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])&amp;&amp;s[i]!=<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;           	<span class="keyword">if</span>(check[s[i]-<span class="string">'a'</span>]&amp;&amp;!flag)&#123; </span><br><span class="line">&gt;           	<span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;           	flag=<span class="number">1</span>;</span><br><span class="line">&gt;					&#125;</span><br><span class="line">&gt;           	stkk[++tt]=s[i];</span><br><span class="line">&gt;           	check[s[i]-<span class="string">'a'</span>]=<span class="number">1</span>;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;       	<span class="keyword">else</span> &#123;  </span><br><span class="line">&gt;           	<span class="keyword">if</span>(s[i]==<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;       		my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">&gt;					i+=<span class="number">2</span>;</span><br><span class="line">&gt;           &#125;               </span><br><span class="line">&gt;           my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;       	i++;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唯一需要注意的是入栈操作，因为要把字符压入整型，所以我又写了个函数来入栈。入栈的时候当然需要注意是不是两位数……</p>
<p>哦，还有，如果这次轮到$n$入栈了，那么就随便入栈一个大于一百的数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_push</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">&gt;	<span class="keyword">if</span>(<span class="built_in">isdigit</span>(a))&#123;</span><br><span class="line">&gt;		<span class="keyword">if</span>(<span class="built_in">isdigit</span>(b))&#123;</span><br><span class="line">&gt;			stk[++t]=(a<span class="number">-48</span>)*<span class="number">10</span>+b<span class="number">-48</span>;</span><br><span class="line">&gt;			i++;</span><br><span class="line">&gt;		&#125;</span><br><span class="line">&gt;		<span class="keyword">else</span> stk[++t]=a<span class="number">-48</span>; </span><br><span class="line">&gt;	&#125;</span><br><span class="line">&gt;	<span class="keyword">if</span>(a==<span class="string">'n'</span>)stk[++t]=MAX;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>最后判断一下输入输出即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;	   <span class="keyword">if</span>(!flag&amp;&amp;cntf!=cnte)&#123;</span><br><span class="line">&gt;     <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;     flag=<span class="number">1</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;	   <span class="keyword">while</span>(num)&#123;</span><br><span class="line">&gt;  	   res=max(res,ans[num]); </span><br><span class="line">&gt;  	   num--;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  <span class="keyword">if</span>(!flag) <span class="keyword">if</span>(res==need_check) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;  			 <span class="keyword">else</span> 				 <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>嗯~o(<em>￣▽￣</em>)o这就是满分做法了。</p>
</blockquote>
<p>唉，时光一去不复返啊。</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p>……其实不算是个新题，只是似乎当时这道题场上很卡常？感觉就是好多东西的杂糅，先SPFA判个全$0$环，再倒着记搜一遍……感觉已经不算什么新题了，T3出成这样感觉很失望qaq……</p>
<p>但怎么说呢，也是个练习码力的机会吧，转移方程挺好想的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;  </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; vis ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fr, to, next, v ;</span><br><span class="line">&#125;E[MAXM] ; <span class="keyword">int</span> head[MAXN][<span class="number">2</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> T, N, L, M, K, P, A, B, C, ss[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Es[MAXM][<span class="number">2</span>], dfn[MAXN], low[MAXN], tot ; </span><br><span class="line"><span class="keyword">bool</span> flag ; LL Ans, dp[MAXN][MAXK], dist[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u][<span class="number">1</span>], head[u][<span class="number">1</span>] = cnt ; </span><br><span class="line">	E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v][<span class="number">0</span>], head[v][<span class="number">0</span>] = cnt ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k ; </span><br><span class="line">	vis.reset() ;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-63</span>, <span class="keyword">sizeof</span>(dp)), cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= L + <span class="number">3</span> ; ++ k) </span><br><span class="line">		dist[k] = Inf, ss[k] = head[k][<span class="number">1</span>] = head[k][<span class="number">0</span>] = <span class="number">0</span> ; 		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> now, k ; </span><br><span class="line">	q.push_front(<span class="number">1</span>), vis[<span class="number">1</span>] = <span class="number">1</span>, dist[<span class="number">1</span>] = <span class="number">0</span>, ++ ss[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		now = q.front(), vis[now] = <span class="number">0</span>, q.pop_front() ;</span><br><span class="line">		<span class="keyword">for</span> (k = head[now][<span class="number">1</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[to(k)] &gt;= dist[now] + E[k].v)&#123;</span><br><span class="line">				++ ss[to(k)] ; </span><br><span class="line">				dist[to(k)] = dist[now] + E[k].v ;</span><br><span class="line">				<span class="keyword">if</span> (ss[to(k)] &gt;= N)&#123; flag = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">				<span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">					<span class="keyword">if</span> (q.empty() || dist[to(k)] &lt; dist[q.front()]) </span><br><span class="line">						q.push_front(to(k)) ; <span class="keyword">else</span> q.push_back(to(k)) ; vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dp[now][op] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[now][op] ; dp[now][op] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = head[now][<span class="number">0</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line">		LL t = op - dist[to(k)] + dist[now] - E[k].v ; </span><br><span class="line">		<span class="keyword">if</span> (t &gt; K || t &lt; <span class="number">0</span>) <span class="keyword">continue</span> ; dp[now][op] = (dp[now][op] + dp_work(to(k), t)) % P ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[now][op] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i ; <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span>(T --)&#123;</span><br><span class="line">		L = <span class="number">200000</span>, Init() ; Ans = <span class="number">0</span> ;</span><br><span class="line">		N = qr(), M = qr(), K = qr(), P = qr() ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), _Add(A, B, C) ;</span><br><span class="line">		SPFA() ; dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ; L = N ; <span class="keyword">if</span> (flag) &#123; flag = <span class="number">0</span>, <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ; <span class="keyword">continue</span> ; &#125; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Ans = (Ans + dp_work(N, i)) % P ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想了一下，似乎出题人是故意把时间押给$B$的，所以$C$比较送。</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>也是挺送的一道题，注意开<code>long long</code>就好…用并查集维护一下最上面和最下面的两个洞在不在一条“连通链”上即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hole</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x,y,z;</span><br><span class="line">&#125;c[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[a]!=a)a=find(f[a]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> xz,<span class="keyword">long</span> <span class="keyword">long</span>  yz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c[find(yz)].z&gt;c[find(xz)].z) f[find(yz)]=f[find(xz)];</span><br><span class="line">	<span class="keyword">else</span> f[find(xz)]=f[find(yz)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(hole a,hole b)</span>z</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">    d=(a.z-b.z)*(a.z-b.z)+(a.y-b.y)*(a.y-b.y)+(a.x-b.x)*(a.x-b.x);</span><br><span class="line">    <span class="keyword">if</span>(d&lt;=<span class="number">4</span>*r*r)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;c[i].x,&amp;c[i].y,&amp;c[i].z);</span><br><span class="line">	    	f[i]=i;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	     <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	      <span class="keyword">if</span>(f[i]!=f[j]&amp;&amp;check(c[i],c[j]))unionn(i,j);</span><br><span class="line">	    <span class="keyword">bool</span> cc=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	      <span class="keyword">if</span>(c[i].z+r&gt;=h&amp;&amp;c[find(i)].z-r&lt;=<span class="number">0</span>)</span><br><span class="line">		  &#123;</span><br><span class="line">		  	cc=<span class="number">1</span>;</span><br><span class="line">		  	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">		  <span class="keyword">if</span>(!cc)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		  cc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>wtm以前的码风是有多犀利啊，字符间不加空格大括号也不换行</del></p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p>emmm第一眼状压，第二眼需要把树高加到状态里，那么就是$f_{s,h}$表示现在选的点集为$S$，树高为$h$的最小花费。转移的时候大概就是朴素的</p>
<script type="math/tex; mode=display">
f_{s,i} = \min\limits _{t \in s}\{f_{t,i-1}+cost_{t\to s}\}</script><p>然后这个cost显然是可以在可接受的复杂度以内$prework$出来的。于是最终的复杂度就是$\Theta(3^n\cdot n^2)$</p>
<blockquote>
<p>求“子集的子集”的复杂度严格来讲是$3^n$而不是$4^n$，原因在于我们事实上一共有$\sum \binom{n}{k}2^k$个子集，逆向二项式展开<del>或者叫二项式收缩</del>一下就可以得到<script type="math/tex">\sum \binom{n}{k}2^k = \sum \binom{n}{k}1^{n-k}\cdot 2^k = (1+2)^n = 3^n</script>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(t = S ; t ; t = (t - <span class="number">1</span>) &amp; S)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>呃，至于这句话的原理暂不可知，但是挺好用是真的qwq</p>
</blockquote>
<p>但是复杂度上限此时是$531441\times 12^2= 76527504$，不可过（但事实上根本不可能跑满所以也过了），以下是<code>Flash_hu</code>巨佬的$\Theta(3^nn)$的做法：</p>
<p>我们发现似乎同一树高的所有节点，完全可以同时转移。所以我们不妨设$f_{s,t}$表示已选点集为$s$，下一层要加入的点集为$t$时， 新加入的所有点与原有点之间最小的边权之和——用于预处理。 具体的转移我们可以考虑如下：</p>
<script type="math/tex; mode=display">
f_{s,t} = \min \{f_{s,t-lowbit(j)}+cost_{k, s}\}, k=\log _2lowbit(j)</script><p>其中$cost_{k,s}$表示点$k$到连通块$s$的最短距离。可以用$lowbit$的原因是答案无序，所以这一部分的复杂度是$O(3^nn).$</p>
<p>那么接下来考虑原先的$dp$，设$g_{s,h}$表示已选点集为$s$，当前树高为$h$的最小代价，即目标函数。那么转移就是：</p>
<script type="math/tex; mode=display">
g_{s,h} = \sum_{t\in s}g_{s-t, h-1}+h\cdot f_{s-t,t}</script><p>同样是显然的。所以最后的复杂度就是$O(3^nn)$ 。答案的话最后直接对所有$g_{_{2^n-1,h}},h\in[1,n]$取个最小值就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, T, D[MAX][MAX], a, b, c ;</span><br><span class="line"><span class="keyword">int</span> F[MAXN][MAX], Next[MAX], Ans, Sup, Now ;</span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k, Log[MAX], Max, A[MAXN][MAXN] ;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A, <span class="number">63</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">63</span>, <span class="keyword">sizeof</span>(F)), Ans = Inf ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), </span><br><span class="line">        A[a][b] = A[b][a] = min(c, A[a][b]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Log[<span class="number">1</span> &lt;&lt; i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) F[<span class="number">0</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = Sup = Max ^ i; j ; j = (j - <span class="number">1</span>) &amp; Sup) Next[j] = cnt, cnt = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = cnt ; j ; j = Next[j])&#123;</span><br><span class="line">            Now = Log[j &amp; (-j)] + <span class="number">1</span>, T = Inf ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= N ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) T = min(T, A[Now][k]) ; </span><br><span class="line">            D[i][j] = D[i][j ^ (j &amp; -j)] + T ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= Max; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k ; k = (k - <span class="number">1</span>) &amp; j)</span><br><span class="line">                F[i][j] = min(F[i][j], F[i - <span class="number">1</span>][j ^ k] + i * D[j ^ k][k]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ans = min(Ans, F[i][Max]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p>一道我不是很会的线段树题……</p>
<p>怎么说呢，感觉这个做法未曾见过吧。大概就是维护$n+1$棵动态开点的线段树，其中对每一行的前$m-1$个元素维护一个线段树，然后对最后一列单独维护一棵线段树。线段树上每个点维护自己子树内到底有多少个点被删了，用来协助寻找现在的位置。在此基础上再维护$n+1$个<code>vector</code>，用来记录从每棵线段树中弹出的点即可。</p>
<p>呃，现在的我似乎并没有很好地理解这个题的做法，有些马虎…所以希望日后再看的时候能看的更清明一点吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> vio&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXV 2010</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t, i, j ; </span><br><span class="line">    <span class="keyword">int</span> base[MAXV][MAXV] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                base[i][j] = ++ t ; </span><br><span class="line">        <span class="keyword">while</span>(Q --)&#123;</span><br><span class="line">            x = qr(), y = qr(), t = base[x][y] ;</span><br><span class="line">            <span class="keyword">for</span> (i = y + <span class="number">1</span> ; i &lt;= M ; ++ i) base[x][i - <span class="number">1</span>] = base[x][i] ; </span><br><span class="line">            <span class="keyword">for</span> (i = x + <span class="number">1</span> ; i &lt;= N ; ++ i) base[i - <span class="number">1</span>][M] = base[i][M] ; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (base[N][M] = t)) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> segment_T&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXN 400010</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rr register int</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; del[MAXN &lt;&lt; <span class="number">4</span>] ; <span class="keyword">int</span> Max ; </span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">4</span>], L[MAXN &lt;&lt; <span class="number">4</span>], R[MAXN &lt;&lt; <span class="number">4</span>], dfn, val[MAXN &lt;&lt; <span class="number">4</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) root = ++ dfn ; val[root] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; rr mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) update(L[root], l, mid, pos) ; <span class="keyword">else</span> update(R[root], mid + <span class="number">1</span>, r, pos) ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ; rr mid = (l + r) &gt;&gt; <span class="number">1</span>, dif = mid - l + <span class="number">1</span> - val[L[root]] ; </span><br><span class="line">        <span class="keyword">if</span> (dif &gt;= pos) <span class="keyword">return</span> query(L[root], l, mid, pos) ; <span class="keyword">else</span> <span class="keyword">return</span> query(R[root], mid + <span class="number">1</span>, r, pos - dif) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase2</span><span class="params">(<span class="keyword">int</span> x, ll y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, x) ; update(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, now_p) ;</span><br><span class="line">        ll ret = now_p &lt;= N ? <span class="number">1L</span>L * now_p * M : del[N + <span class="number">1</span>][now_p - N - <span class="number">1</span>] ; del[N + <span class="number">1</span>].pb(y ? y : ret) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[x], <span class="number">1</span>, Max, y) ; update(rt[x], <span class="number">1</span>, Max, now_p) ; </span><br><span class="line">        ll ret = now_p &lt; M ? <span class="number">1L</span>L * (x - <span class="number">1</span>) * M + now_p : del[x][now_p - M] ; del[x].pb(delcase2(x, ret)) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rr x, y ; Max = max(N, M) + Q ; </span><br><span class="line">        <span class="keyword">while</span> (Q --) x = qr(), y = qr(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, y != M ? delcase1(x, y) : delcase2(x, <span class="number">0</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span> &amp;&amp; M &lt;= <span class="number">5000</span>) vio :: Solve1() ;</span><br><span class="line">    <span class="keyword">else</span> segment_T :: Solve2() ;<span class="comment">/*pkspkspks*/</span> <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="varPhi"><a href="#varPhi" class="headerlink" title="$\varPhi$"></a>$\varPhi$</h1><p>现在来看，乐观估计，自己应该可以得到$100+100+100+100+55+30=485pts$，当且仅当自己的码力已经很强。如果是悲观估计，那大概是$100+70+40+80+55+30=375pts$。继续努力吧，现在还差得很远啊……</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>数据结构/线段树</tag>
        <tag>NOIP系列</tag>
        <tag>暴力,brute-force</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】舞蹈链(DLX)入门</title>
    <url>/2019/07/11/dlx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“<br>在一个全集$X$中若干子集的集合为$S$，精确覆盖（$\boldsymbol{Exact~Cover}$）是指，$S$的子集$S*$，满足$X$中的每一个元素在$S*$中恰好出现一次。在计算机科学中，精确覆盖问题指找出这样的一种覆盖，或证明其不存在。<br>”</p>
<a id="more"></a>
<h1 id="0x01-精准覆盖问题"><a href="#0x01-精准覆盖问题" class="headerlink" title="$0x01$ 精准覆盖问题"></a>$0x01$ 精准覆盖问题</h1><p>……其实是一种决策问题，给定$n$行长度为$m$的$0,1$序列，要求选出一些行，使得每一列有且仅有一个$1$，这就是精准覆盖问题。</p>
<p>诚然，我搜索贼菜，所以暂且不考虑爆搜，引进一种叫做“X算法”的东西，其本质上是每次选取一行，之后删掉所有与这行冲突的行，同时删掉与这行冲突的列，成为一个更小的矩阵，迭代下去。如果什么时候删没了，就说明是一种可行解；否则恢复原来的状态。</p>
<p>我们思考这种简洁做法的流程，发现朴素的删除与恢复无非就是将矩阵的这一个元素由$0$或$1$赋值成$-1$，记录一下状态回溯的时候再赋值回去，整个过程十分地漫长且繁复。而所谓所谓的”<strong>舞蹈链算法</strong>$\rm{DLX~(Dancing-Links ~X ~Algorithm)}$“算法则是专门用来加速这一过程。</p>
<p>在本人看来，$\rm{DLX}$更像是一种包装好的数据结构，一种加速措施，能更好的让爆搜达到其理论复杂度（所以本质上还是爆搜XD）……不过说实话“像翩翩起舞的舞者”我倒是看不出来…我觉得更像是一对牛仔裤上拉链，拉来拉去的那种感觉……</p>
<p><del>诶，什么时候我的Preface开始这么意识流了啊</del></p>
<h1 id="0x02-text-Dancing-Links"><a href="#0x02-text-Dancing-Links" class="headerlink" title="$0x02$ $\text{Dancing-Links}$"></a>$0x02$ $\text{Dancing-Links}$</h1><p>其实算法的本质就是链表，这玩意儿插入删除都是$\Theta(1)$的。我们考虑建立一个<strong>十字循环链表</strong>，即每个元素在链表里是四联通的，并且左右成环、上下成环，目的是方便知道某些操作该什么时候停止。本质上来讲，一个求解矩阵（此处代指上文提到的$n$行$0,1$序列）初始的$\text{Dancing-Links}$ 共有$\text{1+m+Count(‘1’)}$ 个元素，其中$Count(‘1’)$指矩阵中$1$的个数。</p>
<p>前$\text{m+1}$个元素，大概就是列标元素（$m$个）左右连成一片，最左边的$0$号元素用来判断是否$\text{worked-out}$整个矩阵，和所有列标元素串成一条左右连通的链表。然后剩下的的元素就是真实存在的元素…该怎么连怎么连那种感觉…</p>
<p>那么每个元素记录$6$个值，上下左右和行标列标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">	B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro))  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中$R_o[]$数组记录每一行的第一个元素（第一个加进来的元素</p>
<p>然后<code>Insert</code>函数用于插入……毕竟是链表嘛<del>，就要有个链表的样子</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">	B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line">	<span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line">	<span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后$C_s[]$数组用来记录每一列的元素个数，用来剪枝。</p>
<p>然后就是删除和恢复，都是以列为参数的函数，也都是很平凡的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">			B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">			B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">	B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是主函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">		now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">	Del(now_c) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">		Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">		<span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个小剪枝，就是刚才说的$C_s[]$。如果每次从含有最少$1$的那一列开始删，似乎可以快好几倍。</p>
<p>我发现整理算法的文章写起来真是难受啊，还是意识流比较管用。</p>
<p>最后是全部的程序（<a href="https://www.luogu.org/problemnew/show/P4929" target="_blank" rel="noopener">$Luogu4929$</a>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own Init</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king Done</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand work </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, ans ; </span><br><span class="line"><span class="keyword">int</span> N, M, Ans[MAX], Ro[MAX], Cs[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro)) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">    B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">    B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line">    <span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line">    <span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">            B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">            B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">    B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">        now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">    Del(now_c) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">        Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">        <span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            &#123; <span class="built_in">cin</span> &gt;&gt; k ; <span class="keyword">if</span> (k) Insert(i, j) ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dance(<span class="number">0</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own() ; </span><br><span class="line">    I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king() ;</span><br><span class="line">    One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand() ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">/*</span></span><br><span class="line"><span class="comment">             	I hear Jerusalem bells are ringing   Roman Cavalry choirs are singing</span></span><br><span class="line"><span class="comment">             	Be my mirror my sword and shield     My missionaries in a foreign field</span></span><br><span class="line"><span class="comment">                For some reason I can't explain	     Once you know there was never'</span></span><br><span class="line"><span class="comment">                Never an honest word			     That was when I ruled the world</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>精准覆盖</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】用舞蹈链(DLX)解决一类数独问题</title>
    <url>/2019/07/11/dlx2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考虑精准覆盖问题的本质——我们把行看做决策，把列看做任务，那么其实质就是通过决策来完成任务。</p>
<p>那么我们来考虑数独问题的本质，对于一个$n^2\cdot n^2$的数独而言，他的目标函数有四个：</p>
<ul>
<li><p>1、$r(i,j):$对于第$i$行，必须要有数字$j$</p>
</li>
<li><p>2、$c(i,j):$对于第$i$列，必须要有数字$j$</p>
</li>
<li><p>3、$p(i,j):$对于第$i$个宫，必须要有数字$j$</p>
</li>
<li><p>4、$e(i,j):$对于第$(i,j)$个格子，必须要有数字</p>
</li>
</ul>
<p>由此可知，我们有$4\times (n^2\cdot n^2)$的任务量。</p>
<p>同时我们可以用$n^6$的状态表示我们的决策，即$(i,j,k)$表示第$i$行$j$列填了数字$k$。</p>
<p>结合两者考虑，我们可以建出一个新的网格图，有$n^6$行、$4n^4$列。考虑向网格中填“$1$”表示一个决策完成了一个任务，那么对于每一个决策$(i,j,k)$，它理应可以完成$4$个任务，所以一共有$16n^4$个1.</p>
<p>至此建模完毕，一个$n^2\cdot n^2$的数独问题可以转化成一个$n^6$行、$4n^4$列，有$16n^4$个$1$的精准覆盖问题。</p>
<a id="more"></a>
<p>下面是代码实现部分，以<a href="https://www.spoj.com/problems/SUDOKU/" target="_blank" rel="noopener">SPOJ1110-SUDOKU</a>为例：</p>
<ul>
<li>首先是对状态进行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; </span><br><span class="line">  	<span class="keyword">return</span> (a &lt;&lt; <span class="number">8</span>) + (b &lt;&lt; <span class="number">4</span>) + c + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;c)</span></span>&#123; </span><br><span class="line">  	x --, c = x % <span class="number">16</span>, x /= <span class="number">16</span>, b = x % <span class="number">16</span>, x /= <span class="number">16</span>, a = x ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理其实也很简单，就是i的后续状态(j,k)有$n^4=256$种组合，同理j的后续状态有$n^2=16$种组合。</p>
<p>然后就是连边，对于每个点判断一下，如果当前枚举到的数字是这个点的数字那么就需要<code>insert</code>，同理如果没有数字的话那就都<code>insert</code>一遍，毕竟比起有数字的点，可行的决策数要更多。至此我们就保证了原图中存在数字的方格被<code>insert</code>了，不存在数字的方格的所有可能情况也被<code>insert</code>了，之后直接<code>dance</code>就可以啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t[O][O], op ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POS = <span class="number">0</span>, Row = <span class="number">1</span>, Col = <span class="number">2</span>, Sub = <span class="number">3</span> ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		read(), Init() ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j)&#123;</span><br><span class="line">				t[i][j] = base[i][j] == <span class="string">'-'</span> ? <span class="number">0</span> : base[i][j] - <span class="number">64</span> ;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">16</span> ; ++ k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (t[i][j] &amp;&amp; t[i][j] != k + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">					op = encode(i, j, k) ; </span><br><span class="line">          Insert(op, encode(POS, i, j)),</span><br><span class="line">					Insert(op, encode(Row, i, k)), </span><br><span class="line">          Insert(op, encode(Col, j, k)), </span><br><span class="line">          Insert(op, encode(Sub, (i / <span class="number">4</span>) * <span class="number">4</span> + j / <span class="number">4</span>, k)) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		dance(<span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j) <span class="built_in">printf</span>(<span class="string">"%c"</span>, (<span class="keyword">char</span>)(res[i][j] + <span class="number">65</span>)) ;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是一道要求出所有解的题：<a href="https://www.luogu.org/problem/P1074" target="_blank" rel="noopener">NOIP2009D 靶形数独</a></p>
<p>此处需要我们求出所有可能的精准覆盖方案然后取最大值，于是小小改动一下<code>dance</code>就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">gs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || y == <span class="number">1</span> || x == <span class="number">9</span> || y == <span class="number">9</span> )   <span class="keyword">return</span> <span class="number">6</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || y == <span class="number">2</span> || x == <span class="number">8</span> || y == <span class="number">8</span> )   <span class="keyword">return</span> <span class="number">7</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span> || y == <span class="number">3</span> || x == <span class="number">7</span> || y == <span class="number">7</span> )   <span class="keyword">return</span> <span class="number">8</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">4</span> || y == <span class="number">4</span> || x == <span class="number">6</span> || y == <span class="number">6</span> )   <span class="keyword">return</span> <span class="number">9</span> ; <span class="keyword">return</span> <span class="number">10</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">	<span class="keyword">if</span> (!now_c)&#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, z, ret = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; step ; ++ i)</span><br><span class="line">			decode(ans[i], x, y, z), g[x][y] = z + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span> ; ++ j)</span><br><span class="line">				ret += g[i][j] * gs(i + <span class="number">1</span>, j + <span class="number">1</span>) ;</span><br><span class="line">		res = max(res, ret) ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = now_c ; i ; i = B[i].r) </span><br><span class="line">    now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ;  </span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d)&#123;</span><br><span class="line">		ans[step] = B[i].ro ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">		dance(step + <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line">	&#125;</span><br><span class="line">	Back(now_c) ; <span class="keyword">return</span>  ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>撒花~ <del>（撒自己XD</del></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title>随想八 · 逃吧</title>
    <url>/2019/06/11/8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一篇时间跨度很长的文章，也是「随想」系列里面我认为最丧的一篇文章。</p>
<p>你确定要看吗？或许也没有想象的那么丧。可能今天我是这么写的，后天我就不这么认为了。毕竟本质上，这只是一篇闲扯的文章。</p>
<a id="more"></a>
<p>灵长类动物的情绪往往会表征在行为上。从一开始只会因希望发泄而抢、砸物品，演变到脱离出群落、独自对着天上的月亮皎洁、地上的蚂蚁成群，最后演变出音乐、文章、涂鸦。同时，不得不承认，情感是推动艺术发展的内在力量，而瞬时的情绪则是艺术诞生的缘由。</p>
<p>所以，这篇文章写了很久也就不奇怪了——我的情绪起伏有时会很严重，从内环境角度分析，就是雌性激素含量的起伏变化。而这篇文章，不同于其他的文章，是必须要在我十分情绪化的状态下才能写出来。</p>
<p>就好像，比起平日里活跃的过头的我，我更倾向于认为现在这个自己才是真正的自己。只有在现在这个状态，可能会被叫做「抑郁情绪堆积」之类的，我才能够感到“啊，原来我还活着”。</p>
<p>正如，比起四处高呼“为了兴趣而学”、“勇敢学下去”、“别放弃啊”的我，我更倾向于认为那个懦弱无能的我才是真的我。</p>
<p>正如，我一直以来认为的，「短暂的快乐只会带来空虚，无尽的悲伤才会带来充实」。</p>
<hr>

        <div id="aplayer-RMizavAP" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-RMizavAP"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "Space Oddity",
              author: "(Mix)",
              url: "Space Oddity.mp3",
              pic: "/2019/06/11/8/qwq.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h1 id="时间轴：19年夏"><a href="#时间轴：19年夏" class="headerlink" title="时间轴：19年夏"></a>时间轴：19年夏</h1><h2 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h2><p>最近有在看《哈利·波特》，以前从未读过的我现在俨然成了异类，不过倒也是兴趣使然。本是读英文版的，第一部却读了接近一个月，每日尝读10页已算不错的收获了。读完首卷后尝试整理下单词，苦于如同伸手摘繁星，不知从何而始，亦不知到何处是个尽头。于是第二卷便一直搁置在书桌的角落，未尝得到时间用于阅读。</p>
<p>恰逢高考端午连休，索性用假期的最后一天把《哈》电影的3\4\5\6看完了。看完的感触自然是有的，虽然未触及结局，但早在知乎上被剧透了个差不多。大概就是类似父母的感觉？看着哈利、罗恩和赫敏每部电影都更成熟的模样，不禁感慨时间的流逝确是一去不回，顺便也为自己一只没有过铁三角那样金石可镂的友情而忧伤，大概是自己太孤独了吧。</p>
<p>但我却很在意一个新出场的人物，卢娜，卢娜·洛夫古德。她是后期“铁六角”的一员，经常在哈利需要的时候帮助他——但这不是最重要的，最重要的是，不知为何，她似乎对我有一种天然的吸引力，$\rm{gorgerous}$，就是这个词。可能是因为扮演这个角色的演员演绎的太完美了，把精灵/空灵、机敏/睿智的混合演绎的栩栩如生，也可能是角色本身就很讨喜，或者说扮演者自己的颜值加了很大的分（我认为是很漂亮的）——总之，我才明白如果在我的梦境里出现一位类似“洛神”的存在，那形象大概就是她，卢娜，的样子了。无论是小说里的描写、电影里的演绎，亦或者是杂糅，我都欣然接受这样一位精灵入驻我遥不可及的梦。</p>
<p>我这种感情缘何而起呢？大概是她身上的那种超然脱俗的感觉吧。在电影里，扮演者恰如其分地把卢娜的超然演绎了出来——她看得透生死，看得透哈利有多难过，看得透一切，却又像一块无瑕的宝玉不受沾染。大概是因为几乎所有人，及时天性是善的，也会因为后天知识的输入、阅历的增长而变得混浊、扭曲、纠结、迷茫，但她似乎并没有。书中的设定，她是拉文克劳的学生，并且有着拉文克劳人固有的聪慧机敏，但是那一切似乎都没有成为她超脱的枷锁。</p>
<p>她有爱，心中有说不出的温度。她的父亲是某本奇妙的畅销杂志《The Quibbler（唱唱反调）》的主编。那是一本被赫敏嫌弃的奇怪的杂志，但她却很喜欢，并且四处推销，用她那精灵一般的嗓音推销——看到那儿时，我突然感觉有什么东西开始在黑暗里发光。哈利波特到了后期，完全变成了黑暗童话，充满了紧张、喧嚣和压抑。但每次卢娜一出现，只要说几句话，似乎就可以马上呼唤一阵清风徐来，涤荡心灵。</p>
<p><img src="http://b-ssl.duitang.com/uploads/item/201701/29/20170129133646_i5Bh3.thumb.224_0.gif" alt></p>
<p>那是梦，是遥遥无期的梦，梦里有她，一个虚构的人物，有着不存在的身份，不存在的音容笑貌。我特意去搜索过扮演者的相关信息，发现成年后的扮演者似乎并不出彩，身上再也没有那种精灵的气息。</p>
<p>好在由于时间实在不够用，只能看到《混血王子》。之后还有两部决定留在下次大休，也就是合格考之后看。我猜大概我看完全部的《哈》之后，自己会变得很惆怅——惆怅好几天的那种吧，毕竟上次看完《言叶之庭》就是这样。美好的东西结束了，总是感觉很悲伤。</p>
<p>但天下没有不散的宴席，你说对吧。哦，对，这句话我第一次见还是在《家有儿女》里面呢。</p>
<h2 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h2><p>但其实，我更向往的，是这么一种生活，这么一种无忧无虑的生活吧？</p>
<p>一个人，静静地待在一个四周有着连绵蜿蜒的山、静静流淌的水，大地被一望无尽的、软绵绵的绿草覆盖，天与山与水之间只有一间小小的棚屋，用石头垒的，可能会有着红色的顶，但那样太突兀；可能会有着棕色的顶，但那样太沉寂。屋里炉子上煮着茶或者咖啡，一张简单但是温暖的床，一床蓬松到恰好的被子，一只没那么柔软的枕头，几把带背儿的椅子，一张古色古香的桌子。房里，墙上可能会放着一两只精致的挂钟，桌上可能会放着一个插有各色鲜艳花儿的花瓶。</p>
<p>平时我唯一做的事，就是坐在山坡上，感受着草的柔软与细腻，目送着天边云彩的来去匆匆，眺望着潺潺流过的河流。可能，在一望无际间，会有一棵大大的树，有时我也会爬上树梢，无奈斜阳来了又去，感慨星点来了又回。</p>
<p>是啊，就让我一个人，原远离这个世界，不行吗？</p>
<p>我一直在想，既然我知道有很简单很简单的生活，但为什么我每天都活在惶恐、活在忧虑、活在无奈中？我受够了因为一点美好的机遇而沾沾自喜、因为一点不堪的经历就要担惊受怕的日子了。我受够这必须要忍受一切、必须要提防一切的日子了。我受够这种不够单调的日子了。</p>
<p>是啊，这种跌宕起伏的生活才有趣，我又何尝不知道？</p>
<p>但，我不想了啊，只是觉得，太难走下去了啊。</p>
<p>「地球online」这个游戏，确实不公平吧。规则限定了只有前进的人才能活下去，剥夺了想要原地踏步的人的权利。所以讽刺的是，或许世界上最难的事，就是「过最简单的生活」这件事吧。</p>
<p>为什么，连「我和世界互相忘记」这种对整个游戏根本无关痛痒的决策，也不是免费的呢？</p>
<h2 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h2><p>嗯，胆小啊、懦弱啊，我知道。</p>
<p>「除了勇气，我什么都不缺。」这话，本就是说给自己听的。「未来的路又在哪呢？」这话，说了千百遍也还是颓唐。</p>
<p>所以，如果可以的话，把我绑架到加拿大北部、瑞士、丹麦之类的地方——让这世界，忘了我吧。</p>
<h1 id="时间轴：2019年秋"><a href="#时间轴：2019年秋" class="headerlink" title="时间轴：2019年秋"></a>时间轴：2019年秋</h1>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Prufer序列泛做</title>
    <url>/2019/05/26/Prufer%E5%BA%8F%E5%88%97%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Prufer数列是无根树的一种数列，常用来求解树的计数问题。</p>
</blockquote>
<a id="more"></a>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="$Preface$"></a>$Preface$</h1><p>嗯，最近学了学一个叫做<code>Prufer</code>序列的东西，然后主要是跟树的计数有关。</p>
<h2 id="基本概念与基本操作"><a href="#基本概念与基本操作" class="headerlink" title="基本概念与基本操作"></a>基本概念与基本操作</h2><p>首先下定义：Prufer序列是一个长度为$n-2$的序列。</p>
<p>我们考虑给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数$n&gt;2$的树总存在叶子节点，因此一棵$n$个节点的无根树唯一地对应了一个长度为$n-2$的数列，数列中的每个数都在$1$到$n$的范围内。而这就是这棵树的$\boldsymbol{Prufer}$<strong>序列</strong>。</p>
<blockquote>
<p>为什么是$n-2$？</p>
<p>我们观察一棵树，$n-1$条无向边决定了总度数为$2n-2$，同时由于每个节点当自己是被删成叶子的时候不会被算进去，所以每个节点需要减去一的贡献，换句话说就是$Prufer$序列的长度为$n-2$。</p>
</blockquote>
<p>emmm然后一个比较平凡的结论就是<strong>$\boldsymbol{P rufer}$序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。</strong></p>
<p>同时我们接下来要不加证明地断言<strong>任何一个长为$n-2$、取值范围在$1$到$n$之间的数列都唯一地对应了一棵$n$个节点的无根树.</strong></p>
<p><del>严格证明大家可以去Mt67的博客上翻（</del></p>
<p>想要更好的意会以上内容，需要我们考虑如何实现Prufer的呈现与复原：(摘自<code>ProJ7-Jeffy</code>的博客)</p>
<p>（1）无根树转化为 $Prufer$ 序列。<br>首先定义无根树中度数为<code>1</code>的节点是叶子节点。<br>找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下<code>2</code>个节点。<br>如下图的树对应的 $Prufer$ 序列就是 <code>3，5，1，3</code>。<br><img src="1.png" alt><br>具体实现可以用一个 <code>set</code> 搞定，维护度数为 <code>1</code> 的节点。复杂度 $O(n\log n)$。<br>（2）$Prufer$序列转化为无根树。<br>设点集 <code>V={1,2,3,...,n}</code>，每次取出 $Prufer$ 序列中最前面的元素$u$，在<code>V</code>中找到编号最小的没有在 $Prufer$ 序列中出现的元素$v$，给 $u，v$ 连边然后分别删除，最后在 <code>V</code> 中剩下两个节点，给它们连边。最终得到的就是无根树。<br>具体实现也可以用一个 <code>set</code>，维护 $Prufer$ 序列中没有出现的编号。复杂度 $O(n\log n）$。 </p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><p>$n$个点有标号无根树共有$n^{n-2}$种。</p>
<ul>
<li>$\rm{Proof}:$ 仔细想想…似乎Prufer序列一共$n-2$项，于是就乘法原理就好了……</li>
</ul>
</li>
<li>接上一个，有根树的话因为对于每种方案里面的$n$个点都可以当作根，所以总数量是$n^{n-2}\cdot n=n^{n-1}$。</li>
</ul>
<hr>
<ul>
<li><p>假设每个点的度数已经确定了，设第$i$号点的度数为$d_i$，则显然有$\sum_{i=1}^{n}(d_i - 1)=n-2$，那么对于每个节点度数确定的带标号无根树数量就是</p>
<script type="math/tex; mode=display">
\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)}</script><ul>
<li>$\rm{Proof}:$ 大概是一个排列组合的思想，我们可以认为是一共$n$种元素，选$n-2$个，每种元素有且必须有$d_i-1$个，求排列数。然后比较显然的是$(n-2)!$是总排列数，而每个元素一共有$d_i-1$个位置，对于同一种元素的同一种位置排布，我们多算了$A_{(d_i-1)}^{(d_i-1)}=(d_i-1)!$次的，所以分母上乘法原理起来去除这些贡献就好。</li>
</ul>
</li>
<li><p>接上一个, $n$ 个节点的度依次为 $d_1,d_2,…,d_{n-m}$，另外有 $m$ 个节点度数未知，求有多少种生成树？</p>
<ul>
<li>我们考虑首先计算一下$Prufer$序列该剩下多少未知项，设其数目为$\omega$，则$\omega=(n-2)-\sum_{d_i ~is~known} (d_i-1)$。那么本着瞎**去重的原则，我们考虑应该在分母上乘一个$\omega!$。而同时由于我们存在$m$个度数并未确定的点，在$Prufer$序列中占据了$\omega$个位置，所以我们分子上应该再乘上一个$m^{\omega}$。故总方案数就变成了：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\frac{(n-2)!m^{\omega}}{\omega!\cdot \prod_{i=1}^{n-m}(d_i-1)}</script><h1 id="A-HNOI2008-明明的烦恼"><a href="#A-HNOI2008-明明的烦恼" class="headerlink" title="$A$ [HNOI2008]明明的烦恼"></a>$A$ [HNOI2008]明明的烦恼</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1005" target="_blank" rel="noopener">bzoj1005</a></p>
<p>其实就是上面<code>扩展</code>里面的一个推论，然后我们就用<code>python</code>水过去就好了233</p>
<p><del>然而BZOJ的Py只会一直Pending，所以还是什么时候再写一发高精度吧</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = input()</span><br><span class="line">Fac = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N - <span class="number">1</span>) :</span><br><span class="line">    Fac = Fac + [Fac[i - <span class="number">1</span>] * i]</span><br><span class="line">Ans = Fac[N - <span class="number">2</span>]</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">Sum = N - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N) :</span><br><span class="line">    di = input()</span><br><span class="line">    <span class="keyword">if</span> di == <span class="number">-1</span> :</span><br><span class="line">    	cnt = cnt + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> : </span><br><span class="line">        Ans = Ans / Fac[di - <span class="number">1</span>]</span><br><span class="line">        Sum = Sum - (di - <span class="number">1</span>)</span><br><span class="line">Ans = Ans / Fac[Sum]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, Sum) :</span><br><span class="line">    Ans = Ans * cnt</span><br><span class="line"><span class="keyword">print</span> (Ans)</span><br></pre></td></tr></table></figure>
<h1 id="B-小猴打架"><a href="#B-小猴打架" class="headerlink" title="$B$ 小猴打架"></a>$B$ 小猴打架</h1><p>由于在BZOJ上是权限题，所以不得已去Luogu做…<del>国内最大的盗版题市场</del></p>
<p><a href="https://www.luogu.org/problemnew/show/P4430" target="_blank" rel="noopener">Luogu4430</a></p>
<p> 我们发现这个题的Aim在于让我们求无根树有多少种不同的生成方式，比普通的Prufer序列多一个加边的顺序——毕竟Prufer只能处理树的形态不同&amp;标号不同，所以我们理所当然地乘上一个$(n-1)!$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//用sb代码来填补博文太短的空白</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; Frac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i) (Ans *= N) %= Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">	(Ans *= Frac[N - <span class="number">1</span>]) %= Mod, <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF#Global Round 1の题解(A $\to$ G)</title>
    <url>/2019/05/10/Codeforces-1110/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从省选完之后状态一直不佳，感觉自己刚燃起的希望又熄灭了。所以就打算来整理一下省选之前因为懒而没整的一些题。然后你会发现前两句话一点关系都没有XD</p>
<p>这里是总链接<a href="http://codeforces.com/contest/1110" target="_blank" rel="noopener">$Link$</a>.</p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p><img src="https://img.shields.io/badge/难度-普及－-yellow.svg" alt></p>
<p>题意：求$\sum_{i=1}^{k} a_i\times b^{k-i}$的奇偶性， $k = \Theta(n \log n)$ </p>
<p>……其实很容易想麻烦，比如说逐个判断，整体判断啥的。但其实只要对结果都$\bmod ~10$，然后判断奇偶性就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; k ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= k ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">   reverse (base + <span class="number">1</span>, base + k + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = k ; i &gt;= <span class="number">1</span> ; -- i) Sum = Sum * b + base[i], Sum %= <span class="number">10</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; (Sum &amp; <span class="number">1</span> ? <span class="string">"odd"</span> : <span class="string">"even"</span>) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<p><del>其实就是在水字数</del></p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p><img src="https://img.shields.io/badge/难度-普及%2B-red.svg" alt></p>
<p>题意：给定一条网格纸，$n, m, k$, 分别表示点数，总长度，胶带的数量。对于输入的$n$个点，保证位置递增， 求覆盖所有的点所需的最小胶带长度（胶带数量$\leq k$）。</p>
<p>其实是个制杖题。我们考虑如果$k$是无限大，那么最优的方式一定是单点覆盖。所以如果胶带不够的话，就是要去额外多粘$N-k$个空白的区间。所以我们就可以排个序，求出$N-k$个空白区间的长度，再加上单点的长度和$n$，得到答案。注意空白区间的两头开的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;now), (i &gt; <span class="number">1</span> ? (d[i - <span class="number">1</span>] = now - Last - <span class="number">1</span>) : <span class="number">1</span>), Last = now ;</span><br><span class="line">nth_element(d + <span class="number">1</span>, d + N - K + <span class="number">1</span>, d + N) ; <span class="comment">//Last row, now - Last + 1 -&gt; now - Last</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N - K ; ++ i) Ans += d[i] ; Ans += N ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<p>emmm怎么说呢，是个显然又不显然的贪心，大概还是跟<code>OI素养</code>直接挂钩的吧（sigh</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p>
<p>题目简述    :    定义函数$f(a)$</p>
<script type="math/tex; mode=display">
f(a) = \max_{0 < b < a}{\gcd(a \oplus b, a \> \& \> b)}</script><p>给出 $q$ 个询问，每个询问为一个整数$a_i$。你需要对于每个询问，求出$f(a_i)$的值。$q=O(10^3),a=O(2^{25}).$</p>
<p>也算是比较巧妙的一道题，当然这个难度评级是给的分块打表的，毕竟思维难度摆在那里……首先我们考虑这个式子的结构，最大化一个gcd，那么我们不妨考虑如果$gcd(x,y)$,存在$x=0$或者$y=0$时，$gcd(x,y)=y$或者$gcd(x,y)=x$。</p>
<p>所以我们考虑，对于任意的$a$，我们只需要去尝试构造一种方案 ，使得$a\oplus b$最大并且$a~\&amp; ~b$最小。那么不妨考虑直接选一个与$a$所有位上都相反的数$b$，就可以保证$a~\oplus~b$最大且$a~\&amp;~b=0$，最后的答案就是$2^{k-1}-1$，其中$k$是二进制下$a$的位数。其中合法性是不言而喻的，因为根据构造，$b$的第$k$位（二进制位下最大的那一位）上必定是$0$，所以似乎就做完了？</p>
<p>然而并不是，因为$b\not =0$，所以当$~a=2^{w}-1，w\in \mathbb N~$时就会不合法。此处又有一个精妙的构造，我们发现当$a$的二进制位上都是$1$时，$\forall b&lt;a,\exists a  ~\&amp; ~b=b, a~\oplus~b=a-b$, 于是最后就相当于求$\max \gcd (a-b,b)$，运用辗转相除或者更相减损的思想可以立即看出是$\max \gcd(a,b)$，于是只需要找出$a$最大的因子就好了——此处暴力即可。</p>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 34000000</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span> &lt;MAXN&gt; check ; <span class="keyword">int</span> T, N, i, O ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fac</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span> ; i &lt;= x ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i)) <span class="keyword">return</span> (x /= i) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">25</span> ; ++ i) check[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) ;</span><br><span class="line">        <span class="keyword">if</span> (check[N]) </span><br><span class="line">            O = get_fac(N), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; i &lt;&lt;= <span class="number">1</span>, O = i) ; </span><br><span class="line">            O --, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说是一道比较神的的题了，Brainstorm，Brainstorm…..</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p>
<p>题目详述：你在玩一个叫做 <code>Jongmah</code> 的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。你只能使用手中的麻将，并且每个麻将只能使用一次。请求出你最多可以形成多少个三元组。</p>
<p><del>这道题准确预报了今年各省省选里面的毒瘤雀魂题</del></p>
<p>一道动态规划，感觉思路清新、解法自然<del>，给出题人点赞.</del> 然后底下是我丢到Luogu的题解：</p>
<blockquote>
<p>$dp.$</p>
<p>其实主要思想都差不多，但我发这篇$sol$为了阐明一种观点：复杂度同阶的$DP$，不同的状态设计，会导致代码难度、时空复杂度等截然不同。</p>
<p>我们定义状态$dp_{i,j_{1},j_{2}}$表示考虑了前$i$大序号的麻将($mahJong$)，其中有$j_{1}$个$[i - 1, i, i + 1]$类型、有$j_{2}$个$[i, i + 1, i + 2]$类型的组合，最多组成多少个三元组。</p>
<p>这样定义状态的原因是：我们发现如果单纯用$1$维状态转移，那么状态势必是“前$i$大序号的麻将包含的三元组个数”，但是此状态不明确——无法准确定义“包含”的意思。而此处我们定义包含指<strong>三元组右端点也$\leq i$</strong>，那么$[i - 1, i, i + 1]$和$[i, i + 1, i + 2]$便需要单独定义出来。</p>
<p>转移的时候直接枚举有多少个$[i + 1,i+2, i+3]$即可（因为我们使用$i$更新$i+1$而不是用$i-1$更新$i$，如是做细节少、思考难度小）</p>
</blockquote>
<p>然后转移的时候也要顺便计算$[i,i,i]$的数量。而由于如果存在三个$[i,i+1,i+2]$，那么我们直接拆成三个$[i,i,i]$，三个$[i+1,i+1,i+1]$, 三个$[i+2,i+2,i+2]$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Sum[ qrd() ] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">3</span> ; ++ k)</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span> ; l &lt; <span class="number">3</span> ; ++ l)</span><br><span class="line">                <span class="keyword">if</span> (Sum[i] &lt; j + k + l) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> dp[i][k][l] = max(dp[i][k][l], dp[i - <span class="number">1</span>][j][k] + (Sum[i] - j - k - l)/<span class="number">3</span> + l) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[M][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p>
<p>题目简述：给定数列$c$和$t$，每次操作都可以选择一个$1&lt;i&lt;n$，令$c_i$变成$c_i’$，其中$c_i’=c_{i+1}+c_{i-1}-c_i$。问是否可以经过若干次操作，使得$\forall c_i=t_i$. </p>
<p>……我管这种题叫做“疯狂暗示题”，其实也是一种做题技巧的问题。打完比赛反思了一下，似乎有好几个关键信息没有捕捉到。比如说“若干次操作”，没有限定操作次数，就说明无论怎么操作，其背后一定有某些本质不变的东西，否则应该出成一个交互题，在$k$步之内完成任务的那种感觉。而同时，每次操作一个$c_i$，都只会跟$c_{i-1}$、$c_{i+1}$有关。所以，一切的一切都在引导我们向<code>差分</code>靠拢。</p>
<p>我们思考对于一个$c_i$，令其满足$c_{i-1}+d_1=c_i, ~c_i+d_2=c_{i+1}$，那么我们新的$c_i’$就是</p>
<script type="math/tex; mode=display">
c_i'=c_i-d_1+c_i+d_2-c_i=c_i-d_1+d_2</script><p>那么我们就会发现</p>
<script type="math/tex; mode=display">
c_{i+1}-c_i' = d_1\\\ c_i'-c_{i-1} = d_2</script><p>换句话说，其实就是相邻两个差换了位置！那么也就是说无论怎样，差分数组里面每个数出现的次数都是不变的，直接排个序检查就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]) ;</span><br><span class="line">   <span class="keyword">if</span> (A[<span class="number">1</span>] != B[<span class="number">1</span>] || A[N] != B[N]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Da[i] = A[i] - A[i - <span class="number">1</span>] ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Db[i] = B[i] - B[i - <span class="number">1</span>] ;</span><br><span class="line">   sort(Da + <span class="number">2</span>, Da + N + <span class="number">1</span>), sort(Db + <span class="number">2</span>, Db + N + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Da[i] != Db[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ; <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br></pre></td></tr></table></figure>
<p>感觉其实$C/D/E$都是比较好的思维题……但是接下来一个就不是了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<p>题目简述 ：给定一棵以$1$为根的$n$个节点有根树， 给定$m$次询问， 形如 <code>v l r</code>， 输出以$v$为起点，终点编号为$l$ ~$r$以内的叶子中最短的路径距离。</p>
<p>根据dfs序的相关知识，我们需要一棵线段树来维护dfs序上的路径长度最小值。但是很多人（比如我）会认为一定需要线段树上个树什么的，但其实有更简单的策略。</p>
<p>不妨直接令当前点到其他所有的点的距离是一个数组$dis$。思考如果我们把当前点的当前子节点设为$x$, 那么我们如果向下递归$x$，就会有$x$到$x$子树内的所有节点的$dis$，比其父亲的dis都小一个$E[k].v$，$x$到其他节点的距离都会大一个$E[k].v$，那么就如同状态转移一样，每次向下递归的时候先统计一遍$Ans$，再更新一下距离即可。</p>
<p>其实这个题是一个$tricky$题，比如我们为了用一个dis数组表示到叶子的距离，可以把非叶子之间的距离都设成$\rm{Inf}$ ；比如我们为了飞速统计答案，可以把询问离线下到一个<code>vector</code>里面，在dfs的时候直接统计出全部答案。</p>
<p>不失为一道好题啊qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf (1LL &lt;&lt; 55)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ; ll c ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, A, i, q ; </span><br><span class="line">ll tag[MAXN &lt;&lt; <span class="number">2</span>], S[MAXN &lt;&lt; <span class="number">2</span>], Ans[MAXN], dis[MAXN], B ;</span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN], Last[MAXN], Lr[MAXN], Rr[MAXN] ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; query[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">max</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	Last[u] = u ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; </span><br><span class="line">		dis[to(k)] = dis[u] + E[k].c ; </span><br><span class="line">		dfs(to(k), u), Last[u] = max(Last[u], Last[to(k)]) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].c = w, </span><br><span class="line">	E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].c = w, </span><br><span class="line">	E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123; </span><br><span class="line">	S[rt] = min(S[rt &lt;&lt; <span class="number">1</span>], S[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tag[rt] == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	rr <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">	tag[lc] += tag[rt], tag[rc] += tag[rt], </span><br><span class="line">	S[lc] += tag[rt], S[rc] += tag[rt], tag[rt] = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">		S[rt] += k, tag[rt] += k ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	push_down(rt) ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul ,ur, k) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, k) ; push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		S[rt] = dis[l] ; <span class="keyword">return</span> ; </span><br><span class="line">	&#125; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">querys</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">	rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; rr ll res = Inf ; push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (ql &lt;= mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr)) ;</span><br><span class="line">	<span class="keyword">if</span> (qr &gt; mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr)) ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k : query[u]) </span><br><span class="line">		Ans[k] = querys(<span class="number">1</span>, <span class="number">1</span>, N, Lr[k], Rr[k]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line"> 		update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], -(E[k].c &lt;&lt; <span class="number">1</span>)), </span><br><span class="line">		work(to(k), u) ; update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, -E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], E[k].c &lt;&lt; <span class="number">1</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>, &amp;A, &amp;B), Add(A, i, B) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q, &amp;Lr[i], &amp;Rr[i]), query[q].push_back(i) ; </span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (i != Last[i]) dis[i] = Inf ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="comment">// by _pks</span></span><br><span class="line">	work(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// by _pks by _pks by _pks by_pks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>by_pks其实是用来占位的因为我喜欢同一个代码块里，每一行的长度都是递增的XD</del></p>
<h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt></p>
<p>题目大意：给出一棵N个点的树，初始时某些节点是白色，其他节点没有颜色，有两个人在树上博弈。每一回合，一方可以将一个没有颜色的点染成白色，然后另一方可以将一个没有颜色的点染成黑色。如果在某次染色后树上存在三个点ABC满足有边$(A,B)(B,C)$且ABC都有颜色且颜色相同，则该颜色对应的人获胜。假设两人绝顶聪明，问最后结果如何。$T\leq 5e5,\sum n\leq 5e5$</p>
<p>emmmm一道我不会的题。其实总觉得这种博弈论有一种一脉相承的精妙之处，但是自己总是不能稔熟于心……GG</p>
<p>然后我选择搬了<code>Itst</code>巨佬的思路过来</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>首先我们考虑，黑色是不可能获胜的，毕竟原来就已经有一堆白点了……</p>
<p>其次我们考虑先忽略原树中的所有已经被染过色的点，然后用一种比较前卫的方式来分类讨论——<code>度数讨论法</code>。</p>
<ul>
<li>假设有一个点的度数$\geq 4$，换句话说这个联通块的点的个数要$\geq 5$，那么根据白色先手的原则，白色的一定可以取$3$个节点，并且一定可以取$3$个连续的节点。所以白色赢；</li>
<li>如果存在一个点的度数$=3$，且它所连的$3$个点至少有$2$个点不是叶子节点，那么我们如果考虑讲树平展开之后，先选中间的点，就可以保证白色赢；</li>
<li>其余的情况我们可以考虑大力分类讨论树的形态：<img src="1.png" alt></li>
</ul>
<p>我们发现，对于前两种情况都是draw的。而对于第三种情况，如果总点数是<strong>奇数个</strong>，那么<strong>白色必赢</strong>。我们考虑从左向右染色，白色第一次考虑染从左往右第二个非叶子节点，那么黑色只能染第一个；白色染第四个，黑色只能染第三个……以此类推。到最后一定会出现白色染了$2n$这个点，黑色去染$2n-1$这个点，那么白色接下来就可以染$2n+1$这个点，Winner！</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>接下来我们如果要算上原本就是白色的点呢？对于这种情况，一般都是转化回我们已经讨论完的<code>0x01</code>去。我们考虑把一个白色点拆成$4$个无色点。<img src="2.png" alt></p>
<p>其中A就是原来的$1$号点，原图上哪些点跟$1$连了边，现在也和$A$连，换句话说就是$A$多了一棵三个节点的子树。那么接下来我们考虑其可行性。</p>
<ul>
<li>如果$A$被染成黑色，那么白色没有必要再染子树内的点，这种情况等价于不连子树。</li>
<li>如果$A$被染成白色，那么黑色一定要染$B$点，那么此时这棵子树又没用了，所以也等价于不连子树。</li>
</ul>
<p>嗯，然后这个题就完了。我们可以发现就是一个大力分类讨论的过程——题还是挺好的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Input[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> In[MAXN], qaq ;</span><br><span class="line"><span class="keyword">int</span> T, N, head[MAXN], A, qwq, B, i, j, ans, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, In[v] ++ ;</span><br><span class="line">	E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, In[u] ++ ; </span><br><span class="line">	E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N), ++qwq ;</span><br><span class="line">		fill(In, In + N + <span class="number">4</span>, <span class="number">0</span>) ;</span><br><span class="line">		fill(head, head + N + <span class="number">4</span>, <span class="number">0</span>), ans = <span class="number">0</span>, qaq = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, Input) ; <span class="keyword">if</span> (N &lt; <span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">"Draw"</span>) ; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) ans += Input[i] == <span class="string">'W'</span> ;</span><br><span class="line">			<span class="built_in">puts</span>(ans &gt;= <span class="number">2</span> ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> Linshi = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">				<span class="keyword">if</span> (Input[i] == <span class="string">'W'</span>)&#123;</span><br><span class="line">					head[++ N] = <span class="number">0</span>, Add(i + <span class="number">1</span>, N), In[N] = <span class="number">3</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N &amp;&amp; ans &lt;= <span class="number">0</span>; ++ i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (In[i] &gt; <span class="number">3</span>) ans ++ ;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="number">3</span>)&#123; Linshi = <span class="number">0</span> ;</span><br><span class="line">					<span class="keyword">for</span> (j = head[i] ; j ; j = E[j].next) Linshi += (In[to(j)] &gt;= <span class="number">2</span>) ;</span><br><span class="line">					ans += Linshi &gt; <span class="number">1</span>, qaq ++ ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (qaq == <span class="number">2</span> &amp;&amp; (N % <span class="number">2</span>)) ans ++ ; <span class="built_in">puts</span>(ans ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 		if (qwq == 20) return 0 ;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Global Round的题目质量不低蛤。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/构造</tag>
        <tag>动态规划/普通DP</tag>
        <tag>树模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究向】主席树上的不靠谱解法</title>
    <url>/2019/04/05/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E4%B8%8A%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>yy出来的假复杂度做法，但是据说有一个很强的剪枝？</p>
<a id="more"></a>
<h1 id="rm-0x00-Preface"><a href="#rm-0x00-Preface" class="headerlink" title="$\rm{0x00~}Preface$"></a>$\rm{0x00~}Preface$</h1><p>某天机房里，<del>公认的ezi</del> lwy跟wxl随口说了一道luogu上的题，wxl来了兴趣，被pks听见了，于是pks就瞅了一眼这题，然后说了一句”这不就是sb主席树上二分吗？随便一个$\Theta(n \log^2n)$就可以过啊”</p>
<p>然后pks那一整个晚上都在搞这个假算法，$\rm{QAQ}$</p>
<p>于是就有了本文，整理了两道主席树的正确（？）应用。</p>
<h1 id="rm-0x01-faebdc的烦恼"><a href="#rm-0x01-faebdc的烦恼" class="headerlink" title="$\rm{0x01~}$faebdc的烦恼"></a>$\rm{0x01~}$faebdc的烦恼</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P1997" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1997</a></p>
<p>呃，其实这不是一道很难的题。因为本来就保证了数列不降，所以我们直接记录一下每个数出现区间的左右端点，瞎搞就好。但是既然我说了要主席树上二分，就一定要写写看吧qaq</p>
<p>我们考虑在我的<a href>这篇博客</a>里面曾经介绍过的$T3$中的算法，我们直接去查询左右儿子值域区间内中数的个数，看看哪个可行，然后暴力找就好。</p>
<p>但是…他TLE了两个点，因为我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; </span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (sum[Right] - sum[Left] &lt; k) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>),Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>), </span><br><span class="line">	  T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++) </span><br><span class="line">      pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, </span><br><span class="line">  		T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           	<span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid) &gt; <span class="number">0</span>) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像很正常？但是，这个复杂度是完全错误的。最大的时候甚至可以到达单次$m \log n$的复杂度——注意是单次。因为我们每次询问的时候，如果查询了左区间不合法，那么不代表右区间合法——毕竟是二分里的<code>check</code>环节。而上一个类似方法的题，可以保证我们如果左区间的数的出现次数不超过$\frac{1}{2}$，那么右区间一定满足——但显然的是，本题不具有这个性质。</p>
<p>所以，总结一下，主席树上不可以二分。</p>
<p>但是如果我们加一点剪枝呢？</p>
<p>我们考虑，对于主席树上的每一个点维护一个$maxx$一个$minx$，记录区间内<strong>单个数值出现的最大次数和最小次数</strong>，那么我们在$check$的时候就可以直接用这种方式判——如果$r$版本的主席树内出现的最大次数减去$l-1$版本内出现的数的最小次数$k&lt;q$（$q$是二分出的$val$），那么一定不满足。</p>
<p>比较显然的是，这不是一种最优性剪枝，而是一种可行性剪枝。但是对付这道题却有着不错的效果，跑的奇快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD 393216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100073</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> a, b, c, pos, N, base[MAXN], mx[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], mn[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], aft[MAXN], M, i ;</span><br><span class="line"><span class="keyword">int</span> cnt, Len, T[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], L[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], R[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], sum[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ; &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;last, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> rt = ++ cnt, mid ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span>, R[rt] = R[last], L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">    	mx[rt] = mn[rt] = sum[rt] ; </span><br><span class="line">        <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">    <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    mn[rt] = min(mn[L[rt]], mn[R[rt]]), mx[rt] = max(mx[L[rt]], mx[R[rt]]) ;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">1</span> ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (mx[L[Right]] - mn[L[Left]] &gt;= k &amp;&amp; query(L[Left], L[Right], l, mid, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mx[R[Right]] - mn[R[Left]] &gt;= k &amp;&amp; query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M; <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>), Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        a = qr(), b = qr() ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, mid, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           	mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid)) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-0x02-CF840D-Destiny"><a href="#rm-0x02-CF840D-Destiny" class="headerlink" title="$\rm{0x02~}CF840D~Destiny$"></a>$\rm{0x02~}CF840D~Destiny$</h2><p>传送门：<a href="http://codeforces.com/problemset/problem/840/D" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/840/D</a></p>
<p>简化版题意：每次给出三个参数$l,r,k$，询问区间$[l,r]$内是否存在出现次数严格大于$\frac{r-l+1}{k}$的数。如果存在就输出最小的那个$ans$，否则输出$-1$.</p>
<p>这个东西……就直接查询就好了啊……由于不用二分，所以复杂度相对来说稳定了一些。于是我就没有加上文中提到过的那个诡异的优化。我们每次先查左半边，就可以保证在值域上最小，也就是说每次我们都可以求出最小的合法$ans$了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        L[rt] = build(l, mid) ;</span><br><span class="line">        R[rt] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    R[rt] = R[last] ;</span><br><span class="line">    L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">        <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; <span class="keyword">int</span> qwq ;</span><br><span class="line">    <span class="comment">// if (sum[Right] - sum[Left] &lt;= k) return -1 ;</span></span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) </span><br><span class="line">		<span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; k) </span><br><span class="line">		<span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) base[i] = qr(), aft[i] = base[i] ;</span><br><span class="line">    sort(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) ;</span><br><span class="line">    Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ; </span><br><span class="line">    T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft;</span><br><span class="line">        T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c) ; <span class="keyword">int</span> k = (b - a + <span class="number">1</span>) / c ;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, k) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，加上那优化之后，总用时大约$27000ms$，而我这个不加优化的版本足足跑了$56677ms$……真丢人啊</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构/可持久化/可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>防守战线[ZJOI2013] &amp; 志愿者招募[NOI2008]</title>
    <url>/2019/04/05/fszx-and-zyzzm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x01-ZJOI2013-防守阵线"><a href="#rm-0x01-ZJOI2013-防守阵线" class="headerlink" title="$\rm{0x01}$ [ZJOI2013]防守阵线"></a>$\rm{0x01}$ [ZJOI2013]防守阵线</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3337" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3337</a></p>
<p>首先就是要明白怎么建模，大概就是：</p>
<script type="math/tex; mode=display">
\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots n)\\\
\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} x_{j} \geq d_i \quad (i = 1,2,3\cdots m)</script><p>其中$x_j$表示$j$这个地方有几座塔。</p>
<p>那我们首先把它对偶过去，就会得到：</p>
<script type="math/tex; mode=display">
\text{最大化} \quad \sum d_iy_i \quad(i = 1, 2,3 \cdots m) \\\
\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} y_{j} \leq c_i\quad (i = 1,2,3\cdots n)</script><p>然后我们考虑，似乎价值不能带小数啊，毕竟题目中规定了价值都为整数<del>(事实上并没有规定但是数据是这样给的)</del>，换句话说我们不能存在建某座塔的一部分(比如只建一半)。</p>
<p>那么这就是<strong>整数线性规划问题</strong>，换句话说就是<strong>自变量取值范围是$\Z$的线性规划</strong>。</p>
<p>呃，这问题已经被证明是$\rm{NP-Hard}$的问题了…但是，有一种矩阵叫做<strong>全幺模矩阵</strong>，即<strong>元素只会是$\boldsymbol{0,1,-1}$的矩阵</strong>，被证明肯定至少有一组最优解保证整数线性规划与实数线性规划的方案一致。</p>
<p><del>啥，你说啥？你要关于全幺模矩阵这个性质的争鸣？是百家争鸣那个争鸣吗？学OI呢别瞎讨论历史</del> </p>
<p>然后就可以一发单纯形给艹过去啦~开心心~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e9</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">double</span> A[MAXN][MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M, B, E, i, j, k, p ; <span class="keyword">double</span> res, t, cost[MAXM], _need[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">	cost[l] /= A[l][e], t = A[l][e], A[l][e] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) A[l][i] /= t ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (i != l &amp;&amp; <span class="built_in">abs</span>(A[i][e]) &gt; eps)&#123;</span><br><span class="line">			cost[i] -= A[i][e] * cost[l] ;  </span><br><span class="line">			<span class="keyword">for</span> (p = <span class="number">1</span> ; p &lt;= M ; ++ p) <span class="keyword">if</span> (p != e) A[i][p] -= A[i][e] * A[l][p] ;</span><br><span class="line">			A[i][e] = - A[i][e] * A[l][e] ;</span><br><span class="line">		&#125; </span><br><span class="line">	res += _need[e] * cost[l] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) _need[i] -= _need[e] * A[l][i] ;</span><br><span class="line">	_need[e] = - _need[e] * A[l][e] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">double</span> MINX = INF ; j = <span class="number">0</span>, k = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="keyword">if</span> (j &gt; M) <span class="keyword">return</span> res ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MINX &gt; cost[i] / A[i][j]) k = i, MINX = cost[i] / A[i][j] ;</span><br><span class="line">		<span class="keyword">if</span> (MINX &gt;= INF) <span class="keyword">return</span> INF ;  Pivot(j, k) ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cost[i]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;B, &amp;E, &amp;_need[i]) ; <span class="comment">//约束 </span></span><br><span class="line">		<span class="keyword">for</span> (j = B ; j &lt;= E ; ++ j) A[j][i] = <span class="number">1.0</span> ;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex() + <span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么说呢，似乎单纯形有好多地方的写法都比较灵活<del>让我不知道背什么样的板子会更好</del></p>
<h1 id="rm-0x02-NOI2008-志愿者招募"><a href="#rm-0x02-NOI2008-志愿者招募" class="headerlink" title="$\rm{0x02}$ [NOI2008] 志愿者招募"></a>$\rm{0x02}$ [NOI2008] 志愿者招募</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3980</a></p>
<p><del>什么鬼啊这不是上面的那道题吗</del></p>
<p>还是：</p>
<script type="math/tex; mode=display">
\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots m)\\\
\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \geq A_i \quad (i = 1,2,3\cdots n)</script><p>其中$x_j$表示选择的第$j$类志愿者的个数，$w_{i,j}$表示在第$i$天，第$j$类志愿者能否选择。那么还是老样子，对偶过去就可以得到：</p>
<script type="math/tex; mode=display">
\text{最大化} \quad \sum A_ix_i \quad(i = 1,2,3\cdots n)\\\
\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \leq c_i \quad (i = 1,2,3\cdots m)</script><p>怎么说呢……这个一开始的建模比上一个题还是有难度的，因为上一个题的$L_i,R_i$跟约束有关，而这次的$L_i,R_i$则是跟目标函数有关——或许不应该这么说，但是看上去确实不如上面那题跟约束有关系就对了<del>(我在BB一堆什么啊)</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span> ; <span class="keyword">double</span> res ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> b[MAXM], e[MAXM] ; </span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k ; <span class="keyword">double</span> C[MAXM], _need[MAXM], A[MAXM][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> posN, <span class="keyword">int</span> posC)</span></span>&#123;</span><br><span class="line">	C[posC] /= A[posC][posN] ; <span class="comment">// constraint divided by A_&#123;l,e&#125;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) A[posC][p] /= A[posC][posN] ;<span class="comment">//this line Booom</span></span><br><span class="line">	A[posC][posN] = <span class="number">1</span> ;</span><br><span class="line">	<span class="comment">// Pivot is above, taking it back is below</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= M ; ++ p)<span class="comment">//taking back to constraints </span></span><br><span class="line">		<span class="keyword">if</span> (p != posC &amp;&amp; <span class="built_in">fabs</span>(A[p][posN]) &gt; eps)&#123;</span><br><span class="line">			C[p] -= A[p][posN] * C[posC] ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">				<span class="keyword">if</span> (i != posN) A[p][i] -= A[p][posN] * A[posC][i] ;</span><br><span class="line">			A[p][posN] = <span class="number">0</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	res += _need[posN] * C[posC] ;<span class="comment">//this time results in a better INIT-Sol</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) _need[p] -= _need[posN] * A[posC][p] ;</span><br><span class="line">	_need[posN] = - _need[posN] * A[posC][posN] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		j = <span class="number">0</span>, k = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="comment">/*1*/</span> <span class="keyword">if</span> (j &gt; N) <span class="keyword">return</span> res ; <span class="comment">//make-it-sure if go on</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MAX &gt; C[i] / A[i][j]) MAX = C[i] / A[i][j], k = i ; <span class="comment">//find the min_val constraint</span></span><br><span class="line">		<span class="keyword">if</span> (MAX &gt;= INF) <span class="keyword">return</span> INF ; <span class="comment">/* this task is unbounded */</span> Pivot(j, k) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; _need[i] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;b[i], &amp;e[i], &amp;C[i]) ;</span><br><span class="line">		<span class="keyword">for</span> (j = b[i] ; j &lt;= e[i] ; ++ j) A[i][j] = <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex()+<span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$Candy?$的$blog$ <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】1·较简单的费用流</title>
    <url>/2019/03/29/nw-flow-24-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要包括三个问题：运输问题，分配问题和数字梯形问题。</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<h1 id="rm-Preface"><a href="#rm-Preface" class="headerlink" title="$\rm{Preface}~$"></a>$\rm{Preface}~$</h1><p>关于网络流，一直是我的一个阴影……因为去年暑假，大家都会而网络流，我因为觉得这个算法没意思就没学，结果rqy来给我们考试网络流那题被全场打爆了——除了我qaq。</p>
<p>于是决定开始做这些题，每道题都会标注我看题解程度多少，如果太高的话会被自己嫌弃的qaq……希望自己能争气一点。</p>
<h1 id="rm-0x01-运输问题"><a href="#rm-0x01-运输问题" class="headerlink" title="$\rm{0x01}$ 运输问题"></a>$\rm{0x01}$ 运输问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4015" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4015</a></p>
<p>看了，程度大概80%……呃我知道这个题不难，但是毕竟我上次写费用流可是几百年之前了啊……qaq</p>
<p>其实就是</p>
<script type="math/tex; mode=display">
S\stackrel{f = a_i,c = 0}{\longrightarrow}i \stackrel{f = Inf,c = c_{i,j}}{\longrightarrow}j \stackrel{f = b_j,c=0}{\longrightarrow}T</script><p>其中$i$代表仓库的编号，$j$代表商店的编号，建完图跑费用流即可。</p>
<p>由于SPFA死了，所以就一直用$dijk$做费用流，只不过难背一点……然后第二问的话就把权值取负重新做一下费用流就好。</p>
<p>总结一下，这个题似乎是比较裸的费用流的题了？一般费用流大概都是用来求解最优化问题的吧qwq……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> S, T, N, M, dist[MAXN], i, j, k, t[MAXN], x ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dist, num ;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> Last[MAXN], F[MAXN], H[MAXN], Pre[MAXN], MAX_C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].c = c, t[cnt] = f ;</span><br><span class="line">	E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].c = -c, t[cnt] = <span class="number">0</span> ;</span><br><span class="line">	E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; vis[S] = dist[S] = <span class="number">0</span>, F[<span class="number">0</span>] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i) dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		node now = q.top() ; q.pop() ;</span><br><span class="line">		<span class="keyword">int</span> fr = now.num, sec = now.dist ; <span class="keyword">if</span> (vis[fr]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">for</span> (vis[fr] = <span class="number">1</span>, k = head[fr] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> nowc = sec + E[k].c + H[fr] - H[to(k)] ;</span><br><span class="line">			<span class="keyword">if</span> (E[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[to(k)] &amp;&amp; dist[to(k)] &gt; nowc)&#123;</span><br><span class="line">				dist[to(k)] = nowc, q.push((node)&#123;dist[to(k)], to(k)&#125;) ;</span><br><span class="line">				F[to(k)] = min(F[fr], E[k].f), Pre[to(k)] = fr, Last[to(k)] = k ; </span><br><span class="line">			&#125;<span class="comment">//!!!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">		_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">		<span class="keyword">while</span>(_Ed != S)	E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*	cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, S = <span class="number">0</span> ; </span><br><span class="line">	T = N + M + <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(S, i, x, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, T, x, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	</span><br><span class="line">		<span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + M ; ++ j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, j, Inf, x) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= cnt ; ++ i) printf("%d %d %d\n", E[i].to + 1, E[i].f, E[i].c) ;</span></span><br><span class="line">	MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i], E[i].c = -E[i].c ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x02-分配问题"><a href="#rm-0x02-分配问题" class="headerlink" title="$\rm{0x02~}$ 分配问题"></a>$\rm{0x02~}$ 分配问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4014" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4014</a></p>
<p>这道题由于实在太水了，所以没有看题解(窃喜</p>
<p>其实就是建$2n$个点，然后$i \stackrel{f = Inf,c = base_{i,j}}{\longrightarrow} j$就连完了。</p>
<p>不得不说…建边真的是太水了，太水了，qaq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">此处是dijkstra……</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">		_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">		<span class="keyword">while</span>(_Ed != S)	E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*	cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + N ; ++ i) Add(i, T, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + N ; ++ j)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x, Add(i, j, Inf, x) ;</span><br><span class="line">	MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].c = -E[i].c, E[i].f = t[i] ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x03-数字梯形问题"><a href="#rm-0x03-数字梯形问题" class="headerlink" title="$\rm{0x03}~$数字梯形问题"></a>$\rm{0x03}~$数字梯形问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4013" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4013</a></p>
<p>看题解：$90\%$+…我是真没见过这种建边方式啊喂，并且我一开始建的边很迷…我没有看到，呃，换句话说，我看到了然后忘了，一个数只能向正下方和右下方走……</p>
<h2 id="第一问·完全不相交的路径"><a href="#第一问·完全不相交的路径" class="headerlink" title="第一问·完全不相交的路径"></a>第一问·完全不相交的路径</h2><p>我真是要菜死了，题解里面说”拆点已经是烂大街的$trick$了”，我：？？？</p>
<p>大概就是每个点拆成两个点，原因是我们需要<strong>把点上的限制转化成边上的限制</strong>，所以需要进行拆点，然后对于某个点和它的副本连一条$f=1,c=-base[x]$的边，毕竟是求最大值。然后$S$和最顶上的连$f=1,c=0$的边，$T$和最下面一层连$f=1,c=0$，就完了。</p>
<h2 id="第二问-·-边不相交的路径"><a href="#第二问-·-边不相交的路径" class="headerlink" title="第二问 · 边不相交的路径"></a>第二问 · 边不相交的路径</h2><p>我们考虑此时其实是删除了点的限制，那么我们就将每个点和自己的副本之间的边容量改成$Inf$，并把$T$与最底下的所有点的容量扩为$Inf$即可。注意后半部分的扩容，其目的在于防止中间节点的扩容被限制。</p>
<h2 id="第三问-·-随便的路径"><a href="#第三问-·-随便的路径" class="headerlink" title="第三问 · 随便的路径"></a>第三问 · 随便的路径</h2><p>既然都随便了，就直接把所有的边都设置成$Inf$，但是显然的是我们不能扩$S$连出去的边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijk</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) </span><br><span class="line">		dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">	dist[S] = <span class="number">0</span>, q.push((Node)&#123;S, <span class="number">0</span>&#125;) ;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		Node now = q.top() ; q.pop() ;</span><br><span class="line">		<span class="keyword">int</span> num = now.num, dis = now.dist ; <span class="keyword">if</span> (vis[num]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[num] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> DIS = E[k].c + H[num] - H[to(k)] + dis ;</span><br><span class="line">			<span class="keyword">if</span> (DIS &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f)</span><br><span class="line">				F[to(k)] = min(F[num], E[k].f), dist[to(k)] = DIS, </span><br><span class="line">				q.push((Node)&#123;to(k), DIS&#125;), Pre[to(k)] = num, Last[to(k)] = k ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Ans = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (dijk())&#123;</span><br><span class="line">		_End = T, Ans += (dist[T] - H[S] + H[T]) * F[T] ;	</span><br><span class="line">		<span class="keyword">while</span> (_End) E[Last[_End]].f -= F[_End], E[Last[_End] ^ <span class="number">1</span>].f += F[_End], _End = Pre[_End] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; -Ans &lt;&lt; endl ;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L1, R1, L ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N ; S = <span class="number">0</span>, T = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j) </span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = (tot += <span class="number">2</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) Add(S, Id[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>) ; L = cnt + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (L1 = cnt + <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N + M ; ++ i) Add(Id[N][i] + <span class="number">1</span>, T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">			Add(Id[i][j], Id[i][j] + <span class="number">1</span>, <span class="number">1</span>, -base[i][j]) ; R1 = cnt ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">			<span class="keyword">if</span> (i &lt; N) Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>), Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; </span><br><span class="line">	<span class="keyword">for</span> (i = L1 ; i &lt; R1 ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line">	<span class="keyword">for</span> (i = L1 + <span class="number">1</span> ; i &lt;= R1 ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ;</span><br><span class="line">	<span class="keyword">for</span> (i = L ; i &lt; cnt ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line">	<span class="keyword">for</span> (i = L + <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ; </span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/*  以下是错误的建边 </span></span><br><span class="line"><span class="comment">	for (i = 1 ; i &lt;= M ; ++ i) </span></span><br><span class="line"><span class="comment">		cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ;</span></span><br><span class="line"><span class="comment">	for (i = 1 ; i &lt; N ; ++ i)</span></span><br><span class="line"><span class="comment">		for (j = 1 ; j &lt;= M + i ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">			cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ;</span></span><br><span class="line"><span class="comment">			for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, Inf, -base[tot]) ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">	<span class="comment">/*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，大概这三个题就先分成一组吧！</p>
]]></content>
      <categories>
        <category>网络流二十四题</category>
      </categories>
      <tags>
        <tag>网络流/费用流</tag>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title>随想七 · 言葉の庭</title>
    <url>/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>​    Hello darkness my old friend. 黯淡如旧，今时重逢。<br>​    I’ve come to talk with you again. 阔别久日，可赴低叙？<br>​    Because a vision softly creeping. 如梦如幻，于我心萦。<br>​    Left its seeds while I was sleeping. 遗之入梦，齐我心同。<br>​    And the vision that was planted in my brain. 不知归处，不知归处。<br>​    Still remains with the sound of silence. 行舟如风，遣舟迟暮。<br>​    In restless dreams I walk alone. 吾心独行，兰皋止息。<br>​    Narrow streets of cobble stone. 越陌度阡，可有一醉？<br>​    Beneath the hallo of a street lamp’, 如光化影，于我心寂。<br>​    I turned my collar to the cold and damp. 浊寒入襟，刺我心底。<br>​    When my eyes were stabbled. 所见皆幻，所见皆明。<br>​    By the flash of a neon light. 万物皆虚，万物皆允。<br>​    That split the night. 不知归处，不知归处。<br>​    And touched the sound of silence 星瀚灿漫，行人慢走。</p>
<p>​    ——『$\rm{The ~Sound~of~Silence}$』寂静之声</p>
</blockquote>
<p>随想系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<p>这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。</p>
<hr>
<h1 id="rm-Part-1"><a href="#rm-Part-1" class="headerlink" title="$\rm{Part~1}$"></a>$\rm{Part~1}$</h1><p>月考结束了。我终于有时间把这本书读完。</p>
<p>之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。</p>
<p>我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。</p>
<p>但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。</p>
<p>《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。</p>
<p>那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。</p>
<p>并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。</p>
<p>或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。</p>
<h1 id="rm-Part-2"><a href="#rm-Part-2" class="headerlink" title="$\rm{Part~2}$"></a>$\rm{Part~2}$</h1><p>感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。</p>
<p>连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。</p>
<p>我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。</p>
<p>所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。</p>
<p>……</p>
<p>说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如……</p>
<p>但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。</p>
<p>现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套……</p>
<p>我不知道为什么。</p>
<p>总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。</p>
<p>我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了……</p>
<p>突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。</p>
<p>这绝对是我读过的最美的故事了。</p>
<h1 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h1><p>现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。</p>
<p>“这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。</p>
<p>但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。</p>
<p>我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。</p>
<p>……</p>
<p>读完之后，后记里面新海诚是这么描述的：</p>
<blockquote>
<p>我一直单恋着小说。<br>不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一<br>种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再<br>想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。</p>
<p>……</p>
<p>写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到<br>「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？<br>这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人<br>一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这<br>种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的<br>声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到<br>耳机声音外溢云云。<br>我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回<br>顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。</p>
<p>……</p>
<p>写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两<br>情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多<br>多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物<br>的心编织出这个世界。而本书想要描述的就是这点。<br>在「爱」以前，这是段「孤独希求」的故事。<br>这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋<br>爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。</p>
</blockquote>
<p>我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。</p>
<h1 id="rm-Part-4"><a href="#rm-Part-4" class="headerlink" title="$\rm{Part~4}$"></a>$\rm{Part~4}$</h1><p>选了几段放到这里，留作纪念。</p>
<p>首先是最后，孝雄和雪野重逢的情景：</p>
<blockquote>
<p>走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自<br>制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、<br>杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。<br>孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅<br>粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带<br>上缝着枫叶的形状。<br>这双鞋是为了那个人打造，一定可以走得更长更远。<br>不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。<br>——隐约雷鸣。<br>孝雄脱口而出这句话。<br>一股预感充满全身。<br>已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。<br>孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼<br>帘。<br>那是一位穿着浅绿色裙子的女人。<br>孝雄停下脚步。<br>有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。<br>看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。<br>孝雄心想，雨好像停了。</p>
</blockquote>
<p>然后是孝雄表白完、雪野拒绝后，雪野的心声：</p>
<blockquote>
<p>「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。<br>不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的<br>门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却<br>觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。<br>这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。<br>不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地<br>对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的<br>人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个<br>耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生<br>活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出<br>现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现<br>了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光<br>是不让自己蹲下，就必须耗费莫大的力气。<br>听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干<br>的制服。<br>「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便<br>朝着玄关走去。<br>「啊！」<br>雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，<br>不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的<br>声音，转开门把的声音。然后——</p>
<p>啪嗒。关门的声音。<br>那一瞬间，雪野突然感到很气愤。<br>「笨蛋！」<br>她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时<br>泄气地慢慢放下椅子，再次坐了下来。<br>「……笨蛋。」她小声地又说了一次。<br>秋月那个笨蛋。<br>一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑<br>假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃<br>饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。<br>一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一<br>切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续<br>冷却着。<br>——结束这段时光的人，是你啊！<br>雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换<br>连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，<br>静静地结束我们的关系。<br>其实我一直在忍耐。<br>其实我一直没有说出口。<br>其实我一直没有说出来过——</p>
<p>我喜欢你。</p>
</blockquote>
<p>还有两段段很有名的摘录下来：</p>
<blockquote>
<p>二十七岁的我，丝毫不比十五岁时候的我聪明。<br>雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想<br>着。</p>
</blockquote>
<p>还有孝雄的情感爆发：</p>
<blockquote>
<p>孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」<br>仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，<br>说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」<br>吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才<br>露出这副表情的她。<br>「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和<br>歌。」孝雄说着。<br>过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。<br>「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑<br>鄙！」<br>讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！<br>「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现<br>的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」<br>讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。<br>「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知<br>道！」<br>我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我<br>讨厌你！<br>「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」<br>但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更<br>加喜欢你。<br>「你就一直那样……」<br>——开什么玩笑，怎么连你也哭了？<br>「你就一直那样，摆出若无其事的表情……」<br>秋月的泪水滴滴答答滑落，大吼着。<br>「——一直孤单一人，度过一生吧！」</p>
</blockquote>
<p>……</p>
<p>今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。</p>
<p>孤独。</p>
<p>对，就是这个词，孤独。</p>
<p>无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。</p>
<p>总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。</p>
<p>或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。</p>
<p>或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许……</p>
<p>但我没有啊，哈。</p>
<p>但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。</p>
<p>天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。</p>
<h1 id="rm-Part-5-Ending"><a href="#rm-Part-5-Ending" class="headerlink" title="$\rm{Part~5/Ending}$"></a>$\rm{Part~5/Ending}$</h1><p>今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。</p>
<p>我一直在想，这本书到底能带给我什么。</p>
<p>是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？……</p>
<p>我不知道，但我觉得我列举的每个目的都太肤浅。</p>
<p>或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。</p>
<p>说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？</p>
<p>我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。</p>
<p>$\mathfrak{Orchidany, 3,31,2019}$</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性规划对偶定理</title>
    <url>/2019/03/19/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<h1 id="rm-Preface-About-Duality-Theorm"><a href="#rm-Preface-About-Duality-Theorm" class="headerlink" title="$\rm{Preface:} About~Duality~Theorm$"></a>$\rm{Preface:} About~Duality~Theorm$</h1><p><strong>线性规划对偶定理</strong>：我们朴素的线性规划大致如下：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)</script><p>那么我们称它的<strong>对偶</strong>为形如下的线性规划：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\
\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)</script><a id="more"></a>
<p>换做矩阵表示就会是这样：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \boldsymbol{b^Ty} \\
\text{满足约束} \quad A^T\boldsymbol{y\geq c} \\\
\it{\qquad \qquad \quad} \boldsymbol {y} \geq 0</script><p>那其实比较显然的是，我们原来线性规划中的约束向量与目标函数里的系数向量交换，目标函数的最大化变成了最小化。现在我们思考对偶的意义。</p>
<p>首先假设我们有这么一个线性规划：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\
\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)</script><p><del>其实就是上面那个</del></p>
<p>我们的目的其实等价于确定目标函数的下界。我们观察每一组约束，假设有一组约束是</p>
<script type="math/tex; mode=display">
\quad \sum \limits_{j=1}^{m} a_{p,j}y_{j} \geq c_p\quad (i = 1,2,3\cdots n)</script><p>并且我们保证有：</p>
<script type="math/tex; mode=display">
\forall a_{p,j} \in \boldsymbol{a_p},\forall b_i \in{\boldsymbol{b}},\quad i=j \Longrightarrow b_i\geq a_{p,j}</script><p>好像写的很不规矩……意思就是对应项的系数，目标函数都比这个约束里的大。</p>
<p>那么因为$\forall x\geq 0$，所以我们可以保证目标函数的最小值一定会是$c_p$。这个结论是显然的。</p>
<p>更进一步，那么我们最后确定的下界一定会是这样的（此处一点也不严谨地使用了$\Omega$符号）：</p>
<script type="math/tex; mode=display">
\Omega(\rm{Aim}) = \it{\sum \limits_{j = 1}^{n}t_j\cdot\sum\limits_{i=1}^{n}\sum \limits_{k=1}^{m}a_{i,k}y_k}\\\
\forall t_j \geq 0</script><p>而因为我们对于原来的约束有</p>
<script type="math/tex; mode=display">
\quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n)</script><p>所以我们将其代回我们画好的式子里面：</p>
<script type="math/tex; mode=display">
\Omega(\rm{Aim}) \geq \it{\sum\limits_{j=1}^{n}t_jc_j}</script><p>那么……目标函数的下界就变成了一个和式的上界——又变成了一个求解目标函数最大值的问题。</p>
<p>那么这或许感性证明了对偶定理的正确性？</p>
<h1 id="rm-Afterword-Some-Typical-Problem"><a href="#rm-Afterword-Some-Typical-Problem" class="headerlink" title="$\rm{Afterword:}Some~Typical~Problem$"></a>$\rm{Afterword:}Some~Typical~Problem$</h1><p><del>没见过吧，一篇文章只有前言和总结</del></p>
<p><del>其实博主就是在疯狂划水/摸鱼</del></p>
<p>其实常见的对偶问题有很多，博主功力不够，于是只能整理一个比较形式化的结论：</p>
<h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="$~$最大流问题"></a>$~$最大流问题</h2><p>形式化的最大流问题的线性规划如下：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \quad \quad ~f_{s\to t} \quad ~ \quad \quad \quad \quad \quad \quad \\
\text{满足约束} \quad \quad f_{u\to v} \leq L_{u \to v}\qquad (u,v) \in E \\\ 
\qquad \quad \quad ~\sum\limits_{u}f_{u \to v} = \sum\limits_{v}f_{v \to u}\qquad u\in V
 \\\ \qquad \qquad \qquad ~~\quad f_{u\to v} \geq 0 \qquad (u,v) \in E ~\cup \text{e(s,t)}</script><p>其中$e(u,v)$表示链接$u,v$的路径集合，$f$表示流量，$L$表示容量(Limit)。</p>
<p>其对偶过去就会是：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \quad \quad \sum_{(u,v)\in E}L_{u\to v}d_{u \to v} \quad ~ \quad \quad \quad \\
\begin{aligned}
\text{满足约束} \quad \quad d_{u\to v}-p_u+p_v &\geq 0\qquad (u,v) \in E \\\ 
\qquad \quad \quad \quad \quad \quad ~~p_s - p_t & \geq 1\qquad u\in V
 \\\ \qquad \qquad \qquad \quad  p_i,d_{i\to j} & \in \{0,1\} ~\qquad
\end{aligned}</script><p>里面$d_{i\to j}$表示$i \to j$这条边有没有被割，同时假设我们割完之后，原来的图分成了两部分$S$和$T$,那么会有$p_i = [i \in S]$。这个限制是为了保证割的逻辑性——所有的割边都连接着$S,T$两个集合，且源点和汇点在不同的集合。</p>
<p>emmm我实在不想再整理了(写式子太麻烦)，等什么时候我退完役闲下来再说吧233</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】NTT和任意模数NTT</title>
    <url>/2019/03/17/NTT1-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0x01-quad-rm-Preface"><a href="#0x01-quad-rm-Preface" class="headerlink" title="$0x01\quad \rm{Preface}$"></a>$0x01\quad \rm{Preface}$</h1><p>无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。</p>
<p>我们知道，对于$FFT$而言，其得以优化成$\log$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。</p>
<p>$\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，<strong>快速数论变换</strong>。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$：</p>
<ul>
<li><p>$\omega_n^n = 1$。</p>
</li>
<li><p>$\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。</p>
</li>
<li><p>{$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}$}，这使得问题规模可以在计算的时候减半。</p>
</li>
<li><script type="math/tex; mode=display">
\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k = 
 \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}</script></li>
</ul>
<p>这样可以保证我们能够使用相同的方法进行逆变换。</p>
<hr>
<p>首先，原根的基本定义：设$g$为$p$的一个原根，则满足：</p>
<script type="math/tex; mode=display">
𝑔^{𝑝−1}  \equiv 1(\mod p) \\
∀1≤𝑘<𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)</script><p>换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。</p>
<p>同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过</p>
<script type="math/tex; mode=display">
g^{p-1} \equiv1(\bmod~p) \\ \omega_n^n=1</script><p>而已。于是就满足性质一。</p>
<p>  而对于性质三，我们先考虑一个转化。我们如果要将$g$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}$。换句话说，$N | (p-1)$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)$，得到一个和单位根相似的形式。</p>
<p>  那么接下来，因为$p$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：</p>
<script type="math/tex; mode=display">
  g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)</script><p>  再结合<del>显而易证的</del>消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。</p>
<p>  至于性质四，证明的大体相似于单位单位复根。即：</p>
<script type="math/tex; mode=display">
  \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow  \frac{(g_n^n)^k -1}{g_n^k -1} \equiv  \frac{(1)^k -1}{g_n^k -1} = 0</script><p>  而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。</p>
<h1 id="0x02-quad-rm-Codes"><a href="#0x02-quad-rm-Codes" class="headerlink" title="$0x02\quad \rm{Codes}$"></a>$0x02\quad \rm{Codes}$</h1><p>呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且 $N$ 是 $2$ 的幂次，所以素数 $p$ 一定要是 $k\cdot 2^j+1$ 的形式。</p>
<p>至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000010</span> ;</span><br><span class="line">LL A[MAXN], B[MAXN], Inv ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    	<span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    	<span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    	*++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    	LL Gn = expow(flag == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        	LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    N = read(), M = read() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - <span class="number">2</span>) ;</span><br><span class="line">    NTT(A, <span class="number">-1</span>) ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) write((<span class="keyword">long</span> <span class="keyword">long</span>) (A[i] * Inv + P) % P) ; 	 					fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Gi</code>表示$998244353$的原根的逆元。</p>
<h1 id="0x03-quad-rm-Extending"><a href="#0x03-quad-rm-Extending" class="headerlink" title="$0x03\quad \rm{Extending}$"></a>$0x03\quad \rm{Extending}$</h1><p>接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=\omega\cdot 2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。</p>
<p>然后…我也不知道从哪找到了一张比较浅显的图：<img src="1.png" alt> </p>
<p>但是这个地方仍然会存在不少问题，巨佬<code>KsCla</code>如此解释：</p>
<blockquote>
<p>具体做法是这样：先选取三个乘积在$10^{23 }$以上的便于使用NTT的模数。在这里我选的是$m_1=998244353=2^{23}∗119+1$，$m_2=1004535809=2^{21}∗479+1$，$m_3=469762049=2^{26}∗7+1$。选这三个模数的好处在于它们的原根都是3。<br>然后用这三个模数做NTT，可以得到以下三条式子：</p>
<script type="math/tex; mode=display">
~ans≡c_1~(\bmod m_1)\\\
ans≡c_2~(\bmod m_2)\\\
ans≡c_3~(\bmod m_3)</script><p>虽然这三条式子可以在$10^{23}$以内唯一固定$ans$的值，但问题也随之而来：$m_1∗m_2∗m_3$很大，无法直接用<code>long long</code>存下，而用<code>long double</code>之类的则会丢失精度，所以无法用普通的$CRT$。难道要写高精度？</p>
<p>不，有一种很妙的方法可以解决这个问题。<br>首先注意到这里只有三个模数，而且两个模数乘起来是不会爆<code>long long</code>的，所以可以先合并前两条式子。根据CRT，有：</p>
<script type="math/tex; mode=display">
ans≡(c_1m_2Inv(m_2,m_1)+c_2m_1Inv(m_1,m_2))(\bmod m_1m_2)</script><p>其中$Inv(x,y)$表示x关于y的逆元。<br>这条式子涉及到两个很大的数相乘然后再取模，而直接相乘会爆long long。可以用$O(\log(m_1m_2))$的快速乘，或者$O(1)$转double后相乘。<br>为了方便，把上式化成这样的形式：</p>
<script type="math/tex; mode=display">
ans≡C(\bmod M)</script><p>然后设：</p>
<script type="math/tex; mode=display">
ans=xM+C=ym_3+c_3</script><p>接下来的部分才是精髓。我们求出$x$在$\bmod m_3$意义下的值：</p>
<script type="math/tex; mode=display">
xM≡c_3−C(\bmod m_3)</script><p>在$\bmod m_3$意义下，$ym_3$被消掉了。</p>
<p>然后有：</p>
<script type="math/tex; mode=display">
x≡(c_3−C)M−1(\bmod m_3)</script><p>算出右半部分的值为$q$，则可令$x=km_3+qx=km_3+q$。将其代入$ans=xM+C$：</p>
<script type="math/tex; mode=display">
ans=(km_3+q)M+C=km_3M+qM+C</script><p>也就是说：</p>
<script type="math/tex; mode=display">ans=km_1m_2m_3+qM+C</script><p>而由于$ans∈[0,m_1m_2m_3)$，所以$k$必为0。也就是说$ans$就是$qM+C$！直接把这条式子对题面要求的模数取模即可.</p>
</blockquote>
<p>嗝……其实我就是加了一遍mkd，但是也算是复习了一遍吧XD。</p>
<p>有一点是需要注意的：</p>
<ul>
<li>为什么要选三个乘积大于$10^{23}$的质数作为模数？<ul>
<li>为了是最后的结果可以<strong>不取模</strong></li>
</ul>
</li>
</ul>
<p>嗯，然后就是板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600010</span> ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> Mod, P, pr[] = &#123;<span class="number">469762049</span>, <span class="number">998244353</span>, <span class="number">1004535809</span>&#125; ;</span><br><span class="line">LL Ans[<span class="number">4</span>][MAXN], A[MAXN], B[MAXN], Inv, A1[MAXN], B1[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    	LL Gn = expow(G, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>), P) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        	LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Inv = expow(Lim, P - <span class="number">2</span>, P) ; reverse(J + <span class="number">1</span>, J + Lim) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Lim ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(LL *J, LL *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i) J[i] = L[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">egg</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b,LL p)</span></span>&#123;</span><br><span class="line">    LL re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>,a = (a + a) % p)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) re = (re + a) % p;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T_NTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">2</span> ; ++ i)&#123;</span><br><span class="line">        P = pr[i] ; i ? clear(A1, B1) : egg() ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N ; ++ j) A1[j] = A[j] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j) B1[j] = B[j] ;</span><br><span class="line">        NTT(A1, <span class="number">1</span>), NTT(B1, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; Lim ; ++ j) A1[j] = A1[j] * B1[j] % P ;</span><br><span class="line">        NTT(A1, <span class="number">-1</span>) ; <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= Lim ; ++ j) Ans[i + <span class="number">1</span>][j] = A1[j] ; </span><br><span class="line">    &#125;</span><br><span class="line">    rr LL Mo = <span class="number">1l</span>l * pr[<span class="number">1</span>] * pr[<span class="number">0</span>], k1, k2, a, b, c, mod = Mod ;</span><br><span class="line">    LL inv1 = expow(pr[<span class="number">1</span>] % pr[<span class="number">0</span>], pr[<span class="number">0</span>] - <span class="number">2</span>, pr[<span class="number">0</span>]), inv0 = expow(pr[<span class="number">0</span>] % pr[<span class="number">1</span>], pr[<span class="number">1</span>] - <span class="number">2</span>, pr[<span class="number">1</span>]), inv3 = expow(Mo % pr[<span class="number">2</span>], pr[<span class="number">2</span>] - <span class="number">2</span>, pr[<span class="number">2</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">        a = Ans[<span class="number">1</span>][i], b = Ans[<span class="number">2</span>][i], c = Ans[<span class="number">3</span>][i] ;</span><br><span class="line">        k1 = (mul(a * pr[<span class="number">1</span>] % Mo, inv1, Mo) + mul(b * pr[<span class="number">0</span>] % Mo, inv0, Mo)) % Mo ;</span><br><span class="line">        k2 = ((c - k1 % pr[<span class="number">2</span>]) % pr[<span class="number">2</span>] + pr[<span class="number">2</span>]) % pr[<span class="number">2</span>] * inv3 % pr[<span class="number">2</span>], Ans[<span class="number">0</span>][i] = ((k2 % mod) * (Mo % mod) % mod + k1 % mod) % mod;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    LL a,b,c,t,k,M = 1ll * pr[0] * pr[1];</span></span><br><span class="line"><span class="comment">    LL inv1 = inv(pr[1],pr[0]),inv0 = inv(pr[0],pr[1]),inv3 = inv(M % pr[2],pr[2]);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt;= deg; i++)&#123;</span></span><br><span class="line"><span class="comment">        a = fft[0].A[i],b = fft[1].A[i],c = fft[2].A[i];</span></span><br><span class="line"><span class="comment">        t = (mul(a * pr[1] % M,inv1,M) + mul(b * pr[0] % M,inv0,M)) % M;</span></span><br><span class="line"><span class="comment">        k = ((c - t % pr[2]) % pr[2] + pr[2]) % pr[2] * inv3 % pr[2];</span></span><br><span class="line"><span class="comment">        ans[i] = ((k % md) * (M % md) % md + t % md) % md;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ;</span><br><span class="line">    N = qr(), M = qr(), Mod = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = qr() % Mod ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = qr() % Mod ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    T_NTT() ; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[<span class="number">0</span>][i])  ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是这玩意儿进行了9遍NTT，那是真的慢。。。</p>
<h1 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h1><ul>
<li><code>KsCla</code>的$blog$ <a href="https://blog.csdn.net/kscla/article/details/79547242" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】有趣的数学题</title>
    <url>/2019/03/17/Math1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两道小清新数学题，分别是[NOI2002]Savage和[Violet · 5]樱花</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt></p>
<h2 id="rm-NOI2002-Savage"><a href="#rm-NOI2002-Savage" class="headerlink" title="$\rm{[NOI2002]}$ Savage"></a>$\rm{[NOI2002]}$ Savage</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1407" target="_blank" rel="noopener">$\color{violet}{Link}$</a> </p>
<h3 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不算特别难…其实就是求方程<script type="math/tex">C_{i}+P_{i}x \equiv C_j+P_jx ~(\bmod ~M)</script>不存在一个解使得$x \leq min(L_i,L_j)$时，$M$的最小值。然后因为题目中的数据，假设我们令每个野人都只是绕着圈走而不重复经过对方的路径——即$M$的最大值，也不过是$100\times 106\times 100 = O(1e6)$的级别，于是考虑直接枚举$M$, 然后check。由于最多共有$15$个野人，且单次exgcd是$\log n $级别的，所以复杂度上限是$O (Mn^2 \log C_{max}) &lt; \Omega(1e8)$级别的。如果不是精心构造数据的话，可以直接艹过去。</p>
<p>喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ;</span><br><span class="line">            <span class="keyword">int</span> qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ;</span><br><span class="line">            x = x * w / qwq ; <span class="keyword">while</span> (x &lt;= <span class="number">0</span>) x += M ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后觉得一点问题都没有，$40pts$之后愣了大半天。</p>
<p>而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的$x$，应该不断取模$b/ \gcd(a,b)$</p>
<p>为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解：</p>
<blockquote>
<p>_这是上面这个式子为什么可以这么做的证明：_</p>
<p>若有$ax+by=c$且$a_0x+b_0y=c$</p>
<p>那么便有$a(x-x_0)+b(y-y_0)=0$<br>两边同时除以$gcd(a,b)$可得：<br>$\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)$ $ \quad$ $(1)$</p>
<p>而因为</p>
<p>$(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p>
<p>所以由$(1)$可得$\frac{b}{gcd(a,b)}$整除$(x-x_0)$</p>
<p>所以很显然有$\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in Z$</p>
<p>那么就有对于任意一个$x_i$，有</p>
<p>$ x_i=x_0+\frac{b}{gcd(a,b)} \times{t} $</p>
</blockquote>
<p>我特么…智商已经回退到上个世纪了吧$\rm{qaq}$，自闭了。</p>
<p>这就是我整理这道题的原因……还有，上面$P_i-P_j$似乎需要取模并使其变成正的，因为好像我的$exgcd$里面限制了$A&gt;0$的缘故。</p>
<p>心得：我退役吧嘤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B) &#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> A ;&#125;</span><br><span class="line">    <span class="keyword">int</span> t = exgcd(y, x, B, A % B) ; y -= A / B * x ; <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ; </span><br><span class="line">            x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; <span class="keyword">if</span> (!x) x += (M / qwq) ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> ( M ; ; ++ M) <span class="keyword">if</span> (check()) &#123; <span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Violet～5-樱花"><a href="#rm-Violet～5-樱花" class="headerlink" title="$\rm{[Violet～5]}$ 樱花"></a>$\rm{[Violet～5]}$ 樱花</h2><p>链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2721" target="_blank" rel="noopener">$\color{violet}{Link}$</a> </p>
<p>这是好久之前做的一道题，突然被我发现了。大概就是求方程<script type="math/tex">\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 1e6)</script>的解的组数。</p>
<h3 id="rm-Sol-1"><a href="#rm-Sol-1" class="headerlink" title="$\rm{Sol}$"></a>$\rm{Sol}$</h3><p>不想思考系列问题，我这么懒还是退役吧。(sigh)</p>
<p>我们将柿子变个形：</p>
<script type="math/tex; mode=display">
\frac{x+y}{xy} = \frac{1}{n!} \\
n!x + n!y = xy</script><p><del>然后我就不会了，此题完结</del></p>
<p>然后有一步很妙的是两边同时$+(n!)^2$得到：</p>
<script type="math/tex; mode=display">
(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\
(n!-x)(n!-y)=(n!)^2</script><p>然后就会发现我们只需要找出$(n!)^2$的因子个数就好了…</p>
<p>好像我从来没有写过$\tau$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）</p>
<script type="math/tex; mode=display">
x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)</script><p><del>其实就是为了水字数</del></p>
<p>$\rm upd ~on ~6.13$ : 我发现自己似乎之前听过这个题的”另解”，以前自己整理过：</p>
<blockquote>
<p>$233$窝萌思考一个比较显然的问题，就是一定会有$y&gt;n!$。那窝萌不妨设$y = n!+T$，那么带回到原式里面就会有<script type="math/tex">\frac{1}{x} + \frac{1}{n!+T} = \frac{1}{n!}</script>继而有<script type="math/tex">x = \frac{n!^2}{T}+n!</script>那么其实一共就有$\tau(n!^2)$个合法答案，所以我们转而求$n!^2$的约数数量。</p>
<p>但是显然的是我们并不可以直接求解，当然我不知道高精度之后会怎么样，估计$nlogn$一下还是有可能过的。但是考虑到常数巨大，所以卡过$1e6$基本上是痴人说梦。所以我们思考一种清新脱俗<del>我根本想不出来</del>的做法。</p>
<p>窝萌考虑筛出所有的$1-n$素数来，然后对于一个素数而言，由于窝萌要判断的对象是$n!$，他有一个奇妙的性质就是<script type="math/tex">n!=\prod \limits_{i=1}^{n}{i}</script>那么也就是说我们只需要判断对于一个当前给定的素数$p$，在$1-n$的所有数里面，$p$作为因子出现了多少次即可。那么也就是这个式子：</p>
<script type="math/tex; mode=display">
Ans = \prod \limits _{p \in prime }^{p \leq n}{\sum \limits _{i \geq 1}^{p^i \leq n}{\lfloor \frac{n}{p^i}} \rfloor +1}</script><p>我们每次遍历一遍，保证只加一次，譬如质数$3$，三的倍数的个数产生的贡献是一，三的平方的倍数产生的贡献是二，但是我们从前往后扫的话，每次就只要增长一个贡献即可（类似于去重操作$233$）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Prime[MAXN] ;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">bitset</span> &lt;MAXN&gt; vis ; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, i, j, cnt, Ans, Cnt[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ego</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>] = vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) Prime[++ cnt] = i ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i * Prime[j] &gt; N) <span class="keyword">break</span> ;</span><br><span class="line">			vis[i * Prime[j]] = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span> (!(i % Prime[j])) <span class="keyword">break</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">	    <span class="keyword">for</span> (j = Prime[i] ; j &lt;= N ; j *= Prime[i])</span><br><span class="line">	        ( Cnt[i] += (N / j) ) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; N ; Ans = <span class="number">1l</span>l, Ego() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">        (Ans *= (Cnt[i] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>) %= Mod ;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; Ans % Mod &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学/扩展欧几里德</tag>
        <tag>数学/素数/素数筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】一类线段树的转移</title>
    <url>/2019/03/17/Segment-Tree1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>奇奇怪怪的线段树散发着奇奇怪怪的香气（</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<p>最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$</p>
<h1 id="rm-Task1-子段和"><a href="#rm-Task1-子段和" class="headerlink" title="$\rm{Task1} $子段和"></a>$\rm{Task1} $子段和</h1><p>其实这个算是比较简单的了，毕竟$qyf$曾经给我们讲过，当时我就觉得十分的……麻烦233.</p>
<p>那么例题其实就是$\rm{SPOJ}$的$GSS$系列——的前三道题<del>(后几道题都不会做)</del></p>
<h2 id="GSS1-区间求最大子段和-不带修"><a href="#GSS1-区间求最大子段和-不带修" class="headerlink" title="$GSS1$区间求最大子段和(不带修)"></a>$GSS1$区间求最大子段和(不带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>$2333$应该算是比较简单的了。我们对于每个区间维护一个<strong>区间和</strong>，维护一个<strong>从最左端开始且必须包含最左端元素的最大子段和</strong>，再维护一个<strong>从最右端开始且必须包含最右端元素的最大子段和</strong>，最后维护一个<strong>区间最大子段和</strong>。</p>
<p>那么转移($push$_$up$)时就显得十分方便。我们的父区间的$Lmax$只取决于左子区间的$Lmax$和<strong>当左区间的$Sum$等于$Max$时（即左区间全部都要纳入到其最大子段和中时）</strong>，左区间的$Sum$与右区间的$Lmax$的和。那么对于区间的$Rsum$，也是一个道理。最终对于该区间的最大子段和，我们<strong>不考虑</strong>从已经转移来的$Lmax/Rmax$，而是考虑从左右区间的$Max$以及左右区间的和来转移。大体代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有值得注意的一点：在询问的时候，它比较膈应……就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来……所以所就要类似于边询问，边$push_up$这种感觉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">		T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">	&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line">		<span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">while</span> (M --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GSS3-区间求最大子段和-带修"><a href="#GSS3-区间求最大子段和-带修" class="headerlink" title="$GSS3$ 区间求最大子段和(带修)"></a>$GSS3$ 区间求最大子段和(带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1716" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>……其实吧，这个带修不带修……好像影响并不大？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max my_Fuckmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(rt) rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(rt) rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">bool</span> MArk ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	LL S, Sum, Lsum, Rsum ;</span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, L, R, base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) T[x].S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sum(x) T[x].Sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lsum(x) T[x].Lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rsum(x) T[x].Rsum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">		T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">	&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line">		<span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == l &amp;&amp; L == r)&#123;</span><br><span class="line">		T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) change(ls(rt), l, mid, k) ;</span><br><span class="line">	<span class="keyword">else</span> change(rs(rt), mid + <span class="number">1</span>, r, k ) ; P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">while</span> (M --) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R) ;</span><br><span class="line">		<span class="keyword">if</span> (!MArk) change(<span class="number">1</span>, <span class="number">1</span>, N, R) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GSS4-区间开根问题"><a href="#GSS4-区间开根问题" class="headerlink" title="$GSS4$ 区间开根问题"></a>$GSS4$ 区间开根问题</h2><p><a href="https://www.luogu.org/problemnew/show/SP2713" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>这个和子段和一点儿关系都没有，顺便整一下233.</p>
<p>就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个$2^{63}$内的数值$N$，我们假设其开根$k$次可以得到$N &lt; 2$——只要$N &lt; 2$之后的计算就会集中在一个紧确的范围$(1,2)$内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。</p>
<p>那么现在，我们致力于去确定$k$的值域。我们不得不承认，$\sqrt n$在$[0,+\infty]$是单调递增的，同理三次方根也是，四次方根也是……所以我们不妨取最大值，考虑$N=2^{63}$时，$k$值的大小。而很显然，此时的$k$应该为$\log _263+1 ≈ 6.978$——这似乎是十分平凡的结论。</p>
<p>总之，我们得出，似乎运算次数的上界就是$k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是$\Omega(7n)$的样子，无非就是多几个常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll N, M, K, i, L, R ; </span><br><span class="line">ll base[MAXN], T[MAXN], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">p_u</span><span class="params">(ll rt)</span></span>&#123; ;&#125;</span><br><span class="line"><span class="keyword">void</span> _Build(ll rt, ll l, ll r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;T[rt] = base[l] ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _Build(ls(rt), l, mid) ;</span><br><span class="line">    _Build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) ret += _query(rs(rt), mid + <span class="number">1</span>, r, sl, sr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (T[rt] &lt;= (r - l + <span class="number">1</span>)) <span class="keyword">return</span> ; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">                T[rt] = (<span class="keyword">int</span>)(<span class="built_in">pow</span>((<span class="keyword">double</span>)T[rt], <span class="number">0.5</span>)) ;</span><br><span class="line">            	<span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), </span><br><span class="line">				   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) _Sqrt(rs(rt), mid + <span class="number">1</span>, r, sl, sr), </span><br><span class="line">				   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">    	++ tot, <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, tot) ;</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    	_Build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    	    K = qr(), L = qr(), R = qr() ;</span><br><span class="line">    	    <span class="keyword">if</span> (L &gt; R) swap(L, R) ;</span><br><span class="line">   		    <span class="keyword">if</span> (K)&#123;</span><br><span class="line">    	        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, _query(<span class="number">1</span>, <span class="number">1</span>, N, L, R)) ;</span><br><span class="line">    	        <span class="keyword">continue</span> ;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	    _Sqrt(<span class="number">1</span>, <span class="number">1</span>, N, L, R) ;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Task2-最长连续问题"><a href="#rm-Task2-最长连续问题" class="headerlink" title="$\rm{Task2}$ 最长连续问题"></a>$\rm{Task2}$ 最长连续问题</h1><p>这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括<strong>连续</strong>字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断$push_up$即可。</p>
<p>$emmm$在这边整理几道思路不错的题吧：</p>
<h2 id="rm-USACO-酒店-hotel"><a href="#rm-USACO-酒店-hotel" class="headerlink" title="$\rm{USACO}$ 酒店($hotel$)"></a>$\rm{USACO}$ 酒店($hotel$)</h2><p><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>初始的一个全零的序列，我们对它准确来说有以下三个操作：</p>
<ul>
<li>区间置$0$</li>
<li>区间置$1$</li>
<li>询问是否有一段长度为$k$的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作②</li>
</ul>
<hr>
<p>这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。</p>
<p>但事实上……这就是学数据结构学傻了的后果……毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。</p>
<p>唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于$NOI2005$维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。</p>
<p>诶，好像扯了什么奇怪的东西……</p>
<p>回到正题，我们不考虑直接维护这个东西，而是<strong>通过维护区间内的最长连续$0$的个数，达到辅助查找区间的目的</strong>。那么我们查找区间的时候，就直接**择最左边的区间优先，并$check$其是否有足够的$0$。</p>
<p>对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Sum, Len, Lsum, Rsum, tag ; </span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, N, M, MArk, i, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ;	</span><br><span class="line">	&#125;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].Sum == T[ls(rt)].Len) </span><br><span class="line">		T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">else</span> T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">if</span> (T[rs(rt)].Sum == T[rs(rt)].Len) </span><br><span class="line">		T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ;</span><br><span class="line">	<span class="keyword">else</span> T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">	T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), </span><br><span class="line">	T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span>,</span><br><span class="line">	T[rt].Len = T[rt].Lsum = </span><br><span class="line">	T[rt].Rsum = T[rt].Sum = r - l + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">		T[rt].tag = k ;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">else</span> T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid) update(rs(rt), mid + <span class="number">1</span>, r, ul, ur, k) ;</span><br><span class="line">	push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].Sum &gt;= A) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) <span class="keyword">return</span> mid - T[ls(rt)].Rsum + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">	<span class="keyword">while</span>(M --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MArk) ;</span><br><span class="line">		<span class="keyword">if</span> (MArk == <span class="number">2</span>)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), update(<span class="number">1</span>, <span class="number">1</span>, N, A, A + B - <span class="number">1</span>, <span class="number">1</span>) ;	</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A) ;</span><br><span class="line">			<span class="keyword">if</span> (T[<span class="number">1</span>].Sum &gt;= A)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t = query(<span class="number">1</span>, <span class="number">1</span>, N)), update(<span class="number">1</span>, <span class="number">1</span>, N, t, t + A - <span class="number">1</span>, <span class="number">0</span>)  ;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">'0'</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。</p>
<h2 id="rm-SCOI-序列操作"><a href="#rm-SCOI-序列操作" class="headerlink" title="$\rm{SCOI}$ 序列操作"></a>$\rm{SCOI}$ 序列操作</h2><p><a href="https://www.luogu.org/problemnew/show/P2572" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>对于一个$01$序列，大体是这几种操作：</p>
<ul>
<li>区间清零</li>
<li>区间置为$1$</li>
<li>区间全部取非</li>
<li>区间查询$1$的个数</li>
<li>区间查询最长连续的$1$的长度</li>
</ul>
<p>好的，这道题被我秒了，爽啊……不过秒是秒了，对拍调试法调了好久$233$。</p>
<p>其实对于$1,2,4,5$都好说，只是第$3$个操作，需要再另维护区间最长连续的$0$的长度，如果存在取非标记生效，就交换一下就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> OS, OL, OR ;</span><br><span class="line">	<span class="keyword">int</span> Sum, Lsum, Len, Rsum, S, tag, t ;</span><br><span class="line">	<span class="comment">//tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor</span></span><br><span class="line">&#125;T[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, MArk, L, R, base[MAX], i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	T[rt].S = T[ls(rt)].S + T[rs(rt)].S ;</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].S == T[ls(rt)].Len) </span><br><span class="line">		  T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">if</span> (T[rs(rt)].S == T[rs(rt)].Len) </span><br><span class="line">		  T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">	T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ;</span><br><span class="line">	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">if</span> (!T[ls(rt)].S) </span><br><span class="line">		  T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].OL = T[ls(rt)].OL ;</span><br><span class="line">	<span class="keyword">if</span> (!T[rs(rt)].S) </span><br><span class="line">		  T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].OR = T[rs(rt)].OR ;</span><br><span class="line">	T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].t == <span class="number">1</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag ^= <span class="number">1</span>, T[rs(rt)].tag ^= <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ;</span><br><span class="line">		T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ;</span><br><span class="line">		<span class="comment">//l</span></span><br><span class="line">		T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ;</span><br><span class="line">		T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ;</span><br><span class="line">		T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ;</span><br><span class="line">		<span class="comment">//r</span></span><br><span class="line">		T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ;</span><br><span class="line">		T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ;</span><br><span class="line">		T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">1</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ;</span><br><span class="line">	&#125;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span>, T[rt].t = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">		T[rt].tag = k ;</span><br><span class="line">		<span class="keyword">if</span> (!k)	</span><br><span class="line">			T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, </span><br><span class="line">			T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">else</span>  T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">0</span>, </span><br><span class="line">			  T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) _change(ls(rt), l, mid, k) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) _change(rs(rt), mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">	up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _reverse(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">		T[rt].t = <span class="number">1</span> ;</span><br><span class="line">		T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ;</span><br><span class="line">		T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ;</span><br><span class="line">		T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ;	</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) _reverse(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) _reverse(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt].S ;</span><br><span class="line">	down(rt) ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) res += Sum(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) res += Sum(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">	T[rt].Len = r - l + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span>  T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">	Tree res, A, B ;	</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">    res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; </span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">	<span class="keyword">while</span> (M --)&#123;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R),</span><br><span class="line">		++ L, ++ R ;</span><br><span class="line">		<span class="keyword">if</span> (MArk == <span class="number">0</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">1</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">2</span>) _reverse(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Sum(<span class="number">1</span>, <span class="number">1</span>, N)) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$push_up$真长啊$233$</p>
<p>艹完这个题是真的爽啊~</p>
<h1 id="Task3-总结一下"><a href="#Task3-总结一下" class="headerlink" title="$Task3~$ 总结一下"></a>$Task3~$ 总结一下</h1><p>其实这东西和$DP$是一样的吧？你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。</p>
<p>嗯，万物相同。</p>
<blockquote>
<p>野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？</p>
</blockquote>
<p>不知为什么，突然想到了这句话。</p>
<h1 id="mathscr-The-End"><a href="#mathscr-The-End" class="headerlink" title="$\mathscr{The~End}$"></a>$\mathscr{The~End}$</h1>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】自适应Simpson法入门</title>
    <url>/2019/03/17/Simpson1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一种很可爱的积分近似法，学的时候顺便看了好多论文qaq</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p>
<h1 id="rm-0x01-前言"><a href="#rm-0x01-前言" class="headerlink" title="$\rm{0x01}$  前言"></a>$\rm{0x01}$  前言</h1><p>首先阐明一点，<strong>自适应辛普森算法($\rm{Adaptive ~Simpson’s~ rule}$ )</strong>是一类<strong>近似算法($\rm{Approximation ~algorithm}$)</strong>，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？</p>
<p>其思想是利用二次函数来不断<strong>拟合($\rm{Overfitting}$)</strong>所求曲线，而所谓的<strong>$Adapative$（自适应）</strong>则是用于优化时间复杂度的方法。</p>
<p>嗝…总之…比较简单？</p>
<p>表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。</p>
<h1 id="rm-0x02-mathcal-Simpson-Formula-辛普森公式"><a href="#rm-0x02-mathcal-Simpson-Formula-辛普森公式" class="headerlink" title="$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式"></a>$\rm{0x02}$  $\mathcal{Simpson~Formula}$ 辛普森公式</h1><p>稍等，这个跟算法的关系不大，主要是公式：<script type="math/tex">\rm{\int _{l}^{r} f(x) \rm{dx}\approx \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}} \,</script></p>
<p>事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大$233$</p>
<p>这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$：</p>
<blockquote>
<p>因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx</script><p>求 $g(x)$ 的不定积分为：</p>
<script type="math/tex; mode=display">
\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C</script><p>然后再带入 R 和 L ：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)</script><p>然后提公因式，原式为：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)</script><p>把里面展开来：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)</script><p>重新整理一下式子：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)</script><p>再整理：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))</script><p>代换可得：</p>
<script type="math/tex; mode=display">
aR^2+bR+c\approx f(R)\\\
aL^2+bL+c\approx f(L)\\\
4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})</script><p>把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))</script></blockquote>
<p>于是我们就得到了所谓的$\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是——</p>
<h1 id="rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法"><a href="#rm-0x03-mathcal-Adaptive-Simpson-Rule-自适应辛普森法" class="headerlink" title="$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法"></a>$\rm{0x03}$  $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法</h1><p>我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑<strong>定向二分</strong>。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。</p>
<p>于是考虑<strong>自适应</strong>。</p>
<p>所谓<strong>自适应</strong>，说的直白点，无非就是<strong>需要多分治几次的地方，多分治几次；不需要的则可以少分治几次</strong></p>
<p>你会发现，其实他节约的就是一个点——<strong>时间效率</strong>。</p>
<p>举个栗子$^{[2]}$：</p>
<p>比如有这么个函数$\rm{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }$，我们要求$\int_{0}^{4}f(x) \rm{~dx}$ 并要求精度误差在$1e-5$ 以内。而我们有两种方法去解决：</p>
<ul>
<li>以固定的比例以及约束二分。</li>
<li>运用自适应策略分配</li>
</ul>
<p>那么我们首先要知道他真正的$value:$</p>
<p><img src="3.png" alt></p>
<p>看起来好像海星？然后我们用两种方法都试一试：</p>
<p>首先是自适应法，我们发现最后只需要求$20$段区间。表中的$a_k \&amp; b_k$表示左右区间，$S(l,r)$表示$[l,r]$内、运用$0x01$中的公式计算的，$\rm{Error~Bound}$表示误差界，$\rm{Tolerance}$表示计算时<strong>需要的误差</strong>(程序设计时会讲)。</p>
<p><img src="4.png" alt></p>
<p>那么最后算出来的值是$ −1.54878823413$ ，与真实值误差为$0.00000013840 $，一共调用了$79$次<strong>函数估值</strong>（留个坑，后文会讲）。</p>
<p>那么绘制出来的函数图像大概长这样：<img src="5.png" alt></p>
<p>好像很流畅？$233$</p>
<p>那么第二种方法是定值分段。我们考虑分成区间$[0,4]$分为长度为$0.03125$的$128$段，并运用$0x01$的$Formula$，最后得出的结果为$−1.54878844029$，误差为$0.00000006776$……</p>
<p>好像是第一个误差的二分之一？听起来好像误差小了，但是却需要$257$次函数估值的调用……相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦的啦～</p>
<p>但是比起$1e-5$精度来说……这波稳赚啊$233$</p>
<h1 id="rm-0x04-mathcal-About-Code-代码实现"><a href="#rm-0x04-mathcal-About-Code-代码实现" class="headerlink" title="$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现"></a>$\rm{0x04}$  $\mathcal{About~Code~}$ 代码实现</h1><p>首先是<a href="https://www.luogu.org/problemnew/show/P4525" target="_blank" rel="noopener">$LuoguP4525$</a>的暴力解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (C * x + D) / (A * x + B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ;</span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Simp_calc(l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid) + do_divide(mid, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ;</span><br><span class="line">    Ans = do_divide(L, R) ; <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是……他对的很？</p>
<p>至于进化版<a href="https://www.luogu.org/problemnew/show/P4526" target="_blank" rel="noopener">$LuoguP4526$</a>，也是完全可以violently艹过去的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">23.3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R)) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，其真正的实现应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v Lans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) * 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, L, R ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Liu = <span class="number">1.0</span> / <span class="number">6</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * Liu * (F(l) + F(r) + <span class="number">4.0</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans, <span class="keyword">double</span> eps)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, t ; </span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ; </span><br><span class="line">    <span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; <span class="comment">//据说eps×15来自于Wiki……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">30</span> ; </span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们发现这就可以跟文章上面$0x03$中的例子呼应了：每次分治时计算两次，总共分治了$39$次，最终一共计算了$78+1=79$次，而二分则是一棵有$128$个叶子节点的递归树，总共计算了$256 +1=257$次。    </p>
<p>好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断$check\&amp;calc$, 而$check$的方式也很简单，只需要判断一下两段子区间的函数值之和与整个区间的函数值之和的差值是否在精度要求范围之内，之后如果满足精度误差就直接$return$，否则对于这段区间继续递归下去。</p>
<p>而这个地方有个要求，就是对于$eps$，你需要不断$half$他，原因很简单，对于一整段区间$U$，要求他的返回值的$|eps(U)| \leq k$的话，那么对于其作为子集两个连续区间$A,B$，当$A \bigcup B = U$时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq  \frac{k}{2}$，才能保证$|eps(U) = eps(A) + eps(B)| \leq k$，所以要：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line">....................</span><br><span class="line"><span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ;</span><br></pre></td></tr></table></figure>
<p>好了，唯一的问题在于有句话迷的很：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ;</span><br></pre></td></tr></table></figure>
<p><img src="nky.jpg" alt></p>
<p>这个$\leq 15 \cdot eps$是什么意思？</p>
<p>好吧，笔者也不清楚，但是有个结论是长这样的：<img src="1.png" alt></p>
<p>什么？你说推什么倒？小小年纪整天想着推倒<del>学姐</del>可不好啊$233$</p>
<p>什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～</p>
<p>好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了……</p>
<p>于是结束，撒花花…（不是撒笔者x）</p>
<h1 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm{Referance}$"></a>$\rm{Referance}$</h1><ul>
<li><p>$[1]$ :$NaCly_Fish$的$blog$ <a href="https://www.luogu.org/blog/NaCly-Fish-blog/SimpsonIntegral" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p>
</li>
<li><p>$[2]$ :某篇论文 <a href="https://files.cnblogs.com/files/pks-t/AdaptiveQuadProof.pdf" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p>
</li>
</ul>
<p>对于第二篇$refer$，借鉴的比较多（读书人的事……咳咳……），但是改了一个数据，就是$81 \to 79$，因为代码需要$233$</p>
<p>$Ps:$史上最不正经的$reference$诞生了……</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/积分/积分近似</tag>
        <tag>计算几何/Simpson积分</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】一类树上距离的计算</title>
    <url>/2019/03/16/Cal-on-Tree1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p>
<p>好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。</p>
<p>问题大概有两类：只有查询$\&amp;$修改查询都有</p>
<h2 id="mathscr-Task1-普通的查询问题"><a href="#mathscr-Task1-普通的查询问题" class="headerlink" title="$\mathscr{Task1}$普通的查询问题"></a>$\mathscr{Task1}$普通的查询问题</h2><p>大概问题就类似于这个典型的<a href="https://www.luogu.org/problemnew/show/P2420" target="_blank" rel="noopener">$XOR$问题</a> </p>
<p>其实说白了，这个题的解法十分简单——$LCA$</p>
<p>但其实……我一开始考虑$LCA$，没有细致考虑，只是觉得如果从$u,v$分别向$LCA$跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。</p>
<p>但是这个地方，$LCA$的作用十分巧妙——我们试图去拓展这个题。我们定义$D(\bigodot,r,u)$表示在运算$\bigodot$下，从根$r$到某一固定点$u$的边权运算结果，其中限定了运算$\bigodot$必须为可逆运算，比如说异或、加法、减法——注意，此时的可逆运算，可以是<strong>自可逆（自己对自己运算是逆运算，比如$A~XOR ~A = 0$）</strong>或者<strong>他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法）</strong>，那么我们就可以很方便地得出它的一般形式<script type="math/tex">D(\bigodot,u,v) = D(\bigodot,r,u) \bigodot D(\bigodot,r,v) ~\bigoplus ~(~2 \cdot D(\bigodot,r,LCA(u,v)~)~)</script> ，其中我们假设运算$\bigodot$与$\bigoplus$互逆。树上前缀和大抵上就是这个意思。</p>
<p>那么回到这个题，我们对于每一个点的$D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$是一个相当平凡的结论；有权时，则直接$dfs$一遍即可。每次查询是$log$级别的，所以时间复杂度的渐进上界就是比较显然的$O(\max(m \log_2n,n))$。</p>
<p>代码大概是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span> )+ (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].t = v ;</span><br><span class="line">    e[cnt].next = head[u] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">	head[u] = cnt ;</span><br><span class="line">    e[++cnt].t = u ;</span><br><span class="line">    e[cnt].next = head[v] ;</span><br><span class="line">    e[cnt].v = w ;</span><br><span class="line">	head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _build(<span class="keyword">int</span> deep, <span class="keyword">int</span> now, <span class="keyword">int</span> f, <span class="keyword">int</span> _xor)&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f, dep[now] = deep, XOR[now] = _xor ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = head[now]; k ;k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[k].t == f) <span class="keyword">continue</span> ;</span><br><span class="line">        _build(deep + <span class="number">1</span>, e[k].t, now, _xor ^ e[k].v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Up = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Up; i ++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    pre = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= Up; j ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; pre) u = fa[u][j] ;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span>(j = Up; j &gt;= <span class="number">0</span>; j --) <span class="keyword">if</span>(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> fa[v][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr(), in3 = qr();</span><br><span class="line">        add(in1, in2, in3) ;</span><br><span class="line">    &#125;</span><br><span class="line">    M = qr() ;</span><br><span class="line">    _build(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), init( );</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr() ;</span><br><span class="line">        f1 = LCA(in1, in2) ;</span><br><span class="line">        <span class="keyword">int</span> t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mathscr-Task-2-带有修改的查询问题："><a href="#mathscr-Task-2-带有修改的查询问题：" class="headerlink" title="$\mathscr{Task~2}$带有修改的查询问题："></a>$\mathscr{Task~2}$带有修改的查询问题：</h2><p>之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是<a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">某年国家集训队的板子题</a>和一道经典的<a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">边权修改启蒙题</a> </p>
<p>我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然<strong>只能转移到深度大的点上</strong>，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。</p>
<p>所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要<strong>忽略$LCA(u,v)$</strong>，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v]) ;	</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v], d) ;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;	</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>而对于如何边权转点权，我用的总时间复杂度大约$O(n)$的区间赋值函数，好像比较方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">    n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，<del>题解好啊</del></p>
<p>那么上面两个题就比较简单了：</p>
<p>$\mathscr{T1 ~\text{の} ~code}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;  </span><br><span class="line"><span class="keyword">int</span> Id[MAX], M, N, tot, A, B, C, i ; <span class="keyword">char</span> STR[<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Max[MAX &lt;&lt; <span class="number">1</span>], Min[MAX &lt;&lt; <span class="number">1</span>], S[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ;</span><br><span class="line">    Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ;</span><br><span class="line">    S[rt] = S[Ls(rt)] + S[Rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ;</span><br><span class="line">        T[Ls(rt)] ^= <span class="number">1</span>, T[Rs(rt)] ^= <span class="number">1</span> ;</span><br><span class="line">        Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ;</span><br><span class="line">        Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ;</span><br><span class="line">        T[rt] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        S[rt] = Max[rt] = Min[rt] = k, T[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Max[rt] ;</span><br><span class="line">        Max[rt] = -Min[rt], Min[rt] = -t ; </span><br><span class="line">        T[rt] ^= <span class="number">1</span>, S[rt] = -S[rt] ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Max[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = -Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Min[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Minnnnn = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Minnnnn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ___query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Ssssss = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    <span class="keyword">return</span> Ssssss ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Min</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Sum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr() + <span class="number">1</span>, n[i].v = qr() + <span class="number">1</span>, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'N'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, _Update(A, B) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'S'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Sum(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'A'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'I'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Min(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$一定是<strong>异或而不是覆盖</strong> ……是一个坑点</p>
<p>$\mathscr{T2 ~\text{の} ~code}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ; <span class="comment">//0 = Change, 1 = Add .</span></span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">char</span> STR[<span class="number">50</span>] ; <span class="keyword">int</span> A, B, C ;</span><br><span class="line"><span class="keyword">int</span> Rec[MAX], Id[MAX], Aft[MAX] ;<span class="keyword">int</span> N, tot ;</span><br><span class="line"><span class="keyword">int</span> M[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>][<span class="number">2</span>], head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">0</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">        M[Ls(rt)] = T[rt][<span class="number">0</span>], M[Rs(rt)] = T[rt][<span class="number">0</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>], T[Ls(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>]; </span><br><span class="line">        T[rt][<span class="number">0</span>] = <span class="number">-1</span>, T[Rs(rt)][<span class="number">1</span>] = <span class="number">0</span>, T[Ls(rt)][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">1</span>])&#123;</span><br><span class="line">        M[Ls(rt)] += T[rt][<span class="number">1</span>], M[Rs(rt)] += T[rt][<span class="number">1</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>], T[Ls(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>] ; </span><br><span class="line">        T[rt][<span class="number">1</span>] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T[rt][<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;M[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">0</span>] = M[rt] = k, T[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">1</span>] += k, M[rt] += k ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> M[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; STR ;</span><br><span class="line">    <span class="keyword">while</span>(STR[<span class="number">0</span>] != <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'A'</span>) A = qr(), B = qr(), C = qr(), _Update(A, B, C) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span>) A = qr(), B = qr(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'o'</span>) A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ;    </span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'h'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。</p>
<h2 id="与树形-mathbb-DP-的巧妙结合"><a href="#与树形-mathbb-DP-的巧妙结合" class="headerlink" title="与树形$\mathbb{DP}$ 的巧妙结合"></a>与树形$\mathbb{DP}$ 的巧妙结合</h2><p>这个地方其实说的是一类问题。。。比如一道<del>我根本不会的</del> 经典题：</p>
<p>$\rm Description$</p>
<p>一棵带权树，$n$个点$q$次询问，每次询问一个点的$\sum dis_{odd}$和$\sum dis_{even}$。</p>
<p>$\mathcal{Solution}$</p>
<p>其实这个题的题目意思是让我们求：</p>
<blockquote>
<p>$R$君想知道对于每个点来说，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。    </p>
</blockquote>
<p>那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？</p>
<p>这个东西比较简单，因为我们可以直接$dfs$。</p>
<p>那么如果是求所有点到所有点的距离和呢？</p>
<p>换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。</p>
<p>我首先忽略边权，令边权都是$1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道<strong>根节点到所有点的距离之和</strong>，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？</p>
<p>我们会发现，此时我们知道的量，同一般的树形$DP$或者说树形结构不同，我们现在已经知道了<strong>每一个子树的根节点的讯息；</strong>而平常的树形结构，我们知道的则是<strong>子节点的讯息$or$子树的讯息</strong>，这一点提示我们：<strong>反向$DP$</strong></p>
<p>我们不妨设$dp_u$表示$\sum \limits_{i \in T}^{}{dist(i,u)}$ 那么我们思考如何构造相邻两层的状态转移方程：</p>
<p>首先，我们已经决定反向$DP$，换句话说就是<strong>用父亲推出儿子</strong>；并且我们了解到，对于某一个点$u$，他的<strong>所有子节点到他的距离要比到他的父亲的距离少$1$</strong>（假设边权$=1$），同时所有<strong>除其子树之外的所有点到他的距离会多$1$</strong>.那么转移方程旧顺水推舟地：</p>
<script type="math/tex; mode=display">
dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u</script><p>那么接下来我们思考，当边权不为$1$的时候呢？我们可以稍微魔改一下上式，于是就得到</p>
<script type="math/tex; mode=display">
dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + N \cdot pre_v</script><p>其中$pre_i$表示节点$i$的上行边，即父亲与它相连的那条边。</p>
<p>那么以上简单版本的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAX] ; <span class="keyword">int</span> head[MAX], cnt ; </span><br><span class="line"><span class="keyword">int</span> N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	sub[now] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		build(to(k), now) ;  </span><br><span class="line">		sub[now] += sub[E[k].to], dp[<span class="number">1</span>] += sub[E[k].to] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwork</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[k].to == f) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[E[k].to] = dp[now] - <span class="number">2</span> * sub[E[k].to] + N ;</span><br><span class="line">		fwork(to(k), now) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), _Add(A, B) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>) ; fwork(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一值得注意的地方就是其中$dp_1$或者说$dp_{root}$的处理。那么其实这个地方我们只需要不断加$size$即可。</p>
<p>高端版本的问题，代码类似：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	Sub[now] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		build(to(k), now) ;  Pre[to(k)] = E[k].v ;</span><br><span class="line">		Sub[now] += Sub[to(k)], dp[<span class="number">1</span>] += Pre[to(k)] * Sub[to(k)] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[to(k)] = dp[now] - <span class="number">2</span> * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C), Add(A, B, C) ;;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>) ; dp_work(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。</p>
<p>我们致力于维护这样一个东西：对于每个$u \in T$， 我们试图确定除$u$及其子树外，到$u$点距离是奇数的点的个数$S0$$\&amp;$距离是偶数的点的个数$S1$，以便于状态转移时，作为第二部分。那么平均树高下，直接在$dfs/bfs$里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要$swap$一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）：</p>
<script type="math/tex; mode=display">
dp[to(k)][0] = dp[now][1] - Sub[to(k)][0] * Pre[to(k)] \\ dp[to(k)][1] = dp[now][0] - Sub[to(k)][1] * Pre[to(k)] ，\\ dp[to(k)][0] += S0 * Pre[to(k)] , \\ dp[to(k)][1] += S1 * Pre[to(k)] ;</script><p>其中$to(k) \in son_{now}$</p>
<p>而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）：</p>
<script type="math/tex; mode=display">dp[to(k)][1] = dp[now][1] - Sub[to(k)][1] * Pre[to(k)] ;\\ dp[to(k)][0] = dp[now][0] - Sub[to(k)][0] * Pre[to(k)] ;\\        dp[to(k)][1] += S1 * Pre[to(k)],\\         dp[to(k)][0] += S0 * Pre[to(k)] ;</script><p>于是就结束了。其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句：</p>
<script type="math/tex; mode=display">
dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_vs</script><p>其中$Count$表示某种神秘的计数。。。。</p>
<p>那么其实这种问题还可以拓展到“求对于每一个点$u$，$dist(u,v) \mod n =k$的点的个数，其中$k \in [0,k-1]$，我感觉做法应该会类似吧<del>（但是我肯定不会做因为根本不可能调的出来）</del></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul>
<li>没啥好说的，只觉得第三模块的例题十分难调！十分难调！！！并且……我一开始没用$S0$或者$S1$，直接用的根节点的$sub_0$和$sub_1$，最后才法案根本不和逻辑。。。但他居然过样例了。。。</li>
<li>转移的时候还是需要有一个清醒的思路再code啊！</li>
<li>$DP$好啊！</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>树模型</tag>
        <tag>动态规划/树形DP</tag>
        <tag>数据结构/数据结构方法/轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性规划入门</title>
    <url>/2019/03/15/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<p>许久之前开始学的算法了…今天终于学完了。主要参考的材料是董克凡的 $ 2016 $ 集训队论文和 $ \rm{Candy?} $ 的代码整理，在此处致以敬意。</p>
<hr>
<h1 id="rm-0x01-Preface"><a href="#rm-0x01-Preface" class="headerlink" title="$ \rm{0x01~ Preface} $"></a>$ \rm{0x01~ Preface} $</h1><p>线性规划主要解决的问题是：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)</script><p>不失一般性的，我们定义最大化的函数为<strong>目标函数( $ \rm{Aim-Func} $ )</strong> ，定义约束函数的集合为<strong>约束函数集( $ \rm{Constraint-Set} $ )</strong>。那么朴素的线性规划可以看求一组向量{ $ x_1,x_2\cdots x_n $ }，使之既可以做约束函数的因变量，又满足其目标函数的值为 $ max $ 。</p>
<p>同时，规定所有的 $ x $ 均满足 $ x&gt;0 $ 。</p>
<a id="more"></a>
<p>当然，存在一种更加赏心悦目的矩阵表示方式：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \boldsymbol{c^Tx} \\
\text{满足约束} \quad A\boldsymbol{x\leq b} \\\
\it{\qquad \qquad \quad} \boldsymbol {x} \geq 0</script><p>其中 $ \boldsymbol{c,x,b} $ 均为一维向量， $ A $ 为系数矩阵。</p>
<p>那么我们在高中数学必修五里面运用的智障做法是，通过每个约束确定一个凸包，再用目标函数不断平移以求得与凸包的切点/切线来达到最大值，但是这样的做法通常不具有一般性。所以需要引入一种更常用的方法来解决这类问题。</p>
<h1 id="rm-0x02-松弛型矩阵与-rm-Pivot-操作"><a href="#rm-0x02-松弛型矩阵与-rm-Pivot-操作" class="headerlink" title="$ \rm{0x02} $  松弛型矩阵与 $ \rm{Pivot} $ 操作"></a>$ \rm{0x02} $  松弛型矩阵与 $ \rm{Pivot} $ 操作</h1><p>我们考虑一种更加友好的线性规划方式——<strong>松弛型矩阵</strong>，即将原来的矩阵添加几个无实际作用的新变量 $ x_i $ ，使之换一个样子：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} \quad (i = 1,2,3\cdots m) \\\ \qquad\quad  x_j \geq 0\quad (j=1,2,3\cdots n+m)</script><p>两种表示是等价的，但是我们更倾向于松弛型这种简洁的表述方式。</p>
<p>同时我们规定以下：</p>
<p> $ 1. $ 基变量：在松弛型约束中，等式左边的变量。</p>
<p> $ 2. $ 非基变量：在松弛型约束中，等式右边的变量。</p>
<p>那我们定义一次<strong>转轴操作 $ (pivot) $ </strong>为<strong>将一个基变量换进等式右边，换出一个非基变量的过程</strong>。</p>
<p>假设我们在第 $ i $ 组约束中，有一个变量 $ x_k~(k&gt;n) $ 是基变量，我们要换出一个非基变量 $ x_p~(1\leq p\leq n) $ ，那么就会由：</p>
<script type="math/tex; mode=display">
x_k= b_i -\sum \limits_{j=1}^{n} a_{i,j}x_{j}</script><p>变成</p>
<script type="math/tex; mode=display">
x_p = \frac{b_i - \sum \limits_{j\neq p}a_{i,j}x_j -x_k}{a_{i,p}}</script><p>而单纯性做法的本质就是通过不断转轴，实现目标函数不断变大。</p>
<p>看上去似乎比较抽象？我们考虑对一次转轴操作，我们需要在转轴之后将原来目标函数里的非基变量代入，即用 $ (b_i - \sum _{j\neq p}a_{i,j}x_j -x_k)/a_{i,p} $ 这个东西去替换掉 $ x_p $ ，那么其中的常数项 $ \frac{b_i}{a_{i,p}} $ 就可以作为目标函数中的一个常数值，当 $ x_i~(i=1,2,3\cdots n) $ 均为 $ 0 $ 时，目标函数的值即为此。那么转轴操作就是通过这样的操作使得目标函数里的常数值不断增大，达到最优解。</p>
<p>注意，转轴之后的得到的 $ x_p $ 的表达式，不仅要代入目标函数，也要代入其余的约束。</p>
<h1 id="rm-0x03-rm-Simplex"><a href="#rm-0x03-rm-Simplex" class="headerlink" title="$ \rm{0x03}~ \rm{Simplex} $"></a>$ \rm{0x03}~ \rm{Simplex} $</h1><p>那么接下来，我们考虑单纯性做法的完整过程。</p>
<p>不失一般性的，我们假设所有 $ b_i\geq 0 $ </p>
<p>首先，我们对于转轴操作结束，回代一次之后，会发现目标函数中肯定会有至少一项系数变为负值，即转进来的前·基变量 $ x_k $ ，那么增大 $ x_k $ 一定会让结果目标函数变小。所以我们可以断言，<strong>当目标函数里的所有变量系数均为负值时，目标函数的最优值就会是现在目标函数中的常数值</strong>——因为我们在前文已经假定 $ x_i\geq 0 $ 了。</p>
<p>同样，我们每次转轴操作需要保持原来线性规划的不变性，换句话说就是我们每次转轴时<strong>都需要找一个对与某个非基变量限制最紧的约束，将其换出</strong>。原因是我们考虑目标函数中的 $ x_i $ ，当其系数 $ \geq 0 $ 时， $ \rm{Aim  }\propto x_i $ ，所以我们需要找一个最紧的约束<strong>遏止</strong> $ x_i $ 的增长(即使我们不想)。</p>
<p>那么伪代码如下， $ A,\boldsymbol{b,c} $ 的定义一开始已给出：</p>
<hr>
<p>Simplex(A, b, c){<br> $ \qquad $  initialization(A,b,c)  ;<br> $ \qquad $  while  $ ∃e $  that  $ c_e&gt;0 $ {<br> $ \qquad  \qquad $ find the index  $ l $  that  $ A_{l,e} $   $ &gt; 0 $  and minimizes  $ b_l/A_{l,e} $<br> $ \qquad \qquad $ if  $ ∀l, A_{l,e} ≤ 0 $<br> $ \qquad \qquad \qquad $ return Unbounded ;<br> $ \qquad \qquad $ else<br> $ \qquad \qquad \qquad $ pivot(A, b, c, l, e)；<br>}</p>
<hr>
<p>值得注意的是，如果在寻找完最紧约束后，存在一个 $ A_{l,e} \leq 0 $ ，那么我们在这组约束里无论怎么增大 $ x_e $ 都会使得目标函数增大，所以直接<code>return Unbounded</code>。</p>
<p>此时我们还需要进行额外的操作，即初始化。因为我们转轴操作的目的是使目标函数增大，所以我们需要保证所有的 $ b_i\geq 0 $ ，但一开始给定的 $ b_i $ 很可能不满足这一约束，所以我们需要进行一次初始化。那么对于初始化，我们的思想是做另一次线性规划。<del>鬼知道那些发明这玩意儿的神仙怎么构造出的这个线性规划。</del></p>
<p>我们考虑一个这样的线性规划：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad -x_0 \\
\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} +x_0\quad (i = 1,2,3\cdots m)\\
\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=0,1,2,3\cdots n)</script><p>首先，无论怎样，先思考他会不会对原来的线性规划产生什么影响——答案是：不会。因为我们考虑当 $ -x_0 $ 最大时，一定是 $ x_0=0 $ 的时候。所以对于约束中的 $ x_{n+i} $ ，大小不会变化。</p>
<p>那么我们考虑这种初始化方式的正确性。我们考虑每次都将 $ x_0 $ 作为换入变量(即我们一开始将 $ x_0 $ 视作非基变量)，那么 $ pivot $ 之后就会有</p>
<script type="math/tex; mode=display">
x_0 = -b_i+x_{i+n}+\sum\limits_{j=1}^{n}a_{i,j}x_j</script><p>由于我们一定找的时限制最小的，那么 $b_i\lt 0\Longrightarrow-b_i\gt 0$ ，这组约束合法。</p>
<p>对于其余的约束，我们考虑代入之后，会有：</p>
<script type="math/tex; mode=display">
x_{n+k}= b_k-b_i+\sum\limits_{j=1}^{n}(a_{k,j}-a_{i,j})x_j+x_{i+n}</script><p>由于 $ b_i $ 最小，那么 $ b_k\geq b_i \Longrightarrow b_k-b_i\geq 0 $ 。任务完成。</p>
<p>那么就可以愉快地上代码辣(≧▽≦)/！题目来自于<a href="http://uoj.ac/problem/179" target="_blank" rel="noopener"> $ \rm{UOJ179} $ </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e15</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, T, Id[MAXN], i, j ; <span class="keyword">double</span> A[MAXN][MAXN], Get[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    swap(Id[N + l], Id[e]) ;<span class="comment">//交换两个变量</span></span><br><span class="line">    <span class="keyword">double</span> t = A[l][e] ; A[l][e] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= N ; ++ i) A[l][i] /= t ;<span class="comment">//类似于高斯消元的第一步，把这一项挪到等式右边，所以要先都除以系数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= M ; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(A[i][e]) &gt; eps)</span><br><span class="line">            <span class="keyword">for</span>(t = A[i][e], A[i][e] = j = <span class="number">0</span> ; j &lt;= N ; ++ j) </span><br><span class="line">              A[i][j] -= A[l][j] * t ;<span class="comment">//此处则是代换。而由于代数式中肯定不会出现我们的A_&#123;i,e&#125;(毕竟是换到了等式右边)，所以对于这一项的系数要特殊处理成0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span> ; <span class="keyword">double</span> t = -eps ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][<span class="number">0</span>] &lt; t) l = i, t = A[i][<span class="number">0</span>] ; <span class="keyword">if</span>(!l) <span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//找系数最小的负值项</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; <span class="number">1</span>))) e = j ;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Infeasible"</span>), <span class="literal">false</span> ;  Pivot(l, e) ;</span><br><span class="line">    &#125;<span class="comment">//不合法的线性规划，因为我们假设全部的系数都为正，且我们前面已经假定了全部x_i为正，那么不可能满足标准型里面的小于b_l——此时b_l为负值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, e = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[<span class="number">0</span>][j] &gt; eps) &#123; e = j ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span>(!e) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][e] &gt; eps &amp;&amp; A[i][<span class="number">0</span>] / A[i][e] &lt; MAX) MAX = A[i][<span class="number">0</span>] / A[i][e], l = i ;<span class="comment">//选个最紧的约束</span></span><br><span class="line">        <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Unbounded"</span>), <span class="literal">false</span> ; Pivot(l,e) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; T ; srand(<span class="number">19260817</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Id[i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; A[<span class="number">0</span>][i] ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; <span class="built_in">cin</span> &gt;&gt; A[i ++][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="built_in">cin</span> &gt;&gt; A[i][j] ; </span><br><span class="line">    <span class="keyword">if</span> (!(Init() &amp;&amp; Simplex())) <span class="keyword">return</span> <span class="number">0</span> ; <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, -A[<span class="number">0</span>][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) Get[Id[N + i]] = A[i][<span class="number">0</span>] ; </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%.8lf "</span>,Get[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然鹅事实上这份代码只有 $ 97pts $ …好像剩下3分就几乎没有人得过，除了kcz和std……</p>
<p>至于中间的<code>srand</code>，是由于我们随便 $ pivot $ 一个 $ e $ 就好，于是就<del>听长者的</del>。</p>
<h1 id="rm-0x04-Afterwords"><a href="#rm-0x04-Afterwords" class="headerlink" title="$ \rm{0x04}~ Afterwords $"></a>$ \rm{0x04}~ Afterwords $</h1><p>一直想学，一直没有机会学。</p>
<p>说起来确实有点儿小激动。第一次写单纯型的代码是前不久的一次周末，早上点起来之后头昏脑涨地扑向Candy?的博客，学了起来。在那之后才发现原来线性规划并不常考，甚至说，不考。但是我挺喜欢这种感觉，<del>感觉自己仿佛比出题人会的还多</del></p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $ Candy? $ 的 $ blog $  <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>目测用不到的算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>随想六 · 难</title>
    <url>/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近心绪颇不宁静。</p>
<a id="more"></a>
<p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">$Link$</a></p>
<h2 id="text-Part0"><a href="#text-Part0" class="headerlink" title="$\text{Part0}$"></a>$\text{Part0}$</h2><p>不知道为什么，最近的心绪颇不宁静。</p>
<p>那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。</p>
<p>我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。</p>
<p>这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。</p>
<p>毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。</p>
<p>就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。</p>
<h2 id="text-Part1-cdot-Her"><a href="#text-Part1-cdot-Her" class="headerlink" title="$\text{Part1}\cdot Her$"></a>$\text{Part1}\cdot Her$</h2><p>“她”是谁？</p>
<p>我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系：</p>
<blockquote>
<p>头一次清晨在无人的校园里闲逛，<br>耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，<br>眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。<br>一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。<br>好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光——</p>
</blockquote>
<p>最后一句本来是<code>但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系</code>，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。</p>
<p>我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。</p>
<p>我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？……</p>
<p>以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说：</p>
<blockquote>
<p>大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。</p>
</blockquote>
<p>她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。</p>
<h2 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h2><p>我很烦。</p>
<p>机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。</p>
<p>我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年<code>NOIP</code>考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？</p>
<p>好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊…</p>
<p>最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了……</p>
<h2 id="rm-Part4"><a href="#rm-Part4" class="headerlink" title="$\rm{Part4}$"></a>$\rm{Part4}$</h2><p>不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。</p>
<p>其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望：</p>
<blockquote>
<p>我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。</p>
<p>同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。</p>
<p>如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。</p>
<p>没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。</p>
<p>保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙——</p>
<p>你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？</p>
<p>你知道每年有多少初中生在NOIp中碾压高中生吗？</p>
<p>你不知道。</p>
<p>每天几个小时？</p>
<p>做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。</p>
<p>你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。</p>
<p>我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。</p>
</blockquote>
<p>看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。</p>
<p>为什么会这么难呢？我不知道啊。</p>
<p>我只知道我的机会确乎是不多了。</p>
<p>今年省选还有没有戏呢？我也不知道。</p>
<p>我只知道我的时间不多了。</p>
<p>不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。</p>
<p>呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。</p>
<p>这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想四 · 故人故事</title>
    <url>/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我一直在想，这篇到底该怎么写，到底该写什么。</p>
<p>但才发现，想要回忆的太多了啊。</p>
<p>但既然是讲故人故事的，那就讲好了。</p>
<p>这是段什么故事呢？这是段我不想讲也不会讲的故事吧。</p>
<a id="more"></a>
<h1 id="0"><a href="#0" class="headerlink" title="$0$"></a>$0$</h1><p>说实在的，这篇文章我写了好多好多不同的版本，但都是写了一两段不想写了，感觉越写越智障。今天是 <code>11/1/2020</code> ，不知道为啥突然就啥都不想干了，于是就来补一下。</p>
<p>我们这一级，应该是最特殊的吧？我们来的前一年9月实验部成立，来的第一年10月因为高三太菜了，实验部解散；我们的学长是rqy，这份奇怪的缘分奇怪在，我们些人连续参加了 $4$ 年的 $noip$，每次都和 $rqy$ 一起参加——就算是和他同级的人也没有这种缘分。同样，我们也是老校最后一批初三，新校第一批高一</p>
<p>总之呢，这让我想起一句话：</p>
<blockquote>
<p>过去与未来的交叉点就是当下,而我正站在这个点上。 ——梭罗《瓦尔登湖》</p>
</blockquote>
<h1 id="1-老校-·-衔接班-·-光明"><a href="#1-老校-·-衔接班-·-光明" class="headerlink" title="$1$ 老校 · 衔接班 · 光明"></a>$1$ 老校 · 衔接班 · 光明</h1><p>还在老校的时候，每天最烦的就是考试，因为我老是垫底。</p>
<p>我 $2019$ 年一月份来的实验部，直到现在也一直觉得自己是混上来的，因为我觉得我考的很差，可能只是因为初三提高组写了个小凯的疑惑水到了省三而被潜规则上来的。当时刚来的时候十分愉快，每天 $5:30$ 起，太新奇了。高中部四处都是新鲜的环境，种类繁多的动物小卖部，再加上我初三一直很稳地霸占着全班第一，觉得自己人生到达了一个小顶点。</p>
<p>刚来的时候，是 $12$ 个人。我在其中的实力不算高。只记得刚来的时候，由于大家初中是就挺熟，所以也了解彼此的八卦。在阿淳帮獴哥给他的大番薯女神用qq表（机）完白（惨）之后（至于为什么叫大番薯…我承认这是我起的绰号，因为他女神和《老夫子》里面的大番薯一样可爱233），獴哥被无情拒绝，之后这就变成了我们机房初来实验班的第一个梗。嗯，其实我并没有多老实，因为接下来两天，我外放了两天的《好日子》来庆祝獴哥表白失败，233.</p>
<p>不过之后可能是遭报应了，由于在高中部食堂吃了一碗烤鸡心，肠胃发炎在学校高烧了两天——当时我说什么都不会请假的。所以现在我在打出「烤鸡心」这三个字的任意一个组合或者某个后缀的时候都会感到恶心。</p>
<p>之后呢？之后我不知道为什么就被选成了队长。然后大家就开始在高中部吹水，每天去洛谷做题，从上到下挨着刷，不过我大多数都是在抄题解。</p>
<p>渐渐地，我的缺点终于暴露了——我很偏执。这就直接导致了我的领导十分「黑暗」，也可能是因为大家都太有个性了，初中的时候都是班里叱咤风云的人物，所以都不是很服。当然了，矛盾啥的最后也都不了了之，大多数时候大家还是很和睦的。</p>
<p>衔接班，也就是实验班被选出来提前在高中部学习的那半年，挺快乐的。但就是考试自己老是不会，然而自己当时唯一找出的原因就是「别人经验丰富」，233。</p>
<p>期间经历过什么呢？经历过最难忘的一次培训，那是在二月。年前刚来实验部的愉悦加上马上过年的期盼，每天和lzr&amp;qcr吃鸡吃到凌晨三四点，四点多开始写博客，8点多起床直奔讲课地点也来不及吃早饭，于是饭票几乎就没用过；自我感觉是收获比较多的一次培训。因为在那之后，经过一位HB巨佬的指正，我学会了线段树（之后才发现原来跟线段没有关系），再之后我就写出了洛谷上「线段树」的题解——当时的洛谷还不是这么热闹。</p>
<p>现在回想起来，真幸福啊。</p>
<p>比较悲伤的几件事，就是来的前几天就被主任给抓了晚上在宿舍说话（8个人有7哥在闲扯），被罚干一学期的值日并且挂名「物业公司」；四月底又因为在奥赛室里开qq群吹水+换了一张sexy Miku的高清图做桌面而被赶回家过了个黄金周……</p>
<p>然后就是无止尽的失恋，如果我可以这么说的话。因为毕竟妹子都没喜欢过我qaq。</p>
<p>记得当时的大家：</p>
<p>dyz作为我们之中唯一的女选手，很要强很认真，会自己申请不放假留校学习；</p>
<p>ljp每天和wx黏在一起并伙同我们一起给wx起名为「王强」，毕竟wx确实很强；</p>
<p>yjk由于每次考试都rank1深受金牌教练喜爱被我们称为「干儿子」，是个骚包；</p>
<p>lwy做题速度总是很快，我也不知道「影流殿」是个什么梗（一直到去年年底「影流之主」的爆火我才知道）；</p>
<p>wxl一直被我们怂恿去跟他暗恋的妹子表白，直到拍毕业照那天他才真敢去表白；</p>
<p>獴哥一直很稳，由于和别人水群被组cp，同时由于我们的宿舍和初三宿舍以及买学习用品的小卖部面对面，导致每次他的「大番薯女神」经过旁边的商店都被我们起哄；</p>
<p>qcr给自己起了个Id叫做「邱城锐大神」，在明白OI的生存法则之后感到失去梦想，然而他经常因为看小说被抓，因此也掌握了各种「装作自己不在看小说但实际上就是在看」的看小说方法（比如复制进luogu的剪贴板）；</p>
<p>lzr十分颓，经常和qcr被成对抓包，但他主要是在搓游戏；由于初中的时候同班，所以我有什么事儿都会先同他讲——他也很仗义，在我们的水群被抓包、我要被赶回家的时候，他站出来跟主任解释不全是我的锅（虽然最后还是因为我身为队长也在水群被赶回去黄金周了）；</p>
<p>阿淳作为唯一有女票的，被我们整天起哄——我们用「大河」代指他的女票，你没猜错这也是我起的绰号（文学带师.jpg）；同时后期的他也是html（读作『喝特么了』）带师，博客园美化小能手，甚至真的拿了奥赛室的一本html教材开始学orz；</p>
<p>ZZH一度是我们中做题做的最多的，也是八卦八的很频繁的：他自诩为钢铁直男（虽然，indeed），同时一直暗恋着一个妹子但是一直不表白（因为那个妹子也来了实验班，不过不是我们班的233）——还有，我自诩为全奥赛模仿ZZH模仿的最像的，我把他回答问题/说话时的「慢<del>~</del><del>~</del>~~条斯理」模仿的淋漓尽致。</p>
<p>嗯，那我呢？似乎因为我写的博客都很详细，所以获得了一堆赞，自己也很开心；至于组织学习方面，我组织大家每个人都去学不同的新算法然后互相教给对方，学了一堆比如网络流、splay、莫队、treap之类的新奇东西，也补了一下dp、搜索之类的基本功。</p>
<p>关于这个活动…评价几点吧：</p>
<ul>
<li>我主张的学splay——当时仿佛大家都觉得splay，名字简短但是总感觉蕴含着复杂有趣的道理，于是决定wx讲二叉搜索木和treap，我讲splay.</li>
<li>…如果说我们这一级到底出了什么问题，那可能就是基础不扎实吧。作为始作俑者，我自裁qaq</li>
</ul>
<p>还有学长啊。一直在骑砍（233）的邱神、不熟的学长hmr，mzq、一开始不熟但慢慢熟得很的zay（虽然现在已经变成了我的同学），还有rqy。</p>
<p>老校的天，总是变得很慢很慢；老校的日子，也总是过的很慢很慢。和lzr、qcr一起打乒乓球，当时的我为什么会觉得，这一球一球、来回翻飞之间，时光会流的这么慢呢？走在吃饭的路上、为了不迟到奔跑在凌晨五点的操场上、在月光下慢悠悠地走在回宿舍的路上，为什么，为什么这时光总是过得这么慢呢？</p>
<p>慢啊，慢到我都忘记了，忘记了这一切，总是会有个尽头的。</p>
<h1 id="2-新校-·-高一-·-总是离别"><a href="#2-新校-·-高一-·-总是离别" class="headerlink" title="$2$ 新校 · 高一 · 总是离别"></a>$2$ 新校 · 高一 · 总是离别</h1><p>终于，獴哥因为忍受不了主任的精英论调，去了右校。</p>
<p>终于，唯一的女生dyz由于文化课的繁重，在马上要联赛的时候退出了奥赛。</p>
<p>终于，联赛之后，zzh走了。我一直在想，他决心要走的时候，内心会有多不舍呢？可能再也没有答案了。</p>
<p>终于，阿淳也不学了，只剩了8个人。</p>
<p>离别，不只是人离别。我离别了自己初中时的快乐，开始变得阴郁，变得更加偏执。但不知道为什么，我就是难以放下奥赛。啊，可能美其名曰是执念吧。但是我可能只是，在那些个时间还会慢慢流淌日子里，已经幻想出自己取得好成绩会去怎样地庆祝——如同驾驶着一匹难以驾驭的马，要我停下，我也很难去放手。</p>
<p>我不得不承认，其实这段时光过的才是最漫长的——有着一眼望不到头的文化课、做着一眼望不到头的不会的习题、接受着一眼望不到头的失败。天分不够，努力更不够。在广袤的天地间，我又算什么呢？</p>
<p>但其实站在现在的角度，我会感恩这段时光，感恩这段碌碌无为的时光。它告诉了我，最差劲、最迷茫、最没有希望的一段日子该怎么走。这期间我翘课去准备省选，但就是在玩；这期间我用「努力」欺骗了自己，实际上根本没有多努力；这期间我用「菜是原罪，有bb、感叹人生的时间，不如多做点题来提升你那本来就微不足道的实力」来说服自己，结果发现这根本就是不是适合我的心态。</p>
<p>总之呢，在老庄(班主任)的关照下，我待在自己的舒适区里，安静地睡着。</p>
<p>直到暑假的到来。</p>
<h1 id="3-暑假-·-外出培训-·-Simon"><a href="#3-暑假-·-外出培训-·-Simon" class="headerlink" title="$3$ 暑假 · 外出培训 · Simon"></a>$3$ 暑假 · 外出培训 · Simon</h1>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】扩展的BSGS</title>
    <url>/2019/02/22/exBSGS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<hr>
<h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>$emmm$严格来讲，不应该被算到一个模板里面。因为在我看来<strong>模板</strong>是人构造出来的，但是这个算法应该是一个解决问题的$process$…更像是在解一道数学题，如果$BSGS$是定理的话，$exBSGS$更像是一个不断转化的过程233（手动@lxa并且溜</p>
<h1 id="rm-0x02-quad-Algorithm-Process"><a href="#rm-0x02-quad-Algorithm-Process" class="headerlink" title="$\rm{0x02\quad Algorithm~Process}$"></a>$\rm{0x02\quad Algorithm~Process}$</h1><p>今天才发现原来$\rm{BSGS}$有两种写法……并且觉得剩下的题解讲的都讲的不是很全的样子233。</p>
<p>其实本质上，当$p$不为素数时，我们无法进行朴素$\rm{BSGS}$的原因是我们的欧拉定理$a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理$(a,p)=1$的情况。那么我们知道，朴素的$\rm{BSGS}$的关键在于，可以保证最小解是有界的——$x$一定在$[1,\varphi(p)]$中。所以最后$BSGS$的复杂度才会是$\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的$p$是素数的情况下，时间复杂度为$\Theta(p)$。</p>
<p>那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。</p>
<p>我们思考，对于同余式$a^x\equiv b (\bmod p)$而言，我们先假定$(a,p)&gt;1 $。而此时如果有$((a,p), b)=1$，那么说明此式只有可能在$x=0,b=1 $的时候有解——这个结论是平凡的。因为假设我们把它展开成$a\cdot a^{x-1} +kp=b $的形式，必须要有$(a,p)  |  b$的情况下，才能保证$a^{x-1}$和$k $都是整数。</p>
<p>那么对于$(a,p)&gt;1$且$(a,p)  |  b $，我们令原式变成</p>
<script type="math/tex; mode=display">
a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} (\bmod \frac{p}{(a,p)})</script><p>的样子，如果此时$(a^{x-1},\frac{p}{(a,p)})=1$ 的话，我们就直接解</p>
<script type="math/tex; mode=display">
a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }(\bmod \frac{p}{(a,p)})</script><p>这个方程即可。否则我们继续分解直至$(p’,a)=1$。</p>
<p>那么此时有个问题需要注意，就是如果们在解这个方程时，出现了</p>
<script type="math/tex; mode=display">
(a^{x-1}, \frac{p}{(a,p)})\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }</script><p>的情况，那我们需要特判并<code>return -1</code> ；另一种情况，如果我们出现了</p>
<script type="math/tex; mode=display">
a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1(\bmod \frac{p}{(a,p)})</script><p>的情况，也需要特判并输出此$k$（此时同余式左边是$a^{x-k}$，因为$a^{x-k}\equiv1~(\bmod p)$所以直接输出$k$），不过也有可能不需要，完全看你写的$BSGS$能不能判断$x=0$的情况……一般情况下不能。</p>
<p>此时<strong>由于$\boldsymbol{p}$不再是素数，所以不能用费马小定理，需要我们用$exgcd$的方法求逆元，包括但不限于$\frac{b}{(a,p)}$的逆元和$a^{-im}$。</strong></p>
<p>以下是完整版代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; H ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, ans ; <span class="comment">// N ^x = M (mod P)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a ;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b) res = ((b &amp; <span class="number">1</span>)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line"> 	ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll mod, ll qaq)</span></span>&#123;</span><br><span class="line">    H.clear() ; ll Q, p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), x, y ; </span><br><span class="line">    exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, </span><br><span class="line">    Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * a % mod)  <span class="keyword">if</span> (!H.count(i)) H[i] = j ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = b, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * Q % mod)  <span class="keyword">if</span> (H[i]) <span class="keyword">return</span> j * p + H[i] ; <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll qaq = <span class="number">1</span> ;</span><br><span class="line">    ll k = <span class="number">0</span>, qwq = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">while</span> ((qwq = gcd(N, P)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (M % qwq) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ;</span><br><span class="line">        <span class="keyword">if</span> (qaq == M) <span class="keyword">return</span> k ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (qwq = BSGS(N, M, P, qaq)) == <span class="number">-1</span> ? <span class="number">-1</span> : qwq + k ;</span><br><span class="line">&#125;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;P, &amp;M); <span class="keyword">if</span> (!N &amp;&amp; !M &amp;&amp; !P) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        N %= P, M %= P, ans = exBSGS() ; <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x03-quad-Afterword"><a href="#rm-0x03-quad-Afterword" class="headerlink" title="$\rm{0x03\quad Afterword}$"></a>$\rm{0x03\quad Afterword}$</h1><p>今天才知道原来$BSGS$有两种写法qaq</p>
<p>$zyf2000$好像和我写的$BSGS$对“大步”和“小步”的定义不是很一样…于是最后还是自己$\rm{yy}$的233</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$zyf2000$的$blog$ <a href="https://blog.csdn.net/clove_unique/article/details/51227328" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】拆系数FFT</title>
    <url>/2019/02/19/FFT2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt></p>
<p>上一篇多项式：<a href="http://www.orchidany.cf/2019/02/19/FFT1/" target="_blank" rel="noopener">多项式1·普通的FFT</a></p>
<hr>
<h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。</p>
<p>由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做<del>抄</del>完，所以就先整理地仓促一点。</p>
<p>首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接<code>long long</code>爆艹。</p>
<h1 id="rm-0x02-Normal-Coefficient-Spliting-FFT"><a href="#rm-0x02-Normal-Coefficient-Spliting-FFT" class="headerlink" title="$\rm{0x02~Normal-Coefficient-Spliting~FFT}$"></a>$\rm{0x02~Normal-Coefficient-Spliting~FFT}$</h1><p>首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成</p>
<script type="math/tex; mode=display">
A_i = a_iM+b_i~(0\leq b_i <a_i) \\
B_i = c_iM+d_i~(0\leq d_i <c_i)</script><p>的形式。然后我们做乘法的话，会有</p>
<script type="math/tex; mode=display">
A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i</script><p>那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。</p>
<p>那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$</p>
<script type="math/tex; mode=display">b_i\cdot d_i \approx \Theta(M^2)</script><script type="math/tex; mode=display">a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)</script><script type="math/tex; mode=display">(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor)</script><p>那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], L, x ; <span class="keyword">long</span> <span class="keyword">long</span> Ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + <span class="number">0.5</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; </span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, t ; <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = <span class="number">32767</span> ; N = <span class="number">1</span>, t = L1 + L2 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; </span><br><span class="line">    <span class="keyword">while</span>(N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ L ; rep(i, <span class="number">0</span>, N) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>), FFT(C, <span class="number">1</span>), FFT(D, <span class="number">1</span>) ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; </span><br><span class="line">    FFT(H1, <span class="number">-1</span>), FFT(H2, <span class="number">-1</span>), FFT(H3, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        Ans[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)H1[i].x * M % P * M % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H2[i].x % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H3[i].x * M % P) % P ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。</p>
<p>但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是——</p>
<h1 id="rm-0x03-Conjugate-Optimization"><a href="#rm-0x03-Conjugate-Optimization" class="headerlink" title="$\rm{0x03~Conjugate~Optimization}$"></a>$\rm{0x03~Conjugate~Optimization}$</h1><p>源自毛啸的《再探快速傅立叶变换》。</p>
<p>我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$</p>
<script type="math/tex; mode=display">
\rm{P(x) = A(x) + iB(x)} \\
\rm{Q(x) = A(x) - iB(x)}</script><p>我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。</p>
<p>同时，令$\text{conj(x)}$表示对$x$取共轭。</p>
<p>那么会有$^{[5]}$：</p>
<script type="math/tex; mode=display">
\begin{align}
P'[k] &= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\
& = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\
& = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\
& =  \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}
\\
Q'[k] &= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\
& = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\
& = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\
& = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\
& = \text{conj} \left( P'[n-k] \right)
\end{align}</script><p>好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。</p>
<p>那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：</p>
<script type="math/tex; mode=display">
A'[k] = \frac{P'[k] + Q'[k]}{2} \\
B'[k] = \frac{P'[k] - Q'[k]}{2i}</script><p>哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$.</p>
<p>以下是共轭优化$FFT$的初号机：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], Len, x, Ans[MAXN] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node(r, -i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                node T = w[N / j * l] ; T.i *= flag ;</span><br><span class="line">                node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; <span class="keyword">while</span> (N &lt;= L) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node ia, ib, a1, a2, b1, b2 ;</span><br><span class="line">    rr <span class="keyword">int</span> i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  FFT(t1, <span class="number">-1</span>), FFT(t2, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / N + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / N + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / N + <span class="number">0.5</span>) % P, Ans[i] = ((((<span class="keyword">long</span> <span class="keyword">long</span>)q3 &lt;&lt; <span class="number">30</span>) % P + ((<span class="keyword">long</span> <span class="keyword">long</span>)q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P + P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) f[i] = qr() % P ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x04-quad-拼命卡常"><a href="#rm-0x04-quad-拼命卡常" class="headerlink" title="$\rm{0x04\quad}$拼命卡常"></a>$\rm{0x04\quad}$拼命卡常</h1><p>好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$）</p>
<p><img src="1.png" alt></p>
<p>然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）：</p>
<p><img src="2.png" alt></p>
<p>特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$:</p>
<p><img src="3.png" alt></p>
<p><img src="4.png" alt></p>
<p>好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点……</p>
<p>于是考虑对共轭优化的进行大力卡常：</p>
<ul>
<li>多次使用的非全局变量。使用<code>register</code>修饰符。</li>
<li>将$double$转换成为$long~double$ 。</li>
<li>减少取模次数。</li>
<li>从yjk那里偷来的$\rm{fread/fwrite}$</li>
</ul>
<p>一番操作之后，我们成功地卡到了第五页上……</p>
<p><img src="5.png" alt></p>
<p>最后奉上最快的代码qwq：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 102333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 272333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    	<span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    	<span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    	*++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[MAXM], Len, x, Ans[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node(r, -i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;<span class="comment">//定义的Complex型是用来进行复数运算的 </span></span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> <span class="keyword">double</span> &amp;Q) &#123; <span class="keyword">return</span> (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    rr node t ;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                rr node T = w[N / j * l] ;</span><br><span class="line">            	rr node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + N), FFT(J) ; </span><br><span class="line">    rr <span class="keyword">int</span> i ; rr <span class="keyword">double</span> qwq = <span class="number">1.0</span> / N ; </span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) J[i] = J[i] * qwq ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    rr <span class="keyword">int</span> i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; </span><br><span class="line">    t = ((L1 = read()) + (L2 = read())), P = read(), N = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)), R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A), FFT(B) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">    IFFT(t1), IFFT(t2) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        write(((ll)(t1[i].r + <span class="number">0.5</span>) + ((ll)(t1[i].i + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">15</span>) + ((ll)(t2[i].r + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">30</span>)) % P) ;</span><br><span class="line">    fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！<br><img src="6.png" alt></p>
<h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？</p>
<p>但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢……</p>
<p>并且在学的过程中顺便认识了一个巨佬<code>CMXRYNP</code>，嘿嘿，也算不亏啦。</p>
<p>本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$.</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$lvzelong2014$的$blog$ <a href="https://blog.csdn.net/lvzelong2014/article/details/80156989" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[2]$:<code>无梦之梦</code>的$blog$ <a href="https://www.cnblogs.com/DreamlessDreams/p/10241267.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[3]$:$Cyhlnj$的$blog$ <a href="https://www.cnblogs.com/cjoieryl/p/10114614.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[4]$:$litble$的$blog$ <a href="https://blog.csdn.net/litble/article/details/84864516" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[5]$:$CMXRYNP$的$blog$ <a href="https://cmxrynp.github.io/2019/01/07/fft-optimization/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】从单位根到FFT</title>
    <url>/2019/02/19/FFT1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$ \rm{0x01\quad Preface} $"></a>$ \rm{0x01\quad Preface} $</h1><p>这篇文章初写于 $ 7/1/2018 $ ，是在陪同好友 $ yjk $ 与 $ wx $ 以及学长 $ rqy $ 一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍 $ FFT $ 并且写 $ MTT $ ，于是便有了这篇文章。</p>
<p>其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的<code>orchidany</code>特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。</p>
<p>但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。</p>
<h1 id="rm-0x02-quad-Convolution"><a href="#rm-0x02-quad-Convolution" class="headerlink" title="$ \rm{0x02\quad Convolution} $"></a>$ \rm{0x02\quad Convolution} $</h1><p><strong>卷积 $ \boldsymbol{(Convolution)} $ </strong>，准确来说是一种<strong>通过两个函数 $ \boldsymbol f $  和 $ \boldsymbol g $  生成第三个函数的一种数学算子.</strong></p>
<p>而广义上其定义为： <script type="math/tex">\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}</script> </p>
<p>我们称 $ h(x) $ 是 $ g(x) $ 与 $ f(x) $ 的<strong>卷积</strong>。</p>
<p>而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到</p>
<script type="math/tex; mode=display">A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}}</script><p>其中 $ A(x) $ 和 $ B(x) $ 均为 $ N-1 $ 次多项式<br>比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有 $ 2n+1 $ 项。</p>
<h1 id="rm-0x03-quad-Dot-Method"><a href="#rm-0x03-quad-Dot-Method" class="headerlink" title="$ \rm{0x03\quad Dot~Method} $"></a>$ \rm{0x03\quad Dot~Method} $</h1><p>我们知道，原本的多项式是系数表示法，现在我们将其转化为<strong>点值表示法 $ (\boldsymbol{dot~method} ) $ </strong>。即我们可以把多项式 $ F(x) $ 转化为多项式函数 $ f(x) $ ，那么这个 $ n $ 阶函数就可以由 $ n+1 $ 个点唯一确定。即 <script type="math/tex">f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)....(x_n,y_n)}</script> 那么 <script type="math/tex">\forall k,y_k = f(x_k)</script> 这是很显然的，并且这 $ n+ $ 个点是随意选取的——只要求它们相异即可。</p>
<ul>
<li><h2 id="rm-Advanced-Trick-Point-color-red-1-rm-Multiplication"><a href="#rm-Advanced-Trick-Point-color-red-1-rm-Multiplication" class="headerlink" title="$ \rm{Advanced~Trick~Point} $   $ \color{red}{1} $   $ \rm{Multiplication} $"></a>$ \rm{Advanced~Trick~Point} $   $ \color{red}{1} $   $ \rm{Multiplication} $</h2></li>
</ul>
<p>假设我们有两个关于 $ x $ 的 $ n+1 $ 次多项式 $ A(x) $ 和 $ B(x) $ ，我们要对它的点值表达式进行乘法操作。由于结果有 $ 2n+1 $ 项，我们考虑补上一堆项，并对 <script type="math/tex">A(x) = {(x_0,y_0),(x_1,y_1)....(x_{2n},y_{2n})}</script>   <script type="math/tex">B(x) = {(x_0,y_0'),(x_1,y_1')....(x_{2n},y_{2n})}</script>  做乘法可得  <script type="math/tex">A(x)B(x) = {(x_0,y_0y_0'),(x_1,y_1y_1')(x_{2n},y_{2n}y_{2n}')}</script>   </p>
<p>我们观察点乘法，它的时间复杂度达到了 $ \Theta(n) $ ，完全可以接受。那么不妨先看一下算法的大体思路：</p>
<blockquote>
<p>对于每个因子多项式，选取 $ n+1 $ 个点，得出点值表达式（复杂度 $ \Theta(n^2) $ ）  $ \longrightarrow $ 点乘法(时间复杂度 $ \Theta(n) $ )——&gt;将得出来的 $ C(x) $ 的点值表达式再转换成系数表达式(复杂度 $ \Theta(n^2) $ )</p>
</blockquote>
<p>这就是 $ FFT $ 的大体流程。<del>转化之后怎么没多快常数还大了</del></p>
<p>虽然其余部分的时间复杂度还是很麻烦的 $ O(n^2) $ ，但是都是可以优化成 $ O(nlogn) $ 的。</p>
<hr>
<p>本质上的 $ FFT $ 包含<strong> $ \boldsymbol{DFT} $ （离散傅立叶变换）</strong>和<strong> $ \boldsymbol{IDFT} $ （逆离散傅立叶变换）</strong>实际上，<strong> $ DFT $ </strong>对应着的就是<strong>把系数表达式映射到点值表达式</strong>的过程，<strong> $ IDFT $ </strong>对应着的就是我们<strong>把点值表达式映射到系数表达式</strong>的过程。</p>
<h1 id="rm-0x04-Base-of-Optimization"><a href="#rm-0x04-Base-of-Optimization" class="headerlink" title="$ \rm{0x04~Base ~of~Optimization} $"></a>$ \rm{0x04~Base ~of~Optimization} $</h1><p>因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到 $ nlogn $ 的，那么总的时间复杂度，渐进意义下就是 $ O(nlogn) $ 的。</p>
<p>下面就让我们来看看如何优化：</p>
<ul>
<li><h2 id="rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root"><a href="#rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root" class="headerlink" title="$ \rm{Advanced~Trick~Point} $   $ \color{red}{2} $   $ \rm{Unit ~Complex ~Root} $"></a>$ \rm{Advanced~Trick~Point} $   $ \color{red}{2} $   $ \rm{Unit ~Complex ~Root} $</h2><p>$ n $ 次单位复根是满足 $ \omega^n = 1 $  的复数 $ \omega $ ，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出<strong> $ n $ 次单位根有 $ n $ 个</strong>这个结论——亦或者是用代数基本定理证，都可以。而又因为复数 $ \omega^n $ 在复数平面上的模都是一，所以相乘之后还会是一，那么所有的 $ \omega_i,1 \leq i \leq n $ 就会均匀分布在单位圆上，类似当 $ n = 8 $ 时它是这样的：</p>
</li>
</ul>
<p><img src="1.png" alt></p>
<p>我们考虑欧拉公式：</p>
<script type="math/tex; mode=display">e^{ix} = cosx + isinx</script><p>我们取 $ x =2\pi $ ，可以得到如下关系式： <script type="math/tex">e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}</script> </p>
<p>们把此时的单位根称之为<strong>主次单位根</strong>，记作 <script type="math/tex">\omega_n = e^{\frac{2\pi i}{n}}</script> </p>
<p>那么对于其他的单位根，记作 <script type="math/tex">\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k < n</script> 都是主次单位根的整次幂，也就是上图中的一圈。</p>
<hr>
<p>诶，这个有啥用啊 $ QAQ $ ?</p>
<p>那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到 $ nlogn $ 的复杂度……</p>
<p>那么我们先来看其支持其规模减半的引理：</p>
<ul>
<li><h3 id="frak-Elimination-Lemma-quad-消去引理"><a href="#frak-Elimination-Lemma-quad-消去引理" class="headerlink" title="$ \frak{Elimination ~Lemma\quad} $ 消去引理"></a>$ \frak{Elimination ~Lemma\quad} $ 消去引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对任何整数 $ n \geq 0,k \geq 0,d &gt;0 $ ,有 <script type="math/tex">\omega_{dn}^{dk} = \omega_n^k</script> </strong></p>
</blockquote>
<p> $ \mathcal{Proof.} $ </p>
<p>这个好像很好证的样子……代入定义可以获得 <script type="math/tex">\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k</script><br> $ \mathcal{Q.E.D.} $ </p>
<hr>
<ul>
<li><h3 id="frak-Binary-Lemma-quad-折半引理"><a href="#frak-Binary-Lemma-quad-折半引理" class="headerlink" title="$ \frak{Binary~Lemma\quad} $  折半引理"></a>$ \frak{Binary~Lemma\quad} $  折半引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对于任何大于 $ 0 $ 的偶数 $ n $ ，都有 $ n $ 个 $ n $ 次单位复根的平方的集合，等于 $ \frac{n}{2} $ 个 $ \frac{n}{2} $ 次单位复根的集合。</strong></p>
</blockquote>
<p> $ \mathcal{Proof.} $ </p>
<p>我们可以由消去引理得到 <script type="math/tex">(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k</script> 那么</p>
<script type="math/tex; mode=display">(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2</script><p> $ \mathcal{Q.E.D.} $ </p>
<hr>
<p>那么接下来，如果对所有的 $ n $ 次单位跟平方一下，我们会发现 $ \frac{n}{2} $ 次单位根每个都恰好出现了两次——也就是说，在 $ n $ 个 $ n $ 此单位复数根的集合（朴素的集合，即不可重集）里，只有 $ \frac{n}{2} $ 个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。</p>
<p>那么把所有 $ n $ 单位根的平方画到一个数列上就是这样。</p>
<p><img src="2.png" alt></p>
<p>这个引理直接保证了我们求值的复杂度为 $ \Theta(n \log n) $ </p>
<p>而我们在代码实现中，<strong>不能直接得到 $ e $ 或者虚数 $ i $ </strong>，所以这个时候求单位根的任务就交给了我们上文中提到过的<strong>欧拉公式</strong>。</p>
<ul>
<li><h3 id="frak-Sum-Lemma-quad-求和引理"><a href="#frak-Sum-Lemma-quad-求和引理" class="headerlink" title="$ \frak{Sum~Lemma\quad} $ 求和引理"></a>$ \frak{Sum~Lemma\quad} $ 求和引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对于任意 $ n&gt;0 $ 且 $ k $ 不能整除 $ n $ ，我们都有 <script type="math/tex">\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0</script> </strong></p>
</blockquote>
<p> $ Proof. $ </p>
<p>由几何级数的求和公式（等比数列求和公式) <script type="math/tex">\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}</script> 可得 <script type="math/tex">\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow  \frac{(\omega_n^n)^k -1}{\omega_n^k -1} =  \frac{(1)^k -1}{\omega_n^k -1}</script> 由于保证了 $ k $ 不可整除 $ n $ 所以分母一定不为 $ 0. $ </p>
<p> $ \mathcal{Q.E.D} $ </p>
<hr>
<h1 id="rm-0x05-quad-DFT-to-FFT"><a href="#rm-0x05-quad-DFT-to-FFT" class="headerlink" title="$ \rm{0x05\quad DFT \to FFT} $"></a>$ \rm{0x05\quad DFT \to FFT} $</h1><p>那么我们在了解完单位复数根之后，便可以正式地对 $ DFT $ 给出定义与操作方案了。</p>
<ul>
<li><h2 id="DFT"><a href="#DFT" class="headerlink" title="$ DFT $"></a>$ DFT $</h2></li>
</ul>
<p>对于我们已知的一个多项式 <script type="math/tex">A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}</script> 在 $ \omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1} $ 处的取值，我们可以假定 $ n $ 是 $ 2 $ 的幂，因为即使它本身不是 $ 2 $ 的幂，我们也可以通过向高次幂补值为 $ 0 $ 的项来解决这个问题。而补足 $ 2 $ 的幂的目的，就是为了在 $ FFT $ 分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。</p>
<p>那我们现在会有一个 $ A $ 的向量组 $ \vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}} $ ，对于 $ k = 0, 1, 2, \cdots n -1 $ ，定义 $ y_k $ 如下： <script type="math/tex">y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}</script> ，那么向量 <script type="math/tex">\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}</script> 就称作系数向量 $ \vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}} $ 的<strong>离散型傅立叶变换（ $ \boldsymbol{Discrete   Fourier   Transformation} $ ）</strong>。</p>
<p>嗯，这个<strong>离散型</strong>我们可以由点乘法联想意会一下：本来 $ A(x) $ 是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容 $ qwq $ ），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。</p>
<ul>
<li><h2 id="FFT-优化-DFT"><a href="#FFT-优化-DFT" class="headerlink" title="$ FFT $ 优化 $ DFT $"></a>$ FFT $ 优化 $ DFT $</h2></li>
</ul>
<p>在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为 $ O(n^2) $ ，这是朴素算法。而我们只需要用一种被称作<strong>快速傅立叶变换（ $ \boldsymbol{Fast   Fourier   Transformation} $ ）</strong>的方式，就可以将其时间复杂度压缩成 $ O(nlogn) $ 。而在这里我们就用到了刚才证明的引理——<strong>折半引理</strong>。</p>
<p>我们考虑将原来的多项式 <script type="math/tex">A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}</script> 重定义成两个次数为 $ \frac{n}{2} $ 的小多项式 $ A^{[0]}(x) $ 和 $ A^{[1]}(x) $ ： </p>
<script type="math/tex; mode=display">A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1} $$   $$  A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1} $$     那么也就是说， $ A^{[0]}(x) $ 存储的是所有偶数位（二进制位最后一位是 $ 0 $ ），而 $ A^{[1]}(x) $ 存储的是所有的奇数位（二进制位最后一位是 $ 1 $ ），那么有下式： $$ A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2) $$ 那我们求 $ A(x) $ 在单位根们 $ \omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1} $ 处的值，就变成了先求出 $ A^{[0]}(x^2) $ 和 $ A^{[1]}(x^2) $ 的值，然后根据上式进行合并即可。

而显然的是，根据折半引理，我们根本不需要 $ O(n) $ 求，而是通过数据规模不断减小使之成为 $ O(\log n) $ 。于是，我们成功通过 $ FFT $ 优化了求值的复杂度。

那么同时对于另一边，我们可以根据

 $$ A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})</script><p>得到</p>
<script type="math/tex; mode=display">A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})</script><p>从而有伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Lim = <span class="number">1</span>, N, M ;</span><br><span class="line"><span class="function">function <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> lenth, <span class="keyword">complex</span> *A, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    IF (Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[lenth &gt;&gt; <span class="number">1</span>], A1[lenth &gt;&gt; <span class="number">1</span>] ;<span class="comment">//分成两部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to lenth by_grow <span class="number">2</span>) A0[j &gt;&gt; <span class="number">1</span>] = A[j], A1[j &gt;&gt; <span class="number">1</span>] = A[j + <span class="number">1</span>] ;</span><br><span class="line">    FFT(lenth &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(lenth &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> Wn = unit(,) , w = (<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂</span></span><br><span class="line">        <span class="comment">/*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to (lenth &gt;&gt; <span class="number">1</span>) by_grow <span class="number">1</span> with w = w * Wn)&#123;</span><br><span class="line">        A[i] = A0[i] + A1[i] * w ;<span class="comment">//应用公式，下同 </span></span><br><span class="line">        A[i + (lenth &gt;&gt; <span class="number">1</span>)] = A0[i] - A1[i] * w ; <span class="comment">//顺便求出另一半，由折半引理可显然。 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">function Main&#123;</span><br><span class="line">    input(N), input(M) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to N by_grow <span class="number">1</span>) =&gt; input(A) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to M by_grow <span class="number">1</span>) =&gt; input(B) ; </span><br><span class="line">    <span class="keyword">while</span>(Lim &lt; N + M) Lim &lt;&lt;= <span class="number">1</span> ;<span class="comment">//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分）</span></span><br><span class="line">    FFT(Lim, A, <span class="number">1</span>) ;<span class="comment">//两遍FFT表示从系数化为点值 </span></span><br><span class="line">    FFT(Lim, B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to Lim by_grow <span class="number">2</span>) =&gt; A[i] *= B[i] ;<span class="comment">//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是基于 $ pks $ 标准下的伪代码<del>你可以试试在c++标准下运行</del>，其中 $ for $ 循环部分， $ grow $ 表示当前循环变量的<strong>单次增量</strong>，之后带有 $ with $ 表示每次循环结束都会进行的运算（下同</p>
<p>嗯，这就是求值的方法，好像很 $ nice $ 地达到了 $ O(n \log n) $ </p>
<ul>
<li><h2 id="FFT-优化-IDFT"><a href="#FFT-优化-IDFT" class="headerlink" title="$ FFT $ 优化 $ IDFT $"></a>$ FFT $ 优化 $ IDFT $</h2></li>
</ul>
<p>上文中我们曾经提及过的<strong>范德蒙德矩阵</strong>可以放到这儿用：</p>
<p> $ \begin{vmatrix}  1         &amp;  1  &amp; 1   &amp; \cdots &amp; 1      \newline 1         &amp;  \omega_n  &amp; \omega_n^2   &amp; \cdots &amp; w_n^{n-1}      \\newline1         &amp;  \omega_n^2  &amp; \omega_n^4   &amp; \cdots &amp; \omega_n^{2(n-1)}      \newline \vdots  &amp; \vdots &amp; \vdots  &amp;  \ddots &amp; \vdots \newline 1    &amp;  \omega_n^{n-1}  &amp; \omega_n^{2(n-1)}   &amp; \cdots &amp; \omega_n^{(n-1)(n-1)}        \newline  \end{vmatrix} $    $ \begin{vmatrix}  a_0  \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix} $  =  $ \begin{vmatrix}  y_0  \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix} $ </p>
<p>那为了求出我们的 $ \vec{a} = {a_0, a_1 \cdots ,a_{n-1}} $ 我们应该让刚刚求值算出的 $ \vec{y} $ 乘上我们 $ \vec{V}^{~-1} $ （ $ \vec{V} $ 的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下：</p>
<hr>
<blockquote>
<p><strong>推论</strong>：对于 $ j,k = 0,1, 2 \cdots n-1,V_n^{-1} $ 的 $ (j, k) $ 处的值为 $ \omega_n^{-kj}/n $ </p>
</blockquote>
<p> $ Proof. $ </p>
<p>我们考虑反向证明，已知 $ V_n’ $ 是一个 $ (j,k) $ 处值为 $ \omega_n^{-kj}/n $ 的、与 $ V $ 形态相同的矩阵，那我们只需要证明 $ V’ \cdot V = I_n $ 即可，其中 $ I_n $ 是 $ n $ 阶单位矩阵，即主对角线都是 $ 1 $ ，其余位置上是 $ 0 $ 的矩阵。</p>
<p>那么我们考察 $ V’ V $ 中的元素 $ (i, j) $ ，有如下的式子 <script type="math/tex">V'V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}</script> </p>
<p>由<strong>求和引理</strong>当且仅当 $ i=j $ 时其值为一，其余的时刻均为零，所以有 $ V’V = I_n $ </p>
<p> $ \mathcal{Q.E.D} $ </p>
<hr>
<p>那么我们把我们刚刚求出来的逆矩阵 $ V^{-1} $ 美化一下，提出每一项所除的 $ n $ ，可以得到 $ IDFT $ 可以如此计算： <script type="math/tex">IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]</script> 诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当 $ flag=1 $ 时，他是正向 $ DFT $ ；当它等于 $ -1 $ 时，它是逆向的 $  IDFT $ 。这可以让我们通过这一个函数解决两个过程。我们只需要用 $ y $ 替换 $ a $ ，用 $ \omega_n^{-1} $ 替换 $ \omega_n $ ，其余的没什么差别，于是……时间复杂度还是 $ O(n \log n) $ 的!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> Lim,<span class="keyword">complex</span> *A,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[Lim &gt;&gt; <span class="number">1</span>], A1[Lim &gt;&gt; <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Lim ; i += <span class="number">2</span>)</span><br><span class="line">        A0[i &gt;&gt; <span class="number">1</span>] = A[i], A1[i &gt;&gt; <span class="number">1</span>] = A[i+<span class="number">1</span>] ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> unit = (<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span> * Pi / Lim) , flag * <span class="built_in">sin</span>(<span class="number">2.0</span> * Pi / Lim)&#125;, w = <span class="keyword">complex</span>(<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//欧拉公式 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        A[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        A[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......................</span><br><span class="line">FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在嘛……可以考虑撒花花啦！因为我们的 $ FFT $ 实际上已经结束了！ $ But $ ，这个递归版本的 $ FFT $ 由于牵扯到 $ sin/cos $ 的运算、 $ double $ 、递归时的入栈出栈（底层），所以常数特别的大 $ emmmmm $ ，那么——</p>
<h1 id="rm-0x06-Iterative-Optimization"><a href="#rm-0x06-Iterative-Optimization" class="headerlink" title="$ \rm{0x06~Iterative~ Optimization} $"></a>$ \rm{0x06~Iterative~ Optimization} $</h1><p>我们现在要引出的就是迭代版的 $ FFTqwq $ </p>
<h2 id="·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation"><a href="#·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation" class="headerlink" title="·  $ \rm{Advanced~Trick~Point} $   $ \color{red}{3} $   $ \rm{The~Butterfly ~Operation} $"></a>·  $ \rm{Advanced~Trick~Point} $   $ \color{red}{3} $   $ \rm{The~Butterfly ~Operation} $</h2><p> $ emmm $ 先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        a[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们会发现…… $ \omega \cdot A^{[1]}[i] $ 被执行了两次，所以我们不妨用个变量记录它：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">     <span class="keyword">int</span> temp = w * A1[i] ;</span><br><span class="line">     a[i] = A0[i] + t ;</span><br><span class="line">     a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - t ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><del>嗯，这就是全部的优化啦！那么，FFT，完！</del></p>
<p> $ qwq $ 这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好 $ \mathcal{QAQ} $ 。好吧，说这个的原因，只是为了引出我们关于<strong>蝴蝶操作</strong>的定义：</p>
<blockquote>
<p>我们定义 $ \omega_n^k $ 为<strong>旋转因子</strong>，那么每一次我们先将 $ y_k^{[1]} $ 与旋转因子的乘积存储在一个变量 $ t $ 里，并在 $ y_k^{[0]} $ 增加、减去 $ t $ 的操作称为一次蝴蝶操作。</p>
</blockquote>
<p>说白了，蝴蝶操作是一次 $ O(2) $ 的求出 $ A^{[0]}_k $ 与 $ A^{[1]}_k $ 的操作。</p>
<hr>
<p>我们首先考虑按照递归的思路，将 $ FFT $ 的分治流程刻画一下：</p>
<p><img src="3.png" alt></p>
<p>我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下：</p>
<blockquote>
<p>$ step   1 $   成对地取出儿子节点，用蝴蝶操作计算出其 $ DFT $ 。<br>$ step   2 $   用这一步的 $ DFT $ 替换之前的；<br>$ step   3 $   直到我们迭代到根节点为止，否则返回 $ step   1 $ </p>
</blockquote>
<p>而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层 $ for $ ，先枚举区间长度（1，2，4，8……），第二层枚举长度为 $ j*2 $ 的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间 $ DFT $ 的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举区间长度，从小区间到大区间依次合并。</span></span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;<span class="comment">//两段区间两段区间的枚举，用于合并</span></span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;<span class="comment">//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。</span></span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;<span class="comment">//一次蝴蝶操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在 $ DFT $ 的时候，为了保证时间复杂度是 $ \Theta(\log n) $ ，我们曾经进行过一次 $ A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2) $ 的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是 $ 0,1,2,3,4,5,6,7 $ ，但是迭代版的 $ FFT $ 却需要的顺序应该跟叶子结点的顺序吻合，即 $ 0, 4, 2, 6, 1, 5,3,7 $ 。所以——</p>
<ul>
<li><h2 id="·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law"><a href="#·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law" class="headerlink" title="·  $ \rm{Trick~Point} $   $ \color{red}{4} $   $ \rm{The~Butterfly ~Law} $"></a>·  $ \rm{Trick~Point} $   $ \color{red}{4} $   $ \rm{The~Butterfly ~Law} $</h2></li>
</ul>
<p>这个嘛……我们可以选择打个表观察：<br>原来的序号  $ 0        1        2        3        4        5        6         7 $<br>现在的序号  $ 0        4        2        6        1        5        3        7 $<br>原来的二进制表示  $ 000        001        010        011        100        101        110        111 $<br>现在的二进制表示  $ 000        100        010        110        100        101        011        111 $ </p>
<p>诶，二进制好像是反序的嗷~~这便是我们的最后一个 $ trick $ ，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在 $ FFT $ 之前 $ swap $ 一遍即可。</p>
<p>嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure></p>
<p>呃，这个二进制计算自己推一下就好。</p>
<p>那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。<del>真开森啊</del></p>
<p>最后附迭代版的代码(我写的常数好像有点儿大 $ QAQ $ )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN] ;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;<span class="comment">//前面的if保证只换一次</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(), M = qr() ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i].x = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i].x = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">    FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(A[i].x / Lim + <span class="number">0.5</span>)) ;<span class="comment">//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啊……那就撒花花吧！！</p>
<h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$ \rm{0x00\quad Afterword} $"></a>$ \rm{0x00\quad Afterword} $</h1><p>以下是原尾语，保留了下来：</p>
<blockquote>
<p>嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短<del>这么容易背过</del>。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天 $ qwq $ ，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他 $ DALAO $ 比对审核、或者缠着 $ rqy $ 问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。</p>
<p>以下是温馨提示：</p>
<ul>
<li>好多自己当初不理解的地方在代码里就只有半行qaq</li>
<li>三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的</li>
</ul>
</blockquote>
<p>真 · 结束语：</p>
<p>其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去<code>现在看这个算法，真是简单的一匹啊</code>，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $ rvalue $ 的 $ blog $  <a href="https://www.cnblogs.com/rvalue/p/7351400.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :算法导论 <a href="https://pan.baidu.com/s/13PRy8pPn__zGj3UfOTX8Ew" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a> 提取码: txs2 </li>
<li>[3]*：鸣谢rqy</li>
</ul>
<h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$ \mathfrak{writter:pks} $"></a>$ \mathfrak{writter:pks} $</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>随想五 · 手中没有红玫瑰</title>
    <url>/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>今天下了一天的雪。</p>
<p>我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。</p>
<p>“情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。</p>
<p>雪真美啊。</p>
<hr>
<p>早恋？</p>
<p>“严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”……</p>
<p>说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。</p>
<p>直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了：</p>
<blockquote>
<p>小学五年级的时候，我喜欢班上的一个女孩子。<br>那时候想的很多。<br>比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。<br>那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。<br>这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。<br>我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。</p>
<p>如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。</p>
<p>我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。<br>他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。</p>
<p>于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。<br>家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。</p>
<p>后来初三开学，我收到了一封信。<br>来自那个小学时候喜欢的女孩子。<br>信的末尾有一句话：我准备报考X中，你要不要一起？</p>
<p>我的手不受控制地颤抖。<br>烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。</p>
<p>为什么要读书呢？<br>16岁的我获得了唯一的答案——为了和喜欢的人在一起。<br>我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。<br>对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。<br>是啦，他们总以为自己很懂。</p>
<p>很多人说，小孩子不要谈感情，因为反正不会有结果。<br>是，的确不会有结果。<br>就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。</p>
<p>可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。<br>爱过一个人，是我少年时最大的幸运。</p>
<p>所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。<br>是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。</p>
<p>有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。<br>结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。</p>
<p>我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。</p>
<p>他们轻蔑地说，小孩子懂什么恋爱。<br>好，那我们来看看大人们有多么懂爱情。<br>相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。<br>夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。<br>夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。</p>
<p>所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。<br>难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？</p>
<p>还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”<br>仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。</p>
<p>可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？<br>你们是真的有的是以后，还是早已离散在人海？<br>而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？</p>
<p>很久以后我们终于知道，大人都在说谎。<br>少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。</p>
<p>如果有还在上学的读者看到这里，请记住，人生没有那么多以后。<br>有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。</p>
<p>至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。</p>
<p>我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。</p>
<p>” 很多人即使只见过一面，已经算见过了最后一面。“</p>
<p>十八岁前不早恋，这辈子都来不及早恋。<br>你的人生看起来很长，每一秒都无法挽回。</p>
</blockquote>
<p>虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。</p>
<p>我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。</p>
<p>当然，也是给我自己讲。</p>
<p>关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。</p>
<p>现在不一样了吧，一生，多长啊。</p>
<p>我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。</p>
<p>没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。</p>
<p>等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？</p>
<p>不，我觉得不是。</p>
<p>我是在亵渎一种感情，是在侮辱一个人。</p>
<p>爱从来都是无私地付出，而不是拼命的占有啊。</p>
<p>我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。</p>
<p>你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊，</p>
<p>都不过是拼命地想被爱而已。</p>
<hr>
<p>不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊……</p>
<p>孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。</p>
<p>我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。</p>
<p>下面是歌词：</p>
<blockquote>
<p>我喜欢暖冬的太阳<br>我喜欢初春的青草<br>我喜欢午后的庭院和一旁发呆的秋千<br>我喜欢仲夏的冰沙<br>我喜欢清秋的明月<br>良宵的夜空 漫天星辰<br>我喜欢雨后的青蛙<br>我喜欢山前的杏<br>我喜欢周三的傍晚被霞光亲吻的水族馆<br>我喜欢成群的野<br>我喜欢凌乱的书架<br>清风的露台远处的灯海<br>我喜欢 走在无人的九十六号公路<br>我喜欢 木村拓哉长长的头发<br>我喜欢 无尽田野上奔跑的麋鹿<br>我喜欢 外婆门前的榕树<br>我喜欢母亲的便当<br>喜欢父亲的胡渣<br>我喜欢八月的夜晚还在营业的游乐场<br>我喜欢放学的铃铛<br>我喜欢停电的夜晚<br>点一对蜡烛 在幽静的玄关<br>我喜欢 城市尽头那远远的青山<br>我喜欢 热气球飞上西边的天空<br>我喜欢 清晨的石板路<br>雾腾腾的早餐店 阿公的桂花糕<br>我喜欢 每一朵暮云 每一株绿树<br>我喜欢你，你应该，也知道<br>我喜欢你，你应该，也知道</p>
</blockquote>
<p>优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句——</p>
<blockquote>
<p>我喜欢你，你应该，也知道.</p>
<p>我喜欢你，你应该，也知道。</p>
</blockquote>
<p>很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。</p>
<p>你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。</p>
<p>有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。</p>
<p>我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。</p>
<p>我喜欢你，你应该，也知道。</p>

        <div id="aplayer-NZZrNGul" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-NZZrNGul"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "我喜欢",
              author: "彩虹合唱团",
              url: "我喜欢.flac",
              pic: "/2019/02/14/随想五·情人节/wxh.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<hr>
<p>心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？</p>
<p>如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。</p>
<p>我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。</p>
<p>相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。</p>
<p>$19/2/14$ </p>
<hr>
<p>本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。</p>
<p>那么就补一个深沉一点的结尾吧。</p>
<p>我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。</p>
<p>但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧……</p>
<p>路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。</p>
<p>可是面对着无奈的明天的我，什么都不能做。</p>
<hr>
<p>雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。</p>

        <div id="aplayer-GKjKaaah" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-GKjKaaah"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "遇见",
              author: "孙燕姿",
              url: "遇见.flac",
              pic: "/2019/02/14/随想五·情人节/yj.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想三 · NOIP2018游记</title>
    <url>/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我不想退役。</p>
<a id="more"></a>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>他看着眼前的屏幕，静静地发呆。</p>
<p>他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。</p>
<p>刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。</p>
<p>“希望别考期望吧，嘿嘿……”他心里这么想着。</p>
<p>晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。</p>
<p>他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。</p>
<p>从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。</p>
<hr>
<p>早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$\rm Mac$版，连硕鼠也不能用了，便只得作罢。</p>
<p>终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。</p>
<p>“大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。</p>
<p>看了看天空，他上了大巴车。</p>
<hr>
<p>”昌邑一中真大啊“这是他到这儿后的第一想法。</p>
<p>到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。</p>
<p>宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。</p>
<p>他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。</p>
<hr>
<h2 id="rm-Day-1"><a href="#rm-Day-1" class="headerlink" title="$\rm{Day~1}$"></a>$\rm{Day~1}$</h2><p>突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。</p>
<p>考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。</p>
<p>入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。</p>
<p>$T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。</p>
<p>$T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。</p>
<p>$T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。</p>
<p>期望得分$100pts + random(0,100)+random(10,20) $</p>
<p>$Luogu$数据$100pts + 65pts + 15pts = 180pts$</p>
<p>听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。</p>
<p>下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。</p>
<p>考挂了，他想到。</p>
<p>这世界上似乎就他一个不会$\rm T2$的人。</p>
<p>他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。</p>
<p>虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。</p>
<p>或许他期望着明天能翻盘？</p>
<p>晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。</p>
<hr>
<h2 id="rm-Day-2"><a href="#rm-Day-2" class="headerlink" title="$\rm{Day~2}$"></a>$\rm{Day~2}$</h2><p>今天他没有带什么吃的。</p>
<p>$T1$只会$60$分，转眼去看$T2$</p>
<p>写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。</p>
<p>$T3$连想的时间都没有。</p>
<p>退役了。</p>
<hr>
<p>他很伤心。</p>
<p>回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。</p>
<p>他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。</p>
<p>他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。</p>
<p>其余的都考炸了。</p>
<p>初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。</p>
<p>他一开始也并不怎样，没啥感觉。</p>
<p>直到那天下午。</p>
<hr>
<p>他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。</p>
<p>兴奋的他去奥赛室看成绩。</p>
<p>学长看错了。</p>
<p>他的两个同僚都是$370/380+$的样子。</p>
<p>只有他不到.</p>
<p>其他人的分数也比他高。</p>
<p>他大概全校第十几吧。</p>
<p>他感到了绝望。</p>
<p>本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。</p>
<p>他注定是失败者。</p>
<p>他伤心极了。</p>
<hr>
<p>他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。</p>
<p>他觉得一年来，他一事无成。</p>
<p>或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。</p>
<p>他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。</p>
<p>他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。</p>
<p>期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。</p>
<p>这似乎是实验部该有的成绩。可是跟他没有关系。</p>
<p>特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。</p>
<p>太失败了。</p>
<p>太失败了。</p>
<hr>
<p>大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。</p>
<p>我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。</p>
<p>这真是从未有过的轻松的感觉。</p>
<p>或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。</p>
<p>我感到无比的轻松。</p>
<p>以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。</p>
<p>我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。</p>
<p>嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。</p>
<p>但是其实山东没有开展$AO$的，不过我想当这个第一人。</p>
<p>我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。</p>
<p>到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。</p>
<hr>
<p>在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。</p>
<p>没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。</p>
<p>我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好+强大的理解能力=rqy这个等式也是成立的。</p>
<p>当然，不属于我啦。</p>
<p>虽然现在很不甘……但是没有办法，大概这就是人生吧。</p>
<p>如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。</p>
<p>听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。</p>
<p>总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么：</p>
<h2 id="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"><a href="#做什么事情，都要先从自己的灵魂出发，而不是从利益出发。" class="headerlink" title="做什么事情，都要先从自己的灵魂出发，而不是从利益出发。"></a>做什么事情，都要先从自己的灵魂出发，而不是从利益出发。</h2><p>之类的吧。</p>
<p>我想引用一句（段）话，来自《本杰明巴顿奇事》：</p>
<blockquote>
<p>有些人，注定可以于河边闲坐。<br>有些人被闪电击中过七次。<br>有些人对音乐有着非凡的天赋。<br>有些人是艺术家。<br>有些人是游泳健将。<br>有些人懂得制作纽扣。<br>有些人懂莎士比亚。<br>有些人是妈妈。<br>还有些人，是舞者。<br>我们注定要失去我们所爱的人，<br>要不然我们怎么知道他们对我们有多么的重要。</p>
</blockquote>
<p>后会有期。</p>
<h1 id="mathscr-THE-quad-END…"><a href="#mathscr-THE-quad-END…" class="headerlink" title="$\mathscr{THE\quad END….?}$"></a>$\mathscr{THE\quad END….?}$</h1>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF#536Div2の题解(E&amp;F)</title>
    <url>/2019/02/08/CF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>春节前的一场$CF$～名字很$nice$的说～</p>
<p>⑧说别的啦，新年好那个新年好qwq!</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89--%2F%E7%9C%81%E9%80%89-blueviolet.svg" alt></p>
<h2 id="0x01-Preface"><a href="#0x01-Preface" class="headerlink" title="$0x01~~Preface$"></a>$0x01~~Preface$</h2><p>$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕</p>
<p>这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233</p>
<p>简单总结一下前面四道题<a href="http://codeforces.com/contest/1106" target="_blank" rel="noopener">$\color{red}{Link}$</a>：</p>
<ul>
<li><p>A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次<del>身败名裂XD</del></p>
</li>
<li><p>B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树）</p>
</li>
<li>C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。</li>
<li>D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞</li>
</ul>
<p>下面两道题就好像不是那么水了qaq</p>
<h2 id="0x02-E-cdot-text-Lunar-New-Year-and-Red-Envelopes"><a href="#0x02-E-cdot-text-Lunar-New-Year-and-Red-Envelopes" class="headerlink" title="$0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$"></a>$0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$</h2><h3 id="color-red-Link"><a href="#color-red-Link" class="headerlink" title="$\color{red}{Link}$"></a><a href="http://codeforces.com/contest/1106/problem/E" target="_blank" rel="noopener">$\color{red}{Link}$</a></h3><p>简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。</p>
<p>最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。</p>
<h3 id="mathfrak-Solution"><a href="#mathfrak-Solution" class="headerlink" title="$\mathfrak {Solution}$"></a>$\mathfrak {Solution}$</h3><p>呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。</p>
<p>之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。</p>
<p>Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark, d, w ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> time_node &amp;T) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; base[MAXN] ; </span><br><span class="line"><span class="built_in">map</span> &lt;time_node, <span class="keyword">int</span>&gt; M_set ; </span><br><span class="line"><span class="built_in">vector</span>&lt;time_node&gt;Time[MAXN] ; <span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, A, B, C, D, i, j ; <span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN][MAXM] ;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;A, &amp;B, &amp;C, &amp;D), </span><br><span class="line">        Time[A].push_back((time_node)&#123;<span class="number">1</span>, C, D&#125;) ;</span><br><span class="line">        Time[B + <span class="number">1</span>].push_back((time_node)&#123;<span class="number">2</span>, C, D&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> tot = Time[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; tot ; ++ j) </span><br><span class="line">            <span class="keyword">if</span> (Time[i][j].mark == <span class="number">1</span>) ++ M_set[Time[i][j]] ; </span><br><span class="line">            <span class="keyword">else</span> M_set[Time[i][j]] &gt; <span class="number">1</span> ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ;</span><br><span class="line">        <span class="keyword">if</span> (M_set.size()) base[i] = (*M_set.begin()).first ; <span class="keyword">else</span> base[i] = (time_node)&#123;<span class="number">0</span>, i, <span class="number">0</span>&#125; ;</span><br><span class="line">    &#125;dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, Ans = dp[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">            j &gt; <span class="number">0</span> ? dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j]) : <span class="number">1</span> ;</span><br><span class="line">            dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - <span class="number">1</span>][j] + base[i].w) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-F-cdot-text-Lunar-New-Year-and-a-Recursive-Sequence"><a href="#0x03-F-cdot-text-Lunar-New-Year-and-a-Recursive-Sequence" class="headerlink" title="$0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$"></a>$0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$</h2><p><a href="http://codeforces.com/contest/1106/problem/E" target="_blank" rel="noopener">$Link$</a></p>
<p>简单来说就是给你一个序列$F_x$的$k$项的递推法则（幂次积式递推），在认定前$k-1$项都满足$F_x=1$的基础上给定$F_n$，让你倒推出$F_k$来。</p>
<h3 id="mathfrak-Solution-1"><a href="#mathfrak-Solution-1" class="headerlink" title="$\mathfrak {Solution}$"></a>$\mathfrak {Solution}$</h3><p>恕我直言…这道题我考场上是不可能会的…（已扑街</p>
<p>首先我们观察一般形式：</p>
<script type="math/tex; mode=display">
F_x = \begin{cases}1 \ , &\rm{x<k} \newline ? \ , & \rm{x = k} \newline \prod\limits_{j=1}^kF_{x-j}^{b_j}  ,  & \rm{x>k}\end{cases} \  (\mod 998,244,353)</script><p>大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个<del>我没想出来、想出来也不会用的</del>$Idea$，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。</p>
<p>次我们选择$998,244,353$的<strong>原根</strong>作为底数。因为原根有一个很优美的性质，就是<strong>$p$的原根的幂次可以遍历$p$的简化剩余系。</strong>而由$NTT$里得到的经验，这个模数的最小原根是$3$。</p>
<hr>
<p>原根的基本定义：设$g$为$p$的一个原根，则满足：</p>
<script type="math/tex; mode=display">𝑔^{𝑝−1}  \equiv 1(\mod p)</script><script type="math/tex; mode=display">∀1≤𝑘<𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)</script><hr>
<p>之后呢？之后我们就找一个函数$q(x)$，令<script type="math/tex">g^{q(x)} \equiv x(\bmod p)</script> 目的是为了构造一个$l_x = q(F_x)$，使得等式<script type="math/tex">g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}}( \mod p)</script>成立。而比较特殊的是，因为$F_1$~$F_{k-1}$都为$1$，所以$l_i=0\quad(1 \leq i &lt;k)$ 。那么也就是说对于指数上的$l_x$满足<script type="math/tex">l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i}( \mod p-1)</script>这就是一个线性递推的形式了。</p>
<p>此处有个小$trick$，就是我们为了防止$l_x$过大，我们需要对它取模，此时直接依据费马小定理，取$p-1$做模数即可。</p>
<p>接下来是一个十分巧妙的$Idea$，我们虽然不知道$l_k$，但是我们可以知道$l_k$到$l_n$是如何变化的。观察题目性质，<script type="math/tex">l_j = \omega_j l_k \mod(p-1)</script>其中的$\omega_j$是一个关于$b_k$的常量因子。证明也比较简单，因为$l_i=0\quad(1 \leq i &lt; k) $是显然的。</p>
<p>那么我们只需要做一下矩阵快速幂——幂次上是$n-k$——就可以得出$\omega_n$来。而我们的$l_n$是可以通过对原根$g$求$BSGS$解得的。那么现在就是<script type="math/tex">l_k\omega_n = l_n \mod (p-1)</script>移个项可以得到<script type="math/tex">l_k \omega_n + t(p-1)= l_n</script>由于原题让求的是最小的正整数解，所以应用一下$exgcd$判一下是否有解就解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; Hash ;</span><br><span class="line"><span class="keyword">int</span> N, T, base[MAXN] ;</span><br><span class="line">LL Ft, Hn, Xs, Ans, X, Y, G  ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    LL M[MAXN][MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N; ++ k)</span><br><span class="line">                    Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                    Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix T, LL P)</span></span>&#123;</span><br><span class="line">    Matrix Ans ; Ans.reset() ;</span><br><span class="line">    <span class="keyword">while</span> (P)&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &amp; <span class="number">1</span>) Ans = Ans * T ;</span><br><span class="line">        T = T * T, P &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    LL P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p - <span class="number">1</span>)), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= P ; ++ j, (i *= x) %= p)  <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; </span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p)  <span class="keyword">if</span> (Hash.count(i)) <span class="keyword">return</span> Hash[i] + j * P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line">    LL t = exgcd(b, a % b, y, x) ;  y -=  a / b * x ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL k = <span class="number">0</span>, p = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; c = getchar() ; <span class="keyword">if</span> (c == <span class="string">'-'</span>) p = <span class="number">-1</span> ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; Ft ;  Matrix lab ;  lab.clear() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) lab.M[i][i - <span class="number">1</span>] = <span class="number">1l</span>l  ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) lab.M[i][N] = <span class="number">1l</span>l * base[N -i + <span class="number">1</span>] ;</span><br><span class="line">    lab = expow(lab, T - N), Hn = bsgs(<span class="number">3</span>,Ft, Mod), Xs = lab.M[N][N] ; </span><br><span class="line">    G = exgcd(Xs, Mod - <span class="number">1</span>, X, Y) ; <span class="keyword">if</span> (Hn % G) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    X = (X % (Mod - <span class="number">1</span>) * (Hn / G) % (Mod - <span class="number">1</span>) + Mod - <span class="number">1</span>) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">    Ans = expow(<span class="number">3</span>, X, Mod) ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x00-quad-后记"><a href="#0x00-quad-后记" class="headerlink" title="$0x00\quad$后记"></a>$0x00\quad$后记</h2><p>说实话，这是第一次做整套CF的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A$~$E$都还好，但是$F$实在是……看题解都要想半天的那种……尤其是这个解离散方根的东西……哇塞恶心死了从没听说过还有这东西qaq</p>
<p>rqy说$F$题是省选一轮的难度——虽然没说是$D$几$T$几，但我感觉他的语气不像是在说一道很难的题……</p>
<p>完了，要跪了。</p>
<blockquote>
<p>奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。</p>
<p>​                                                    ——（pks《春日绝句》）</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>动态规划/普通DP</tag>
        <tag>数学/线性代数/矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】拉格朗日插值法</title>
    <url>/2019/02/07/Lagrange-Formula/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好像初三的时候看选修4-6的课本看的一脸懵，这东西似乎是为数不多印象深刻的233</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt></p>
<h2 id="rm-0x01-Preface"><a href="#rm-0x01-Preface" class="headerlink" title="$\rm{0x01~~} Preface$"></a>$\rm{0x01~~} Preface$</h2><p><strong>插值($Interpolaton$)</strong> 在多项式域中可以看做是<strong>求值$(Evaluation)$</strong>的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。</p>
<p>而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明——</p>
<h2 id="rm-0x02-rm-Proof"><a href="#rm-0x02-rm-Proof" class="headerlink" title="$\rm{0x02}~~\rm{Proof}$"></a>$\rm{0x02}~~\rm{Proof}$</h2><h3 id="rm-Proof-of-Existence"><a href="#rm-Proof-of-Existence" class="headerlink" title="$\rm Proof ~of~Existence$"></a>$\rm Proof ~of~Existence$</h3><p>我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。</p>
<p>首先我们需要构造一个对于第$i$个二元组的特殊多项式$L_i(x)$，满足<script type="math/tex">L_i(x_j) = \begin{cases}1, &\rm{i=j} \newline 0, & \rm{i \neq j}\end{cases}</script></p>
<p>那么我们所求的多项式$F(x)$就可以写作<script type="math/tex">F(x)  = \sum L_i(x_i)\cdot y_i</script>这个式子保证了我们对应的$n$个二元组，$F(x)=y$恒成立。</p>
<p>那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出<script type="math/tex">L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)</script>其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数<script type="math/tex">k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}</script>那么<script type="math/tex">L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}</script>从而<script type="math/tex">F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}</script></p>
<h3 id="mathcal-Q-E-D"><a href="#mathcal-Q-E-D" class="headerlink" title="$\mathcal{Q.E.D.}$"></a>$\mathcal{Q.E.D.}$</h3><hr>
<h3 id="rm-Proof-of-Uniqueness-1"><a href="#rm-Proof-of-Uniqueness-1" class="headerlink" title="$\rm Proof~of~Uniqueness^{[1]}$"></a>$\rm Proof~of~Uniqueness^{[1]}$</h3><p>​    我们接下来要证明的是多项式$L_i(x)$的唯一性</p>
<p>​    我们假设同时有两个实数域上的$n-1$次多项式$L_1(x),L_2(x)$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2$在取所有的$x_i$时，其值均为$0$。那么一定会有多项式<script type="math/tex">L'(x) = \prod\limits_{i=1}^{n}(x - x_i)</script>满足<script type="math/tex">L'|L_{\Delta}</script> 其中$|$表示多项式整除。但是我们知道，对于$L’$这个多项式，其次数为$n-1$；而对于我们所定义的$L_i(x)$，均为$(n-2)$次的，从而$L_{\Delta}$也是$n-2$次多项式。所以我们可以得出<script type="math/tex">L_{\Delta} = 0</script>从而有<script type="math/tex">L_1=L_2</script></p>
<h3 id="mathcal-Q-E-D-1"><a href="#mathcal-Q-E-D-1" class="headerlink" title="$\mathcal{Q.E.D.}$"></a>$\mathcal{Q.E.D.}$</h3><h2 id="rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$"></a>$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题号：Luogu4781</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL Ans, xs ;</span><br><span class="line"><span class="keyword">int</span> N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B &amp; <span class="number">1</span>) (res *= A) %= Mod ; </span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>, (A *= A) %= Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;xv[i], &amp;yv[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        t = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (xv[i] - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        t = expow(t, Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (T - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; Ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-一道水题"><a href="#0x04-一道水题" class="headerlink" title="$0x04$ 一道水题"></a>$0x04$ 一道水题</h2><p>题意大概就是给出连续的一段$x_0$和$y_0$，算出多项式$F(x)$在一个特定值$x_0’$时的值。</p>
<p>我们注意到$40 \%$的数据可以直接高消，列出$n+1$个方程。</p>
<p>同时，我们还可以用朴素的拉格朗日插值法插出$80pts$的好成绩。</p>
<p>而对于$100 \%$的数据，$n$是$1e5$级别的，所以考虑预处理出一些东西。</p>
<p>我们观察拉格朗日插值公式的一般形式：</p>
<script type="math/tex; mode=display">
F(x) = \sum \limits _{i=0}^{N} y_i \cdot \prod \limits_{i \neq j} \frac{x -x_j}{x_i-x_j}</script><p>我们发现首先分子可以$O(n)$预处理，而分母由于$x_j$是连续的，所以</p>
<script type="math/tex; mode=display">
\rm{\prod \limits _{i \neq j} x_i  - x_j}= fac(i) \cdot fac(N-i) \cdot evenmark(N-i)</script><p>其中$fac$表示求阶乘，$\rm{evenmark}$是符号函数，当$N-i$是偶数时返回$1$，否则返回$-1$。</p>
<p>于是我们就可以得出一个式子：</p>
<script type="math/tex; mode=display">
\rm F(x) = \sum \limits_{i=0}^{N}{y_i \cdot}\frac{\frac{Pre}{x-i}}{fac(i) \cdot fac(N-i) \cdot evenmark(N-i)}</script><p>其中$\frac{Pre}{x-i}$的缘由可以参考我的代码。</p>
<p>取模啥的就小费马搞一搞即可，最终复杂度$\Theta(n \log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (B)&#123;</span><br><span class="line">		<span class="keyword">if</span> (B &amp; <span class="number">1</span>) (res *= A) %= Mod ; </span><br><span class="line">		B &gt;&gt;= <span class="number">1</span>, (A *= A) %= Mod ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_symbol</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> (!x ? <span class="number">1</span> : Mod - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; Fac[<span class="number">0</span>] = qwq = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), (Fac[i + <span class="number">1</span>] = Fac[i] * (i + <span class="number">1</span>)) %= Mod ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; Ans = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T &lt;= N) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, base[T]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) (qwq *= (T - i + Mod)) %= Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		M = (N - i) &amp; <span class="number">1</span>, _qwq = qwq * expow((T - i), Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">		t = expow(Fac[i] * Fac[N - i] % Mod, Mod - <span class="number">2</span>) % Mod ; </span><br><span class="line">		t = t * (get_symbol(M) * _qwq % Mod) % Mod, t = (t * base[i]) % Mod ;</span><br><span class="line">		(Ans += t)  %= Mod ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; Ans &lt;&lt; endl ;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
<h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter:pks}$"></a>$\mathfrak{writter:pks}$</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【摸鱼笔记】群论入门</title>
    <url>/2019/02/06/%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>⑧说别的了，抽代赛高！</p>
<a id="more"></a>
<h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="1-群的定义"><a href="#1-群的定义" class="headerlink" title="$1~)~$群的定义"></a>$1~)~$群的定义</h2><p>比较简单的来讲，所谓<strong>群$(\rm{group})$</strong>指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质：</p>
<p>我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算：</p>
<h4 id="Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G"><a href="#Property1-封闭性-forall-a-in-G-b-in-G-a-color-purple-qwq-b-in-G" class="headerlink" title="$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$"></a>$Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$</h4><h4 id="Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c"><a href="#Property2-运算的结合性-a-color-purple-qwq-b-color-purple-qwq-c-a-color-purple-qwq-b-qwq-c" class="headerlink" title="$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$"></a>$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$</h4><h4 id="Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a"><a href="#Property3-存在单位元（幺元）满足以下定义：-exists-e-in-G-s-t-forall-a-in-G-e-color-purple-qwq-a-a-color-purple-qwq-e-a" class="headerlink" title="$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$"></a>$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$</h4><h4 id="Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e"><a href="#Property4-对于每个元素，存在逆元，即满足-forall-a-in-G-exists-b-in-G-s-t-a-color-purple-qwq-b-b-color-purple-qwq-a-e" class="headerlink" title="$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$"></a>$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$</h4><p>那么也就是说的直白点吧，对所有的元素，做完该群所带有的<strong>带有结合律的运算</strong>之后，所得结果<strong>仍然属于该群</strong>且一定存在单位元，对于每个元素存在运算逆元。</p>
<p>那我们不妨定义一些其他的：</p>
<ul>
<li><h3 id="阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。"><a href="#阿贝尔群-Abel-Group-：即交换群——运算满足交换律的群。" class="headerlink" title="阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。"></a>阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。</h3></li>
<li><h3 id="半群：满足封闭性和结合律的群。"><a href="#半群：满足封闭性和结合律的群。" class="headerlink" title="半群：满足封闭性和结合律的群。"></a>半群：满足封闭性和结合律的群。</h3></li>
<li><h3 id="有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶"><a href="#有限群-Finite-Group-：元素个数有限的群称为有限群-而有限群的元素个数称作有限群的阶" class="headerlink" title="有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶"></a>有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶</h3></li>
</ul>
<p>结合几个例子来解释一下：</p>
<p>比如以下是几个乘法群 <script type="math/tex">(Q\setminus\{0\}~,~\cdot)</script> <script type="math/tex">(R\setminus\{0\}~, ~\cdot)$$$$ (C\setminus\{0\}~,~\cdot)</script></p>
<p>他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。</p>
<p>或者一个好玩儿的乘法群<script type="math/tex">((1, -1)~~, ~~\cdot)</script>或者是所有<strong>非奇异的$n$阶矩阵</strong>也可以组成一个乘法群。</p>
<p>或者是<script type="math/tex">(Z~,~+)</script>这个群比较经典$233$，其中我们借助这个来练习一下如何判断<strong>是否成群</strong>,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。</p>
<hr>
<p>$Extra   Things :$</p>
<p>以下是两种复合抽代数据结构（名字自己起的$233$）：</p>
<h3 id="环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群"><a href="#环：定义在两个运算上，-G-cdot-其中-G-是阿贝尔群，-G-cdot-是半群" class="headerlink" title="环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群"></a>环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群</h3><p>举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。</p>
<h3 id="域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群"><a href="#域：同样定义在两个运算上，-F-cdot-其中-F-是阿贝尔群，-F-setminus-0-cdot-是阿贝尔群" class="headerlink" title="域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus\{0\},\cdot)$是阿贝尔群"></a>域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus\{0\},\cdot)$是阿贝尔群</h3><p>举例子 ：$Q,R,C$即有理数域、实数域和复数域。</p>
<hr>
<p>好的，那我们尝试证明两个命题：</p>
<h3 id="Proposition1-一个群中的单位元唯一"><a href="#Proposition1-一个群中的单位元唯一" class="headerlink" title="$Proposition1~~~~$一个群中的单位元唯一"></a>$Proposition1~~~~$一个群中的单位元唯一</h3><p>设有两个单位元$e_1,e_2$</p>
<p>那么$e_1=e_1e_2=e_2$，其实是一个$233$</p>
<h3 id="Proposition2-群中元素的逆元唯一"><a href="#Proposition2-群中元素的逆元唯一" class="headerlink" title="$Proposition2~~~~$群中元素的逆元唯一"></a>$Proposition2~~~~$群中元素的逆元唯一</h3><p>以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有<script type="math/tex">b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c</script></p>
<p>显然也是同一个。</p>
<p>那么此时我打算整理一个群的共性特征：</p>
<script type="math/tex; mode=display">(ab)^{-1}=b^{-1}a^{-1}</script><p>很显然，证明如下：</p>
<script type="math/tex; mode=display">ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e</script><p>提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心</p>
<p>那么之后我们讨论<strong>周期</strong></p>
<p>对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$</p>
<p>$o(a)$表示最小正整数，使得$a^{o(a)}=e$</p>
<hr>
<h2 id="2-子群及衍生"><a href="#2-子群及衍生" class="headerlink" title="$2~)~$子群及衍生"></a>$2~)~$子群及衍生</h2><p>本节所指<strong>“群”</strong>没有特别说明便均为<strong>有限群</strong></p>
<p>不妨先给出子群的浅显版定义：</p>
<h3 id="如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示"><a href="#如果对于一个群-G-C-，其中-H-subseteq-G-，且-H-C-是群，那么我们称在运算-C-下，-H-是-G-的子群，用-H-leq-G-表示" class="headerlink" title="如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示"></a>如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示</h3><p>那么从而我们可以定义<strong>生成子群</strong>这个东西：</p>
<p><strong>生成子群：若$S \subseteq G$， 并且对于运算$C$而言，$(G,C)$也是一个群，那么就称$G$为集合$S$在运算$C$下的生成子群。集合$S$的生成子群用$&lt;<script type="math/tex">S</script>&gt;$表示</strong></p>
<p>这之后我们就可以定义<strong>陪集</strong>这个概念</p>
<p>陪集一般上包含<strong>左陪集</strong>和<strong>右陪集</strong>。</p>
<h3 id="左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。"><a href="#左陪集：如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ah-x-为-H-的与元素-a-左陪集。" class="headerlink" title="左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = \{x\in G~|~ \exists h\in H, ah=x\}$为$H$的与元素$a$左陪集。"></a>左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = \{x\in G~|~ \exists h\in H, ah=x\}$为$H$的与元素$a$左陪集。</h3><h3 id="右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。"><a href="#右陪集：-如果-H-leq-G-，对于-a-in-G-，定义集合-H-a-x-in-G-exists-h-in-H-ha-x-为-H-的右陪集。" class="headerlink" title="右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = \{x\in G~|~ \exists h\in H, ha=x\}$为$H$的右陪集。"></a>右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = \{x\in G~|~ \exists h\in H, ha=x\}$为$H$的右陪集。</h3><p>$233$也可以叫做<strong>傍集</strong>或者<strong>旁系</strong>之类的~</p>
<p>那么我们这个地方先只研究右陪集$233$</p>
<h4 id="Lemma1"><a href="#Lemma1" class="headerlink" title="$Lemma1:$"></a>$Lemma1:$</h4><p>我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的<strong>群中元素数量</strong>。 </p>
<p>这个其实比较显然，因为事实上群都是定义在<strong>非可重集</strong>上面的。</p>
<p>较为严谨的证明如下：</p>
<hr>
<p>$Proof.$</p>
<p>对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$</p>
<p>反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾</p>
<p>对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$</p>
<hr>
<h4 id="Lemma2"><a href="#Lemma2" class="headerlink" title="$Lemma2:$"></a>$Lemma2:$</h4><p>之后我们再证明一些好玩儿的：</p>
<p>命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ </p>
<p>看起来好像不是那么好玩……</p>
<hr>
<p>$Proof.$</p>
<p>若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$</p>
<p>若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$</p>
<p>$hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$</p>
<p>因此$H_a=H_b$</p>
<hr>
<p>那么我们还可以有一个推论：</p>
<p>若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$</p>
<hr>
<p>$Proof.$</p>
<p>假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾</p>
<hr>
<p>从而还可以有个定理（$Lagrange$定理）：</p>
<p>由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么</p>
<script type="math/tex; mode=display">|G|=|H|\cdot [G:H]</script><p>也就是说$|H|$是$|G|$的约数。</p>
<p>这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。</p>
<p>但是其实这是个很伟大的定理$233$ </p>
<hr>
<p>好的，那么从而就会有一些神奇的推论：</p>
<p><strong>推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ </strong></p>
<p><strong>$Proof.$</strong> 因为$o(a) = |<script type="math/tex"><</script>a<script type="math/tex">></script>|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ </p>
<p><strong>推论二：对任意的$a \in G,a ^{|G|} = e$</strong></p>
<p>$Proof.$ 比较显然，由推论一可知。</p>
<p><strong>推论三：若$|G|$为素数，则$G$是循环群</strong></p>
<p>$Proof.$ 若$a \neq e$，那么会有$|<script type="math/tex"><</script>a<script type="math/tex">></script>|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |<script type="math/tex"><</script>a<script type="math/tex">></script>|$ ，所以$G$是个循环群。</p>
<p>接下来我们真的要去做些好玩的了~</p>
<hr>
<h3 id="定理-1-·-Fermat-小定理"><a href="#定理-1-·-Fermat-小定理" class="headerlink" title="定理$1$·$Fermat$小定理"></a>定理$1$·$Fermat$小定理</h3><p>如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="$Proof. $"></a>$Proof. $</h3><p>考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知：</p>
<script type="math/tex; mode=display">\forall a\in G, a^{p-1}=1(\mod p)</script><h3 id="定理2·-Euler-定理"><a href="#定理2·-Euler-定理" class="headerlink" title="定理2·$Euler$定理"></a>定理2·$Euler$定理</h3><p>$a^{\phi(n)}=1 (\mod n)$</p>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="$Proof.$"></a>$Proof.$</h3><p>考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法</p>
<p>那么会有$|G|=\phi(n)$，从而有：</p>
<script type="math/tex; mode=display">\forall a\in G, a^{\phi(n)}=1 (\mod n)</script><hr>
<p>没错，证明十分的简洁美观。</p>
<p>作者被这种神奇的证明给折服了$stO$.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>抽象代数</category>
      </categories>
      <tags>
        <tag>数学/抽象代数/群论</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】BSGS算法初探</title>
    <url>/2019/02/06/BSGS-junior/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一类解决$a^x\equiv b(~\bmod~p)$，且$p$为$prime$的同余式的算法。</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt></p>
<h1 id="rm-0x01-mathcal-Preface"><a href="#rm-0x01-mathcal-Preface" class="headerlink" title="$\rm{0x01}$  $\mathcal{Preface}$"></a>$\rm{0x01}$  $\mathcal{Preface}$</h1><p><strong>$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法</strong>。当然也会被叫做<strong>拔山盖世</strong>、<strong>北上广深</strong>算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : </p>
<blockquote>
<p>给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x$, 使得$a^x≡ b~(\mod p)$</p>
</blockquote>
<p>而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)$，并且我们还知道$a^0=1≡1  ~(\mod p)$，所以我们可以得出一个断言：</p>
<p><strong>如果方程$a^x≡ b~(\mod p)$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))$中</strong> $\qquad \qquad(1) $</p>
<p>此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。</p>
<p>之后我们将以此为基础进行类似分块的操作——</p>
<h1 id="rm-0x02-Baby-Step-Giant-Step"><a href="#rm-0x02-Baby-Step-Giant-Step" class="headerlink" title="$\rm{0x02~~Baby~Step~Giant~Step}$"></a>$\rm{0x02~~Baby~Step~Giant~Step}$</h1><p>首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq  \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：<script type="math/tex">a^{i\cdot n+j}≡ b~(\mod p)</script>移一下项就可以变成<script type="math/tex">a^j ≡b \cdot a^{-i\cdot n} (\mod p)</script>那么现在我们的策略是算出所有$a^j$来，在$\mod p$  意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做<strong>小步$(\rm{Baby~Step})$</strong>，  称右边枚举$b \cdot a^{-i\cdot n}$叫做<strong>大步$~(\rm{Giant~Step})$</strong>。</p>
<p>那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中细节还是有的：</p>
<ul>
<li><p>计算<code>sqrt</code>时要上<strong>取整</strong>。</p>
</li>
<li><p>我们在求$a^{-i\cdot n}$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。</p>
</li>
<li>两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$</li>
<li>算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的<code>Q</code>就会<code>=0</code>，从而在下面的第二个循环处出错——我们的<code>hash[i]</code>和<code>j</code>不能同时为$0$，从而输出错误的答案。</li>
</ul>
<h1 id="rm-0x03-例题"><a href="#rm-0x03-例题" class="headerlink" title="$\rm{0x03}$   例题"></a>$\rm{0x03}$   例题</h1><p>$T1~$<a href="https://www.luogu.org/problemnew/show/P4028" target="_blank" rel="noopener">$LuoguP4028$</a></p>
<p>裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tr1 ; <span class="keyword">int</span> T ;</span><br><span class="line">LL A, B, M, P, Q ; <span class="built_in">unordered_map</span> &lt;LL, LL&gt; Hash ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        M = qr(), A = qr(), B = qr() ;</span><br><span class="line">        <span class="keyword">if</span> ((!(A % M == <span class="number">0</span> &amp;&amp; B))) bsgs(A, B, M) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$T2~$ <a href="https://www.luogu.org/problemnew/show/P3846" target="_blank" rel="noopener">$TJOI2007~Cute~Prime$</a></p>
<p>最裸最裸的、无特判的题……可以水一下双倍经验。</p>
<h1 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$\mathfrak{writter: pks}$"></a>$\mathfrak{writter: pks}$</h1>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】LCT初步</title>
    <url>/2019/02/04/LCT-s-Junior-Intro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一种以 $ \rm Splay $ 作为辅助树的、动态维护森林连通性的算法。</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p>
<h1 id="rm-0x01-闲话-·-rm-LCT-的用途以及具体思路"><a href="#rm-0x01-闲话-·-rm-LCT-的用途以及具体思路" class="headerlink" title="$ \rm{0x01} $  闲话 ·  $\rm LCT$ 的用途以及具体思路"></a>$ \rm{0x01} $  闲话 ·  $\rm LCT$ 的用途以及具体思路</h1><p>咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得 $\rm LCT$ 其实就是一个用来维护<strong>森林连通性</strong>的。</p>
<p>嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，$\rm LCT$ 是更加全能的树剖。</p>
<p>但其实吧…… $ \rm LCT $ 打板子是很简单的，但是真正理解却一点儿也不简单。因为本身 $\rm splay$ 就很麻烦了，况且 $\rm splay$ 之前一直用于维护数列。要知道，此处的 $\rm splay$ 可是作为<strong>辅助树</strong>，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener"> $\rm Luogu3391 $ </a>，在 $\rm LCT$ 里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是， $\rm LCT $ 虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与 $ \rm FFT $ 一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。</p>
<p>也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完 $\rm LCT$ ，网上的每一篇博客都包教包会。但是我今天要整理的，是对于 $ \rm LCT $ 真正的理解。希望各位看到这篇拙作的人可以获得一些什么。</p>
<h1 id="rm-0x02-闲话-·-关于-rm-splay"><a href="#rm-0x02-闲话-·-关于-rm-splay" class="headerlink" title="$ \rm{0x02} $  闲话 · 关于 $ \rm{splay} $"></a>$ \rm{0x02} $  闲话 · 关于 $ \rm{splay} $</h1><p>道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？<del>后宫佳丽三千我该翻谁的牌子呢</del></p>
<p>历史的重任最后落到了 $ \rm{splay} $ 的身上。然后 $ \rm{splay} $ 他居然：</p>
<p><img src="t1.jpg" alt></p>
<p>他甚至还：</p>
<p><img src="t2.png" alt></p>
<p>……</p>
<p>好吧，由于某些<del>rqy也不知道的</del>原因，如果不用 $ \rm{splay} $ 的话，复杂度是均摊 $ \Theta(\rm{nlog^2n}) $ , 而用 $ \rm{splay} $ 就可以做到均摊 $ \Theta(\rm{nlogn}) $  ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合 $\rm LCT$ </p>
<h1 id="rm-0x03-rm-LCT-的思路和基础操作"><a href="#rm-0x03-rm-LCT-的思路和基础操作" class="headerlink" title="$ \rm{0x03} $     $\rm LCT$ 的思路和基础操作"></a>$ \rm{0x03} $     $\rm LCT$ 的思路和基础操作</h1><h2 id="一-主要思路"><a href="#一-主要思路" class="headerlink" title="一 主要思路"></a>一 主要思路</h2><p>主要思路嘛……大概是基于<strong>实链剖分</strong>的操作。</p>
<p><strong>朴素的树剖是重链剖分</strong>，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到 $ log $ 级别。而遗憾的是 $\rm LCT$ 维护的是森林的连通性，所以只能采用实链剖分。</p>
<p>而实链剖分大体上就是把边分为<strong>虚边</strong>和<strong>实边</strong>。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵 $ \rm{splay} $ 中。 $ \rm{splay} $ 和 $ \rm{splay} $ 之间由虚边相连。</p>
<p>实链剖分的好处呢？在于<strong>实链剖分是一种动态剖分</strong>，他可以<strong>随意改变边的虚实属性</strong>。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。</p>
<p>那么接下来我们来看一个 $\rm LCT$ 是如何定义的:</p>
<ul>
<li><p>0、本质上， $\rm LCT$  是一堆树，正如它的全称「$\rm Link-Cut~Trees$」，里面充斥着实边和虚边。每一棵单独的 $\rm Link-Cut ~Tree$ 用来维护一个连通块（原图中连通）。</p>
</li>
<li><p>1、首先，一棵  $\rm LCT$  管控的是一堆分散的点，点以几棵分散的 $\rm splay$ 的形式聚集。起初整棵 $\rm LCT$ 是没有任何联系的，各自为战，各自为根。接下来看到的 $ access $ 、 $ makeroot $ 等操作，都是在自己的联通块儿内部进行的操作。换句话讲， $\rm LCT$ 维护的是有根森林，即组成森林的每个联通块都有其唯一的根。</p>
</li>
<li><p>2、实边串联起一个联通块，同一组实边存在、且仅存在于一棵 $ \rm{splay} $ 中。 $ \rm{splay} $ 和 $ \rm{splay} $ 之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。<strong>但是两种边都没有用到显式存储</strong>，都是通过splay中的 $ Son $ 数组和 $ Fa $ 数组访问的。但虚边和实边的存储有区别：</p>
</li>
<li><p>3、虚边是认父不认子，即如果 $ Fa[x]==y $ ，那么 $ y $ 不存 $ x $ 这个儿子，但是 $ x $ 存 $ y $ 这个父亲。这样做是为了可以 $ Access $ ——因为其实在 $ Access $ 的子函数 $\rm splay$ 里，发挥作用的实际上是 $ Fa $ 指针。</p>
</li>
<li><p>4、实边是完整的双向存储。</p>
</li>
<li><p>5、显然的是， $ \rm{splay} $ 中维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历 $ \rm{splay} $ 得到的每个点的深度序列严格递增。换句话讲，一个 $ \rm{splay} $ 里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵 $ \rm{splay} $ 中，键值就是原树中的深度。</p>
</li>
<li><p>6、如果  $ x $  是它所在  $\rm splay$  的最左边的点，那么它在原森林里的父亲是  $ x $  所在  $\rm splay$  的根的  $ fa $ , 否则就是  $ x $  在  $\rm splay$  上的前驱。</p>
</li>
</ul>
<h2 id="二-基础操作"><a href="#二-基础操作" class="headerlink" title="二 基础操作"></a>二 基础操作</h2><p> $ emm $ 所谓基础操作大概就是每个用到 $\rm LCT$ 的题几乎都要用到的操作。我们把  $ n $  以实边相连的儿子记作实儿子，否则记为虚儿子。</p>
<p>同时值得注意的是，$\rm Access$、$\rm Make~Root$ 、$\rm Find~Root$ 和 $\rm Merge$ 操作都是针对<strong>一棵</strong> $lct$ 的操作，而 $\rm Link$ 和 $\rm Cut$ 则是针对一整片 $lct$ 森林，可以看做“分裂/合并两个 $\rm LCT$”。    </p>
<p>至于连通块的根，可以看做是给无根树强行钦定的一个根，即原图里的根（似乎可以结合并查集理解？</p>
<ul>
<li><h2 id="rm-1-rm-Access"><a href="#rm-1-rm-Access" class="headerlink" title="$ \rm{1} $ $\rm Access $"></a>$ \rm{1} $ $\rm Access $</h2></li>
</ul>
<p>这个操作有着很迷的性质，其时间复杂度是均摊  $ \log n $  的。而这个操作的目的是 <strong>$ Access(n) $  表示从  $ root $  向  $ n $  打通一条实链，并以  $ n $  点为最深度最大的点、 $ root $  为深度最小的点形成一棵 $ \rm{splay} $ </strong>。</p>
<p>不难看出，这个操作其实就是把原来  $\rm splay$  的割据给改变了。</p>
<p>我们思考，如果此时我们  $ Access $  完点  $ n $  之后，理论上来讲， $ n $  点应该不再有实儿子了——显然，如果有实儿子的话， $\rm splay$  中是应该包含这个实儿子的——而这就不符合  $ n $  是  $ \rm{splay} $  中深度最大的点的性质了。而因为在  $ \rm splay $  中，点是以深度为键值的，所以我们要每次砍掉 $ \rm{splay} $ 中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的  $ \rm{splay} $  连上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">		splay(x), rc = qwq, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这就是 $\rm Access $ 了。</p>
<ul>
<li><h2 id="rm-2-Make-Root"><a href="#rm-2-Make-Root" class="headerlink" title="$\rm 2 ~Make~ Root~ $"></a>$\rm 2 ~Make~ Root~ $</h2></li>
</ul>
<p>这个操作的目的是把一个节点变成  $ lct$  的根节点。</p>
<p>先从  $ root $  向  $ n $  打通一条路径，然后  $\rm splay$  上去，最后  $ reverse $  一下。此处由于一开始  $ n $  的深度最大， $\rm splay$  之后深度依旧最大，但此时  $ n $  是  $\rm splay$  的根，所以  $ reverse(n) $  就相当于翻转了整条树上的链，那么翻转之后， $ n $  的深度就变成了最小，于是就是这个联通块儿的根节点了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line">	<span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line">	<span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line">	<span class="keyword">while</span>(check(x))&#123;</span><br><span class="line">	<span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line">	<span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 $\rm splay$ 中由于<strong>要下放标记，需要保证树的形态是正确</strong>的，所以我们用一个 $ stack $ 存一下，顺序下放标记。</p>
<ul>
<li><h2 id="rm-3-Merge"><a href="#rm-3-Merge" class="headerlink" title="$\rm 3 ~Merge~ $"></a>$\rm 3 ~Merge~ $</h2></li>
</ul>
<p>此处的 $\rm Merge(x, y) $ 的意义是，拉起 $ x,y $ 中间的链，形成一个 $\rm splay$ 。这里就直接 $ Mkroot $ 一遍，然后 $ Access $ 即可。让哪个点当根应该都可以，只不过多 $\rm splay$ 几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。</p>
<p>upd：此处 $\rm splay$ 还有深层次的意图，就是可以保证现在 $ x $ 和 $ y $ 是相邻的，这样在cut的时候就会很方便了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="rm-4-Link-amp-Cut"><a href="#rm-4-Link-amp-Cut" class="headerlink" title="$\rm 4~Link~\&amp;~Cut $"></a>$\rm 4~Link~\&amp;~Cut $</h2></li>
</ul>
<p>如果保证 $ \rm Link $ 和 $ \rm Cut $ 都是合法的操作的话， $ \rm Link $ 直接连， $ \rm Cut $ 直接删即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Merge(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br></pre></td></tr></table></figure>
<p>此处 $\rm Link$ 必须先 $ \rm Mkroot $ 一下，否则树链就断了。连的是虚边（因为连实边就会改变原来 $\rm splay$ 的割据）； $ \rm Cut $ 必须先 $\rm Merge$ 一下，保证两个点之间在同一棵 $\rm splay$ 中，加之我们的 $ Merge $ 操作中，一开始把 $ x $ 给 $ mkroot $ 了，再把 $ y $ 点 $\rm splay$ 上去，直接导致了现在 $ x $ 应该是 $ y $ 的孩子——于是就很开心的，可以直接 $\rm Cut$ 了。       </p>
<p>但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致 $ GG $ ，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作……</p>
<ul>
<li>1、 $\text{ New-Link }$  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br></pre></td></tr></table></figure>
<p>此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。 $ \rm Find $ 则是找到这个 $lct$ 维护的连通块内的根。 </p>
<p>但要注意啊， $ Find $ 找的是原树中的根，不是 $\rm splay$ 。由于原树中根的深度一定最小，所以应该是 $\rm splay$ 中最靠左的点……所以不断找左儿子。</p>
<p>多 $ BB $ 一句，这个地方一定注意啊！ $ Find $ 只改变了 $\rm splay$ 的形态， $ mkroot $ 改变的是原树中的根</p>
<ul>
<li>2、 $\text{New-Cut}$ </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">	Rooten(x) ; </span><br><span class="line">	<span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; </span><br><span class="line">	T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵 $\rm splay$ 中的体现，要克服两个问题，第一是要判断是否连通，还是 $ Find $ 操作。</p>
<p>之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的 $ x $ 比 $ y $ 在原树位置靠上（ $ Rooten $ 了 $ x $ ），在 $\rm splay$ 中靠左，那么如果 $ y $ 有左儿子的话，说明一定有</p>
<script type="math/tex; mode=display">
\rm Depth(x) < Depth(y\text{的左儿子们})  < Depth(y)</script><p>其中 $\rm depth$ 表示原树深度。那么此时原树中 $ x $ 和 $ y $ 之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当 $\rm T[y].son[0] $ 不指向 $ Null $ 时， $ x $ 和 $ y $ 之间没有一条边，不能直接 $\rm Cut$ 。</p>
<p>剩下的就很简单了， $\rm T[y].F $ 应该是 $ x $ ，否则也不是直接相连。</p>
<ul>
<li><h2 id="5-rm-Rotate-中的坑点"><a href="#5-rm-Rotate-中的坑点" class="headerlink" title="5  $\rm ~Rotate $ 中的坑点"></a>5  $\rm ~Rotate $ 中的坑点</h2></li>
</ul>
<p>呃……其实就一处而已。就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">	T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x</span><br><span class="line">  T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方 $\rm splay$ 双旋判断祖父的时候，不再用 $ \rm{if(g\text{_}fa)} $ ，而是用 $ \rm{if(check(fa))} $ 。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的 $\rm splay$ </p>
<p>剩下的……大概就没了吧……</p>
<p>于是——</p>
<h1 id="color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$ \color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e} $"></a>$ \color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e} $</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目名称：UOJ#3 「NOI2014」魔法森林</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va(k) E[k].va</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vb(k) E[k].vb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000008</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">bool</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> va, vb ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge a, Edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.va &lt; b.va ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (lc(fa(x)) == x) || (rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span> ; swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vb(val[x]) &lt; vb(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vb(val[x]) &lt; vb(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    fa(t[x].son[w ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((f1 == rc(f2)) == (rc(f1) == x))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span> (lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    <span class="keyword">if</span> (find_root(y) != x)</span><br><span class="line">        <span class="keyword">return</span> fa(x) = y, <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    access(y) ; splay(y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(to(x)) ; splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = find(f[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        split(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            split(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x00-后记和参考"><a href="#rm-0x00-后记和参考" class="headerlink" title="$ \rm{0x00} $    后记和参考"></a>$ \rm{0x00} $    后记和参考</h1><p>可写完了……嗝……<del>打个肥宅嗝犒劳犒劳自己</del></p>
<p>怎么说呢，自从我开始学 $\rm LCT$ 到我写完这篇 $ blog $ 为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的 $\rm LCT$ ，想当然地、草率地理解了理解，就开始打板子，对 $\rm LCT$ 一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨……</p>
<p>写博客真是一个陶冶情操的过程啊……<del>包括做表情包</del></p>
<p>加油吧， $ pks $ ！</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $\rm Flash\text{_}Hu $ 的 $ blog $  <a href="http://www.cnblogs.com/flashhu/p/8324551.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :某篇论文，结合食用效果显著 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a></li>
</ul>
<h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$ \mathfrak{writter:pks} $"></a>$ \mathfrak{writter:pks} $</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Link-Cut Trees</category>
      </categories>
      <tags>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】左偏树</title>
    <url>/2019/01/27/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只会写不会用系列.jpeg</p>
<a id="more"></a>
<p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt></p>
<p>嗯…就当作是复习了233…时隔好几个月（其实就两个月）才想起来要整理。</p>
<h1 id="rm-0x01-关于左偏树"><a href="#rm-0x01-关于左偏树" class="headerlink" title="$\rm{0x01}$  关于左偏树"></a>$\rm{0x01}$  关于左偏树</h1><p>首先是整理自己想出来的几个梗</p>
<ul>
<li>$\mathcal{To~be~(left) ~or~not ~to~be~(left), this~is ~a~question}$ 左偏还是右偏，这是个问题。（哈姆雷特梗）</li>
<li>$Hell~!~Where~is~my~Left~Leaning~Tree?$ 该死，我的左偏树向右偏了。</li>
<li>左偏树是1个log，右偏树也是1个log，那我左右都偏是不是就会更快！（恭喜你建出了一棵满二叉树）</li>
<li>讲个鬼故事：每棵树都是下偏树。</li>
<li>其实，左耳离心脏更近，所以甜言蜜语麻烦合并到左偏树里吧。（《左耳》梗）<br><del>好吧我承认不是很好笑</del></li>
</ul>
<p>呐，下面进入正题。左偏树，一种<strong>可以合并的堆状结构</strong>，支持$insert/remove/merge$等操作。稳定的时间复杂度在$\Theta(\log n)$的级别。对于一个左偏树中的节点，需要维护的值有$dist$和$value$。其中$value$不必多说，$dist$记录这个节点到它子树里面最近的叶子节点的距离，叶子节点距离为$0$。</p>
<p>首先，他有以下几个喜闻乐见的性质：</p>
<blockquote>
<p>一个节点的$value$必定（或小于）左、右儿子的$value$ <strong>（堆性质）</strong><br>一个节点的左儿子的$dist$不小于右儿子的$dist$ <strong>（左偏性质）</strong><br>一个节点的距离始终等于右儿子$+1$</p>
</blockquote>
<p>那么这就可以推出以下性质：</p>
<blockquote>
<p>推论：任何时候，节点数为$n$的左偏树，距离最大为$\log (n+1)-1$</p>
</blockquote>
<script type="math/tex; mode=display">
\mathcal{Proof.}</script><p>对于一棵距离为定值$k$的树，点数最少时，一定是一棵满二叉树。这是显然的。因为对于每个节点，如果想要有最少的儿子，那么起码要做到左儿子的数量等于右儿子的数量。那么对于他的逆命题也是成立的——“若一棵左偏树的距离为$k$，则这棵左偏树至少有$2^{k+1}-1$个节点。”<br>所以会有</p>
<script type="math/tex; mode=display">
n \geq 2^{k+1}-1\\\ \log_2{(n+1)} \geq k+1\\\ \log_2{(n+1)}-1 \geq k</script><script type="math/tex; mode=display">
\mathcal{Q.E.D}</script><p>$emmm$这可是一个很美妙的性质啊。</p>
<h1 id="rm-0x02-基本操作"><a href="#rm-0x02-基本操作" class="headerlink" title="$\rm{0x02}~~$基本操作"></a>$\rm{0x02}~~$基本操作</h1><ul>
<li><h2 id="Merge"><a href="#Merge" class="headerlink" title="$Merge$"></a>$Merge$</h2></li>
</ul>
<p>这是整个左偏树的重头戏，时间复杂度稳定在一个$log$，其主要思想就是不断把新的堆合并到新的根节点的右子树中——因为我们的右子树决定“距离”这个变量，而距离又一定保证在$~\log~$的复杂度内，所以不断向右子树合并。</p>
<p>大体思路（以小根堆为例），首先我们假设两个节点$x$和$y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了。</p>
<p>合并了$x$的右子树和$y$之后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护性质二，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x = dist_{rson(x)}+1$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; </span><br><span class="line">    <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; </span><br><span class="line">    S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察，我们是不断交替拆分右子树，由推论可得我们的距离不会大于$\Theta(\log(n_x+1))+\Theta(\log(n_y+1))-2 =O(\log n_x+ \log n_y) $ </p>
<p>这个地方比较喜闻乐见的是需要存$root$，即需要路径压缩。不路径压缩的话，寻一次$rt$就是$\Theta(n)$的了，复杂度是不对的<del>但似乎Luogu的模板，不路径压缩会更快</del></p>
<ul>
<li><h2 id="Pop"><a href="#Pop" class="headerlink" title="$Pop$"></a>$Pop$</h2></li>
</ul>
<p>……$pop$的话，乱搞就好了$233$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br></pre></td></tr></table></figure>
<p>然后就是总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">		<span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">			<span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">			<span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x03-一点问题"><a href="#rm-0x03-一点问题" class="headerlink" title="$\rm{0x03}$    一点问题"></a>$\rm{0x03}$    一点问题</h1><p>问题大概就是路径压缩……</p>
<p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">$LuoguP3377$</a>很不负责任地处了数据，导致以下这份代码可以过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, val, F, Son[<span class="number">2</span>] ;</span><br><span class="line">&#125;S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].F = S[rs].F = <span class="number">0</span>, Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">    rs = Merge(rs, y), S[rs].F = x ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">            <span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span> || B == C) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; Merge(f1, f2) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切都很正常，但问题在于他复杂度不对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br></pre></td></tr></table></figure>
<p>这显然是个上界为$O(n)$的函数……不寒而栗……</p>
<p>所以他是不对的，<a href="https://www.luogu.org/discuss/show/96561" target="_blank" rel="noopener">这组数据</a>可以很好的卡掉（由巨佬小粉兔制作）。</p>
<p>所以应该用一个并查集维护。而我们在路径压缩之后，必须要在$pop$后，给$pop$掉的点一个指针指向新的根，所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br></pre></td></tr></table></figure>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 150010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap my_swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">		<span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">			<span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">			<span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x04-一道水题"><a href="#rm-0x04-一道水题" class="headerlink" title="$\rm{0x04}$    一道水题"></a>$\rm{0x04}$    一道水题</h1><p>无论怎么说，单独用一篇博客来整理板子题实在是太$Low$了（尤其是显得笔者很没品位），于是就直接拼到一起吧qwq</p>
<p><strong>[LuoguP1456]Monkey King</strong> <a href="https://www.luogu.org/problemnew/show/P1456" target="_blank" rel="noopener">链接</a></p>
<p>这玩意儿真tm水爆啊…直接存个代码证明我做过这道题吧qaq：</p>
<p>等会儿，突然想起来这道题的坑点来。就是原来的板子题，都是维护序列那种感觉，一个元素pop掉之后又就不用管它了。但是这道题是一道应用题，所以不应该删完不管，应该清空qwq。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a, i, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, dis, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> N, M, A, B, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == T[x].rt)  <span class="keyword">return</span> x ;</span><br><span class="line">	<span class="keyword">return</span> T[x].rt = get(T[x].rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].val &lt; T[y].val) x ^= y ^= x ^= y ;</span><br><span class="line">	rc = Merge(rc, y) ; <span class="keyword">if</span> (T[lc].dis &lt; T[rc].dis) lc ^= rc ^= lc ^= rc ;</span><br><span class="line">	T[lc].rt = T[rc].rt = T[x].rt = x, T[x].dis = T[rc].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N))&#123;</span><br><span class="line">		<span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">		rep(<span class="number">1</span>, i, N) T[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T[i].val) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">		rep(<span class="number">1</span>, i, M)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ; <span class="keyword">int</span> rt1, rt2 ;</span><br><span class="line">			<span class="keyword">int</span> f1 = get(A), f2 = get(B) ; <span class="keyword">int</span> ff1, ff2 ;  </span><br><span class="line">			<span class="keyword">if</span> (f1 == f2) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">			T[f1].val &gt;&gt;= <span class="number">1</span>, T[f2].val &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">			rt1 = Merge(T[f1].Son[<span class="number">0</span>], T[f1].Son[<span class="number">1</span>]) ; </span><br><span class="line">			T[f1].Son[<span class="number">0</span>] = T[f1].Son[<span class="number">1</span>] = T[f1].dis = <span class="number">0</span> ; </span><br><span class="line">			rt2 = Merge(T[f2].Son[<span class="number">0</span>], T[f2].Son[<span class="number">1</span>]) ; </span><br><span class="line">			T[f2].Son[<span class="number">0</span>] = T[f2].Son[<span class="number">1</span>] = T[f2].dis = <span class="number">0</span> ; </span><br><span class="line">			ff1 = Merge(f1, rt1), ff2 = Merge(f2, rt2) ;</span><br><span class="line">			T[ff2].rt = T[ff1].rt = Merge(ff1, ff2), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[get(T[ff1].rt)].val) ; 	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>左偏树</category>
      </categories>
      <tags>
        <tag>可并堆/左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】HLPP+丧心病狂的优化</title>
    <url>/2019/01/11/HLPP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt></p>
<blockquote>
<p>#define $u$的伴点集合     与$u$相隔一条边的且$u$能达到的点的集合 </p>
</blockquote>
<h1 id="0x00-Preface"><a href="#0x00-Preface" class="headerlink" title="$0x00~ {}~Preface$"></a>$0x00~ {}~Preface$</h1><blockquote>
<p><strong>$HLPP(Highest~Label~Preflow~Push)$最高标签预流推进算法</strong>是处理网络最大流里两种常用方法——<strong>增广路</strong>&amp;<strong>预流推进</strong>中，预流推进算法的一种。据传由$tarjan$发明<del>怎么又是他</del> ，并被其他科学家证明了其复杂度是<strong>紧却的$O(n^2\sqrt m)$</strong>。在随机数据中不逊色于普通的增广路算法，而在精心构造的数据中无法被卡，所以是一种可以替代$Dinic$的方法（随我怎么说，代码又长又难调，所以还是$Dinic$好啊$\rm{TAT}$）</p>
<p>但无论怎样，$wiki$里面已经承认$HLPP$是现在最优秀的网络流算法了。</p>
</blockquote>
<p>那么<strong>预流推进</strong>这个大门类里面，思想都差不多。大抵上就是我们对每个点记录<strong>超额流($Extra~Flow$)</strong> ，即<strong>允许流在非源点暂时存储</strong>，并<strong>伺机将超额流推送出去</strong>。不可推送的，就会流回源点。那么最终答案显然存储在$Extra[T]$里面。</p>
<p>但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用<strong>最高标号</strong>的策略，给每个点一个高度，对于一个点$u$以及它的伴点集合$\{v\}$，当且仅当$h_u = h_v + 1$ 时才可以推送流。并且我们对于源点$S$，设置$h_S = N$，并对于$S$实行<strong>无限制推送</strong>。那么最后的答案就保存在$Extra[T]$里面 。</p>
<p>但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑<strong>拔高它的高度</strong>，即<strong>重贴标签($relabel$)</strong>操作。</p>
<h1 id="0x01-quad-初步的算法流程"><a href="#0x01-quad-初步的算法流程" class="headerlink" title="$0x01\quad$ 初步的算法流程"></a>$0x01\quad$ 初步的算法流程</h1><p>以下我们用$Extra_u$表示$u$的超额流，$h_u$表示$u$的高度，用$f_k$表示边$k$的容量。</p>
<ul>
<li><p>首先把所有的$h_i$都置为零，并把$h_s$置为$N$（点数）。</p>
</li>
<li><p>将$S$的流推送到每个与$S$相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。</p>
</li>
<li><p>对于点$u$推送过程中，如果$Extra_u$减到了$0$，就立即退出<strong>（优化一）</strong></p>
</li>
<li><p>对于每条出边$k$，推送的流量$F = min(f_k,Extra_u)$并执行两个点（$u,v$）的超额流增减。<strong>如果$v$不在堆里面</strong>，要把$v$放到堆里面。</p>
</li>
<li><p>如果推送完毕$Extra[u]$不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度$h_{min}$，则新的$h_u = h_{min}+1$，并把$u$入堆。</p>
</li>
</ul>
<p>好的，然后就可以撒花了……可是等等，他怎么这么慢$qaq$</p>
<p>接下来我们发现，重贴标签的过程似乎与$ISAP$有点点像……所以我们不妨通过一个$Gap$数组来记录”断层情况“：即如果对于一个点$u$来说，他的伴点集$\{v\}$已经不存在$h_u = h_v + 1$的点了，并且也不存在一个点$j$使得$h_j = h_u$那么这个地方就是一个<strong>断层$(Gap)$</strong> ，那么也就是说，对于所有$h_i&gt; h_u$的点来说，它们把流推送到$h_u$的高度就不能继续推送了，所以我们直接$h_i = N + 1$，让他们回流到源点。<strong>（优化二）</strong></p>
<p>接下来这个优化，亲测可以<strong>提速$4000ms$</strong>，平均每个测试点提速$700$ ~ $800ms$，去掉数据最小的点，每个点平均提速$1000ms$。这就是——$BFS$!</p>
<p>我们不妨一开始就倒着$BFS$一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度（源点高度还是$N$。嗯，$Mr_Spade$大佬实在太强了$qwq$</p>
<p>对了，代码实现方面，需要好多判断不是源点和汇点的小细节……无路赛无路赛无路赛$&gt;_&lt;$！</p>
<h2 id="color-red-C-color-cyan-o-color-gold-d-color-green-e-·1"><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e-·1" class="headerlink" title="$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$"></a>$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//省略某些部分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf, MAXN, MAXM, to(k)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num, h ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now) </span><br><span class="line">    <span class="keyword">const</span>&#123;  <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ; priority_queue &lt;state&gt; heap ; </span><br><span class="line">BFS init ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T, cnt = <span class="number">-1</span>, A, B, C, D, t, min_h ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Preflow_Push</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(H[i] &lt; Inf) ++ Gap[H[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(k = head[S]; k != <span class="number">-1</span> ; k = E[k].next)</span><br><span class="line">        <span class="keyword">if</span>((t = E[k].f))&#123;</span><br><span class="line">            E[k].f -= t, E[k ^ <span class="number">1</span>].f += t, Extra[S] -= t, Extra[to(k)] += t ;</span><br><span class="line">            <span class="keyword">if</span>(to(k) != T &amp;&amp; !vis[to(k)])</span><br><span class="line">                heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        vis[node = heap.top().num] = <span class="number">0</span>, min_h = Inf, heap.pop() ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[node] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(E[k].f &amp;&amp; H[node] == H[to(k)] + <span class="number">1</span>)&#123;</span><br><span class="line">                t = min(Extra[node], E[k].f) ;</span><br><span class="line">                E[k].f -= t, E[k ^ <span class="number">1</span>].f += t, Extra[node] -= t, Extra[to(k)] += t ;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T)</span><br><span class="line">                    heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (E[k].f) min_h = min(min_h, H[to(k)]) ;</span><br><span class="line">            <span class="keyword">if</span> (!Extra[node]) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Extra[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--Gap[H[node]])    </span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span>(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + <span class="number">1</span>) H[i] = N + <span class="number">1</span> ;</span><br><span class="line">            H[node] = Inf; H[node] = min_h + <span class="number">1</span> ; </span><br><span class="line">            heap.push((state)&#123;node, H[node]&#125;), vis[node] = <span class="number">1</span>, ++ Gap[H[node]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;fast;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Input() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        head[i] = <span class="number">-1</span>, H[i] = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(M --)&#123;Add; &#125;</span><br><span class="line">    q.push(T), H[T] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[now] ; k != <span class="number">-1</span> ; k = E[k].next)</span><br><span class="line">            <span class="keyword">if</span> (H[to(k)] &gt; H[now] + <span class="number">1</span>)</span><br><span class="line">                H[E[k].to] = H[now] + <span class="number">1</span>, q.push(E[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (H[S] == <span class="number">0</span>) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125; </span><br><span class="line">    H[S] = N, Preflow_Push() ; <span class="built_in">cout</span> &lt;&lt; Extra[T] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来我们加上下面这一句话的毒瘤卡常就可以有$4000ms$左右的好成绩，但事实上，这个速度依旧慢的要死。</p>
<p><strong>注意！这个写法是经典写法，其时间复杂度是紧却的$\boldsymbol{\rm{\Theta(n^2mlogn)}}$的，也就是说在$\boldsymbol{n=1200}$时会带一个$\boldsymbol{10}$倍的常数</strong></p>
<p>怎么优化呢——</p>
<h1 id="boldsymbol-0x02-Optimization"><a href="#boldsymbol-0x02-Optimization" class="headerlink" title="$\boldsymbol{0x02~~Optimization}$"></a>$\boldsymbol{0x02~~Optimization}$</h1><p>各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）……</p>
<p>来，我们首先思考思考普通的HLPP到底会慢在哪里：</p>
<ul>
<li><p>$STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！</p>
</li>
<li><p>每次$Gap$优化，我们的时间复杂度是<strong>紧确</strong>的$\Theta(n)$。的这显然不合算，因为假设我当前的$\boldsymbol{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会<strong>浪费$\boldsymbol{\Theta(n)}$的时间</strong>。</p>
</li>
</ul>
<p>事实上…普通的$HLPP$代码并不长，主要问题就是这两个。</p>
<p>我们考虑，如果不用堆的话怎么做呢？</p>
<p>呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，<strong>高度函数$\boldsymbol{H(x)}$和点数集大小$\boldsymbol{N(x)}$是广义同阶的。</strong> 换句话说，我们可以考虑从高度入手。</p>
<p>换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\boldsymbol{O(n)}$而不是$\boldsymbol{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。</p>
<p>那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。</p>
<p>也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333</p>
<p>hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。</p>
<p>好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花…</p>
<p>哦对，还有几点我debug的时候被坑死的点：</p>
<ul>
<li>那个$Iterator$类型的$vector$对象是点的编号不是高度！</li>
<li>注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质<del>wrnm</del>，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！</li>
</ul>
<h2 id="color-red-C-color-cyan-o-color-gold-d-color-green-e-·2-我觉得写的很难看但是有注释qaq-："><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e-·2-我觉得写的很难看但是有注释qaq-：" class="headerlink" title="$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$  (我觉得写的很难看但是有注释qaq)："></a>$\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$  (我觉得写的很难看但是有注释qaq)：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//writter:Orchidany(pks)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)<span class="comment">//sb毒瘤优化</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10030</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min my_min</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG begin()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Iter iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List ; <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, f, next ;</span><br><span class="line">    Edge(<span class="keyword">int</span> to,<span class="keyword">int</span> f,<span class="keyword">int</span> next):to(to),f(f),next(next)&#123;&#125;<span class="comment">//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq</span></span><br><span class="line">&#125; ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;<span class="comment">//list，就是快（</span></span><br><span class="line"><span class="comment">//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维</span></span><br><span class="line"><span class="keyword">int</span> Ans, N, M, S, T, max_H, now_H ; <span class="built_in">vector</span> &lt;Edge&gt; E[MAXN] ; <span class="comment">/*vector存边（据说会快）*/</span><span class="built_in">vector</span>&lt;List::iterator&gt; Era_pos ; <span class="comment">//辅助定位+删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">eggs</span><span class="params">()</span> </span>&#123; ;&#125;<span class="comment">//for free~</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">my_min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &amp; ((a - b) &gt;&gt; <span class="number">31</span>) | b &amp; ( ~ (a - b) &gt;&gt; <span class="number">31</span>) ;&#125;<span class="comment">//黑科技</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> v, <span class="keyword">int</span> u)</span></span>&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, <span class="number">0</span>, E[u].size() - <span class="number">1</span>)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = gc() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = gc() ;<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = gc() ; <span class="keyword">return</span> k ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init_label</span><span class="params">()</span></span>&#123;<span class="comment">//等价于一开始的那个BFS，只执行一次</span></span><br><span class="line">    rr <span class="keyword">int</span> i, h = <span class="number">0</span>, t = <span class="number">0</span> ;q.clear(), q.resize(N) ; </span><br><span class="line">    H.assign(N + <span class="number">1</span>, N + <span class="number">1</span>) ; H[T] = <span class="number">0</span> ; q[t ++] = T ;<span class="comment">//从T（高度小的）向前标号</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;<span class="comment">//队列……BFS……真熟悉啊……嗝……</span></span><br><span class="line">        rr <span class="keyword">int</span> now = q[h] ; ++ h ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k)</span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == N + <span class="number">1</span> &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + <span class="number">1</span>, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, N + <span class="number">1</span>) Set[i].clear(), Gap[i].clear() ;<span class="comment">//还是清空一下比较好吧</span></span><br><span class="line">    rep(i, <span class="number">0</span>, N) </span><br><span class="line">        <span class="keyword">if</span> (H[i]  &lt;N + <span class="number">1</span>)  </span><br><span class="line">            Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), <span class="comment">//疑似insert函数的返回值是一个指针qaq</span></span><br><span class="line">            (Extra[i]&gt;<span class="number">0</span>) ? Set[H[i]].push_back(i) : eggs() ;<span class="comment">//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同…</span></span><br><span class="line">    max_H = now_H = H[q[-- t]] ; <span class="comment">//更新，BFS的性质，最后一个元素一定高度最大（除了源点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x, Edge &amp;e)</span></span>&#123;<span class="comment">//单独写出来的push函数，好像很方便？</span></span><br><span class="line">    rr <span class="keyword">int</span> now_flow = min(Extra[x], e.f) ;</span><br><span class="line">    Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ;</span><br><span class="line">    <span class="keyword">if</span> (Extra[e.to] &gt; <span class="number">0</span> &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ;  <span class="comment">// push it into "heap"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Push(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, x_h = N, t = H[x] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k)</span><br><span class="line">        <span class="keyword">if</span> (k-&gt;f &gt; <span class="number">0</span>)<span class="comment">//如果可以流</span></span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == H[x] - <span class="number">1</span>) &#123; Push(x, *k) ; <span class="keyword">if</span> (!Extra[x]) <span class="keyword">return</span> ;&#125; <span class="keyword">else</span> x_h = min(x_h, H[k-&gt;to] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (cnt[H[x]] &lt;= <span class="number">1</span>)&#123;<span class="comment">//如果出现断层了</span></span><br><span class="line">        <span class="keyword">for</span>(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)<span class="comment">//这个gap的for肯定比O(n)优秀</span></span><br><span class="line">            <span class="keyword">for</span>(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; </span><br><span class="line">        max_H = t - <span class="number">1</span> ; <span class="comment">/*断层以上的高度都没用了*/</span><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; <span class="keyword">if</span> (x_h == N) <span class="keyword">return</span> ; <span class="comment">//重贴标签操作，为当前点删除原来的高度</span></span><br><span class="line">    ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;<span class="comment">//增添新的高度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, now ; H.assign(N, <span class="number">0</span>) ; H[S] = N ; Era_pos.resize(N)  ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) <span class="keyword">if</span> (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; </span><br><span class="line">    cnt.assign(N, <span class="number">0</span>), cnt[<span class="number">0</span>] = N - <span class="number">1</span> ; Extra.assign(N, <span class="number">0</span>), Extra[S] = INF, Extra[T] =- INF ;</span><br><span class="line">    rep(i, <span class="number">0</span>, E[S].size() - <span class="number">1</span>) Push(S, E[S][i]) ;  <span class="comment">//下面源点要单独拿出来推送，因为源点推送时高度差不需要=1.</span></span><br><span class="line">    Init_label() ; <span class="comment">//初始化（BFS）</span></span><br><span class="line">    <span class="keyword">while</span> (now_H &gt;= <span class="number">0</span>) <span class="comment">//正式开始HLPP（泪目）</span></span><br><span class="line">        <span class="keyword">if</span> (Set[now_H].empty()) now_H -- ; <span class="comment">//高度递减，实现一个堆的效果</span></span><br><span class="line">        <span class="keyword">else</span> now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;</span><br><span class="line">    <span class="keyword">return</span> Extra[T] + INF ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(),; rr <span class="keyword">int</span> i ;<span class="comment">//下面的++N是为了日后好操作qaq</span></span><br><span class="line">    rep(i, <span class="number">1</span>, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是个$fread$卡常版本$qaq$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min my_min</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG begin()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap my_swap </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Iter iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List ; <span class="keyword">int</span> step;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, f, next ;</span><br><span class="line">    Edge(<span class="keyword">int</span> to,<span class="keyword">int</span> f,<span class="keyword">int</span> next):to(to),f(f),next(next)&#123;&#125;</span><br><span class="line">&#125; ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Ans, N, M, S, T, max_H, now_H ; <span class="built_in">vector</span> &lt;Edge&gt; E[MAXN] ; <span class="built_in">vector</span>&lt;List::iterator&gt; Era_pos ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">eggs</span><span class="params">()</span> </span>&#123; ;&#125;<span class="comment">//for free~</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">my_min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &amp; ((a - b) &gt;&gt; <span class="number">31</span>) | b &amp; ( ~ (a - b) &gt;&gt; <span class="number">31</span>) ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> v, <span class="keyword">int</span> u)</span></span>&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, <span class="number">0</span>, E[u].size() - <span class="number">1</span>)) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init_label</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, h = <span class="number">0</span>, t = <span class="number">0</span> ;q.clear(), q.resize(N) ; </span><br><span class="line">    rr <span class="keyword">int</span> qaq = N + <span class="number">1</span> ; H.assign(qaq, qaq) ; H[T] = <span class="number">0</span> ; q[t ++] = T ;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;</span><br><span class="line">        rr <span class="keyword">int</span> now = q[h], qwq = H[now] + <span class="number">1</span> ; ++ h ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k)</span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == qaq &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = qwq, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) Set[i].clear(), Gap[i].clear() ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) <span class="keyword">if</span> (H[i] &lt; N)  Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] &gt; <span class="number">0</span>) ? Set[H[i]].push_back(i) : eggs() ;</span><br><span class="line">    max_H = now_H = H[q[-- t]] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x, Edge &amp;e)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> now_flow = min(Extra[x], e.f) ;</span><br><span class="line">    Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ;</span><br><span class="line">    <span class="keyword">if</span> (Extra[e.to] &gt; <span class="number">0</span> &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ;  <span class="comment">// push it into heap</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Push(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, x_h = N, t = H[x] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k)</span><br><span class="line">        <span class="keyword">if</span> (k-&gt;f &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == H[x] - <span class="number">1</span>) &#123; Push(x, *k) ; <span class="keyword">if</span> (!Extra[x]) <span class="keyword">return</span> ;&#125; <span class="keyword">else</span> x_h = min(x_h, H[k-&gt;to] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (cnt[H[x]] &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)</span><br><span class="line">            <span class="keyword">for</span>(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; <span class="keyword">if</span> (x_h == N) <span class="keyword">return</span> ; </span><br><span class="line">    ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, now ; H.assign(N, <span class="number">0</span>) ; H[S] = N ; cnt.assign(N, <span class="number">0</span>) ; Era_pos.resize(N) ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) <span class="keyword">if</span> (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[<span class="number">0</span>] = N - <span class="number">1</span> ;</span><br><span class="line">    Extra.assign(N, <span class="number">0</span>), Extra[S] = INF, Extra[T] = -INF ; rep(i, <span class="number">0</span>, E[S].size() - <span class="number">1</span>) Push(S, E[S][i]) ;  Init_label() ; </span><br><span class="line">    <span class="keyword">while</span> (now_H &gt;= <span class="number">0</span>) <span class="keyword">if</span> (Set[now_H].empty()) now_H -- ; <span class="keyword">else</span> now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;<span class="keyword">return</span> Extra[T] + INF ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); N = read(), M = read(), S = read(), T = read() ; rr <span class="keyword">int</span> i ;</span><br><span class="line">    rep(i, <span class="number">1</span>, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>撒fa~</strong></p>
<h1 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="$0x03~~$后记"></a>$0x03~~$后记</h1><ul>
<li>这道题的经典版本好几个月之前我写了一天……然后今天又翻出来，发现了巨佬<code>KevinYu</code>抛了一个玉，我就打算优化一波……毒瘤啊，什么$vector$存边、$list$我都是第一次用呜呜……</li>
<li>不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） </li>
<li>最后，人艰不拆，人艰不拆…</li>
</ul>
<h1 id="boldsymbol-mathfrak-writter-Orchidany-pks"><a href="#boldsymbol-mathfrak-writter-Orchidany-pks" class="headerlink" title="$\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$"></a>$\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$</h1>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流/最大流</tag>
        <tag>目测用不到的算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Dinic&amp;费用流</title>
    <url>/2018/08/20/net-work-flow%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt></p>
<h1 id="0x00-Preface"><a href="#0x00-Preface" class="headerlink" title="$0x00~ {}~Preface$"></a>$0x00~ {}~Preface$</h1><p>$2333$这是好久之前学的了，不过一直在咕咕咕咕。</p>
<p>一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。</p>
<p>那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。那么，我们定义容量为$c(u,v) \in E ? c(u,v) : 0$。在整张图中有一个源点和一个汇点，且对于每个点来说有<script type="math/tex">\sum F_{in} = \sum F_{out}</script>并且我们人为的将$S$的$F_{in}$设置为$0$，$F_{out}$设置为$+\infty$。$T$正好相反。当然，如果非说不合适的话，可以将源点和汇点看做同一个点233.</p>
<p>通过线性规划我们可以证明的是<strong>最大流等价于最小割</strong>，而博主现在对线性规划还只是一知半解，等什么时候“贯通了”再整理博客吧233</p>
<p>好的，窝觉得定义什么的可以不说了，我们直接上$EK$</p>
<h1 id="0x01-不知道可以用来干啥的-EK"><a href="#0x01-不知道可以用来干啥的-EK" class="headerlink" title="$0x01~$ 不知道可以用来干啥的$EK$"></a>$0x01~$ 不知道可以用来干啥的$EK$</h1><p>其实，$EK$身为大家眼中的$basis$算法，他居然是比$Dinic$晚发表的……$233$</p>
<p>全程是$Edmond-Karp$ ,由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，<del>是个比较没用的算法</del></p>
<p>他的原理就是，我们通过两个杀器来实现最大流：</p>
<p>$Killer1:$增广路</p>
<p>这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。</p>
<p>$Killer2:$ 反向边</p>
<p>虽然图集与解是单射的逻辑关系，即虽然对于同一张图$G(U, V)$无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从$T$连向$S$的，等同于原来没反向边时的情况。</p>
<p>嗯，那么我们程序实现的时候，大概就是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[k].v &amp;&amp; !dis[e[k].to])&#123;</span><br><span class="line">                    dis[e[k].to] = dis[now] + <span class="number">1</span> ;</span><br><span class="line">                    _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                    pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">                    q.push(e[k].to) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(BFS())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中$Last$记录前驱，$dis$就是个$mark$，$_F$数组记录增广路上最大的流量 。</p>
<p>那我们接下来分析复杂度。值得注意的是，$EK$由于采用$BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}++$），所以在每条边都作为残量最小值增广一次之后（至多$m$次）最短路就会增加。而最短路最多从$2$增到$n$，所以最多增广$n \times m$次。而每次$bfs$至多是$\Theta(m)$的，所以总复杂度上界是$\Theta(nm^2)$</p>
<p>但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以$EK$可以解决朴素的最大流问题。</p>
<p>全部的代码存档：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1926081700</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> MAX_F, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, pre[MAX], now ;</span><br><span class="line"><span class="keyword">int</span> A, B, C, Last[MAX], _F[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v],  head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[k].v &amp;&amp; !dis[e[k].to])&#123;</span><br><span class="line">                    dis[e[k].to] = dis[now] + <span class="number">1</span> ;</span><br><span class="line">                    _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                    pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">                    q.push(e[k].to) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(BFS())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), add(A, B, C) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-据说可以拯救世界的-Dinic"><a href="#0x02-据说可以拯救世界的-Dinic" class="headerlink" title="$0x02$  据说可以拯救世界的$Dinic$"></a>$0x02$  据说可以拯救世界的$Dinic$</h1><p>那么接下来我们说$Dinic$，这个算法是由$Dinic$教授创造的$qwq$</p>
<p>然后$Dinic$在$EK$的基础上，采用了两个新的优化方案：</p>
<p>$Case1:$分层图</p>
<p>每次我们选择用$bfs + dfs$去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用$dfs$遍历这张增广网。</p>
<p>$Case2:$当前弧</p>
<p>我们依仗的是这一段（句）代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[now];i!=<span class="number">-1</span>;i=line[i].nxt)</span><br></pre></td></tr></table></figure>
<p>其中比较重要的是引用符号，此处引用的目的是不断更新$cur$，达到不重复枚举的目的。</p>
<p>那么整体代码就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ; </span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, C, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, now, cur[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">23</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!dis[e[k].to] &amp;&amp; e[k].v)</span><br><span class="line">                dis[e[k].to] = dis[now] + <span class="number">1</span>, q.push(e[k].to) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> St, <span class="keyword">int</span> Aim, <span class="keyword">int</span> Flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (St == Aim || !Flow) <span class="keyword">return</span> Flow ; <span class="keyword">int</span> Fl, res = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;k = cur[St] ; k != <span class="number">-1</span>; k = e[k].next)</span><br><span class="line">        <span class="keyword">if</span> (dis[e[k].to] == dis[St] + <span class="number">1</span> &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123;</span><br><span class="line">            res += Fl, e[k].v -= Fl, e[k ^ <span class="number">1</span>].v+= Fl ;</span><br><span class="line">            Flow -= Fl ; <span class="keyword">if</span> (!Flow) <span class="keyword">break</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; ++ i) cur[i] = head[i] ;</span><br><span class="line">        res += dfs(S, T, <span class="number">0x7fffffff</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M;  ++ i) </span><br><span class="line">        A = qr(), B = qr(), C = qr(), add(A, B, C) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dinic() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，那么我们不难看出$cur$其实就是为了防止我们不断重复枚举边。因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走。而复杂度没有变，但是确实会更快。</p>
<p>那么接下来证明一下$Dinic$的时间复杂度。</p>
<p>根据分层图而言，$t$的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有$n$次重新分层。而对于每次在增广网上的操作，至多有$m$条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共$O(2n)$的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。</p>
<p>很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。</p>
<p>据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。</p>
<p>最后我们来说一下费用流。</p>
<h1 id="0x03-费用流（最小费用最大流）"><a href="#0x03-费用流（最小费用最大流）" class="headerlink" title="$0x03$ 费用流（最小费用最大流）"></a>$0x03$ 费用流（最小费用最大流）</h1><p>其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把$EK$的$bfs$换成$SPFA$就行了233</p>
<p>至于为什么不能$dinic$，很显然是因为没法分层啊……$hhh$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1926081700</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v, c ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">bool</span> mark[MAX] ; <span class="keyword">int</span> MAX_F, MAX_C, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, pre[MAX], now ;</span><br><span class="line"><span class="keyword">int</span> A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], e[cnt].c = <span class="number">-1</span> * c, head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(mark, mark + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	q.push(S), dis[S] = <span class="number">0</span>, mark[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ; mark[now] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)</span><br><span class="line">			<span class="keyword">if</span> (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123;</span><br><span class="line">                dis[e[k].to] = dis[now] + e[k].c ;</span><br><span class="line">                _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">				<span class="keyword">if</span>(!mark[e[k].to])&#123;</span><br><span class="line">					q.push(e[k].to) ;</span><br><span class="line">					mark[e[k].to] = <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != Inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(SPFA())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt;<span class="string">" "</span>&lt;&lt; MAX_C &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是$SPFA$他，他他他他他已经死在了$NOI2018$……</p>
<p>那么我们考虑是否能用$dijkstra$来做。那我们要考虑的就是负权边，因为我们建的反向边是要把代价也跑回去的啊，所以我们致力于解决负权边问题。$rqy$当时是这么给我们讲的：</p>
<blockquote>
<p>考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。</p>
</blockquote>
<p>那么我们从点$S$到点$B$点的距离便从$dis_B$变成了$dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。</p>
<p>下面我们思考到底要选取什么作为势函数呢？</p>
<p>我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的：</p>
<blockquote>
<p>这为什么是对的呢? </p>
<p>考虑一条边 $u→v$ ，费用为 $c$ 。</p>
<p>如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 </p>
</blockquote>
<p>于是我们现在可以用 $Dijkstra$ 增广，很快而且更难卡( </p>
<p>至于代码，大概长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 192608170</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, c, f ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> H[MAX], S ;</span><br><span class="line"><span class="keyword">int</span> dist[MAX], _F[MAX], Pre[MAX], i, k ;</span><br><span class="line"><span class="keyword">int</span> N, M, A, B, C, D, cnt = <span class="number">-1</span>, x1, x2, head[MAX] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAX] ; <span class="keyword">int</span> Last[MAX], MAX_F, MAX_C, t, ww ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].f = f ;</span><br><span class="line">    e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].f = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], e[cnt].c = <span class="number">-1</span> * c, head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; dist[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node now = q.top() ; q.pop() ; </span><br><span class="line">        <span class="keyword">while</span>(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop();</span><br><span class="line">        x1 = now.num, x2 = now.dist ; <span class="keyword">if</span>(vis[x1]) <span class="keyword">continue</span> ; </span><br><span class="line">        vis[x1] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[x1] ; k != <span class="number">-1</span> ; k = e[k].next)</span><br><span class="line">            <span class="keyword">if</span> (e[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123;</span><br><span class="line">                <span class="keyword">int</span> T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ;</span><br><span class="line">                _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(dijkstra())&#123;</span><br><span class="line">        ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ;</span><br><span class="line">        <span class="keyword">while</span>(ww != S)</span><br><span class="line">            e[Last[ww]].f -= _F[t], e[Last[ww] ^ <span class="number">1</span>].f += _F[t], ww = Pre[ww] ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) H[i] += dist[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) head[i] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt; <span class="string">" "</span> &lt;&lt; MAX_C &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流/最大流</tag>
        <tag>网络流/费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>随想二 · 丘吉尔</title>
    <url>/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一点功利的遐想？</p>
<a id="more"></a>
<hr>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>啊……还有几十天就$NOIp$了啊……</p>
<p>现在是下午四点，机房。</p>
<p>比我弱的都在颓废，比我强的都在做题。</p>
<p>唯独我在写博客。</p>
<p>我在想些什么呢？</p>
<hr>
<p>我是$pks$，没错，我不敢称自己为$Flower_pks$，不敢称自己为“花”，因为这跟我实力不符——我不是那个在$Luogu$这个$OJ$上小有名气的大佬，不是那个题解写得十分详细的作者，更不是$SD$集训里面排的上号的人。</p>
<p>没错，我不配啊。</p>
<p>上午$rqy$出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。</p>
<p>旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。</p>
<p>撇过头来看键盘上发着光的$w$键，突然有种想哭的欲望。</p>
<hr>
<p>我是真弱啊。</p>
<p>$NOIp$现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。</p>
<p>我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕……</p>
<p>但我什么也没有。我也不是个富有毅力的人。</p>
<hr>
<p>我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。</p>
<p>我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。</p>
<p>估计是我什么都不适合吧。</p>
<hr>
<p>其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。</p>
<p>这种人强到让我厌恶。也让我悲哀。</p>
<p>好啦好啦你强好啦……我滚粗好了吧……</p>
<p>我并不是很服气，但是现实却总是不尽人意。</p>
<p>过去我一直能依靠着的、可以包容我的人已经与我一别两宽了，  估计以后也只能靠自己了吧。</p>
<p>我并不知道为什么我要选择承受这么多，大概是天性使然吧。</p>
<hr>
<p>我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。</p>
<blockquote>
<p>二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”<br>“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。</p>
</blockquote>
<p>路在哪呢……</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想一 · 山丘</title>
    <url>/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello，World！</p>
<a id="more"></a>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>我是花，来自山东，今时今日写下这一篇，只是为了给并肩的$Oiers$一个不算多美的故事，为了给后来的$Oiers$一个对未来有所期望的愿景。</p>
<p>看着眼前发黄的电脑屏幕，不知道该说些什么。</p>
<p>现在的我即将高一，有着比较厉害的学长，和什么都不会的教练，每天来机房就是刷题-&gt;不会-&gt;刷题-&gt;不会。</p>
<p>大概我马上就要习惯了吧。</p>
<p>闷热的八月让人有一种说不出的惆怅，大概是初中毕业旧事未了，或者是即将$NOIp$但却并没太大信心，或者是教练总是给出不尽人意的安排打乱计划。</p>
<p>我捏着手边新换上的眼镜腿儿，默默地想到。</p>
<p>我依稀记得几个月前的快乐场景：每天都在学新算法、不亦乐乎地学、废寝忘食地学。最讨厌做模拟题、玛丽题或者搜索题。最喜欢去学习新的算法，所以导致我整天刷模板题：线段树、$Splay$、$LCA$……偶尔会兴致盎然地发几篇题解，也总是会用最生动的语言，盯着$luogu$的$markdown$那方小小的编辑框，一个字一个字地码着。二月的培训让我觉得是最有意义的一次培训了，大多数精致的$blog$都出自那时。一般都是回到宾馆后，开始联机颓废，等到半夜凌晨开始写博客，写到鱼肚泛白或者困意袭来才罢休。</p>
<p>可真是让人高兴的回忆啊……</p>
<p>回想这几个月，变化是日新月异的——就如同把一颗小小的石子扔进一池静水，起初不见多大声势，静候才可见其早已涤荡了半池——是波纹展开了。一开始来这儿，是实力悬殊的——初中有人努力、也有人不努力；初中时都挺聪明，在班里都名列前茅；初中时上奥赛几乎等于颓废，因为没多少人真正地在做题……</p>
<p>可惜时光不容许保留原来的模样。</p>
<p>主任盯得紧，教练怂主任从而也盯得紧；大多数人都因为外力的因素必须要努力，但也有根本不想努力的人；以前可以骄傲的资本、譬如文化课，现在早就变成了一纸空谈——作为所谓“奥赛负责人”的我，看到来到实验部第一次的月考成绩时，看到级部前二十（这一级实验部一共$116$个人）充斥着数学物理化学生物奥赛的人、却又跟信息学奥赛没有任何关系时，我不知道该怎么做。</p>
<p>于是我便开始加大压力：组织学生定期讲课、定期比赛。用这种空泛的压榨时间的行为来压榨效率无疑是可笑的，但是也起了一部分好的效果：几个$NOIp$内容都没会熟练的家伙开始跃跃欲试地学习$Splay$、学习网络流……我不知道这样做是否真的好，就如同我不知道我学习新东西是否会在十月、甚至十一月之前压垮所有人的神经——学完新东西、反过头来发现基础却根本不牢固——就如同为了学新知识，而去学新知识。这种功利让我不知道现在在走着一条怎样的路。</p>
<p>终于，差距出来了。经过几个月训练、实力强劲的人自然涌了上来，也有根本不行的人光辉逐渐黯淡。二月时的能力局面现在早就会焕然一新，有人选择走，有人选择苟活。我不清楚原来那些充满骄傲的、惬意的脸庞如今去了哪里，我只知道我给他们定的目标是今年全部省一、我只知道来到实验部之后，只能选择负重前行。</p>
<p>看着机房里其他人的变化，就宛如翻完了一部小说一般，跌宕而符合逻辑。</p>
<hr>
<p>告别了初中，留下了什么呢？或许是由于自身意气用事而破坏了原本纯洁的友情，但是我不能——真的不能仅仅把$Ta$当作一个不世出的好朋友。但当我跨越了自身的那一步之后才发现原来无人等候，才发现我只能把一些事情抛撒在风里，然后安慰自己“没事”。</p>
<hr>
<p>我喜欢李宗盛，喜欢他的歌里面唱出的人间无奈。而最喜欢的是他的《山丘》:</p>
<blockquote>
<p>给自己随便找了个理由，<br> 向情爱的挑逗，命运的左右。<br> 不自量力地还手，直至死方休——<br> 越过山丘——虽然已白了头；<br> 喋喋不休——时不我予的哀愁；<br> 还未如愿见着不朽<br> 就把自己先搞丢——<br> 越过山丘——才发现无人等候；<br> 喋喋不休——再也唤不回了温柔；<br> 为何记不得上一次是谁给的拥抱<br> 在什么时候。</p>
</blockquote>
<p>大概是能唱出柳永“杨柳岸晓风残月”几分意味的吧。</p>
<p>$2018/8/4$</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
</search>
