<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LCT's Junior Intro]]></title>
    <url>%2F2019%2F02%2F04%2FLCT-s-Junior-Intro%2F</url>
    <content type="text"><![CDATA[0x01\rm{0x01}0x01 闲话 · LCTLCTLCT的用途以及具体思路 LCT是啥？百度一下的话……貌似是一种检查妇科病的东西？Oier的口味可是真不一般啊 咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得LCTLCTLCT其实就是一个用来维护森林连通性的。 嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。 但其实吧……LCTLCTLCT打板子是很简单的，但是真正理解却一点儿也不简单。因为本身splaysplaysplay就很麻烦了，况且splaysplaysplay之前一直用于维护数列。要知道，此处的splaysplaysplay可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转Luogu3391Luogu3391Luogu3391，在LCTLCTLCT里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，LCTLCTLCT虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与FFTFFTFFT一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。 也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完LCTLCTLCT，网上的每一篇博客都包教包会。但是我今天要整理的，是对于LCTLCTLCT真正的理解。希望各位看到这篇拙作的人可以获得一些什么。 0x02\rm{0x02}0x02 闲话 · 关于splay\rm{splay}splay 道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢 历史的重任最后落到了splay​\rm{splay}​splay​的身上。然后splay​\rm{splay}​splay​他居然： 他甚至还： …… 好吧，由于某些rqy也不知道的原因，如果不用splay\rm{splay}splay的话，复杂度是均摊Θ(nlog2n)\Theta(\rm{nlog^2n})Θ(nlog2n), 而用splay\rm{splay}splay就可以做到均摊Θ(nlogn)\Theta(\rm{nlogn})Θ(nlogn) ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合LCTLCTLCT 0x03\rm{0x03}0x03 LCTLCTLCT的思路和基础操作 一 主要思路 主要思路嘛……大概是基于实链剖分的操作。 朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到logloglog级别。而遗憾的是LCTLCTLCT维护的是森林的连通性，所以只能采用实链剖分。 而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵splay\rm{splay}splay中。splay\rm{splay}splay和splay\rm{splay}splay之间由虚边相连。 实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。 那么接下来我们来看一个LCT​LCT​LCT​是如何定义的: 首先，一棵LCT​LCT​LCT​管控的是一对分散的点，点以几棵分散的splay​splay​splay​的形式聚集。起初整棵LCT​LCT​LCT​是没有任何联系的，各自为战，各自为根。我们接下来会看到的access​access​access​、makeroot​makeroot​makeroot​等操作，都是在自己的联通块儿内部进行的操作。换句话讲，LCT​LCT​LCT​维护的是有根森林，即组成森林的每个联通块都有其唯一的根。 实边串联起一个联通块，同一组实边存在、且仅存在于一棵splay\rm{splay}splay中。splay\rm{splay}splay和splay\rm{splay}splay之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过splay中的SonSonSon数组和FaFaFa数组访问的。但虚边和实边的存储有区别： 虚边是认父不认子，即如果Fa[x]==yFa[x]==yFa[x]==y，那么yyy不存xxx这个儿子，但是xxx存yyy这个父亲。这样做是为了可以AccessAccessAccess——因为其实在AccessAccessAccess的子函数splaysplaysplay里，发挥作用的实际上是FaFaFa指针。 实边是完整的双向存储。 splay\rm{splay}splay中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历splay\rm{splay}splay得到的每个点的深度序列严格递增。换句话讲，一个splay\rm{splay}splay里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵splay\rm{splay}splay中，键值就是原树中的深度。 如果xxx是它所在splaysplaysplay的最左边的点，那么它在原森林里的父亲是xxx所在splaysplaysplay的根的fafafa, 否则就是xxx在splaysplaysplay上的前驱. 二 基础操作 emmemmemm所谓基础操作大概就是每个用到LCTLCTLCT的题几乎都要用到的操作，我们这个地方先把点nnn所在联通块儿内的树的根记作$root(n) ，把与，把与，把与n$以实边相连的儿子记作实儿子。 1\rm{1}1 AccessAccessAccess 这个操作有着很迷的性质，其时间复杂度是均摊log⁡n\log nlogn的。而这个操作的目的是**Access(n)Access(n)Access(n)表示从root(n)root(n)root(n)向nnn打通一条实链，并以nnn点为最深度最大的点、root(n)root(n)root(n)为深度最小的点形成一棵splay\rm{splay}splay**。 不难看出，这个操作其实跟是一种逻辑层面的自我调控，没有改变原树的结构。 我们思考，如果此时我们Access​Access​Access​完点n​n​n​之后，理论上来讲，n​n​n​点应该不再有实儿子了——显然，如果有实儿子的话，splay​splay​splay​中是应该包含这个实儿子的——而这就不符合n​n​n​是splay​\rm{splay}​splay​中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉splay​\rm{splay}​splay​中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的splay​\rm{splay}​splay​连上。 1234inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125; 然后这就是Access​Access​Access​了。 2 Make Root 2 ~~Make~ Root~2 Make Root make_root​make\_root​make_root​先从原来的根向n​n​n​打通一条路径，然后splay​splay​splay​上去，最后reverse​reverse​reverse​一下。此处由于一开始n​n​n​的深度最大，splay​splay​splay​之后深度依旧最大，但此时n​n​n​是splay​splay​splay​的根，所以reverse(n)​reverse(n)​reverse(n)​就相当于翻转了整条树上的链，那么翻转之后，n​n​n​的深度就变成了最小，于是就是这个联通块儿的根节点了。 1234567891011121314151617181920#define lc T[x].Son[0]#define rc T[x].Son[1]struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; inline void splay(int x) ;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void splay(int x)&#123;int qwq = x ; stk.push(qwq) ;while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;while(!stk.empty()) push_down(stk.top()), stk.pop() ;while(check(x))&#123;int fa = T[x].F, g_fa = T[fa].F ;if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125;&#125; 此处splaysplaysplay中由于要下放标记，保证树的形态是正确的，所以我们用一个stackstackstack存一下，顺序下放标记。 3 Merge 3~~Merge~~3 Merge 此处的Merge(x,y)Merge(x, y)Merge(x,y)的意义是，拉起x,yx,yx,y中间的链，形成一个splaysplaysplay。这里就直接MkrootMkrootMkroot一遍，然后AccessAccessAccess即可。让哪个点当根应该都可以，只不过多splaysplaysplay几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。 1inline void Merge(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125; 4 Link &amp; Cut4~~Link~\&amp;~Cut4 Link &amp; Cut 如果保证LinkLinkLink和CutCutCut都是合法的操作的话，LinkLinkLink直接连，CutCutCut直接删即可。 12inline void Link(int x, int y)&#123; Rooten(x) ; T[x].F = y ;&#125;inline void Cut(int x, int y)&#123; Merge(x, y) ; T[x].F = T[y].Son[0] = 0 ;&#125; 此处LinkLinkLink必须先MkrootMkrootMkroot一下，否则树链就断了。连的是虚边（因为连实边就会改变原来splaysplaysplay的割据）；CutCutCut必须先splitsplitsplit一下，保证两个点之间在同一棵splaysplaysplay中，加之我们的MergeMergeMerge操作中，一开始把xxx给mkrootmkrootmkroot了，再把yyy点splaysplaysplay上去，直接导致了现在xxx应该是yyy的孩子——于是就很开心的，可以直接cutcutcut了。 但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致GGGGGG，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作…… New−LinkNew-LinkNew−Link 12inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125; 此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。FindFindFind就是无比普通的FindFindFind。。。。233 但要注意啊，FindFindFind找的是原树中的根，不是splaysplaysplay。由于原树中根的深度一定最小，所以应该是splaysplaysplay中最靠左的点……所以不断找左儿子。 多BBBBBB一句，这个地方一定注意啊！FindFindFind只改变了splaysplaysplay的形态，mkrootmkrootmkroot改变的是原树中的根 New−CutNew-CutNew−Cut 12345inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125; 此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵splaysplaysplay中的体现，要克服两个问题，第一是要判断是否连通，还是FindFindFind操作。 之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的xxx比yyy在原树位置靠上（RootenRootenRooten了xxx），在splaysplaysplay中靠左，那么如果yyy有左儿子的话，说明一定有Depth(x)&lt;Depth(y的左儿子们)&lt;Depth(y)Depth(x) &lt; Depth(y\text{的左儿子们}) &lt; Depth(y)Depth(x)&lt;Depth(y的左儿子们)&lt;Depth(y)，其中DepthDepthDepth表示原树深度。那么此时原树中xxx和yyy之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当T[y].Son[0]T[y].Son[0]T[y].Son[0]不指向NullNullNull时，xxx和yyy之间没有一条边，不能直接CutCutCut。 剩下的就很简单了，T[y].FT[y].FT[y].F应该是xxx，否则也不是直接相连。 5 Rotate~Rotate Rotate中的坑点 呃……其实就一处而已。就是： 123456inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void rotate(int x) &#123;int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ;if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ;T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125; 这个地方splaysplaysplay双旋判断祖父的时候，不再用if(g_fa)\rm{if(g\_fa)}if(g_fa)，而是用if(check(fa))\rm{if(check(fa))}if(check(fa))。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的splaysplaysplay 剩下的……大概就没了吧…… 于是—— Code\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 300233#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)using namespace std ;struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; stack &lt;int&gt; stk ;int base[MAXN], N, M, A, B, C, i ;inline int Find(int x) ;inline void splay(int x) ;inline void push_down(int x) ;inline void update(int x) &#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;inline void rotate(int x) &#123;int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ;if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ;T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125;inline void splay(int x)&#123;int qwq = x ; stk.push(qwq) ;while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;while(!stk.empty()) push_down(stk.top()), stk.pop() ;while(check(x))&#123;int fa = T[x].F, g_fa = T[fa].F ;if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125;&#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void split(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125;inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125;int main()&#123;cin &gt;&gt; N &gt;&gt; M ;rep(i, 1, N) scanf("%lld", &amp;base[i]) ;rep(i, 1, M)&#123;scanf("%d%d%d", &amp;A, &amp;B, &amp;C) ;if (A == 0) split(B, C), printf("%d\n", T[C].S) ;else if (A == 1) Link(B, C) ; else if (A == 2) Cut(B, C) ; else splay(B), base[B] = C ;&#125;return 0 ;&#125; 0x00\rm{0x00}0x00 后记和参考 可写完了……嗝……打个肥宅嗝犒劳犒劳自己 怎么说呢，自从我开始学LCTLCTLCT到我写完这篇blogblogblog为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的LCTLCTLCT，想当然地、草率地理解了理解，就开始打板子，对LCTLCTLCT一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨…… 写博客真是一个陶冶情操的过程啊……包括做表情包 加油吧，pkspkspks！ Reference\rm{Reference}Reference [1][1][1] :Flash_HuFlash\_HuFlash_Hu的blogblogblog [↗]^{^{[\nearrow ]}}[↗] [2][2][2] :某篇论文，结合食用效果显著 [↗]^{^{[\nearrow]}}[↗] writter:pks\mathfrak{writter:pks}writter:pks]]></content>
      <tags>
        <tag>LCT-Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intro]]></title>
    <url>%2F2019%2F02%2F04%2FIntro-1%2F</url>
    <content type="text"><![CDATA[Hello, here is Orchidany, a high-school student from S.D., China. Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is Olympiad in Informatics，shorthanded for OI. And this blog is mainly gonna to record my Learning Steps. Although I’m a bit week by now, but I shall catch the glimmer and keep getting stronger! See you soon in my articles ! Somthing Special Errr…About this ID Orchidany, there is a theory about that: My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) : 鹃住落英满，柳拂溪畔沙。 南城略炊烟，浣女徐归家。 故人今安否，欲歌口偏哑。 笔寒下梅去，皎月半洒花 So……I’ m glad to encounter you!]]></content>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
</search>
