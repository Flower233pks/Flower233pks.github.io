<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随想·目次表]]></title>
    <url>%2F2050%2F12%2F31%2F%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[终于又开始了。 换了新的博客，把之前博客园里的三篇搬了下来。 每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。 时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。 读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。 读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。 是的，我是花，一个不理智的$Oier$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。 在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。 是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。 var ap = new APlayer({ element: document.getElementById("aplayer-rPekRcdx"), narrow: false, autoplay: false, showlrc: false, music: { title: "花", author: "Hello Nico", url: "Hello Nico-花.flac", pic: "/2050/12/31/随想·目次表/qwq.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 以下是目录： 题目 链接（点击即可） 随想一 · 杨柳岸晓风残月 $Link$ 随想二 · 丘吉尔 $Link$ 随想三 · 本赛季最后的随想/启示录 $Link$ 随想四 · 故人今安否？ $Link$ 随想五 · 手中没有红玫瑰 $Link$ $\rm{empty}$ $\rm{empty}$ $\rm{empty}$ $\rm{empty}$]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式1.5·拆系数FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT2%2F</url>
    <content type="text"><![CDATA[拆系数FFT主要用于解决不可思议的任意模数$NTT/FFT$问题。 其中主要针对的就是【$Luogu4245·$任意模数NTT】这道题。链接：$Link$ $\rm{0x01\quad Preface}$今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。 由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做抄完，所以就先整理地仓促一点。 首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接long long爆艹。 $\rm{0x02~Normal-Coefficient-Spliting~FFT}$首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成$$A_i = a_iM+b_i~(0\leq b_i &lt;a_i)$$ $$B_i = c_iM+d_i~(0\leq d_i &lt;c_i)$$的形式。然后我们做乘法的话，会有$$A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i$$ 那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。 那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$ $$b_i\cdot d_i \approx \Theta(M^2)$$ $$a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)$$ $$(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor) $$ 那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 423333#define rr register #define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;const long double Pi = acos(-1) ;int R[MAXN], L, x ; long long Ans[MAXN] ;struct node&#123; long double x, y ; node (long double xx = 0, long double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;node H1[MAXN], H2[MAXN], H3[MAXN] ; int L1, L2, P, N, M ;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y); &#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y); &#125;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;void FFT(node *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; N; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; N; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125; if (flag &lt; 0) for (i = 0 ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + 0.5 ;&#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;signed main()&#123; rr int i, t ; cin &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = 32767 ; N = 1, t = L1 + L2 ; for (i = 0 ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ; for (i = 0 ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; while(N &lt;= t) N &lt;&lt;= 1, ++ L ; rep(i, 0, N) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1), FFT(C, 1), FFT(D, 1) ; rep(i, 0, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; FFT(H1, -1), FFT(H2, -1), FFT(H3, -1) ; for (i = 0 ; i &lt;= N ; ++ i) Ans[i] = ((long long)H1[i].x * M % P * M % P + (long long)H2[i].x % P + (long long)H3[i].x * M % P) % P ; for (i = 0 ; i &lt;= L1 + L2 ; ++ i) printf("%lld ", Ans[i]) ; return 0 ;&#125; 所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。 但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是—— $\rm{0x03\quad Conjugate~Optimization}$咕…… 原因是笔者虽然写出来了，但是其中的过程还需要再推敲几天。 $\rm{0x04\quad}$拼命卡常此处也咕，因为现在作业做不完没闲心去卡常……回学校躲过这一劫再说吧233 笔者现在常数还是很大的…… $\rm{0x00\quad Afterword}$后记咕~ $\rm{Reference}$ $[1]$ :$lvzelong2014$的$blog$ $^{^{[\nearrow ]}}​$ $[2]$:无梦之梦的$blog$ $^{^{[\nearrow ]}}​$ $[3]$:$Cyhlnj$的$blog$ $^{^{[\nearrow ]}}​$ $[4]$:$litble$的$blog$ $^{^{[\nearrow ]}}​$ $[5]$:$CMXRYNP$的$blog$ $^{^{[\nearrow ]}}​$ $[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式-FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式1·普通的FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT1%2F</url>
    <content type="text"><![CDATA[$\rm{0x01\quad Preface}$这篇文章初写于$7/1/2018$，是在陪同好友$yjk$与$wx$以及学长$rqy$一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍$FFT$并且写$MTT$，于是便有了这篇文章。 其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的orchidany特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。 但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。 $\rm{0x02\quad Convolution}$卷积$\boldsymbol{(Convolution)}$，准确来说是一种通过两个函数$\boldsymbol f$ 和$\boldsymbol g​$ 生成第三个函数的一种数学算子. 而广义上其定义为：$$\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}$$ 我们称$h(x)$是$g(x)$与$f(x)$的卷积。 而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到 $$A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}} $$其中$A(x)$和$B(x)$均为$N-1$次多项式比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有$2n+1$项。 $\rm{0x03\quad Dot~Method}$我们知道，原本的多项式是系数表示法，现在我们将其转化为点值表示法$(\boldsymbol{dot~method} )$。即我们可以把多项式$F(x)$转化为多项式函数$f(x)$，那么这个$n$阶函数就可以由$n+1$个点唯一确定。即$$f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)….(x_n,y_n)}$$那么$$\forall k,y_k = f(x_k)$$这是很显然的，并且这$n+$个点是随意选取的——只要求它们相异即可。 $\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$ 假设我们有两个关于$x$的$n+1$次多项式$A(x)$和$B(x)$，我们要对它的点值表达式进行乘法操作。由于结果有$2n+1$项，我们考虑补上一堆项，并对$$A(x) = {(x_0,y_0),(x_1,y_1)….(x_{2n},y_{2n})}$$ $$B(x) = {(x_0,y_0’),(x_1,y_1’)….(x_{2n},y_{2n})}$$ 做乘法可得 $$A(x)B(x) = {(x_0,y_0y_0’),(x_1,y_1y_1’)(x_{2n},y_{2n}y_{2n}’)}$$ 我们观察点乘法，它的时间复杂度达到了$\Theta(n)$，完全可以接受。那么不妨先看一下算法的大体思路： 对于每个因子多项式，选取$n+1$个点，得出点值表达式（复杂度$\Theta(n^2)$） $\longrightarrow$点乘法(时间复杂度$\Theta(n)$)——&gt;将得出来的$C(x)$的点值表达式再转换成系数表达式(复杂度$\Theta(n^2)$) 这就是$FFT$的大体流程。转化之后怎么没多快常数还大了 虽然其余部分的时间复杂度还是很麻烦的$O(n^2)$，但是都是可以优化成$O(nlogn)$的。 本质上的$FFT$包含$\boldsymbol{DFT}$（离散傅立叶变换）和$\boldsymbol{IDFT}$（逆离散傅立叶变换）实际上，$DFT$对应着的就是把系数表达式映射到点值表达式的过程，$IDFT$对应着的就是我们把点值表达式映射到系数表达式的过程。 $\rm{0x04~Base ~of~Optimization}$因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到$nlogn$的，那么总的时间复杂度，渐进意义下就是$O(nlogn)$的。 下面就让我们来看看如何优化： $\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$ $n$次单位复根是满足$\omega^n = 1$ 的复数$\omega$，其中我们可以由复数的运算法则（辐角相乘，模相加）很简单地得出$n$次单位根有$n$个这个结论——亦或者是用代数基本定理证，都可以。而又因为复数$\omega^n$在复数平面上的模都是一，所以相乘之后还会是一，那么所有的$\omega_i,1 \leq i \leq n$就会均匀分布在单位圆上，类似当$n = 8$时它是这样的： 我们考虑欧拉公式： $$e^{ix} = cosx + isinx$$ 我们取$x =2\pi$，可以得到如下关系式：$$e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}$$ 们把此时的单位根称之为主次单位根，记作$$\omega_n = e^{\frac{2\pi i}{n}} $$ 那么对于其他的单位根，记作$$\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k &lt; n$$都是主次单位根的整次幂，也就是上图中的一圈。 诶，这个有啥用啊$QAQ$? 那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到$nlogn$的复杂度…… 那么我们先来看其支持其规模减半的引理： $\frak{Elimination ~Lemma\quad}$消去引理 引理：对任何整数$n \geq 0,k \geq 0,d &gt;0$,有$$\omega_{dn}^{dk} = \omega_n^k$$ $\mathcal{Proof.}$ 这个好像很好证的样子……代入定义可以获得$$\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k$$$\mathcal{Q.E.D.}$ $\frak{Binary~Lemma\quad}$ 折半引理 引理：对于任何大于$0$的偶数$n$，都有$n$个$n$次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合。 $\mathcal{Proof.}$ 我们可以由消去引理得到$$(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k$$那么 $$(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2​$$ $\mathcal{Q.E.D.}$ 那么接下来，如果对所有的$n$次单位跟平方一下，我们会发现$\frac{n}{2}$次单位根每个都恰好出现了两次——也就是说，在$n$个$n$此单位复数根的集合（朴素的集合，即不可重集）里，只有$\frac{n}{2}$个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。 那么把所有$n$单位根的平方画到一个数列上就是这样。 这个引理直接保证了我们求值的复杂度为$\Theta(n \log n)$ 而我们在代码实现中，不能直接得到$e$或者虚数$i$，所以这个时候求单位根的任务就交给了我们上文中提到过的欧拉公式。 $\frak{Sum~Lemma\quad}$求和引理 引理：对于任意$n&gt;0$且$k$不能整除$n$，我们都有$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0$$ $Proof.$ 由几何级数的求和公式（等比数列求和公式)$$\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}$$可得$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow \frac{(\omega_n^n)^k -1}{\omega_n^k -1} = \frac{(1)^k -1}{\omega_n^k -1}$$由于保证了$k$不可整除$n$所以分母一定不为$0.$ $\mathcal{Q.E.D}$ $\rm{0x05\quad DFT \to FFT}$那么我们在了解完单位复数根之后，便可以正式地对$DFT$给出定义与操作方案了。 $DFT$ 对于我们已知的一个多项式$$A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}$$在$\omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1}$处的取值，我们可以假定$n$是$2$的幂，因为即使它本身不是$2$的幂，我们也可以通过向高次幂补值为$0$的项来解决这个问题。而补足$2$的幂的目的，就是为了在$FFT$分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。 那我们现在会有一个$A$的向量组$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$，对于$k = 0, 1, 2, \cdots n -1$，定义$y_k$如下：$$y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}$$，那么向量$$\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}$$就称作系数向量$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$的离散型傅立叶变换（$\boldsymbol{Discrete Fourier Transformation}$）。 嗯，这个离散型我们可以由点乘法联想意会一下：本来$A(x)$是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容$qwq$），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。 $FFT$优化$DFT$ 在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为$O(n^2)$，这是朴素算法。而我们只需要用一种被称作快速傅立叶变换（$\boldsymbol{Fast Fourier Transformation}$）的方式，就可以将其时间复杂度压缩成$O(nlogn)$。而在这里我们就用到了刚才证明的引理——折半引理。 我们考虑将原来的多项式$$A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}$$重定义成两个次数为$\frac{n}{2}$的小多项式$A^{[0]}(x)$和$A^{[1]}(x)$： $$A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1}$$ $$ A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1}$$ 那么也就是说，$A^{[0]}(x)$存储的是所有偶数位（二进制位最后一位是$0$），而$A^{[1]}(x)$存储的是所有的奇数位（二进制位最后一位是$1$），那么有下式：$$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$$那我们求$A(x)$在单位根们$\omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1}$处的值，就变成了先求出$A^{[0]}(x^2)$和$A^{[1]}(x^2)$的值，然后根据上式进行合并即可。 而显然的是，根据折半引理，我们根本不需要$O(n)$求，而是通过数据规模不断减小使之成为$O(\log n)$。于是，我们成功通过$FFT$优化了求值的复杂度。 那么同时对于另一边，我们可以根据 $$A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})$$ 得到 $$A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})$$ 从而有伪代码： 1234567891011121314151617181920212223int Lim = 1, N, M ;function FFT(int lenth, complex *A, int flag)&#123; IF (Lim == 1) return ; complex A0[lenth &gt;&gt; 1], A1[lenth &gt;&gt; 1] ;//分成两部分 for(int j : 0 to lenth by_grow 2) A0[j &gt;&gt; 1] = A[j], A1[j &gt;&gt; 1] = A[j + 1] ; FFT(lenth &gt;&gt; 1, A0, flag) ; FFT(lenth &gt;&gt; 1, A1, flag) ; complex Wn = unit(,) , w = (1, 0) ;//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂 /*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/ for(int j : 0 to (lenth &gt;&gt; 1) by_grow 1 with w = w * Wn)&#123; A[i] = A0[i] + A1[i] * w ;//应用公式，下同 A[i + (lenth &gt;&gt; 1)] = A0[i] - A1[i] * w ; //顺便求出另一半，由折半引理可显然。 &#125; &#125; function Main&#123; input(N), input(M) ; for(i : 0 to N by_grow 1) =&gt; input(A) ; for(i : 0 to M by_grow 1) =&gt; input(B) ; while(Lim &lt; N + M) Lim &lt;&lt;= 1 ;//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分） FFT(Lim, A, 1) ;//两遍FFT表示从系数化为点值 FFT(Lim, B, 1) ; for(i : 0 to Lim by_grow 2) =&gt; A[i] *= B[i] ;//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq &#125; 以上是基于$pks$标准下的伪代码你可以试试在c++标准下运行，其中$for$循环部分，$grow$表示当前循环变量的单次增量，之后带有$with$表示每次循环结束都会进行的运算（下同 嗯，这就是求值的方法，好像很$nice$地达到了$O(n \log n)$ $FFT$优化$IDFT$ 上文中我们曾经提及过的范德蒙德矩阵可以放到这儿用： $\begin{vmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \newline 1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; w_n^{n-1} \\newline1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n-1)} \newline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)(n-1)} \newline \end{vmatrix}$ $\begin{vmatrix} a_0 \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix}$ = $\begin{vmatrix} y_0 \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix}$ 那为了求出我们的$\vec{a} = {a_0, a_1 \cdots ,a_{n-1}}$我们应该让刚刚求值算出的$\vec{y}$乘上我们$\vec{V}^{~-1}$（$\vec{V}$的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下： 推论：对于$j,k = 0,1, 2 \cdots n-1,V_n^{-1}$的$(j, k)$处的值为$\omega_n^{-kj}/n$ $Proof.$ 我们考虑反向证明，已知$V_n’$是一个$(j,k)$处值为$\omega_n^{-kj}/n$的、与$V$形态相同的矩阵，那我们只需要证明$V’ \cdot V = I_n$即可，其中$I_n$是$n$阶单位矩阵，即主对角线都是$1$，其余位置上是$0$的矩阵。 那么我们考察$V’ V$中的元素$(i, j)$，有如下的式子$$V’V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}$$ 由求和引理当且仅当$i=j$时其值为一，其余的时刻均为零，所以有$V’V = I_n$ $\mathcal{Q.E.D}$ 那么我们把我们刚刚求出来的逆矩阵$V^{-1}$美化一下，提出每一项所除的$n$，可以得到$IDFT$可以如此计算：$$IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]$$诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当$flag=1$时，他是正向$DFT$；当它等于$-1$时，它是逆向的$ IDFT$。这可以让我们通过这一个函数解决两个过程。我们只需要用$y$替换$a$，用$\omega_n^{-1}$替换$\omega_n$，其余的没什么差别，于是……时间复杂度还是$O(n \log n)$的! 123456789101112131415161718192021void FFT(int Lim,complex *A,int flag)&#123; if(Lim == 1) return ; complex A0[Lim &gt;&gt; 1], A1[Lim &gt;&gt; 1] ; for(int i = 0; i &lt;= Lim ; i += 2) A0[i &gt;&gt; 1] = A[i], A1[i &gt;&gt; 1] = A[i+1] ; FFT(Lim &gt;&gt; 1, A0, flag) ; FFT(Lim &gt;&gt; 1, A1, flag) ; complex unit = (complex)&#123;cos(2.0 * Pi / Lim) , flag * sin(2.0 * Pi / Lim)&#125;, w = complex(1, 0) ;//欧拉公式 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; A[i] = A0[i] + w * A1[i] ; A[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i]; &#125;&#125;int main()&#123;......................FFT(A, 1), FFT(B, 1) ;for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;FFT(A, -1) ;......................&#125; 好的，现在嘛……可以考虑撒花花啦！因为我们的$FFT$实际上已经结束了！$But$，这个递归版本的$FFT$由于牵扯到$sin/cos$的运算、$double$、递归时的入栈出栈（底层），所以常数特别的大$emmmmm$，那么—— $\rm{0x06~Iterative~ Optimization}$我们现在要引出的就是迭代版的$FFTqwq$ · $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$$emmm$先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：1234 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; a[i] = A0[i] + w * A1[i] ; a[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i];&#125; 我们会发现……$\omega \cdot A^{[1]}[i]$被执行了两次，所以我们不妨用个变量记录它：12345 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; int temp = w * A1[i] ; a[i] = A0[i] + t ; a[i + (Lim&gt;&gt;1)] = A0[i] - t ;&#125; 嗯，这就是全部的优化啦！那么，FFT，完！ $qwq$这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好$\mathcal{QAQ}$。好吧，说这个的原因，只是为了引出我们关于蝴蝶操作的定义： 我们定义$\omega_n^k$为旋转因子，那么每一次我们先将$y_k^{[1]}$与旋转因子的乘积存储在一个变量$t$里，并在$y_k^{[0]}$增加、减去$t$的操作称为一次蝴蝶操作。 说白了，蝴蝶操作是一次$O(2)$的求出$A^{[0]}_k$与$A^{[1]}_k$的操作。 我们首先考虑按照递归的思路，将$FFT$的分治流程刻画一下： 我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下： $step 1$ 成对地取出儿子节点，用蝴蝶操作计算出其$DFT$。$step 2$ 用这一步的$DFT$替换之前的；$step 3$ 直到我们迭代到根节点为止，否则返回$step 1$ 而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层$for$，先枚举区间长度（1，2，4，8……），第二层枚举长度为$j*2$的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间$DFT$的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并： 12345678910for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123;//枚举区间长度，从小区间到大区间依次合并。 node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123;//两段区间两段区间的枚举，用于合并 node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123;//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。 node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;//一次蝴蝶操作 &#125; &#125; &#125; 嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在$DFT$的时候，为了保证时间复杂度是$\Theta(\log n)$，我们曾经进行过一次$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是$0,1,2,3,4,5,6,7$，但是迭代版的$FFT$却需要的顺序应该跟叶子结点的顺序吻合，即$0, 4, 2, 6, 1, 5,3,7$。所以—— · $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$ 这个嘛……我们可以选择打个表观察：原来的序号 $0 1 2 3 4 5 6 7$现在的序号 $0 4 2 6 1 5 3 7$原来的二进制表示 $000 001 010 011 100 101 110 111$现在的二进制表示 $000 100 010 110 100 101 011 111$ 诶，二进制好像是反序的嗷~~这便是我们的最后一个$trick$，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在$FFT$之前$swap$一遍即可。 嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：1for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; 呃，这个二进制计算自己推一下就好。 那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。真开森啊 最后附迭代版的代码(我写的常数好像有点儿大$QAQ$) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define il inlineusing namespace std ;int N, M, K ;const int MAXN = 3000100 ;const double Pi = acos(-1.0) ;int i, j, k, l, Lim = 1, L, R[MAXN] ; struct node&#123; double x, y ; node (double xx = 0, double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN] ;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);&#125;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y);&#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y );&#125;il int qr()&#123; int k = 0, f = 1 ; char c = getchar() ; while(!isdigit(c))&#123;if(c == '-') f = -1 ;c = getchar() ;&#125; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48 ,c = getchar() ; return k * f ;&#125;void FFT(node *J, int flag)&#123; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ;//前面的if保证只换一次 for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125;&#125;int main()&#123; N = qr(), M = qr() ; for(i = 0; i &lt;= N; i ++) A[i].x = qr() ; for(i = 0; i &lt;= M; i ++) B[i].x = qr() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1) ; for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ; FFT(A, -1) ; for(i = 0; i &lt;= N + M; i ++) printf("%d ", (int)(A[i].x / Lim + 0.5)) ;//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 return 0 ;&#125; 啊……那就撒花花吧！！ $\rm{0x00\quad Afterword}$以下是原尾语，保留了下来： 嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短这么容易背过。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天$qwq$，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他$DALAO$比对审核、或者缠着$rqy$问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。 以下是温馨提示： 好多自己当初不理解的地方在代码里就只有半行qaq 三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的 真 · 结束语： 其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去现在看这个算法，真是简单的一匹啊，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。 $\rm{Reference}$ $[1]$ :$rvalue$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :算法导论 $^{^{[\nearrow]}}$ 提取码: txs2 [3]*：鸣谢rqy $\mathfrak{writter:pks}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式-FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想五·手中没有红玫瑰]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 今天下了一天的雪。 我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。 “情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。 雪真美啊。 var ap = new APlayer({ element: document.getElementById("aplayer-iWEgoHKG"), narrow: false, autoplay: false, showlrc: false, music: { title: "空も飞べるはず", author: "定能飞向天空", url: "古谷拳-空も飛べるはず (定能飞向天空).mp3", pic: "/2019/02/14/随想五·情人节/ggq.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 早恋？ “严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”…… 说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。 直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了： 小学五年级的时候，我喜欢班上的一个女孩子。那时候想的很多。比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。 如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。 我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。 于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。 后来初三开学，我收到了一封信。来自那个小学时候喜欢的女孩子。信的末尾有一句话：我准备报考X中，你要不要一起？ 我的手不受控制地颤抖。烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。 为什么要读书呢？16岁的我获得了唯一的答案——为了和喜欢的人在一起。我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。是啦，他们总以为自己很懂。 很多人说，小孩子不要谈感情，因为反正不会有结果。是，的确不会有结果。就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。 可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。爱过一个人，是我少年时最大的幸运。 所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。 有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。 我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。 他们轻蔑地说，小孩子懂什么恋爱。好，那我们来看看大人们有多么懂爱情。相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。 所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？ 还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。 可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？你们是真的有的是以后，还是早已离散在人海？而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？ 很久以后我们终于知道，大人都在说谎。少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。 如果有还在上学的读者看到这里，请记住，人生没有那么多以后。有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。 至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。 我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。 ” 很多人即使只见过一面，已经算见过了最后一面。“ 十八岁前不早恋，这辈子都来不及早恋。你的人生看起来很长，每一秒都无法挽回。 虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。 我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。 当然，也是给我自己讲。 关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。 现在不一样了吧，一生，多长啊。 我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。 没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。 等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？ 不，我觉得不是。 我是在亵渎一种感情，是在侮辱一个人。 爱从来都是无私地付出，而不是拼命的占有啊。 我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。 你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊， 都不过是拼命地想被爱而已。 var ap = new APlayer({ element: document.getElementById("aplayer-uAcgXcXN"), narrow: false, autoplay: false, showlrc: false, music: { title: "clammbon-ソナタ", author: "(奏鸣曲)", url: "clammbon-ソナタ (奏鸣曲).mp3", pic: "/2019/02/14/随想五·情人节/zmq.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊…… 孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。 我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。 下面是歌词： 我喜欢暖冬的太阳我喜欢初春的青草我喜欢午后的庭院和一旁发呆的秋千我喜欢仲夏的冰沙我喜欢清秋的明月良宵的夜空 漫天星辰我喜欢雨后的青蛙我喜欢山前的杏我喜欢周三的傍晚被霞光亲吻的水族馆我喜欢成群的野我喜欢凌乱的书架清风的露台远处的灯海我喜欢 走在无人的九十六号公路我喜欢 木村拓哉长长的头发我喜欢 无尽田野上奔跑的麋鹿我喜欢 外婆门前的榕树我喜欢母亲的便当喜欢父亲的胡渣我喜欢八月的夜晚还在营业的游乐场我喜欢放学的铃铛我喜欢停电的夜晚点一对蜡烛 在幽静的玄关我喜欢 城市尽头那远远的青山我喜欢 热气球飞上西边的天空我喜欢 清晨的石板路雾腾腾的早餐店 阿公的桂花糕我喜欢 每一朵暮云 每一株绿树我喜欢你，你应该，也知道我喜欢你，你应该，也知道 优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句—— 我喜欢你，你应该，也知道. 我喜欢你，你应该，也知道。 很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。 你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。 有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。 我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。 我喜欢你，你应该，也知道。 var ap = new APlayer({ element: document.getElementById("aplayer-tCLtVXcq"), narrow: false, autoplay: false, showlrc: false, music: { title: "我喜欢", author: "彩虹合唱团", url: "上海彩虹室内合唱团-我喜欢 (合唱版).flac", pic: "/2019/02/14/随想五·情人节/wxh.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？ 如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。 我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。 相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。 $19/2/14$ 本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。 那么就补一个深沉一点的结尾吧。 我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。 但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧…… 路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。 可是面对着无奈的明天的我，什么都不能做。 雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。 var ap = new APlayer({ element: document.getElementById("aplayer-TLIcALIt"), narrow: false, autoplay: false, showlrc: false, music: { title: "遇见", author: "孙燕姿", url: "孙燕姿-遇见.flac", pic: "/2019/02/14/随想五·情人节/yj.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019赛季最后的随想/NOIP2018游记·启示录]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 他看着眼前的屏幕，静静地发呆。 他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。 刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。 “希望别考期望吧，嘿嘿……”他心里这么想着。 晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。 他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。 从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。 早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$Mac$版，连硕鼠也不能用了，便只得作罢。 终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。 “大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。 看了看天空，他上了大巴车。 ”昌邑一中真大啊“这是他到这儿后的第一想法。 到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。 宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。 他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。 $\rm{Day~1}$突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。 考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。 入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。 $T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。 $T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。 $T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。 期望得分$100pts + random(0,100)+random(10,20) $ $Luogu$数据$100pts + 65pts + 15pts = 180pts$ 听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。 下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。 考挂了，他想到。 这世界上似乎就他一个不会$T2$的人。 他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。 虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。 或许他期望着明天能翻盘？ 晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。 $\rm{Day~2}$今天他没有带什么吃的。 $T1$只会$60$分，转眼去看$T2$ 写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。 $T3$连想的时间都没有。 退役了。 他很伤心。 回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。 他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。 他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。 其余的都考炸了。 初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。 他一开始也并不怎样，没啥感觉。 直到那天下午。 他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。 兴奋的他去奥赛室看成绩。 学长看错了。 他的两个同僚都是$370/380+$的样子。 只有他不到. 其他人的分数也比他高。 他大概全校第十几吧。 他感到了绝望。 本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。 他注定是失败者。 他伤心极了。 他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。 他觉得一年来，他一事无成。 或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。 他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。 他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。 期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。 这似乎是实验部该有的成绩。可是跟他没有关系。 特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。 太失败了。 太失败了。 大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。 我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。 这真是从未有过的轻松的感觉。 或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。 我感到无比的轻松。 以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。 我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。 嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。 但是其实山东没有开展$AO$的，不过我想当这个第一人。 我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。 到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。 在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。 没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。 我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好的话+强大的理解能力=rqy这个等式也是成立的。 当然，不属于我啦。 虽然现在很不甘……但是没有办法，大概这就是人生吧。 如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。 听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。 总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么： 做什么事情，都要先从自己的灵魂出发，而不是从利益出发。之类的吧。 我想引用一句（段）话，来自《本杰明巴顿奇事》： 有些人，注定可以于河边闲坐。有些人被闪电击中过七次。有些人对音乐有着非凡的天赋。有些人是艺术家。有些人是游泳健将。有些人懂得制作纽扣。有些人懂莎士比亚。有些人是妈妈。还有些人，是舞者。我们注定要失去我们所爱的人，要不然我们怎么知道他们对我们有多么的重要。 后会有期。 $\mathscr{THE~~~END}$]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笙上月Project]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%99%E4%B8%8A%E6%9C%88%2F</url>
    <content type="text"><![CDATA[准确来说这是一个$project$，专门以$art/painting$、$music$为主。 现在已经在原博客上更了两期了，因为实在懒得再去捯饬图片的事儿，于是就直接链过来好了： ArseniXC &amp; 莫奈 var ap = new APlayer({ element: document.getElementById("aplayer-RljMRMyq"), narrow: false, autoplay: false, showlrc: false, music: { title: "人啊", author: "徐佳莹", url: "徐佳莹-人啊.mp3", pic: "/2019/02/14/笙上月/rena.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>笙上月</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#536Div2の题解(E&F)]]></title>
    <url>%2F2019%2F02%2F08%2FCF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F%2F</url>
    <content type="text"><![CDATA[$0x01~~Preface$$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕 这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233 简单总结一下前面四道题$\color{red}{Link}$： A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次身败名裂XD B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树） C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。 D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞 下面两道题就好像不是那么水了qaq $0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$$\color{red}{Link}$简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。 最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。 $\mathfrak {Solution}$呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。 之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。 Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXM 233#define MAXN 100010using namespace std ;struct time_node&#123; int mark, d, w ; bool operator &lt; (const time_node &amp;T) const &#123; return w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d); &#125;&#125; base[MAXN] ; map &lt;time_node, int&gt; M_set ; vector&lt;time_node&gt;Time[MAXN] ; long long Ans ;int N, M, K, A, B, C, D, i, j ; long long dp[MAXN][MAXM] ; int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; memset(dp, 63, sizeof(dp)) ; for (i = 1 ; i &lt;= K ; ++ i)&#123; scanf("%d%d%d%d", &amp;A, &amp;B, &amp;C, &amp;D), Time[A].push_back((time_node)&#123;1, C, D&#125;) ; Time[B + 1].push_back((time_node)&#123;2, C, D&#125;) ; &#125; for (i = 1 ; i &lt;= N ; ++ i)&#123; register int tot = Time[i].size() ; for (j = 0 ; j &lt; tot ; ++ j) if (Time[i][j].mark == 1) ++ M_set[Time[i][j]] ; else M_set[Time[i][j]] &gt; 1 ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ; if (M_set.size()) base[i] = (*M_set.begin()).first ; else base[i] = (time_node)&#123;0, i, 0&#125; ; &#125;dp[0][0] = 0, Ans = dp[1][1] ; for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = 0 ; j &lt;= M ; ++ j)&#123; j &gt; 0 ? dp[i][j] = min(dp[i - 1][j - 1], dp[i][j]) : 1 ; dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - 1][j] + base[i].w) ; &#125; &#125; for (i = 0 ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$$Link$ 简单来说就是给你一个序列$F_x$的$k$项的递推法则（幂次积式递推），在认定前$k-1$项都满足$F_x=1$的基础上给定$F_n$，让你倒推出$F_k$来。 $\mathfrak {Solution}$恕我直言…这道题我考场上是不可能会的…（已扑街 首先我们观察一般形式：$$F_x = \begin{cases}1~, &amp;\rm{x&lt;k} \newline ?~, &amp; \rm{x = k} \newline \prod\limits_{j=1}^kF_{x-j}^{b_j} , &amp; \rm{x&gt;k}\end{cases}~ (\mod 998,244,353)$$ 大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个我没想出来、想出来也不会用的$Idea​$，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。 次我们选择$998,244,353​$的原根作为底数。因为原根有一个很优美的性质，就是$p​$的原根的幂次可以遍历$p​$的简化剩余系。而由$NTT​$里得到的经验，这个模数的最小原根是$3​$。 原根的基本定义：设$g$为$p$的一个原根，则满足：$$𝑔^{𝑝−1} \equiv 1(\mod p)$$$$∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$ 之后呢？之后我们就找一个函数$q(x)$，令$$g^{q(x)} \equiv x(\bmod p)$$ 目的是为了构造一个$l_x = q(F_x)$，使得等式$$g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}}( \mod p)$$成立。而比较特殊的是，因为$F_1$~$F_{k-1}$都为$1$，所以$l_i=0\quad(1 \leq i &lt;k)$ 。那么也就是说对于指数上的$l_x$满足$$l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i}( \mod p-1)$$这就是一个线性递推的形式了。 此处有个小$trick$，就是我们为了防止$l_x$过大，我们需要对它取模，此时直接依据费马小定理，取$p-1$做模数即可。 接下来是一个十分巧妙的$Idea$，我们虽然不知道$l_k$，但是我们可以知道$l_k$到$l_n$是如何变化的。观察题目性质，$$l_j = \omega_j l_k \mod(p-1)$$其中的$\omega_j$是一个关于$b_k$的常量因子。证明也比较简单，因为$l_i=0\quad(1 \leq i &lt; k) $是显然的。 那么我们只需要做一下矩阵快速幂——幂次上是$n-k$——就可以得出$\omega_n$来。而我们的$l_n$是可以通过对原根$g$求$BSGS$解得的。那么现在就是$$l_k\omega_n = l_n \mod (p-1)$$移个项可以得到$$l_k \omega_n + t(p-1)= l_n$$由于原题让求的是最小的正整数解，所以应用一下$exgcd$判一下是否有解就解决了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 108#define LL long long#define Mod 998244353using namespace std ;map&lt;LL, LL&gt; Hash ;int N, T, base[MAXN] ;LL Ft, Hn, Xs, Ans, X, Y, G ; struct Matrix&#123; LL M[MAXN][MAXN] ; void clear() &#123; memset(M, 0, sizeof(M)) ;&#125; void reset() &#123; clear() ; for (int i = 1 ; i &lt;= N ; ++ i) M[i][i] = 1 ; &#125; Matrix friend operator *(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) for (int k = 1 ; k &lt;= N; ++ k) Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - 1) ; return Ans ; &#125; Matrix friend operator +(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % (Mod - 1) ; return Ans ; &#125;&#125; ; inline Matrix expow(Matrix T, LL P)&#123; Matrix Ans ; Ans.reset() ; while (P)&#123; if (P &amp; 1) Ans = Ans * T ; T = T * T, P &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline LL bsgs(LL x, LL y, LL p)&#123; LL P = ceil(sqrt(p - 1)), Q = expow(x, -P + 2 *(p - 1), p) ; for (LL i = 1, j = 0 ; j &lt;= P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i)) return Hash[i] + j * P ;&#125;inline LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(!b) &#123;x = 1, y = 0 ; return a ;&#125; LL t = exgcd(b, a % b, y, x) ; y -= a / b * x ; return t ;&#125;inline LL qr()&#123; register LL k = 0, p = 1 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') &#123; c = getchar() ; if (c == '-') p = -1 ;&#125; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k * p ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) base[i] = qr() ; cin &gt;&gt; T &gt;&gt; Ft ; Matrix lab ; lab.clear() ; for (i = 2 ; i &lt;= N ; ++ i) lab.M[i][i - 1] = 1ll ; for (i = 1 ; i &lt;= N ; ++ i) lab.M[i][N] = 1ll * base[N -i + 1] ; lab = expow(lab, T - N), Hn = bsgs(3,Ft, Mod), Xs = lab.M[N][N] ; G = exgcd(Xs, Mod - 1, X, Y) ; if (Hn % G) return puts("-1"), 0 ; X = (X % (Mod - 1) * (Hn / G) % (Mod - 1) + Mod - 1) % (Mod - 1) ; Ans = expow(3, X, Mod) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x00\quad$后记说实话，这是第一次做整套CF的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A$~$E$都还好，但是$F$实在是……看题解都要想半天的那种……尤其是这个解离散方根的东西……哇塞恶心死了从没听说过还有这东西qaq rqy说$F$题是省选一轮的难度——虽然没说是$D$几$T$几，但我感觉他的语气不像是在说一道很难的题…… 完了，要跪了。 奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。 ​ ——（pks《春日绝句》）]]></content>
      <tags>
        <tag>BSGS</tag>
        <tag>动态规划-普通DP</tag>
        <tag>线性代数-矩阵</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lagrange Formula·拉格朗日插值法]]></title>
    <url>%2F2019%2F02%2F07%2FLagrange-Formula%2F</url>
    <content type="text"><![CDATA[拉格朗日插值公式 $\rm{Lagrange~Interpolation~Formula}$$\rm{0x01~~} Preface$插值($Interpolaton$) 在多项式域中可以看做是求值$(Evaluation)$的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。 而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明—— $\rm{0x02}~~\rm{Proof}$$Proof ~of~Existence$​ 我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。 ​ 首先我们需要构造一个对于第$i$个二元组的特殊多项式$L_i(x)$，满足$$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \newline 0, &amp; \rm{i \neq j}\end{cases}$$ 那么我们所求的多项式$F(x)​$就可以写作$$F(x) = \sum L_i(x_i)\cdot y_i​$$这个式子保证了我们对应的$n​$个二元组，$F(x)=y​$恒成立。 ​ 那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出$$L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)$$其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数$$k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}$$那么$$L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$从而$$F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$ $\mathcal{Q.E.D.}$ $Proof~of~Uniqueness^{[1]}$​ 我们接下来要证明的是多项式$L_i(x)​$的唯一性 ​ 我们假设同时有两个实数域上的$n-1​$次多项式$L_1(x),L_2(x)​$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}​$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2​$在取所有的$x_i​$时，其值均为$0​$。那么一定会有多项式$$L’(x) = \prod\limits_{i=1}^{n}(x - x_i)​$$满足$$L’|L_{\Delta}​$$ 其中$|​$表示多项式整除。但是我们知道，对于$L’​$这个多项式，其次数为$n-1​$；而对于我们所定义的$L_i(x)​$，均为$(n-2)​$次的，从而$L_{\Delta}​$也是$n-2​$次多项式。所以我们可以得出$$L_{\Delta} = 0​$$从而有$$L_1=L_2​$$ $\mathcal{Q.E.D.}$$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$1234567891011121314151617181920212223242526272829303132333435363738题号：Luogu4781#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 2020#define LL long long#define Mod 998244353using namespace std ; LL Ans, xs ;int N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;inline LL expow(LL A, LL B)&#123; LL res = 1 ; while (B)&#123; if (B &amp; 1) (res *= A) %= Mod ; B &gt;&gt;= 1, (A *= A) %= Mod ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld%lld", &amp;xv[i], &amp;yv[i]) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; t = 1 ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (xv[i] - xv[j] + Mod)) %= Mod ; &#125; t = expow(t, Mod - 2) ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (T - xv[j] + Mod)) %= Mod ; &#125; (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;// cout &lt;&lt; Ans &lt;&lt; endl ; &#125; printf("%lld", Ans) ; return 0 ;&#125; $\rm{Reference}$ $[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 $^{^{[\nearrow ]}}$ $\mathfrak{writter:pks}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Math - Lagrange Formula</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群论入门]]></title>
    <url>%2F2019%2F02%2F06%2F%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面：群作为抽象代数领域中比较基础的一环，同时也是沟通初等代数、初等几何与抽象代数的桥梁，着实打开了笔者的眼界。此篇blog旨在泛泛谈一些比较基础的群论内容，包括群的基本定义，子群的概念，阶的概念等等，不存在较为艰深的内容。 群$1~)~$群的定义比较简单的来讲，所谓群$(\rm{group})$指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质： 我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算： $Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$那么也就是说的直白点吧，对所有的元素，做完该群所带有的带有结合律的运算之后，所得结果仍然属于该群且一定存在单位元，对于每个元素存在运算逆元。 那我们不妨定义一些其他的： 阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。 半群：满足封闭性和结合律的群。 有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶 结合几个例子来解释一下： 比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)​$$ $$(R\setminus{0}~, ~\cdot)​$$$$ (C\setminus{0}~,~\cdot)​$$ 他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。 或者一个好玩儿的乘法群$$((1, -1)~~, ~~\cdot)$$或者是所有非奇异的$n$阶矩阵也可以组成一个乘法群。 或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断是否成群,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。 $Extra Things :$ 以下是两种复合抽代数据结构（名字自己起的$233$）： 环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。 域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群举例子 ：$Q,R,C$即有理数域、实数域和复数域。 好的，那我们尝试证明两个命题： $Proposition1~~~~$一个群中的单位元唯一设有两个单位元$e_1,e_2$ 那么$e_1=e_1e_2=e_2$，其实是一个$233$ $Proposition2~~~~$群中元素的逆元唯一以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$ 显然也是同一个。 那么此时我打算整理一个群的共性特征：$$(ab)^{-1}=b^{-1}a^{-1}$$ 很显然，证明如下：$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$ 提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心 那么之后我们讨论周期 对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$ $o(a)$表示最小正整数，使得$a^{o(a)}=e$ $2~)~$子群及衍生本节所指“群”没有特别说明便均为有限群 不妨先给出子群的浅显版定义： 如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示那么从而我们可以定义生成子群这个东西： 生成子群：若$S \subseteq G​$， 并且对于运算$C​$而言，$(G,C)​$也是一个群，那么就称$G​$为集合$S​$在运算$C​$下的生成子群。集合$S​$的生成子群用$&lt;​$$S​$$&gt;​$表示 这之后我们就可以定义陪集这个概念 陪集一般上包含左陪集和右陪集。 左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。$233$也可以叫做傍集或者旁系之类的~ 那么我们这个地方先只研究右陪集$233$ $Lemma1:$我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的群中元素数量。 这个其实比较显然，因为事实上群都是定义在非可重集上面的。 较为严谨的证明如下： $Proof.$ 对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$ 反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾 对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$ $Lemma2:$之后我们再证明一些好玩儿的： 命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ 看起来好像不是那么好玩…… $Proof.$ 若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$ 若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$ $hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$ 因此$H_a=H_b$ 那么我们还可以有一个推论： 若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$ $Proof.$ 假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾 从而还可以有个定理（$Lagrange$定理）： 由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么 $$|G|=|H|\cdot [G:H]$$ 也就是说$|H|$是$|G|$的约数。 这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。 但是其实这是个很伟大的定理$233$ 好的，那么从而就会有一些神奇的推论： 推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ $Proof.$ 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ 推论二：对任意的$a \in G,a ^{|G|} = e$ $Proof.$ 比较显然，由推论一可知。 推论三：若$|G|$为素数，则$G$是循环群 $Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。 接下来我们真的要去做些好玩的了~ 定理$1$·$Fermat$小定理如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $ $Proof. $考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知： $$\forall a\in G, a^{p-1}=1(\mod p)$$ 定理2·$Euler$定理$a^{\phi(n)}=1 (\mod n)$ $Proof.$考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法 那么会有$|G|=\phi(n)$，从而有： $$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$ 没错，证明十分的简洁美观。 作者被这种神奇的证明给折服了$stO$.]]></content>
      <tags>
        <tag>抽象代数-群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS-Junior·BSGS算法初探]]></title>
    <url>%2F2019%2F02%2F06%2FBSGS-junior%2F</url>
    <content type="text"><![CDATA[$BSGS$$\rm{0x01}$ $\mathcal{Preface}$$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法。当然也会被叫做拔山盖世、北上广深算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : 给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x$, 使得$a^x≡ b~(\mod p)​$而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)​$，并且我们还知道$a^0=1≡1 ~(\mod p)​$，所以我们可以得出一个断言： 如果方程$a^x≡ b~(\mod p)​$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))​$中 $\qquad \qquad(1) ​$ 此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。 之后我们将以此为基础进行类似分块的操作—— $\rm{0x02~~Baby~Step~Giant~Step}$首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：$$a^{i\cdot n+j}≡ b~(\mod p)$$移一下项就可以变成$$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$$那么现在我们的策略是算出所有$a^j$来，在$\mod p$ 意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做小步$(\rm{Baby~Step})$， 称右边枚举$b \cdot a^{-i\cdot n}$叫做大步$~(\rm{Giant~Step})$。 那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。 123456789101112131415161718inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "-1" &lt;&lt; endl ;&#125; 其中细节还是有的： 计算sqrt时要上取整。 我们在求$a^{-i\cdot n}​$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。 两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$ 算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的Q就会=0，从而在下面的第二个循环处出错——我们的hash[i]和j不能同时为$0$，从而输出错误的答案。 $\rm{0x03}$ 例题$T1~$$LuoguP4028$ 裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;tr1/unordered_map&gt;#define LL long longusing namespace std ; using namespace tr1 ; int T ;LL A, B, M, P, Q ; unordered_map &lt;LL, LL&gt; Hash ;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ;&#125;inline LL qr()&#123; LL res = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res ;&#125;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; M = qr(), A = qr(), B = qr() ; if ((!(A % M == 0 &amp;&amp; B))) bsgs(A, B, M) ; else cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ; &#125; return 0 ;&#125; $T2~$ $TJOI2007~Cute~Prime​$ 最裸最裸的、无特判的题……可以水一下双倍经验。 $\mathfrak{writter: pks}$]]></content>
      <tags>
        <tag>BSGS</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT's Junior Intro]]></title>
    <url>%2F2019%2F02%2F04%2FLCT-s-Junior-Intro%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护森林连通性的。 嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。 但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转$Luogu3391$，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。 也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。 $\rm{0x02}$ 闲话 · 关于$\rm{splay}$道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢 历史的重任最后落到了$\rm{splay}​$的身上。然后$\rm{splay}​$他居然： 他甚至还： …… 好吧，由于某些rqy也不知道的原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$ $\rm{0x03}$ $LCT$的思路和基础操作一 主要思路主要思路嘛……大概是基于实链剖分的操作。 朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。 而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。 实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。 那么接下来我们来看一个$LCT​$是如何定义的: 首先，一棵$LCT​$管控的是一对分散的点，点以几棵分散的$splay​$的形式聚集。起初整棵$LCT​$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access​$、$makeroot​$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT​$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。 实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别： 虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。 实边是完整的双向存储。 $\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。 如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱. 二 基础操作$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作，我们这个地方先把点$n$所在联通块儿内的树的根记作$root(n) $，把与$n$以实边相连的儿子记作实儿子。 $\rm{1}$ $Access$ 这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是$Access(n)$表示从$root(n)$向$n$打通一条实链，并以$n$点为最深度最大的点、$root(n)$为深度最小的点形成一棵$\rm{splay}$。 不难看出，这个操作其实跟是一种逻辑层面的自我调控，没有改变原树的结构。 我们思考，如果此时我们$Access​$完点$n​$之后，理论上来讲，$n​$点应该不再有实儿子了——显然，如果有实儿子的话，$splay​$中是应该包含这个实儿子的——而这就不符合$n​$是$\rm{splay}​$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}​$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}​$连上。 1234inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125; 然后这就是$Access​$了。 $2 ~~Make~ Root~$ $make_root​$先从原来的根向$n​$打通一条路径，然后$splay​$上去，最后$reverse​$一下。此处由于一开始$n​$的深度最大，$splay​$之后深度依旧最大，但此时$n​$是$splay​$的根，所以$reverse(n)​$就相当于翻转了整条树上的链，那么翻转之后，$n​$的深度就变成了最小，于是就是这个联通块儿的根节点了。 1234567891011121314151617181920#define lc T[x].Son[0]#define rc T[x].Son[1]struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; inline void splay(int x) ;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void splay(int x)&#123;int qwq = x ; stk.push(qwq) ;while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;while(!stk.empty()) push_down(stk.top()), stk.pop() ;while(check(x))&#123;int fa = T[x].F, g_fa = T[fa].F ;if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125;&#125; 此处$splay$中由于要下放标记，保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。 $3 ~Merge~$ 此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。 1inline void Merge(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125; $4~~Link~\&amp;~Cut$ 如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。 12inline void Link(int x, int y)&#123; Rooten(x) ; T[x].F = y ;&#125;inline void Cut(int x, int y)&#123; Merge(x, y) ; T[x].F = T[y].Son[0] = 0 ;&#125; 此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。 但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作…… $New-Link$ 12inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125; 此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233 但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。 多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根 $New-Cut$ 12345inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125; 此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。 之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$Depth(x) &lt; Depth(y\text{的左儿子们}) &lt; Depth(y)$，其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。 剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。 5 $~Rotate$中的坑点 呃……其实就一处而已。就是： 123456inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void rotate(int x) &#123; int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125; 这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g_fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$ 剩下的……大概就没了吧…… 于是—— $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 300233#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)using namespace std ;struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; stack &lt;int&gt; stk ;int base[MAXN], N, M, A, B, C, i ;inline int Find(int x) ;inline void splay(int x) ;inline void push_down(int x) ;inline void update(int x) &#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;inline void rotate(int x) &#123;int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125;inline void splay(int x)&#123; int qwq = x ; stk.push(qwq) ; while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ; while(!stk.empty()) push_down(stk.top()), stk.pop() ; while(check(x))&#123; int fa = T[x].F, g_fa = T[fa].F ; if (check(fa)) &#123; rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ; &#125;&#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void split(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125;inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; rep(i, 1, N) scanf("%lld", &amp;base[i]) ; rep(i, 1, M)&#123; scanf("%d%d%d", &amp;A, &amp;B, &amp;C) ; if (A == 0) split(B, C), printf("%d\n", T[C].S) ; else if (A == 1) Link(B, C) ; else if (A == 2) Cut(B, C) ; else splay(B), base[B] = C ; &#125; return 0 ;&#125; $\rm{0x00}$ 后记和参考可写完了……嗝……打个肥宅嗝犒劳犒劳自己 怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨…… 写博客真是一个陶冶情操的过程啊……包括做表情包 加油吧，$pks$！ $\rm{Reference}$ $[1]$ :$Flash_Hu$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :某篇论文，结合食用效果显著 $^{^{[\nearrow]}}$ $\mathfrak{writter:pks}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>LCT-Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intro]]></title>
    <url>%2F2019%2F02%2F04%2FIntro-1%2F</url>
    <content type="text"><![CDATA[Hello, here is Orchidany, a high-school student from S.D., China. Algorithms, astrophysics, technology, that’s what I love. Perhaps sometimes I‘m fond of painting, music and modern art appreciation. Anyhow, recently my first mission is Olympiad in Informatics，shorthanded for OI. And this blog is mainly gonna to record my Learning Steps. Although I’m a bit weak in OI by now, but I shall catch the glimmer and keep getting stronger! During daliy lives, I shall also write some about my own emotion, music &amp; art…it seems like I’m a chairwamrer in OI hhhhh… See you soon in my articles ! Somthing Special Errr…About this ID _Orchidany_, there is a theory about that: My Chinese Id is 皎月半洒花， which is from the poem (Writter is myself) : 鹃住落英满，柳拂溪畔沙。南城略炊烟，浣女徐归家。故人今安否，欲歌口偏哑。笔寒下梅去，皎月半洒花。 So……I’ m glad to encounter you!]]></content>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流2·HLPP+丧心病狂的优化]]></title>
    <url>%2F2019%2F01%2F11%2FHLPP%2F</url>
    <content type="text"><![CDATA[$\mathfrak{HLPP}$嗯，我也不知道我在月考即将爆炸 + $NOIp$即将爆炸之际，学$HLPP$的目的何在$\rm{TAT}$。 #define $u$的伴点集合 与$u$相隔一条边的且$u$能达到的点的集合 $0x00~ {}~Preface$ $HLPP(Highest~Label~Preflow~Push)​$最高标签预流推进算法是处理网络最大流里两种常用方法——增广路&amp;预流推进中，预流推进算法的一种。据传由$tarjan​$发明怎么又是他 ，并被其他科学家证明了其复杂度是紧却的$O(n^2\sqrt m)​$。在随机数据中不逊色于普通的增广路算法，而在精心构造的数据中无法被卡，所以是一种可以替代$Dinic​$的方法（随我怎么说，代码又长又难调，所以还是$Dinic​$好啊$\rm{TAT}​$） 但无论怎样，$wiki$里面已经承认$HLPP$是现在最优秀的网络流算法了。 那么预流推进这个大门类里面，思想都差不多。大抵上就是我们对每个点记录超额流($Extra~Flow$) ，即允许流在非源点暂时存储，并伺机将超额流推送出去。不可推送的，就会流回源点。那么最终答案显然存储在$Extra[T]$里面。 但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用最高标号的策略，给每个点一个高度，对于一个点$u​$以及它的伴点集合${v}​$，当且仅当$h_u = h_v + 1​$ 时才可以推送流。并且我们对于源点$S​$，设置$h_S = N​$，并对于$S​$实行无限制推送。那么最后的答案就保存在$Extra[T]​$里面 。 但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑拔高它的高度，即重贴标签($relabel​$)操作。 $0x01$ 初步的算法流程以下我们用$Extra_u$表示$u$的超额流，$h_u$表示$u$的高度，用$f_k$表示边$k$的容量。 首先把所有的$h_i$都置为零，并把$h_s$置为$N$（点数）。 将$S$的流推送到每个与$S$相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。 对于点$u$推送过程中，如果$Extra_u$减到了$0$，就立即退出（优化一） 对于每条出边$k$，推送的流量$F = min(f_k,Extra_u)$并执行两个点（$u,v$）的超额流增减。如果$v$不在堆里面，要把$v$放到堆里面。 如果推送完毕$Extra[u]$不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度$h_{min}$，则新的$h_u = h_{min}+1$，并把$u​$入堆。 好的，然后就可以撒花了……可是等等，他怎么这么慢$qaq$ 接下来我们发现，重贴标签的过程似乎与$ISAP$有点点像……所以我们不妨通过一个$Gap$数组来记录”断层情况“：即如果对于一个点$u$来说，他的伴点集${v}$已经不存在$h_u = h_v + 1$的点了，并且也不存在一个点$j$使得$h_j = h_u$那么这个地方就是一个断层$(Gap)$ ，那么也就是说，对于所有$h_i&gt; h_u$的点来说，它们把流推送到$h_u$的高度就不能继续推送了，所以我们直接$h_i = N + 1$，让他们回流到源点。（优化二） 接下来这个优化，亲测可以提速$4000ms​$，平均每个测试点提速$700​$ ~ $800ms​$，去掉数据最小的点，每个点平均提速$1000ms​$。这就是——$BFS​$! 我们不妨一开始就倒着$BFS$一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度（源点高度还是$N$。嗯，$Mr_Spade$大佬实在太强了$qwq$ 对了，代码实现方面，需要好多判断不是源点和汇点的小细节……无路赛无路赛无路赛$&gt;_&lt;$！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//省略某些部分#define Inf, MAXN, MAXM, to(k)struct state&#123; int num, h ; bool operator &lt;(const state &amp; now) const&#123; return h &lt; now.h ; &#125;&#125; ; priority_queue &lt;state&gt; heap ; BFS init ;int N, M, S, T, cnt = -1, A, B, C, D, t, min_h ;int head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;inline void Preflow_Push()&#123; register int i, k ; for (i = 1 ; i &lt;= N ; ++ i) if(H[i] &lt; Inf) ++ Gap[H[i]] ; for(k = head[S]; k != -1 ; k = E[k].next) if((t = E[k].f))&#123; E[k].f -= t, E[k ^ 1].f += t, Extra[S] -= t, Extra[to(k)] += t ; if(to(k) != T &amp;&amp; !vis[to(k)]) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; while(!heap.empty())&#123; vis[node = heap.top().num] = 0, min_h = Inf, heap.pop() ; for(k = head[node] ; k != -1 ; k = E[k].next)&#123; if(E[k].f &amp;&amp; H[node] == H[to(k)] + 1)&#123; t = min(Extra[node], E[k].f) ; E[k].f -= t, E[k ^ 1].f += t, Extra[node] -= t, Extra[to(k)] += t ; if(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; if (E[k].f) min_h = min(min_h, H[to(k)]) ; if (!Extra[node]) break ; &#125; if(Extra[node]) &#123; if (!--Gap[H[node]]) for(i = 1; i &lt;= N ; ++ i) if(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + 1) H[i] = N + 1 ; H[node] = Inf; H[node] = min_h + 1 ; heap.push((state)&#123;node, H[node]&#125;), vis[node] = 1, ++ Gap[H[node]] ; &#125; &#125;&#125;inline int read() &#123;fast;&#125;int main()&#123; Input() ; for (i = 1 ; i &lt;= N ; ++ i) head[i] = -1, H[i] = Inf ; while(M --)&#123;Add; &#125; q.push(T), H[T] = 0 ; while(!q.empty())&#123; int now = q.front() ; q.pop() ; for(k = head[now] ; k != -1 ; k = E[k].next) if (H[to(k)] &gt; H[now] + 1) H[E[k].to] = H[now] + 1, q.push(E[k].to) ; &#125; if (H[S] == 0) &#123;cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ;&#125; H[S] = N, Preflow_Push() ; cout &lt;&lt; Extra[T] &lt;&lt; endl ;&#125; 看起来我们加上下面这一句话的毒瘤卡常就可以有$4000ms$左右的好成绩，但事实上，这个速度依旧慢的要死。 注意！这个写法是经典写法，其时间复杂度是紧却的$\boldsymbol{\rm{\Theta(n^2mlogn)}}$的，也就是说在$\boldsymbol{n=1200}$时会带一个$\boldsymbol{10}$倍的常数 怎么优化呢—— $\boldsymbol{0x02~~Optimization}$各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）…… 来，我们首先思考思考普通的HLPP到底会慢在哪里： $STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！ 每次$Gap$优化，我们的时间复杂度是紧确的$\Theta(n)$。的这显然不合算，因为假设我当前的$\boldsymbol{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会浪费$\boldsymbol{\Theta(n)}$的时间。 事实上…普通的$HLPP$代码并不长，主要问题就是这两个。 我们考虑，如果不用堆的话怎么做呢？ 呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，高度函数$\boldsymbol{H(x)}$和点数集大小$\boldsymbol{N(x)}$是广义同阶的。 换句话说，我们可以考虑从高度入手。 换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\boldsymbol{O(n)}$而不是$\boldsymbol{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。 那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。 也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333 hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。 好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花… 哦对，还有几点我debug的时候被坑死的点： 那个$Iterator$类型的$vector$对象是点的编号不是高度！ 注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质wrnm，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$ (我觉得写的很难看但是有注释qaq)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//writter:Orchidany(pks)#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")//sb毒瘤优化#define MAXN 10030#define min my_min#define BG begin()#define gc getchar#define rr register #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;//list，就是快（//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; /*vector存边（据说会快）*/vector&lt;List::iterator&gt; Era_pos ; //辅助定位+删除inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;//黑科技inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = gc() ; while (!isdigit(c)) c = gc() ;while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = gc() ; return k ; &#125;inline void Init_label()&#123;//等价于一开始的那个BFS，只执行一次 rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; H.assign(N + 1, N + 1) ; H[T] = 0 ; q[t ++] = T ;//从T（高度小的）向前标号 while (h &lt; t)&#123;//队列……BFS……真熟悉啊……嗝…… rr int now = q[h] ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == N + 1 &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + 1, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N + 1) Set[i].clear(), Gap[i].clear() ;//还是清空一下比较好吧 rep(i, 0, N) if (H[i] &lt;N + 1) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), //疑似insert函数的返回值是一个指针qaq (Extra[i]&gt;0) ? Set[H[i]].push_back(i) : eggs() ;//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同… max_H = now_H = H[q[-- t]] ; //更新，BFS的性质，最后一个元素一定高度最大（除了源点）&#125;inline void Push(int x, Edge &amp;e)&#123;//单独写出来的push函数，好像很方便？ rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into "heap"&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0)//如果可以流 if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123;//如果出现断层了 for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)//这个gap的for肯定比O(n)优秀 for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; /*断层以上的高度都没用了*/return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; //重贴标签操作，为当前点删除原来的高度 ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;//增添新的高度&#125;inline int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt.assign(N, 0), cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] =- INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; //下面源点要单独拿出来推送，因为源点推送时高度差不需要=1. Init_label() ; //初始化（BFS） while (now_H &gt;= 0) //正式开始HLPP（泪目） if (Set[now_H].empty()) now_H -- ; //高度递减，实现一个堆的效果 else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ; return Extra[T] + INF ;&#125;int main()&#123; N = qr(),; rr int i ;//下面的++N是为了日后好操作qaq rep(i, 1, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125; 下面是个$fread$卡常版本$qaq$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#define MAXN 1202#define min my_min#define BG begin()#define rr register#define swap my_swap #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;const int ch_top=4e7+3;char ch[ch_top],*now_r=ch-1,*now_w=ch-1;inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x;&#125;inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w='\n';&#125;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; vector&lt;List::iterator&gt; Era_pos ; inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline void Init_label()&#123; rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; rr int qaq = N + 1 ; H.assign(qaq, qaq) ; H[T] = 0 ; q[t ++] = T ; while (h &lt; t)&#123; rr int now = q[h], qwq = H[now] + 1 ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == qaq &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = qwq, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N - 1) Set[i].clear(), Gap[i].clear() ; rep(i, 0, N - 1) if (H[i] &lt; N) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] &gt; 0) ? Set[H[i]].push_back(i) : eggs() ; max_H = now_H = H[q[-- t]] ; &#125;inline void Push(int x, Edge &amp;e)&#123; rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into heap&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0) if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123; for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i) for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;&#125;int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; cnt.assign(N, 0) ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] = -INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; Init_label() ; while (now_H &gt;= 0) if (Set[now_H].empty()) now_H -- ; else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;return Extra[T] + INF ;&#125;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read(), S = read(), T = read() ; rr int i ; rep(i, 1, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,1,now_w-ch,stdout) ;&#125; 撒fa~$0x03~~$后记 这道题的经典版本好几个月之前我写了一天……然后今天又翻出来，发现了巨佬KevinYu抛了一个玉，我就打算优化一波……毒瘤啊，什么$vector$存边、$list$我都是第一次用呜呜…… 不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） 最后，人艰不拆，人艰不拆… $\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>目测用不到的算法之HLPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想四·故人今安否？]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 最近初三的小朋友们生龙活虎地来了，虽然没有什么深入的交流，但是其身上洋溢着的青春，确是我辈所比不了的。 是啊，一年了啊。 去年这个时候，我们也是这样意气风发的吧？听说今年的“小班”（初三来的实验班），信竞有12个人，和去年一样。换句话说，和我们一样，只不过他们这一级女生有四个，我们只有一个而已。 真像啊。 $\rm{0x01}$ 结束比我想象的要早，早好多，好多好多。 我退役了，虽然是本赛季退役。 我仿佛从来没有考虑过这件事情，18年的2月、3月、4月……甚至一直到8月，我都一直以我仍然初三、仍然未升上高中而自豪。我们是有生力量里面最年轻的一代，我们开口$Splay$、网络流、$Tarjan$，闭口莫队、$A-star$、替罪羊，我们研究各种奇妙的算法，我们刷各种三倍经验，我们酒入豪肠酿成三分月光，我们春风得意马蹄疾—— 我们年轻啊。 恍如隔世，考完$Noip$或许才真正知道自己几斤几两。 我悔恨，我懊恼，我痛苦，我不甘。我终于也变成了只能孤注一掷在高二出成绩的老年人。我或许什么都没少，只不过少了一次计划；但我或许已经一无所有——我的时间没有了。 我曾经认为考省一应该不算多难，结果现实重重地给了我一闷棍，厉喝道：这就是现实的力量。 或许几个月之前，或者说，从考完Noip到现在，我的所有负面情绪表现出来的都是消极、沉默、颓废，而直到今天，我看着窗外空旷的操场、不燥的微风，我看着天边徘徊的流云——我只想哭，声嘶力竭地、歇斯底里地哭。 我只想哭。 $\rm{0x02}$ 故人最近晚眠前，常会想起初来实验部时的同僚们：]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流1·Dinic&费用流]]></title>
    <url>%2F2018%2F08%2F20%2Fnet-work-flow%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[网络流1·$Dinic\&amp;$费用流$0x00~ {}~Preface$$2333$这是好久之前学的了，不过一直在咕咕咕咕。 一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。 那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。那么，我们定义容量为$c(u,v) \in E ? c(u,v) : 0​$。在整张图中有一个源点和一个汇点，且对于每个点来说有$$\sum F_{in} = \sum F_{out}​$$并且我们人为的将$S​$的$F_{in}​$设置为$0​$，$F_{out}​$设置为$+\infty​$。$T​$正好相反。当然，如果非说不合适的话，可以将源点和汇点看做同一个点233. 通过线性规划我们可以证明的是最大流等价于最小割，而博主现在对线性规划还只是一知半解，等什么时候“贯通了”再整理博客吧233 好的，窝觉得定义什么的可以不说了，我们直接上$EK$ $0x01~$ 不知道可以用来干啥的$EK$其实，$EK$身为大家眼中的$basis$算法，他居然是比$Dinic$晚发表的……$233$ 全程是$Edmond-Karp$ ,由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，是个比较没用的算法 他的原理就是，我们通过两个杀器来实现最大流： $Killer1:$增广路 这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。 $Killer2:$ 反向边 虽然图集与解是单射的逻辑关系，即虽然对于同一张图$G(U, V)$无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从$T$连向$S$的，等同于原来没反向边时的情况。 嗯，那么我们程序实现的时候，大概就是这样 12345678910111213141516171819202122232425bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125; 其中$Last$记录前驱，$dis$就是个$mark$，$_F$数组记录增广路上最大的流量 。 那我们接下来分析复杂度。值得注意的是，$EK$由于采用$BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}++$），所以在每条边都作为残量最小值增广一次之后（至多$m$次）最短路就会增加。而最短路最多从$2$增到$n$，所以最多增广$n \times m$次。而每次$bfs$至多是$\Theta(m)$的，所以总复杂度上界是$\Theta(nm^2)$ 但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以$EK$可以解决朴素的最大流问题。 全部的代码存档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ;&#125;e[MAX &lt;&lt; 1] ;int MAX_F, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; endl ; return 0 ;&#125; $0x02$ 据说可以拯救世界的$Dinic$那么接下来我们说$Dinic$，这个算法是由$Dinic$教授创造的$qwq$ 然后$Dinic$在$EK$的基础上，采用了两个新的优化方案： $Case1:$分层图 每次我们选择用$bfs + dfs$去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用$dfs$遍历这张增广网。 $Case2:$当前弧 我们依仗的是这一段（句）代码： 1for(int &amp;i=cur[now];i!=-1;i=line[i].nxt) 其中比较重要的是引用符号，此处引用的目的是不断更新$cur$，达到不重复枚举的目的。 那么整体代码就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;queue&gt; #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ; &#125;e[MAX &lt;&lt; 1] ; int A, B, C, i ;int head[MAX], cnt = -1, now, cur[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool bfs()&#123; queue&lt;int&gt; q ; fill(dis, dis + N + 23, 0) ; q.push(S), dis[S] = 1 ; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if (!dis[e[k].to] &amp;&amp; e[k].v) dis[e[k].to] = dis[now] + 1, q.push(e[k].to) ; &#125; &#125; return dis[T] ? 1 : 0 ;&#125;int dfs(int St, int Aim, int Flow)&#123; if (St == Aim || !Flow) return Flow ; int Fl, res = 0 ; for (int &amp;k = cur[St] ; k != -1; k = e[k].next) if (dis[e[k].to] == dis[St] + 1 &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123; res += Fl, e[k].v -= Fl, e[k ^ 1].v+= Fl ; Flow -= Fl ; if (!Flow) break ; &#125; return res ;&#125;int Dinic()&#123; int res = 0 ; while(bfs())&#123; for(i = 1; i &lt;= N; ++ i) cur[i] = head[i] ; res += dfs(S, T, 0x7fffffff) ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; cout &lt;&lt; Dinic() ; return 0 ;&#125; 嗯，那么我们不难看出$cur$其实就是为了防止我们不断重复枚举边。因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走。而复杂度没有变，但是确实会更快。 那么接下来证明一下$Dinic$的时间复杂度。 根据分层图而言，$t$的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有$n$次重新分层。而对于每次在增广网上的操作，至多有$m$条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共$O(2n)$的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。 很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。 据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。 最后我们来说一下费用流。 $0x03$ 费用流（最小费用最大流）其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把$EK$的$bfs$换成$SPFA$就行了233 至于为什么不能$dinic$，很显然是因为没法分层啊……$hhh$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v, c ;&#125;e[MAX &lt;&lt; 1] ;bool mark[MAX] ; int MAX_F, MAX_C, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w, int c)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool SPFA()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, Inf) ; fill(mark, mark + N + 1, 0) ; q.push(S), dis[S] = 0, mark[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; mark[now] = 0 ; for (int k = head[now]; k != -1 ; k = e[k].next) if (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123; dis[e[k].to] = dis[now] + e[k].c ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; if(!mark[e[k].to])&#123; q.push(e[k].to) ; mark[e[k].to] = 1 ; &#125; &#125; &#125; return dis[T] != Inf;&#125;void _EK()&#123; while(SPFA())&#123; now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt;" "&lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125; 但是$SPFA$他，他他他他他已经死在了$NOI2018$…… 那么我们考虑是否能用$dijkstra$来做。那我们要考虑的就是负权边，因为我们建的反向边是要把代价也跑回去的啊，所以我们致力于解决负权边问题。$rqy$当时是这么给我们讲的： 考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。 那么我们从点$S$到点$B$点的距离便从$dis_B$变成了$dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。 下面我们思考到底要选取什么作为势函数呢？ 我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的： 这为什么是对的呢? 考虑一条边 $u→v$ ，费用为 $c$ 。 如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 于是我们现在可以用 $Dijkstra$ 增广，很快而且更难卡( 至于代码，大概长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100010#define Inf 192608170using namespace std ;struct edge&#123; int to, next, c, f ;&#125;e[MAX &lt;&lt; 1] ; int H[MAX], S ;int dist[MAX], _F[MAX], Pre[MAX], i, k ;int N, M, A, B, C, D, cnt = -1, x1, x2, head[MAX] ;struct node&#123; int dist, num ; bool operator &lt;(const node &amp; now) const&#123;return dist &gt; now.dist ; &#125;&#125;; priority_queue&lt;node&gt; q ; bool vis[MAX] ; int Last[MAX], MAX_F, MAX_C, t, ww ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void Add(int u, int v, int f, int c)&#123; e[++ cnt].to = v, e[cnt].f = f ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].f = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool dijkstra()&#123; for (i = 1 ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = 0 ; q.push((node)&#123;0, S&#125;) ; dist[S] = 0 ; while(!q.empty())&#123; node now = q.top() ; q.pop() ; while(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop(); x1 = now.num, x2 = now.dist ; if(vis[x1]) continue ; vis[x1] = 1 ; for(k = head[x1] ; k != -1 ; k = e[k].next) if (e[k].f &gt; 0 &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123; int T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ; _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ; &#125; &#125; return dist[t] &lt; Inf ;&#125;inline void _EK()&#123; while(dijkstra())&#123; ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ; while(ww != S) e[Last[ww]].f -= _F[t], e[Last[ww] ^ 1].f += _F[t], ww = Pre[ww] ; for (i = 1 ; i &lt;= N ; ++ i) H[i] += dist[i] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ; for (i = 0 ; i &lt;= N ; ++ i) head[i] = -1 ; for (i = 1 ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; " " &lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流-最大流</tag>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想二·丘吉尔]]></title>
    <url>%2F2018%2F08%2F08%2F%E9%9A%8F%E6%83%B3%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 啊……还有几十天就$NOIp$了啊…… 现在是下午四点，机房。 比我弱的都在颓废，比我强的都在做题。 唯独我在写博客。 我在想些什么呢？ 我是$pks$，没错，我不敢称自己为$Flower_pks$，不敢称自己为“花”，因为这跟我实力不符——我不是那个在$Luogu$这个$OJ$上小有名气的大佬，不是那个题解写得十分详细的作者，更不是$SD$集训里面排的上号的人。 没错，我不配啊。 上午$rqy$出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。 旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。 撇过头来看键盘上发着光的$w$键，突然有种想哭的欲望。 我是真弱啊。 $NOIp$现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。 我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕…… 但我什么也没有。我也不是个富有毅力的人。 我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。 我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。 估计是我什么都不适合吧。 其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。 这种人强到让我厌恶。也让我悲哀。 好啦好啦你强好啦……我滚粗好了吧…… 我并不是很服气，但是现实却总是不尽人意。 过去我一直能依靠着的、可以包容我的人已经与我一别两宽了， 估计以后也只能靠自己了吧。 我并不知道为什么我要选择承受这么多，大概是天性使然吧。 我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。 二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。 路在哪呢……]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想一·杨柳岸晓风残月]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E6%83%B3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 我是花，来自山东，今时今日写下这一篇，只是为了给并肩的$Oiers$一个不算多美的故事，为了给后来的$Oiers$一个对未来有所期望的愿景。 看着眼前发黄的电脑屏幕，不知道该说些什么。 现在的我即将高一，有着比较厉害的学长，和什么都不会的教练，每天来机房就是刷题-&gt;不会-&gt;刷题-&gt;不会。 大概我马上就要习惯了吧。 闷热的八月让人有一种说不出的惆怅，大概是初中毕业旧事未了，或者是即将$NOIp$但却并没太大信心，或者是教练总是给出不尽人意的安排打乱计划。 我捏着手边新换上的眼镜腿儿，默默地想到。 我依稀记得几个月前的快乐场景：每天都在学新算法、不亦乐乎地学、废寝忘食地学。最讨厌做模拟题、玛丽题或者搜索题。最喜欢去学习新的算法，所以导致我整天刷模板题：线段树、$Splay$、$LCA$……偶尔会兴致盎然地发几篇题解，也总是会用最生动的语言，盯着$luogu$的$markdown$那方小小的编辑框，一个字一个字地码着。二月的培训让我觉得是最有意义的一次培训了，大多数精致的$blog$都出自那时。一般都是回到宾馆后，开始联机颓废，等到半夜凌晨开始写博客，写到鱼肚泛白或者困意袭来才罢休。 可真是让人高兴的回忆啊…… 回想这几个月，变化是日新月异的——就如同把一颗小小的石子扔进一池静水，起初不见多大声势，静候才可见其早已涤荡了半池——是波纹展开了。一开始来这儿，是实力悬殊的——初中有人努力、也有人不努力；初中时都挺聪明，在班里都名列前茅；初中时上奥赛几乎等于颓废，因为没多少人真正地在做题…… 可惜时光不容许保留原来的模样。 主任盯得紧，教练怂主任从而也盯得紧；大多数人都因为外力的因素必须要努力，但也有根本不想努力的人；以前可以骄傲的资本、譬如文化课，现在早就变成了一纸空谈——作为所谓“奥赛负责人”的我，看到来到实验部第一次的月考成绩时，看到级部前二十（这一级实验部一共$116$个人）充斥着数学物理化学生物奥赛的人、却又跟信息学奥赛没有任何关系时，我不知道该怎么做。 于是我便开始加大压力：组织学生定期讲课、定期比赛。用这种空泛的压榨时间的行为来压榨效率无疑是可笑的，但是也起了一部分好的效果：几个$NOIp$内容都没会熟练的家伙开始跃跃欲试地学习$Splay$、学习网络流……我不知道这样做是否真的好，就如同我不知道我学习新东西是否会在十月、甚至十一月之前压垮所有人的神经——学完新东西、反过头来发现基础却根本不牢固——就如同为了学新知识，而去学新知识。这种功利让我不知道现在在走着一条怎样的路。 终于，差距出来了。经过几个月训练、实力强劲的人自然涌了上来，也有根本不行的人光辉逐渐黯淡。二月时的能力局面现在早就会焕然一新，有人选择走，有人选择苟活。我不清楚原来那些充满骄傲的、惬意的脸庞如今去了哪里，我只知道我给他们定的目标是今年全部省一、我只知道来到实验部之后，只能选择负重前行。 看着机房里其他人的变化，就宛如翻完了一部小说一般，跌宕而符合逻辑。 告别了初中，留下了什么呢？或许是由于自身意气用事而破坏了原本纯洁的友情，但是我不能——真的不能仅仅把$Ta$当作一个不世出的好朋友。但当我跨越了自身的那一步之后才发现原来无人等候，才发现我只能把一些事情抛撒在风里，然后安慰自己“没事”。 我喜欢李宗盛，喜欢他的歌里面唱出的人间无奈。而最喜欢的是他的《山丘》: 给自己随便找了个理由， 向情爱的挑逗，命运的左右。 不自量力地还手，直至死方休—— 越过山丘——虽然已白了头； 喋喋不休——时不我予的哀愁； 还未如愿见着不朽 就把自己先搞丢—— 越过山丘——才发现无人等候； 喋喋不休——再也唤不回了温柔； 为何记不得上一次是谁给的拥抱 在什么时候。 大概是能唱出柳永“杨柳岸晓风残月”几分意味的吧。 $2018/8/4​$]]></content>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
</search>
